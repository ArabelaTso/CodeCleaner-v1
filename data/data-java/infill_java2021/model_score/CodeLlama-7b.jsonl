{"hexsha": "b08a80f53c729d0b170df6c3806811715adb16ff", "ext": "java", "lang": "Java", "content": "public class BitstreamReader extends AbstractReader implements Recyclable\n{\n    private static Logger log = Logger.getLogger(BitstreamReader.class);\n        \n    /**\n     * Messages to be sent when the user is not authorized to view\n     * a particular bitstream. They will be redirected to the login\n     * where this message will be displayed.\n     */\n    private static final String AUTH_REQUIRED_HEADER = \"xmlui.BitstreamReader.auth_header\";\n    private static final String AUTH_REQUIRED_MESSAGE = \"xmlui.BitstreamReader.auth_message\";\n        \n    /**\n     * How big a buffer should we use when reading from the bitstream before\n     * writing to the HTTP response?\n     */\n    protected static final int BUFFER_SIZE = 8192;\n\n    /**\n     * When should a bitstream expire in milliseconds. This should be set to\n     * some low value just to prevent someone hiting DSpace repeatedy from\n     * killing the server. Note: there are 1000 milliseconds in a second.\n     *\n     * Format: minutes * seconds * milliseconds\n     *  60 * 60 * 1000 == 1 hour\n     */\n    protected static final int expires = 60 * 60 * 1000;\n\n    /** The Cocoon response */\n    protected Response response;\n\n    /** The Cocoon request */\n    protected Request request;\n\n    /** The bitstream file */\n    protected InputStream bitstreamInputStream;\n    \n    /** The bitstream's reported size */\n    protected long bitstreamSize;\n    \n    /** The bitstream's mime-type */\n    protected String bitstreamMimeType;\n    \n    /** The bitstream's name */\n    protected String bitstreamName;\n    \n    /** True if bitstream is readable by anonymous users */\n    protected boolean isAnonymouslyReadable;\n\n    /** The last modified date of the item containing the bitstream */\n    private Date itemLastModified = null;\n\n    /** True if user agent making this request was identified as spider. */\n    private boolean isSpider = false;\n\n    /** TEMP file for citation PDF. We will save here, so we can delete the temp file when done.  */\n    private File tempFile;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();\n\n\n    /**\n     * Set up the bitstream reader.\n     *\n     * See the class description for information on configuration options.\n     * @param resolver source resolver.\n     * @param objectModel Cocoon object model.\n     * @param src source to read.\n     * @param par Reader parameters.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    public void setup(SourceResolver resolver, Map objectModel, String src,\n            Parameters par)\n            throws ProcessingException, SAXException, IOException\n    {\n        super.setup(resolver, objectModel, src, par);\n\n        try\n        {\n            this.request = ObjectModelHelper.getRequest(objectModel);\n            this.response = ObjectModelHelper.getResponse(objectModel);\n\n            Item item = null;\n\n            // Check to see if a context already exists or not. We may\n            // have been aggregated into an http request by the XSL document\n            // pulling in an XML-based bitstream. In this case the context has\n            // already been created and we should leave it open because the\n            // normal processes will close it.\n            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);\n            Context context = ContextUtil.obtainContext(objectModel);\n            \n            // Get our parameters that identify the bitstream\n            String itemID = par.getParameter(\"itemID\", null);\n            String bitstreamID = par.getParameter(\"bitstreamID\", null);\n            String handle = par.getParameter(\"handle\", null);\n            \n            int sequence = par.getParameterAsInteger(\"sequence\", -1);\n            String name = par.getParameter(\"name\", null);\n        \n            this.isSpider = par.getParameter(\"userAgent\", \"\").equals(\"spider\");\n\n            // Resolve the bitstream\n            Bitstream bitstream = null;\n            DSpaceObject dso = null;\n            \n            if (bitstreamID != null)\n            {\n                // Direct reference to the individual bitstream ID.\n                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);\n            }\n            else if (itemID != null)\n            {\n                // Referenced by internal itemID\n                item = itemService.findByIdOrLegacyId(context, itemID);\n                \n                if (sequence > -1)\n                {\n                        bitstream = findBitstreamBySequence(item, sequence);\n                }\n                else if (name != null)\n                {\n                        bitstream = findBitstreamByName(item, name);\n                }\n            }\n            else if (handle != null)\n            {\n                // Reference by an item's handle.\n                dso = handleService.resolveToObject(context, handle);\n\n                if (dso instanceof Item)\n                {\n                    item = (Item)dso;\n\n                    if (sequence > -1)\n                    {\n                        bitstream = findBitstreamBySequence(item,sequence);\n                    }\n                    else if (name != null)\n                    {\n                        bitstream = findBitstreamByName(item,name);\n                    }\n                }\n            }\n\n            if (item != null) {\n                itemLastModified = item.getLastModified();\n            }\n\n            // if initial search was by sequence number and found nothing,\n            // then try to find bitstream by name (assuming we have a file name)\n            if((sequence > -1 && bitstream==null) && name!=null)\n            {\n                bitstream = findBitstreamByName(item,name);\n\n                // if we found bitstream by name, send a redirect to its new sequence number location\n                if(bitstream!=null)\n                {\n                    String redirectURL = \"\";\n\n                    // build redirect URL based on whether item has a handle assigned yet\n                    if(item.getHandle()!=null && item.getHandle().length()>0)\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/handle/\" + item.getHandle();\n                    }\n                    else\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/item/\" + item.getID();\n                    }\n\n                        redirectURL += \"/\" + name + \"?sequence=\" + bitstream.getSequenceID();\n\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redirectURL);\n                        return;\n                }\n            }\n\n            // Was a bitstream found?\n            if (bitstream == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate bitstream\");\n            }\n\n            // Is there a User logged in and does the user have access to read it?\n            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);\n            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context))\n            {\n                isAuthorized = false;\n                log.info(LogManager.getHeader(context, \"view_bitstream\", \"handle=\" + item.getHandle() + \",withdrawn=true\"));\n            }\n            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request  \n            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\");\n            if (!isAuthorized)\n            {\n                if(context.getCurrentUser() != null || StringUtils.equalsIgnoreCase(\"all\", requestItemType)){\n                        // A user is logged in, but they are not authorized to read this bitstream,\n                        // instead of asking them to login again we'll point them to a friendly error\n                        // message that tells them the bitstream is restricted.\n                        String redictURL = request.getContextPath() + \"/handle/\";\n                        if (item!=null){\n                                redictURL += item.getHandle();\n                        }\n                        else if(dso!=null){\n                                redictURL += dso.getHandle();\n                        }\n                        redictURL += \"/restricted-resource?bitstreamId=\" + bitstream.getID();\n\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                }\n                else{\n                \tif(StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\")) ||\n                \t\t\t                \t\t\tDSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\").equalsIgnoreCase(\"logged\")){\n                        // The user does not have read access to this bitstream. Interrupt this current request\n                        // and then forward them to the login page so that they can be authenticated. Once that is\n                        // successful, their request will be resumed.\n                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);\n\n                        // Redirect\n                        String redictURL = request.getContextPath() + \"/login\";\n\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                \t}\n                }\n            }\n\n            // Success, bitstream found and the user has access to read it.\n            // Store these for later retrieval:\n\n            // Intercepting views to the original bitstream to instead show a citation altered version of the object\n            // We need to check if this resource falls under the \"show watermarked alternative\" umbrella.\n            // At which time we will not return the \"bitstream\", but will instead on-the-fly generate the citation rendition.\n\n            // What will trigger a redirect/intercept?\n            // 1) Intercepting Enabled\n            // 2) This User is not an admin\n            // 3) This object is citation-able\n            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {\n                // on-the-fly citation generator\n                log.info(item.getHandle() + \" - \" + bitstream.getName() + \" is citable.\");\n\n                FileInputStream fileInputStream = null;\n\n                try {\n                    //Create the cited document\n                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);\n                    if(tempFile == null) {\n                        log.error(\"CitedDocument was null\");\n                    } else {\n                        log.info(\"CitedDocument was ok,\" + tempFile.getAbsolutePath());\n                    }\n\n\n                    fileInputStream = new FileInputStream(tempFile);\n                    if(fileInputStream == null) {\n                        log.error(\"Error opening fileInputStream: \");\n                    }\n\n                    this.bitstreamInputStream = fileInputStream;\n                    this.bitstreamSize = tempFile.length();\n\n                } catch (Exception e) {\n                    log.error(\"Caught an error with intercepting the citation document:\" + e.getMessage());\n                }\n\n                //End of CitationDocument\n            } else {\n                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);\n                this.bitstreamSize = bitstream.getSize();\n            }\n\n            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();\n            this.bitstreamName = bitstream.getName();\n            if (context.getCurrentUser() == null)\n            {\n                this.isAnonymouslyReadable = true;\n            }\n            else\n            {\n                this.isAnonymouslyReadable = false;\n                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ))\n                {\n                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS))\n                    {\n                        this.isAnonymouslyReadable = true;\n                    }\n                }\n            }\n\n            // Trim any path information from the bitstream\n            if (bitstreamName != null && bitstreamName.length() >0 )\n            {\n                        int finalSlashIndex = bitstreamName.lastIndexOf('/');\n                        if (finalSlashIndex > 0)\n                        {\n                                bitstreamName = bitstreamName.substring(finalSlashIndex+1);\n                        }\n            }\n            else\n            {\n                // In-case there is no bitstream name...\n                if(name != null && name.length() > 0) {\n                    bitstreamName = name;\n                    if(name.endsWith(\".jpg\")) {\n                        bitstreamMimeType = \"image/jpeg\";\n                    } else if(name.endsWith(\".png\")) {\n                        bitstreamMimeType = \"image/png\";\n                    }\n                } else {\n                    bitstreamName = \"bitstream\";\n                }\n            }\n            \n            // Log that the bitstream has been viewed, this is non-cached and the complexity\n            // of adding it to the sitemap for every possible bitstream uri is not very tractable\n            DSpaceServicesFactory.getInstance().getEventService().fireEvent(\n                                new UsageEvent(\n                                                UsageEvent.Action.VIEW,\n                                                ObjectModelHelper.getRequest(objectModel),\n                                                ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),\n                                                bitstream));\n            \n            // If we created the database connection close it, otherwise leave it open.\n            if (BitstreamReaderOpenedContext)\n            \tcontext.complete();\n        }\n        catch (SQLException sqle)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",sqle);\n        }\n        catch (AuthorizeException ae)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",ae);\n        }\n    }\n\n    \n    \n    \n    \n    /**\n     * Find the bitstream identified by a sequence number on this item.\n     *\n     * @param item A DSpace item\n     * @param sequence The sequence of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException\n    {\n        if (item == null)\n        {\n            return null;\n        }\n        \n        List<Bundle> bundles = item.getBundles();\n        for (Bundle bundle : bundles)\n        {\n            List<Bitstream> bitstreams = bundle.getBitstreams();\n\n            for (Bitstream bitstream : bitstreams)\n            {\n                if (bitstream.getSequenceID() == sequence)\n                {\n                    return bitstream;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Return the bitstream from the given item that is identified by the\n     * given name. If the name has prepended directories they will be removed\n     * one at a time until a bitstream is found. Note that if two bitstreams\n     * have the same name then the first bitstream will be returned.\n     *\n     * @param item A DSpace item\n     * @param name The name of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamByName(Item item, String name) throws SQLException\n    {\n        if (name == null || item == null)\n        {\n            return null;\n        }\n    \n        // Determine our the maximum number of directories that will be removed for a path.\n        int maxDepthPathSearch = 3;\n        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"xmlui.html.max-depth-guess\") != null)\n        {\n            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.html.max-depth-guess\");\n        }\n        \n        // Search for the named bitstream on this item. Each time through the loop\n        // a directory is removed from the name until either our maximum depth is\n        // reached or the bitstream is found. Note: an extra pass is added on to the\n        // loop for a last ditch effort where all directory paths will be removed.\n        for (int i = 0; i < maxDepthPathSearch+1; i++)\n        {\n                // Search through all the bitstreams and see\n                // if the name can be found\n                List<Bundle> bundles = item.getBundles();\n                for (Bundle bundle : bundles)\n                {\n                    List<Bitstream> bitstreams = bundle.getBitstreams();\n        \n                    for (Bitstream bitstream : bitstreams)\n                    {\n                        if (name.equals(bitstream.getName()))\n                        {\n                            return bitstream;\n                        }\n                    }\n                }\n                \n                // The bitstream was not found, so try removing a directory\n                // off of the name and see if we lost some path information.\n                int indexOfSlash = name.indexOf('/');\n                \n                if (indexOfSlash < 0)\n                {\n                    // No more directories to remove from the path, so return null for no\n                    // bitstream found.\n                    return null;\n                }\n               \n                name = name.substring(indexOfSlash+1);\n                \n                // If this is our next to last time through the loop then\n                // trim everything and only use the trailing filename.\n                if (i == maxDepthPathSearch-1)\n                {\n                        int indexOfLastSlash = name.lastIndexOf('/');\n                        if (indexOfLastSlash > -1)\n                        {\n                            name = name.substring(indexOfLastSlash + 1);\n                        }\n                }\n                \n        }\n        \n        // The named bitstream was not found and we exhausted the maximum path depth that\n        // we search.\n        return null;\n    }\n    \n    \n    /**\n         * Write the actual data out to the response.\n         *\n         * Some implementation notes:\n         *\n         * 1) We set a short expiration time just in the hopes of preventing someone\n         * from overloading the server by clicking reload a bunch of times. I\n         * Realize that this is nowhere near 100% effective but it may help in some\n         * cases and shouldn't hurt anything.\n         *\n         * 2) We accept partial downloads, thus if you lose a connection halfway\n         * through most web browser will enable you to resume downloading the\n         * bitstream.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n         */\n    @Override\n    public void generate() throws IOException, SAXException,\n            ProcessingException\n    {\n        if (this.bitstreamInputStream == null)\n        {\n            return;\n        }\n        \n        // Only allow If-Modified-Since protocol if request is from a spider\n        // since response headers would encourage a browser to cache results\n        // that might change with different authentication.\n        if (isSpider)\n        {\n            // Check for if-modified-since header -- ONLY if not authenticated\n            long modSince = request.getDateHeader(\"If-Modified-Since\");\n            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince)\n            {\n                // Item has not been modified since requested date,\n                // hence bitstream has not been, either; return 304\n                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n        }\n\n        // Only set Last-Modified: header for spiders or anonymous\n        // access, since it might encourage browse to cache the result\n        // which might leave a result only available to authenticated\n        // users in the cache for a response later to anonymous user.\n        try\n        {\n            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null))\n            {\n                // TODO:  Currently just borrow the date of the item, since\n                // we don't have last-mod dates for Bitstreams\n                response.setDateHeader(\"Last-Modified\", itemLastModified.getTime());\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new ProcessingException(e);\n        }\n\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int length = -1;\n\n        // Only encourage caching if this is not a restricted resource, i.e.\n        // if it is accessed anonymously or is readable by Anonymous:\n        if (isAnonymouslyReadable)\n        {\n            response.setDateHeader(\"Expires\", System.currentTimeMillis() + expires);\n        }\n        \n        // If this is a large bitstream then tell the browser it should treat it as a download.\n        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.content_disposition_threshold\");\n        if (bitstreamSize > threshold && threshold != 0)\n        {\n                String name  = bitstreamName;\n                \n                // Try and make the download file name formatted for each browser.\n                try {\n                        String agent = request.getHeader(\"USER-AGENT\");\n                        if (agent != null && agent.contains(\"MSIE\"))\n                        {\n                            name = URLEncoder.encode(name, \"UTF8\");\n                        }\n                        else if (agent != null && agent.contains(\"Mozilla\"))\n                        {\n                            name = MimeUtility.encodeText(name, \"UTF8\", \"B\");\n                        }\n                }\n                catch (UnsupportedEncodingException see)\n                {\n                        // do nothing\n                }\n                response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + '\"' + name + '\"');\n        }\n\n        ByteRange byteRange = null;\n\n        // Turn off partial downloads, they cause problems\n        // and are only rarely used. Specifically some windows pdf\n        // viewers are incapable of handling this request. You can\n        // uncomment the following lines to turn this feature back on.\n/*\n    response.setHeader(\"Accept-Ranges\", \"bytes\");\n        String ranges = request.getHeader(\"Range\");\n        if (ranges != null)\n        {\n            try\n            {\n                ranges = ranges.substring(ranges.indexOf('=') + 1);\n                byteRange = new ByteRange(ranges);\n            }\n            catch (NumberFormatException e)\n            {\n                byteRange = null;\n                if (response instanceof HttpResponse)\n                {\n                    // Respond with status 416 (Request range not\n                    // satisfiable)\n                    response.setStatus(416);\n                }\n            }\n        }*/\n\n        try\n        {\n            if (byteRange != null)\n            {\n                String entityLength;\n                String entityRange;\n\t\tByteRange requestedRange=null; //VT\n                if (this.bitstreamSize != -1)\n                {\n                    entityLength = \"\" + this.bitstreamSize;\n                   //VT entityRange = byteRange.intersection(\n                   //VT        new ByteRange(0, this.bitstreamSize)).toString();\n\t\t\trequestedRange = byteRange.intersection(\n                        new ByteRange(0, this.bitstreamSize - 1));\n                    \tentityRange = requestedRange.toString();\n                }\n                else\n                {\n                    entityLength = \"*\";\n                    entityRange = byteRange.toString();\n                }\n\n                response.setHeader(\"Content-Range\", entityRange + \"/\" + entityLength);\n                if (response instanceof HttpResponse)\n                {\n                    // Response with status 206 (Partial content)\n                    response.setStatus(206);\n                }\n\n                int pos = 0;\n                int posEnd;\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    posEnd = pos + length - 1;\n                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));\n                    if (intersection != null)\n                    {\n                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());\n                    }\n                    pos += length;\n                }\n            }\n            else\n            {\n                response.setHeader(\"Content-Length\", String.valueOf(this.bitstreamSize));\n\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    out.write(buffer, 0, length);\n                }\n                out.flush();\n            }\n        }\n        finally\n        {\n            try\n            {\n                // Close the bitstream input stream so that we don't leak a file descriptor\n                this.bitstreamInputStream.close();\n                \n                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html\n                out.close();\n            } \n            catch (IOException ioe)\n            {\n                // Closing the stream threw an IOException but do we want this to propagate up to Cocoon?\n                // No point since the user has already got the bitstream contents.\n                log.warn(\"Caught IO exception when closing a stream: \" + ioe.getMessage());\n            }\n        }\n\n    }\n\n    /**\n     * Returns the mime-type of the bitstream.\n     * @return the type.\n     */\n    @Override\n    public String getMimeType()\n    {\n        return this.bitstreamMimeType;\n    }\n    \n    /**\n         * Recycle\n         */\n    @Override\n    public void recycle() {\n        this.response = null;\n        this.request = null;\n        this.bitstreamInputStream = null;\n        this.bitstreamSize = 0;\n        this.bitstreamMimeType = null;\n        this.bitstreamName = null;\n        this.itemLastModified = null;\n        this.tempFile = null;\n        super.recycle();\n    }\n\n\n}", "class_id": 0, "repo": "sunakshitejwani/testOER", "file": "dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/BitstreamReader.java", "last_update_at": "2021-02-13T18:35:31+00:00", "question_id": "b08a80f53c729d0b170df6c3806811715adb16ff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BitstreamReader extends AbstractReader implements Recyclable\n{\n    private static Logger log = Logger.getLogger(BitstreamReader.class);\n    /**\n     * Messages to be sent when the user is not authorized to view\n     * a particular bitstream. They will be redirected to the login\n     * where this message will be displayed.\n     */\n    private static final String AUTH_REQUIRED_HEADER = \"xmlui.BitstreamReader.auth_header\";\n    private static final String AUTH_REQUIRED_MESSAGE = \"xmlui.BitstreamReader.auth_message\";\n    /**\n     * How big a buffer should we use when reading from the bitstream before\n     * writing to the HTTP response?\n     */\n    protected static final int BUFFER_SIZE = 8192;\n    /**\n     * When should a bitstream expire in milliseconds. This should be set to\n     * some low value just to prevent someone hiting DSpace repeatedy from\n     * killing the server. Note: there are 1000 milliseconds in a second.\n     *\n     * Format: minutes * seconds * milliseconds\n     *  60 * 60 * 1000 == 1 hour\n     */\n    protected static final int expires = 60 * 60 * 1000;\n    /** The Cocoon response */\n    protected Response response;\n    /** The Cocoon request */\n    protected Request request;\n    /** The bitstream file */\n    protected InputStream bitstreamInputStream;\n    /** The bitstream's reported size */\n    protected long bitstreamSize;\n    /** The bitstream's mime-type */\n    protected String bitstreamMimeType;\n    /** The bitstream's name */\n    protected String bitstreamName;\n    /** True if bitstream is readable by anonymous users */\n    protected boolean isAnonymouslyReadable;\n    /** The last modified date of the item containing the bitstream */\n    private Date itemLastModified = null;\n    /** True if user agent making this request was identified as spider. */\n    private boolean isSpider = false;\n    /** TEMP file for citation PDF. We will save here, so we can delete the temp file when done.  */\n    private File tempFile;\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();\n    /**\n     * Set up the bitstream reader.\n     *\n     * See the class description for information on configuration options.\n     * @param resolver source resolver.\n     * @param objectModel Cocoon object model.\n     * @param src source to read.\n     * @param par Reader parameters.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    public void setup(SourceResolver resolver, Map objectModel, String src,\n            Parameters par)\n            throws ProcessingException, SAXException, IOException\n    {\n        super.setup(resolver, objectModel, src, par);\n        try\n        {\n            this.request = ObjectModelHelper.getRequest(objectModel);\n            this.response = ObjectModelHelper.getResponse(objectModel);\n            Item item = null;\n            // Check to see if a context already exists or not. We may\n            // have been aggregated into an http request by the XSL document\n            // pulling in an XML-based bitstream. In this case the context has\n            // already been created and we should leave it open because the\n            // normal processes will close it.\n            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);\n            Context context = ContextUtil.obtainContext(objectModel);\n            // Get our parameters that identify the bitstream\n            String itemID = par.getParameter(\"itemID\", null);\n            String bitstreamID = par.getParameter(\"bitstreamID\", null);\n            String handle = par.getParameter(\"handle\", null);\n            int sequence = par.getParameterAsInteger(\"sequence\", -1);\n            String name = par.getParameter(\"name\", null);\n            this.isSpider = par.getParameter(\"userAgent\", \"\").equals(\"spider\");\n            // Resolve the bitstream\n            Bitstream bitstream = null;\n            DSpaceObject dso = null;\n            if (bitstreamID != null)\n            {\n                // Direct reference to the individual bitstream ID.\n                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);\n            }\n            else if (itemID != null)\n            {\n                // Referenced by internal itemID\n                item = itemService.findByIdOrLegacyId(context, itemID);\n                if (sequence > -1)\n                {\n                        bitstream = findBitstreamBySequence(item, sequence);\n                }\n                else if (name != null)\n                {\n                        bitstream = findBitstreamByName(item, name);\n                }\n            }\n            else if (handle != null)\n            {\n                // Reference by an item's handle.\n                dso = handleService.resolveToObject(context, handle);\n                if (dso instanceof Item)\n                {\n                    item = (Item)dso;\n                    if (sequence > -1)\n                    {\n                        bitstream = findBitstreamBySequence(item,sequence);\n                    }\n                    else if (name != null)\n                    {\n                        bitstream = findBitstreamByName(item,name);\n                    }\n                }\n            }\n            if (item != null) {\n                itemLastModified = item.getLastModified();\n            }\n            // if initial search was by sequence number and found nothing,\n            // then try to find bitstream by name (assuming we have a file name)\n            if((sequence > -1 && bitstream==null) && name!=null)\n            {\n                bitstream = findBitstreamByName(item,name);\n                // if we found bitstream by name, send a redirect to its new sequence number location\n                if(bitstream!=null)\n                {\n                    String redirectURL = \"\";\n                    // build redirect URL based on whether item has a handle assigned yet\n                    if(item.getHandle()!=null && item.getHandle().length()>0)\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/handle/\" + item.getHandle();\n                    }\n                    else\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/item/\" + item.getID();\n                    }\n                        redirectURL += \"/\" + name + \"?sequence=\" + bitstream.getSequenceID();\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redirectURL);\n                        return;\n                }\n            }\n            // Was a bitstream found?\n            if (bitstream == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate bitstream\");\n            }\n            // Is there a User logged in and does the user have access to read it?\n            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);\n            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context))\n            {\n                isAuthorized = false;\n                log.info(LogManager.getHeader(context, \"view_bitstream\", \"handle=\" + item.getHandle() + \",withdrawn=true\"));\n            }\n            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request  \n            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\");\n            if (!isAuthorized)\n            {\n                if(context.getCurrentUser() != null || StringUtils.equalsIgnoreCase(\"all\", requestItemType)){\n                        // A user is logged in, but they are not authorized to read this bitstream,\n                        // instead of asking them to login again we'll point them to a friendly error\n                        // message that tells them the bitstream is restricted.\n                        String redictURL = request.getContextPath() + \"/handle/\";\n                        if (item!=null){\n                                redictURL += item.getHandle();\n                        }\n                        else if(dso!=null){\n                                redictURL += dso.getHandle();\n                        }\n                        redictURL += \"/restricted-resource?bitstreamId=\" + bitstream.getID();\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                }\n                else{\n                \tif(StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\")) ||\n                \t\t\t                \t\t\tDSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\").equalsIgnoreCase(\"logged\")){\n                        // The user does not have read access to this bitstream. Interrupt this current request\n                        // and then forward them to the login page so that they can be authenticated. Once that is\n                        // successful, their request will be resumed.\n                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);\n                        // Redirect\n                        String redictURL = request.getContextPath() + \"/login\";\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                \t}\n                }\n            }\n            // Success, bitstream found and the user has access to read it.\n            // Store these for later retrieval:\n            // Intercepting views to the original bitstream to instead show a citation altered version of the object\n            // We need to check if this resource falls under the \"show watermarked alternative\" umbrella.\n            // At which time we will not return the \"bitstream\", but will instead on-the-fly generate the citation rendition.\n            // What will trigger a redirect/intercept?\n            // 1) Intercepting Enabled\n            // 2) This User is not an admin\n            // 3) This object is citation-able\n            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {\n                // on-the-fly citation generator\n                log.info(item.getHandle() + \" - \" + bitstream.getName() + \" is citable.\");\n                FileInputStream fileInputStream = null;\n                try {\n                    //Create the cited document\n                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);\n                    if(tempFile == null) {\n                        log.error(\"CitedDocument was null\");\n                    } else {\n                        log.info(\"CitedDocument was ok,\" + tempFile.getAbsolutePath());\n                    }\n                    fileInputStream = new FileInputStream(tempFile);\n                    if(fileInputStream == null) {\n                        log.error(\"Error opening fileInputStream: \");\n                    }\n                    this.bitstreamInputStream = fileInputStream;\n                    this.bitstreamSize = tempFile.length();\n                } catch (Exception e) {\n                    log.error(\"Caught an error with intercepting the citation document:\" + e.getMessage());\n                }\n                //End of CitationDocument\n            } else {\n                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);\n                this.bitstreamSize = bitstream.getSize();\n            }\n            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();\n            this.bitstreamName = bitstream.getName();\n            if (context.getCurrentUser() == null)\n            {\n                this.isAnonymouslyReadable = true;\n            }\n            else\n            {\n                this.isAnonymouslyReadable = false;\n                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ))\n                {\n                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS))\n                    {\n                        this.isAnonymouslyReadable = true;\n                    }\n                }\n            }\n            // Trim any path information from the bitstream\n            if (bitstreamName != null && bitstreamName.length() >0 )\n            {\n                        int finalSlashIndex = bitstreamName.lastIndexOf('/');\n                        if (finalSlashIndex > 0)\n                        {\n                                bitstreamName = bitstreamName.substring(finalSlashIndex+1);\n                        }\n            }\n            else\n            {\n                // In-case there is no bitstream name...\n                if(name != null && name.length() > 0) {\n                    bitstreamName = name;\n                    if(name.endsWith(\".jpg\")) {\n                        bitstreamMimeType = \"image/jpeg\";\n                    } else if(name.endsWith(\".png\")) {\n                        bitstreamMimeType = \"image/png\";\n                    }\n                } else {\n                    bitstreamName = \"bitstream\";\n                }\n            }\n            // Log that the bitstream has been viewed, this is non-cached and the complexity\n            // of adding it to the sitemap for every possible bitstream uri is not very tractable\n            DSpaceServicesFactory.getInstance().getEventService().fireEvent(\n                                new UsageEvent(\n                                                UsageEvent.Action.VIEW,\n                                                ObjectModelHelper.getRequest(objectModel),\n                                                ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),\n                                                bitstream));\n            // If we created the database connection close it, otherwise leave it open.\n            if (BitstreamReaderOpenedContext)\n            \tcontext.complete();\n        }\n        catch (SQLException sqle)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",sqle);\n        }\n        catch (AuthorizeException ae)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",ae);\n        }\n    }\n    /**\n     * Find the bitstream identified by a sequence number on this item.\n     *\n     * @param item A DSpace item\n     * @param sequence The sequence of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException\n    {\n        if (item == null)\n        {\n            return null;\n        }\n        List<Bundle> bundles = item.getBundles();\n        for (Bundle bundle : bundles)\n        {\n            List<Bitstream> bitstreams = bundle.getBitstreams();\n            for (Bitstream bitstream : bitstreams)\n            {\n                if (bitstream.getSequenceID() == sequence)\n                {\n                    return bitstream;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Return the bitstream from the given item that is identified by the\n     * given name. If the name has prepended directories they will be removed\n     * one at a time until a bitstream is found. Note that if two bitstreams\n     * have the same name then the first bitstream will be returned.\n     *\n     * @param item A DSpace item\n     * @param name The name of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamByName(Item item, String name) throws SQLException\n    {\n        if (name == null || item == null)\n        {\n            return null;\n        }\n        // Determine our the maximum number of directories that will be removed for a path.\n        int maxDepthPathSearch = 3;\n        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"xmlui.html.max-depth-guess\") != null)\n        {\n            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.html.max-depth-guess\");\n        }\n        // Search for the named bitstream on this item. Each time through the loop\n        // a directory is removed from the name until either our maximum depth is\n        // reached or the bitstream is found. Note: an extra pass is added on to the\n        // loop for a last ditch effort where all directory paths will be removed.\n        for (int i = 0; i < maxDepthPathSearch+1; i++)\n        {\n                // Search through all the bitstreams and see\n                // if the name can be found\n                List<Bundle> bundles = item.getBundles();\n                for (Bundle bundle : bundles)\n                {\n                    List<Bitstream> bitstreams = bundle.getBitstreams();\n                    for (Bitstream bitstream : bitstreams)\n                    {\n                        if (name.equals(bitstream.getName()))\n                        {\n                            return bitstream;\n                        }\n                    }\n                }\n                // The bitstream was not found, so try removing a directory\n                // off of the name and see if we lost some path information.\n                int indexOfSlash = name.indexOf('/');\n                if (indexOfSlash < 0)\n                {\n                    // No more directories to remove from the path, so return null for no\n                    // bitstream found.\n                    return null;\n                }\n                name = name.substring(indexOfSlash+1);\n                // If this is our next to last time through the loop then\n                // trim everything and only use the trailing filename.\n                if (i == maxDepthPathSearch-1)\n                {\n                        int indexOfLastSlash = name.lastIndexOf('/');\n                        if (indexOfLastSlash > -1)\n                        {\n                            name = name.substring(indexOfLastSlash + 1);\n                        }\n                }\n        }\n        // The named bitstream was not found and we exhausted the maximum path depth that\n        // we search.\n        return null;\n    }\n    /**\n         * Write the actual data out to the response.\n         *\n         * Some implementation notes:\n         *\n         * 1) We set a short expiration time just in the hopes of preventing someone\n         * from overloading the server by clicking reload a bunch of times. I\n         * Realize that this is nowhere near 100% effective but it may help in some\n         * cases and shouldn't hurt anything.\n         *\n         * 2) We accept partial downloads, thus if you lose a connection halfway\n         * through most web browser will enable you to resume downloading the\n         * bitstream.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n         */\n    @Override\n    public void generate() throws IOException, SAXException,\n            ProcessingException\n    {\n        if (this.bitstreamInputStream == null)\n        {\n            return;\n        }\n        // Only allow If-Modified-Since protocol if request is from a spider\n        // since response headers would encourage a browser to cache results\n        // that might change with different authentication.\n        if (isSpider)\n        {\n            // Check for if-modified-since header -- ONLY if not authenticated\n            long modSince = request.getDateHeader(\"If-Modified-Since\");\n            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince)\n            {\n                // Item has not been modified since requested date,\n                // hence bitstream has not been, either; return 304\n                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n        }\n        // Only set Last-Modified: header for spiders or anonymous\n        // access, since it might encourage browse to cache the result\n        // which might leave a result only available to authenticated\n        // users in the cache for a response later to anonymous user.\n        try\n        {\n            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null))\n            {\n                // TODO:  Currently just borrow the date of the item, since\n                // we don't have last-mod dates for Bitstreams\n                response.setDateHeader(\"Last-Modified\", itemLastModified.getTime());\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new ProcessingException(e);\n        }\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int length = -1;\n        // Only encourage caching if this is not a restricted resource, i.e.\n        // if it is accessed anonymously or is readable by Anonymous:\n        if (isAnonymouslyReadable)\n        {\n            response.setDateHeader(\"Expires\", System.currentTimeMillis() + expires);\n        }\n        // If this is a large bitstream then tell the browser it should treat it as a download.\n        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.content_disposition_threshold\");\n        if (bitstreamSize > threshold && threshold != 0)\n        {\n                String name  = bitstreamName;\n                // Try and make the download file name formatted for each browser.\n                try {\n                        String agent = request.getHeader(\"USER-AGENT\");\n                        if (agent != null && agent.contains(\"MSIE\"))\n                        {\n                            name = URLEncoder.encode(name, \"UTF8\");\n                        }\n                        else if (agent != null && agent.contains(\"Mozilla\"))\n                        {\n                            name = MimeUtility.encodeText(name, \"UTF8\", \"B\");\n                        }\n                }\n                catch (UnsupportedEncodingException see)\n                {\n                        // do nothing\n                }\n                response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + '\"' + name + '\"');\n        }\n        ByteRange byteRange = null;\n        // Turn off partial downloads, they cause problems\n        // and are only rarely used. Specifically some windows pdf\n        // viewers are incapable of handling this request. You can\n        // uncomment the following lines to turn this feature back on.\n/*\n    response.setHeader(\"Accept-Ranges\", \"bytes\");\n        String ranges = request.getHeader(\"Range\");\n        if (ranges != null)\n        {\n            try\n            {\n                ranges = ranges.substring(ranges.indexOf('=') + 1);\n                byteRange = new ByteRange(ranges);\n            }\n            catch (NumberFormatException e)\n            {\n                byteRange = null;\n                if (response instanceof HttpResponse)\n                {\n                    // Respond with status 416 (Request range not\n                    // satisfiable)\n                    response.setStatus(416);\n                }\n            }\n        }*/\n        try\n        {\n            if (byteRange != null)\n            {\n                String entityLength;\n                String entityRange;\n\t\tByteRange requestedRange=null; //VT\n                if (this.bitstreamSize != -1)\n                {\n                    entityLength = \"\" + this.bitstreamSize;\n                   //VT entityRange = byteRange.intersection(\n                   //VT        new ByteRange(0, this.bitstreamSize)).toString();\n\t\t\trequestedRange = byteRange.intersection(\n                        new ByteRange(0, this.bitstreamSize - 1));\n                    \tentityRange = requestedRange.toString();\n                }\n                else\n                {\n                    entityLength = \"*\";\n                    entityRange = byteRange.toString();\n                }\n                response.setHeader(\"Content-Range\", entityRange + \"/\" + entityLength);\n                if (response instanceof HttpResponse)\n                {\n                    // Response with status 206 (Partial content)\n                    response.setStatus(206);\n                }\n                int pos = 0;\n                int posEnd;\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    posEnd = pos + length - 1;\n                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));\n                    if (intersection != null)\n                    {\n                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());\n                    }\n                    pos += length;\n                }\n            }\n            else\n            {\n                response.setHeader(\"Content-Length\", String.valueOf(this.bitstreamSize));\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    out.write(buffer, 0, length);\n                }\n                out.flush();\n            }\n        }\n        finally\n        {\n            try\n            {\n                // Close the bitstream input stream so that we don't leak a file descriptor\n                this.bitstreamInputStream.close();\n                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html\n                out.close();\n            } \n            catch (IOException ioe)\n            {\n                // Closing the stream threw an IOException but do we want this to propagate up to Cocoon?\n                // No point since the user has already got the bitstream contents.\n                log.warn(\"Caught IO exception when closing a stream: \" + ioe.getMessage());\n            }\n        }\n    }\n    /**\n     * Returns the mime-type of the bitstream.\n     * @return the type.\n     */\n    @Override\n    public String getMimeType()\n    {\n        return this.bitstreamMimeType;\n    }\n    /**\n         * Recycle\n         */\n    @Override\n    public void recycle() {\n        this.response = null;\n        this.request = null;\n        this.bitstreamInputStream = null;\n        this.bitstreamSize = 0;\n        this.bitstreamMimeType = null;\n        this.bitstreamName = null;\n        this.itemLastModified = null;\n        this.tempFile = null;\n        super.recycle();\n    }\n"]], "pred": {"ppl": 2.7265570163726807, "ppl_lower": 3.086224317550659, "ppl/lowercase_ppl": -1.1235332953554633, "ppl/zlib": 0.00013991346730278845, "Min_5.0% Prob": 7.544320349599801, "Min_10.0% Prob": 5.888761253917918, "Min_20.0% Prob": 4.138871764435487, "Min_30.0% Prob": 3.116589266685099, "Min_40.0% Prob": 2.450803980704916, "Min_50.0% Prob": 1.9949980242844898, "Min_60.0% Prob": 1.6712533410875579}}
{"hexsha": "9070530deb7f6fef01876b2859a32446ef3c2a06", "ext": "java", "lang": "Java", "content": "@NativeTag\n@Execution(ExecutionMode.SAME_THREAD)\npublic class InfNanTests extends BaseNd4jTestWithBackends {\n\n\n    @BeforeEach\n    public void setUp() {\n       Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n               .checkForINF(true)\n               .checkForNAN(true)\n               .build());\n    }\n\n    @AfterEach\n    public void cleanUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf3(Nd4jBackend backend) {\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NaN);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForINF(true)\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NaN);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN3(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .checkForINF(true)\n                .checkForNAN(true)\n                .build());\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .build());\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n}", "class_id": 0, "repo": "showkawa/deeplearning4j", "file": "nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/profiling/InfNanTests.java", "last_update_at": "2021-09-01T06:59:10+00:00", "question_id": "9070530deb7f6fef01876b2859a32446ef3c2a06", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@NativeTag\n@Execution(ExecutionMode.SAME_THREAD)\npublic class InfNanTests extends BaseNd4jTestWithBackends {\n    @BeforeEach\n    public void setUp() {\n       Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n               .checkForINF(true)\n               .checkForNAN(true)\n               .build());\n    }\n    @AfterEach\n    public void cleanUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf3(Nd4jBackend backend) {\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForINF(true)\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN3(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .checkForINF(true)\n                .checkForNAN(true)\n                .build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n"]], "pred": {"ppl": 1.2327110767364502, "ppl_lower": 1.5130457878112793, "ppl/lowercase_ppl": -1.9794133912008567, "ppl/zlib": 0.0003910577033400607, "Min_5.0% Prob": 3.3540349146899056, "Min_10.0% Prob": 1.9673603518920786, "Min_20.0% Prob": 1.0372944914498459, "Min_30.0% Prob": 0.697436650913647, "Min_40.0% Prob": 0.52289494041588, "Min_50.0% Prob": 0.41874655196238164, "Min_60.0% Prob": 0.34912678061582436}}
{"hexsha": "0bdccbde2f8923091380e6547b9a7dcaa1198eba", "ext": "java", "lang": "Java", "content": "public class GooOverlayRenderer\n{\n    private static final String[] NUM_SUFFIXES = new String[]{\"\", \"k\", \"m\", \"b\", \"t\"};\n    private static final int MAX_LENGTH = 4;\n    private static final Minecraft CLIENT = Minecraft.getInstance();\n\n    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {\n        if (!stack.isEmpty() && stack.getAmount() != 1) {\n            String s = shortHandNumber(stack.getAmount());\n\n            if (stack.getAmount() < 1)\n                s = TextFormatting.RED + String.valueOf(stack.getAmount());\n\n            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);\n\n        }\n    }\n\n    private static String shortHandNumber(Number number) {\n        String shorthand = new DecimalFormat(\"##0E0\").format(number);\n        shorthand = shorthand.replaceAll(\"E[0-9]\", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);\n        while (shorthand.length() > MAX_LENGTH || shorthand.matches(\"[0-9]+\\\\.[a-z]\"))\n            shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);\n\n        return shorthand;\n    }\n\n    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {\n        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);\n\n        if (iconSprite == null)\n            return;\n\n        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());\n    }\n\n    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {\n        float f = 0.00390625F;\n        float f1 = 0.00390625F;\n        float zLevel = 0.0F;\n        Tessellator tessellator = Tessellator.getInstance();\n        BufferBuilder buffer = tessellator.getBuffer();\n        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);\n        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();\n        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();\n        tessellator.draw();\n    }\n}", "class_id": 0, "repo": "skyboy/Goo", "file": "src/main/java/com/xeno/goo/client/render/GooOverlayRenderer.java", "last_update_at": "2021-08-19T01:52:37+00:00", "question_id": "0bdccbde2f8923091380e6547b9a7dcaa1198eba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GooOverlayRenderer\n{\n    private static final String[] NUM_SUFFIXES = new String[]{\"\", \"k\", \"m\", \"b\", \"t\"};\n    private static final int MAX_LENGTH = 4;\n    private static final Minecraft CLIENT = Minecraft.getInstance();\n    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {\n        if (!stack.isEmpty() && stack.getAmount() != 1) {\n            String s = shortHandNumber(stack.getAmount());\n            if (stack.getAmount() < 1)\n                s = TextFormatting.RED + String.valueOf(stack.getAmount());\n            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);\n        }\n    }\n    private static String shortHandNumber(Number number) {\n        String shorthand = new DecimalFormat(\"##0E0\").format(number);\n        shorthand = shorthand.replaceAll(\"E[0-9]\", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);\n        while (shorthand.length() > MAX_LENGTH || shorthand.matches(\"[0-9]+\\\\.[a-z]\"))\n            shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);\n        return shorthand;\n    }\n    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {\n        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);\n        if (iconSprite == null)\n            return;\n        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());\n    }\n    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {\n        float f = 0.00390625F;\n        float f1 = 0.00390625F;\n        float zLevel = 0.0F;\n        Tessellator tessellator = Tessellator.getInstance();\n        BufferBuilder buffer = tessellator.getBuffer();\n        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);\n        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();\n        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();\n        tessellator.draw();\n    }\n"]], "pred": {"ppl": 1.6108189821243286, "ppl_lower": 1.8658945560455322, "ppl/lowercase_ppl": -1.3083379106942192, "ppl/zlib": 0.0005044896658301775, "Min_5.0% Prob": 5.4846452077229815, "Min_10.0% Prob": 3.8003396150611697, "Min_20.0% Prob": 2.269671944824196, "Min_30.0% Prob": 1.569385847208772, "Min_40.0% Prob": 1.1901859271301496, "Min_50.0% Prob": 0.9536146725237317, "Min_60.0% Prob": 0.7946925317970798}}
{"hexsha": "763fc82862a43e0b16eb8f74bb7a4c58704f0059", "ext": "java", "lang": "Java", "content": "public class MessageBindingsReader {\n\n    public MessageBindingsReader() {\n    }\n\n    public static MessageBindings readMessageBindings(final AnnotationScannerContext context,\n            final AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return null;\n        }\n\n        IoLogging.logger.annotationsArray(\"@MessageBindings\");\n        AnnotationInstance nested = annotationValue.asNested();\n\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));\n\n        return bindings;\n    }\n\n    public static MessageBindings readMessageBindings(final JsonNode node) {\n        if (node == null) {\n            return null;\n        }\n\n        IoLogging.logger.singleJsonNode(\"ChannelBindings\");\n\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));\n\n        return bindings;\n    }\n}", "class_id": 0, "repo": "openknowledge/smallrye-async-api", "file": "core/src/main/java/io/smallrye/asyncapi/core/runtime/io/bindings/MessageBindingsReader.java", "last_update_at": "2021-02-12T10:51:20+00:00", "question_id": "763fc82862a43e0b16eb8f74bb7a4c58704f0059", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageBindingsReader {\n    public MessageBindingsReader() {\n    }\n    public static MessageBindings readMessageBindings(final AnnotationScannerContext context,\n            final AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return null;\n        }\n        IoLogging.logger.annotationsArray(\"@MessageBindings\");\n        AnnotationInstance nested = annotationValue.asNested();\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n    public static MessageBindings readMessageBindings(final JsonNode node) {\n        if (node == null) {\n            return null;\n        }\n        IoLogging.logger.singleJsonNode(\"ChannelBindings\");\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n"]], "pred": {"ppl": 1.4112468957901, "ppl_lower": 1.8705132007598877, "ppl/lowercase_ppl": -1.817883184990664, "ppl/zlib": 0.0008611840921550649, "Min_5.0% Prob": 5.0304291890217705, "Min_10.0% Prob": 3.1465105200713537, "Min_20.0% Prob": 1.7080740939790957, "Min_30.0% Prob": 1.1499579775245479, "Min_40.0% Prob": 0.8630119799181473, "Min_50.0% Prob": 0.6900706673547328, "Min_60.0% Prob": 0.5747858839972383}}
{"hexsha": "4d76de705259e8969c3567afa2dc3811eff12574", "ext": "java", "lang": "Java", "content": "@Service\npublic class IssueServiceImpl implements IssueService {\n\n\n    private final IssueRepository issueRepository;\n    private final LabelRepository labelRepository;\n    private final UserRepository userRepository;\n    private final ModelMapper modelMapper;\n    private final FromIssueToIssueDTO fromIssueToIssueDTO;\n    private final FromIssueDTOToIssue fromIssueDTOToIssue;\n    private final FromLabelToLabelDTO fromLabelToLabelDTO;\n    private final FromLabelDTOToLabel fromLabelDTOToLabel;\n    private final FromUserToUserDTO fromUserToUserDTO;\n    private final FromUserDTOToUser fromUserDTOToUser;\n    private final CommentService commentService;\n    private final FromCommentDTOToComment fromCommentDTOtoComment;\n\n    private final StateRepository stateRepository;\n\n    private final static String ASCENDING=\"asc\" ;\n    private final static String DESCENDING=\"desc\" ;\n    private final static String ORDER_TYPE_ERROR_MESSAGE=\" Recieved OrderType is : %s .\\nOrder Type must be asc or desc.\";\n\n\n    @Autowired\n    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper,\n                            FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue,\n                            FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService,\n                            FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {\n\n        this.issueRepository = issueRepository;\n        this.labelRepository = labelRepository;\n        this.userRepository = userRepository;\n        this.modelMapper = modelMapper;\n        this.fromIssueToIssueDTO = fromIssueToIssueDTO;\n        this.fromIssueDTOToIssue = fromIssueDTOToIssue;\n        this.fromLabelToLabelDTO = fromLabelToLabelDTO;\n        this.fromLabelDTOToLabel = fromLabelDTOToLabel;\n        this.fromUserToUserDTO = fromUserToUserDTO;\n        this.fromUserDTOToUser = fromUserDTOToUser;\n        this.commentService = commentService;\n        this.fromCommentDTOtoComment = fromCommentDTOtoComment;\n        this.stateRepository = stateRepository;\n    }\n\n    @Override\n    public IssueDTO createIssue(IssueDTO idt) {\n        Issue issue = fromIssueDTOToIssue.convert(idt);\n        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));\n        return issueDto;\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssues() {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());\n        return issueDTOList;\n    }\n\n    @Override\n    public IssueDTO findById(Long issueId) {\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(\n                issueRepository.findById(issueId)\n                        .orElseThrow(NoSuchElementException::new));\n\n        return issueDTO;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByTitleKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByDescKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlIssuesByLabel(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));\n        return issueDTOList;\n    }\n\n    @Transactional\n    @Override\n    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));\n        issue.getComments().add(addedComment);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public void deleteComment(Long issueId,Long commentId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(()->new IssueTrackerNotFoundException(\"Issue\",issueId.toString()));\n        Optional<Comment> comment=issue.getComments().stream()\n                .filter(x->x.getId()==commentId)\n                .findFirst();\n        if(comment.isPresent()){\n            issue.getComments().remove(comment.get());\n        }else{\n            throw new IssueTrackerNotFoundException(\"Comment\",commentId.toString());\n        }\n        issueRepository.save(issue);\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());\n        }\n\n    }\n\n    @Override\n    public IssueDTO updateState(Long issueId, Long stateId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        State state = stateRepository.findById(stateId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"State\", stateId.toString()));\n        issue.setState(state);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());\n        }\n\n    }\n\n    public List<IssueDTO> getAllIssuesSort( String orderType, String byWhichSort) {\n       if (byWhichSort == null) {\n            return getAllIssues();\n        }\n\n        if (byWhichSort.equalsIgnoreCase(\"createDate\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByCreateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByCreateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else if (byWhichSort.equalsIgnoreCase(\"update\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByUpdateTime(true);\n\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByUpdateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n\n        } else {\n            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n        }\n    }\n    @Override\n    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {\n\n        labelRepository.removeLabelFromIssue(labelId, issueId);\n\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n\n\n\n    @Override\n    public IssueDTO addLabel(Long labelId,Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n\n       Label label = labelRepository.findById(labelId)\n                .orElseThrow(NoSuchElementException::new);\n\n        issue.getLabels().add(label);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO editIssue(Long issueId, IssueDTO issue) {\n        Issue updatedIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n\n        modelMapper.getConfiguration().setSkipNullEnabled(true);\n        modelMapper.map(issue, updatedIssue);\n\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));\n\n        return issueDTO;\n\n    }\n\n    @Override\n    public void deleteIssue(Long issueId) {\n        issueRepository.deleteById(issueId);\n    }\n\n\n    @Override\n    public void deleteSelectedIssues(List<Long> selectedIssueIds) {\n        for (Long id : selectedIssueIds) {\n            deleteIssue(id);\n        }\n    }\n\n    @Override\n    public IssueDTO addAssignee(Long userId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n\n        User user = userRepository.findById(userId)\n                .orElseThrow(NoSuchElementException::new);\n\n        issue.getAssignees().add(user);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {\n\n        userRepository.removeAssigneeFromIssue(userId, issueId);\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n}", "class_id": 0, "repo": "SuzanGencer/issue-tracker-2020-2", "file": "backend/issue-tracker/src/main/java/com/kodstar/issuetracker/service/impl/IssueServiceImpl.java", "last_update_at": "2021-04-06T13:05:56+00:00", "question_id": "4d76de705259e8969c3567afa2dc3811eff12574", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class IssueServiceImpl implements IssueService {\n    private final IssueRepository issueRepository;\n    private final LabelRepository labelRepository;\n    private final UserRepository userRepository;\n    private final ModelMapper modelMapper;\n    private final FromIssueToIssueDTO fromIssueToIssueDTO;\n    private final FromIssueDTOToIssue fromIssueDTOToIssue;\n    private final FromLabelToLabelDTO fromLabelToLabelDTO;\n    private final FromLabelDTOToLabel fromLabelDTOToLabel;\n    private final FromUserToUserDTO fromUserToUserDTO;\n    private final FromUserDTOToUser fromUserDTOToUser;\n    private final CommentService commentService;\n    private final FromCommentDTOToComment fromCommentDTOtoComment;\n    private final StateRepository stateRepository;\n    private final static String ASCENDING=\"asc\" ;\n    private final static String DESCENDING=\"desc\" ;\n    private final static String ORDER_TYPE_ERROR_MESSAGE=\" Recieved OrderType is : %s .\\nOrder Type must be asc or desc.\";\n    @Autowired\n    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper,\n                            FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue,\n                            FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService,\n                            FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {\n        this.issueRepository = issueRepository;\n        this.labelRepository = labelRepository;\n        this.userRepository = userRepository;\n        this.modelMapper = modelMapper;\n        this.fromIssueToIssueDTO = fromIssueToIssueDTO;\n        this.fromIssueDTOToIssue = fromIssueDTOToIssue;\n        this.fromLabelToLabelDTO = fromLabelToLabelDTO;\n        this.fromLabelDTOToLabel = fromLabelDTOToLabel;\n        this.fromUserToUserDTO = fromUserToUserDTO;\n        this.fromUserDTOToUser = fromUserDTOToUser;\n        this.commentService = commentService;\n        this.fromCommentDTOtoComment = fromCommentDTOtoComment;\n        this.stateRepository = stateRepository;\n    }\n    @Override\n    public IssueDTO createIssue(IssueDTO idt) {\n        Issue issue = fromIssueDTOToIssue.convert(idt);\n        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));\n        return issueDto;\n    }\n    @Override\n    public List<IssueDTO> getAllIssues() {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());\n        return issueDTOList;\n    }\n    @Override\n    public IssueDTO findById(Long issueId) {\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(\n                issueRepository.findById(issueId)\n                        .orElseThrow(NoSuchElementException::new));\n        return issueDTO;\n    }\n    @Override\n    public List<IssueDTO> findALlByTitleKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));\n        return issueDTOList;\n    }\n    @Override\n    public List<IssueDTO> findALlByDescKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));\n        return issueDTOList;\n    }\n    @Override\n    public List<IssueDTO> findALlIssuesByLabel(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));\n        return issueDTOList;\n    }\n    @Transactional\n    @Override\n    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));\n        issue.getComments().add(addedComment);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    @Override\n    public void deleteComment(Long issueId,Long commentId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(()->new IssueTrackerNotFoundException(\"Issue\",issueId.toString()));\n        Optional<Comment> comment=issue.getComments().stream()\n                .filter(x->x.getId()==commentId)\n                .findFirst();\n        if(comment.isPresent()){\n            issue.getComments().remove(comment.get());\n        }else{\n            throw new IssueTrackerNotFoundException(\"Comment\",commentId.toString());\n        }\n        issueRepository.save(issue);\n    }\n    @Override\n    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());\n        }\n    }\n    @Override\n    public IssueDTO updateState(Long issueId, Long stateId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        State state = stateRepository.findById(stateId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"State\", stateId.toString()));\n        issue.setState(state);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());\n        }\n    }\n    public List<IssueDTO> getAllIssuesSort( String orderType, String byWhichSort) {\n       if (byWhichSort == null) {\n            return getAllIssues();\n        }\n        if (byWhichSort.equalsIgnoreCase(\"createDate\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByCreateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByCreateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else if (byWhichSort.equalsIgnoreCase(\"update\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByUpdateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByUpdateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else {\n            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n        }\n    }\n    @Override\n    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {\n        labelRepository.removeLabelFromIssue(labelId, issueId);\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n    @Override\n    public IssueDTO addLabel(Long labelId,Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n       Label label = labelRepository.findById(labelId)\n                .orElseThrow(NoSuchElementException::new);\n        issue.getLabels().add(label);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    @Override\n    public IssueDTO editIssue(Long issueId, IssueDTO issue) {\n        Issue updatedIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        modelMapper.getConfiguration().setSkipNullEnabled(true);\n        modelMapper.map(issue, updatedIssue);\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));\n        return issueDTO;\n    }\n    @Override\n    public void deleteIssue(Long issueId) {\n        issueRepository.deleteById(issueId);\n    }\n    @Override\n    public void deleteSelectedIssues(List<Long> selectedIssueIds) {\n        for (Long id : selectedIssueIds) {\n            deleteIssue(id);\n        }\n    }\n    @Override\n    public IssueDTO addAssignee(Long userId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        User user = userRepository.findById(userId)\n                .orElseThrow(NoSuchElementException::new);\n        issue.getAssignees().add(user);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    @Override\n    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {\n        userRepository.removeAssigneeFromIssue(userId, issueId);\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n"]], "pred": {"ppl": 1.3842850923538208, "ppl_lower": 1.5299760103225708, "ppl/lowercase_ppl": -1.3077281823486018, "ppl/zlib": 0.0002014769687529461, "Min_5.0% Prob": 4.695848677672592, "Min_10.0% Prob": 2.8767139823997723, "Min_20.0% Prob": 1.595895140157903, "Min_30.0% Prob": 1.0803688358138102, "Min_40.0% Prob": 0.8117691071722246, "Min_50.0% Prob": 0.650592886267773, "Min_60.0% Prob": 0.5425807557248801}}
{"hexsha": "8443c954494c6c6baca7fbd14f3c738d5cd75922", "ext": "java", "lang": "Java", "content": "public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {\n\n    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)\n    private EventManager eventManager;\n\n    /**\n     * SubAppRuntimeManager Interface member variables.\n     */\n    List<FermatEventListener> listenersAdded = new ArrayList<>();\n\n    /**\n     * MAp of desktop identifier + runtimeDesktopObject\n     */\n\n    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();\n\n    /**\n     * Last desktop-object\n     */\n    String lastDesktopObject;\n\n    public DesktopRuntimeEnginePluginRoot() {\n        super(new PluginVersionReference(new Version()));\n    }\n\n\n    @Override\n    public void start() throws CantStartPluginException {\n        try {\n            /**\n             * I will initialize the handling of com.bitdubai.platform events.\n             */\n\n            /**\n             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add\n             * functionality based on wallets downloaded by users this wont be an option.\n             * * *\n             */\n            factoryReset();\n\n            this.serviceStatus = ServiceStatus.STARTED;\n        } catch (CantFactoryResetException ex) {\n            String message = CantStartPluginException.DEFAULT_MESSAGE;\n            FermatException cause = ex;\n            String context = \"App Runtime Start\";\n            String possibleReason = \"Some null definition\";\n            throw new CantStartPluginException(message, cause, context, possibleReason);\n        } catch (Exception exception) {\n            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, \"Unchecked Exception occurred, check the cause\");\n        }\n    }\n\n    @Override\n    public void stop() {\n        /**\n         * I will remove all the listeners registered with the event manager. \n         */\n        for (FermatEventListener eventListener : listenersAdded) {\n            eventManager.removeListener(eventListener);\n        }\n\n        listenersAdded.clear();\n\n        this.serviceStatus = ServiceStatus.STOPPED;\n\n    }\n\n    /**\n     * AppRuntime Interface implementation.\n     */\n    @Override\n    public DesktopObject getLastDesktopObject() {\n        if (lastDesktopObject != null) {\n            return lstDesktops.get(0);\n        }\n        return  null;\n        //return mapDesktops.get(startDesktopObject);\n    }\n\n    @Override\n    public DesktopObject getDesktopObject(String desktopObjectType) {\n        //DesktopObject desktopObject = mapDesktops.get(desktopObjectType);\n//        if (desktopObject != null) {\n//            lastDesktopObject = desktopObjectType;\n//            return desktopObject;\n//        }\n        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta\n        return null;\n    }\n\n    @Override\n    public List<DesktopObject> listDesktops() {\n        return lstDesktops;\n    }\n\n    /**\n     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the\n     * factory structure.\n     */\n    private void factoryReset() throws CantFactoryResetException {\n\n        //loadHomeScreen();\n\n        try {\n\n            RuntimeDesktopObject runtimeDesktopObject;// = new RuntimeDesktopObject();\n\n            Activity runtimeActivity; //= new Activity();\n            //runtimeActivity.setType(Activities.CWP_SHELL_LOGIN);\n            //runtimeSubApp.addActivity(runtimeActivity);\n\n            Fragment runtimeFragment; //= new Fragment();\n            //runtimeFragment.setType(Fragments.CWP_SHELL_LOGIN.getKey());\n            //runtimeActivity.addFragment(Fragments.CWP_SHELL_LOGIN.getKey(), runtimeFragment);\n\n            TitleBar runtimeTitleBar;\n            SideMenu runtimeSideMenu;\n            MainMenu runtimeMainMenu;\n            MenuItem runtimeMenuItem;\n            TabStrip runtimeTabStrip;\n            StatusBar statusBar;\n            Tab runtimeTab;\n\n            /**\n             * Desktop CCP\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCCP\");\n            lastDesktopObject = runtimeDesktopObject.getType();\n\n            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);\n\n            Activity activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CCPDHA\");\n            Fragment fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add WalletManager fragment\n             */\n\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CCPWMF\");\n            activity.addFragment(\"CCPWMF\",fragment);\n            runtimeDesktopObject.setStartActivity(activity.getType());\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n\n\n            lstDesktops.add(runtimeDesktopObject);\n            /**\n             * End Desktop CCP\n             */\n\n\n            /**\n             * Desktop WPD\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"WPD\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);\n\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"WPD\");\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n\n\n            /**\n             * End Desktop WPD\n             */\n\n\n            /**\n             * Desktop DAP\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DDAP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);\n\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"DAPDHA\");\n            fragment = new Fragment();\n\n            /**\n             * Add WalletManager fragment\n             */\n\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"DAPWMF\");\n            activity.addFragment(\"DAPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"DAPSAMF\");\n            activity.addFragment(\"DAPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * End Desktop DAP\n             */\n\n            /**\n             * Desktop CBP\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCBP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);\n\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CBPDHA\");\n            fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add WalletManager fragment\n             */\n\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CBPWMF\");\n            activity.addFragment(\"CBPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CBPSAMF\");\n            activity.addFragment(\"CBPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * End Desktop CBP\n             */\n\n\n        } catch (Exception e) {\n            String message = CantFactoryResetException.DEFAULT_MESSAGE;\n            FermatException cause = FermatException.wrapException(e);\n            String context = \"Error on method Factory Reset, setting the structure of the apps\";\n            String possibleReason = \"some null definition\";\n            throw new CantFactoryResetException(message, cause, context, possibleReason);\n\n        }\n\n    }\n\n\n\n}", "class_id": 0, "repo": "nattyco/fermatold", "file": "PIP/plugin/engine/fermat-pip-plugin-engine-desktop-runtime-bitdubai/src/main/java/com/bitdubai/fermat_pip_plugin/layer/engine/desktop_runtime/developer/bitdubai/version_1/DesktopRuntimeEnginePluginRoot.java", "last_update_at": "2021-08-15T20:32:35+00:00", "question_id": "8443c954494c6c6baca7fbd14f3c738d5cd75922", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {\n    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)\n    private EventManager eventManager;\n    /**\n     * SubAppRuntimeManager Interface member variables.\n     */\n    List<FermatEventListener> listenersAdded = new ArrayList<>();\n    /**\n     * MAp of desktop identifier + runtimeDesktopObject\n     */\n    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();\n    /**\n     * Last desktop-object\n     */\n    String lastDesktopObject;\n    public DesktopRuntimeEnginePluginRoot() {\n        super(new PluginVersionReference(new Version()));\n    }\n    @Override\n    public void start() throws CantStartPluginException {\n        try {\n            /**\n             * I will initialize the handling of com.bitdubai.platform events.\n             */\n            /**\n             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add\n             * functionality based on wallets downloaded by users this wont be an option.\n             * * *\n             */\n            factoryReset();\n            this.serviceStatus = ServiceStatus.STARTED;\n        } catch (CantFactoryResetException ex) {\n            String message = CantStartPluginException.DEFAULT_MESSAGE;\n            FermatException cause = ex;\n            String context = \"App Runtime Start\";\n            String possibleReason = \"Some null definition\";\n            throw new CantStartPluginException(message, cause, context, possibleReason);\n        } catch (Exception exception) {\n            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, \"Unchecked Exception occurred, check the cause\");\n        }\n    }\n    @Override\n    public void stop() {\n        /**\n         * I will remove all the listeners registered with the event manager. \n         */\n        for (FermatEventListener eventListener : listenersAdded) {\n            eventManager.removeListener(eventListener);\n        }\n        listenersAdded.clear();\n        this.serviceStatus = ServiceStatus.STOPPED;\n    }\n    /**\n     * AppRuntime Interface implementation.\n     */\n    @Override\n    public DesktopObject getLastDesktopObject() {\n        if (lastDesktopObject != null) {\n            return lstDesktops.get(0);\n        }\n        return  null;\n        //return mapDesktops.get(startDesktopObject);\n    }\n    @Override\n    public DesktopObject getDesktopObject(String desktopObjectType) {\n        //DesktopObject desktopObject = mapDesktops.get(desktopObjectType);\n//        if (desktopObject != null) {\n//            lastDesktopObject = desktopObjectType;\n//            return desktopObject;\n//        }\n        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta\n        return null;\n    }\n    @Override\n    public List<DesktopObject> listDesktops() {\n        return lstDesktops;\n    }\n    /**\n     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the\n     * factory structure.\n     */\n    private void factoryReset() throws CantFactoryResetException {\n        //loadHomeScreen();\n        try {\n            RuntimeDesktopObject runtimeDesktopObject;// = new RuntimeDesktopObject();\n            Activity runtimeActivity; //= new Activity();\n            //runtimeActivity.setType(Activities.CWP_SHELL_LOGIN);\n            //runtimeSubApp.addActivity(runtimeActivity);\n            Fragment runtimeFragment; //= new Fragment();\n            //runtimeFragment.setType(Fragments.CWP_SHELL_LOGIN.getKey());\n            //runtimeActivity.addFragment(Fragments.CWP_SHELL_LOGIN.getKey(), runtimeFragment);\n            TitleBar runtimeTitleBar;\n            SideMenu runtimeSideMenu;\n            MainMenu runtimeMainMenu;\n            MenuItem runtimeMenuItem;\n            TabStrip runtimeTabStrip;\n            StatusBar statusBar;\n            Tab runtimeTab;\n            /**\n             * Desktop CCP\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCCP\");\n            lastDesktopObject = runtimeDesktopObject.getType();\n            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);\n            Activity activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CCPDHA\");\n            Fragment fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add WalletManager fragment\n             */\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CCPWMF\");\n            activity.addFragment(\"CCPWMF\",fragment);\n            runtimeDesktopObject.setStartActivity(activity.getType());\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            lstDesktops.add(runtimeDesktopObject);\n            /**\n             * End Desktop CCP\n             */\n            /**\n             * Desktop WPD\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"WPD\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"WPD\");\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * End Desktop WPD\n             */\n            /**\n             * Desktop DAP\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DDAP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"DAPDHA\");\n            fragment = new Fragment();\n            /**\n             * Add WalletManager fragment\n             */\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"DAPWMF\");\n            activity.addFragment(\"DAPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"DAPSAMF\");\n            activity.addFragment(\"DAPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * End Desktop DAP\n             */\n            /**\n             * Desktop CBP\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCBP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CBPDHA\");\n            fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add WalletManager fragment\n             */\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CBPWMF\");\n            activity.addFragment(\"CBPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CBPSAMF\");\n            activity.addFragment(\"CBPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * End Desktop CBP\n             */\n        } catch (Exception e) {\n            String message = CantFactoryResetException.DEFAULT_MESSAGE;\n            FermatException cause = FermatException.wrapException(e);\n            String context = \"Error on method Factory Reset, setting the structure of the apps\";\n            String possibleReason = \"some null definition\";\n            throw new CantFactoryResetException(message, cause, context, possibleReason);\n        }\n    }\n"]], "pred": {"ppl": 2.439405679702759, "ppl_lower": 3.613039493560791, "ppl/lowercase_ppl": -1.4404743408928367, "ppl/zlib": 0.0004695915933353661, "Min_5.0% Prob": 7.697212107041302, "Min_10.0% Prob": 6.05131123346441, "Min_20.0% Prob": 3.9953274814521564, "Min_30.0% Prob": 2.8691724809556227, "Min_40.0% Prob": 2.20341257958657, "Min_50.0% Prob": 1.778626436961782, "Min_60.0% Prob": 1.486526828335194}}
{"hexsha": "a7adb9c2cd2745f6f8a868174542360456f4045b", "ext": "java", "lang": "Java", "content": "public class CPGManualTest extends CPGTestBase {\n\n    @Test\n    public void testGet() {\n\n        String location = given()\n                .post(baseUrlOfSut + \"/api/cpg/x\")\n                .then()\n                .statusCode(201)\n                .extract().header(\"location\");\n\n        int a = 42;\n        int b = 77;\n\n        location = resolveLocation(location, baseUrlOfSut + \"/api/cpg/x/{id}/y\");\n\n        given().contentType(ContentType.JSON)\n                .body(\"{\\\"a\\\":\" + a + \", \\\"b\\\":\" + b + \"}\")\n                .post(location)\n                .then()\n                .statusCode(201);\n\n        given().accept(ContentType.JSON)\n                .get(location)\n                .then()\n                .statusCode(200)\n                .body(\"a\", is(a))\n                .body(\"b\", is(b));\n    }\n}", "class_id": 0, "repo": "mitchellolsthoorn/ASE-Technical-2021-api-linkage-replication", "file": "EvoMaster/e2e-tests/spring-examples/src/test/java/org/evomaster/e2etests/spring/examples/chainedpostget/CPGManualTest.java", "last_update_at": "2021-07-15T12:44:15+00:00", "question_id": "a7adb9c2cd2745f6f8a868174542360456f4045b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CPGManualTest extends CPGTestBase {\n    @Test\n    public void testGet() {\n        String location = given()\n                .post(baseUrlOfSut + \"/api/cpg/x\")\n                .then()\n                .statusCode(201)\n                .extract().header(\"location\");\n        int a = 42;\n        int b = 77;\n        location = resolveLocation(location, baseUrlOfSut + \"/api/cpg/x/{id}/y\");\n        given().contentType(ContentType.JSON)\n                .body(\"{\\\"a\\\":\" + a + \", \\\"b\\\":\" + b + \"}\")\n                .post(location)\n                .then()\n                .statusCode(201);\n        given().accept(ContentType.JSON)\n                .get(location)\n                .then()\n                .statusCode(200)\n                .body(\"a\", is(a))\n                .body(\"b\", is(b));\n    }\n"]], "pred": {"ppl": 2.4666662216186523, "ppl_lower": 2.9464681148529053, "ppl/lowercase_ppl": -1.1968612965147707, "ppl/zlib": 0.0029124759068294434, "Min_5.0% Prob": 7.740142981211345, "Min_10.0% Prob": 5.7380789915720625, "Min_20.0% Prob": 3.895042878886064, "Min_30.0% Prob": 2.8542867799599967, "Min_40.0% Prob": 2.2181255782080678, "Min_50.0% Prob": 1.8002851715018926, "Min_60.0% Prob": 1.5097757417194801}}
{"hexsha": "16d5f6bd57d22f954e4f4bcebb596da796cc9164", "ext": "java", "lang": "Java", "content": "@UnitTest\npublic class MavenCodeLocationPackagerTest {\n    @Test\n    public void testParseProject() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        Dependency dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:0.0.1\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar\");\n        assertNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1:monkey\");\n        assertNull(dependency);\n    }\n\n    @Test\n    public void testParseDependency() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:0.0.1:compile\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1:test\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar\");\n        assertNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n    }\n\n    @Test\n    public void testIsLineRelevant() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465] stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]  stuff\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]     \"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" \"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloaded\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and thingsDownloaded stuff and things\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloading\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and things Downloadingstuff and things\"));\n    }\n\n    @Test\n    public void testTrimLogLevel() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        String actualLine = \"\";\n        final String expectedValue = \"thing\";\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"weird garbage 3525356 [thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\" [INFO] \" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n    }\n\n    @Test\n    public void testIsProjectSection() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\" \"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"       \"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:\"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:other      stuff\"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"maven-dependency-plugin:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin garbage:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"      ---       maven-dependency-plugin      :       tree\"));\n    }\n\n    @Test\n    public void testIsDependencyTreeUpdates() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"artifact com.google.guava:guava:jar:15.0:compile checking for updates from\"));\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"         artifact       com.google.guava:guava:         checking for updates\"));\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"      checking for updates   artifact       com.google.guava:guava:      \"));\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"checking for updates\"));\n\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"com.google.guava:guava:jar:15.0:compile\"));\n\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"+- com.google.guava:guava:jar:15.0:compile\"));\n\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"|  \\\\- com.google.guava:guava:jar:15.0:compile\"));\n    }\n\n    @Test\n    public void testIsGav() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertFalse(mavenCodeLocationPackager.isGav(\" \"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"       \"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"::::\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\" : : : : \"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact:version\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group-artifact:type-classifier-version:scope-garbage\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact::classifier:version: :garbage\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:version\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope:garbage\"));\n    }\n\n    @Test\n    public void testIndexOfEndOfSegments() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"\"));\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\"));\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\"));\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n\n        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\"));\n\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\"));\n\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"and\"));\n\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testDoesLineContainSegmentsInOrder() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"\"));\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\"));\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\"));\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"and\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testLineWithExtraTextAfterScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", dependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithUnknownScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", scopedDependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithBadColonPlacement() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from\", dependency.getExternalId().createExternalId());\n    }\n}", "class_id": 0, "repo": "antontroshin/synopsys-detect", "file": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/maven/unit/MavenCodeLocationPackagerTest.java", "last_update_at": "2021-01-08T16:56:35+00:00", "question_id": "16d5f6bd57d22f954e4f4bcebb596da796cc9164", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@UnitTest\npublic class MavenCodeLocationPackagerTest {\n    @Test\n    public void testParseProject() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        Dependency dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1:monkey\");\n        assertNull(dependency);\n    }\n    @Test\n    public void testParseDependency() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:0.0.1:compile\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1:test\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n    }\n    @Test\n    public void testIsLineRelevant() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465] stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]  stuff\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]     \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloaded\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and thingsDownloaded stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloading\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and things Downloadingstuff and things\"));\n    }\n    @Test\n    public void testTrimLogLevel() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        String actualLine = \"\";\n        final String expectedValue = \"thing\";\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"weird garbage 3525356 [thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\" [INFO] \" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n    }\n    @Test\n    public void testIsProjectSection() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\" \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:other      stuff\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin garbage:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"      ---       maven-dependency-plugin      :       tree\"));\n    }\n    @Test\n    public void testIsDependencyTreeUpdates() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"artifact com.google.guava:guava:jar:15.0:compile checking for updates from\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"         artifact       com.google.guava:guava:         checking for updates\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"      checking for updates   artifact       com.google.guava:guava:      \"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"checking for updates\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"+- com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"|  \\\\- com.google.guava:guava:jar:15.0:compile\"));\n    }\n    @Test\n    public void testIsGav() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isGav(\" \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"::::\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\" : : : : \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact:version\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group-artifact:type-classifier-version:scope-garbage\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact::classifier:version: :garbage\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope:garbage\"));\n    }\n    @Test\n    public void testIndexOfEndOfSegments() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\"));\n    }\n    @Test\n    public void testDoesLineContainSegmentsInOrder() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\"));\n    }\n    @Test\n    public void testLineWithExtraTextAfterScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", dependency.getExternalId().createExternalId());\n    }\n    @Test\n    public void testLineWithUnknownScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", scopedDependency.getExternalId().createExternalId());\n    }\n    @Test\n    public void testLineWithBadColonPlacement() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from\", dependency.getExternalId().createExternalId());\n    }\n"]], "pred": {"ppl": 1.6505987644195557, "ppl_lower": 1.7781414985656738, "ppl/lowercase_ppl": -1.1485231433833643, "ppl/zlib": 0.000396783934767806, "Min_5.0% Prob": 6.220027586993049, "Min_10.0% Prob": 4.264653188340804, "Min_20.0% Prob": 2.4375548020881763, "Min_30.0% Prob": 1.6642144543964879, "Min_40.0% Prob": 1.2512662304601743, "Min_50.0% Prob": 1.0027803848474788, "Min_60.0% Prob": 0.8361959589805171}}
{"hexsha": "236dd9c3e3386bd6a06a244e8ea1516692f3c35d", "ext": "java", "lang": "Java", "content": "public class PluginXMLTextHover extends PDETextHover {\n\n    private PDESourcePage fSourcePage;\n\n    public  PluginXMLTextHover(PDESourcePage sourcePage) {\n        fSourcePage = sourcePage;\n    }\n\n    @Override\n    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {\n        int offset = hoverRegion.getOffset();\n        IDocumentRange range = fSourcePage.getRangeElement(offset, true);\n        if (range instanceof IDocumentTextNode)\n            return checkTranslatedValue((IDocumentTextNode) range);\n        if (!(range instanceof IPluginObject))\n            return null;\n        ISchema schema = getExtensionSchema((IPluginObject) range);\n        if (schema != null) {\n            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);\n            if (sObj == null) {\n                return null;\n            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {\n                IDocumentAttributeNode da = (IDocumentAttributeNode) range;\n                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)\n                    // inside name\n                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);\n                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)\n                    // inside value\n                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);\n            } else if (range instanceof IPluginElement) {\n                IDocumentElementNode dn = (IDocumentElementNode) range;\n                int dnOff = dn.getOffset();\n                int dnLen = dn.getLength();\n                String dnName = dn.getXMLTagName();\n                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())\n                    // inside opening tag\n                    return getElementText((ISchemaElement) sObj);\n                try {\n                    String nt = textViewer.getDocument().get(dnOff, dnLen);\n                    if (nt.endsWith(//$NON-NLS-1$\n                    \"</\" + dnName + //$NON-NLS-1$\n                    '>')) {\n                        offset = offset - dnOff;\n                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)\n                            // inside closing tag\n                            return getElementText((ISchemaElement) sObj);\n                    }\n                } catch (BadLocationException e) {\n                }\n            }\n        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)\n            return getExtensionPointHoverInfo((IPluginObject) range, offset);\n        return null;\n    }\n\n    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {\n        IDocumentAttributeNode da = (IDocumentAttributeNode) object;\n        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {\n            String value = da.getAttributeValue();\n            if (//$NON-NLS-1$\n            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith(\"%\"))\n                return object.getResourceString(value);\n        }\n        return null;\n    }\n\n    private ISchema getExtensionSchema(IPluginObject object) {\n        IPluginObject extension = object;\n        if (object instanceof IDocumentAttributeNode)\n            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();\n        while (extension != null && !(extension instanceof IPluginExtension)) extension = extension.getParent();\n        if (extension == null)\n            // started off outside of an extension element\n            return null;\n        String point = ((IPluginExtension) extension).getPoint();\n        return PDECore.getDefault().getSchemaRegistry().getSchema(point);\n    }\n\n    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {\n        if (object instanceof IPluginElement)\n            return schema.findElement(((IPluginElement) object).getName());\n        if (object instanceof IPluginExtension)\n            //$NON-NLS-1$\n            return schema.findElement(\"extension\");\n        if (object instanceof IDocumentAttributeNode)\n            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());\n        return null;\n    }\n\n    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        return sAtt.getDescription();\n    }\n\n    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {\n        if (//$NON-NLS-1$\n        sEle.getName().equals(\"extension\") && attrib.getName().equals(IPluginExtension.P_POINT))\n            return getSchemaDescription(attrib, sEle);\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        String value = attrib.getValue();\n        if (//$NON-NLS-1$\n        sAtt.isTranslatable() && value.startsWith(\"%\"))\n            return attrib.getResourceString(value);\n        return null;\n    }\n\n    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {\n        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        if (description == null) {\n            URL url = sEle.getSchema().getURL();\n            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();\n            SchemaUtil.parseURL(url, handler);\n            description = handler.getDescription();\n            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        }\n        return description;\n    }\n\n    private String getElementText(ISchemaElement sEle) {\n        if (sEle == null) {\n            return null;\n        }\n        return sEle.getDescription();\n    }\n\n    private String checkTranslatedValue(IDocumentTextNode node) {\n        String value = node.getText();\n        if (//$NON-NLS-1$\n        value.startsWith(\"%\"))\n            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);\n        return null;\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.pde.ui/1463.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "236dd9c3e3386bd6a06a244e8ea1516692f3c35d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PluginXMLTextHover extends PDETextHover {\n    private PDESourcePage fSourcePage;\n    public  PluginXMLTextHover(PDESourcePage sourcePage) {\n        fSourcePage = sourcePage;\n    }\n    @Override\n    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {\n        int offset = hoverRegion.getOffset();\n        IDocumentRange range = fSourcePage.getRangeElement(offset, true);\n        if (range instanceof IDocumentTextNode)\n            return checkTranslatedValue((IDocumentTextNode) range);\n        if (!(range instanceof IPluginObject))\n            return null;\n        ISchema schema = getExtensionSchema((IPluginObject) range);\n        if (schema != null) {\n            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);\n            if (sObj == null) {\n                return null;\n            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {\n                IDocumentAttributeNode da = (IDocumentAttributeNode) range;\n                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)\n                    // inside name\n                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);\n                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)\n                    // inside value\n                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);\n            } else if (range instanceof IPluginElement) {\n                IDocumentElementNode dn = (IDocumentElementNode) range;\n                int dnOff = dn.getOffset();\n                int dnLen = dn.getLength();\n                String dnName = dn.getXMLTagName();\n                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())\n                    // inside opening tag\n                    return getElementText((ISchemaElement) sObj);\n                try {\n                    String nt = textViewer.getDocument().get(dnOff, dnLen);\n                    if (nt.endsWith(//$NON-NLS-1$\n                    \"</\" + dnName + //$NON-NLS-1$\n                    '>')) {\n                        offset = offset - dnOff;\n                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)\n                            // inside closing tag\n                            return getElementText((ISchemaElement) sObj);\n                    }\n                } catch (BadLocationException e) {\n                }\n            }\n        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)\n            return getExtensionPointHoverInfo((IPluginObject) range, offset);\n        return null;\n    }\n    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {\n        IDocumentAttributeNode da = (IDocumentAttributeNode) object;\n        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {\n            String value = da.getAttributeValue();\n            if (//$NON-NLS-1$\n            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith(\"%\"))\n                return object.getResourceString(value);\n        }\n        return null;\n    }\n    private ISchema getExtensionSchema(IPluginObject object) {\n        IPluginObject extension = object;\n        if (object instanceof IDocumentAttributeNode)\n            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();\n        while (extension != null && !(extension instanceof IPluginExtension)) extension = extension.getParent();\n        if (extension == null)\n            // started off outside of an extension element\n            return null;\n        String point = ((IPluginExtension) extension).getPoint();\n        return PDECore.getDefault().getSchemaRegistry().getSchema(point);\n    }\n    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {\n        if (object instanceof IPluginElement)\n            return schema.findElement(((IPluginElement) object).getName());\n        if (object instanceof IPluginExtension)\n            //$NON-NLS-1$\n            return schema.findElement(\"extension\");\n        if (object instanceof IDocumentAttributeNode)\n            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());\n        return null;\n    }\n    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        return sAtt.getDescription();\n    }\n    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {\n        if (//$NON-NLS-1$\n        sEle.getName().equals(\"extension\") && attrib.getName().equals(IPluginExtension.P_POINT))\n            return getSchemaDescription(attrib, sEle);\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        String value = attrib.getValue();\n        if (//$NON-NLS-1$\n        sAtt.isTranslatable() && value.startsWith(\"%\"))\n            return attrib.getResourceString(value);\n        return null;\n    }\n    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {\n        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        if (description == null) {\n            URL url = sEle.getSchema().getURL();\n            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();\n            SchemaUtil.parseURL(url, handler);\n            description = handler.getDescription();\n            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        }\n        return description;\n    }\n    private String getElementText(ISchemaElement sEle) {\n        if (sEle == null) {\n            return null;\n        }\n        return sEle.getDescription();\n    }\n    private String checkTranslatedValue(IDocumentTextNode node) {\n        String value = node.getText();\n        if (//$NON-NLS-1$\n        value.startsWith(\"%\"))\n            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);\n        return null;\n    }\n"]], "pred": {"ppl": 1.815529465675354, "ppl_lower": 2.256049633026123, "ppl/lowercase_ppl": -1.3642631093994606, "ppl/zlib": 0.000418510274948303, "Min_5.0% Prob": 5.677552054910099, "Min_10.0% Prob": 4.2013740048689, "Min_20.0% Prob": 2.683843380972451, "Min_30.0% Prob": 1.92593836881756, "Min_40.0% Prob": 1.4768231892024684, "Min_50.0% Prob": 1.1909594217792825, "Min_60.0% Prob": 0.9948776168057462}}
{"hexsha": "b5f71a5a6d3aac676e17055cfabf54d3d8029f71", "ext": "java", "lang": "Java", "content": "public class CylonGpioExample {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        System.out.println(\"<--Pi4J--> GPIO Cylon Example ... started.\");\n\n        // create gpio controller\n        final GpioController gpio = GpioFactory.getInstance();\n\n        // provision gpio pin #01 as an output pin and turn on\n        final GpioPinDigitalOutput[] pins = {\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW)};\n        System.out.println(\"--> GPIO state should be: ON\");\n\n        // set shutdown options on all pins\n        gpio.setShutdownOptions(true, PinState.LOW, pins);\n\n        // infinite loop\n        while(true) {\n\n            for(int index = 0; index <= 6; index++) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n\n            for(int index = 6; index >= 0; index--) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n        }\n\n        // stop all GPIO activity/threads by shutting down the GPIO controller\n        // (this method will forcefully shutdown all GPIO monitoring threads and scheduled tasks)\n        // gpio.shutdown();   <--- implement this method call if you wish to terminate the Pi4J GPIO controller\n    }\n}", "class_id": 0, "repo": "funk-overload/funky_leds", "file": "pi4j-1.1/examples/CylonGpioExample.java", "last_update_at": "2021-01-13T03:25:14+00:00", "question_id": "b5f71a5a6d3aac676e17055cfabf54d3d8029f71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CylonGpioExample {\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"<--Pi4J--> GPIO Cylon Example ... started.\");\n        // create gpio controller\n        final GpioController gpio = GpioFactory.getInstance();\n        // provision gpio pin #01 as an output pin and turn on\n        final GpioPinDigitalOutput[] pins = {\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW)};\n        System.out.println(\"--> GPIO state should be: ON\");\n        // set shutdown options on all pins\n        gpio.setShutdownOptions(true, PinState.LOW, pins);\n        // infinite loop\n        while(true) {\n            for(int index = 0; index <= 6; index++) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n            for(int index = 6; index >= 0; index--) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n        }\n        // stop all GPIO activity/threads by shutting down the GPIO controller\n        // (this method will forcefully shutdown all GPIO monitoring threads and scheduled tasks)\n        // gpio.shutdown();   <--- implement this method call if you wish to terminate the Pi4J GPIO controller\n    }\n"]], "pred": {"ppl": 1.3868772983551025, "ppl_lower": 1.7615187168121338, "ppl/lowercase_ppl": -1.731136696234936, "ppl/zlib": 0.0005379188682927451, "Min_5.0% Prob": 4.914693057537079, "Min_10.0% Prob": 2.9459189845804583, "Min_20.0% Prob": 1.6174999634856764, "Min_30.0% Prob": 1.0892891207699142, "Min_40.0% Prob": 0.8186727461356718, "Min_50.0% Prob": 0.6550362835498044, "Min_60.0% Prob": 0.5456867729611755}}
{"hexsha": "f03acb955ac4cb27321bca392b2d1acefa0e597e", "ext": "java", "lang": "Java", "content": "public class PrivateUrlTest {\n\n    @Test\n    public void testProcessLine() throws Exception {\n        PropertiesFile propertiesFile = new PropertiesFile(\"resources/.application.properties\");\n        String accessKeyId = propertiesFile.getValue(\"ten-id\");\n        String accessKeySecret = propertiesFile.getValue(\"ten-secret\");\n        String bucket = propertiesFile.getValue(\"bucket\");\n        String region = \"ap-shanghai\";\n        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, \"~/Downloads\");\n        String result = privateUrl.singleResult(new HashMap<String, String>(){{\n            put(\"key\", \"24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg\");\n        }});\n        System.out.println(result);\n\n        List<Map<String, String>> mapList = new ArrayList<>();\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"1\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"2\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"3\"); }});\n        privateUrl.processLine(mapList);\n        privateUrl.closeResource();\n    }\n}", "class_id": 0, "repo": "NigelWu95/qiniu-suits", "file": "src/test/java/com/qiniu/process/tencent/PrivateUrlTest.java", "last_update_at": "2021-05-19T13:33:45+00:00", "question_id": "f03acb955ac4cb27321bca392b2d1acefa0e597e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PrivateUrlTest {\n    @Test\n    public void testProcessLine() throws Exception {\n        PropertiesFile propertiesFile = new PropertiesFile(\"resources/.application.properties\");\n        String accessKeyId = propertiesFile.getValue(\"ten-id\");\n        String accessKeySecret = propertiesFile.getValue(\"ten-secret\");\n        String bucket = propertiesFile.getValue(\"bucket\");\n        String region = \"ap-shanghai\";\n        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, \"~/Downloads\");\n        String result = privateUrl.singleResult(new HashMap<String, String>(){{\n            put(\"key\", \"24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg\");\n        }});\n        System.out.println(result);\n        List<Map<String, String>> mapList = new ArrayList<>();\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"1\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"2\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"3\"); }});\n        privateUrl.processLine(mapList);\n        privateUrl.closeResource();\n    }\n"]], "pred": {"ppl": 2.8200416564941406, "ppl_lower": 3.294935703277588, "ppl/lowercase_ppl": -1.1501179156047405, "ppl/zlib": 0.0023509107860484194, "Min_5.0% Prob": 7.235794812440872, "Min_10.0% Prob": 5.678922891616821, "Min_20.0% Prob": 4.1585385909447306, "Min_30.0% Prob": 3.2383787181912638, "Min_40.0% Prob": 2.5425634650328686, "Min_50.0% Prob": 2.062545519503878, "Min_60.0% Prob": 1.732623308782979}}
{"hexsha": "d1df0edd75da094a11db311dfe81daf5603081fa", "ext": "java", "lang": "Java", "content": "public class ViewCommand extends Command {\n\n    public static final String COMMAND_WORD = \"view\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD\n            + \": Displays the applicant details identified by the index number used in the displayed applicant list.\\n\"\n            + \"Parameters: INDEX (must be a positive integer) [T] (case sensitive)\\n\"\n            + \"Example: \" + COMMAND_WORD + \" 1 T\";\n\n\n    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = \"Displayed Applicant details: %1$s\";\n\n    private final Index targetIndex;\n    private final Boolean toggle;\n\n    /**\n     * User can view applicant details in Intern Watcher.\n     */\n    public ViewCommand(Index index, Boolean toggle) {\n        this.targetIndex = index;\n        this.toggle = toggle;\n    }\n\n    @Override\n    public CommandResult execute(Model model) throws CommandException {\n        requireNonNull(model);\n        List<Applicant> lastShownList = model.getFilteredApplicantList();\n\n        if (targetIndex != null) {\n            if (targetIndex.getZeroBased() >= lastShownList.size()) {\n                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);\n            }\n        }\n        if (toggle) {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, true);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        } else {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, false);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        }\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof ViewCommand // instanceof handles nulls\n                && targetIndex.equals(((ViewCommand) other).targetIndex)); // state check\n    }\n}", "class_id": 0, "repo": "jackgugz/tp", "file": "src/main/java/seedu/intern/logic/commands/ViewCommand.java", "last_update_at": "2021-11-11T13:50:27+00:00", "question_id": "d1df0edd75da094a11db311dfe81daf5603081fa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ViewCommand extends Command {\n    public static final String COMMAND_WORD = \"view\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD\n            + \": Displays the applicant details identified by the index number used in the displayed applicant list.\\n\"\n            + \"Parameters: INDEX (must be a positive integer) [T] (case sensitive)\\n\"\n            + \"Example: \" + COMMAND_WORD + \" 1 T\";\n    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = \"Displayed Applicant details: %1$s\";\n    private final Index targetIndex;\n    private final Boolean toggle;\n    /**\n     * User can view applicant details in Intern Watcher.\n     */\n    public ViewCommand(Index index, Boolean toggle) {\n        this.targetIndex = index;\n        this.toggle = toggle;\n    }\n    @Override\n    public CommandResult execute(Model model) throws CommandException {\n        requireNonNull(model);\n        List<Applicant> lastShownList = model.getFilteredApplicantList();\n        if (targetIndex != null) {\n            if (targetIndex.getZeroBased() >= lastShownList.size()) {\n                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);\n            }\n        }\n        if (toggle) {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, true);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        } else {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, false);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        }\n    }\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof ViewCommand // instanceof handles nulls\n                && targetIndex.equals(((ViewCommand) other).targetIndex)); // state check\n    }\n"]], "pred": {"ppl": 1.4162908792495728, "ppl_lower": 1.9326248168945312, "ppl/lowercase_ppl": -1.8931055117799813, "ppl/zlib": 0.0004485069553787662, "Min_5.0% Prob": 4.722384683017073, "Min_10.0% Prob": 2.981672754575466, "Min_20.0% Prob": 1.6823680957072769, "Min_30.0% Prob": 1.150043556124143, "Min_40.0% Prob": 0.8686862769376101, "Min_50.0% Prob": 0.6964733035913829, "Min_60.0% Prob": 0.5808627176932836}}
{"hexsha": "73f66a22b3c991c1a48893c0996622a8d2412519", "ext": "java", "lang": "Java", "content": "public class MiniMaxSum {\n\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n        Object[] numbers = Arrays.stream(stdin.nextLine().split(\" \"))\n                .map(Long::parseLong).toArray();\n        Arrays.sort(numbers);\n        long minSum = 0;\n        long maxSum = 0;\n        for(int i = 0; i < numbers.length - 1; i++) {\n            minSum += (long) numbers[i];\n            maxSum += (long) numbers[i + 1];\n        }\n\n        System.out.println(minSum + \" \" + maxSum);\n        stdin.close();\n    }\n}", "class_id": 0, "repo": "Alok255/hackerrank", "file": "practice/algorithms/implementation/mini-max_sum/MiniMaxSum.java", "last_update_at": "2021-09-04T00:14:38+00:00", "question_id": "73f66a22b3c991c1a48893c0996622a8d2412519", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MiniMaxSum {\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n        Object[] numbers = Arrays.stream(stdin.nextLine().split(\" \"))\n                .map(Long::parseLong).toArray();\n        Arrays.sort(numbers);\n        long minSum = 0;\n        long maxSum = 0;\n        for(int i = 0; i < numbers.length - 1; i++) {\n            minSum += (long) numbers[i];\n            maxSum += (long) numbers[i + 1];\n        }\n        System.out.println(minSum + \" \" + maxSum);\n        stdin.close();\n    }\n"]], "pred": {"ppl": 1.7333859205245972, "ppl_lower": 2.3481884002685547, "ppl/lowercase_ppl": -1.5518639051831746, "ppl/zlib": 0.0019233450182631177, "Min_5.0% Prob": 5.4593665599823, "Min_10.0% Prob": 3.9263883057762596, "Min_20.0% Prob": 2.4492712812764306, "Min_30.0% Prob": 1.767077131053576, "Min_40.0% Prob": 1.3568706764706544, "Min_50.0% Prob": 1.0914604903876104, "Min_60.0% Prob": 0.9190604771886554}}
{"hexsha": "f0df889c9a924965d5986a36b2a0cbf9e81b51b7", "ext": "java", "lang": "Java", "content": "public class Saml2IdentityProviderResponse {\n  @JsonProperty(\"issuer\")\n  private String issuer = null;\n\n  @JsonProperty(\"settings\")\n  private java.util.List<SettingResponse> settings = null;\n\n  @JsonProperty(\"certificates\")\n  private java.util.List<CertificateResponse> certificates = null;\n\n  @JsonProperty(\"attribute_mappings\")\n  private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;\n\n  /**\n   * issuer.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse issuer(String issuer) {\n    this.issuer = issuer;\n    return this;\n  }\n\n  /**\n   * Get issuer.\n   *\n   * @return issuer\n   */\n  @ApiModelProperty(value = \"\")\n  public String getIssuer() {\n    return issuer;\n  }\n\n  /** setIssuer. */\n  public void setIssuer(String issuer) {\n    this.issuer = issuer;\n  }\n\n  /**\n   * settings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n    return this;\n  }\n\n  /**\n   * addSettingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {\n    if (this.settings == null) {\n      this.settings = new java.util.ArrayList<>();\n    }\n    this.settings.add(settingsItem);\n    return this;\n  }\n\n  /**\n   * Get settings.\n   *\n   * @return settings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<SettingResponse> getSettings() {\n    return settings;\n  }\n\n  /** setSettings. */\n  public void setSettings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n  }\n\n  /**\n   * certificates.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse certificates(\n      java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n    return this;\n  }\n\n  /**\n   * addCertificatesItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {\n    if (this.certificates == null) {\n      this.certificates = new java.util.ArrayList<>();\n    }\n    this.certificates.add(certificatesItem);\n    return this;\n  }\n\n  /**\n   * Get certificates.\n   *\n   * @return certificates\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<CertificateResponse> getCertificates() {\n    return certificates;\n  }\n\n  /** setCertificates. */\n  public void setCertificates(java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n  }\n\n  /**\n   * attributeMappings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse attributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n    return this;\n  }\n\n  /**\n   * addAttributeMappingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addAttributeMappingsItem(\n      RequiredAttributeMappingResponse attributeMappingsItem) {\n    if (this.attributeMappings == null) {\n      this.attributeMappings = new java.util.ArrayList<>();\n    }\n    this.attributeMappings.add(attributeMappingsItem);\n    return this;\n  }\n\n  /**\n   * Get attributeMappings.\n   *\n   * @return attributeMappings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {\n    return attributeMappings;\n  }\n\n  /** setAttributeMappings. */\n  public void setAttributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n  }\n\n  /**\n   * Compares objects.\n   *\n   * @return true or false depending on comparison result.\n   */\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;\n    return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer)\n        && Objects.equals(this.settings, saml2IdentityProviderResponse.settings)\n        && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates)\n        && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);\n  }\n\n  /** Returns the HashCode. */\n  @Override\n  public int hashCode() {\n    return Objects.hash(issuer, settings, certificates, attributeMappings);\n  }\n\n  /** Converts the given object to string. */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Saml2IdentityProviderResponse {\\n\");\n\n    sb.append(\"    issuer: \").append(toIndentedString(issuer)).append(\"\\n\");\n    sb.append(\"    settings: \").append(toIndentedString(settings)).append(\"\\n\");\n    sb.append(\"    certificates: \").append(toIndentedString(certificates)).append(\"\\n\");\n    sb.append(\"    attributeMappings: \").append(toIndentedString(attributeMappings)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n}", "class_id": 0, "repo": "docusign/docusign-admin-java-client", "file": "src/main/java/com/docusign/admin/model/Saml2IdentityProviderResponse.java", "last_update_at": "2021-11-14T17:02:16+00:00", "question_id": "f0df889c9a924965d5986a36b2a0cbf9e81b51b7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Saml2IdentityProviderResponse {\n  @JsonProperty(\"issuer\")\n  private String issuer = null;\n  @JsonProperty(\"settings\")\n  private java.util.List<SettingResponse> settings = null;\n  @JsonProperty(\"certificates\")\n  private java.util.List<CertificateResponse> certificates = null;\n  @JsonProperty(\"attribute_mappings\")\n  private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;\n  /**\n   * issuer.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse issuer(String issuer) {\n    this.issuer = issuer;\n    return this;\n  }\n  /**\n   * Get issuer.\n   *\n   * @return issuer\n   */\n  @ApiModelProperty(value = \"\")\n  public String getIssuer() {\n    return issuer;\n  }\n  /** setIssuer. */\n  public void setIssuer(String issuer) {\n    this.issuer = issuer;\n  }\n  /**\n   * settings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n    return this;\n  }\n  /**\n   * addSettingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {\n    if (this.settings == null) {\n      this.settings = new java.util.ArrayList<>();\n    }\n    this.settings.add(settingsItem);\n    return this;\n  }\n  /**\n   * Get settings.\n   *\n   * @return settings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<SettingResponse> getSettings() {\n    return settings;\n  }\n  /** setSettings. */\n  public void setSettings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n  }\n  /**\n   * certificates.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse certificates(\n      java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n    return this;\n  }\n  /**\n   * addCertificatesItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {\n    if (this.certificates == null) {\n      this.certificates = new java.util.ArrayList<>();\n    }\n    this.certificates.add(certificatesItem);\n    return this;\n  }\n  /**\n   * Get certificates.\n   *\n   * @return certificates\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<CertificateResponse> getCertificates() {\n    return certificates;\n  }\n  /** setCertificates. */\n  public void setCertificates(java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n  }\n  /**\n   * attributeMappings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse attributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n    return this;\n  }\n  /**\n   * addAttributeMappingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addAttributeMappingsItem(\n      RequiredAttributeMappingResponse attributeMappingsItem) {\n    if (this.attributeMappings == null) {\n      this.attributeMappings = new java.util.ArrayList<>();\n    }\n    this.attributeMappings.add(attributeMappingsItem);\n    return this;\n  }\n  /**\n   * Get attributeMappings.\n   *\n   * @return attributeMappings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {\n    return attributeMappings;\n  }\n  /** setAttributeMappings. */\n  public void setAttributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n  }\n  /**\n   * Compares objects.\n   *\n   * @return true or false depending on comparison result.\n   */\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;\n    return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer)\n        && Objects.equals(this.settings, saml2IdentityProviderResponse.settings)\n        && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates)\n        && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);\n  }\n  /** Returns the HashCode. */\n  @Override\n  public int hashCode() {\n    return Objects.hash(issuer, settings, certificates, attributeMappings);\n  }\n  /** Converts the given object to string. */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Saml2IdentityProviderResponse {\\n\");\n    sb.append(\"    issuer: \").append(toIndentedString(issuer)).append(\"\\n\");\n    sb.append(\"    settings: \").append(toIndentedString(settings)).append(\"\\n\");\n    sb.append(\"    certificates: \").append(toIndentedString(certificates)).append(\"\\n\");\n    sb.append(\"    attributeMappings: \").append(toIndentedString(attributeMappings)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]], "pred": {"ppl": 1.124090552330017, "ppl_lower": 1.2657923698425293, "ppl/lowercase_ppl": -2.014957846732884, "ppl/zlib": 0.00011468069686048946, "Min_5.0% Prob": 2.3047482757007374, "Min_10.0% Prob": 1.1713234531492287, "Min_20.0% Prob": 0.5864691639553891, "Min_30.0% Prob": 0.3910372716133257, "Min_40.0% Prob": 0.29257204738235004, "Min_50.0% Prob": 0.23417530454984456, "Min_60.0% Prob": 0.1952108525373546}}
{"hexsha": "07f14f69f8dacb6b9a0eeb603908e41613cd4a6a", "ext": "java", "lang": "Java", "content": "public class RegistrationFactory implements FactoryBean<Registration> {\n    @Override\n    public Registration getObject() throws Exception {\n\n        User user = new UserFactory().getObject();\n        Activity activity = new ActivityFactory().getObject();\n\n        assert user != null;\n        assert activity != null;\n\n        return Registration.builder()\n                .registrationId(new RegistrationId(user.getId(), activity.getId()))\n                .user(user)\n                .activity(activity)\n                .build();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}", "class_id": 0, "repo": "olros/GIDD", "file": "backend/src/test/java/com/ntnu/gidd/factories/RegistrationFactory.java", "last_update_at": "2021-04-30T21:46:19+00:00", "question_id": "07f14f69f8dacb6b9a0eeb603908e41613cd4a6a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RegistrationFactory implements FactoryBean<Registration> {\n    @Override\n    public Registration getObject() throws Exception {\n        User user = new UserFactory().getObject();\n        Activity activity = new ActivityFactory().getObject();\n        assert user != null;\n        assert activity != null;\n        return Registration.builder()\n                .registrationId(new RegistrationId(user.getId(), activity.getId()))\n                .user(user)\n                .activity(activity)\n                .build();\n    }\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n"]], "pred": {"ppl": 1.8371402025222778, "ppl_lower": 2.2217648029327393, "ppl/lowercase_ppl": -1.312542826605414, "ppl/zlib": 0.0021644488426362796, "Min_5.0% Prob": 7.106614053249359, "Min_10.0% Prob": 5.01509215682745, "Min_20.0% Prob": 2.9052567807110874, "Min_30.0% Prob": 2.0092601585388183, "Min_40.0% Prob": 1.52362499213708, "Min_50.0% Prob": 1.219880999531597, "Min_60.0% Prob": 1.0163373528417237}}
{"hexsha": "be19510bbe554bc909260040d46c21ac6908f660", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\"})\npublic class LRExprParenParser extends Parser {\n\tstatic { RuntimeMetaData.checkVersion(\"4.9.2\", RuntimeMetaData.VERSION); }\n\n\tprotected static final DFA[] _decisionToDFA;\n\tprotected static final PredictionContextCache _sharedContextCache =\n\t\tnew PredictionContextCache();\n\tpublic static final int\n\t\tT__0=1, T__1=2, T__2=3, T__3=4, T__4=5, ID=6, INT=7, WS=8;\n\tpublic static final int\n\t\tRULE_stat = 0, RULE_expr = 1;\n\tprivate static String[] makeRuleNames() {\n\t\treturn new String[] {\n\t\t\t\"stat\", \"expr\"\n\t\t};\n\t}\n\tpublic static final String[] ruleNames = makeRuleNames();\n\n\tprivate static String[] makeLiteralNames() {\n\t\treturn new String[] {\n\t\t\tnull, \"';'\", \"'*'\", \"'+'\", \"'('\", \"')'\"\n\t\t};\n\t}\n\tprivate static final String[] _LITERAL_NAMES = makeLiteralNames();\n\tprivate static String[] makeSymbolicNames() {\n\t\treturn new String[] {\n\t\t\tnull, null, null, null, null, null, \"ID\", \"INT\", \"WS\"\n\t\t};\n\t}\n\tprivate static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();\n\tpublic static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);\n\n\t/**\n\t * @deprecated Use {@link #VOCABULARY} instead.\n\t */\n\t@Deprecated\n\tpublic static final String[] tokenNames;\n\tstatic {\n\t\ttokenNames = new String[_SYMBOLIC_NAMES.length];\n\t\tfor (int i = 0; i < tokenNames.length; i++) {\n\t\t\ttokenNames[i] = VOCABULARY.getLiteralName(i);\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = VOCABULARY.getSymbolicName(i);\n\t\t\t}\n\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = \"<INVALID>\";\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic String[] getTokenNames() {\n\t\treturn tokenNames;\n\t}\n\n\t@Override\n\n\tpublic Vocabulary getVocabulary() {\n\t\treturn VOCABULARY;\n\t}\n\n\t@Override\n\tpublic String getGrammarFileName() { return \"LRExprParen.g4\"; }\n\n\t@Override\n\tpublic String[] getRuleNames() { return ruleNames; }\n\n\t@Override\n\tpublic String getSerializedATN() { return _serializedATN; }\n\n\t@Override\n\tpublic ATN getATN() { return _ATN; }\n\n\tpublic LRExprParenParser(TokenStream input) {\n\t\tsuper(input);\n\t\t_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);\n\t}\n\n\tpublic static class StatContext extends ParserRuleContext {\n\t\tpublic ExprContext expr() {\n\t\t\treturn getRuleContext(ExprContext.class,0);\n\t\t}\n\t\tpublic TerminalNode EOF() { return getToken(LRExprParenParser.EOF, 0); }\n\t\tpublic StatContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_stat; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitStat(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\n\tpublic final StatContext stat() throws RecognitionException {\n\t\tStatContext _localctx = new StatContext(_ctx, getState());\n\t\tenterRule(_localctx, 0, RULE_stat);\n\t\ttry {\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(4);\n\t\t\texpr(0);\n\t\t\tsetState(5);\n\t\t\tmatch(T__0);\n\t\t\tsetState(6);\n\t\t\tmatch(EOF);\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\texitRule();\n\t\t}\n\t\treturn _localctx;\n\t}\n\n\tpublic static class ExprContext extends ParserRuleContext {\n\t\tpublic List<ExprContext> expr() {\n\t\t\treturn getRuleContexts(ExprContext.class);\n\t\t}\n\t\tpublic ExprContext expr(int i) {\n\t\t\treturn getRuleContext(ExprContext.class,i);\n\t\t}\n\t\tpublic TerminalNode INT() { return getToken(LRExprParenParser.INT, 0); }\n\t\tpublic TerminalNode ID() { return getToken(LRExprParenParser.ID, 0); }\n\t\tpublic ExprContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_expr; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitExpr(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\n\tpublic final ExprContext expr() throws RecognitionException {\n\t\treturn expr(0);\n\t}\n\n\tprivate ExprContext expr(int _p) throws RecognitionException {\n\t\tParserRuleContext _parentctx = _ctx;\n\t\tint _parentState = getState();\n\t\tExprContext _localctx = new ExprContext(_ctx, _parentState);\n\t\tExprContext _prevctx = _localctx;\n\t\tint _startState = 2;\n\t\tenterRecursionRule(_localctx, 2, RULE_expr, _p);\n\t\ttry {\n\t\t\tint _alt;\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(15);\n\t\t\t_errHandler.sync(this);\n\t\t\tswitch (_input.LA(1)) {\n\t\t\tcase T__3:\n\t\t\t\t{\n\t\t\t\tsetState(9);\n\t\t\t\tmatch(T__3);\n\t\t\t\tsetState(10);\n\t\t\t\texpr(0);\n\t\t\t\tsetState(11);\n\t\t\t\tmatch(T__4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\t{\n\t\t\t\tsetState(13);\n\t\t\t\tmatch(INT);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ID:\n\t\t\t\t{\n\t\t\t\tsetState(14);\n\t\t\t\tmatch(ID);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new NoViableAltException(this);\n\t\t\t}\n\t\t\t_ctx.stop = _input.LT(-1);\n\t\t\tsetState(25);\n\t\t\t_errHandler.sync(this);\n\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\twhile ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tif ( _alt==1 ) {\n\t\t\t\t\tif ( _parseListeners!=null ) triggerExitRuleEvent();\n\t\t\t\t\t_prevctx = _localctx;\n\t\t\t\t\t{\n\t\t\t\t\tsetState(23);\n\t\t\t\t\t_errHandler.sync(this);\n\t\t\t\t\tswitch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(17);\n\t\t\t\t\t\tif (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\t\t\t\t\t\tsetState(18);\n\t\t\t\t\t\tmatch(T__1);\n\t\t\t\t\t\tsetState(19);\n\t\t\t\t\t\texpr(6);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(20);\n\t\t\t\t\t\tif (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\t\t\t\t\t\tsetState(21);\n\t\t\t\t\t\tmatch(T__2);\n\t\t\t\t\t\tsetState(22);\n\t\t\t\t\t\texpr(5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tsetState(27);\n\t\t\t\t_errHandler.sync(this);\n\t\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\tunrollRecursionContexts(_parentctx);\n\t\t}\n\t\treturn _localctx;\n\t}\n\n\tpublic boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n\t\tswitch (ruleIndex) {\n\t\tcase 1:\n\t\t\treturn expr_sempred((ExprContext)_localctx, predIndex);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate boolean expr_sempred(ExprContext _localctx, int predIndex) {\n\t\tswitch (predIndex) {\n\t\tcase 0:\n\t\t\treturn precpred(_ctx, 5);\n\t\tcase 1:\n\t\t\treturn precpred(_ctx, 4);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static final String _serializedATN =\n\t\t\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3\\n\\37\\4\\2\\t\\2\\4\\3\"+\n\t\t\"\\t\\3\\3\\2\\3\\2\\3\\2\\3\\2\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3\\22\\n\\3\\3\\3\\3\\3\\3\"+\n\t\t\"\\3\\3\\3\\3\\3\\3\\3\\7\\3\\32\\n\\3\\f\\3\\16\\3\\35\\13\\3\\3\\3\\2\\3\\4\\4\\2\\4\\2\\2\\2 \\2\\6\"+\n\t\t\"\\3\\2\\2\\2\\4\\21\\3\\2\\2\\2\\6\\7\\5\\4\\3\\2\\7\\b\\7\\3\\2\\2\\b\\t\\7\\2\\2\\3\\t\\3\\3\\2\\2\\2\"+\n\t\t\"\\n\\13\\b\\3\\1\\2\\13\\f\\7\\6\\2\\2\\f\\r\\5\\4\\3\\2\\r\\16\\7\\7\\2\\2\\16\\22\\3\\2\\2\\2\\17\\22\"+\n\t\t\"\\7\\t\\2\\2\\20\\22\\7\\b\\2\\2\\21\\n\\3\\2\\2\\2\\21\\17\\3\\2\\2\\2\\21\\20\\3\\2\\2\\2\\22\\33\"+\n\t\t\"\\3\\2\\2\\2\\23\\24\\f\\7\\2\\2\\24\\25\\7\\4\\2\\2\\25\\32\\5\\4\\3\\b\\26\\27\\f\\6\\2\\2\\27\\30\"+\n\t\t\"\\7\\5\\2\\2\\30\\32\\5\\4\\3\\7\\31\\23\\3\\2\\2\\2\\31\\26\\3\\2\\2\\2\\32\\35\\3\\2\\2\\2\\33\\31\"+\n\t\t\"\\3\\2\\2\\2\\33\\34\\3\\2\\2\\2\\34\\5\\3\\2\\2\\2\\35\\33\\3\\2\\2\\2\\5\\21\\31\\33\";\n\tpublic static final ATN _ATN =\n\t\tnew ATNDeserializer().deserialize(_serializedATN.toCharArray());\n\tstatic {\n\t\t_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];\n\t\tfor (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {\n\t\t\t_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "courses-at-nju-by-hfwei/compilers-antlr", "file": "build/generated-src/antlr/main/parserllantlr/LRExprParenParser.java", "last_update_at": "2021-12-16T03:24:37+00:00", "question_id": "be19510bbe554bc909260040d46c21ac6908f660", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\"})\npublic class LRExprParenParser extends Parser {\n\tstatic { RuntimeMetaData.checkVersion(\"4.9.2\", RuntimeMetaData.VERSION); }\n\tprotected static final DFA[] _decisionToDFA;\n\tprotected static final PredictionContextCache _sharedContextCache =\n\t\tnew PredictionContextCache();\n\tpublic static final int\n\t\tT__0=1, T__1=2, T__2=3, T__3=4, T__4=5, ID=6, INT=7, WS=8;\n\tpublic static final int\n\t\tRULE_stat = 0, RULE_expr = 1;\n\tprivate static String[] makeRuleNames() {\n\t\treturn new String[] {\n\t\t\t\"stat\", \"expr\"\n\t\t};\n\t}\n\tpublic static final String[] ruleNames = makeRuleNames();\n\tprivate static String[] makeLiteralNames() {\n\t\treturn new String[] {\n\t\t\tnull, \"';'\", \"'*'\", \"'+'\", \"'('\", \"')'\"\n\t\t};\n\t}\n\tprivate static final String[] _LITERAL_NAMES = makeLiteralNames();\n\tprivate static String[] makeSymbolicNames() {\n\t\treturn new String[] {\n\t\t\tnull, null, null, null, null, null, \"ID\", \"INT\", \"WS\"\n\t\t};\n\t}\n\tprivate static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();\n\tpublic static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);\n\t/**\n\t * @deprecated Use {@link #VOCABULARY} instead.\n\t */\n\t@Deprecated\n\tpublic static final String[] tokenNames;\n\tstatic {\n\t\ttokenNames = new String[_SYMBOLIC_NAMES.length];\n\t\tfor (int i = 0; i < tokenNames.length; i++) {\n\t\t\ttokenNames[i] = VOCABULARY.getLiteralName(i);\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = VOCABULARY.getSymbolicName(i);\n\t\t\t}\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = \"<INVALID>\";\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\t@Deprecated\n\tpublic String[] getTokenNames() {\n\t\treturn tokenNames;\n\t}\n\t@Override\n\tpublic Vocabulary getVocabulary() {\n\t\treturn VOCABULARY;\n\t}\n\t@Override\n\tpublic String getGrammarFileName() { return \"LRExprParen.g4\"; }\n\t@Override\n\tpublic String[] getRuleNames() { return ruleNames; }\n\t@Override\n\tpublic String getSerializedATN() { return _serializedATN; }\n\t@Override\n\tpublic ATN getATN() { return _ATN; }\n\tpublic LRExprParenParser(TokenStream input) {\n\t\tsuper(input);\n\t\t_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);\n\t}\n\tpublic static class StatContext extends ParserRuleContext {\n\t\tpublic ExprContext expr() {\n\t\t\treturn getRuleContext(ExprContext.class,0);\n\t\t}\n\t\tpublic TerminalNode EOF() { return getToken(LRExprParenParser.EOF, 0); }\n\t\tpublic StatContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_stat; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitStat(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\tpublic final StatContext stat() throws RecognitionException {\n\t\tStatContext _localctx = new StatContext(_ctx, getState());\n\t\tenterRule(_localctx, 0, RULE_stat);\n\t\ttry {\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(4);\n\t\t\texpr(0);\n\t\t\tsetState(5);\n\t\t\tmatch(T__0);\n\t\t\tsetState(6);\n\t\t\tmatch(EOF);\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\texitRule();\n\t\t}\n\t\treturn _localctx;\n\t}\n\tpublic static class ExprContext extends ParserRuleContext {\n\t\tpublic List<ExprContext> expr() {\n\t\t\treturn getRuleContexts(ExprContext.class);\n\t\t}\n\t\tpublic ExprContext expr(int i) {\n\t\t\treturn getRuleContext(ExprContext.class,i);\n\t\t}\n\t\tpublic TerminalNode INT() { return getToken(LRExprParenParser.INT, 0); }\n\t\tpublic TerminalNode ID() { return getToken(LRExprParenParser.ID, 0); }\n\t\tpublic ExprContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_expr; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitExpr(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\tpublic final ExprContext expr() throws RecognitionException {\n\t\treturn expr(0);\n\t}\n\tprivate ExprContext expr(int _p) throws RecognitionException {\n\t\tParserRuleContext _parentctx = _ctx;\n\t\tint _parentState = getState();\n\t\tExprContext _localctx = new ExprContext(_ctx, _parentState);\n\t\tExprContext _prevctx = _localctx;\n\t\tint _startState = 2;\n\t\tenterRecursionRule(_localctx, 2, RULE_expr, _p);\n\t\ttry {\n\t\t\tint _alt;\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(15);\n\t\t\t_errHandler.sync(this);\n\t\t\tswitch (_input.LA(1)) {\n\t\t\tcase T__3:\n\t\t\t\t{\n\t\t\t\tsetState(9);\n\t\t\t\tmatch(T__3);\n\t\t\t\tsetState(10);\n\t\t\t\texpr(0);\n\t\t\t\tsetState(11);\n\t\t\t\tmatch(T__4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\t{\n\t\t\t\tsetState(13);\n\t\t\t\tmatch(INT);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ID:\n\t\t\t\t{\n\t\t\t\tsetState(14);\n\t\t\t\tmatch(ID);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new NoViableAltException(this);\n\t\t\t}\n\t\t\t_ctx.stop = _input.LT(-1);\n\t\t\tsetState(25);\n\t\t\t_errHandler.sync(this);\n\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\twhile ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tif ( _alt==1 ) {\n\t\t\t\t\tif ( _parseListeners!=null ) triggerExitRuleEvent();\n\t\t\t\t\t_prevctx = _localctx;\n\t\t\t\t\t{\n\t\t\t\t\tsetState(23);\n\t\t\t\t\t_errHandler.sync(this);\n\t\t\t\t\tswitch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(17);\n\t\t\t\t\t\tif (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\t\t\t\t\t\tsetState(18);\n\t\t\t\t\t\tmatch(T__1);\n\t\t\t\t\t\tsetState(19);\n\t\t\t\t\t\texpr(6);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(20);\n\t\t\t\t\t\tif (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\t\t\t\t\t\tsetState(21);\n\t\t\t\t\t\tmatch(T__2);\n\t\t\t\t\t\tsetState(22);\n\t\t\t\t\t\texpr(5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tsetState(27);\n\t\t\t\t_errHandler.sync(this);\n\t\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\tunrollRecursionContexts(_parentctx);\n\t\t}\n\t\treturn _localctx;\n\t}\n\tpublic boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n\t\tswitch (ruleIndex) {\n\t\tcase 1:\n\t\t\treturn expr_sempred((ExprContext)_localctx, predIndex);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate boolean expr_sempred(ExprContext _localctx, int predIndex) {\n\t\tswitch (predIndex) {\n\t\tcase 0:\n\t\t\treturn precpred(_ctx, 5);\n\t\tcase 1:\n\t\t\treturn precpred(_ctx, 4);\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static final String _serializedATN =\n\t\t\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3\\n\\37\\4\\2\\t\\2\\4\\3\"+\n\t\t\"\\t\\3\\3\\2\\3\\2\\3\\2\\3\\2\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3\\22\\n\\3\\3\\3\\3\\3\\3\"+\n\t\t\"\\3\\3\\3\\3\\3\\3\\3\\7\\3\\32\\n\\3\\f\\3\\16\\3\\35\\13\\3\\3\\3\\2\\3\\4\\4\\2\\4\\2\\2\\2 \\2\\6\"+\n\t\t\"\\3\\2\\2\\2\\4\\21\\3\\2\\2\\2\\6\\7\\5\\4\\3\\2\\7\\b\\7\\3\\2\\2\\b\\t\\7\\2\\2\\3\\t\\3\\3\\2\\2\\2\"+\n\t\t\"\\n\\13\\b\\3\\1\\2\\13\\f\\7\\6\\2\\2\\f\\r\\5\\4\\3\\2\\r\\16\\7\\7\\2\\2\\16\\22\\3\\2\\2\\2\\17\\22\"+\n\t\t\"\\7\\t\\2\\2\\20\\22\\7\\b\\2\\2\\21\\n\\3\\2\\2\\2\\21\\17\\3\\2\\2\\2\\21\\20\\3\\2\\2\\2\\22\\33\"+\n\t\t\"\\3\\2\\2\\2\\23\\24\\f\\7\\2\\2\\24\\25\\7\\4\\2\\2\\25\\32\\5\\4\\3\\b\\26\\27\\f\\6\\2\\2\\27\\30\"+\n\t\t\"\\7\\5\\2\\2\\30\\32\\5\\4\\3\\7\\31\\23\\3\\2\\2\\2\\31\\26\\3\\2\\2\\2\\32\\35\\3\\2\\2\\2\\33\\31\"+\n\t\t\"\\3\\2\\2\\2\\33\\34\\3\\2\\2\\2\\34\\5\\3\\2\\2\\2\\35\\33\\3\\2\\2\\2\\5\\21\\31\\33\";\n\tpublic static final ATN _ATN =\n\t\tnew ATNDeserializer().deserialize(_serializedATN.toCharArray());\n\tstatic {\n\t\t_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];\n\t\tfor (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {\n\t\t\t_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.0913573503494263, "ppl_lower": 1.6455050706863403, "ppl/lowercase_ppl": -5.69703562239344, "ppl/zlib": 3.7649525012262734e-05, "Min_5.0% Prob": 1.7343658677795355, "Min_10.0% Prob": 0.8762186546946931, "Min_20.0% Prob": 0.43835983013916263, "Min_30.0% Prob": 0.29225847534519217, "Min_40.0% Prob": 0.21866069619706333, "Min_50.0% Prob": 0.17501480237502154, "Min_60.0% Prob": 0.1458934835167219}}
{"hexsha": "80b509f6a9d12338612de5cf8c483f27953d4d54", "ext": "java", "lang": "Java", "content": "public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {\n\n  private int x;\n  private int y;\n  private int z;\n  private List<IoMode> modes;\n  private Channel selectedChannel;\n\n  public PacketClientState() {\n  }\n\n  public PacketClientState(TileHyperCube te) {\n    x = te.xCoord;\n    y = te.yCoord;\n    z = te.zCoord;\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      modes.add(te.getModeForChannel(sc));\n    }\n    selectedChannel = te.getChannel();\n  }\n\n  @Override\n  public void toBytes(ByteBuf buf) {\n    buf.writeInt(x);\n    buf.writeInt(y);\n    buf.writeInt(z);\n\n    if(selectedChannel == null) {\n      ByteBufUtils.writeUTF8String(buf, \"\");\n      ByteBufUtils.writeUTF8String(buf, \"\");\n    } else {\n      ByteBufUtils.writeUTF8String(buf, selectedChannel.name);\n      if(selectedChannel.isPublic()) {\n        ByteBufUtils.writeUTF8String(buf, \"\");\n      } else {\n        ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());\n      }\n    }\n\n    for (IoMode mode : modes) {\n      buf.writeShort(mode.ordinal());\n    }\n  }\n\n  @Override\n  public void fromBytes(ByteBuf buf) {\n    x = buf.readInt();\n    y = buf.readInt();\n    z = buf.readInt();\n\n    String name = ByteBufUtils.readUTF8String(buf);\n    String user = ByteBufUtils.readUTF8String(buf);\n    selectedChannel = null;\n    if(name != null && name.trim().length() > 0) {\n      if(user != null && user.trim().length() > 0) {\n        selectedChannel = new Channel(name, user);\n      } else {\n        selectedChannel = new Channel(name, null);\n      }\n\n    }\n\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      short ordinal = buf.readShort();\n      modes.add(IoMode.values()[ordinal]);\n    }\n\n  }\n\n  @Override\n  public IMessage onMessage(PacketClientState message, MessageContext ctx) {\n    EntityPlayer player = ctx.getServerHandler().playerEntity;\n    TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);\n    if(te instanceof TileHyperCube) {\n      TileHyperCube hc = (TileHyperCube) te;\n\n      SubChannel[] vals = SubChannel.values();\n      for (int i = 0; i < vals.length; i++) {\n        SubChannel sc = vals[i];\n        IoMode mode = message.modes.get(i);\n        hc.setModeForChannel(sc, mode);\n      }\n\n      hc.setChannel(message.selectedChannel);\n\n      player.worldObj.markBlockForUpdate(message.x, message.y, message.z);\n    }\n    return null;\n\n  }\n\n}", "class_id": 0, "repo": "LorenzoDCC/EnderIO", "file": "src/main/java/crazypants/enderio/machine/hypercube/PacketClientState.java", "last_update_at": "2021-08-22T03:46:51+00:00", "question_id": "80b509f6a9d12338612de5cf8c483f27953d4d54", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {\n  private int x;\n  private int y;\n  private int z;\n  private List<IoMode> modes;\n  private Channel selectedChannel;\n  public PacketClientState() {\n  }\n  public PacketClientState(TileHyperCube te) {\n    x = te.xCoord;\n    y = te.yCoord;\n    z = te.zCoord;\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      modes.add(te.getModeForChannel(sc));\n    }\n    selectedChannel = te.getChannel();\n  }\n  @Override\n  public void toBytes(ByteBuf buf) {\n    buf.writeInt(x);\n    buf.writeInt(y);\n    buf.writeInt(z);\n    if(selectedChannel == null) {\n      ByteBufUtils.writeUTF8String(buf, \"\");\n      ByteBufUtils.writeUTF8String(buf, \"\");\n    } else {\n      ByteBufUtils.writeUTF8String(buf, selectedChannel.name);\n      if(selectedChannel.isPublic()) {\n        ByteBufUtils.writeUTF8String(buf, \"\");\n      } else {\n        ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());\n      }\n    }\n    for (IoMode mode : modes) {\n      buf.writeShort(mode.ordinal());\n    }\n  }\n  @Override\n  public void fromBytes(ByteBuf buf) {\n    x = buf.readInt();\n    y = buf.readInt();\n    z = buf.readInt();\n    String name = ByteBufUtils.readUTF8String(buf);\n    String user = ByteBufUtils.readUTF8String(buf);\n    selectedChannel = null;\n    if(name != null && name.trim().length() > 0) {\n      if(user != null && user.trim().length() > 0) {\n        selectedChannel = new Channel(name, user);\n      } else {\n        selectedChannel = new Channel(name, null);\n      }\n    }\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      short ordinal = buf.readShort();\n      modes.add(IoMode.values()[ordinal]);\n    }\n  }\n  @Override\n  public IMessage onMessage(PacketClientState message, MessageContext ctx) {\n    EntityPlayer player = ctx.getServerHandler().playerEntity;\n    TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);\n    if(te instanceof TileHyperCube) {\n      TileHyperCube hc = (TileHyperCube) te;\n      SubChannel[] vals = SubChannel.values();\n      for (int i = 0; i < vals.length; i++) {\n        SubChannel sc = vals[i];\n        IoMode mode = message.modes.get(i);\n        hc.setModeForChannel(sc, mode);\n      }\n      hc.setChannel(message.selectedChannel);\n      player.worldObj.markBlockForUpdate(message.x, message.y, message.z);\n    }\n    return null;\n  }\n"]], "pred": {"ppl": 1.480986475944519, "ppl_lower": 1.7204591035842896, "ppl/lowercase_ppl": -1.3816642857845638, "ppl/zlib": 0.0004927332541263659, "Min_5.0% Prob": 5.1752354488816374, "Min_10.0% Prob": 3.3545172186784966, "Min_20.0% Prob": 1.9039491162916948, "Min_30.0% Prob": 1.3005032508756764, "Min_40.0% Prob": 0.981435096968875, "Min_50.0% Prob": 0.7848096404720547, "Min_60.0% Prob": 0.6546231403265047}}
{"hexsha": "2d088d08cd730611273367ea147d60a48850ecf1", "ext": "java", "lang": "Java", "content": "public final class ResourceLoader {\n    static ObjectMapper om;\n\n   static {\n        om = new ObjectMapper();\n        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n                .enable(SerializationFeature.INDENT_OUTPUT);\n        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n        om.registerModule(new JavaTimeModule());\n        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n    }\n\n    public static String load(String resourceName) {\n        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {\n            return IOUtils.toString(is, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public static String loadGitlabFile(String resourceName) {\n\n        String loaded = load(resourceName);\n        GitlabFile file = GitlabFile.builder().content(loaded).filePath(\"engagement.json\").build();\n        file.encodeFileAttributes();\n\n        try {\n            return om.writeValueAsString(file);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n}", "class_id": 0, "repo": "rht-labs/lodestar-hosting", "file": "src/test/java/com/redhat/labs/lodestar/hosting/mock/ResourceLoader.java", "last_update_at": "2021-08-09T16:55:15+00:00", "question_id": "2d088d08cd730611273367ea147d60a48850ecf1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ResourceLoader {\n    static ObjectMapper om;\n   static {\n        om = new ObjectMapper();\n        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n                .enable(SerializationFeature.INDENT_OUTPUT);\n        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n        om.registerModule(new JavaTimeModule());\n        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n    public static String load(String resourceName) {\n        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {\n            return IOUtils.toString(is, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static String loadGitlabFile(String resourceName) {\n        String loaded = load(resourceName);\n        GitlabFile file = GitlabFile.builder().content(loaded).filePath(\"engagement.json\").build();\n        file.encodeFileAttributes();\n        try {\n            return om.writeValueAsString(file);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n"]], "pred": {"ppl": 1.925044298171997, "ppl_lower": 2.6325976848602295, "ppl/lowercase_ppl": -1.4779335518891241, "ppl/zlib": 0.0011195709051493603, "Min_5.0% Prob": 6.249002540812773, "Min_10.0% Prob": 4.47528069860795, "Min_20.0% Prob": 2.8896699996962063, "Min_30.0% Prob": 2.1018011128673186, "Min_40.0% Prob": 1.62672543865831, "Min_50.0% Prob": 1.3094409535062967, "Min_60.0% Prob": 1.0918228557834833}}
{"hexsha": "900efec8f77509ae8a2b4b9488dc2c67b487169f", "ext": "java", "lang": "Java", "content": "public class OpFactory {\n    public static ASTLeaf createOperator(Token t) {\n        String op = t.getText();\n        String[] AssignOperators = {\"+=\", \"-=\", \"*=\", \"/=\"};\n        if(Arrays.asList(AssignOperators).contains(op))\n            return new CompoundAssignOperator(t);\n        else if(op.equals(\"=\"))\n            return new AssignOperator(t);\n        else if(op.equals(\"+\"))\n            return new PlusOperator(t);\n        else if(op.equals(\"-\"))\n            return new MinusOperator(t);\n        else if(op.equals(\"*\"))\n            return new ProductOperator(t);\n        else if (op.equals(\"/\"))\n            return new QuotientOperator(t);\n        else if (op.equals(\"%\"))\n            return new SurplusOperator(t);\n        else if (op.equals(\"==\"))\n            return new EqualityOperator(t);\n        else if (op.equals(\"!=\"))\n            return new NonEqualityOperator(t);\n        else if (op.equals(\">\"))\n            return new MoreOperator(t);\n        else if (op.equals(\">=\"))\n            return new MoreOrEqualOperator(t);\n        else if (op.equals(\"<\"))\n            return new LessOperator(t);\n        else if (op.equals(\"<=\"))\n            return new LessOrEqualOperator(t);\n        else if (op.equals(\"&&\"))\n            return new AndOperator(t);\n        else if (op.equals(\"||\"))\n            return new OrOperator(t);\n        throw new SheepException(\"Unsupported operator\", t.getLineNumber());\n    }\n}", "class_id": 0, "repo": "teru01/Sheep", "file": "src/main/java/sheep/operator/OpFactory.java", "last_update_at": "2021-07-13T15:30:20+00:00", "question_id": "900efec8f77509ae8a2b4b9488dc2c67b487169f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OpFactory {\n    public static ASTLeaf createOperator(Token t) {\n        String op = t.getText();\n        String[] AssignOperators = {\"+=\", \"-=\", \"*=\", \"/=\"};\n        if(Arrays.asList(AssignOperators).contains(op))\n            return new CompoundAssignOperator(t);\n        else if(op.equals(\"=\"))\n            return new AssignOperator(t);\n        else if(op.equals(\"+\"))\n            return new PlusOperator(t);\n        else if(op.equals(\"-\"))\n            return new MinusOperator(t);\n        else if(op.equals(\"*\"))\n            return new ProductOperator(t);\n        else if (op.equals(\"/\"))\n            return new QuotientOperator(t);\n        else if (op.equals(\"%\"))\n            return new SurplusOperator(t);\n        else if (op.equals(\"==\"))\n            return new EqualityOperator(t);\n        else if (op.equals(\"!=\"))\n            return new NonEqualityOperator(t);\n        else if (op.equals(\">\"))\n            return new MoreOperator(t);\n        else if (op.equals(\">=\"))\n            return new MoreOrEqualOperator(t);\n        else if (op.equals(\"<\"))\n            return new LessOperator(t);\n        else if (op.equals(\"<=\"))\n            return new LessOrEqualOperator(t);\n        else if (op.equals(\"&&\"))\n            return new AndOperator(t);\n        else if (op.equals(\"||\"))\n            return new OrOperator(t);\n        throw new SheepException(\"Unsupported operator\", t.getLineNumber());\n    }\n"]], "pred": {"ppl": 1.6284695863723755, "ppl_lower": 1.8315060138702393, "ppl/lowercase_ppl": -1.240951840978421, "ppl/zlib": 0.001336001834811322, "Min_5.0% Prob": 6.463369131088257, "Min_10.0% Prob": 4.106570934637999, "Min_20.0% Prob": 2.3509631779374955, "Min_30.0% Prob": 1.610387711402248, "Min_40.0% Prob": 1.2154034882690172, "Min_50.0% Prob": 0.9735186779894983, "Min_60.0% Prob": 0.8148328090231365}}
{"hexsha": "73c0128eea6de9f738bb18aeb804b5c4154dd8dc", "ext": "java", "lang": "Java", "content": "@ExtendWith(MockitoExtension.class)\nclass AuthCodeGenerationServiceTest {\n\n    @Mock\n    private AuthorizationCodeRepository repository;\n    @InjectMocks\n    private AuthCodeGenerationService testee;\n\n    @Test\n    void test_create() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));\n        when(repository.existsByCode(anyString())).thenReturn(false);\n\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_code_already_exists() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);\n\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_in_future() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_too_far_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017,7,7));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_4_weeks_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_now() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n}", "class_id": 0, "repo": "Ruben23/CovidCode-Service", "file": "src/test/java/ch/admin/bag/covidcode/authcodegeneration/service/AuthCodeGenerationServiceTest.java", "last_update_at": "2021-09-11T08:45:20+00:00", "question_id": "73c0128eea6de9f738bb18aeb804b5c4154dd8dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(MockitoExtension.class)\nclass AuthCodeGenerationServiceTest {\n    @Mock\n    private AuthorizationCodeRepository repository;\n    @InjectMocks\n    private AuthCodeGenerationService testee;\n    @Test\n    void test_create() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));\n        when(repository.existsByCode(anyString())).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n    @Test\n    void test_create_code_already_exists() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n    @Test\n    void test_create_invalid_onset_date_in_future() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n    @Test\n    void test_create_invalid_onset_date_too_far_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017,7,7));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n    @Test\n    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n    @Test\n    void test_create_valid_onset_date_exactly_4_weeks_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n    @Test\n    void test_create_valid_onset_date_exactly_now() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n"]], "pred": {"ppl": 1.3429796695709229, "ppl_lower": 1.4991416931152344, "ppl/lowercase_ppl": -1.373026110315843, "ppl/zlib": 0.0005371416746005904, "Min_5.0% Prob": 4.137819822953672, "Min_10.0% Prob": 2.659686798399145, "Min_20.0% Prob": 1.4546511837810128, "Min_30.0% Prob": 0.981721571868523, "Min_40.0% Prob": 0.7370696486624416, "Min_50.0% Prob": 0.5895484778419956, "Min_60.0% Prob": 0.4919156601804701}}
{"hexsha": "bbc956ee5ff3ca405fd0af54c93d59a6b745685b", "ext": "java", "lang": "Java", "content": "@Service\npublic class ItemService {\n\n    @Autowired\n    private GmallPmsClient pmsClient;\n\n    @Autowired\n    private GmallSmsClient smsClient;\n    @Autowired\n    private GmallWmsClient wmsClient;\n\n    @Autowired\n    private ThreadPoolExecutor threadPoolExecutor;\n\n\n    public ItemVO queryItemVO(Long skuId) {\n\n        ItemVO itemVO = new ItemVO();\n        //\u6839\u636esku\u7684id\u67e5\u8be2sku\n\n\n        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {\n            itemVO.setSkuId(skuId);\n            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);\n            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();\n            if (skuInfoEntity == null) {\n                return null;\n            }\n            itemVO.setWeight(skuInfoEntity.getWeight());\n            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());\n            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());\n            itemVO.setPrice(skuInfoEntity.getPrice());\n\n            return skuInfoEntity;\n        },threadPoolExecutor);\n\n        //\u6839\u636esku\u4e2d\u7684\u54c1\u724c\u7684id\u67e5\u8be2\u5206\u7c7b\n        //thenAcceptAsync:\u6709\u53c2\u6570\uff0c\u65e0\u8fd4\u56de\n        //thanApplyAsync: \u6709\u53c2\u6570\uff0c\u6709\u8fd4\u56de\n        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());\n            CategoryEntity categoryEntity = categoryEntityResp.getData();\n            if (categoryEntity != null) {\n\n                itemVO.setCategoryId(categoryEntity.getCatId());\n                itemVO.setCategoryName(categoryEntity.getName());\n            }\n\n        },threadPoolExecutor);\n\n        //\u6839\u636esku\u4e2d\u7684brandID\u67e5\u8be2\u54c1\u724c\n        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n\n            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());\n            BrandEntity brandEntity = brandEntityResp.getData();\n            if(brandEntity!=null){\n                itemVO.setBrandId(brandEntity.getBrandId());\n                itemVO.setBrandName(brandEntity.getName());\n\n            }\n        },threadPoolExecutor);\n\n        //\u6839\u636esku\u4e2d\u7684spu\u67e5\u8be2spu\n        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());\n            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();\n            if (skuInfoEntity != null) {\n                itemVO.setSpuId(spuInfoEntity.getId());\n                itemVO.setSpuName(spuInfoEntity.getSpuName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684\u4fe1\u606f\u67e5\u8be2\u56fe\u7247\n        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);\n            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();\n            if (!CollectionUtils.isEmpty(imagesEntities)) {\n                itemVO.setImeges(imagesEntities);\n            }\n        },threadPoolExecutor);\n\n\n        //\u6839\u636eskuid\u67e5\u8be2\u5e93\u5b58\n        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);\n            List<WareSkuEntity> wareSkuEntities = listResp.getData();\n            if (!CollectionUtils.isEmpty(wareSkuEntities)) {\n                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));\n            }\n        },threadPoolExecutor);\n\n\n        //\u6839\u636eskuid\u67e5\u8be2\u8425\u9500\u4fe1\u606f3\u4e2a\n        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);\n            List<ItemSaleVO> itemSaleVOList = listResp1.getData();\n            itemVO.setSales(itemSaleVOList);\n        },threadPoolExecutor);\n\n\n        //\u6839\u636esku\u4e2d\u7684spuID\u67e5\u8be2\u63cf\u8ff0\u4fe1\u606f\n        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());\n            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();\n            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {\n\n                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), \",\")));\n            }\n        },threadPoolExecutor);\n\n        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());\n            List<ItemGroupVO> itemGroupVOS = listResp2.getData();\n            itemVO.setGroupVOS(itemGroupVOS);\n\n        },threadPoolExecutor);\n\n\n        //\u6839\u636esku\u4e2d\u7684spuId\u67e5\u8be2skus\n        //\u6839\u636eskuIds\u67e5\u8be2\u9500\u552e\u5c5e\u6027\n        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());\n            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();\n            itemVO.setSaleAttrs(skuSaleAttrValueEntities);\n\n        },threadPoolExecutor);\n\n        CompletableFuture.allOf(completableFuture,cateCompletablbe,brandCompletablbe,spuCompletable,imagesCompletableFuture\n                               ,skuCompletableFuture,saleCompletableFuture,descCompletableFuture,\n                groupCompletableFuture,attrValueCompletableFuture).join();\n        return itemVO;\n    }\n}", "class_id": 0, "repo": "lxftheking/gmall", "file": "gmall-item/src/main/java/com/atguigu/gmall/item/service/ItemService.java", "last_update_at": "2021-09-09T07:21:17+00:00", "question_id": "bbc956ee5ff3ca405fd0af54c93d59a6b745685b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class ItemService {\n    @Autowired\n    private GmallPmsClient pmsClient;\n    @Autowired\n    private GmallSmsClient smsClient;\n    @Autowired\n    private GmallWmsClient wmsClient;\n    @Autowired\n    private ThreadPoolExecutor threadPoolExecutor;\n    public ItemVO queryItemVO(Long skuId) {\n        ItemVO itemVO = new ItemVO();\n        //\u6839\u636esku\u7684id\u67e5\u8be2sku\n        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {\n            itemVO.setSkuId(skuId);\n            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);\n            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();\n            if (skuInfoEntity == null) {\n                return null;\n            }\n            itemVO.setWeight(skuInfoEntity.getWeight());\n            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());\n            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());\n            itemVO.setPrice(skuInfoEntity.getPrice());\n            return skuInfoEntity;\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684\u54c1\u724c\u7684id\u67e5\u8be2\u5206\u7c7b\n        //thenAcceptAsync:\u6709\u53c2\u6570\uff0c\u65e0\u8fd4\u56de\n        //thanApplyAsync: \u6709\u53c2\u6570\uff0c\u6709\u8fd4\u56de\n        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());\n            CategoryEntity categoryEntity = categoryEntityResp.getData();\n            if (categoryEntity != null) {\n                itemVO.setCategoryId(categoryEntity.getCatId());\n                itemVO.setCategoryName(categoryEntity.getName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684brandID\u67e5\u8be2\u54c1\u724c\n        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());\n            BrandEntity brandEntity = brandEntityResp.getData();\n            if(brandEntity!=null){\n                itemVO.setBrandId(brandEntity.getBrandId());\n                itemVO.setBrandName(brandEntity.getName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684spu\u67e5\u8be2spu\n        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());\n            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();\n            if (skuInfoEntity != null) {\n                itemVO.setSpuId(spuInfoEntity.getId());\n                itemVO.setSpuName(spuInfoEntity.getSpuName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684\u4fe1\u606f\u67e5\u8be2\u56fe\u7247\n        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);\n            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();\n            if (!CollectionUtils.isEmpty(imagesEntities)) {\n                itemVO.setImeges(imagesEntities);\n            }\n        },threadPoolExecutor);\n        //\u6839\u636eskuid\u67e5\u8be2\u5e93\u5b58\n        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);\n            List<WareSkuEntity> wareSkuEntities = listResp.getData();\n            if (!CollectionUtils.isEmpty(wareSkuEntities)) {\n                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));\n            }\n        },threadPoolExecutor);\n        //\u6839\u636eskuid\u67e5\u8be2\u8425\u9500\u4fe1\u606f3\u4e2a\n        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);\n            List<ItemSaleVO> itemSaleVOList = listResp1.getData();\n            itemVO.setSales(itemSaleVOList);\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684spuID\u67e5\u8be2\u63cf\u8ff0\u4fe1\u606f\n        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());\n            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();\n            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {\n                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), \",\")));\n            }\n        },threadPoolExecutor);\n        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());\n            List<ItemGroupVO> itemGroupVOS = listResp2.getData();\n            itemVO.setGroupVOS(itemGroupVOS);\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684spuId\u67e5\u8be2skus\n        //\u6839\u636eskuIds\u67e5\u8be2\u9500\u552e\u5c5e\u6027\n        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());\n            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();\n            itemVO.setSaleAttrs(skuSaleAttrValueEntities);\n        },threadPoolExecutor);\n        CompletableFuture.allOf(completableFuture,cateCompletablbe,brandCompletablbe,spuCompletable,imagesCompletableFuture\n                               ,skuCompletableFuture,saleCompletableFuture,descCompletableFuture,\n                groupCompletableFuture,attrValueCompletableFuture).join();\n        return itemVO;\n    }\n"]], "pred": {"ppl": 1.4206432104110718, "ppl_lower": 1.7089442014694214, "ppl/lowercase_ppl": -1.5262343982275368, "ppl/zlib": 0.00026419092109381247, "Min_5.0% Prob": 5.145283441917569, "Min_10.0% Prob": 3.1659466297018763, "Min_20.0% Prob": 1.7152043983486354, "Min_30.0% Prob": 1.164827892995056, "Min_40.0% Prob": 0.8762372978632782, "Min_50.0% Prob": 0.7024356740487671, "Min_60.0% Prob": 0.5858228182187304}}
{"hexsha": "b695b9c87c6ae72391dd9e982a7a2b9c105d886d", "ext": "java", "lang": "Java", "content": "public class VertexStroke {\n\n    /**\n     * Method to compute Vertex Stroke\n     *\n     * @param v JUNG's V (Vertex) type\n     * @param dash The array representing the dashing pattern\n     * @param view VisualizationViewer<Object, Edge>\n     * @param layout Layout<Object, Edge>\n     * @return Stroke\n     */\n    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {\n        PickedState<Object> picked_state = view.getPickedVertexState();\n        if (picked_state.isPicked(v)) {\n            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        } else {\n            for (Object w : layout.getGraph().getNeighbors(v)) {\n                if (picked_state.isPicked(w)) {\n                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n                }\n            }\n//            float value = ((Vertex)v).getAttributeValueFloat(\"Cluster\");\n//            if(value != value)\n                return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n//            else\n//                return new BasicStroke(5.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        }\n    }\n\n    /**\n     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,\n     * hired)\n     *\n     * @param v\n     * @param view\n     * @param layout\n     * @param variables\n     * @return\n     */\n    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {\n        float[] dash = null;\n//        if (v instanceof Graph) {\n//            return new BasicStroke(0);\n//        }\n\n        if (v instanceof Vertex) {\n            if (!variables.config.vertexStrokevariables.isEmpty()) {\n                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {\n                    String[] list = vertexStrokevariable.split(\" \");\n                    String att = ((Vertex) v).getAttributeValue(list[0]);\n                    if (!\"\".equals(att)) {\n                        for (int j = 1; j < list.length; j++) {\n                            if (att.equalsIgnoreCase(list[j])) {\n                                dash = new float[1];\n                                dash[0] = 4.0f;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return VertexStroke(v, dash, view, layout);\n    }\n}", "class_id": 0, "repo": "stain/prov-viewer", "file": "src/main/java/br/uff/ic/provviewer/Stroke/VertexStroke.java", "last_update_at": "2021-12-09T05:27:32+00:00", "question_id": "b695b9c87c6ae72391dd9e982a7a2b9c105d886d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VertexStroke {\n    /**\n     * Method to compute Vertex Stroke\n     *\n     * @param v JUNG's V (Vertex) type\n     * @param dash The array representing the dashing pattern\n     * @param view VisualizationViewer<Object, Edge>\n     * @param layout Layout<Object, Edge>\n     * @return Stroke\n     */\n    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {\n        PickedState<Object> picked_state = view.getPickedVertexState();\n        if (picked_state.isPicked(v)) {\n            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        } else {\n            for (Object w : layout.getGraph().getNeighbors(v)) {\n                if (picked_state.isPicked(w)) {\n                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n                }\n            }\n//            float value = ((Vertex)v).getAttributeValueFloat(\"Cluster\");\n//            if(value != value)\n                return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n//            else\n//                return new BasicStroke(5.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        }\n    }\n    /**\n     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,\n     * hired)\n     *\n     * @param v\n     * @param view\n     * @param layout\n     * @param variables\n     * @return\n     */\n    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {\n        float[] dash = null;\n//        if (v instanceof Graph) {\n//            return new BasicStroke(0);\n//        }\n        if (v instanceof Vertex) {\n            if (!variables.config.vertexStrokevariables.isEmpty()) {\n                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {\n                    String[] list = vertexStrokevariable.split(\" \");\n                    String att = ((Vertex) v).getAttributeValue(list[0]);\n                    if (!\"\".equals(att)) {\n                        for (int j = 1; j < list.length; j++) {\n                            if (att.equalsIgnoreCase(list[j])) {\n                                dash = new float[1];\n                                dash[0] = 4.0f;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return VertexStroke(v, dash, view, layout);\n    }\n"]], "pred": {"ppl": 2.0640079975128174, "ppl_lower": 2.389638662338257, "ppl/lowercase_ppl": -1.2021562146622364, "ppl/zlib": 0.0009435543260101188, "Min_5.0% Prob": 7.3785475217379055, "Min_10.0% Prob": 5.420770776577485, "Min_20.0% Prob": 3.3812660874834486, "Min_30.0% Prob": 2.376862853511851, "Min_40.0% Prob": 1.801982891989077, "Min_50.0% Prob": 1.4460574156929367, "Min_60.0% Prob": 1.2083754804105975}}
{"hexsha": "1bfe81dec8dca4cb4bef7c48cad2b36862d7d8fe", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet\")\n@JsonPropertyOrder({\n  PresentationResult.JSON_PROPERTY_SLIDE_NUMBER,\n  PresentationResult.JSON_PROPERTY_U_R_L,\n  PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS\n})\n@JsonTypeName(\"PresentationResult\")\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-11-14T13:47:19.979-08:00[America/Los_Angeles]\")\npublic class PresentationResult {\n  public static final String JSON_PROPERTY_SLIDE_NUMBER = \"SlideNumber\";\n  private Integer slideNumber;\n\n  public static final String JSON_PROPERTY_U_R_L = \"URL\";\n  private String URL;\n\n  public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = \"PresentationContents\";\n  private byte[] presentationContents;\n\n\n  public PresentationResult slideNumber(Integer slideNumber) {\n    \n    this.slideNumber = slideNumber;\n    return this;\n  }\n\n   /**\n   * Worksheet number of the converted page, starting with 1 for the left-most worksheet\n   * @return slideNumber\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Worksheet number of the converted page, starting with 1 for the left-most worksheet\")\n  @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public Integer getSlideNumber() {\n    return slideNumber;\n  }\n\n\n  public void setSlideNumber(Integer slideNumber) {\n    this.slideNumber = slideNumber;\n  }\n\n\n  public PresentationResult URL(String URL) {\n    \n    this.URL = URL;\n    return this;\n  }\n\n   /**\n   * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\n   * @return URL\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\")\n  @JsonProperty(JSON_PROPERTY_U_R_L)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public String getURL() {\n    return URL;\n  }\n\n\n  public void setURL(String URL) {\n    this.URL = URL;\n  }\n\n\n  public PresentationResult presentationContents(byte[] presentationContents) {\n    \n    this.presentationContents = presentationContents;\n    return this;\n  }\n\n   /**\n   * Contents of the presentation in bytes\n   * @return presentationContents\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Contents of the presentation in bytes\")\n  @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public byte[] getPresentationContents() {\n    return presentationContents;\n  }\n\n\n  public void setPresentationContents(byte[] presentationContents) {\n    this.presentationContents = presentationContents;\n  }\n\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PresentationResult presentationResult = (PresentationResult) o;\n    return Objects.equals(this.slideNumber, presentationResult.slideNumber) &&\n        Objects.equals(this.URL, presentationResult.URL) &&\n        Arrays.equals(this.presentationContents, presentationResult.presentationContents);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PresentationResult {\\n\");\n    sb.append(\"    slideNumber: \").append(toIndentedString(slideNumber)).append(\"\\n\");\n    sb.append(\"    URL: \").append(toIndentedString(URL)).append(\"\\n\");\n    sb.append(\"    presentationContents: \").append(toIndentedString(presentationContents)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "Cloudmersive/Cloudmersive.APIClient.Java.RestTemplate", "file": "src/main/java/com/cloudmersive/client/rt/model/PresentationResult.java", "last_update_at": "2021-02-14T19:52:25+00:00", "question_id": "1bfe81dec8dca4cb4bef7c48cad2b36862d7d8fe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(description = \"A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet\")\n@JsonPropertyOrder({\n  PresentationResult.JSON_PROPERTY_SLIDE_NUMBER,\n  PresentationResult.JSON_PROPERTY_U_R_L,\n  PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS\n})\n@JsonTypeName(\"PresentationResult\")\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-11-14T13:47:19.979-08:00[America/Los_Angeles]\")\npublic class PresentationResult {\n  public static final String JSON_PROPERTY_SLIDE_NUMBER = \"SlideNumber\";\n  private Integer slideNumber;\n  public static final String JSON_PROPERTY_U_R_L = \"URL\";\n  private String URL;\n  public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = \"PresentationContents\";\n  private byte[] presentationContents;\n  public PresentationResult slideNumber(Integer slideNumber) {\n    this.slideNumber = slideNumber;\n    return this;\n  }\n   /**\n   * Worksheet number of the converted page, starting with 1 for the left-most worksheet\n   * @return slideNumber\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Worksheet number of the converted page, starting with 1 for the left-most worksheet\")\n  @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public Integer getSlideNumber() {\n    return slideNumber;\n  }\n  public void setSlideNumber(Integer slideNumber) {\n    this.slideNumber = slideNumber;\n  }\n  public PresentationResult URL(String URL) {\n    this.URL = URL;\n    return this;\n  }\n   /**\n   * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\n   * @return URL\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\")\n  @JsonProperty(JSON_PROPERTY_U_R_L)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public String getURL() {\n    return URL;\n  }\n  public void setURL(String URL) {\n    this.URL = URL;\n  }\n  public PresentationResult presentationContents(byte[] presentationContents) {\n    this.presentationContents = presentationContents;\n    return this;\n  }\n   /**\n   * Contents of the presentation in bytes\n   * @return presentationContents\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Contents of the presentation in bytes\")\n  @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public byte[] getPresentationContents() {\n    return presentationContents;\n  }\n  public void setPresentationContents(byte[] presentationContents) {\n    this.presentationContents = presentationContents;\n  }\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PresentationResult presentationResult = (PresentationResult) o;\n    return Objects.equals(this.slideNumber, presentationResult.slideNumber) &&\n        Objects.equals(this.URL, presentationResult.URL) &&\n        Arrays.equals(this.presentationContents, presentationResult.presentationContents);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PresentationResult {\\n\");\n    sb.append(\"    slideNumber: \").append(toIndentedString(slideNumber)).append(\"\\n\");\n    sb.append(\"    URL: \").append(toIndentedString(URL)).append(\"\\n\");\n    sb.append(\"    presentationContents: \").append(toIndentedString(presentationContents)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]], "pred": {"ppl": 1.3906257152557373, "ppl_lower": 1.8192635774612427, "ppl/lowercase_ppl": -1.8147836056516424, "ppl/zlib": 0.0002847614859356995, "Min_5.0% Prob": 4.82956677792119, "Min_10.0% Prob": 3.123307731221704, "Min_20.0% Prob": 1.6472460528671302, "Min_30.0% Prob": 1.101784513843264, "Min_40.0% Prob": 0.8246508601641346, "Min_50.0% Prob": 0.6601166397194119, "Min_60.0% Prob": 0.5502960126040549}}
{"hexsha": "b5ba2355ae572f4a5409e77434046a0882844699", "ext": "java", "lang": "Java", "content": "@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class HttpProviderTest {\n\n    /**\n     * Initial configuration.\n     */\n    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/x28wW7J8\\\"\\n\"\n    );\n\n    /**\n     * Initial configuration. Requested remote configuration file does not exists.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn87\\\"\\n\"\n    );\n\n    /**\n     * Initial configuration. Remote server can't be resolved.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\\\"\\n\"\n    );\n\n    /**\n     * Initial configuration. Requested remote configuration file is not valid.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn\\\"\\n\"\n    );\n\n    @Test\n    public void httpTest_001() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        final Config remoteConfig = ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION);\n\n        // Test version\n        final Properties properties = new Properties();\n        final InputStream is = HttpProvider.class.getClassLoader()\n            .getResourceAsStream(\"playrconf-http.properties\");\n        try {\n            properties.load(is);\n            Assert.assertEquals(\n                provider.getVersion(),\n                properties.getProperty(\"playrconf.http.version\", \"unknown\")\n            );\n            properties.clear();\n            is.close();\n        } catch (final IOException ignore) {\n        }\n\n        // Standard values\n        Assert.assertEquals(5, remoteConfig.getInt(\"application.five\"));\n        Assert.assertEquals(\"world\", remoteConfig.getString(\"application.hello\"));\n        Assert.assertTrue(remoteConfig.getBoolean(\"application.is-enabled\"));\n        Assert.assertEquals(4, remoteConfig.getIntList(\"application.list\").size());\n\n        // File\n        final File file = new File(\"./test\");\n        try {\n            final InputStream initialStream = new FileInputStream(file);\n            final byte[] buffer = new byte[128];\n            final int nbRead = initialStream.read(buffer);\n            buffer[nbRead] = '\\0';\n            Assert.assertTrue(nbRead > 0);\n            Assert.assertEquals(\n                \"Hello World!\",\n                new String(buffer, 0, nbRead)\n            );\n        } catch (final IOException ex) {\n            ex.printStackTrace();\n            Assert.fail();\n        }\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_002() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);\n    }\n\n    @Test(expected = ConfigException.BadValue.class)\n    public void httpTest_003() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_004() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);\n    }\n}", "class_id": 0, "repo": "play-rconf/play-rconf-http", "file": "src/test/java/io/playrconf/provider/HttpProviderTest.java", "last_update_at": "2021-09-03T01:39:21+00:00", "question_id": "b5ba2355ae572f4a5409e77434046a0882844699", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class HttpProviderTest {\n    /**\n     * Initial configuration.\n     */\n    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/x28wW7J8\\\"\\n\"\n    );\n    /**\n     * Initial configuration. Requested remote configuration file does not exists.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn87\\\"\\n\"\n    );\n    /**\n     * Initial configuration. Remote server can't be resolved.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\\\"\\n\"\n    );\n    /**\n     * Initial configuration. Requested remote configuration file is not valid.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn\\\"\\n\"\n    );\n    @Test\n    public void httpTest_001() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        final Config remoteConfig = ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION);\n        // Test version\n        final Properties properties = new Properties();\n        final InputStream is = HttpProvider.class.getClassLoader()\n            .getResourceAsStream(\"playrconf-http.properties\");\n        try {\n            properties.load(is);\n            Assert.assertEquals(\n                provider.getVersion(),\n                properties.getProperty(\"playrconf.http.version\", \"unknown\")\n            );\n            properties.clear();\n            is.close();\n        } catch (final IOException ignore) {\n        }\n        // Standard values\n        Assert.assertEquals(5, remoteConfig.getInt(\"application.five\"));\n        Assert.assertEquals(\"world\", remoteConfig.getString(\"application.hello\"));\n        Assert.assertTrue(remoteConfig.getBoolean(\"application.is-enabled\"));\n        Assert.assertEquals(4, remoteConfig.getIntList(\"application.list\").size());\n        // File\n        final File file = new File(\"./test\");\n        try {\n            final InputStream initialStream = new FileInputStream(file);\n            final byte[] buffer = new byte[128];\n            final int nbRead = initialStream.read(buffer);\n            buffer[nbRead] = '\\0';\n            Assert.assertTrue(nbRead > 0);\n            Assert.assertEquals(\n                \"Hello World!\",\n                new String(buffer, 0, nbRead)\n            );\n        } catch (final IOException ex) {\n            ex.printStackTrace();\n            Assert.fail();\n        }\n    }\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_002() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);\n    }\n    @Test(expected = ConfigException.BadValue.class)\n    public void httpTest_003() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);\n    }\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_004() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);\n    }\n"]], "pred": {"ppl": 2.1744160652160645, "ppl_lower": 2.5708017349243164, "ppl/lowercase_ppl": -1.215584767127571, "ppl/zlib": 0.0006748567790893562, "Min_5.0% Prob": 6.620144956252155, "Min_10.0% Prob": 5.048581223861844, "Min_20.0% Prob": 3.4708469182837245, "Min_30.0% Prob": 2.528203207877726, "Min_40.0% Prob": 1.9302497344014113, "Min_50.0% Prob": 1.5521646629027483, "Min_60.0% Prob": 1.2956090660357078}}
{"hexsha": "03d7a5ce83aba3ab84bada38250092fab43c06b1", "ext": "java", "lang": "Java", "content": "public class RandomTest {\n    public static void main(String[] args) {\n\n\n        long start = System.currentTimeMillis();\n        for (int i = 0; i <1000000 ; i++) {\n\n\n\n        int intv = new Double(Math.random() * 10000).intValue();\n        long longv = new Double(Math.random() * 1000000).longValue();\n        double doublev = Math.random() * 100;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end-start);\n\n        long start1 = System.currentTimeMillis();\n        for (int i = 0; i <10000 ; i++) {\n\n\n\n            int intv = ThreadLocalRandom.current().nextInt(10000);\n            long longv = ThreadLocalRandom.current().nextLong(1000000);\n            double doublev = ThreadLocalRandom.current().nextDouble(500);\n//            System.out.println(intv);\n//            System.out.println(longv);\n//            System.out.println(doublev);\n//            System.out.println(\"===============\");\n        }\n        long end1 = System.currentTimeMillis();\n        System.out.println(end1-start1);\n\n\n\n    }\n}", "class_id": 0, "repo": "fbjoker/cn.gitv.clickhouse", "file": "src/main/java/com/virtusai/clickhouseclient/utils/RandomTest.java", "last_update_at": "2021-11-11T00:20:35+00:00", "question_id": "03d7a5ce83aba3ab84bada38250092fab43c06b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RandomTest {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i <1000000 ; i++) {\n        int intv = new Double(Math.random() * 10000).intValue();\n        long longv = new Double(Math.random() * 1000000).longValue();\n        double doublev = Math.random() * 100;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end-start);\n        long start1 = System.currentTimeMillis();\n        for (int i = 0; i <10000 ; i++) {\n            int intv = ThreadLocalRandom.current().nextInt(10000);\n            long longv = ThreadLocalRandom.current().nextLong(1000000);\n            double doublev = ThreadLocalRandom.current().nextDouble(500);\n//            System.out.println(intv);\n//            System.out.println(longv);\n//            System.out.println(doublev);\n//            System.out.println(\"===============\");\n        }\n        long end1 = System.currentTimeMillis();\n        System.out.println(end1-start1);\n    }\n"]], "pred": {"ppl": 1.5690562725067139, "ppl_lower": 1.8358255624771118, "ppl/lowercase_ppl": -1.3485657816066767, "ppl/zlib": 0.0013775973648709429, "Min_5.0% Prob": 4.861143991351128, "Min_10.0% Prob": 3.432959444595106, "Min_20.0% Prob": 2.078929637795064, "Min_30.0% Prob": 1.4645217033010898, "Min_40.0% Prob": 1.1169891221379793, "Min_50.0% Prob": 0.8990354417828765, "Min_60.0% Prob": 0.7508492477586851}}
{"hexsha": "c7ffc9b5dcc827825419f89bb5fd3694937e4516", "ext": "java", "lang": "Java", "content": "public class PlainSpringJSONDocScannerTest {\n\n\tprivate JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();\n\n\t@Controller\n\t@RequestMapping(value = \"/api\", produces = { MediaType.APPLICATION_JSON_VALUE })\n\tprivate class SpringController {\n\n\t\t@RequestMapping(value = \"/string/{name}\", headers = \"header=test\", params = \"delete\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n\t\t@ResponseStatus(value = HttpStatus.CREATED)\n\t\tpublic @ResponseBody String string(@PathVariable(value = \"test\") String name, @RequestParam(\"id\") Integer id, @RequestParam Long query, @RequestParam(name = \"user\", required = false, defaultValue = \"admin\") String user,\t\t\t\t@RequestHeader(value = \"header-two\", defaultValue = \"header-test\") String header, @RequestBody String requestBody) {\n\t\t\treturn \"ok\";\n\t\t}\n\n\t}\n\n\t@Test\n\tpublic void testMergeApiDoc() {\n\t\tSet<Class<?>> controllers = new LinkedHashSet<Class<?>>();\n\t\tcontrollers.add(SpringController.class);\n\t\tSet<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);\n\n\t\tApiDoc apiDoc = apiDocs.iterator().next();\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getDescription());\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getName());\n\t\tAssert.assertNotNull(apiDoc.getGroup());\n\n\t\tfor (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {\n\t\t\tAssert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());\n\t\t\tAssert.assertNull(apiMethodDoc.getAuth());\n\t\t\tAssert.assertNull(apiMethodDoc.getSupportedversions());\n\t\t\tAssert.assertTrue(apiMethodDoc.getApierrors().isEmpty());\n\t\t\tAssert.assertNull(apiMethodDoc.getId());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getSummary());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getDescription());\n\t\t\t\n\t\t\tif (apiMethodDoc.getPath().contains(\"/api/string/{name}\")) {\n\t\t\t\tAssert.assertEquals(2, apiMethodDoc.getHeaders().size());\n\t\t\t\tSet<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();\n\t\t\t\tIterator<ApiHeaderDoc> headersIterator = headers.iterator();\n\t\t\t\tApiHeaderDoc headerTest = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header\", headerTest.getName());\n\t\t\t\tAssert.assertEquals(\"test\", headerTest.getAllowedvalues()[0]);\n\t\t\t\tApiHeaderDoc headerTwo = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header-two\", headerTwo.getName());\n\t\t\t\tAssert.assertEquals(\"header-test\", headerTwo.getAllowedvalues()[0]);\n\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getResponse().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"POST\", apiMethodDoc.getVerb().iterator().next().name());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getProduces().iterator().next());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getConsumes().iterator().next());\n\t\t\t\tAssert.assertEquals(\"201 - Created\", apiMethodDoc.getResponsestatuscode());\n\n\t\t\t\tSet<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();\n\t\t\t\tAssert.assertEquals(4, queryparameters.size());\n\t\t\t\tIterator<ApiParamDoc> qpIterator = queryparameters.iterator();\n\t\t\t\tApiParamDoc apiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"delete\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(null, apiParamDoc.getDefaultvalue());\n\t\t\t\tAssert.assertEquals(0, apiParamDoc.getAllowedvalues().length);\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"id\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getDefaultvalue());\n\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"user\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"false\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"admin\", apiParamDoc.getDefaultvalue());\n\n\t\t\t\tSet<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();\n\t\t\t\tIterator<ApiParamDoc> ppIterator = pathparameters.iterator();\n\t\t\t\tapiParamDoc = ppIterator.next();\n\t\t\t\tapiParamDoc = apiMethodDoc.getPathparameters().iterator().next();\n\t\t\t\tAssert.assertEquals(\"test\", apiParamDoc.getName());\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "class_id": 0, "repo": "eoekun/jsondoc", "file": "jsondoc-springmvc/src/test/java/org/jsondoc/springmvc/scanner/PlainSpringJSONDocScannerTest.java", "last_update_at": "2021-12-11T23:36:19+00:00", "question_id": "c7ffc9b5dcc827825419f89bb5fd3694937e4516", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlainSpringJSONDocScannerTest {\n\tprivate JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();\n\t@Controller\n\t@RequestMapping(value = \"/api\", produces = { MediaType.APPLICATION_JSON_VALUE })\n\tprivate class SpringController {\n\t\t@RequestMapping(value = \"/string/{name}\", headers = \"header=test\", params = \"delete\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n\t\t@ResponseStatus(value = HttpStatus.CREATED)\n\t\tpublic @ResponseBody String string(@PathVariable(value = \"test\") String name, @RequestParam(\"id\") Integer id, @RequestParam Long query, @RequestParam(name = \"user\", required = false, defaultValue = \"admin\") String user,\t\t\t\t@RequestHeader(value = \"header-two\", defaultValue = \"header-test\") String header, @RequestBody String requestBody) {\n\t\t\treturn \"ok\";\n\t\t}\n\t}\n\t@Test\n\tpublic void testMergeApiDoc() {\n\t\tSet<Class<?>> controllers = new LinkedHashSet<Class<?>>();\n\t\tcontrollers.add(SpringController.class);\n\t\tSet<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);\n\t\tApiDoc apiDoc = apiDocs.iterator().next();\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getDescription());\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getName());\n\t\tAssert.assertNotNull(apiDoc.getGroup());\n\t\tfor (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {\n\t\t\tAssert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());\n\t\t\tAssert.assertNull(apiMethodDoc.getAuth());\n\t\t\tAssert.assertNull(apiMethodDoc.getSupportedversions());\n\t\t\tAssert.assertTrue(apiMethodDoc.getApierrors().isEmpty());\n\t\t\tAssert.assertNull(apiMethodDoc.getId());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getSummary());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getDescription());\n\t\t\t\n\t\t\tif (apiMethodDoc.getPath().contains(\"/api/string/{name}\")) {\n\t\t\t\tAssert.assertEquals(2, apiMethodDoc.getHeaders().size());\n\t\t\t\tSet<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();\n\t\t\t\tIterator<ApiHeaderDoc> headersIterator = headers.iterator();\n\t\t\t\tApiHeaderDoc headerTest = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header\", headerTest.getName());\n\t\t\t\tAssert.assertEquals(\"test\", headerTest.getAllowedvalues()[0]);\n\t\t\t\tApiHeaderDoc headerTwo = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header-two\", headerTwo.getName());\n\t\t\t\tAssert.assertEquals(\"header-test\", headerTwo.getAllowedvalues()[0]);\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getResponse().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"POST\", apiMethodDoc.getVerb().iterator().next().name());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getProduces().iterator().next());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getConsumes().iterator().next());\n\t\t\t\tAssert.assertEquals(\"201 - Created\", apiMethodDoc.getResponsestatuscode());\n\t\t\t\tSet<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();\n\t\t\t\tAssert.assertEquals(4, queryparameters.size());\n\t\t\t\tIterator<ApiParamDoc> qpIterator = queryparameters.iterator();\n\t\t\t\tApiParamDoc apiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"delete\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(null, apiParamDoc.getDefaultvalue());\n\t\t\t\tAssert.assertEquals(0, apiParamDoc.getAllowedvalues().length);\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"id\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getDefaultvalue());\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"user\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"false\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"admin\", apiParamDoc.getDefaultvalue());\n\t\t\t\tSet<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();\n\t\t\t\tIterator<ApiParamDoc> ppIterator = pathparameters.iterator();\n\t\t\t\tapiParamDoc = ppIterator.next();\n\t\t\t\tapiParamDoc = apiMethodDoc.getPathparameters().iterator().next();\n\t\t\t\tAssert.assertEquals(\"test\", apiParamDoc.getName());\n\t\t\t}\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.8381339311599731, "ppl_lower": 2.0955429077148438, "ppl/lowercase_ppl": -1.215296236068867, "ppl/zlib": 0.0005459649230106496, "Min_5.0% Prob": 6.118200311473772, "Min_10.0% Prob": 4.395058818891937, "Min_20.0% Prob": 2.7943475781118168, "Min_30.0% Prob": 1.9787510717713754, "Min_40.0% Prob": 1.5106630949417361, "Min_50.0% Prob": 1.216500660929457, "Min_60.0% Prob": 1.0153621737989573}}
{"hexsha": "7740a522f9d31a442361aea9f7bbad55c45087be", "ext": "java", "lang": "Java", "content": "@Ignore\npublic class PhishingDetectionApiTest {\n\n    private final PhishingDetectionApi api = new PhishingDetectionApi();\n\n    \n    /**\n     * Detects phishing attempts\n     *\n     * \n     *\n     * @throws ApiException\n     *          if the Api call fails\n     */\n    @Test\n    public void detectAndReportTest() throws ApiException {\n        List<String> attachments = null;\n        String body = null;\n        String from = null;\n        String subject = null;\n        Integer response = api.detectAndReport(attachments, body, from, subject);\n\n        // TODO: test validations\n    }\n    \n}", "class_id": 0, "repo": "LogSentinel/logsentinel-java-api", "file": "src/test/java/com/logsentinel/api/PhishingDetectionApiTest.java", "last_update_at": "2021-05-14T10:05:46+00:00", "question_id": "7740a522f9d31a442361aea9f7bbad55c45087be", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Ignore\npublic class PhishingDetectionApiTest {\n    private final PhishingDetectionApi api = new PhishingDetectionApi();\n    /**\n     * Detects phishing attempts\n     *\n     * \n     *\n     * @throws ApiException\n     *          if the Api call fails\n     */\n    @Test\n    public void detectAndReportTest() throws ApiException {\n        List<String> attachments = null;\n        String body = null;\n        String from = null;\n        String subject = null;\n        Integer response = api.detectAndReport(attachments, body, from, subject);\n        // TODO: test validations\n    }\n"]], "pred": {"ppl": 2.042020320892334, "ppl_lower": 3.157724142074585, "ppl/lowercase_ppl": -1.610572442422825, "ppl/zlib": 0.0024789571915220555, "Min_5.0% Prob": 7.888866901397705, "Min_10.0% Prob": 6.032347664237022, "Min_20.0% Prob": 3.445295560540575, "Min_30.0% Prob": 2.39033564111712, "Min_40.0% Prob": 1.7817275950007818, "Min_50.0% Prob": 1.435728070309113, "Min_60.0% Prob": 1.1896742268987563}}
{"hexsha": "c6ec38e3aa543ebec430a9ccbdb14ad544958a43", "ext": "java", "lang": "Java", "content": "public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {\n\n    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n    /**\n     * Creation mode.\n     */\n    private ShardMapManagerCreateMode createMode;\n\n    /**\n     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.\n     */\n    private Version targetVersion;\n\n    /**\n     * Constructs request for deploying SMM storage objects to target GSM database.\n     *\n     * @param credentials\n     *            Credentials for connection.\n     * @param retryPolicy\n     *            Retry policy.\n     * @param operationName\n     *            Operation name, useful for diagnostics.\n     * @param createMode\n     *            Creation mode.\n     * @param targetVersion\n     *            target version of store to deploy\n     */\n    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials,\n            RetryPolicy retryPolicy,\n            String operationName,\n            ShardMapManagerCreateMode createMode,\n            Version targetVersion) {\n        super(credentials, retryPolicy, operationName);\n        this.createMode = createMode;\n        this.targetVersion = targetVersion;\n    }\n\n    /**\n     * Whether this is a read-only operation.\n     */\n    @Override\n    public boolean getReadOnly() {\n        return false;\n    }\n\n    /**\n     * Execute the operation against GSM in the current transaction scope.\n     *\n     * @param ts\n     *            Transaction scope.\n     * @return Results of the operation.\n     */\n    @Override\n    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {\n        log.info(\"ShardMapManagerFactory {}, Started creating Global Shard Map structures.\", this.getOperationName());\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n\n        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));\n\n        // If we did find some store deployed.\n        if (checkResult.getStoreVersion() != null) {\n            // DevNote: We need to have a way to error out if versions do not match.\n            if (createMode == ShardMapManagerCreateMode.KeepExisting) {\n                stopwatch.stop();\n                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory,\n                        ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);\n            }\n\n            log.info(\"ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.\", this.getOperationName());\n\n            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());\n        }\n\n        // Deploy initial version and run upgrade script to bring it to the specified version.\n        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());\n\n        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));\n\n        stopwatch.stop();\n\n        log.info(\"ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}\", this.getOperationName(),\n                stopwatch.elapsed(TimeUnit.MILLISECONDS));\n\n        return new StoreResults();\n    }\n\n    /**\n     * Handles errors from the GSM operation after the LSM operations.\n     *\n     * @param result\n     *            Operation result.\n     */\n    @Override\n    public void handleDoGlobalExecuteError(StoreResults result) {\n        log.debug(\"Always expect Success or Exception from DoGlobalExecute.\");\n    }\n\n    /**\n     * Error category for store exception.\n     */\n    @Override\n    protected ShardManagementErrorCategory getErrorCategory() {\n        return ShardManagementErrorCategory.ShardMapManagerFactory;\n    }\n}", "class_id": 0, "repo": "Blackbaud-MattWalsh/elastic-db-tools-for-java", "file": "elastic-db-tools/src/main/java/com/microsoft/azure/elasticdb/shard/storeops/mapmanagerfactory/CreateShardMapManagerGlobalOperation.java", "last_update_at": "2021-12-07T18:21:33+00:00", "question_id": "c6ec38e3aa543ebec430a9ccbdb14ad544958a43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {\n    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    /**\n     * Creation mode.\n     */\n    private ShardMapManagerCreateMode createMode;\n    /**\n     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.\n     */\n    private Version targetVersion;\n    /**\n     * Constructs request for deploying SMM storage objects to target GSM database.\n     *\n     * @param credentials\n     *            Credentials for connection.\n     * @param retryPolicy\n     *            Retry policy.\n     * @param operationName\n     *            Operation name, useful for diagnostics.\n     * @param createMode\n     *            Creation mode.\n     * @param targetVersion\n     *            target version of store to deploy\n     */\n    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials,\n            RetryPolicy retryPolicy,\n            String operationName,\n            ShardMapManagerCreateMode createMode,\n            Version targetVersion) {\n        super(credentials, retryPolicy, operationName);\n        this.createMode = createMode;\n        this.targetVersion = targetVersion;\n    }\n    /**\n     * Whether this is a read-only operation.\n     */\n    @Override\n    public boolean getReadOnly() {\n        return false;\n    }\n    /**\n     * Execute the operation against GSM in the current transaction scope.\n     *\n     * @param ts\n     *            Transaction scope.\n     * @return Results of the operation.\n     */\n    @Override\n    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {\n        log.info(\"ShardMapManagerFactory {}, Started creating Global Shard Map structures.\", this.getOperationName());\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));\n        // If we did find some store deployed.\n        if (checkResult.getStoreVersion() != null) {\n            // DevNote: We need to have a way to error out if versions do not match.\n            if (createMode == ShardMapManagerCreateMode.KeepExisting) {\n                stopwatch.stop();\n                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory,\n                        ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);\n            }\n            log.info(\"ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.\", this.getOperationName());\n            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());\n        }\n        // Deploy initial version and run upgrade script to bring it to the specified version.\n        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());\n        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));\n        stopwatch.stop();\n        log.info(\"ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}\", this.getOperationName(),\n                stopwatch.elapsed(TimeUnit.MILLISECONDS));\n        return new StoreResults();\n    }\n    /**\n     * Handles errors from the GSM operation after the LSM operations.\n     *\n     * @param result\n     *            Operation result.\n     */\n    @Override\n    public void handleDoGlobalExecuteError(StoreResults result) {\n        log.debug(\"Always expect Success or Exception from DoGlobalExecute.\");\n    }\n    /**\n     * Error category for store exception.\n     */\n    @Override\n    protected ShardManagementErrorCategory getErrorCategory() {\n        return ShardManagementErrorCategory.ShardMapManagerFactory;\n    }\n"]], "pred": {"ppl": 1.9297641515731812, "ppl_lower": 2.7972607612609863, "ppl/lowercase_ppl": -1.5647156833681872, "ppl/zlib": 0.0005344697513757668, "Min_5.0% Prob": 6.833859039389568, "Min_10.0% Prob": 4.98076185454493, "Min_20.0% Prob": 3.101366101406716, "Min_30.0% Prob": 2.160567067992344, "Min_40.0% Prob": 1.6373308593974603, "Min_50.0% Prob": 1.3132315406792572, "Min_60.0% Prob": 1.0968961204844359}}
{"hexsha": "11992b1676761a8e7bb5d9a4c39bd1a80802e4e0", "ext": "java", "lang": "Java", "content": "public class DateTest implements Predicate<Object> {\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public boolean test(Object o) {\r\n        if (!(o instanceof Map))\r\n            return false;\r\n\r\n        Map<String, Object> m = (Map<String, Object>) o;\r\n        return m.containsKey(\"$date\");\r\n    }\r\n}", "class_id": 0, "repo": "ozwolf-software/mongo-trek", "file": "src/main/java/net/ozwolf/mongo/migrations/internal/util/strict/test/DateTest.java", "last_update_at": "2021-11-05T13:13:10+00:00", "question_id": "11992b1676761a8e7bb5d9a4c39bd1a80802e4e0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DateTest implements Predicate<Object> {\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public boolean test(Object o) {\r\n        if (!(o instanceof Map))\r\n            return false;\r\n\r\n        Map<String, Object> m = (Map<String, Object>) o;\r\n        return m.containsKey(\"$date\");\r\n    }\r\n"]], "pred": {"ppl": 2.281486988067627, "ppl_lower": 2.92079758644104, "ppl/lowercase_ppl": -1.2994921136955082, "ppl/zlib": 0.00400401659288011, "Min_5.0% Prob": 7.214916229248047, "Min_10.0% Prob": 5.356695731480916, "Min_20.0% Prob": 3.5892428821987576, "Min_30.0% Prob": 2.669904915270982, "Min_40.0% Prob": 2.054953879573279, "Min_50.0% Prob": 1.6595734461314149, "Min_60.0% Prob": 1.3875474535549681}}
{"hexsha": "471abfbcd5ea2120b3ab3a2bcc2caedb5f103606", "ext": "java", "lang": "Java", "content": "public class CustomInlineFunctions {\n\t\n\t// declare log services\n\tprivate LogServices log = LogServices.getInstance(\"wbtServices\");\n\n\t\t\n\tpublic String doSample(String value) {\n\t\t\n\t\tlog.debug(\"wbtServices\", \"WebertiseInlineFunctions - doSample: got value '\" + value + \"'\");\n\t\t\n\t\t// do something\n\t\t\n\t\t\n\t\treturn value;\n\t}\n\n}", "class_id": 0, "repo": "bernfried/wbf-framework", "file": "dsextensions/src/de/webertise/ds/inlinefunctions/CustomInlineFunctions.java", "last_update_at": "2021-01-15T02:53:06+00:00", "question_id": "471abfbcd5ea2120b3ab3a2bcc2caedb5f103606", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomInlineFunctions {\n\t\n\t// declare log services\n\tprivate LogServices log = LogServices.getInstance(\"wbtServices\");\n\t\t\n\tpublic String doSample(String value) {\n\t\t\n\t\tlog.debug(\"wbtServices\", \"WebertiseInlineFunctions - doSample: got value '\" + value + \"'\");\n\t\t\n\t\t// do something\n\t\t\n\t\t\n\t\treturn value;\n\t}\n"]], "pred": {"ppl": 6.162797451019287, "ppl_lower": 8.770284652709961, "ppl/lowercase_ppl": -1.1940239099068972, "ppl/zlib": 0.008742936567874185, "Min_5.0% Prob": 9.221015739440919, "Min_10.0% Prob": 7.980250597000122, "Min_20.0% Prob": 6.410428819202242, "Min_30.0% Prob": 5.1235346756875515, "Min_40.0% Prob": 4.198675341384355, "Min_50.0% Prob": 3.509730511241489, "Min_60.0% Prob": 3.023151695728302}}
{"hexsha": "f7178660a3d266187dc4287ef23abc8f0a527d87", "ext": "java", "lang": "Java", "content": "public class AbstractDRResourceProviderTest {\n  @Test\n  public void testGetResourceProvider() throws Exception {\n    Set<String> propertyIds = new HashSet<String>();\n    propertyIds.add(\"foo\");\n    propertyIds.add(\"cat1/foo\");\n    propertyIds.add(\"cat2/bar\");\n    propertyIds.add(\"cat2/baz\");\n    propertyIds.add(\"cat3/sub1/bam\");\n    propertyIds.add(\"cat4/sub2/sub3/bat\");\n    propertyIds.add(\"cat5/subcat5/map\");\n\n    Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();\n\n    IvoryService ivoryService = createMock(IvoryService.class);\n\n    AbstractResourceProvider provider =\n        (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(\n            Resource.Type.DRFeed,\n            propertyIds,\n            keyPropertyIds,\n            ivoryService);\n\n    Assert.assertTrue(provider instanceof FeedResourceProvider);\n  }\n}", "class_id": 0, "repo": "dawnwish/ambari", "file": "ambari-server/src/test/java/org/apache/ambari/server/controller/internal/AbstractDRResourceProviderTest.java", "last_update_at": "2021-08-05T03:13:26+00:00", "question_id": "f7178660a3d266187dc4287ef23abc8f0a527d87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbstractDRResourceProviderTest {\n  @Test\n  public void testGetResourceProvider() throws Exception {\n    Set<String> propertyIds = new HashSet<String>();\n    propertyIds.add(\"foo\");\n    propertyIds.add(\"cat1/foo\");\n    propertyIds.add(\"cat2/bar\");\n    propertyIds.add(\"cat2/baz\");\n    propertyIds.add(\"cat3/sub1/bam\");\n    propertyIds.add(\"cat4/sub2/sub3/bat\");\n    propertyIds.add(\"cat5/subcat5/map\");\n    Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();\n    IvoryService ivoryService = createMock(IvoryService.class);\n    AbstractResourceProvider provider =\n        (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(\n            Resource.Type.DRFeed,\n            propertyIds,\n            keyPropertyIds,\n            ivoryService);\n    Assert.assertTrue(provider instanceof FeedResourceProvider);\n  }\n"]], "pred": {"ppl": 2.222799301147461, "ppl_lower": 3.167968273162842, "ppl/lowercase_ppl": -1.4435873749389607, "ppl/zlib": 0.0024502065890235633, "Min_5.0% Prob": 7.970385789871216, "Min_10.0% Prob": 5.545979102452596, "Min_20.0% Prob": 3.5042366057026144, "Min_30.0% Prob": 2.5473216896927036, "Min_40.0% Prob": 1.9762667059296308, "Min_50.0% Prob": 1.5960231557668698, "Min_60.0% Prob": 1.3331712464608203}}
{"hexsha": "7cbaabecd2cc61947ab6279a547d2c9290a3bb1e", "ext": "java", "lang": "Java", "content": "@Path(\"/shop\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ShoppingController {\n    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);\n    private final StylingApi stylingApi;\n\n    ShoppingController() {\n        String stylingUrl = \"http://localhost:50051\";\n        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;\n        // wavefrontJaxrsFilter = wfJaxrsClientFilter;\n        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);\n    }\n\n    @GET\n    @Path(\"/menu\")\n    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {\n        return Response.ok(stylingApi.getAllStyles()).build();\n    }\n\n    @POST\n    @Path(\"/order\")\n    @Consumes(APPLICATION_JSON)\n    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {\n        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();\n        }\n        Response deliveryResponse = stylingApi.makeShirts(\n                orderDTO.getStyleName(), orderDTO.getQuantity());\n        if (deliveryResponse.getStatus() < 400) {\n            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);\n            return Response.ok().entity(deliveryStatus).build();\n        } else {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(deliveryResponse.getStatus()).entity(msg).build();\n        }\n    }\n}", "class_id": 0, "repo": "scrogatl/otel-demo-app-java", "file": "shopping/src/main/java/com/wfsample/shopping/ShoppingController.java", "last_update_at": "2021-06-21T13:56:10+00:00", "question_id": "7cbaabecd2cc61947ab6279a547d2c9290a3bb1e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Path(\"/shop\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ShoppingController {\n    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);\n    private final StylingApi stylingApi;\n    ShoppingController() {\n        String stylingUrl = \"http://localhost:50051\";\n        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;\n        // wavefrontJaxrsFilter = wfJaxrsClientFilter;\n        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);\n    }\n    @GET\n    @Path(\"/menu\")\n    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {\n        return Response.ok(stylingApi.getAllStyles()).build();\n    }\n    @POST\n    @Path(\"/order\")\n    @Consumes(APPLICATION_JSON)\n    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {\n        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();\n        }\n        Response deliveryResponse = stylingApi.makeShirts(\n                orderDTO.getStyleName(), orderDTO.getQuantity());\n        if (deliveryResponse.getStatus() < 400) {\n            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);\n            return Response.ok().entity(deliveryStatus).build();\n        } else {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(deliveryResponse.getStatus()).entity(msg).build();\n        }\n    }\n"]], "pred": {"ppl": 2.00252628326416, "ppl_lower": 2.589902400970459, "ppl/lowercase_ppl": -1.3704019855454628, "ppl/zlib": 0.001088416183541991, "Min_5.0% Prob": 6.617933335511581, "Min_10.0% Prob": 4.811926760572068, "Min_20.0% Prob": 3.0888088841187327, "Min_30.0% Prob": 2.2287281483828605, "Min_40.0% Prob": 1.713768298635308, "Min_50.0% Prob": 1.384206514041793, "Min_60.0% Prob": 1.1571231812485314}}
{"hexsha": "d8c97610050943cdf2ccaade422a76ac48e11c71", "ext": "java", "lang": "Java", "content": "public class B_SuperClass {\n    public static void main(String[] args) {\n        Class<?> clazz = Example_B_SuperClass.class;\n        Class<?> superclass = clazz.getSuperclass();\n        System.out.println(superclass);\n    }\n}", "class_id": 0, "repo": "lsieun/learn-java", "file": "Reflection/code/learn-reflection/src/main/java/lsieun/reflection/a_clazz/B_SuperClass.java", "last_update_at": "2021-03-24T23:13:33+00:00", "question_id": "d8c97610050943cdf2ccaade422a76ac48e11c71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class B_SuperClass {\n    public static void main(String[] args) {\n        Class<?> clazz = Example_B_SuperClass.class;\n        Class<?> superclass = clazz.getSuperclass();\n        System.out.println(superclass);\n    }\n"]], "pred": {"ppl": 2.6718835830688477, "ppl_lower": 4.0568108558654785, "ppl/lowercase_ppl": -1.4249291905264314, "ppl/zlib": 0.006824886704961618, "Min_5.0% Prob": 8.12165117263794, "Min_10.0% Prob": 6.7455055713653564, "Min_20.0% Prob": 4.416896430345682, "Min_30.0% Prob": 3.089755338430405, "Min_40.0% Prob": 2.4488796431284685, "Min_50.0% Prob": 1.9655192133152124, "Min_60.0% Prob": 1.635608027689159}}
{"hexsha": "21ca9661f3376f46943fd2a0ddc93a92bb03a6a3", "ext": "java", "lang": "Java", "content": "public class MvnModelFactory {\r\n    \r\n    public Model createModel(Project project) throws MvnModelInputException{\r\n        return createModel(project.getProjectDirectory());\r\n    }\r\n    \r\n    public Model createModel(FileObject projectDir) throws MvnModelInputException {\r\n        FileObject pomFile = projectDir.getFileObject(\"pom.xml\");\r\n        MavenXpp3Reader mavenreader = new MavenXpp3Reader();\r\n        try(Reader reader=new InputStreamReader(pomFile.getInputStream())){\r\n            Model model = mavenreader.read(reader);\r\n            model.setPomFile(new File(pomFile.getPath()));\r\n            return model;\r\n        }catch(XmlPullParserException | IOException ex) {\r\n            throw new MvnModelInputException(ex);\r\n        }\r\n    }\r\n    \r\n}", "class_id": 0, "repo": "hmvictor/radar-netbeans", "file": "src/main/java/qubexplorer/MvnModelFactory.java", "last_update_at": "2021-11-14T19:52:07+00:00", "question_id": "21ca9661f3376f46943fd2a0ddc93a92bb03a6a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MvnModelFactory {\r\n    \r\n    public Model createModel(Project project) throws MvnModelInputException{\r\n        return createModel(project.getProjectDirectory());\r\n    }\r\n    \r\n    public Model createModel(FileObject projectDir) throws MvnModelInputException {\r\n        FileObject pomFile = projectDir.getFileObject(\"pom.xml\");\r\n        MavenXpp3Reader mavenreader = new MavenXpp3Reader();\r\n        try(Reader reader=new InputStreamReader(pomFile.getInputStream())){\r\n            Model model = mavenreader.read(reader);\r\n            model.setPomFile(new File(pomFile.getPath()));\r\n            return model;\r\n        }catch(XmlPullParserException | IOException ex) {\r\n            throw new MvnModelInputException(ex);\r\n        }\r\n    }\r\n    \r\n"]], "pred": {"ppl": 2.251532793045044, "ppl_lower": 2.5761771202087402, "ppl/lowercase_ppl": -1.1659604177957303, "ppl/zlib": 0.0026697737685201406, "Min_5.0% Prob": 6.727521737416585, "Min_10.0% Prob": 5.268473851053338, "Min_20.0% Prob": 3.586032029829527, "Min_30.0% Prob": 2.6109257622769007, "Min_40.0% Prob": 2.006084135019934, "Min_50.0% Prob": 1.625229539660116, "Min_60.0% Prob": 1.3604158752881315}}
{"hexsha": "3037ceb3997c55c745d234f6205a58fc66497019", "ext": "java", "lang": "Java", "content": "public class PushNotificationCallback{\n    private String email;\n    private String url;\n\n    public PushNotificationCallback(Context appContext){\n        Breadcaster caster = new Breadcaster(appContext)\n                .action(\"1\", new Execution() {\n                    @Override\n                    public void exec(Context context, Intent intent) {\n                        String email = intent.getStringExtra(\"email\");\n                        if(email != null){\n                            PushNotificationCallback.this.email = email;\n                            String url = intent.getStringExtra(\"url\");\n                            PushNotificationCallback.this.url = url;\n                        }\n\n                        System.out.println(\"****PUSH_NOTIFICATION_CALLBACK_INVOKED*****\");\n                        System.out.println(email+\":\"+MyFirebaseMessagingService.pushToken+\":\"+url);\n\n                        if(PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null){\n                            return;\n                        }\n                        Thread t = new Thread(()->{\n                            URL urlValue = null;\n                            HttpsURLConnection urlConnection = null;\n                            String json = null;\n                            OutputStreamWriter writer = null;\n                            BufferedReader reader = null;\n                            try {\n                                urlValue = new URL(PushNotificationCallback.this.url);\n                                urlConnection = (HttpsURLConnection) urlValue.openConnection();\n                                urlConnection.setDoOutput(true);\n\n                                JSONObject jsonObject = new JSONObject();\n                                jsonObject.put(\"email\",PushNotificationCallback.this.email);\n                                jsonObject.put(\"pushToken\",MyFirebaseMessagingService.pushToken);\n                                json = jsonObject.toString();\n\n                                writer = new OutputStreamWriter(urlConnection.getOutputStream());\n                                writer.write(json);\n                                writer.flush();\n\n                                reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                                StringBuilder sb = new StringBuilder();\n                                String line = null;\n                                // Read Server Response\n                                while((line = reader.readLine()) != null)\n                                {\n                                    // Append server response in string\n                                    sb.append(line + \"\\n\");\n                                }\n                                System.out.println(\"TOKEN_REGISTRATION_SUCCESS: \"+sb);\n                            }catch(Exception e){\n                                //e.printStackTrace();\n                            }finally {\n                                if(urlConnection != null) {\n                                    urlConnection.disconnect();\n                                }\n                                try {\n                                    if(writer != null) {\n                                        writer.close();\n                                    }\n                                    if(reader != null) {\n                                        reader.close();\n                                    }\n                                }catch(Exception e){}\n                            }\n                        });\n                        t.start();\n                    }\n                }).register();\n    }\n}", "class_id": 0, "repo": "slydogshah/appGalCloud", "file": "jennetapp/android/app/src/main/java/io/appgallabs/jennetwork/PushNotificationCallback.java", "last_update_at": "2021-06-17T13:29:02+00:00", "question_id": "3037ceb3997c55c745d234f6205a58fc66497019", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PushNotificationCallback{\n    private String email;\n    private String url;\n    public PushNotificationCallback(Context appContext){\n        Breadcaster caster = new Breadcaster(appContext)\n                .action(\"1\", new Execution() {\n                    @Override\n                    public void exec(Context context, Intent intent) {\n                        String email = intent.getStringExtra(\"email\");\n                        if(email != null){\n                            PushNotificationCallback.this.email = email;\n                            String url = intent.getStringExtra(\"url\");\n                            PushNotificationCallback.this.url = url;\n                        }\n                        System.out.println(\"****PUSH_NOTIFICATION_CALLBACK_INVOKED*****\");\n                        System.out.println(email+\":\"+MyFirebaseMessagingService.pushToken+\":\"+url);\n                        if(PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null){\n                            return;\n                        }\n                        Thread t = new Thread(()->{\n                            URL urlValue = null;\n                            HttpsURLConnection urlConnection = null;\n                            String json = null;\n                            OutputStreamWriter writer = null;\n                            BufferedReader reader = null;\n                            try {\n                                urlValue = new URL(PushNotificationCallback.this.url);\n                                urlConnection = (HttpsURLConnection) urlValue.openConnection();\n                                urlConnection.setDoOutput(true);\n                                JSONObject jsonObject = new JSONObject();\n                                jsonObject.put(\"email\",PushNotificationCallback.this.email);\n                                jsonObject.put(\"pushToken\",MyFirebaseMessagingService.pushToken);\n                                json = jsonObject.toString();\n                                writer = new OutputStreamWriter(urlConnection.getOutputStream());\n                                writer.write(json);\n                                writer.flush();\n                                reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                                StringBuilder sb = new StringBuilder();\n                                String line = null;\n                                // Read Server Response\n                                while((line = reader.readLine()) != null)\n                                {\n                                    // Append server response in string\n                                    sb.append(line + \"\\n\");\n                                }\n                                System.out.println(\"TOKEN_REGISTRATION_SUCCESS: \"+sb);\n                            }catch(Exception e){\n                                //e.printStackTrace();\n                            }finally {\n                                if(urlConnection != null) {\n                                    urlConnection.disconnect();\n                                }\n                                try {\n                                    if(writer != null) {\n                                        writer.close();\n                                    }\n                                    if(reader != null) {\n                                        reader.close();\n                                    }\n                                }catch(Exception e){}\n                            }\n                        });\n                        t.start();\n                    }\n                }).register();\n    }\n"]], "pred": {"ppl": 1.794232964515686, "ppl_lower": 2.093003749847412, "ppl/lowercase_ppl": -1.2634767717908277, "ppl/zlib": 0.0006627864090650861, "Min_5.0% Prob": 6.157591349737984, "Min_10.0% Prob": 4.468969225883484, "Min_20.0% Prob": 2.730462128177602, "Min_30.0% Prob": 1.9091943210026003, "Min_40.0% Prob": 1.45563819835372, "Min_50.0% Prob": 1.1677627684363816, "Min_60.0% Prob": 0.9738833095761947}}
{"hexsha": "27a89c084d6ab746c2199fdd9f7518ada1b9eea9", "ext": "java", "lang": "Java", "content": "public class ArrayTypeReference extends SingleTypeReference {\n\n    public int dimensions;\n\n    // jsr308 style type annotations on dimensions.\n    private Annotation[][] annotationsOnDimensions;\n\n    public int originalSourceEnd;\n\n    public int extendedDimensions;\n\n    /**\n\t * ArrayTypeReference constructor comment.\n\t * @param source char[]\n\t * @param dimensions int\n\t * @param pos int\n\t */\n    public  ArrayTypeReference(char[] source, int dimensions, long pos) {\n        super(source, pos);\n        this.originalSourceEnd = this.sourceEnd;\n        this.dimensions = dimensions;\n        this.annotationsOnDimensions = null;\n    }\n\n    public  ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {\n        this(source, dimensions, pos);\n        if (annotationsOnDimensions != null) {\n            this.bits |= ASTNode.HasTypeAnnotations;\n        }\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    public int dimensions() {\n        return this.dimensions;\n    }\n\n    public int extraDimensions() {\n        return this.extendedDimensions;\n    }\n\n    /**\n\t @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)\n\t*/\n    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {\n        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)\n            return this.annotationsOnDimensions;\n        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];\n        final int baseDimensions = this.dimensions - this.extendedDimensions;\n        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);\n        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);\n        return externalAnnotations;\n    }\n\n    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    /**\n\t * @return char[][]\n\t */\n    public char[][] getParameterizedTypeName() {\n        int dim = this.dimensions;\n        char[] dimChars = new char[dim * 2];\n        for (int i = 0; i < dim; i++) {\n            int index = i * 2;\n            dimChars[index] = '[';\n            dimChars[index + 1] = ']';\n        }\n        return new char[][] { CharOperation.concat(this.token, dimChars) };\n    }\n\n    protected TypeBinding getTypeBinding(Scope scope) {\n        if (this.resolvedType != null) {\n            return this.resolvedType;\n        }\n        if (this.dimensions > 255) {\n            scope.problemReporter().tooManyDimensions(this);\n        }\n        TypeBinding leafComponentType = scope.getType(this.token);\n        return scope.createArrayType(leafComponentType, this.dimensions);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        super.printExpression(indent, output);\n        if ((this.bits & IsVarArgs) != 0) {\n            for (int i = 0; i < this.dimensions - 1; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    output.append(' ');\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    output.append(' ');\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {\n                output.append(' ');\n                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);\n                output.append(' ');\n            }\n            //$NON-NLS-1$\n            output.append(\"...\");\n        } else {\n            for (int i = 0; i < this.dimensions; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n        }\n        return output;\n    }\n\n    public void traverse(ASTVisitor visitor, BlockScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    public void traverse(ASTVisitor visitor, ClassScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    protected TypeBinding internalResolveType(Scope scope, int location) {\n        TypeBinding internalResolveType = super.internalResolveType(scope, location);\n        return internalResolveType;\n    }\n\n    @Override\n    public boolean hasNullTypeAnnotation(AnnotationPosition position) {\n        switch(position) {\n            case LEAF_TYPE:\n                // ignore annotationsOnDimensions:\n                return super.hasNullTypeAnnotation(position);\n            case MAIN_TYPE:\n                // outermost dimension only:\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {\n                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];\n                    return containsNullAnnotation(innerAnnotations);\n                }\n                break;\n            case ANY:\n                if (super.hasNullTypeAnnotation(position))\n                    return true;\n                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())\n                    // shortcut\n                    return false;\n                if (this.annotationsOnDimensions != null) {\n                    for (int i = 0; i < this.annotationsOnDimensions.length; i++) {\n                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];\n                        if (containsNullAnnotation(innerAnnotations))\n                            return true;\n                    }\n                }\n        }\n        return false;\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.core/4509.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "27a89c084d6ab746c2199fdd9f7518ada1b9eea9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayTypeReference extends SingleTypeReference {\n    public int dimensions;\n    // jsr308 style type annotations on dimensions.\n    private Annotation[][] annotationsOnDimensions;\n    public int originalSourceEnd;\n    public int extendedDimensions;\n    /**\n\t * ArrayTypeReference constructor comment.\n\t * @param source char[]\n\t * @param dimensions int\n\t * @param pos int\n\t */\n    public  ArrayTypeReference(char[] source, int dimensions, long pos) {\n        super(source, pos);\n        this.originalSourceEnd = this.sourceEnd;\n        this.dimensions = dimensions;\n        this.annotationsOnDimensions = null;\n    }\n    public  ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {\n        this(source, dimensions, pos);\n        if (annotationsOnDimensions != null) {\n            this.bits |= ASTNode.HasTypeAnnotations;\n        }\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n    public int dimensions() {\n        return this.dimensions;\n    }\n    public int extraDimensions() {\n        return this.extendedDimensions;\n    }\n    /**\n\t @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)\n\t*/\n    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {\n        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)\n            return this.annotationsOnDimensions;\n        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];\n        final int baseDimensions = this.dimensions - this.extendedDimensions;\n        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);\n        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);\n        return externalAnnotations;\n    }\n    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n    /**\n\t * @return char[][]\n\t */\n    public char[][] getParameterizedTypeName() {\n        int dim = this.dimensions;\n        char[] dimChars = new char[dim * 2];\n        for (int i = 0; i < dim; i++) {\n            int index = i * 2;\n            dimChars[index] = '[';\n            dimChars[index + 1] = ']';\n        }\n        return new char[][] { CharOperation.concat(this.token, dimChars) };\n    }\n    protected TypeBinding getTypeBinding(Scope scope) {\n        if (this.resolvedType != null) {\n            return this.resolvedType;\n        }\n        if (this.dimensions > 255) {\n            scope.problemReporter().tooManyDimensions(this);\n        }\n        TypeBinding leafComponentType = scope.getType(this.token);\n        return scope.createArrayType(leafComponentType, this.dimensions);\n    }\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        super.printExpression(indent, output);\n        if ((this.bits & IsVarArgs) != 0) {\n            for (int i = 0; i < this.dimensions - 1; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    output.append(' ');\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    output.append(' ');\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {\n                output.append(' ');\n                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);\n                output.append(' ');\n            }\n            //$NON-NLS-1$\n            output.append(\"...\");\n        } else {\n            for (int i = 0; i < this.dimensions; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n        }\n        return output;\n    }\n    public void traverse(ASTVisitor visitor, BlockScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n    public void traverse(ASTVisitor visitor, ClassScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n    protected TypeBinding internalResolveType(Scope scope, int location) {\n        TypeBinding internalResolveType = super.internalResolveType(scope, location);\n        return internalResolveType;\n    }\n    @Override\n    public boolean hasNullTypeAnnotation(AnnotationPosition position) {\n        switch(position) {\n            case LEAF_TYPE:\n                // ignore annotationsOnDimensions:\n                return super.hasNullTypeAnnotation(position);\n            case MAIN_TYPE:\n                // outermost dimension only:\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {\n                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];\n                    return containsNullAnnotation(innerAnnotations);\n                }\n                break;\n            case ANY:\n                if (super.hasNullTypeAnnotation(position))\n                    return true;\n                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())\n                    // shortcut\n                    return false;\n                if (this.annotationsOnDimensions != null) {\n                    for (int i = 0; i < this.annotationsOnDimensions.length; i++) {\n                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];\n                        if (containsNullAnnotation(innerAnnotations))\n                            return true;\n                    }\n                }\n        }\n        return false;\n    }\n"]], "pred": {"ppl": 1.5704745054244995, "ppl_lower": 1.9880849123001099, "ppl/lowercase_ppl": -1.5223872550335171, "ppl/zlib": 0.00029139948770274784, "Min_5.0% Prob": 5.350866607591217, "Min_10.0% Prob": 3.6120224396387735, "Min_20.0% Prob": 2.1492373379422167, "Min_30.0% Prob": 1.4875378261983785, "Min_40.0% Prob": 1.1251464465036443, "Min_50.0% Prob": 0.9029993622066224, "Min_60.0% Prob": 0.7531723509188271}}
{"hexsha": "6ba2c65ef09c9dce214c0d5ad690323d7dcafe61", "ext": "java", "lang": "Java", "content": "public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {\n\n    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext,\n                                                                         ClassLoader classLoader,\n                                                                         List<URL> resources) {\n        if (classLoader == null) {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        }\n\n        SCAGenericApplicationContext appCtx =\n            new SCAGenericApplicationContext((ApplicationContext)scaParentContext, classLoader);\n        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);\n\n        // REVIEW: [rfeng] How do we control the schema validation \n        xmlReader.setValidating(false);\n\n        for (URL resource : resources) {\n            xmlReader.loadBeanDefinitions(new UrlResource(resource));\n        }\n\n        return appCtx;\n\n    }\n\n    @Override\n    public Object load(List<URL> resources,\n                       List<SpringSCAServiceElement> serviceElements,\n                       List<SpringSCAReferenceElement> referenceElements,\n                       List<SpringSCAPropertyElement> propertyElements,\n                       List<SpringBeanElement> beanElements,\n                       ProcessorContext context) {\n        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime\n        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);\n        serviceElements.addAll(applicationContext.getServiceElements());\n        referenceElements.addAll(applicationContext.getReferenceElements());\n        propertyElements.addAll(applicationContext.getPropertyElements());\n        beanElements.addAll(applicationContext.getBeanElements());\n        return applicationContext;\n    }\n\n}", "class_id": 0, "repo": "apache/tuscany-sca-2.x", "file": "modules/implementation-spring-runtime/src/main/java/org/apache/tuscany/sca/implementation/spring/processor/SpringXMLBeanDefinitionLoaderImpl.java", "last_update_at": "2021-11-10T16:04:56+00:00", "question_id": "6ba2c65ef09c9dce214c0d5ad690323d7dcafe61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {\n    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext,\n                                                                         ClassLoader classLoader,\n                                                                         List<URL> resources) {\n        if (classLoader == null) {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        }\n        SCAGenericApplicationContext appCtx =\n            new SCAGenericApplicationContext((ApplicationContext)scaParentContext, classLoader);\n        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);\n        // REVIEW: [rfeng] How do we control the schema validation \n        xmlReader.setValidating(false);\n        for (URL resource : resources) {\n            xmlReader.loadBeanDefinitions(new UrlResource(resource));\n        }\n        return appCtx;\n    }\n    @Override\n    public Object load(List<URL> resources,\n                       List<SpringSCAServiceElement> serviceElements,\n                       List<SpringSCAReferenceElement> referenceElements,\n                       List<SpringSCAPropertyElement> propertyElements,\n                       List<SpringBeanElement> beanElements,\n                       ProcessorContext context) {\n        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime\n        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);\n        serviceElements.addAll(applicationContext.getServiceElements());\n        referenceElements.addAll(applicationContext.getReferenceElements());\n        propertyElements.addAll(applicationContext.getPropertyElements());\n        beanElements.addAll(applicationContext.getBeanElements());\n        return applicationContext;\n    }\n"]], "pred": {"ppl": 2.2634360790252686, "ppl_lower": 2.7605643272399902, "ppl/lowercase_ppl": -1.2430590708534295, "ppl/zlib": 0.0013892585843746892, "Min_5.0% Prob": 6.877496314048767, "Min_10.0% Prob": 5.444194357569625, "Min_20.0% Prob": 3.5931607717420997, "Min_30.0% Prob": 2.6303073681466946, "Min_40.0% Prob": 2.022919340876908, "Min_50.0% Prob": 1.6324387396799356, "Min_60.0% Prob": 1.3636253258569273}}
{"hexsha": "278ec218a2e650deb4500198e2ed05508b55549c", "ext": "java", "lang": "Java", "content": "public class Builders {\n    private Builders() {\n    }\n\n    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();\n\n    static {\n        map.put(User.class, new UserBuilder());\n        map.put(Content.class, new ContentBuilder());\n        map.put(Company.class, new CompanyBuilder());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {\n        K builder = (K) map.get(clazz);\n        if (builder == null) throw new IllegalArgumentException(\"No builder for entity: \" + clazz.getName());\n        return (K) builder.newInstance();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {\n        if (entity == null) throw new IllegalArgumentException(\"Entity should not be a null.\");\n\n        K builder = (K) map.get(entity.getClass());\n\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + entity.getClass().getName());\n\n        return (K) builder.newInstance(entity);\n    }\n\n\n}", "class_id": 0, "repo": "Pivopil/spring-boot-oauth2-rest-service-password-encoding", "file": "share/src/main/java/io/github/pivopil/share/builders/Builders.java", "last_update_at": "2021-04-25T08:44:09+00:00", "question_id": "278ec218a2e650deb4500198e2ed05508b55549c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Builders {\n    private Builders() {\n    }\n    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();\n    static {\n        map.put(User.class, new UserBuilder());\n        map.put(Content.class, new ContentBuilder());\n        map.put(Company.class, new CompanyBuilder());\n    }\n    @SuppressWarnings(\"unchecked\")\n    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {\n        K builder = (K) map.get(clazz);\n        if (builder == null) throw new IllegalArgumentException(\"No builder for entity: \" + clazz.getName());\n        return (K) builder.newInstance();\n    }\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {\n        if (entity == null) throw new IllegalArgumentException(\"Entity should not be a null.\");\n        K builder = (K) map.get(entity.getClass());\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + entity.getClass().getName());\n        return (K) builder.newInstance(entity);\n    }\n"]], "pred": {"ppl": 1.8117996454238892, "ppl_lower": 2.1155858039855957, "ppl/lowercase_ppl": -1.2608206942685334, "ppl/zlib": 0.0015122662354942749, "Min_5.0% Prob": 5.686674022674561, "Min_10.0% Prob": 4.230618530704129, "Min_20.0% Prob": 2.7197334900979073, "Min_30.0% Prob": 1.9164059130094384, "Min_40.0% Prob": 1.465795107606438, "Min_50.0% Prob": 1.1825430046887166, "Min_60.0% Prob": 0.9887953521433457}}
{"hexsha": "cda831809d818cc9f3aa657b63679325f432741b", "ext": "java", "lang": "Java", "content": "public class ObsidianShard extends Item {\n    public ObsidianShard() {\n        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));\n    }\n\n    @Override\n    @ParametersAreNonnullByDefault\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {\n        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);\n        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS))\n                .orElse(0D);\n        if (overworldAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.overworld_attunement_message\", String.format(\"%.2f\", overworldAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.BLUE));\n        }\n        if (netherAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.nether_attunement_message\", String.format(\"%.2f\", netherAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.RED));\n        }\n        if (endAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.end_attunement_message\", String.format(\"%.2f\", endAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.AQUA));\n        }\n    }\n}", "class_id": 0, "repo": "Pursuit-of-Glowstone/Obsidimancy", "file": "src/main/java/com/pursuitofglowstone/obsidimancy/items/ObsidianShard.java", "last_update_at": "2021-09-18T17:27:15+00:00", "question_id": "cda831809d818cc9f3aa657b63679325f432741b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ObsidianShard extends Item {\n    public ObsidianShard() {\n        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));\n    }\n    @Override\n    @ParametersAreNonnullByDefault\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {\n        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);\n        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS))\n                .orElse(0D);\n        if (overworldAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.overworld_attunement_message\", String.format(\"%.2f\", overworldAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.BLUE));\n        }\n        if (netherAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.nether_attunement_message\", String.format(\"%.2f\", netherAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.RED));\n        }\n        if (endAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.end_attunement_message\", String.format(\"%.2f\", endAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.AQUA));\n        }\n    }\n"]], "pred": {"ppl": 1.4730995893478394, "ppl_lower": 1.8873205184936523, "ppl/lowercase_ppl": -1.6396730922700427, "ppl/zlib": 0.0007030285754471545, "Min_5.0% Prob": 5.445095147405352, "Min_10.0% Prob": 3.5015409923436347, "Min_20.0% Prob": 1.911897059497626, "Min_30.0% Prob": 1.293023810120906, "Min_40.0% Prob": 0.9679812767401176, "Min_50.0% Prob": 0.7759510414425012, "Min_60.0% Prob": 0.6455747525502533}}
{"hexsha": "00bef6747de51bf67fa009897a672aaff33c027a", "ext": "java", "lang": "Java", "content": "@Component\r\npublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {\r\n\r\n    @Override\r\n    public TResponse send(TRequest request, Handler handler) {\r\n        return (TResponse) handler.handle(request);\r\n\r\n//        try {\r\n//\r\n//            ApplicationContext applicationContext = SpringbootBeanHelper.getApplicationContext();\r\n//\r\n//            // todo: find class that extend request\r\n//            Class<?> clazz = request.getClass();\r\n//\r\n//            Class<?> entityType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommand\");\r\n//\r\n//            Class<?> handlerType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommandHandler\");\r\n//\r\n//            //Reflection setting method parameters.\r\n//            Method method = handlerType.getDeclaredMethod(\"handle\",entityType);\r\n//\r\n//            //Remove the instantiated bean according to the class in the ApplicationContext\r\n//            method.invoke(applicationContext.getBean(handlerType), new Object[] {new AddInventoryCommand()});\r\n//\r\n//            return null;\r\n//        } catch (Exception ex) {\r\n//            return null;\r\n//        }\r\n    }\r\n}", "class_id": 0, "repo": "unsri-hackers/ecommerce", "file": "src/main/java/com/unsri/ecommerce/infrastructure/mediator/MediatorImpl.java", "last_update_at": "2021-07-12T08:08:01+00:00", "question_id": "00bef6747de51bf67fa009897a672aaff33c027a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\r\npublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {\r\n\r\n    @Override\r\n    public TResponse send(TRequest request, Handler handler) {\r\n        return (TResponse) handler.handle(request);\r\n\r\n//        try {\r\n//\r\n//            ApplicationContext applicationContext = SpringbootBeanHelper.getApplicationContext();\r\n//\r\n//            // todo: find class that extend request\r\n//            Class<?> clazz = request.getClass();\r\n//\r\n//            Class<?> entityType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommand\");\r\n//\r\n//            Class<?> handlerType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommandHandler\");\r\n//\r\n//            //Reflection setting method parameters.\r\n//            Method method = handlerType.getDeclaredMethod(\"handle\",entityType);\r\n//\r\n//            //Remove the instantiated bean according to the class in the ApplicationContext\r\n//            method.invoke(applicationContext.getBean(handlerType), new Object[] {new AddInventoryCommand()});\r\n//\r\n//            return null;\r\n//        } catch (Exception ex) {\r\n//            return null;\r\n//        }\r\n    }\r\n"]], "pred": {"ppl": 2.9274163246154785, "ppl_lower": 3.5460588932037354, "ppl/lowercase_ppl": -1.1784870783866883, "ppl/zlib": 0.002205585695157496, "Min_5.0% Prob": 8.479877293109894, "Min_10.0% Prob": 6.713027238845825, "Min_20.0% Prob": 4.610902834683657, "Min_30.0% Prob": 3.3911789810905852, "Min_40.0% Prob": 2.634425157797523, "Min_50.0% Prob": 2.1334470829926433, "Min_60.0% Prob": 1.786110771393093}}
{"hexsha": "0d702eb90f1c4fb17696cc6f6afccd963790a157", "ext": "java", "lang": "Java", "content": "@ExtendWith(SiriusExtension.class)\nclass XMLReaderTest {\n\n    @Test\n    @DisplayName(\"XMLReader extracts XPATH expression\")\n    void readXpath() throws Exception {\n        ValueHolder<String> readString = ValueHolder.of(null);\n        Counter nodeCount = new Counter();\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            nodeCount.inc();\n            readString.set(node.queryString(\"value\"));\n        });\n\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n\n        assertEquals(\"5\", readString.get());\n        assertEquals(3, nodeCount.getCount(), \"parsed invalid count of nodes\");\n    }\n\n    @Test\n    @DisplayName(\"XMLReader supports compound XPATH paths\")\n    void readXpathCompound() throws Exception {\n        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);\n        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"doc/test/value\", node -> shouldToggle.set(true));\n        reader.addHandler(\"value\", node -> shouldNotToggle.set(true));\n\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n\n        assertTrue(shouldToggle.get());\n        assertFalse(shouldNotToggle.get());\n    }\n\n    @Test\n    @DisplayName(\"XMLReader reads attributes\")\n    void readXpathAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n\n        reader.parse(new ByteArrayInputStream(\"<doc><test namedAttribute=\\\"abc\\\" namedAttribute2=\\\"xyz\\\">1</test></doc>\".getBytes()));\n\n        assertEquals(2, attributes.size());\n        assertEquals(\"abc\", attribute.get());\n    }\n\n    @Test\n    @DisplayName(\"reading non existing attributes does not throw errors\")\n    void readXpathMissingAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"wrongValue\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n\n        reader.parse(new ByteArrayInputStream(\"<doc><test>1</test></doc>\".getBytes()));\n\n        assertEquals(0, attributes.size());\n        assertEquals(\"\", attribute.get());\n    }\n}", "class_id": 0, "repo": "scireum/sirius-kernel", "file": "src/test/java/sirius/kernel/xml/XMLReaderTest.java", "last_update_at": "2021-11-24T01:29:39+00:00", "question_id": "0d702eb90f1c4fb17696cc6f6afccd963790a157", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(SiriusExtension.class)\nclass XMLReaderTest {\n    @Test\n    @DisplayName(\"XMLReader extracts XPATH expression\")\n    void readXpath() throws Exception {\n        ValueHolder<String> readString = ValueHolder.of(null);\n        Counter nodeCount = new Counter();\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            nodeCount.inc();\n            readString.set(node.queryString(\"value\"));\n        });\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertEquals(\"5\", readString.get());\n        assertEquals(3, nodeCount.getCount(), \"parsed invalid count of nodes\");\n    }\n    @Test\n    @DisplayName(\"XMLReader supports compound XPATH paths\")\n    void readXpathCompound() throws Exception {\n        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);\n        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"doc/test/value\", node -> shouldToggle.set(true));\n        reader.addHandler(\"value\", node -> shouldNotToggle.set(true));\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertTrue(shouldToggle.get());\n        assertFalse(shouldNotToggle.get());\n    }\n    @Test\n    @DisplayName(\"XMLReader reads attributes\")\n    void readXpathAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test namedAttribute=\\\"abc\\\" namedAttribute2=\\\"xyz\\\">1</test></doc>\".getBytes()));\n        assertEquals(2, attributes.size());\n        assertEquals(\"abc\", attribute.get());\n    }\n    @Test\n    @DisplayName(\"reading non existing attributes does not throw errors\")\n    void readXpathMissingAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"wrongValue\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test>1</test></doc>\".getBytes()));\n        assertEquals(0, attributes.size());\n        assertEquals(\"\", attribute.get());\n    }\n"]], "pred": {"ppl": 1.8370444774627686, "ppl_lower": 2.0596182346343994, "ppl/lowercase_ppl": -1.1880475490061466, "ppl/zlib": 0.0008917272990470669, "Min_5.0% Prob": 6.699890484681001, "Min_10.0% Prob": 4.691570145289103, "Min_20.0% Prob": 2.8470113611221315, "Min_30.0% Prob": 1.9897825578186248, "Min_40.0% Prob": 1.5114226759225131, "Min_50.0% Prob": 1.2138266915927332, "Min_60.0% Prob": 1.0129241621690905}}
{"hexsha": "16a60673c47ed31ef3e70caf496702cafa6f7bfd", "ext": "java", "lang": "Java", "content": "public class KeyItem extends Item {\n    public static final String ID = \"lock_key\";\n    public static final String TEX_BASE = \"lock_key_\";\n    private static final int ICONS_COUNT = 3;\n\n    private IIcon[] icons = new IIcon[ICONS_COUNT];\n\n    public KeyItem() {\n        setUnlocalizedName(ID);\n    }\n\n    @Override\n    public boolean showDurabilityBar(ItemStack stack) {\n        return false;\n    }\n\n    @Override\n    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {\n        if (!itemStack.hasTagCompound())\n            return false;\n\n        final LockObject lock = LockObject.find(world, x, y, z);\n        if (lock == null || lock.getLockType() == LockType.DIGITAL)\n            return false;\n\n        final String secret = itemStack.getTagCompound().getString(\"secret\");\n        if (lock.canUnlockWith(secret)) {\n            lock.toggleLocked();\n\n            if (!world.isRemote) {\n                final String msg = lock.isLocked() ? \"more.lock.locked\" : \"more.lock.unlocked\";\n                player.addChatMessage(new ChatComponentTranslation(msg));\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public IIcon getIconIndex(ItemStack stack) {\n        if (!stack.hasTagCompound() || stack.getTagCompound().getString(\"secret\").isEmpty())\n            return icons[0];\n\n        final String secret = stack.getTagCompound().getString(\"secret\");\n        final int iconId = secret.charAt(1) % ICONS_COUNT; // use second char, because first one can be minus\n        return icons[iconId];\n    }\n\n    @Override\n    public void registerIcons(IIconRegister p_94581_1_) {\n        for (int i = 0; i < ICONS_COUNT; ++i)\n            icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + \":\" + TEX_BASE + (i + 1));\n    }\n\n    public static ItemStack makeKeyItem(String secret) {\n        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);\n\n        final NBTTagCompound compound = new NBTTagCompound();\n        compound.setString(\"secret\", secret);\n        stack.setTagCompound(compound);\n\n        return stack;\n    }\n}", "class_id": 0, "repo": "msifd/more", "file": "src/main/java/msifeed/mc/extensions/locks/items/KeyItem.java", "last_update_at": "2021-01-25T21:18:39+00:00", "question_id": "16a60673c47ed31ef3e70caf496702cafa6f7bfd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KeyItem extends Item {\n    public static final String ID = \"lock_key\";\n    public static final String TEX_BASE = \"lock_key_\";\n    private static final int ICONS_COUNT = 3;\n    private IIcon[] icons = new IIcon[ICONS_COUNT];\n    public KeyItem() {\n        setUnlocalizedName(ID);\n    }\n    @Override\n    public boolean showDurabilityBar(ItemStack stack) {\n        return false;\n    }\n    @Override\n    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {\n        if (!itemStack.hasTagCompound())\n            return false;\n        final LockObject lock = LockObject.find(world, x, y, z);\n        if (lock == null || lock.getLockType() == LockType.DIGITAL)\n            return false;\n        final String secret = itemStack.getTagCompound().getString(\"secret\");\n        if (lock.canUnlockWith(secret)) {\n            lock.toggleLocked();\n            if (!world.isRemote) {\n                final String msg = lock.isLocked() ? \"more.lock.locked\" : \"more.lock.unlocked\";\n                player.addChatMessage(new ChatComponentTranslation(msg));\n            }\n        }\n        return true;\n    }\n    @Override\n    public IIcon getIconIndex(ItemStack stack) {\n        if (!stack.hasTagCompound() || stack.getTagCompound().getString(\"secret\").isEmpty())\n            return icons[0];\n        final String secret = stack.getTagCompound().getString(\"secret\");\n        final int iconId = secret.charAt(1) % ICONS_COUNT; // use second char, because first one can be minus\n        return icons[iconId];\n    }\n    @Override\n    public void registerIcons(IIconRegister p_94581_1_) {\n        for (int i = 0; i < ICONS_COUNT; ++i)\n            icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + \":\" + TEX_BASE + (i + 1));\n    }\n    public static ItemStack makeKeyItem(String secret) {\n        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);\n        final NBTTagCompound compound = new NBTTagCompound();\n        compound.setString(\"secret\", secret);\n        stack.setTagCompound(compound);\n        return stack;\n    }\n"]], "pred": {"ppl": 1.7103006839752197, "ppl_lower": 2.0759215354919434, "ppl/lowercase_ppl": -1.3609970112709155, "ppl/zlib": 0.0006536774587561228, "Min_5.0% Prob": 5.58309530466795, "Min_10.0% Prob": 3.8195581436157227, "Min_20.0% Prob": 2.4141247423795553, "Min_30.0% Prob": 1.7318526877432454, "Min_40.0% Prob": 1.3330303483653343, "Min_50.0% Prob": 1.070671220264463, "Min_60.0% Prob": 0.8946683716447074}}
{"hexsha": "ce0aae2d035d5e83776bce459265e8dafe8ff912", "ext": "java", "lang": "Java", "content": "public final class MethodHandlerScanner implements EventHandlerScanner {\n    private final AnnotatedListenerPredicate annotatedListenerPredicate =\n            new AnnotatedListenerPredicate();\n    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();\n\n    @Override\n    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {\n        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();\n        Stream.of(listenerContainer.getClass().getDeclaredMethods())\n                .filter(annotatedListenerPredicate).forEach(method -> eventHandlers\n                .computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>())\n                .add(new MethodEventHandler(listenerContainer, method,\n                        filterScanner.scan(method))));\n        return eventHandlers;\n    }\n}", "class_id": 0, "repo": "GentlemanMC/Zenith-Public", "file": "src/main/java/team/stiff/pomelo/impl/annotated/handler/scan/MethodHandlerScanner.java", "last_update_at": "2021-12-19T18:11:35+00:00", "question_id": "ce0aae2d035d5e83776bce459265e8dafe8ff912", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class MethodHandlerScanner implements EventHandlerScanner {\n    private final AnnotatedListenerPredicate annotatedListenerPredicate =\n            new AnnotatedListenerPredicate();\n    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();\n    @Override\n    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {\n        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();\n        Stream.of(listenerContainer.getClass().getDeclaredMethods())\n                .filter(annotatedListenerPredicate).forEach(method -> eventHandlers\n                .computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>())\n                .add(new MethodEventHandler(listenerContainer, method,\n                        filterScanner.scan(method))));\n        return eventHandlers;\n    }\n"]], "pred": {"ppl": 2.4072914123535156, "ppl_lower": 3.139399766921997, "ppl/lowercase_ppl": -1.3022523999941602, "ppl/zlib": 0.002453916816116324, "Min_5.0% Prob": 7.1004866600036625, "Min_10.0% Prob": 5.846337532997131, "Min_20.0% Prob": 3.773764778928059, "Min_30.0% Prob": 2.781648185898046, "Min_40.0% Prob": 2.152470721340761, "Min_50.0% Prob": 1.753161333428294, "Min_60.0% Prob": 1.4611979952248615}}
{"hexsha": "daf88f1a21c8768696553c46d83f94aec56a5ffe", "ext": "java", "lang": "Java", "content": "public class HttpClientHelper {\n\n    public static final String DEFAULT_URL = \"http://localhost:7493/go/\";\n    private String baseUrl = DEFAULT_URL;\n\n    public HttpClientHelper() {\n    }\n\n    public HttpClientHelper(String baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {\n        return httpRequest(path, methodRequired, null);\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, params);\n        return method.getResponseBodyAsString();\n    }\n\n\n    public int httpRequestForHeaders(final String path, RequestMethod methodRequired)\n            throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, \"\");\n        return method.getStatusCode();\n\n    }\n\n    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {\n        HttpMethod method = null;\n        String url = baseUrl + path;\n        switch (methodRequired) {\n            case PUT:\n                method = new PutMethod(url);\n                break;\n            case POST:\n                method = new PostMethod(url);\n                break;\n            case GET:\n                method = new GetMethod(url);\n                break;\n        }\n        method.setQueryString(params);\n        HttpClient client = new HttpClient();\n        client.executeMethod(method);\n        return method;\n    }\n\n    public static boolean isRedirect(int statusCode) {\n        return statusCode >= 300 && statusCode < 400;\n    }\n}", "class_id": 0, "repo": "refdiff-data/gocd", "file": "server/test/common/com/thoughtworks/go/helpers/HttpClientHelper.java", "last_update_at": "2021-08-14T13:50:46+00:00", "question_id": "daf88f1a21c8768696553c46d83f94aec56a5ffe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HttpClientHelper {\n    public static final String DEFAULT_URL = \"http://localhost:7493/go/\";\n    private String baseUrl = DEFAULT_URL;\n    public HttpClientHelper() {\n    }\n    public HttpClientHelper(String baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {\n        return httpRequest(path, methodRequired, null);\n    }\n    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, params);\n        return method.getResponseBodyAsString();\n    }\n    public int httpRequestForHeaders(final String path, RequestMethod methodRequired)\n            throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, \"\");\n        return method.getStatusCode();\n    }\n    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {\n        HttpMethod method = null;\n        String url = baseUrl + path;\n        switch (methodRequired) {\n            case PUT:\n                method = new PutMethod(url);\n                break;\n            case POST:\n                method = new PostMethod(url);\n                break;\n            case GET:\n                method = new GetMethod(url);\n                break;\n        }\n        method.setQueryString(params);\n        HttpClient client = new HttpClient();\n        client.executeMethod(method);\n        return method;\n    }\n    public static boolean isRedirect(int statusCode) {\n        return statusCode >= 300 && statusCode < 400;\n    }\n"]], "pred": {"ppl": 1.7741222381591797, "ppl_lower": 2.135343551635742, "ppl/lowercase_ppl": -1.3232511605191035, "ppl/zlib": 0.0011700118100041012, "Min_5.0% Prob": 5.912464141845703, "Min_10.0% Prob": 4.299416428804397, "Min_20.0% Prob": 2.600590229034424, "Min_30.0% Prob": 1.8491407690233872, "Min_40.0% Prob": 1.4217477543394508, "Min_50.0% Prob": 1.1437813285554719, "Min_60.0% Prob": 0.9545411997680843}}
{"hexsha": "969a8d791f5bc2edfa349e8c2e0c99f9951846c6", "ext": "java", "lang": "Java", "content": "@Component\npublic class StartCommandHandler implements ICommandHandler {\n\n    private final UserService userService;\n\n    public StartCommandHandler(UserService userService) {\n        this.userService = userService;\n    }\n\n    @Override\n    public boolean accept(String command) {\n        return Objects.equals(command, \"/start\");\n    }\n\n    @Override\n    public SendMessage handle(User user, String[] args) {\n        String chatId = user.getId().toString();\n\n        if (args == null || args.length == 0) {\n            userService.resetUser(user);\n            return new SendMessage(chatId, getHelpMessage());\n        }\n\n        String botAnswer;\n\n        if (args[0].equals(\"leaveFeedback\")) {\n            Long eventId = Long.parseLong(args[1]);\n            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;\n            user.setConversationStatus(ConversationStatus.LeaveFeedback);\n            user.setSelectedEventId(eventId);\n            user.setSelectedFeedbackId(feedbackId);\n            userService.insertOrUpdate(user);\n            botAnswer = \"Write your message\";\n        }\n        else {\n            botAnswer = \"Something went wrong!\";\n        }\n\n        return new SendMessage(chatId, botAnswer);\n    }\n}", "class_id": 0, "repo": "animolos/mutual_feedback_bot", "file": "src/main/java/ru/home/mutual_feedback_bot/api/command_handlers/StartCommandHandler.java", "last_update_at": "2021-11-06T12:16:30+00:00", "question_id": "969a8d791f5bc2edfa349e8c2e0c99f9951846c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class StartCommandHandler implements ICommandHandler {\n    private final UserService userService;\n    public StartCommandHandler(UserService userService) {\n        this.userService = userService;\n    }\n    @Override\n    public boolean accept(String command) {\n        return Objects.equals(command, \"/start\");\n    }\n    @Override\n    public SendMessage handle(User user, String[] args) {\n        String chatId = user.getId().toString();\n        if (args == null || args.length == 0) {\n            userService.resetUser(user);\n            return new SendMessage(chatId, getHelpMessage());\n        }\n        String botAnswer;\n        if (args[0].equals(\"leaveFeedback\")) {\n            Long eventId = Long.parseLong(args[1]);\n            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;\n            user.setConversationStatus(ConversationStatus.LeaveFeedback);\n            user.setSelectedEventId(eventId);\n            user.setSelectedFeedbackId(feedbackId);\n            userService.insertOrUpdate(user);\n            botAnswer = \"Write your message\";\n        }\n        else {\n            botAnswer = \"Something went wrong!\";\n        }\n        return new SendMessage(chatId, botAnswer);\n    }\n"]], "pred": {"ppl": 2.18630313873291, "ppl_lower": 2.603151321411133, "ppl/lowercase_ppl": -1.223098971943369, "ppl/zlib": 0.0015963511284419472, "Min_5.0% Prob": 6.646308749914169, "Min_10.0% Prob": 5.238138906657696, "Min_20.0% Prob": 3.509819657068986, "Min_30.0% Prob": 2.519741571375302, "Min_40.0% Prob": 1.9402686570778147, "Min_50.0% Prob": 1.5631130901960337, "Min_60.0% Prob": 1.3048407764972996}}
{"hexsha": "6dc842b708c83d823cc7570e2b26a376f97948f7", "ext": "java", "lang": "Java", "content": "public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate ModelVersion sinceVersion;\n\tprivate ModelVersion deprecatedVersion;\n\n\tprotected VersionableSurveyObject(Survey survey, int id) {\n\t\tsuper(survey, id);\n\t}\n\n\tprotected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {\n\t\tsuper(survey, source, id);\n\t\tif (survey == source.getSurvey()) {\n\t\t\tthis.sinceVersion = source.sinceVersion;\n\t\t\tthis.deprecatedVersion = source.deprecatedVersion;\n\t\t}\n\t}\n\t\n\tpublic void removeVersioning(ModelVersion version) {\n\t\tint versionId = version.getId();\n\t\tif ( sinceVersion != null && sinceVersion.getId() == versionId ) {\n\t\t\tsinceVersion = null;\n\t\t}\n\t\tif ( deprecatedVersion != null && deprecatedVersion.getId() == versionId ) {\n\t\t\tdeprecatedVersion = null;\n\t\t}\n\t}\n\n\tpublic String getSinceVersionName() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getName();\n\t}\n\t\n\tpublic Integer getSinceVersionId() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getId();\n\t}\n\t\n\tpublic void setSinceVersionByName(String name) {\n\t\tthis.sinceVersion = name == null ? null : findVersion(name);\n\t}\n\n\tpublic String getDeprecatedVersionName() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getName();\n\t}\n\t\n\tpublic Integer getDeprecatedVersionId() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getId();\n\t}\n\t\n\tpublic void setDeprecatedVersionByName(String name) {\n\t\tthis.deprecatedVersion = name == null ? null : findVersion(name);\n\t}\n\n\tpublic ModelVersion getSinceVersion() {\n\t\treturn this.sinceVersion;\n\t}\n\n\tpublic void setSinceVersion(ModelVersion since) {\n\t\tthis.sinceVersion = since;\n\t}\n\n\tpublic ModelVersion getDeprecatedVersion() {\n\t\treturn this.deprecatedVersion;\n\t}\n\n\tpublic void setDeprecatedVersion(ModelVersion deprecated) {\n\t\tthis.deprecatedVersion = deprecated;\n\t}\n\n\tprivate ModelVersion findVersion(String name) {\n\t\tif ( name == null ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tSurvey survey = getSurvey();\n\t\t\tif ( survey == null ) {\n\t\t\t\tthrow new IllegalStateException(\"Survey not set!\");\n\t\t\t} \n\t\t\tModelVersion v = survey.getVersion(name);\n\t\t\tif ( v == null ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Undefined version '\"+name+\"' in \"+toString());\n\t\t\t} \n\t\t\treturn v;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean deepEquals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.deepEquals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tVersionableSurveyObject other = (VersionableSurveyObject) obj;\n\t\tif (deprecatedVersion == null) {\n\t\t\tif (other.deprecatedVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))\n\t\t\treturn false;\n\t\tif (sinceVersion == null) {\n\t\t\tif (other.sinceVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!sinceVersion.deepEquals(other.sinceVersion))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}", "class_id": 0, "repo": "jadedevin13/collect", "file": "collect-core/src/main/java/org/openforis/idm/metamodel/VersionableSurveyObject.java", "last_update_at": "2021-10-05T13:25:16+00:00", "question_id": "6dc842b708c83d823cc7570e2b26a376f97948f7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate ModelVersion sinceVersion;\n\tprivate ModelVersion deprecatedVersion;\n\tprotected VersionableSurveyObject(Survey survey, int id) {\n\t\tsuper(survey, id);\n\t}\n\tprotected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {\n\t\tsuper(survey, source, id);\n\t\tif (survey == source.getSurvey()) {\n\t\t\tthis.sinceVersion = source.sinceVersion;\n\t\t\tthis.deprecatedVersion = source.deprecatedVersion;\n\t\t}\n\t}\n\t\n\tpublic void removeVersioning(ModelVersion version) {\n\t\tint versionId = version.getId();\n\t\tif ( sinceVersion != null && sinceVersion.getId() == versionId ) {\n\t\t\tsinceVersion = null;\n\t\t}\n\t\tif ( deprecatedVersion != null && deprecatedVersion.getId() == versionId ) {\n\t\t\tdeprecatedVersion = null;\n\t\t}\n\t}\n\tpublic String getSinceVersionName() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getName();\n\t}\n\t\n\tpublic Integer getSinceVersionId() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getId();\n\t}\n\t\n\tpublic void setSinceVersionByName(String name) {\n\t\tthis.sinceVersion = name == null ? null : findVersion(name);\n\t}\n\tpublic String getDeprecatedVersionName() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getName();\n\t}\n\t\n\tpublic Integer getDeprecatedVersionId() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getId();\n\t}\n\t\n\tpublic void setDeprecatedVersionByName(String name) {\n\t\tthis.deprecatedVersion = name == null ? null : findVersion(name);\n\t}\n\tpublic ModelVersion getSinceVersion() {\n\t\treturn this.sinceVersion;\n\t}\n\tpublic void setSinceVersion(ModelVersion since) {\n\t\tthis.sinceVersion = since;\n\t}\n\tpublic ModelVersion getDeprecatedVersion() {\n\t\treturn this.deprecatedVersion;\n\t}\n\tpublic void setDeprecatedVersion(ModelVersion deprecated) {\n\t\tthis.deprecatedVersion = deprecated;\n\t}\n\tprivate ModelVersion findVersion(String name) {\n\t\tif ( name == null ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tSurvey survey = getSurvey();\n\t\t\tif ( survey == null ) {\n\t\t\t\tthrow new IllegalStateException(\"Survey not set!\");\n\t\t\t} \n\t\t\tModelVersion v = survey.getVersion(name);\n\t\t\tif ( v == null ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Undefined version '\"+name+\"' in \"+toString());\n\t\t\t} \n\t\t\treturn v;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean deepEquals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.deepEquals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tVersionableSurveyObject other = (VersionableSurveyObject) obj;\n\t\tif (deprecatedVersion == null) {\n\t\t\tif (other.deprecatedVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))\n\t\t\treturn false;\n\t\tif (sinceVersion == null) {\n\t\t\tif (other.sinceVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!sinceVersion.deepEquals(other.sinceVersion))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n"]], "pred": {"ppl": 1.3767403364181519, "ppl_lower": 1.4936515092849731, "ppl/lowercase_ppl": -1.254927807319027, "ppl/zlib": 0.00042403001327549994, "Min_5.0% Prob": 4.317417278885841, "Min_10.0% Prob": 2.8375449627637863, "Min_20.0% Prob": 1.5748031933845017, "Min_30.0% Prob": 1.0625075698027322, "Min_40.0% Prob": 0.7985330723762724, "Min_50.0% Prob": 0.6390544962056639, "Min_60.0% Prob": 0.5334741721619202}}
{"hexsha": "f9adf1391613a41a2b211c8031b0e6fa8832d4dc", "ext": "java", "lang": "Java", "content": "public class ApiOvhSslGateway extends ApiOvhBase {\n\tpublic ApiOvhSslGateway(ApiOvhCore core) {\n\t\tsuper(core);\n\t}\n\n\t/**\n\t * Launch a contact change procedure\n\t *\n\t * REST: POST /sslGateway/{serviceName}/changeContact\n\t * @param contactAdmin [required] The contact to set as admin contact\n\t * @param contactTech [required] The contact to set as tech contact\n\t * @param contactBilling [required] The contact to set as billing contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/changeContact\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"contactAdmin\", contactAdmin);\n\t\taddBody(o, \"contactBilling\", contactBilling);\n\t\taddBody(o, \"contactTech\", contactTech);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t1);\n\t}\n\tprivate static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {};\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/serviceInfos\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhService.class);\n\t}\n\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/serviceInfos\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\n\t/**\n\t * Renew your SSL certificates\n\t *\n\t * REST: POST /sslGateway/{serviceName}/renewCertificate\n\t * @param domain [required] Domain on which you want to renew certificate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/renewCertificate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t2);\n\t}\n\tprivate static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {};\n\n\t/**\n\t * Terminate your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/terminate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_terminate_POST(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/terminate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), null);\n\t\treturn convertTo(resp, String.class);\n\t}\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\n\t/**\n\t * Detach a domain from your SSL Gateway\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\n\t/**\n\t * Domains attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\n\t/**\n\t * Attach a new domain to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/domain\n\t * @param domain [required] Domain to attach\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\n\t/**\n\t * Servers attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\n\t/**\n\t * Add a new server to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/server\n\t * @param port [required] Port of your server\n\t * @param address [required] IPv4 address of your server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"address\", address);\n\t\taddBody(o, \"port\", port);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/server/{id}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\n\t/**\n\t * Remove a server\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\n\t/**\n\t * Task for this SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of the task\n\t *\n\t * API beta\n\t */\n\tpublic OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhTask.class);\n\t}\n\n\t/**\n\t * Ip subnet used by OVH to nat requests to your SSL Gateway backends.\n\t *\n\t * REST: GET /sslGateway/{serviceName}/natIp\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/natIp\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t3);\n\t}\n\tprivate static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {};\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhSslGateway serviceName_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhSslGateway.class);\n\t}\n\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\n\t/**\n\t * Confirm termination of your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/confirmTermination\n\t * @param futureUse [required] What next after your termination request\n\t * @param reason [required] Reason of your termination request\n\t * @param commentary [required] Commentary about your termination request\n\t * @param token [required] The termination token sent by mail to the admin contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/confirmTermination\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"commentary\", commentary);\n\t\taddBody(o, \"futureUse\", futureUse);\n\t\taddBody(o, \"reason\", reason);\n\t\taddBody(o, \"token\", token);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, String.class);\n\t}\n\n\t/**\n\t * Check domain eligibility. Return list of eligible IP(s) for this domain.\n\t *\n\t * REST: GET /sslGateway/eligibility\n\t * @param domain [required] domain to check eligibility for SSL Gateway offer\n\t *\n\t * API beta\n\t */\n\tpublic OvhEligibilityStatus eligibility_GET(String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/eligibility\";\n\t\tStringBuilder sb = path(qPath);\n\t\tquery(sb, \"domain\", domain);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhEligibilityStatus.class);\n\t}\n\n\t/**\n\t * List available services\n\t *\n\t * REST: GET /sslGateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> GET() throws IOException {\n\t\tString qPath = \"/sslGateway\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n\n\t/**\n\t * List of zone available for an SSL Gateway\n\t *\n\t * REST: GET /sslGateway/availableZones\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> availableZones_GET() throws IOException {\n\t\tString qPath = \"/sslGateway/availableZones\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n}", "class_id": 0, "repo": "marstona/ovh-java-sdk", "file": "ovh-java-sdk-sslGateway/src/main/java/net/minidev/ovh/api/ApiOvhSslGateway.java", "last_update_at": "2021-04-20T07:54:21+00:00", "question_id": "f9adf1391613a41a2b211c8031b0e6fa8832d4dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ApiOvhSslGateway extends ApiOvhBase {\n\tpublic ApiOvhSslGateway(ApiOvhCore core) {\n\t\tsuper(core);\n\t}\n\t/**\n\t * Launch a contact change procedure\n\t *\n\t * REST: POST /sslGateway/{serviceName}/changeContact\n\t * @param contactAdmin [required] The contact to set as admin contact\n\t * @param contactTech [required] The contact to set as tech contact\n\t * @param contactBilling [required] The contact to set as billing contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/changeContact\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"contactAdmin\", contactAdmin);\n\t\taddBody(o, \"contactBilling\", contactBilling);\n\t\taddBody(o, \"contactTech\", contactTech);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t1);\n\t}\n\tprivate static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {};\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/serviceInfos\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhService.class);\n\t}\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/serviceInfos\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\t/**\n\t * Renew your SSL certificates\n\t *\n\t * REST: POST /sslGateway/{serviceName}/renewCertificate\n\t * @param domain [required] Domain on which you want to renew certificate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/renewCertificate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t2);\n\t}\n\tprivate static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {};\n\t/**\n\t * Terminate your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/terminate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_terminate_POST(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/terminate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), null);\n\t\treturn convertTo(resp, String.class);\n\t}\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\t/**\n\t * Detach a domain from your SSL Gateway\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\t/**\n\t * Domains attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\t/**\n\t * Attach a new domain to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/domain\n\t * @param domain [required] Domain to attach\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\t/**\n\t * Servers attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\t/**\n\t * Add a new server to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/server\n\t * @param port [required] Port of your server\n\t * @param address [required] IPv4 address of your server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"address\", address);\n\t\taddBody(o, \"port\", port);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/server/{id}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\t/**\n\t * Remove a server\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\t/**\n\t * Task for this SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of the task\n\t *\n\t * API beta\n\t */\n\tpublic OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhTask.class);\n\t}\n\t/**\n\t * Ip subnet used by OVH to nat requests to your SSL Gateway backends.\n\t *\n\t * REST: GET /sslGateway/{serviceName}/natIp\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/natIp\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t3);\n\t}\n\tprivate static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {};\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhSslGateway serviceName_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhSslGateway.class);\n\t}\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\t/**\n\t * Confirm termination of your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/confirmTermination\n\t * @param futureUse [required] What next after your termination request\n\t * @param reason [required] Reason of your termination request\n\t * @param commentary [required] Commentary about your termination request\n\t * @param token [required] The termination token sent by mail to the admin contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/confirmTermination\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"commentary\", commentary);\n\t\taddBody(o, \"futureUse\", futureUse);\n\t\taddBody(o, \"reason\", reason);\n\t\taddBody(o, \"token\", token);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, String.class);\n\t}\n\t/**\n\t * Check domain eligibility. Return list of eligible IP(s) for this domain.\n\t *\n\t * REST: GET /sslGateway/eligibility\n\t * @param domain [required] domain to check eligibility for SSL Gateway offer\n\t *\n\t * API beta\n\t */\n\tpublic OvhEligibilityStatus eligibility_GET(String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/eligibility\";\n\t\tStringBuilder sb = path(qPath);\n\t\tquery(sb, \"domain\", domain);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhEligibilityStatus.class);\n\t}\n\t/**\n\t * List available services\n\t *\n\t * REST: GET /sslGateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> GET() throws IOException {\n\t\tString qPath = \"/sslGateway\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n\t/**\n\t * List of zone available for an SSL Gateway\n\t *\n\t * REST: GET /sslGateway/availableZones\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> availableZones_GET() throws IOException {\n\t\tString qPath = \"/sslGateway/availableZones\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n"]], "pred": {"ppl": 1.1421639919281006, "ppl_lower": 1.472694993019104, "ppl/lowercase_ppl": -2.912130298817535, "ppl/zlib": 7.92161511095352e-05, "Min_5.0% Prob": 2.4946490514512156, "Min_10.0% Prob": 1.3234782127261746, "Min_20.0% Prob": 0.6661334645645647, "Min_30.0% Prob": 0.44433323420416615, "Min_40.0% Prob": 0.3324649260011805, "Min_50.0% Prob": 0.2661075723269443, "Min_60.0% Prob": 0.2218297951820896}}
{"hexsha": "2e2144587792d1fd6ca9470159dc937992a00ce0", "ext": "java", "lang": "Java", "content": "public class LectorLadronesJSON implements LectorLadrones{\n    private String ruta = \"src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json\";\n\n    public ArrayList<Ladron> cargarLadrones() {\n        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                String hobby = (String) ladron.get(\"Hobby\");\n                String cabello = (String) ladron.get(\"Cabello\");\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n                ladrones.add(objLadron);\n\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return ladrones;\n    }\n\n    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {\n        HashMap<String, ArrayList<String>> diccionario = new HashMap();\n        diccionario.put(\"Sexo\", new ArrayList<String>());\n        diccionario.put(\"Cabello\", new ArrayList<String>());\n        diccionario.put(\"Hobby\", new ArrayList<String>());\n        diccionario.put(\"Vehiculo\", new ArrayList<String>());\n        diccionario.put(\"Senia\", new ArrayList<String>());\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                ArrayList<String> sexos = diccionario.get(\"Sexo\");\n                if (!sexos.contains(sexo)) {\n                    sexos.add(sexo);\n                }\n                String hobby = (String) ladron.get(\"Hobby\");\n                ArrayList<String> hobbys = diccionario.get(\"Hobby\");\n                if (!hobbys.contains(hobby)) {\n                    hobbys.add(hobby);\n                }\n                String cabello = (String) ladron.get(\"Cabello\");\n                ArrayList<String> cabellos = diccionario.get(\"Cabello\");\n                if (!cabellos.contains(cabello)) {\n                    cabellos.add(cabello);\n                }\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                ArrayList<String> senias = diccionario.get(\"Senia\");\n                if (!senias.contains(caracteristica)) {\n                    senias.add(caracteristica);\n                }\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> vehiculos = diccionario.get(\"Vehiculo\");\n                if (!vehiculos.contains(vehiculo)) {\n                    vehiculos.add(vehiculo);\n                }\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return diccionario;\n    }\n\n\n}", "class_id": 0, "repo": "jmdieguez/algothief", "file": "src/main/java/edu/fiuba/algo3/modelo/lectoresDeArchivos/LectorLadronesJSON.java", "last_update_at": "2021-12-23T21:09:22+00:00", "question_id": "2e2144587792d1fd6ca9470159dc937992a00ce0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LectorLadronesJSON implements LectorLadrones{\n    private String ruta = \"src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json\";\n    public ArrayList<Ladron> cargarLadrones() {\n        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                String hobby = (String) ladron.get(\"Hobby\");\n                String cabello = (String) ladron.get(\"Cabello\");\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n                ladrones.add(objLadron);\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return ladrones;\n    }\n    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {\n        HashMap<String, ArrayList<String>> diccionario = new HashMap();\n        diccionario.put(\"Sexo\", new ArrayList<String>());\n        diccionario.put(\"Cabello\", new ArrayList<String>());\n        diccionario.put(\"Hobby\", new ArrayList<String>());\n        diccionario.put(\"Vehiculo\", new ArrayList<String>());\n        diccionario.put(\"Senia\", new ArrayList<String>());\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                ArrayList<String> sexos = diccionario.get(\"Sexo\");\n                if (!sexos.contains(sexo)) {\n                    sexos.add(sexo);\n                }\n                String hobby = (String) ladron.get(\"Hobby\");\n                ArrayList<String> hobbys = diccionario.get(\"Hobby\");\n                if (!hobbys.contains(hobby)) {\n                    hobbys.add(hobby);\n                }\n                String cabello = (String) ladron.get(\"Cabello\");\n                ArrayList<String> cabellos = diccionario.get(\"Cabello\");\n                if (!cabellos.contains(cabello)) {\n                    cabellos.add(cabello);\n                }\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                ArrayList<String> senias = diccionario.get(\"Senia\");\n                if (!senias.contains(caracteristica)) {\n                    senias.add(caracteristica);\n                }\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> vehiculos = diccionario.get(\"Vehiculo\");\n                if (!vehiculos.contains(vehiculo)) {\n                    vehiculos.add(vehiculo);\n                }\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return diccionario;\n    }\n"]], "pred": {"ppl": 1.32741117477417, "ppl_lower": 1.413761019706726, "ppl/lowercase_ppl": -1.2225147695642216, "ppl/zlib": 0.00035315531201670356, "Min_5.0% Prob": 4.114820580856473, "Min_10.0% Prob": 2.579268470698712, "Min_20.0% Prob": 1.3976354828360034, "Min_30.0% Prob": 0.9425999480604006, "Min_40.0% Prob": 0.7073003945617156, "Min_50.0% Prob": 0.5666549326343928, "Min_60.0% Prob": 0.47256881591237604}}
{"hexsha": "37ecfb9df884be7d35bf5475a3abf4d1b0e8fe8d", "ext": "java", "lang": "Java", "content": "@RunWith(JMock.class)\npublic class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {\n\n    private PasswordValueSemanticsProvider adapter;\n    private Object password;\n    private FacetHolder holder;\n\n    @Before\n    public void setUpObjects() throws Exception {\n        holder = new FacetHolderImpl();\n        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));\n        password = new Password(\"secret\");\n    }\n\n    @Test\n    public void testEncoding() {\n        assertEquals(\"secret\", new String(adapter.toEncodedString(password)));\n    }\n}", "class_id": 0, "repo": "Corpus-2021/nakedobjects-4.0.0", "file": "core/metamodel/src/test/java/org/nakedobjects/metamodel/value/PasswordValueSemanticsProviderTest.java", "last_update_at": "2021-02-22T15:40:05+00:00", "question_id": "37ecfb9df884be7d35bf5475a3abf4d1b0e8fe8d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(JMock.class)\npublic class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {\n    private PasswordValueSemanticsProvider adapter;\n    private Object password;\n    private FacetHolder holder;\n    @Before\n    public void setUpObjects() throws Exception {\n        holder = new FacetHolderImpl();\n        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));\n        password = new Password(\"secret\");\n    }\n    @Test\n    public void testEncoding() {\n        assertEquals(\"secret\", new String(adapter.toEncodedString(password)));\n    }\n"]], "pred": {"ppl": 2.0714645385742188, "ppl_lower": 6.545323848724365, "ppl/lowercase_ppl": -2.5797950585584535, "ppl/zlib": 0.0022829337419125245, "Min_5.0% Prob": 7.3155563218253, "Min_10.0% Prob": 5.418017832438151, "Min_20.0% Prob": 3.2619043877047877, "Min_30.0% Prob": 2.3488279004459796, "Min_40.0% Prob": 1.7935274700003285, "Min_50.0% Prob": 1.4588245651745178, "Min_60.0% Prob": 1.2117939181625843}}
{"hexsha": "2f37e0e31a286e088d15fb05e86f8bfa506763a6", "ext": "java", "lang": "Java", "content": "public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {\n\n    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());\n    \n    private ServerBootstrap serverBootstrap;\n    private Channel serverChannel;\n    private EndpointService endpointService;\n    \n    private AtomicBoolean started = new AtomicBoolean(false);\n    private PeerGroup group;\n    private PeerGroupID homeGroupID;\n    private PeerID localPeerID;\n    \n    private MessengerEventListener listener;\n    private List<EndpointAddress> publicAddresses;\n\n    private AddressTranslator addrTranslator;\n    \n    private ChannelGroup channels;\n\n    private HashedWheelTimer timeoutTimer;\n\n    private ChannelGroupFuture closeChannelsFuture;\n\n    private List<EndpointAddress> boundAddresses;\n    \n    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {\n        this.channels = new DefaultChannelGroup();\n        this.group = group;\n        this.homeGroupID = group.getPeerGroupID();\n        this.localPeerID = group.getPeerID();\n        this.addrTranslator = addrTranslator;\n        serverBootstrap = new ServerBootstrap(factory);\n        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());\n        timeoutTimer = new HashedWheelTimer();\n    }\n \n    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {\n        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));\n        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);\n        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));\n        \n        if(serverChannel == null) {\n\n            Logging.logCheckedWarning(LOG, \"Failed to bind to any of the addresses in the configured range\");\n            throw new PeerGroupException(\"Failed to bind to any address in the configured range\");\n\n        }\n        \n        if(usePublicOnly) {\n\n            if(publicAddress == null) {\n\n                Logging.logCheckedWarning(LOG, \"Instructed to use public address only, but no public address specified! Using all bound addresses instead\");\n                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);\n\n            } else {\n\n                publicAddresses = new ArrayList<EndpointAddress>(1);\n                publicAddresses.add(publicAddress);\n\n            }\n\n        } else {\n            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);\n            publicAddresses = new ArrayList<EndpointAddress>(size);\n            if(publicAddress != null) {\n                publicAddresses.add(publicAddress);\n            }\n            publicAddresses.addAll(boundAddresses);\n        }\n    }\n\n    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {\n        \n        for(SocketAddress nextBP : potentialBindpoints) {\n\n            try {\n                serverChannel = serverBootstrap.bind(nextBP);\n                channels.add(serverChannel);\n                return nextBP;\n            } catch(ChannelException e) {\n                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();\n                Logging.logCheckedInfo(LOG, \"Attempt to bind to \", nextBP, \" failed (\", failReason, \"), trying another address\");\n            }\n            \n        }\n        \n        return null;\n    }\n    \n    public boolean start(EndpointService endpointService) throws IllegalStateException {\n        if(started.get()) {\n            throw new IllegalStateException(\"already started\");\n        }\n        \n        this.endpointService = endpointService;\n        listener = endpointService.addMessageTransport(this);\n        \n        if(listener == null) {\n\n            Logging.logCheckedSevere(LOG, \"Transport registration failed for netty transport server, protocol=\", addrTranslator.getProtocolName());\n            return false;\n\n        }\n        \n        started.set(true);\n        return true;\n    }\n    \n    public void beginStop() {\n\n        if(!started.compareAndSet(true, false)) {\n\n            Logging.logCheckedWarning(LOG, \"Netty transport server for protocol \", addrTranslator.getProtocolName(), \" already stopped or never started!\");\n            return;\n\n        }\n        \n        closeChannelsFuture = channels.close();\n    }\n    \n    public void stop() throws IllegalStateException {\n        if(closeChannelsFuture != null) {\n            closeChannelsFuture.awaitUninterruptibly();\n        }\n        \n        serverChannel = null;\n        serverBootstrap.releaseExternalResources();\n        timeoutTimer.stop();\n    }\n\n    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {\n        // EndpointAddress localAddr = addrTranslator.toEndpointAddress(channel.getLocalAddress(), serverChannel.getLocalAddress());\n        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));\n\t}\n\t\n    public Iterator<EndpointAddress> getPublicAddresses() {\n        return publicAddresses.iterator();\n    }\n\n    public EndpointService getEndpointService() {\n        return endpointService;\n    }\n\n    public String getProtocolName() {\n        return addrTranslator.getProtocolName();\n    }\n\n    @Sharable\n    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {\n\n        @Override\n        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {\n            \n            Logging.logCheckedFine(LOG, String.format(\"Incoming connection for transport %s from %s to %s (handled by %s)\",\n                  getProtocolName(),\n                  e.getChildChannel().getRemoteAddress(),\n                  e.getChildChannel().getLocalAddress(),\n                  ctx.getChannel().getLocalAddress()\n                  ));\n                \n            channels.add(e.getChildChannel());\n            super.childChannelOpen(ctx, e);\n        }\n        \n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n            // BindExceptions are transformed into ChannelBindExceptions by the netty\n            // ServerBootstrap, and handled in in bindServerChannel()\n            if(!(e.getCause() instanceof BindException)) {\n                LOG.log(Level.WARNING, \"Unexpected exception on server channel for {0} protocol:\\n{1}\", \n                        new Object[] { getProtocolName(), e.getCause() });\n            }\n        }\n    }\n\n    public boolean isStarted() {\n        return started.get();\n    }\n\n    /**\n     * @return the physically bound addresses for this transport, as opposed to those which are\n     * broadcasted to external peers.\n     */\n    public List<EndpointAddress> getBoundAddresses() {\n        return boundAddresses;\n    }\n}", "class_id": 0, "repo": "chaupal/jp2p-jxta", "file": "Workspace/net.jp2p.endpoint.netty/src/net/jxta/impl/endpoint/netty/NettyTransportServer.java", "last_update_at": "2021-01-20T14:53:01+00:00", "question_id": "2f37e0e31a286e088d15fb05e86f8bfa506763a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {\n    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());\n    private ServerBootstrap serverBootstrap;\n    private Channel serverChannel;\n    private EndpointService endpointService;\n    private AtomicBoolean started = new AtomicBoolean(false);\n    private PeerGroup group;\n    private PeerGroupID homeGroupID;\n    private PeerID localPeerID;\n    private MessengerEventListener listener;\n    private List<EndpointAddress> publicAddresses;\n    private AddressTranslator addrTranslator;\n    private ChannelGroup channels;\n    private HashedWheelTimer timeoutTimer;\n    private ChannelGroupFuture closeChannelsFuture;\n    private List<EndpointAddress> boundAddresses;\n    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {\n        this.channels = new DefaultChannelGroup();\n        this.group = group;\n        this.homeGroupID = group.getPeerGroupID();\n        this.localPeerID = group.getPeerID();\n        this.addrTranslator = addrTranslator;\n        serverBootstrap = new ServerBootstrap(factory);\n        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());\n        timeoutTimer = new HashedWheelTimer();\n    }\n    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {\n        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));\n        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);\n        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));\n        if(serverChannel == null) {\n            Logging.logCheckedWarning(LOG, \"Failed to bind to any of the addresses in the configured range\");\n            throw new PeerGroupException(\"Failed to bind to any address in the configured range\");\n        }\n        if(usePublicOnly) {\n            if(publicAddress == null) {\n                Logging.logCheckedWarning(LOG, \"Instructed to use public address only, but no public address specified! Using all bound addresses instead\");\n                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);\n            } else {\n                publicAddresses = new ArrayList<EndpointAddress>(1);\n                publicAddresses.add(publicAddress);\n            }\n        } else {\n            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);\n            publicAddresses = new ArrayList<EndpointAddress>(size);\n            if(publicAddress != null) {\n                publicAddresses.add(publicAddress);\n            }\n            publicAddresses.addAll(boundAddresses);\n        }\n    }\n    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {\n        for(SocketAddress nextBP : potentialBindpoints) {\n            try {\n                serverChannel = serverBootstrap.bind(nextBP);\n                channels.add(serverChannel);\n                return nextBP;\n            } catch(ChannelException e) {\n                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();\n                Logging.logCheckedInfo(LOG, \"Attempt to bind to \", nextBP, \" failed (\", failReason, \"), trying another address\");\n            }\n        }\n        return null;\n    }\n    public boolean start(EndpointService endpointService) throws IllegalStateException {\n        if(started.get()) {\n            throw new IllegalStateException(\"already started\");\n        }\n        this.endpointService = endpointService;\n        listener = endpointService.addMessageTransport(this);\n        if(listener == null) {\n            Logging.logCheckedSevere(LOG, \"Transport registration failed for netty transport server, protocol=\", addrTranslator.getProtocolName());\n            return false;\n        }\n        started.set(true);\n        return true;\n    }\n    public void beginStop() {\n        if(!started.compareAndSet(true, false)) {\n            Logging.logCheckedWarning(LOG, \"Netty transport server for protocol \", addrTranslator.getProtocolName(), \" already stopped or never started!\");\n            return;\n        }\n        closeChannelsFuture = channels.close();\n    }\n    public void stop() throws IllegalStateException {\n        if(closeChannelsFuture != null) {\n            closeChannelsFuture.awaitUninterruptibly();\n        }\n        serverChannel = null;\n        serverBootstrap.releaseExternalResources();\n        timeoutTimer.stop();\n    }\n    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {\n        // EndpointAddress localAddr = addrTranslator.toEndpointAddress(channel.getLocalAddress(), serverChannel.getLocalAddress());\n        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));\n\t}\n\t\n    public Iterator<EndpointAddress> getPublicAddresses() {\n        return publicAddresses.iterator();\n    }\n    public EndpointService getEndpointService() {\n        return endpointService;\n    }\n    public String getProtocolName() {\n        return addrTranslator.getProtocolName();\n    }\n    @Sharable\n    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {\n        @Override\n        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {\n            Logging.logCheckedFine(LOG, String.format(\"Incoming connection for transport %s from %s to %s (handled by %s)\",\n                  getProtocolName(),\n                  e.getChildChannel().getRemoteAddress(),\n                  e.getChildChannel().getLocalAddress(),\n                  ctx.getChannel().getLocalAddress()\n                  ));\n            channels.add(e.getChildChannel());\n            super.childChannelOpen(ctx, e);\n        }\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n            // BindExceptions are transformed into ChannelBindExceptions by the netty\n            // ServerBootstrap, and handled in in bindServerChannel()\n            if(!(e.getCause() instanceof BindException)) {\n                LOG.log(Level.WARNING, \"Unexpected exception on server channel for {0} protocol:\\n{1}\", \n                        new Object[] { getProtocolName(), e.getCause() });\n            }\n        }\n    }\n    public boolean isStarted() {\n        return started.get();\n    }\n    /**\n     * @return the physically bound addresses for this transport, as opposed to those which are\n     * broadcasted to external peers.\n     */\n    public List<EndpointAddress> getBoundAddresses() {\n        return boundAddresses;\n    }\n"]], "pred": {"ppl": 2.1689560413360596, "ppl_lower": 2.5053722858428955, "ppl/lowercase_ppl": -1.1862345847344404, "ppl/zlib": 0.00037475603332575455, "Min_5.0% Prob": 6.394910223343793, "Min_10.0% Prob": 4.940280654851128, "Min_20.0% Prob": 3.3511412161238052, "Min_30.0% Prob": 2.4637951447683224, "Min_40.0% Prob": 1.9074066946952442, "Min_50.0% Prob": 1.542678510110439, "Min_60.0% Prob": 1.2901481804582267}}
{"hexsha": "5243c099bbc4d6b225d8d4ed73dce3be7503010c", "ext": "java", "lang": "Java", "content": "public class ScannerImplTest {\n\n  private ClientContext context;\n\n  @Before\n  public void setup() {\n    context = EasyMock.createMock(ClientContext.class);\n  }\n\n  @Test\n  public void testValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(0);\n    s.setReadaheadThreshold(10);\n    s.setReadaheadThreshold(Long.MAX_VALUE);\n\n    assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());\n    s.close();\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(-1);\n    s.close();\n  }\n\n  @Test\n  public void testGetAuthorizations() {\n    Authorizations expected = new Authorizations(\"a,b\");\n    Scanner s = new ScannerImpl(context, \"foo\", expected);\n    assertEquals(expected, s.getAuthorizations());\n    s.close();\n  }\n\n  @SuppressWarnings(\"resource\")\n  @Test(expected = IllegalArgumentException.class)\n  public void testNullAuthorizationsFails() {\n    new ScannerImpl(context, \"foo\", null);\n  }\n\n}", "class_id": 0, "repo": "dorateq/accumulo", "file": "core/src/test/java/org/apache/accumulo/core/client/impl/ScannerImplTest.java", "last_update_at": "2021-04-07T18:45:40+00:00", "question_id": "5243c099bbc4d6b225d8d4ed73dce3be7503010c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScannerImplTest {\n  private ClientContext context;\n  @Before\n  public void setup() {\n    context = EasyMock.createMock(ClientContext.class);\n  }\n  @Test\n  public void testValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(0);\n    s.setReadaheadThreshold(10);\n    s.setReadaheadThreshold(Long.MAX_VALUE);\n    assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());\n    s.close();\n  }\n  @Test(expected = IllegalArgumentException.class)\n  public void testInValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(-1);\n    s.close();\n  }\n  @Test\n  public void testGetAuthorizations() {\n    Authorizations expected = new Authorizations(\"a,b\");\n    Scanner s = new ScannerImpl(context, \"foo\", expected);\n    assertEquals(expected, s.getAuthorizations());\n    s.close();\n  }\n  @SuppressWarnings(\"resource\")\n  @Test(expected = IllegalArgumentException.class)\n  public void testNullAuthorizationsFails() {\n    new ScannerImpl(context, \"foo\", null);\n  }\n"]], "pred": {"ppl": 1.6793971061706543, "ppl_lower": 2.1128363609313965, "ppl/lowercase_ppl": -1.4428645605390686, "ppl/zlib": 0.001382492969687917, "Min_5.0% Prob": 6.067485627006082, "Min_10.0% Prob": 4.235615379469735, "Min_20.0% Prob": 2.484031087585858, "Min_30.0% Prob": 1.7110025383886838, "Min_40.0% Prob": 1.297072460848306, "Min_50.0% Prob": 1.0352163278201425, "Min_60.0% Prob": 0.8645449953575253}}
{"hexsha": "4d7f0a0119dc23fe4bd356b1832ed7063663cf23", "ext": "java", "lang": "Java", "content": "public class D11_ValidAnagram {\n    public static void main(String[] args) {\n        ValidAnagramSolution vas = new ValidAnagramSolution();\n        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();\n\n        System.out.println(vas.isAnagram(\"azamat\", \"tamaza\"));\n        System.out.println(vas_1.isAnagram(\"azamat\", \"tamaza\"));\n    }\n}", "class_id": 0, "repo": "SudoAzek/LeetCodeJava", "file": "Solutions/src/february_daily_challenge/D11_ValidAnagram.java", "last_update_at": "2021-12-18T22:51:42+00:00", "question_id": "4d7f0a0119dc23fe4bd356b1832ed7063663cf23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class D11_ValidAnagram {\n    public static void main(String[] args) {\n        ValidAnagramSolution vas = new ValidAnagramSolution();\n        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();\n        System.out.println(vas.isAnagram(\"azamat\", \"tamaza\"));\n        System.out.println(vas_1.isAnagram(\"azamat\", \"tamaza\"));\n    }\n"]], "pred": {"ppl": 2.18766450881958, "ppl_lower": 3.3901848793029785, "ppl/lowercase_ppl": -1.5595689682588172, "ppl/zlib": 0.0046049090614927, "Min_5.0% Prob": 7.319486236572265, "Min_10.0% Prob": 5.638329202478582, "Min_20.0% Prob": 3.847478384321386, "Min_30.0% Prob": 2.588888548752841, "Min_40.0% Prob": 1.9744945977297095, "Min_50.0% Prob": 1.5634315548007165, "Min_60.0% Prob": 1.3116906118195724}}
{"hexsha": "cf298733351b7e35725e78d8f67a8e27f7e35c3e", "ext": "java", "lang": "Java", "content": "public class demo06ArrayListStudent {\n    public static void main(String[] args) {\n        ArrayList<Student> list =  new ArrayList<>();\n\n        list.add(new Student(22,\"\u6d2a\u4e03\u516c\"));\n        list.add(new Student(23,\"\u6b27\u9633\u950b\"));\n        list.add(new Student(53,\"\u9ec4\u836f\u5e08\"));\n        list.add(new Student(33,\"\u6bb5\u667a\u5e86\"));\n\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(\"\u59d3\u540d\uff1a\"+stu.getName()+\" \u5e74\u9f84\uff1a\"+stu.getAge());\n\n        }\n    }\n}", "class_id": 0, "repo": "BinmingWen/base-code", "file": "day06-code/src/demo04/demo06ArrayListStudent.java", "last_update_at": "2021-03-02T00:49:32+00:00", "question_id": "cf298733351b7e35725e78d8f67a8e27f7e35c3e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class demo06ArrayListStudent {\n    public static void main(String[] args) {\n        ArrayList<Student> list =  new ArrayList<>();\n        list.add(new Student(22,\"\u6d2a\u4e03\u516c\"));\n        list.add(new Student(23,\"\u6b27\u9633\u950b\"));\n        list.add(new Student(53,\"\u9ec4\u836f\u5e08\"));\n        list.add(new Student(33,\"\u6bb5\u667a\u5e86\"));\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(\"\u59d3\u540d\uff1a\"+stu.getName()+\" \u5e74\u9f84\uff1a\"+stu.getAge());\n        }\n    }\n"]], "pred": {"ppl": 2.263232707977295, "ppl_lower": 2.616703510284424, "ppl/lowercase_ppl": -1.1776715990898952, "ppl/zlib": 0.002713601970079649, "Min_5.0% Prob": 7.160538779364692, "Min_10.0% Prob": 5.416671103901333, "Min_20.0% Prob": 3.6065036919381885, "Min_30.0% Prob": 2.6619106624965316, "Min_40.0% Prob": 2.021812293627491, "Min_50.0% Prob": 1.634543823057806, "Min_60.0% Prob": 1.3687661241466573}}
{"hexsha": "f897b790e84ce679266078228c42440591f1ba9b", "ext": "java", "lang": "Java", "content": "public class IsDAG_DontHave_Cycles {\n    Map<Integer, Set<Integer>> map = new HashMap<>();\n    Set<Integer> vis = new HashSet<>();\n    \n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if(prerequisites == null){\n            return false;\n        }\n        \n        if(prerequisites.length <= 0){\n            return true;\n        }\n        \n        Set<Integer> prevS = new HashSet<>();\n        Set<Integer> nextS = new HashSet<>();\n        \n        int n = prerequisites.length;\n        for(int i=0; i<n; i++){\n            int prevCour = prerequisites[i][1];\n            int nextCour = prerequisites[i][0];\n            \n            prevS.add(prevCour);\n            nextS.add(nextCour);\n            \n            Set<Integer> courses = map.get(prevCour);\n            if(courses == null){\n                courses = new HashSet<>();\n                map.put(prevCour, courses);\n            }\n            \n            courses.add(nextCour);\n        }\n        \n        prevS.removeAll(nextS);\n        \n        for(Integer item : prevS){\n            if(!dfs(item)){\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private boolean dfs(Integer node){\n        if(node == null){\n            return true;\n        }\n        \n        if(vis.contains(node)){\n            return false;\n        }\n        \n        vis.add(node);\n        \n        Set<Integer> courses = map.get(node);\n        if(courses != null){\n            for(Integer n : courses){\n                if(!dfs(n)){\n                    return false;\n                }\n            }\n        }\n        \n        vis.remove(node);\n        \n        return true;\n    }\n}", "class_id": 0, "repo": "sergeyltd/pilgrim-base", "file": "src/main/java/org/pilgrim/leetcode/y2021/IsDAG_DontHave_Cycles.java", "last_update_at": "2021-04-06T17:19:31+00:00", "question_id": "f897b790e84ce679266078228c42440591f1ba9b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IsDAG_DontHave_Cycles {\n    Map<Integer, Set<Integer>> map = new HashMap<>();\n    Set<Integer> vis = new HashSet<>();\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if(prerequisites == null){\n            return false;\n        }\n        if(prerequisites.length <= 0){\n            return true;\n        }\n        Set<Integer> prevS = new HashSet<>();\n        Set<Integer> nextS = new HashSet<>();\n        int n = prerequisites.length;\n        for(int i=0; i<n; i++){\n            int prevCour = prerequisites[i][1];\n            int nextCour = prerequisites[i][0];\n            prevS.add(prevCour);\n            nextS.add(nextCour);\n            Set<Integer> courses = map.get(prevCour);\n            if(courses == null){\n                courses = new HashSet<>();\n                map.put(prevCour, courses);\n            }\n            courses.add(nextCour);\n        }\n        prevS.removeAll(nextS);\n        for(Integer item : prevS){\n            if(!dfs(item)){\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean dfs(Integer node){\n        if(node == null){\n            return true;\n        }\n        if(vis.contains(node)){\n            return false;\n        }\n        vis.add(node);\n        Set<Integer> courses = map.get(node);\n        if(courses != null){\n            for(Integer n : courses){\n                if(!dfs(n)){\n                    return false;\n                }\n            }\n        }\n        vis.remove(node);\n        return true;\n    }\n"]], "pred": {"ppl": 1.506602168083191, "ppl_lower": 1.6738826036453247, "ppl/lowercase_ppl": -1.2568919690348708, "ppl/zlib": 0.0008538685322195109, "Min_5.0% Prob": 5.131797096003657, "Min_10.0% Prob": 3.4820342850177846, "Min_20.0% Prob": 1.9846259032425126, "Min_30.0% Prob": 1.3578798793728504, "Min_40.0% Prob": 1.0218198159807608, "Min_50.0% Prob": 0.8179594765401625, "Min_60.0% Prob": 0.6839400304089251}}
{"hexsha": "3b3405f0a50720b0ea3fa6ab7ba19be695a6240c", "ext": "java", "lang": "Java", "content": "public class NullabilityTest {\n\n    @Test\n    public void test() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;\n        settings.sortDeclarations = true;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n        final String expected = \"\" +\n                \"interface A<T> {\\n\" +\n                \"    data?: T;\\n\" +\n                \"    isNonNullableFlag: boolean;\\n\" +\n                \"    isNullableFlag?: boolean;\\n\" +\n                \"    nonNullableBoolean: boolean;\\n\" +\n                \"    nonNullableString: string;\\n\" +\n                \"    nullableArray?: (string | undefined)[];\\n\" +\n                \"    nullableBoolean?: boolean;\\n\" +\n                \"    nullableGenericArray?: (T | undefined)[];\\n\" +\n                \"    nullableGenericType?: T;\\n\" +\n                \"    nullableList?: (string | undefined)[];\\n\" +\n                \"    nullableString?: string;\\n\" +\n                \"    test: string;\\n\" +\n                \"    testNullable?: string;\\n\" +\n                \"}\";\n        Assert.assertEquals(expected.trim(), output.trim());\n    }\n\n    private static class A<T> {\n\n        public @Nullable String nullableString;\n        public String nonNullableString;\n        public @Nullable List<@Nullable String> nullableList;\n        public @Nullable String @Nullable [] nullableArray;\n        public @Nullable T @Nullable [] nullableGenericArray;\n        public @Nullable T nullableGenericType;\n        public @Nullable Boolean nullableBoolean;\n        public Boolean nonNullableBoolean;\n        public @Nullable Boolean isNullableFlag;\n        public Boolean isNonNullableFlag;\n\n        public <B extends T> @Nullable B getData() {\n            return null;\n        }\n\n        public String getTest() {\n            return \"\";\n        }\n\n        public @Nullable String getTestNullable() {\n            return null;\n        }\n\n    }\n\n    @Test\n    public void testVariants() {\n        testVariant(NullabilityDefinition.nullAndUndefinedUnion,       \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null | undefined\");\n        testVariant(NullabilityDefinition.undefinedUnion,              \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | undefined\");\n        testVariant(NullabilityDefinition.nullUnion,                   \"list: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null\");\n        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, \"list?: (string | null | undefined)[] | null\");\n        testVariant(NullabilityDefinition.undefinedInlineUnion,        \"list?: (string | undefined)[]\");\n        testVariant(NullabilityDefinition.nullInlineUnion,             \"list: (string | null)[] | null\");\n    }\n\n    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        for (String s : expected) {\n            Assert.assertTrue(output.contains(s));\n        }\n    }\n\n    private static class B {\n        public @Nullable List<@Nullable String> list;\n    }\n\n    @Test\n    public void testCombinationsOfOptionalAndNullable() {\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.questionMark,\n                NullabilityDefinition.nullInlineUnion,\n                \"list?: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullInlineUnion,\n                \"list: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableAndUndefinableType,\n                NullabilityDefinition.nullAndUndefinedInlineUnion,\n                \"list: (string | null | undefined)[] | null | undefined;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullAndUndefinedUnion,\n                \"list: Nullable<Nullable<string>[]> | null;\");\n    }\n\n    private static void testCombinationOfOptionalAndNullable(\n            OptionalPropertiesDeclaration optionalPropertiesDeclaration,\n            NullabilityDefinition nullabilityDefinition,\n            String expected\n    ) {\n        final Settings settings = TestUtils.settings();\n        settings.optionalAnnotations.add(Nullable.class);\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        Assert.assertTrue(\"Unexpected actual output: \" + output, output.contains(expected));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testNullableAnnotationTarget() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(javax.annotation.Nullable.class);\n        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n    }\n\n}", "class_id": 0, "repo": "joaocmendes/typescript-generator", "file": "typescript-generator-core/src/test/java/cz/habarta/typescript/generator/NullabilityTest.java", "last_update_at": "2021-05-21T07:38:40+00:00", "question_id": "3b3405f0a50720b0ea3fa6ab7ba19be695a6240c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NullabilityTest {\n    @Test\n    public void test() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;\n        settings.sortDeclarations = true;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n        final String expected = \"\" +\n                \"interface A<T> {\\n\" +\n                \"    data?: T;\\n\" +\n                \"    isNonNullableFlag: boolean;\\n\" +\n                \"    isNullableFlag?: boolean;\\n\" +\n                \"    nonNullableBoolean: boolean;\\n\" +\n                \"    nonNullableString: string;\\n\" +\n                \"    nullableArray?: (string | undefined)[];\\n\" +\n                \"    nullableBoolean?: boolean;\\n\" +\n                \"    nullableGenericArray?: (T | undefined)[];\\n\" +\n                \"    nullableGenericType?: T;\\n\" +\n                \"    nullableList?: (string | undefined)[];\\n\" +\n                \"    nullableString?: string;\\n\" +\n                \"    test: string;\\n\" +\n                \"    testNullable?: string;\\n\" +\n                \"}\";\n        Assert.assertEquals(expected.trim(), output.trim());\n    }\n    private static class A<T> {\n        public @Nullable String nullableString;\n        public String nonNullableString;\n        public @Nullable List<@Nullable String> nullableList;\n        public @Nullable String @Nullable [] nullableArray;\n        public @Nullable T @Nullable [] nullableGenericArray;\n        public @Nullable T nullableGenericType;\n        public @Nullable Boolean nullableBoolean;\n        public Boolean nonNullableBoolean;\n        public @Nullable Boolean isNullableFlag;\n        public Boolean isNonNullableFlag;\n        public <B extends T> @Nullable B getData() {\n            return null;\n        }\n        public String getTest() {\n            return \"\";\n        }\n        public @Nullable String getTestNullable() {\n            return null;\n        }\n    }\n    @Test\n    public void testVariants() {\n        testVariant(NullabilityDefinition.nullAndUndefinedUnion,       \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null | undefined\");\n        testVariant(NullabilityDefinition.undefinedUnion,              \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | undefined\");\n        testVariant(NullabilityDefinition.nullUnion,                   \"list: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null\");\n        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, \"list?: (string | null | undefined)[] | null\");\n        testVariant(NullabilityDefinition.undefinedInlineUnion,        \"list?: (string | undefined)[]\");\n        testVariant(NullabilityDefinition.nullInlineUnion,             \"list: (string | null)[] | null\");\n    }\n    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        for (String s : expected) {\n            Assert.assertTrue(output.contains(s));\n        }\n    }\n    private static class B {\n        public @Nullable List<@Nullable String> list;\n    }\n    @Test\n    public void testCombinationsOfOptionalAndNullable() {\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.questionMark,\n                NullabilityDefinition.nullInlineUnion,\n                \"list?: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullInlineUnion,\n                \"list: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableAndUndefinableType,\n                NullabilityDefinition.nullAndUndefinedInlineUnion,\n                \"list: (string | null | undefined)[] | null | undefined;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullAndUndefinedUnion,\n                \"list: Nullable<Nullable<string>[]> | null;\");\n    }\n    private static void testCombinationOfOptionalAndNullable(\n            OptionalPropertiesDeclaration optionalPropertiesDeclaration,\n            NullabilityDefinition nullabilityDefinition,\n            String expected\n    ) {\n        final Settings settings = TestUtils.settings();\n        settings.optionalAnnotations.add(Nullable.class);\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        Assert.assertTrue(\"Unexpected actual output: \" + output, output.contains(expected));\n    }\n    @Test(expected = RuntimeException.class)\n    public void testNullableAnnotationTarget() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(javax.annotation.Nullable.class);\n        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n    }\n"]], "pred": {"ppl": 1.8248388767242432, "ppl_lower": 2.0762758255004883, "ppl/lowercase_ppl": -1.214606660007226, "ppl/zlib": 0.000611272049197673, "Min_5.0% Prob": 6.2559823522380755, "Min_10.0% Prob": 4.475929806045458, "Min_20.0% Prob": 2.779317012020186, "Min_30.0% Prob": 1.9682804911939147, "Min_40.0% Prob": 1.495115466097092, "Min_50.0% Prob": 1.2020451517050281, "Min_60.0% Prob": 1.0032873740017134}}
{"hexsha": "147107bc0784d1e698608f00c42fa859e9ca63b2", "ext": "java", "lang": "Java", "content": "public class DatabaseWriter {\n\n  ProcessingEnvironment processingEnv;\n\n  Elements elementUtils;\n\n  Element database;\n\n  String className;\n\n  ClassName clazzName;\n\n  String fileName;\n\n  List<VariableElement> tables = new ArrayList<>();\n\n  List<VariableElement> execOnCreate = new ArrayList<>();\n\n  ExecutableElement onCreate;\n\n  ExecutableElement onUpgrade;\n\n  ExecutableElement onConfigure;\n\n  int version;\n\n  String outPackage;\n\n  public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {\n    this.processingEnv = env;\n    this.elementUtils = env.getElementUtils();\n\n    this.database = database;\n\n    String databaseSchematicName = database.getSimpleName().toString();\n\n    Database db = database.getAnnotation(Database.class);\n    this.version = db.version();\n\n    this.className = db.className();\n    if (className.trim().isEmpty()) {\n      this.className = databaseSchematicName;\n    }\n\n    this.outPackage = db.packageName();\n    if (outPackage.trim().isEmpty()) {\n      this.outPackage = elements.getPackageOf(database).getQualifiedName() + \".generated\";\n    }\n\n    this.fileName = db.fileName();\n    if (fileName.trim().isEmpty()) {\n      this.fileName =\n          CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + \".db\";\n    }\n\n    clazzName = ClassName.get(outPackage, className);\n\n    findAnnotations(database);\n  }\n\n  private void findAnnotations(Element element) {\n    List<? extends Element> enclosedElements = element.getEnclosedElements();\n\n    for (Element enclosedElement : enclosedElements) {\n      findAnnotations(enclosedElement);\n\n      Table table = enclosedElement.getAnnotation(Table.class);\n      if (table != null) {\n        tables.add((VariableElement) enclosedElement);\n      }\n\n      OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);\n      if (onCreate != null) {\n        if (this.onCreate != null) {\n          error(\"Multiple OnCreate annotations found in \" + database.getSimpleName().toString());\n        }\n\n        this.onCreate = (ExecutableElement) enclosedElement;\n      }\n\n      OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);\n      if (onUpgrade != null) {\n        if (this.onUpgrade != null) {\n          error(\"Multiple OnUpgrade annotations found in \" + database.getSimpleName().toString());\n        }\n\n        this.onUpgrade = (ExecutableElement) enclosedElement;\n      }\n\n      OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);\n      if (onConfigure != null) {\n        if (this.onConfigure != null) {\n          error(\"Multiple OnConfigure annotations found in \" + database.getSimpleName().toString());\n        }\n\n        this.onConfigure = (ExecutableElement) enclosedElement;\n      }\n\n      ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);\n      if (execOnCreate != null) {\n        this.execOnCreate.add((VariableElement) enclosedElement);\n      }\n    }\n  }\n\n  public void writeJava(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getFileName());\n    Writer out = jfo.openWriter();\n\n    TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className)\n        .superclass(Clazz.SQLITE_OPEN_HELPER)\n        .addModifiers(Modifier.PUBLIC);\n\n    FieldSpec versionSpec =\n        FieldSpec.builder(int.class, \"DATABASE_VERSION\", Modifier.PRIVATE, Modifier.STATIC,\n            Modifier.FINAL).initializer(\"$L\", version).build();\n    databaseBuilder.addField(versionSpec);\n\n    for (VariableElement table : tables) {\n      TypeElement tableClass = null;\n      Table columns = table.getAnnotation(Table.class);\n      try {\n        columns.value();\n      } catch (MirroredTypeException e) {\n        TypeMirror mirror = e.getTypeMirror();\n        tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);\n      }\n\n      ClassName tableClassName = ClassName.get(tableClass);\n\n      TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);\n      tableWriter.createTable(databaseBuilder);\n      tableWriter.createValuesBuilder(filer, outPackage);\n    }\n\n    WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);\n\n    databaseBuilder.addField(Clazz.CONTEXT, \"context\", Modifier.PRIVATE);\n\n    MethodSpec constructor = MethodSpec.constructorBuilder()\n        .addModifiers(Modifier.PRIVATE)\n        .addParameter(Clazz.CONTEXT, \"context\")\n        .addStatement(\"super(context.getApplicationContext(), $S, null, DATABASE_VERSION)\", fileName)\n        .addStatement(\"this.context = context.getApplicationContext()\")\n        .build();\n    databaseBuilder.addMethod(constructor);\n\n    databaseBuilder.addMethod(getOnCreateSpec());\n    databaseBuilder.addMethod(getOnUpgradeSpec());\n\n    if (onConfigure != null) {\n      databaseBuilder.addMethod(getOnConfigureSpec());\n    }\n\n    JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n\n  private MethodSpec getOnCreateSpec() {\n    MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder(\"onCreate\")\n        .returns(void.class)\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n\n    for (VariableElement table : tables) {\n      onCreateBuilder.addStatement(\"db.execSQL($L)\", table.getSimpleName().toString());\n    }\n\n    for (VariableElement exec : execOnCreate) {\n      String variableName = exec.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"db.execSQL($T.$L)\", exec.getEnclosingElement(), variableName);\n    }\n\n    if (onCreate != null) {\n      List<? extends VariableElement> parameters = onCreate.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n        TypeMirror paramType = param.asType();\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n      }\n\n      String methodName = onCreate.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"$T.$L($L)\", onCreate.getEnclosingElement(), methodName,\n          params.toString());\n    }\n\n    return onCreateBuilder.build();\n  }\n\n  private MethodSpec getOnUpgradeSpec() {\n    MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder(\"onUpgrade\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\")\n        .addParameter(int.class, \"oldVersion\")\n        .addParameter(int.class, \"newVersion\");\n\n    if (onUpgrade != null) {\n      List<? extends VariableElement> parameters = onUpgrade.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n\n        TypeMirror paramType = param.asType();\n\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n        if (TypeName.get(int.class).equals(TypeName.get(paramType))) {\n          String name = param.getSimpleName().toString();\n          if (\"oldVersion\".equals(name)) {\n            params.append(\"oldVersion\");\n          } else if (\"newVersion\".equals(name)) {\n            params.append(\"newVersion\");\n          } else {\n            error(\"Unknown int parameter: \" + name);\n          }\n        }\n      }\n\n      String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();\n      String methodName = onUpgrade.getSimpleName().toString();\n      onUpgradeBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n    }\n\n    return onUpgradeBuilder.build();\n  }\n\n  private MethodSpec getOnConfigureSpec() {\n    MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder(\"onConfigure\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n\n    List<? extends VariableElement> parameters = onConfigure.getParameters();\n    StringBuilder params = new StringBuilder();\n    boolean first = true;\n    for (VariableElement param : parameters) {\n      if (first) {\n        first = false;\n      } else {\n        params.append(\", \");\n      }\n      TypeMirror paramType = param.asType();\n      if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n        params.append(\"db\");\n      } else {\n        throw new IllegalArgumentException(\n            \"OnConfigure does not support parameter \" + paramType.toString());\n      }\n    }\n\n    String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();\n    String methodName = onConfigure.getSimpleName().toString();\n    onConfigureBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n\n    return onConfigureBuilder.build();\n  }\n\n  public void writeValues(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getValuesFileName());\n    Writer out = jfo.openWriter();\n\n    final String valuesPackage = outPackage + \".values\";\n\n    TypeSpec.Builder spec =\n        TypeSpec.classBuilder(className + \"Values\").addModifiers(Modifier.PUBLIC);\n\n    for (VariableElement table : tables) {\n      Table tableAnnotation = table.getAnnotation(Table.class);\n      String tableName = table.getConstantValue().toString();\n      tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);\n\n      String methodName = \"for\" + tableName;\n      String valuesName = tableName + \"ValuesBuilder\";\n      ClassName builderClass = ClassName.get(valuesPackage, valuesName);\n\n      MethodSpec builderSpec = MethodSpec.methodBuilder(methodName)\n          .addModifiers(Modifier.PUBLIC)\n          .returns(builderClass)\n          .addStatement(\"return new $T()\", builderClass)\n          .build();\n\n      spec.addMethod(builderSpec);\n    }\n\n    JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n\n  private String getFileName() {\n    return outPackage + \".\" + className;\n  }\n\n  private String getValuesFileName() {\n    return outPackage + \".values.\" + className + \"Values\";\n  }\n\n  private void error(String error) {\n    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);\n  }\n}", "class_id": 0, "repo": "icse18-refactorings/schematic", "file": "schematic-compiler/src/main/java/net/simonvt/schematic/compiler/DatabaseWriter.java", "last_update_at": "2021-12-31T14:46:37+00:00", "question_id": "147107bc0784d1e698608f00c42fa859e9ca63b2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DatabaseWriter {\n  ProcessingEnvironment processingEnv;\n  Elements elementUtils;\n  Element database;\n  String className;\n  ClassName clazzName;\n  String fileName;\n  List<VariableElement> tables = new ArrayList<>();\n  List<VariableElement> execOnCreate = new ArrayList<>();\n  ExecutableElement onCreate;\n  ExecutableElement onUpgrade;\n  ExecutableElement onConfigure;\n  int version;\n  String outPackage;\n  public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {\n    this.processingEnv = env;\n    this.elementUtils = env.getElementUtils();\n    this.database = database;\n    String databaseSchematicName = database.getSimpleName().toString();\n    Database db = database.getAnnotation(Database.class);\n    this.version = db.version();\n    this.className = db.className();\n    if (className.trim().isEmpty()) {\n      this.className = databaseSchematicName;\n    }\n    this.outPackage = db.packageName();\n    if (outPackage.trim().isEmpty()) {\n      this.outPackage = elements.getPackageOf(database).getQualifiedName() + \".generated\";\n    }\n    this.fileName = db.fileName();\n    if (fileName.trim().isEmpty()) {\n      this.fileName =\n          CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + \".db\";\n    }\n    clazzName = ClassName.get(outPackage, className);\n    findAnnotations(database);\n  }\n  private void findAnnotations(Element element) {\n    List<? extends Element> enclosedElements = element.getEnclosedElements();\n    for (Element enclosedElement : enclosedElements) {\n      findAnnotations(enclosedElement);\n      Table table = enclosedElement.getAnnotation(Table.class);\n      if (table != null) {\n        tables.add((VariableElement) enclosedElement);\n      }\n      OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);\n      if (onCreate != null) {\n        if (this.onCreate != null) {\n          error(\"Multiple OnCreate annotations found in \" + database.getSimpleName().toString());\n        }\n        this.onCreate = (ExecutableElement) enclosedElement;\n      }\n      OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);\n      if (onUpgrade != null) {\n        if (this.onUpgrade != null) {\n          error(\"Multiple OnUpgrade annotations found in \" + database.getSimpleName().toString());\n        }\n        this.onUpgrade = (ExecutableElement) enclosedElement;\n      }\n      OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);\n      if (onConfigure != null) {\n        if (this.onConfigure != null) {\n          error(\"Multiple OnConfigure annotations found in \" + database.getSimpleName().toString());\n        }\n        this.onConfigure = (ExecutableElement) enclosedElement;\n      }\n      ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);\n      if (execOnCreate != null) {\n        this.execOnCreate.add((VariableElement) enclosedElement);\n      }\n    }\n  }\n  public void writeJava(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getFileName());\n    Writer out = jfo.openWriter();\n    TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className)\n        .superclass(Clazz.SQLITE_OPEN_HELPER)\n        .addModifiers(Modifier.PUBLIC);\n    FieldSpec versionSpec =\n        FieldSpec.builder(int.class, \"DATABASE_VERSION\", Modifier.PRIVATE, Modifier.STATIC,\n            Modifier.FINAL).initializer(\"$L\", version).build();\n    databaseBuilder.addField(versionSpec);\n    for (VariableElement table : tables) {\n      TypeElement tableClass = null;\n      Table columns = table.getAnnotation(Table.class);\n      try {\n        columns.value();\n      } catch (MirroredTypeException e) {\n        TypeMirror mirror = e.getTypeMirror();\n        tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);\n      }\n      ClassName tableClassName = ClassName.get(tableClass);\n      TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);\n      tableWriter.createTable(databaseBuilder);\n      tableWriter.createValuesBuilder(filer, outPackage);\n    }\n    WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);\n    databaseBuilder.addField(Clazz.CONTEXT, \"context\", Modifier.PRIVATE);\n    MethodSpec constructor = MethodSpec.constructorBuilder()\n        .addModifiers(Modifier.PRIVATE)\n        .addParameter(Clazz.CONTEXT, \"context\")\n        .addStatement(\"super(context.getApplicationContext(), $S, null, DATABASE_VERSION)\", fileName)\n        .addStatement(\"this.context = context.getApplicationContext()\")\n        .build();\n    databaseBuilder.addMethod(constructor);\n    databaseBuilder.addMethod(getOnCreateSpec());\n    databaseBuilder.addMethod(getOnUpgradeSpec());\n    if (onConfigure != null) {\n      databaseBuilder.addMethod(getOnConfigureSpec());\n    }\n    JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n  private MethodSpec getOnCreateSpec() {\n    MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder(\"onCreate\")\n        .returns(void.class)\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n    for (VariableElement table : tables) {\n      onCreateBuilder.addStatement(\"db.execSQL($L)\", table.getSimpleName().toString());\n    }\n    for (VariableElement exec : execOnCreate) {\n      String variableName = exec.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"db.execSQL($T.$L)\", exec.getEnclosingElement(), variableName);\n    }\n    if (onCreate != null) {\n      List<? extends VariableElement> parameters = onCreate.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n        TypeMirror paramType = param.asType();\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n      }\n      String methodName = onCreate.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"$T.$L($L)\", onCreate.getEnclosingElement(), methodName,\n          params.toString());\n    }\n    return onCreateBuilder.build();\n  }\n  private MethodSpec getOnUpgradeSpec() {\n    MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder(\"onUpgrade\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\")\n        .addParameter(int.class, \"oldVersion\")\n        .addParameter(int.class, \"newVersion\");\n    if (onUpgrade != null) {\n      List<? extends VariableElement> parameters = onUpgrade.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n        TypeMirror paramType = param.asType();\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n        if (TypeName.get(int.class).equals(TypeName.get(paramType))) {\n          String name = param.getSimpleName().toString();\n          if (\"oldVersion\".equals(name)) {\n            params.append(\"oldVersion\");\n          } else if (\"newVersion\".equals(name)) {\n            params.append(\"newVersion\");\n          } else {\n            error(\"Unknown int parameter: \" + name);\n          }\n        }\n      }\n      String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();\n      String methodName = onUpgrade.getSimpleName().toString();\n      onUpgradeBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n    }\n    return onUpgradeBuilder.build();\n  }\n  private MethodSpec getOnConfigureSpec() {\n    MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder(\"onConfigure\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n    List<? extends VariableElement> parameters = onConfigure.getParameters();\n    StringBuilder params = new StringBuilder();\n    boolean first = true;\n    for (VariableElement param : parameters) {\n      if (first) {\n        first = false;\n      } else {\n        params.append(\", \");\n      }\n      TypeMirror paramType = param.asType();\n      if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n        params.append(\"db\");\n      } else {\n        throw new IllegalArgumentException(\n            \"OnConfigure does not support parameter \" + paramType.toString());\n      }\n    }\n    String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();\n    String methodName = onConfigure.getSimpleName().toString();\n    onConfigureBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n    return onConfigureBuilder.build();\n  }\n  public void writeValues(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getValuesFileName());\n    Writer out = jfo.openWriter();\n    final String valuesPackage = outPackage + \".values\";\n    TypeSpec.Builder spec =\n        TypeSpec.classBuilder(className + \"Values\").addModifiers(Modifier.PUBLIC);\n    for (VariableElement table : tables) {\n      Table tableAnnotation = table.getAnnotation(Table.class);\n      String tableName = table.getConstantValue().toString();\n      tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);\n      String methodName = \"for\" + tableName;\n      String valuesName = tableName + \"ValuesBuilder\";\n      ClassName builderClass = ClassName.get(valuesPackage, valuesName);\n      MethodSpec builderSpec = MethodSpec.methodBuilder(methodName)\n          .addModifiers(Modifier.PUBLIC)\n          .returns(builderClass)\n          .addStatement(\"return new $T()\", builderClass)\n          .build();\n      spec.addMethod(builderSpec);\n    }\n    JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n  private String getFileName() {\n    return outPackage + \".\" + className;\n  }\n  private String getValuesFileName() {\n    return outPackage + \".values.\" + className + \"Values\";\n  }\n  private void error(String error) {\n    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);\n  }\n"]], "pred": {"ppl": 1.547661304473877, "ppl_lower": 2.02961802482605, "ppl/lowercase_ppl": -1.6207344837084128, "ppl/zlib": 0.0001878472927607673, "Min_5.0% Prob": 5.054263077530206, "Min_10.0% Prob": 3.474319141285092, "Min_20.0% Prob": 2.0967841196586106, "Min_30.0% Prob": 1.4450540731910593, "Min_40.0% Prob": 1.0894083720916532, "Min_50.0% Prob": 0.8736627452793566, "Min_60.0% Prob": 0.7286812444177622}}
{"hexsha": "411be56df51eee3c16dfe6b0f35455330e5f8f63", "ext": "java", "lang": "Java", "content": "public final class DnsUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);\n\n    /**\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\n     */\n    public static boolean anyInterfaceSupportsIpV6() {\n        try {\n            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                final NetworkInterface iface = interfaces.nextElement();\n                final Enumeration<InetAddress> addresses = iface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    final InetAddress inetAddress = addresses.nextElement();\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() &&\n                        !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\n                        return true;\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\n        }\n        return false;\n    }\n\n    @Nullable\n    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {\n        final DnsRecordType type = record.type();\n        final ByteBuf content = ((ByteBufHolder) record).content();\n        final int contentLen = content.readableBytes();\n\n        // Skip invalid records.\n        if (type == DnsRecordType.A) {\n            if (contentLen != 4) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else if (type == DnsRecordType.AAAA) {\n            if (contentLen != 16) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else {\n            return null;\n        }\n\n        final byte[] addrBytes = new byte[contentLen];\n        content.getBytes(content.readerIndex(), addrBytes);\n        return addrBytes;\n    }\n\n    /**\n     * Logs a warning message about an invalid record.\n     */\n    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {\n        if (logger.isWarnEnabled()) {\n            final String dump = ByteBufUtil.hexDump(content);\n            logger.warn(\"{} Skipping invalid {} record: {}\",\n                        logPrefix, type.name(), dump.isEmpty() ? \"<empty>\" : dump);\n        }\n    }\n\n    private DnsUtil() {}\n}", "class_id": 0, "repo": "georgecao/armeria", "file": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "last_update_at": "2021-12-22T01:14:48+00:00", "question_id": "411be56df51eee3c16dfe6b0f35455330e5f8f63", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class DnsUtil {\n    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);\n    /**\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\n     */\n    public static boolean anyInterfaceSupportsIpV6() {\n        try {\n            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                final NetworkInterface iface = interfaces.nextElement();\n                final Enumeration<InetAddress> addresses = iface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    final InetAddress inetAddress = addresses.nextElement();\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() &&\n                        !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\n                        return true;\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\n        }\n        return false;\n    }\n    @Nullable\n    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {\n        final DnsRecordType type = record.type();\n        final ByteBuf content = ((ByteBufHolder) record).content();\n        final int contentLen = content.readableBytes();\n        // Skip invalid records.\n        if (type == DnsRecordType.A) {\n            if (contentLen != 4) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else if (type == DnsRecordType.AAAA) {\n            if (contentLen != 16) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else {\n            return null;\n        }\n        final byte[] addrBytes = new byte[contentLen];\n        content.getBytes(content.readerIndex(), addrBytes);\n        return addrBytes;\n    }\n    /**\n     * Logs a warning message about an invalid record.\n     */\n    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {\n        if (logger.isWarnEnabled()) {\n            final String dump = ByteBufUtil.hexDump(content);\n            logger.warn(\"{} Skipping invalid {} record: {}\",\n                        logPrefix, type.name(), dump.isEmpty() ? \"<empty>\" : dump);\n        }\n    }\n    private DnsUtil() {}\n"]], "pred": {"ppl": 1.5895977020263672, "ppl_lower": 1.8170149326324463, "ppl/lowercase_ppl": -1.2884995300229358, "ppl/zlib": 0.0005278826499137914, "Min_5.0% Prob": 4.439810670912266, "Min_10.0% Prob": 3.3084882186009335, "Min_20.0% Prob": 2.151583595917775, "Min_30.0% Prob": 1.5130650652524753, "Min_40.0% Prob": 1.1524932881817223, "Min_50.0% Prob": 0.9256732653453946, "Min_60.0% Prob": 0.772164851704087}}
{"hexsha": "c56eafd18ce46221d394fe0d46db958c396d688c", "ext": "java", "lang": "Java", "content": "class LogicalFormatValidator\n    extends AbstractDataValidator\n{\n    private static final Pattern booleanPattern = Pattern.compile(\"[YNTF ]\");\n\n    LogicalFormatValidator(final Field field)\n    {\n        super(field);\n        assert field.getType() == Type.LOGICAL : \"Can only be validator for LOGICAL fields\";\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A\n     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not\n     * contain leading or trailing spaces.\n     */\n    public void validate(final Object typedObject)\n                  throws DbfLibException\n    {\n        if (typedObject instanceof Boolean)\n        {\n            return;\n        }\n\n        if (typedObject instanceof String)\n        {\n            final String booleanString = (String) typedObject;\n\n            if (! booleanPattern.matcher(booleanString).matches())\n            {\n                throw new DataMismatchException(\"Boolean must be one of Y, N, T, F or a space\");\n            }\n\n            return;\n        }\n\n        throw new DataMismatchException(\"Cannot write objects of type '\" + typedObject.getClass().getName()\n                                        + \"' to a LOGICAL field\");\n    }\n}", "class_id": 0, "repo": "Switajski/dans-dbf-lib", "file": "src/main/java/nl/knaw/dans/common/dbflib/LogicalFormatValidator.java", "last_update_at": "2021-05-25T13:50:19+00:00", "question_id": "c56eafd18ce46221d394fe0d46db958c396d688c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class LogicalFormatValidator\n    extends AbstractDataValidator\n{\n    private static final Pattern booleanPattern = Pattern.compile(\"[YNTF ]\");\n    LogicalFormatValidator(final Field field)\n    {\n        super(field);\n        assert field.getType() == Type.LOGICAL : \"Can only be validator for LOGICAL fields\";\n    }\n    /**\n     * {@inheritDoc}\n     * <p>\n     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A\n     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not\n     * contain leading or trailing spaces.\n     */\n    public void validate(final Object typedObject)\n                  throws DbfLibException\n    {\n        if (typedObject instanceof Boolean)\n        {\n            return;\n        }\n        if (typedObject instanceof String)\n        {\n            final String booleanString = (String) typedObject;\n            if (! booleanPattern.matcher(booleanString).matches())\n            {\n                throw new DataMismatchException(\"Boolean must be one of Y, N, T, F or a space\");\n            }\n            return;\n        }\n        throw new DataMismatchException(\"Cannot write objects of type '\" + typedObject.getClass().getName()\n                                        + \"' to a LOGICAL field\");\n    }\n"]], "pred": {"ppl": 2.650135040283203, "ppl_lower": 3.1553256511688232, "ppl/lowercase_ppl": -1.1790264864135718, "ppl/zlib": 0.0017560551302652626, "Min_5.0% Prob": 6.2608087956905365, "Min_10.0% Prob": 5.121305422349409, "Min_20.0% Prob": 3.861536782179306, "Min_30.0% Prob": 2.9823600143194198, "Min_40.0% Prob": 2.3505672712379426, "Min_50.0% Prob": 1.9204772707252276, "Min_60.0% Prob": 1.6232858468310454}}
{"hexsha": "8c883a23ce2238926cc5819852b763dc95f1d839", "ext": "java", "lang": "Java", "content": "public class NumFilter implements Filter {\n    @Override\n    public boolean doFilter(Msg msg) {\n        String msg1 = msg.getMsg();\n        String num = msg1.replace(\"123\", \"num\");\n        msg.setMsg(num);\n        return true;\n    }\n}", "class_id": 0, "repo": "zhaochaoyue1/Beyond", "file": "student/src/test/java/com/example/designPattern23/chainOfResponsibility/easyImpl/NumFilter.java", "last_update_at": "2021-09-20T20:51:51+00:00", "question_id": "8c883a23ce2238926cc5819852b763dc95f1d839", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NumFilter implements Filter {\n    @Override\n    public boolean doFilter(Msg msg) {\n        String msg1 = msg.getMsg();\n        String num = msg1.replace(\"123\", \"num\");\n        msg.setMsg(num);\n        return true;\n    }\n"]], "pred": {"ppl": 3.239901304244995, "ppl_lower": 4.473978519439697, "ppl/lowercase_ppl": -1.2745414080948807, "ppl/zlib": 0.007633395244723981, "Min_5.0% Prob": 8.338603337605795, "Min_10.0% Prob": 7.372209390004476, "Min_20.0% Prob": 5.091641682844895, "Min_30.0% Prob": 3.708466428518295, "Min_40.0% Prob": 2.8639358944363065, "Min_50.0% Prob": 2.3369874292436768, "Min_60.0% Prob": 1.963557240257903}}
{"hexsha": "004f0b95f9d31afac73fdba3b9f2530353bc2072", "ext": "java", "lang": "Java", "content": "public class MessagesManager {\n  private Configuration freemarkerCfg = null;\n  @Inject\n  private ServletContext context;\n  @Inject\n  private AssetsManager assetsManager;\n  @Inject\n  private SherlockConfig config;\n\n  @PostConstruct\n  public void init() {\n    WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, \"WEB-INF/messages/\");\n    freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);\n    freemarkerCfg.setTemplateLoader(templateLoader);\n    freemarkerCfg.setDefaultEncoding(\"UTF-8\");\n    freemarkerCfg.setLocale(Locale.US);\n    freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n  }\n\n  public String message(String id) throws IOException, MessageException {\n    return message(id, ImmutableMap.of());\n  }\n\n  public String message(String id, Map<String, Object> context)\n      throws IOException, MessageException {\n    if (!context.containsKey(\"random\")) {\n      ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\n      builder.putAll(context);\n      builder.put(\"tool\", new MessagesTool(assetsManager, config));\n      context = builder.build();\n    }\n    Template template = freemarkerCfg.getTemplate(id + \".ftl\");\n    StringWriter output = new StringWriter();\n    try {\n      template.process(context, output);\n    } catch (TemplateException e) {\n      throw new MessageException(\"Freemarker error\", e);\n    }\n    return output.toString();\n  }\n}", "class_id": 0, "repo": "actions-on-google-labs/sherlock-mysteries-java", "file": "sherlock-web/src/main/java/com/google/mystery/actions/messages/MessagesManager.java", "last_update_at": "2021-03-31T21:52:36+00:00", "question_id": "004f0b95f9d31afac73fdba3b9f2530353bc2072", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessagesManager {\n  private Configuration freemarkerCfg = null;\n  @Inject\n  private ServletContext context;\n  @Inject\n  private AssetsManager assetsManager;\n  @Inject\n  private SherlockConfig config;\n  @PostConstruct\n  public void init() {\n    WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, \"WEB-INF/messages/\");\n    freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);\n    freemarkerCfg.setTemplateLoader(templateLoader);\n    freemarkerCfg.setDefaultEncoding(\"UTF-8\");\n    freemarkerCfg.setLocale(Locale.US);\n    freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n  }\n  public String message(String id) throws IOException, MessageException {\n    return message(id, ImmutableMap.of());\n  }\n  public String message(String id, Map<String, Object> context)\n      throws IOException, MessageException {\n    if (!context.containsKey(\"random\")) {\n      ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\n      builder.putAll(context);\n      builder.put(\"tool\", new MessagesTool(assetsManager, config));\n      context = builder.build();\n    }\n    Template template = freemarkerCfg.getTemplate(id + \".ftl\");\n    StringWriter output = new StringWriter();\n    try {\n      template.process(context, output);\n    } catch (TemplateException e) {\n      throw new MessageException(\"Freemarker error\", e);\n    }\n    return output.toString();\n  }\n"]], "pred": {"ppl": 1.8504858016967773, "ppl_lower": 2.491344690322876, "ppl/lowercase_ppl": -1.4831834763529705, "ppl/zlib": 0.0010703446958779796, "Min_5.0% Prob": 7.35440604686737, "Min_10.0% Prob": 4.790301978588104, "Min_20.0% Prob": 2.8337920786421975, "Min_30.0% Prob": 2.008998094388276, "Min_40.0% Prob": 1.5279990982402254, "Min_50.0% Prob": 1.2311647654428046, "Min_60.0% Prob": 1.0250512006895716}}
{"hexsha": "5e2fa117bef24890f7d8225ed48450f9a62751c1", "ext": "java", "lang": "Java", "content": "public class CompletionJavadoc extends Javadoc {\n\n\tExpression completionNode;\n\n\tpublic CompletionJavadoc(int sourceStart, int sourceEnd) {\n\t\tsuper(sourceStart, sourceEnd);\n\t}\n\n\t/**\n\t * @return Returns the completionNode.\n\t */\n\tpublic Expression getCompletionNode() {\n\t\treturn this.completionNode;\n\t}\n\n\t/**\n\t * Resolve selected node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tprivate void internalResolve(Scope scope) {\n\t\tif (this.completionNode != null) {\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocTag) {\n\t\t\t\t((CompletionOnJavadocTag)this.completionNode).filterPossibleTags(scope);\n\t\t\t} else {\n\t\t\t\tboolean resolve = true;\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocParamNameReference)this.completionNode).token != null;\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocTypeParamReference)this.completionNode).token != null;\n\t\t\t\t}\n\t\t\t\tif (resolve) {\n\t\t\t\t\tswitch (scope.kind) {\n\t\t\t\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((ClassScope)scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((MethodScope) scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tCompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;\n\t\t\t\t\tif (scope.kind == Scope.METHOD_SCOPE) {\n\t\t\t\t\t\tparamNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope)scope);\n\t\t\t\t\t}\n\t\t\t\t\tif (paramNameReference.token == null || paramNameReference.token.length == 0) {\n\t\t\t\t\t\tparamNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);\n\t\t\t\t\t}\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tCompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;\n\t\t\t\t\ttypeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBinding qualifiedBinding = null;\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {\n\t\t\t\tCompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;\n\t\t\t\tif (typeRef.packageBinding == null) {\n\t\t\t\t\tqualifiedBinding = typeRef.resolvedType;\n\t\t\t\t} else {\n\t\t\t\t\tqualifiedBinding = typeRef.packageBinding;\n\t\t\t\t}\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {\n\t\t\t\tCompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;\n\t\t\t\tif (!msg.receiver.isThis()) qualifiedBinding = msg.receiver.resolvedType;\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {\n\t\t\t\tCompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;\n\t\t\t\tqualifiedBinding = alloc.type.resolvedType;\n\t\t\t}\n\t\t\tthrow new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);\n\t\t}\n\t}\n\n\t/*\n\t * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)\n\t */\n\tpublic StringBuffer print(int indent, StringBuffer output) {\n\t\tprintIndent(indent, output).append(\"/**\\n\"); //$NON-NLS-1$\n\t\tboolean nodePrinted = false;\n\t\tif (this.paramReferences != null) {\n\t\t\tfor (int i = 0, length = this.paramReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param \"); //$NON-NLS-1$\n\t\t\t\tthis.paramReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.paramTypeParameters != null) {\n\t\t\tfor (int i = 0, length = this.paramTypeParameters.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param <\"); //$NON-NLS-1$\n\t\t\t\tthis.paramTypeParameters[i].print(indent, output).append(\">\\n\"); //$NON-NLS-1$\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramTypeParameters[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.returnStatement != null) {\n\t\t\tprintIndent(indent, output).append(\" * @\"); //$NON-NLS-1$\n\t\t\tthis.returnStatement.print(indent, output).append('\\n');\n\t\t}\n\t\tif (this.exceptionReferences != null) {\n\t\t\tfor (int i = 0, length = this.exceptionReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @throws \"); //$NON-NLS-1$\n\t\t\t\tthis.exceptionReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.exceptionReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.seeReferences != null) {\n\t\t\tfor (int i = 0, length = this.seeReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @see \"); //$NON-NLS-1$\n\t\t\t\tthis.seeReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.seeReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\tprintIndent(indent, output).append(\" * \"); //$NON-NLS-1$\n\t\t\tthis.completionNode.print(indent, output).append('\\n');\n\t\t}\n\t\tprintIndent(indent, output).append(\" */\\n\"); //$NON-NLS-1$\n\t\treturn output;\n\t}\n\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(ClassScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(CompilationUnitScope scope) {\n\t\tinternalResolve(scope);\n\t}\n\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(MethodScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\n\t/*\n\t * Look for missing method @param tags\n\t */\n\tprivate char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {\n\n\t\t// Verify if there's some possible param tag\n\t\tAbstractMethodDeclaration md = methScope.referenceMethod();\n\t\tint paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;\n\t\tif (md == null) return null;\n\t\tint argumentsSize = md.arguments == null ? 0 : md.arguments.length;\n\t\tif (argumentsSize == 0) return null;\n\n\t\t// Store all method arguments if there's no @param in javadoc\n\t\tif (paramTagsSize == 0) {\n\t\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\t\tmissingParams[i] = md.arguments[i].name;\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\n\t\t// Look for missing arguments\n\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\tint size = 0;\n\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\tArgument arg = md.arguments[i];\n\t\t\tboolean found = false;\n\t\t\tint paramNameRefCount = 0;\n\t\t\tfor (int j = 0; j < paramTagsSize && !found; j++) {\n\t\t\t\tJavadocSingleNameReference param = this.paramReferences[j];\n\t\t\t\tif (arg.binding == param.binding) {\n\t\t\t\t\tif (param.binding == paramNameRefBinding) { // do not count first occurence of param name reference\n\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tmissingParams[size++] = arg.name;\n\t\t\t}\n\t\t}\n\t\tif (size > 0) {\n\t\t\tif (size != argumentsSize) {\n\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Look for missing type parameters @param tags\n\t */\n\tprivate char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {\n\t\tint paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;\n\n\t\t// Verify if there's any type parameter to tag\n\t\tTypeParameter[] parameters =  null;\n\t\tTypeVariableBinding[] typeVariables = null;\n\t\tswitch (scope.kind) {\n\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\tAbstractMethodDeclaration methodDeclaration = ((MethodScope)scope).referenceMethod();\n\t\t\t\tif (methodDeclaration == null) return null;\n\t\t\t\tparameters = methodDeclaration.typeParameters();\n\t\t\t\ttypeVariables = methodDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\tTypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;\n\t\t\t\tparameters = typeDeclaration.typeParameters;\n\t\t\t\ttypeVariables = typeDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (typeVariables == null || typeVariables.length == 0) return null;\n\n\t\t// Store all type parameters if there's no @param in javadoc\n\t\tif (parameters != null) {\n\t\t\tint typeParametersLength = parameters.length;\n\t\t\tif (paramTypeParamLength == 0) {\n\t\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\t\tmissingParams[i] = parameters[i].name;\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\n\t\t\t// Look for missing type parameter\n\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\tint size = 0;\n\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\tTypeParameter parameter = parameters[i];\n\t\t\t\tboolean found = false;\n\t\t\t\tint paramNameRefCount = 0;\n\t\t\t\tfor (int j = 0; j < paramTypeParamLength && !found; j++) {\n\t\t\t\t\tif (parameter.binding == this.paramTypeParameters[j].resolvedType) {\n\t\t\t\t\t\tif (parameter.binding == paramNameRefBinding) { // do not count first occurence of param nmae reference\n\t\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tmissingParams[size++] = parameter.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0) {\n\t\t\t\tif (size != typeParametersLength) {\n\t\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}", "class_id": 0, "repo": "TheRakeshPurohit/CodingSpectator", "file": "plug-ins/indigo/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionJavadoc.java", "last_update_at": "2021-05-11T06:56:51+00:00", "question_id": "5e2fa117bef24890f7d8225ed48450f9a62751c1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompletionJavadoc extends Javadoc {\n\tExpression completionNode;\n\tpublic CompletionJavadoc(int sourceStart, int sourceEnd) {\n\t\tsuper(sourceStart, sourceEnd);\n\t}\n\t/**\n\t * @return Returns the completionNode.\n\t */\n\tpublic Expression getCompletionNode() {\n\t\treturn this.completionNode;\n\t}\n\t/**\n\t * Resolve selected node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tprivate void internalResolve(Scope scope) {\n\t\tif (this.completionNode != null) {\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocTag) {\n\t\t\t\t((CompletionOnJavadocTag)this.completionNode).filterPossibleTags(scope);\n\t\t\t} else {\n\t\t\t\tboolean resolve = true;\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocParamNameReference)this.completionNode).token != null;\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocTypeParamReference)this.completionNode).token != null;\n\t\t\t\t}\n\t\t\t\tif (resolve) {\n\t\t\t\t\tswitch (scope.kind) {\n\t\t\t\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((ClassScope)scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((MethodScope) scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tCompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;\n\t\t\t\t\tif (scope.kind == Scope.METHOD_SCOPE) {\n\t\t\t\t\t\tparamNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope)scope);\n\t\t\t\t\t}\n\t\t\t\t\tif (paramNameReference.token == null || paramNameReference.token.length == 0) {\n\t\t\t\t\t\tparamNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);\n\t\t\t\t\t}\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tCompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;\n\t\t\t\t\ttypeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBinding qualifiedBinding = null;\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {\n\t\t\t\tCompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;\n\t\t\t\tif (typeRef.packageBinding == null) {\n\t\t\t\t\tqualifiedBinding = typeRef.resolvedType;\n\t\t\t\t} else {\n\t\t\t\t\tqualifiedBinding = typeRef.packageBinding;\n\t\t\t\t}\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {\n\t\t\t\tCompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;\n\t\t\t\tif (!msg.receiver.isThis()) qualifiedBinding = msg.receiver.resolvedType;\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {\n\t\t\t\tCompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;\n\t\t\t\tqualifiedBinding = alloc.type.resolvedType;\n\t\t\t}\n\t\t\tthrow new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);\n\t\t}\n\t}\n\t/*\n\t * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)\n\t */\n\tpublic StringBuffer print(int indent, StringBuffer output) {\n\t\tprintIndent(indent, output).append(\"/**\\n\"); //$NON-NLS-1$\n\t\tboolean nodePrinted = false;\n\t\tif (this.paramReferences != null) {\n\t\t\tfor (int i = 0, length = this.paramReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param \"); //$NON-NLS-1$\n\t\t\t\tthis.paramReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.paramTypeParameters != null) {\n\t\t\tfor (int i = 0, length = this.paramTypeParameters.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param <\"); //$NON-NLS-1$\n\t\t\t\tthis.paramTypeParameters[i].print(indent, output).append(\">\\n\"); //$NON-NLS-1$\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramTypeParameters[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.returnStatement != null) {\n\t\t\tprintIndent(indent, output).append(\" * @\"); //$NON-NLS-1$\n\t\t\tthis.returnStatement.print(indent, output).append('\\n');\n\t\t}\n\t\tif (this.exceptionReferences != null) {\n\t\t\tfor (int i = 0, length = this.exceptionReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @throws \"); //$NON-NLS-1$\n\t\t\t\tthis.exceptionReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.exceptionReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.seeReferences != null) {\n\t\t\tfor (int i = 0, length = this.seeReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @see \"); //$NON-NLS-1$\n\t\t\t\tthis.seeReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.seeReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\tprintIndent(indent, output).append(\" * \"); //$NON-NLS-1$\n\t\t\tthis.completionNode.print(indent, output).append('\\n');\n\t\t}\n\t\tprintIndent(indent, output).append(\" */\\n\"); //$NON-NLS-1$\n\t\treturn output;\n\t}\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(ClassScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(CompilationUnitScope scope) {\n\t\tinternalResolve(scope);\n\t}\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(MethodScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\t/*\n\t * Look for missing method @param tags\n\t */\n\tprivate char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {\n\t\t// Verify if there's some possible param tag\n\t\tAbstractMethodDeclaration md = methScope.referenceMethod();\n\t\tint paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;\n\t\tif (md == null) return null;\n\t\tint argumentsSize = md.arguments == null ? 0 : md.arguments.length;\n\t\tif (argumentsSize == 0) return null;\n\t\t// Store all method arguments if there's no @param in javadoc\n\t\tif (paramTagsSize == 0) {\n\t\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\t\tmissingParams[i] = md.arguments[i].name;\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\t\t// Look for missing arguments\n\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\tint size = 0;\n\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\tArgument arg = md.arguments[i];\n\t\t\tboolean found = false;\n\t\t\tint paramNameRefCount = 0;\n\t\t\tfor (int j = 0; j < paramTagsSize && !found; j++) {\n\t\t\t\tJavadocSingleNameReference param = this.paramReferences[j];\n\t\t\t\tif (arg.binding == param.binding) {\n\t\t\t\t\tif (param.binding == paramNameRefBinding) { // do not count first occurence of param name reference\n\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tmissingParams[size++] = arg.name;\n\t\t\t}\n\t\t}\n\t\tif (size > 0) {\n\t\t\tif (size != argumentsSize) {\n\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\t\treturn null;\n\t}\n\t/*\n\t * Look for missing type parameters @param tags\n\t */\n\tprivate char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {\n\t\tint paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;\n\t\t// Verify if there's any type parameter to tag\n\t\tTypeParameter[] parameters =  null;\n\t\tTypeVariableBinding[] typeVariables = null;\n\t\tswitch (scope.kind) {\n\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\tAbstractMethodDeclaration methodDeclaration = ((MethodScope)scope).referenceMethod();\n\t\t\t\tif (methodDeclaration == null) return null;\n\t\t\t\tparameters = methodDeclaration.typeParameters();\n\t\t\t\ttypeVariables = methodDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\tTypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;\n\t\t\t\tparameters = typeDeclaration.typeParameters;\n\t\t\t\ttypeVariables = typeDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (typeVariables == null || typeVariables.length == 0) return null;\n\t\t// Store all type parameters if there's no @param in javadoc\n\t\tif (parameters != null) {\n\t\t\tint typeParametersLength = parameters.length;\n\t\t\tif (paramTypeParamLength == 0) {\n\t\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\t\tmissingParams[i] = parameters[i].name;\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\t\t\t// Look for missing type parameter\n\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\tint size = 0;\n\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\tTypeParameter parameter = parameters[i];\n\t\t\t\tboolean found = false;\n\t\t\t\tint paramNameRefCount = 0;\n\t\t\t\tfor (int j = 0; j < paramTypeParamLength && !found; j++) {\n\t\t\t\t\tif (parameter.binding == this.paramTypeParameters[j].resolvedType) {\n\t\t\t\t\t\tif (parameter.binding == paramNameRefBinding) { // do not count first occurence of param nmae reference\n\t\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tmissingParams[size++] = parameter.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0) {\n\t\t\t\tif (size != typeParametersLength) {\n\t\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n"]], "pred": {"ppl": 1.5632693767547607, "ppl_lower": 1.8216066360473633, "ppl/lowercase_ppl": -1.3423154741368026, "ppl/zlib": 0.00022216776855386096, "Min_5.0% Prob": 5.302010246351654, "Min_10.0% Prob": 3.646017579471364, "Min_20.0% Prob": 2.1705672334076143, "Min_30.0% Prob": 1.483216531172979, "Min_40.0% Prob": 1.115631166028091, "Min_50.0% Prob": 0.8940106020436609, "Min_60.0% Prob": 0.745494719132569}}
{"hexsha": "b340f2fb457ab4721fc8027ede739eb8fda262c5", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class CertificateTypeServiceImpl implements CertificateTypeService {\n\n    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);\n\n    private final CertificateTypeRepository certificateTypeRepository;\n\n    private final CertificateTypeMapper certificateTypeMapper;\n\n    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {\n        this.certificateTypeRepository = certificateTypeRepository;\n        this.certificateTypeMapper = certificateTypeMapper;\n    }\n\n    /**\n     * Save a certificateType.\n     *\n     * @param certificateTypeDTO the entity to save.\n     * @return the persisted entity.\n     */\n    @Override\n    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {\n        log.debug(\"Request to save CertificateType : {}\", certificateTypeDTO);\n        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);\n        certificateType = certificateTypeRepository.save(certificateType);\n        return certificateTypeMapper.toDto(certificateType);\n    }\n\n    /**\n     * Get all the certificateTypes.\n     *\n     * @return the list of entities.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public List<CertificateTypeDTO> findAll() {\n        log.debug(\"Request to get all CertificateTypes\");\n        return certificateTypeRepository.findAll().stream()\n            .map(certificateTypeMapper::toDto)\n            .collect(Collectors.toCollection(LinkedList::new));\n    }\n\n    /**\n     * Get one certificateType by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public Optional<CertificateTypeDTO> findOne(Long id) {\n        log.debug(\"Request to get CertificateType : {}\", id);\n        return certificateTypeRepository.findById(id)\n            .map(certificateTypeMapper::toDto);\n    }\n\n    /**\n     * Delete the certificateType by id.\n     *\n     * @param id the id of the entity.\n     */\n    @Override\n    public void delete(Long id) {\n        log.debug(\"Request to delete CertificateType : {}\", id);\n        certificateTypeRepository.deleteById(id);\n    }\n}", "class_id": 0, "repo": "boutainaLemrabet/jhipster-composite-key-server-blueprint", "file": "test/samples/composite-key-blueprint/src/main/java/com/mycompany/myapp/service/impl/CertificateTypeServiceImpl.java", "last_update_at": "2021-09-15T07:41:05+00:00", "question_id": "b340f2fb457ab4721fc8027ede739eb8fda262c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class CertificateTypeServiceImpl implements CertificateTypeService {\n    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);\n    private final CertificateTypeRepository certificateTypeRepository;\n    private final CertificateTypeMapper certificateTypeMapper;\n    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {\n        this.certificateTypeRepository = certificateTypeRepository;\n        this.certificateTypeMapper = certificateTypeMapper;\n    }\n    /**\n     * Save a certificateType.\n     *\n     * @param certificateTypeDTO the entity to save.\n     * @return the persisted entity.\n     */\n    @Override\n    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {\n        log.debug(\"Request to save CertificateType : {}\", certificateTypeDTO);\n        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);\n        certificateType = certificateTypeRepository.save(certificateType);\n        return certificateTypeMapper.toDto(certificateType);\n    }\n    /**\n     * Get all the certificateTypes.\n     *\n     * @return the list of entities.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public List<CertificateTypeDTO> findAll() {\n        log.debug(\"Request to get all CertificateTypes\");\n        return certificateTypeRepository.findAll().stream()\n            .map(certificateTypeMapper::toDto)\n            .collect(Collectors.toCollection(LinkedList::new));\n    }\n    /**\n     * Get one certificateType by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public Optional<CertificateTypeDTO> findOne(Long id) {\n        log.debug(\"Request to get CertificateType : {}\", id);\n        return certificateTypeRepository.findById(id)\n            .map(certificateTypeMapper::toDto);\n    }\n    /**\n     * Delete the certificateType by id.\n     *\n     * @param id the id of the entity.\n     */\n    @Override\n    public void delete(Long id) {\n        log.debug(\"Request to delete CertificateType : {}\", id);\n        certificateTypeRepository.deleteById(id);\n    }\n"]], "pred": {"ppl": 1.0991003513336182, "ppl_lower": 1.2591897249221802, "ppl/lowercase_ppl": -2.4390263802246857, "ppl/zlib": 0.0001678365590557751, "Min_5.0% Prob": 1.8187115690831481, "Min_10.0% Prob": 0.9399335772955212, "Min_20.0% Prob": 0.4733103956517378, "Min_30.0% Prob": 0.3158811745287358, "Min_40.0% Prob": 0.23698605967277625, "Min_50.0% Prob": 0.18896196361308512, "Min_60.0% Prob": 0.15756830666443555}}
{"hexsha": "66221d0b3719371c37d84e20dc260cfa0cb7971a", "ext": "java", "lang": "Java", "content": "public class ClientServiceImplTest extends AbstractSpringTests {\n\n    @Autowired\n    private ClientService clientService;\n\n    public ClientServiceImplTest() {\n        super(true);\n    }\n\n    @Test\n    public void testCreate_notAdmin_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        expectNotAdmin(() -> {\n            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);\n        });\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testCreate_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testCreate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testCreate_shortName_exists_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testDelete_notAdmin_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        expectNotAdmin(() -> {\n            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        });\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testDelete_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testDelete_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testListAll_notAdmin_FAIL() {\n        expectNotAdmin(() -> {\n            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);\n        });\n    }\n\n    @Test\n    public void testListAll_OK() {\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-testListAll_OK.json\", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));\n    }\n\n    @Test\n    public void testUpdate_noChange_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_notAdmin_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        expectNotAdmin(() -> {\n            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        });\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_shortName_exists_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_shortName_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(\"bbb\") //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_shortName_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n}", "class_id": 0, "repo": "foilen/foilen-crm", "file": "src/test/java/com/foilen/crm/services/ClientServiceImplTest.java", "last_update_at": "2021-02-23T13:22:53+00:00", "question_id": "66221d0b3719371c37d84e20dc260cfa0cb7971a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClientServiceImplTest extends AbstractSpringTests {\n    @Autowired\n    private ClientService clientService;\n    public ClientServiceImplTest() {\n        super(true);\n    }\n    @Test\n    public void testCreate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testCreate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testCreate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testCreate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testDelete_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        expectNotAdmin(() -> {\n            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testDelete_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testDelete_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testListAll_notAdmin_FAIL() {\n        expectNotAdmin(() -> {\n            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);\n        });\n    }\n    @Test\n    public void testListAll_OK() {\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-testListAll_OK.json\", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));\n    }\n    @Test\n    public void testUpdate_noChange_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_shortName_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(\"bbb\") //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_shortName_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n"]], "pred": {"ppl": 1.7525951862335205, "ppl_lower": 1.9234023094177246, "ppl/lowercase_ppl": -1.1657429869865106, "ppl/zlib": 0.0006079064496130718, "Min_5.0% Prob": 6.373603446810853, "Min_10.0% Prob": 4.640850903941136, "Min_20.0% Prob": 2.7309856026196013, "Min_30.0% Prob": 1.863526254880175, "Min_40.0% Prob": 1.4009748765092098, "Min_50.0% Prob": 1.1226907354846065, "Min_60.0% Prob": 0.936229977596264}}
{"hexsha": "201d81bb57bfceee81740093f870c685ab999062", "ext": "java", "lang": "Java", "content": "class Solution1 {\n\n  private int[][] dx_dy = new int[][]{\n      {0, 1}, {0, -1}, {1, 0}, {-1, 0}\n  };\n\n  private void dfs(int[][] image, int i, int j) {\n    if (i < 0 || j < 0 || i >= image.length || j >= image[0].length\n        || image[i][j] != oldColor)\n      return;\n    image[i][j] = newColor;\n    for (int[] offset : dx_dy) {\n      dfs(image, i + offset[0], j + offset[1]);\n    }\n  }\n\n  private int oldColor = 0, newColor = 0;\n\n  public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    this.oldColor = image[sr][sc];\n    this.newColor = newColor;\n    if (this.oldColor == this.newColor) return image;\n    dfs(image, sr, sc);\n    return image;\n  }\n\n  private static void test(int[][] image, int sr, int sc, int newColor) {\n    Solution1 solution = new Solution1();\n    int[][] ans = solution.floodFill(image, sr, sc, newColor);\n    for (int[] ints : ans) {\n      for (int i : ints) {\n        System.out.print(i + \" \");\n      }\n      System.out.println();\n    }\n    System.out.println();\n  }\n\n  public static void main(String[] args) {\n    test(new int[][]{\n        {0, 0, 0},\n        {0, 1, 1}}, 1, 1, 1);\n    test(new int[][]{\n        {1, 1, 1},\n        {1, 1, 0},\n        {1, 0, 1}}, 1, 1, 2);\n\n  }\n}", "class_id": 0, "repo": "ooooo-youwillsee/leetcode", "file": "lcci_08_10/java_08_10/src/com/ooooo/Solution1.java", "last_update_at": "2021-12-19T02:24:33+00:00", "question_id": "201d81bb57bfceee81740093f870c685ab999062", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution1 {\n  private int[][] dx_dy = new int[][]{\n      {0, 1}, {0, -1}, {1, 0}, {-1, 0}\n  };\n  private void dfs(int[][] image, int i, int j) {\n    if (i < 0 || j < 0 || i >= image.length || j >= image[0].length\n        || image[i][j] != oldColor)\n      return;\n    image[i][j] = newColor;\n    for (int[] offset : dx_dy) {\n      dfs(image, i + offset[0], j + offset[1]);\n    }\n  }\n  private int oldColor = 0, newColor = 0;\n  public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    this.oldColor = image[sr][sc];\n    this.newColor = newColor;\n    if (this.oldColor == this.newColor) return image;\n    dfs(image, sr, sc);\n    return image;\n  }\n  private static void test(int[][] image, int sr, int sc, int newColor) {\n    Solution1 solution = new Solution1();\n    int[][] ans = solution.floodFill(image, sr, sc, newColor);\n    for (int[] ints : ans) {\n      for (int i : ints) {\n        System.out.print(i + \" \");\n      }\n      System.out.println();\n    }\n    System.out.println();\n  }\n  public static void main(String[] args) {\n    test(new int[][]{\n        {0, 0, 0},\n        {0, 1, 1}}, 1, 1, 1);\n    test(new int[][]{\n        {1, 1, 1},\n        {1, 1, 0},\n        {1, 0, 1}}, 1, 1, 2);\n  }\n"]], "pred": {"ppl": 1.3579390048980713, "ppl_lower": 1.510561227798462, "ppl/lowercase_ppl": -1.348118443204119, "ppl/zlib": 0.0006769206033984024, "Min_5.0% Prob": 3.762164145708084, "Min_10.0% Prob": 2.593731803553445, "Min_20.0% Prob": 1.482847392711104, "Min_30.0% Prob": 1.0117932449342038, "Min_40.0% Prob": 0.7628542803874125, "Min_50.0% Prob": 0.6112892894463956, "Min_60.0% Prob": 0.5097422313319716}}
{"hexsha": "5e28482a90909ff8a582c684e353d5dcc0a58b48", "ext": "java", "lang": "Java", "content": "@EqualsAndHashCode(of = { \"annotatedObject\", \"descriptor\", \"clientId\" })\n/* package */class AnnotatedModelInterceptor implements IModelInterceptor\n{\n\tprivate static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);\n\n\tprivate final AnnotatedModelInterceptorDescriptor descriptor;\n\tprivate final transient Object annotatedObject;\n\tprivate ClientId clientId;\n\n\t/**\n\t * @param annotatedObject\n\t */\n\tAnnotatedModelInterceptor(@NonNull final Object annotatedObject)\n\t{\n\t\tthis.annotatedObject = annotatedObject;\n\t\tthis.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass())\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"annotated[\" + annotatedObject.getClass().getName() + \"]\";\n\t}\n\n\t/**\n\t *\n\t * @return true if it has no initializers, no pointcuts, no nothing\n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\treturn descriptor.isEmpty();\n\t}\n\n\t@Override\n\tpublic void initialize(final IModelValidationEngine engine, final I_AD_Client client)\n\t{\n\t\tif (client != null)\n\t\t{\n\t\t\tthis.clientId = ClientId.ofRepoId(client.getAD_Client_ID());\n\t\t}\n\n\t\tbindPointcuts(engine);\n\n\t\t//\n\t\t// Execute initializers\n\t\tfor (final InterceptorInit init : descriptor.getInitializers())\n\t\t{\n\t\t\tObject[] params = new Object[] {};\n\t\t\tif (init.isMethodRequiresEngine())\n\t\t\t{\n\t\t\t\tparams = new Object[] { engine };\n\t\t\t}\n\n\t\t\tfinal Method method = init.getMethod();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Make sure the method is accessible\n\t\t\t\tif (!method.isAccessible())\n\t\t\t\t{\n\t\t\t\t\tmethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\t// Execute\n\t\t\t\tmethod.invoke(annotatedObject, params);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new AdempiereException(\"Cannot initialize \" + annotatedObject + \". Initializer \" + init + \" failed.\"\n\t\t\t\t\t\t+ \"\\n Method: \" + method\n\t\t\t\t\t\t+ \"\\n Params:\" + Arrays.toString(params)\n\t\t\t\t\t\t+ \"\\n Method Descriptor: \" + init, Throwables.getRootCause(e));\n\t\t\t}\n\n\t\t\tlogger.debug(\"Initializer {} executed successfully.\", init);\n\t\t}\n\t}\n\n\tprivate void bindPointcuts(@NonNull final IModelValidationEngine engine)\n\t{\n\t\tlogger.debug(\"Binding pointcuts for {}\", annotatedObject);\n\t\tfor (final PointcutKey key : descriptor.getPointcutKeys())\n\t\t{\n\t\t\tfinal Set<Pointcut> list = descriptor.getPointcuts(key);\n\t\t\tif (list.isEmpty())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlogger.debug(\"Binding pointcuts for {} on {}\", annotatedObject, key);\n\n\t\t\tswitch (key.getType())\n\t\t\t{\n\t\t\t\tcase ModelChange:\n\t\t\t\t\tengine.addModelChange(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DocValidate:\n\t\t\t\t\tengine.addDocValidate(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new AdempiereException(\"Unknown PointcutType \" + key.getType());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"Binding pointcuts for {} done.\", annotatedObject);\n\t}\n\n\t@Override\n\tpublic int getAD_Client_ID()\n\t{\n\t\treturn ClientId.toRepoId(clientId);\n\t}\n\n\t@Override\n\tpublic void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID)\n\t{\n\t\t// nothing\n\t}\n\n\t@Override\n\tpublic final void onModelChange(final Object model, final ModelChangeType changeType)\n\t{\n\t\texecute(PointcutType.ModelChange, model, changeType.toInt());\n\t}\n\n\t@Override\n\tpublic final void onDocValidate(final Object model, final DocTimingType timing)\n\t{\n\t\texecute(PointcutType.DocValidate, model, timing.toInt());\n\t}\n\n\tprivate void execute(final PointcutType type, final Object po, final int timing)\n\t{\n\t\tfinal String tableName = InterfaceWrapperHelper.getModelTableName(po);\n\t\tfinal PointcutKey key = PointcutKey.of(tableName, type);\n\t\tfinal ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);\n\t\tif (pointcuts.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (final Pointcut pointcut : pointcuts)\n\t\t{\n\t\t\texecute(pointcut, po, timing);\n\t\t}\n\t}\n\n\tprivate void execute(final Pointcut pointcut, final Object po, final int timing)\n\t{\n\t\t//\n\t\t// Check timings\n\t\tfinal Set<Integer> timings = pointcut.getTimings();\n\t\tif (!timings.contains(timing))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// Check if UserAction required (i.e. user manually changed this record from a window)\n\t\tif (pointcut.isOnlyIfUIAction())\n\t\t{\n\t\t\tfinal boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);\n\t\t\tif (!isUIAction)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Check if we shall skip when copying\n\t\tif (pointcut.isSkipIfCopying())\n\t\t{\n\t\t\tfinal boolean isCopying = InterfaceWrapperHelper.isCopy(po);\n\t\t\tif (isCopying)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Check changed columns (only if timing is before/after change).\n\t\t// #105 FRESH-442: only check for changed columns on \"change\". For \"new\" and \"delete\", execute the pointcut.\n\t\t// Else, does not make sense.\n\t\tif (isTimingChange(timing))\n\t\t{\n\t\t\tfinal Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();\n\t\t\tif (!columnsToCheckForChanges.isEmpty())\n\t\t\t{\n\t\t\t\t// none of our columns had changed; skip\n\t\t\t\tif (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Execute the method now\n\t\tif (!pointcut.isAfterCommit())\n\t\t{\n\t\t\texecuteNow(po, pointcut, timing);\n\t\t}\n\t\t//\n\t\t// ... or schedule it to be executed after commit\n\t\telse\n\t\t{\n\t\t\tlogger.trace(\"Scheduling to be executed after commit: {}\", pointcut);\n\t\t\tfinal String trxName = InterfaceWrapperHelper.getTrxName(po);\n\n\t\t\tServices.get(ITrxManager.class)\n\t\t\t\t\t.getTrxListenerManagerOrAutoCommit(trxName)\n\t\t\t\t\t.newEventListener(TrxEventTiming.AFTER_COMMIT)\n\t\t\t\t\t.additionalToStringInfo(() -> MoreObjects.toStringHelper(this)\n\t\t\t\t\t\t\t.add(\"pointcut\", pointcut)\n\t\t\t\t\t\t\t.add(\"po\", po)\n\t\t\t\t\t\t\t.add(\"timing\", timing)\n\t\t\t\t\t\t\t.toString())\n\t\t\t\t\t.invokeMethodJustOnce(true)\n\t\t\t\t\t.registerHandlingMethod(transaction -> {\n\n\t\t\t\t\t\texecuteNow(po, pointcut, timing);\n\t\t\t\t\t\tInterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);\n\t\t\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate final void executeNow(\n\t\t\t@NonNull final Object po,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing)\n\t{\n\t\tif (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut))\n\t\t{\n\t\t\tlogger.info(\"Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}\",\n\t\t\t\t\tAnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());\n\t\ttry\n\t\t{\n\t\t\texecuteNow0(model, pointcut, timing);\n\t\t}\n\t\tcatch (final Exception e)\n\t\t{\n\t\t\tfinal AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);\n\t\t\tthrow adempiereException;\n\t\t}\n\t}\n\n\tprivate static AdempiereException appendAndLogHowtoDisableMessage(\n\t\t\t@NonNull final Exception e,\n\t\t\t@NonNull final Pointcut pointcut)\n\t{\n\t\tfinal String parameterName = \"HowtoDisableModelInterceptor\";\n\t\tfinal AdempiereException ae = AdempiereException.wrapIfNeeded(e);\n\n\t\tif (!ae.hasParameter(parameterName))\n\t\t{\n\t\t\tfinal String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);\n\n\t\t\tlogger.error(howtoDisableMsg);\n\t\t\tae.setParameter(parameterName, howtoDisableMsg);\n\t\t}\n\t\treturn ae;\n\t}\n\n\tprivate void executeNow0(\n\t\t\t@NonNull final Object model,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing) throws IllegalAccessException, InvocationTargetException\n\t{\n\t\tfinal Method method = pointcut.getMethod();\n\n\t\t// Make sure the method is accessible\n\t\tif (!method.isAccessible())\n\t\t{\n\t\t\tmethod.setAccessible(true);\n\t\t}\n\n\t\tfinal Stopwatch stopwatch = Stopwatch.createStarted();\n\t\tif (pointcut.isMethodRequiresTiming())\n\t\t{\n\t\t\tfinal Object timingParam = pointcut.convertToMethodTimingParameterType(timing);\n\t\t\tmethod.invoke(annotatedObject, model, timingParam);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmethod.invoke(annotatedObject, model);\n\t\t}\n\n\t\tlogger.trace(\"Executed in {}: {} (timing={}) on {}\", stopwatch, pointcut, timing, model);\n\t}\n\n\t/**\n\t *\n\t * @param timing\n\t * @return true if timing is change (before, after)\n\t */\n\tprivate static final boolean isTimingChange(final int timing)\n\t{\n\t\treturn ModelValidator.TYPE_BEFORE_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;\n\t}\n}", "class_id": 0, "repo": "focadiz/metasfresh", "file": "backend/de.metas.adempiere.adempiere/base/src/main/java/org/adempiere/ad/modelvalidator/AnnotatedModelInterceptor.java", "last_update_at": "2021-02-17T12:00:41+00:00", "question_id": "5e28482a90909ff8a582c684e353d5dcc0a58b48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@EqualsAndHashCode(of = { \"annotatedObject\", \"descriptor\", \"clientId\" })\n/* package */class AnnotatedModelInterceptor implements IModelInterceptor\n{\n\tprivate static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);\n\tprivate final AnnotatedModelInterceptorDescriptor descriptor;\n\tprivate final transient Object annotatedObject;\n\tprivate ClientId clientId;\n\t/**\n\t * @param annotatedObject\n\t */\n\tAnnotatedModelInterceptor(@NonNull final Object annotatedObject)\n\t{\n\t\tthis.annotatedObject = annotatedObject;\n\t\tthis.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass())\n\t\t\t\t.build();\n\t}\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"annotated[\" + annotatedObject.getClass().getName() + \"]\";\n\t}\n\t/**\n\t *\n\t * @return true if it has no initializers, no pointcuts, no nothing\n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\treturn descriptor.isEmpty();\n\t}\n\t@Override\n\tpublic void initialize(final IModelValidationEngine engine, final I_AD_Client client)\n\t{\n\t\tif (client != null)\n\t\t{\n\t\t\tthis.clientId = ClientId.ofRepoId(client.getAD_Client_ID());\n\t\t}\n\t\tbindPointcuts(engine);\n\t\t//\n\t\t// Execute initializers\n\t\tfor (final InterceptorInit init : descriptor.getInitializers())\n\t\t{\n\t\t\tObject[] params = new Object[] {};\n\t\t\tif (init.isMethodRequiresEngine())\n\t\t\t{\n\t\t\t\tparams = new Object[] { engine };\n\t\t\t}\n\t\t\tfinal Method method = init.getMethod();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Make sure the method is accessible\n\t\t\t\tif (!method.isAccessible())\n\t\t\t\t{\n\t\t\t\t\tmethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\t// Execute\n\t\t\t\tmethod.invoke(annotatedObject, params);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new AdempiereException(\"Cannot initialize \" + annotatedObject + \". Initializer \" + init + \" failed.\"\n\t\t\t\t\t\t+ \"\\n Method: \" + method\n\t\t\t\t\t\t+ \"\\n Params:\" + Arrays.toString(params)\n\t\t\t\t\t\t+ \"\\n Method Descriptor: \" + init, Throwables.getRootCause(e));\n\t\t\t}\n\t\t\tlogger.debug(\"Initializer {} executed successfully.\", init);\n\t\t}\n\t}\n\tprivate void bindPointcuts(@NonNull final IModelValidationEngine engine)\n\t{\n\t\tlogger.debug(\"Binding pointcuts for {}\", annotatedObject);\n\t\tfor (final PointcutKey key : descriptor.getPointcutKeys())\n\t\t{\n\t\t\tfinal Set<Pointcut> list = descriptor.getPointcuts(key);\n\t\t\tif (list.isEmpty())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlogger.debug(\"Binding pointcuts for {} on {}\", annotatedObject, key);\n\t\t\tswitch (key.getType())\n\t\t\t{\n\t\t\t\tcase ModelChange:\n\t\t\t\t\tengine.addModelChange(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DocValidate:\n\t\t\t\t\tengine.addDocValidate(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new AdempiereException(\"Unknown PointcutType \" + key.getType());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"Binding pointcuts for {} done.\", annotatedObject);\n\t}\n\t@Override\n\tpublic int getAD_Client_ID()\n\t{\n\t\treturn ClientId.toRepoId(clientId);\n\t}\n\t@Override\n\tpublic void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID)\n\t{\n\t\t// nothing\n\t}\n\t@Override\n\tpublic final void onModelChange(final Object model, final ModelChangeType changeType)\n\t{\n\t\texecute(PointcutType.ModelChange, model, changeType.toInt());\n\t}\n\t@Override\n\tpublic final void onDocValidate(final Object model, final DocTimingType timing)\n\t{\n\t\texecute(PointcutType.DocValidate, model, timing.toInt());\n\t}\n\tprivate void execute(final PointcutType type, final Object po, final int timing)\n\t{\n\t\tfinal String tableName = InterfaceWrapperHelper.getModelTableName(po);\n\t\tfinal PointcutKey key = PointcutKey.of(tableName, type);\n\t\tfinal ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);\n\t\tif (pointcuts.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (final Pointcut pointcut : pointcuts)\n\t\t{\n\t\t\texecute(pointcut, po, timing);\n\t\t}\n\t}\n\tprivate void execute(final Pointcut pointcut, final Object po, final int timing)\n\t{\n\t\t//\n\t\t// Check timings\n\t\tfinal Set<Integer> timings = pointcut.getTimings();\n\t\tif (!timings.contains(timing))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t//\n\t\t// Check if UserAction required (i.e. user manually changed this record from a window)\n\t\tif (pointcut.isOnlyIfUIAction())\n\t\t{\n\t\t\tfinal boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);\n\t\t\tif (!isUIAction)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// Check if we shall skip when copying\n\t\tif (pointcut.isSkipIfCopying())\n\t\t{\n\t\t\tfinal boolean isCopying = InterfaceWrapperHelper.isCopy(po);\n\t\t\tif (isCopying)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// Check changed columns (only if timing is before/after change).\n\t\t// #105 FRESH-442: only check for changed columns on \"change\". For \"new\" and \"delete\", execute the pointcut.\n\t\t// Else, does not make sense.\n\t\tif (isTimingChange(timing))\n\t\t{\n\t\t\tfinal Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();\n\t\t\tif (!columnsToCheckForChanges.isEmpty())\n\t\t\t{\n\t\t\t\t// none of our columns had changed; skip\n\t\t\t\tif (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// Execute the method now\n\t\tif (!pointcut.isAfterCommit())\n\t\t{\n\t\t\texecuteNow(po, pointcut, timing);\n\t\t}\n\t\t//\n\t\t// ... or schedule it to be executed after commit\n\t\telse\n\t\t{\n\t\t\tlogger.trace(\"Scheduling to be executed after commit: {}\", pointcut);\n\t\t\tfinal String trxName = InterfaceWrapperHelper.getTrxName(po);\n\t\t\tServices.get(ITrxManager.class)\n\t\t\t\t\t.getTrxListenerManagerOrAutoCommit(trxName)\n\t\t\t\t\t.newEventListener(TrxEventTiming.AFTER_COMMIT)\n\t\t\t\t\t.additionalToStringInfo(() -> MoreObjects.toStringHelper(this)\n\t\t\t\t\t\t\t.add(\"pointcut\", pointcut)\n\t\t\t\t\t\t\t.add(\"po\", po)\n\t\t\t\t\t\t\t.add(\"timing\", timing)\n\t\t\t\t\t\t\t.toString())\n\t\t\t\t\t.invokeMethodJustOnce(true)\n\t\t\t\t\t.registerHandlingMethod(transaction -> {\n\t\t\t\t\t\texecuteNow(po, pointcut, timing);\n\t\t\t\t\t\tInterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);\n\t\t\t\t\t});\n\t\t}\n\t}\n\t@VisibleForTesting\n\tprivate final void executeNow(\n\t\t\t@NonNull final Object po,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing)\n\t{\n\t\tif (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut))\n\t\t{\n\t\t\tlogger.info(\"Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}\",\n\t\t\t\t\tAnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);\n\t\t\treturn;\n\t\t}\n\t\tfinal Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());\n\t\ttry\n\t\t{\n\t\t\texecuteNow0(model, pointcut, timing);\n\t\t}\n\t\tcatch (final Exception e)\n\t\t{\n\t\t\tfinal AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);\n\t\t\tthrow adempiereException;\n\t\t}\n\t}\n\tprivate static AdempiereException appendAndLogHowtoDisableMessage(\n\t\t\t@NonNull final Exception e,\n\t\t\t@NonNull final Pointcut pointcut)\n\t{\n\t\tfinal String parameterName = \"HowtoDisableModelInterceptor\";\n\t\tfinal AdempiereException ae = AdempiereException.wrapIfNeeded(e);\n\t\tif (!ae.hasParameter(parameterName))\n\t\t{\n\t\t\tfinal String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);\n\t\t\tlogger.error(howtoDisableMsg);\n\t\t\tae.setParameter(parameterName, howtoDisableMsg);\n\t\t}\n\t\treturn ae;\n\t}\n\tprivate void executeNow0(\n\t\t\t@NonNull final Object model,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing) throws IllegalAccessException, InvocationTargetException\n\t{\n\t\tfinal Method method = pointcut.getMethod();\n\t\t// Make sure the method is accessible\n\t\tif (!method.isAccessible())\n\t\t{\n\t\t\tmethod.setAccessible(true);\n\t\t}\n\t\tfinal Stopwatch stopwatch = Stopwatch.createStarted();\n\t\tif (pointcut.isMethodRequiresTiming())\n\t\t{\n\t\t\tfinal Object timingParam = pointcut.convertToMethodTimingParameterType(timing);\n\t\t\tmethod.invoke(annotatedObject, model, timingParam);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmethod.invoke(annotatedObject, model);\n\t\t}\n\t\tlogger.trace(\"Executed in {}: {} (timing={}) on {}\", stopwatch, pointcut, timing, model);\n\t}\n\t/**\n\t *\n\t * @param timing\n\t * @return true if timing is change (before, after)\n\t */\n\tprivate static final boolean isTimingChange(final int timing)\n\t{\n\t\treturn ModelValidator.TYPE_BEFORE_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;\n\t}\n"]], "pred": {"ppl": 1.7803131341934204, "ppl_lower": 2.135173797607422, "ppl/lowercase_ppl": -1.315121641308793, "ppl/zlib": 0.00022708238855055632, "Min_5.0% Prob": 6.028209433836095, "Min_10.0% Prob": 4.250711155872719, "Min_20.0% Prob": 2.678124305956504, "Min_30.0% Prob": 1.895952165078104, "Min_40.0% Prob": 1.437017853911465, "Min_50.0% Prob": 1.1537250146969658, "Min_60.0% Prob": 0.9623534193890683}}
{"hexsha": "7d552efcea6c5f5cdd42841cc34ad20e76f615e1", "ext": "java", "lang": "Java", "content": "public final class MatrixAppendCPInstruction extends AppendCPInstruction {\n\n\tprotected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type,\n\t\tString opcode, String istr) {\n\t\tsuper(op, in1, in2, out, type, opcode, istr);\n\t}\n\n\t@Override\n\tpublic void processInstruction(ExecutionContext ec) {\n\t\t// get inputs\n\t\tMatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());\n\t\tMatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());\n\n\t\tvalidateInput(matBlock1, matBlock2);\n\n\t\tMatrixBlock ret;\n\t\tif(matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)\n\t\t\tret = CLALibAppend.append(matBlock1, matBlock2);\n\t\telse\n\t\t\tret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);\n\n\t\tec.setMatrixOutput(output.getName(), ret);\n\t\tec.releaseMatrixInput(input1.getName(), input2.getName());\n\t}\n\n\tprivate void validateInput(MatrixBlock m1, MatrixBlock m2) {\n\t\tif(_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-cbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of rows: \" + m1.getNumRows() + \" vs \" + m2.getNumRows());\n\t\t}\n\t\telse if(_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-rbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of columns: \" + m1.getNumColumns() + \" vs \" + m2.getNumColumns());\n\t\t}\n\t}\n\n\t@Override\n\tpublic Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {\n\t\t// TODO: break append to cbind and rbind for full compilation chain\n\t\tString opcode = _type.toString().toLowerCase();\n\t\treturn Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));\n\t}\n}", "class_id": 0, "repo": "Shafaq-Siddiqi/systemml", "file": "src/main/java/org/apache/sysds/runtime/instructions/cp/MatrixAppendCPInstruction.java", "last_update_at": "2021-06-08T18:02:41+00:00", "question_id": "7d552efcea6c5f5cdd42841cc34ad20e76f615e1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class MatrixAppendCPInstruction extends AppendCPInstruction {\n\tprotected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type,\n\t\tString opcode, String istr) {\n\t\tsuper(op, in1, in2, out, type, opcode, istr);\n\t}\n\t@Override\n\tpublic void processInstruction(ExecutionContext ec) {\n\t\t// get inputs\n\t\tMatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());\n\t\tMatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());\n\t\tvalidateInput(matBlock1, matBlock2);\n\t\tMatrixBlock ret;\n\t\tif(matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)\n\t\t\tret = CLALibAppend.append(matBlock1, matBlock2);\n\t\telse\n\t\t\tret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);\n\t\tec.setMatrixOutput(output.getName(), ret);\n\t\tec.releaseMatrixInput(input1.getName(), input2.getName());\n\t}\n\tprivate void validateInput(MatrixBlock m1, MatrixBlock m2) {\n\t\tif(_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-cbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of rows: \" + m1.getNumRows() + \" vs \" + m2.getNumRows());\n\t\t}\n\t\telse if(_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-rbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of columns: \" + m1.getNumColumns() + \" vs \" + m2.getNumColumns());\n\t\t}\n\t}\n\t@Override\n\tpublic Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {\n\t\t// TODO: break append to cbind and rbind for full compilation chain\n\t\tString opcode = _type.toString().toLowerCase();\n\t\treturn Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));\n\t}\n"]], "pred": {"ppl": 1.6093536615371704, "ppl_lower": 2.0907387733459473, "ppl/lowercase_ppl": -1.5499514165187305, "ppl/zlib": 0.0006787912210147993, "Min_5.0% Prob": 5.846712306141853, "Min_10.0% Prob": 3.9044146109372377, "Min_20.0% Prob": 2.289418492349796, "Min_30.0% Prob": 1.5689244332994956, "Min_40.0% Prob": 1.1858447623744723, "Min_50.0% Prob": 0.9507307118474273, "Min_60.0% Prob": 0.7927662318688817}}
{"hexsha": "95b4f2f41928e6bf7ea2abf2c075fca294df06a9", "ext": "java", "lang": "Java", "content": "@Component\n@Description(\"Authorization policy assigned by given identity by assigned or default role.\")\npublic class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {\n\n\t@Autowired @Lazy private RoleConfiguration roleConfiguration;\n\t@Autowired @Lazy private IdmRoleCompositionService roleCompositionService;\n\t\n\t@Autowired\n\tpublic AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {\n\t\tsuper(repository);\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;\n\t}\n\t\n\t@Override\n\tpublic Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {\n\t\tUUID identityId = filter.getIdentityId();\n\t\tif (identityId == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//\n\t\t// assigned role subquery\n\t\tSubquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);\n\t\tRoot<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);\n\t\tsubquery.select(subRoot);\n\t\tsubquery.where(\n                builder.and(\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId),\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role)) // correlation\n                \t\t)\n        );\n\t\tPredicate predicate = builder.exists(subquery);\n\t\t//\n\t\t// or default role\n\t\tUUID defaultRoleId = roleConfiguration.getDefaultRoleId();\n\t\tif (defaultRoleId == null) {\n\t\t\t// default role is not defined\n\t\t\treturn predicate;\n\t\t}\n\t\t//\n\t\t// find all default role sub roles \n\t\tSet<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);\n\t\tdefaultRoles.addAll(\n\t\t\t\troleCompositionService\n\t\t\t\t\t.findAllSubRoles(defaultRoleId)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(IdmRoleCompositionDto::getSub)\n\t\t\t\t\t.collect(Collectors.toSet())\n\t\t);\n\t\treturn builder.or(\n\t\t\t\tpredicate,\n\t\t\t\troot.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles)\n\t\t);\n\t}\n}", "class_id": 0, "repo": "piougy/CzechIdMng", "file": "Realization/backend/core/core-impl/src/main/java/eu/bcvsolutions/idm/core/model/repository/filter/AuthorizationPolicyByIdentityFilterBuilder.java", "last_update_at": "2021-08-06T19:55:05+00:00", "question_id": "95b4f2f41928e6bf7ea2abf2c075fca294df06a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Description(\"Authorization policy assigned by given identity by assigned or default role.\")\npublic class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {\n\t@Autowired @Lazy private RoleConfiguration roleConfiguration;\n\t@Autowired @Lazy private IdmRoleCompositionService roleCompositionService;\n\t\n\t@Autowired\n\tpublic AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {\n\t\tsuper(repository);\n\t}\n\t@Override\n\tpublic String getName() {\n\t\treturn IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;\n\t}\n\t\n\t@Override\n\tpublic Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {\n\t\tUUID identityId = filter.getIdentityId();\n\t\tif (identityId == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//\n\t\t// assigned role subquery\n\t\tSubquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);\n\t\tRoot<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);\n\t\tsubquery.select(subRoot);\n\t\tsubquery.where(\n                builder.and(\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId),\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role)) // correlation\n                \t\t)\n        );\n\t\tPredicate predicate = builder.exists(subquery);\n\t\t//\n\t\t// or default role\n\t\tUUID defaultRoleId = roleConfiguration.getDefaultRoleId();\n\t\tif (defaultRoleId == null) {\n\t\t\t// default role is not defined\n\t\t\treturn predicate;\n\t\t}\n\t\t//\n\t\t// find all default role sub roles \n\t\tSet<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);\n\t\tdefaultRoles.addAll(\n\t\t\t\troleCompositionService\n\t\t\t\t\t.findAllSubRoles(defaultRoleId)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(IdmRoleCompositionDto::getSub)\n\t\t\t\t\t.collect(Collectors.toSet())\n\t\t);\n\t\treturn builder.or(\n\t\t\t\tpredicate,\n\t\t\t\troot.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles)\n\t\t);\n\t}\n"]], "pred": {"ppl": 1.6597628593444824, "ppl_lower": 2.384847640991211, "ppl/lowercase_ppl": -1.7153711795105562, "ppl/zlib": 0.0006819310045047255, "Min_5.0% Prob": 5.7192686423659325, "Min_10.0% Prob": 4.013709801893968, "Min_20.0% Prob": 2.3754379426250023, "Min_30.0% Prob": 1.6543942237565965, "Min_40.0% Prob": 1.2618807607849363, "Min_50.0% Prob": 1.0126562626129472, "Min_60.0% Prob": 0.844259023195993}}
{"hexsha": "d0aa6b0a1e5c6f19bbc40686624f1ab36563df62", "ext": "java", "lang": "Java", "content": "public class Dispatcher {\n  \n  /**\n   * DispatcherRunnable is the runnable class in which a group of dispatch\n   *   messages (sharing the same url) get dispatched to corresponding worker\n   *   service\n   */\n  private class DispatcherRunnable implements Runnable {\n    \n    private static final String kWorkerEntryPoint = \"/Worker\";\n\n    private String dispatchMessages;\n    private ArrayList<String> workersTopology;\n    \n    /**\n     * Constructor DispatcherRunnable\n     * @param url: worker service's url\n     * @param dispatchMessages: messages to be dispatched\n     * @return new DispatcherRunnable Object\n     */\n    public DispatcherRunnable (\n      String dispatchMessages) {\n\n      this.dispatchMessages = dispatchMessages;\n      \n      this.workersTopology = new ArrayList<String>();\n      \n      try {\n      \n        String propertiesWorkersTopology =\n          DispatcherProperties.i().getStringPropterty(\n            DispatcherProperties.kWorkersTopology);\n        \n        String[] topologyArr = propertiesWorkersTopology.split(\",\");\n        \n        for (String topologyEntry : topologyArr) {\n          \n          this.workersTopology.add(topologyEntry + kWorkerEntryPoint);\n        }\n      } catch (Exception e) {\n\n        throw new CodeException(\n          32,\n          1,\n          \"propterty [\"\n            + DispatcherProperties.kWorkersTopology\n            + \"] isn't defined in properties file [\"\n            + DispatcherProperties.i().getName()\n            + \"]\",\n          ExceptionClass.PROPERTIES);\n      }\n    }\n    \n    /**\n     * send the messages to be despatched in a POST http request to the\n     *   worker service\n     * NOTE: silent in case of failure, change as needed?\n     * */\n    @Override\n    public void run () {\n      \n      for (String workerTopologyPoint : this.workersTopology) {\n      \n        try {\n          \n          URLConnection urlConnection = RestSyncInl.restCall(\n            workerTopologyPoint,\n            RestCallType.POST,\n            this.dispatchMessages);\n          \n          if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {\n          \n            break;\n          }\n        } catch (Exception e) {\n          \n        }\n      }\n    }\n    \n    @Override\n    public String toString () {\n      \n      return\n        \"DispatcherRunnable:  dispatchMessages(\"\n        + this.dispatchMessages\n        + \")\";\n    }\n  }\n  \n  // url -> list of dispatch messages\n  private ArrayList<DispatchMessage> dispatchMessages;\n\n  /**\n   * Constructor Dispatcher\n   * @return new Dispatcher Object\n   */\n  public Dispatcher () {\n    \n    this.dispatchMessages = new ArrayList<DispatchMessage>();\n  }\n  \n  /**\n   * addDispatchMessage\n   * adds a new dispatch message to the dispatcher's buffer\n   * @param url: url of the worker service that handles this type of\n   *               dispatch message\n   * @param dispatchMessage: the message to be dispatched\n   * @throws Exception\n   */\n  public void addDispatchMessage (\n    DispatchMessage dispatchMessage) throws Exception {\n    \n    this.dispatchMessages.add(dispatchMessage);\n  }\n  \n  /**\n   * dispatchMessages\n   * dispatches all the dispatch messages in the dispatcher buffer to their\n   *   corresponding worker services then clears the dispatcher buffer\n   * @throws Exception\n   */\n  public void dispatchMessages () throws Exception {\n    \n    if (this.dispatchMessages.isEmpty() == true) {\n      \n      return;\n    }\n      \n    ThreadPool.i().executeInDispatcherPool(\n      new DispatcherRunnable(\n        new DispatchMessages(this.dispatchMessages).toJsonString() ) );\n    \n    this.dispatchMessages.clear();\n  }\n  \n  @Override\n  public String toString () {\n    \n    return this.dispatchMessages.toString();\n  }\n}", "class_id": 0, "repo": "vangav/vos_backend", "file": "src/com/vangav/backend/dispatcher/Dispatcher.java", "last_update_at": "2021-08-09T19:54:45+00:00", "question_id": "d0aa6b0a1e5c6f19bbc40686624f1ab36563df62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Dispatcher {\n  /**\n   * DispatcherRunnable is the runnable class in which a group of dispatch\n   *   messages (sharing the same url) get dispatched to corresponding worker\n   *   service\n   */\n  private class DispatcherRunnable implements Runnable {\n    private static final String kWorkerEntryPoint = \"/Worker\";\n    private String dispatchMessages;\n    private ArrayList<String> workersTopology;\n    /**\n     * Constructor DispatcherRunnable\n     * @param url: worker service's url\n     * @param dispatchMessages: messages to be dispatched\n     * @return new DispatcherRunnable Object\n     */\n    public DispatcherRunnable (\n      String dispatchMessages) {\n      this.dispatchMessages = dispatchMessages;\n      this.workersTopology = new ArrayList<String>();\n      try {\n        String propertiesWorkersTopology =\n          DispatcherProperties.i().getStringPropterty(\n            DispatcherProperties.kWorkersTopology);\n        String[] topologyArr = propertiesWorkersTopology.split(\",\");\n        for (String topologyEntry : topologyArr) {\n          this.workersTopology.add(topologyEntry + kWorkerEntryPoint);\n        }\n      } catch (Exception e) {\n        throw new CodeException(\n          32,\n          1,\n          \"propterty [\"\n            + DispatcherProperties.kWorkersTopology\n            + \"] isn't defined in properties file [\"\n            + DispatcherProperties.i().getName()\n            + \"]\",\n          ExceptionClass.PROPERTIES);\n      }\n    }\n    /**\n     * send the messages to be despatched in a POST http request to the\n     *   worker service\n     * NOTE: silent in case of failure, change as needed?\n     * */\n    @Override\n    public void run () {\n      for (String workerTopologyPoint : this.workersTopology) {\n        try {\n          URLConnection urlConnection = RestSyncInl.restCall(\n            workerTopologyPoint,\n            RestCallType.POST,\n            this.dispatchMessages);\n          if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {\n            break;\n          }\n        } catch (Exception e) {\n        }\n      }\n    }\n    @Override\n    public String toString () {\n      return\n        \"DispatcherRunnable:  dispatchMessages(\"\n        + this.dispatchMessages\n        + \")\";\n    }\n  }\n  // url -> list of dispatch messages\n  private ArrayList<DispatchMessage> dispatchMessages;\n  /**\n   * Constructor Dispatcher\n   * @return new Dispatcher Object\n   */\n  public Dispatcher () {\n    this.dispatchMessages = new ArrayList<DispatchMessage>();\n  }\n  /**\n   * addDispatchMessage\n   * adds a new dispatch message to the dispatcher's buffer\n   * @param url: url of the worker service that handles this type of\n   *               dispatch message\n   * @param dispatchMessage: the message to be dispatched\n   * @throws Exception\n   */\n  public void addDispatchMessage (\n    DispatchMessage dispatchMessage) throws Exception {\n    this.dispatchMessages.add(dispatchMessage);\n  }\n  /**\n   * dispatchMessages\n   * dispatches all the dispatch messages in the dispatcher buffer to their\n   *   corresponding worker services then clears the dispatcher buffer\n   * @throws Exception\n   */\n  public void dispatchMessages () throws Exception {\n    if (this.dispatchMessages.isEmpty() == true) {\n      return;\n    }\n    ThreadPool.i().executeInDispatcherPool(\n      new DispatcherRunnable(\n        new DispatchMessages(this.dispatchMessages).toJsonString() ) );\n    this.dispatchMessages.clear();\n  }\n  @Override\n  public String toString () {\n    return this.dispatchMessages.toString();\n  }\n"]], "pred": {"ppl": 2.434504747390747, "ppl_lower": 2.6788394451141357, "ppl/lowercase_ppl": -1.1074920217551543, "ppl/zlib": 0.0007937050371866741, "Min_5.0% Prob": 7.451255440711975, "Min_10.0% Prob": 5.606936911946719, "Min_20.0% Prob": 3.8216106634873612, "Min_30.0% Prob": 2.824954539333304, "Min_40.0% Prob": 2.1885378246888134, "Min_50.0% Prob": 1.7693748824741142, "Min_60.0% Prob": 1.4814965129280702}}
{"hexsha": "1168d4b7c2a618ee1fa85e5a4e7400a4dc63922f", "ext": "java", "lang": "Java", "content": "public class DialogShopCarAdapter extends BaseAdapter {\n    private static final int FIRST = 0;\n    private static final int SECOND = 1;\n    private static final int COUNT = 2;\n    private FunctionListActivity activity;\n    private List<Quotation> data;\n    private LayoutInflater mInflater;\n\n    private DelOnClickListener delOnClickListener;\n    private AddDelOnClickListener addDelOnClickListener;\n    private ShopCarDialog dialog;\n\n    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {\n        this.activity = activity;\n        mInflater = LayoutInflater.from(activity);\n        this.dialog = dialog;\n        this.delOnClickListener = new DelOnClickListener();\n        this.addDelOnClickListener = new AddDelOnClickListener();\n    }\n\n    public void setData(List<Quotation> data) {\n        this.data = data;\n    }\n\n    public List<Quotation> getData() {\n        return data;\n    }\n\n    @Override\n    public int getCount() {\n        return data == null ? 0 : data.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (data.get(position).type == 1) {\n            return FIRST;\n        } else {\n            return SECOND;\n        }\n    }\n\n    @Override\n    public int getViewTypeCount() {\n        return COUNT;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        int type = getItemViewType(position);\n        if (convertView == null) {\n            holder = new ViewHolder();\n            switch (type) {\n                case FIRST:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);\n                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);\n                    holder.clearAll = convertView.findViewById(R.id.tv_clear);\n                    holder.reset = convertView.findViewById(R.id.tv_reset);\n                    holder.clearAll.setOnClickListener(clickClear);\n                    holder.reset.setOnClickListener(clickReset);\n                    break;\n\n                case SECOND:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);\n                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);\n                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);\n                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);\n                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);\n                    break;\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        Quotation quotation = data.get(position);\n        switch (type) {\n            case FIRST:\n                String sectionTitle = String.format(\"%s . %d\", quotation.title, quotation.getExtra().size());\n                holder.tv_head.setText(sectionTitle);\n                holder.clearAll.setTag(quotation);\n                holder.reset.setTag(quotation);\n                break;\n\n            case SECOND:\n                holder.tv_name.setText(quotation.title);\n                if (quotation.title.equals(\"\u9875\u9762\u6570\u91cf\")) {\n                    holder.ivDelCar.setVisibility(View.VISIBLE);\n                    holder.tvNum.setVisibility(View.VISIBLE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);\n                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);\n                    holder.tvNum.setText(activity.getNum() + \"\");\n                    //\u52a0\u6570\u91cf\n                    holder.ivAddCar.setTag(R.id.action_type, 0);\n                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);\n                    //\u51cf\u6570\u91cf\n                    holder.ivDelCar.setTag(R.id.action_type, 1);\n                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);\n                } else {\n                    holder.ivDelCar.setVisibility(View.GONE);\n                    holder.tvNum.setVisibility(View.GONE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);\n                    holder.ivAddCar.setTag(quotation);\n                    holder.ivAddCar.setOnClickListener(delOnClickListener);\n                }\n\n                break;\n        }\n\n        return convertView;\n    }\n\n    private class ViewHolder {\n        TextView tv_head;\n\n        View reset;\n        View clearAll;\n\n        TextView tv_name;\n        ImageView ivAddCar;\n        ImageView ivDelCar;\n        TextView tvNum;\n    }\n\n    private View.OnClickListener clickClear = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.clearPickedFunction(tag);\n\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private View.OnClickListener clickReset = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.resetPickedFunction(tag);\n\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private class DelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            Quotation quotation = (Quotation) v.getTag();\n            if (quotation.isRadioItem()) {\n                return;\n            }\n\n            int pos = data.indexOf(quotation);\n            if (pos != -1) {\n                data.remove(quotation);\n                Quotation platform = null;\n                for (int i = pos - 1; i >= 0; --i) {\n                    Quotation quotation1 = data.get(i);\n                    if (quotation1.isPlatform()) {\n                        platform = quotation1;\n                        break;\n                    }\n                }\n\n                if (platform != null) {\n                    platform.getExtra().remove(quotation);\n                }\n\n                dialog.updateNum();\n                notifyDataSetChanged();\n            }\n        }\n    }\n\n    private class AddDelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            int type = (int) v.getTag(R.id.action_type);\n            switch (type) {\n                case 0: {\n                    int num = activity.getNum();\n                    num++;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n\n                case 1: {\n                    int num = activity.getNum();\n                    if (num < 1) {\n                        return;\n                    }\n                    num--;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n            }\n        }\n    }\n\n\n}", "class_id": 0, "repo": "JingMeng/Mart-Android", "file": "app/src/main/java/net/coding/mart/developers/adapter/DialogShopCarAdapter.java", "last_update_at": "2021-05-19T05:38:56+00:00", "question_id": "1168d4b7c2a618ee1fa85e5a4e7400a4dc63922f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DialogShopCarAdapter extends BaseAdapter {\n    private static final int FIRST = 0;\n    private static final int SECOND = 1;\n    private static final int COUNT = 2;\n    private FunctionListActivity activity;\n    private List<Quotation> data;\n    private LayoutInflater mInflater;\n    private DelOnClickListener delOnClickListener;\n    private AddDelOnClickListener addDelOnClickListener;\n    private ShopCarDialog dialog;\n    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {\n        this.activity = activity;\n        mInflater = LayoutInflater.from(activity);\n        this.dialog = dialog;\n        this.delOnClickListener = new DelOnClickListener();\n        this.addDelOnClickListener = new AddDelOnClickListener();\n    }\n    public void setData(List<Quotation> data) {\n        this.data = data;\n    }\n    public List<Quotation> getData() {\n        return data;\n    }\n    @Override\n    public int getCount() {\n        return data == null ? 0 : data.size();\n    }\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n    @Override\n    public int getItemViewType(int position) {\n        if (data.get(position).type == 1) {\n            return FIRST;\n        } else {\n            return SECOND;\n        }\n    }\n    @Override\n    public int getViewTypeCount() {\n        return COUNT;\n    }\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        int type = getItemViewType(position);\n        if (convertView == null) {\n            holder = new ViewHolder();\n            switch (type) {\n                case FIRST:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);\n                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);\n                    holder.clearAll = convertView.findViewById(R.id.tv_clear);\n                    holder.reset = convertView.findViewById(R.id.tv_reset);\n                    holder.clearAll.setOnClickListener(clickClear);\n                    holder.reset.setOnClickListener(clickReset);\n                    break;\n                case SECOND:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);\n                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);\n                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);\n                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);\n                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);\n                    break;\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        Quotation quotation = data.get(position);\n        switch (type) {\n            case FIRST:\n                String sectionTitle = String.format(\"%s . %d\", quotation.title, quotation.getExtra().size());\n                holder.tv_head.setText(sectionTitle);\n                holder.clearAll.setTag(quotation);\n                holder.reset.setTag(quotation);\n                break;\n            case SECOND:\n                holder.tv_name.setText(quotation.title);\n                if (quotation.title.equals(\"\u9875\u9762\u6570\u91cf\")) {\n                    holder.ivDelCar.setVisibility(View.VISIBLE);\n                    holder.tvNum.setVisibility(View.VISIBLE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);\n                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);\n                    holder.tvNum.setText(activity.getNum() + \"\");\n                    //\u52a0\u6570\u91cf\n                    holder.ivAddCar.setTag(R.id.action_type, 0);\n                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);\n                    //\u51cf\u6570\u91cf\n                    holder.ivDelCar.setTag(R.id.action_type, 1);\n                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);\n                } else {\n                    holder.ivDelCar.setVisibility(View.GONE);\n                    holder.tvNum.setVisibility(View.GONE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);\n                    holder.ivAddCar.setTag(quotation);\n                    holder.ivAddCar.setOnClickListener(delOnClickListener);\n                }\n                break;\n        }\n        return convertView;\n    }\n    private class ViewHolder {\n        TextView tv_head;\n        View reset;\n        View clearAll;\n        TextView tv_name;\n        ImageView ivAddCar;\n        ImageView ivDelCar;\n        TextView tvNum;\n    }\n    private View.OnClickListener clickClear = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.clearPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n    private View.OnClickListener clickReset = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.resetPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n    private class DelOnClickListener implements View.OnClickListener {\n        @Override\n        public void onClick(View v) {\n            Quotation quotation = (Quotation) v.getTag();\n            if (quotation.isRadioItem()) {\n                return;\n            }\n            int pos = data.indexOf(quotation);\n            if (pos != -1) {\n                data.remove(quotation);\n                Quotation platform = null;\n                for (int i = pos - 1; i >= 0; --i) {\n                    Quotation quotation1 = data.get(i);\n                    if (quotation1.isPlatform()) {\n                        platform = quotation1;\n                        break;\n                    }\n                }\n                if (platform != null) {\n                    platform.getExtra().remove(quotation);\n                }\n                dialog.updateNum();\n                notifyDataSetChanged();\n            }\n        }\n    }\n    private class AddDelOnClickListener implements View.OnClickListener {\n        @Override\n        public void onClick(View v) {\n            int type = (int) v.getTag(R.id.action_type);\n            switch (type) {\n                case 0: {\n                    int num = activity.getNum();\n                    num++;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n                case 1: {\n                    int num = activity.getNum();\n                    if (num < 1) {\n                        return;\n                    }\n                    num--;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.5752264261245728, "ppl_lower": 1.6966640949249268, "ppl/lowercase_ppl": -1.163435653585859, "ppl/zlib": 0.0002977713136064992, "Min_5.0% Prob": 5.936468475005206, "Min_10.0% Prob": 3.887254560694975, "Min_20.0% Prob": 2.1986137156685195, "Min_30.0% Prob": 1.504069383457011, "Min_40.0% Prob": 1.1334527442026838, "Min_50.0% Prob": 0.9089621029750475, "Min_60.0% Prob": 0.7581430445468892}}
{"hexsha": "20ce929ce28429536893d7323990cd9eaf4116b3", "ext": "java", "lang": "Java", "content": "public class MainActivity extends AppCompatActivity\n        implements NavigationView.OnNavigationItemSelectedListener {\n\n    private static final String TAG = MainActivity.class.getSimpleName();\n\n    private static final String KEY_NAV_POS = \"key_nav_pos\";\n\n    private Fragment m_actualFragment;\n    private NavigationView m_navigationView;\n\n    private int m_navPos;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n\n        Log.d(TAG, \"TAG: \" + TAG);\n\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(\n                this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawer.setDrawerListener(toggle);\n        toggle.syncState();\n\n        m_navigationView = (NavigationView) findViewById(R.id.nav_view);\n        m_navigationView.setNavigationItemSelectedListener(this);\n        // Select first menu item of drawer\n        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);\n        m_navPos = R.id.nav_example_1;\n\n        /*\n        FlipIconChecker flipIconChecker = (FlipIconChecker) findViewById(R.id.flipChecker);\n        View view = getLayoutInflater().inflate(R.layout.custom_front_color, flipIconChecker, false);\n        flipIconChecker.setFrontView(view);\n        */\n\n    }\n\n    @Override\n    public void onBackPressed() {\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main_activity, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n\n        return super.onOptionsItemSelected(item);\n    }\n\n    @SuppressWarnings(\"StatementWithEmptyBody\")\n    @Override\n    public boolean onNavigationItemSelected(MenuItem item) {\n        // Handle navigation view item clicks here.\n        int id = item.getItemId();\n\n        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();\n        if (id == R.id.nav_example_1) {\n            if (!(m_actualFragment instanceof FragmentColors)) {\n                m_navPos = R.id.nav_example_1;\n                FragmentColors fragmentColors = FragmentColors.newInstance();\n                m_actualFragment = fragmentColors;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentColors, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n        else if (id == R.id.nav_example_2) {\n            if (!(m_actualFragment instanceof FragmentCities)) {\n                m_navPos = R.id.nav_example_2;\n                FragmentCities fragmentCities = FragmentCities.newInstance();\n                m_actualFragment = fragmentCities;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentCities, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n\n    @Override\n        protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_NAV_POS, m_navPos);\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        if (savedInstanceState != null) {\n            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);\n            // Select first menu item of drawer\n            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);\n        }\n    }\n}", "class_id": 0, "repo": "TmCrafz/FlipIconChecker", "file": "example/src/main/java/org/tmcrafz/flipiconcheckerexample/MainActivity.java", "last_update_at": "2021-03-16T13:55:31+00:00", "question_id": "20ce929ce28429536893d7323990cd9eaf4116b3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainActivity extends AppCompatActivity\n        implements NavigationView.OnNavigationItemSelectedListener {\n    private static final String TAG = MainActivity.class.getSimpleName();\n    private static final String KEY_NAV_POS = \"key_nav_pos\";\n    private Fragment m_actualFragment;\n    private NavigationView m_navigationView;\n    private int m_navPos;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        Log.d(TAG, \"TAG: \" + TAG);\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(\n                this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawer.setDrawerListener(toggle);\n        toggle.syncState();\n        m_navigationView = (NavigationView) findViewById(R.id.nav_view);\n        m_navigationView.setNavigationItemSelectedListener(this);\n        // Select first menu item of drawer\n        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);\n        m_navPos = R.id.nav_example_1;\n        /*\n        FlipIconChecker flipIconChecker = (FlipIconChecker) findViewById(R.id.flipChecker);\n        View view = getLayoutInflater().inflate(R.layout.custom_front_color, flipIconChecker, false);\n        flipIconChecker.setFrontView(view);\n        */\n    }\n    @Override\n    public void onBackPressed() {\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main_activity, menu);\n        return true;\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    @SuppressWarnings(\"StatementWithEmptyBody\")\n    @Override\n    public boolean onNavigationItemSelected(MenuItem item) {\n        // Handle navigation view item clicks here.\n        int id = item.getItemId();\n        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();\n        if (id == R.id.nav_example_1) {\n            if (!(m_actualFragment instanceof FragmentColors)) {\n                m_navPos = R.id.nav_example_1;\n                FragmentColors fragmentColors = FragmentColors.newInstance();\n                m_actualFragment = fragmentColors;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentColors, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n        else if (id == R.id.nav_example_2) {\n            if (!(m_actualFragment instanceof FragmentCities)) {\n                m_navPos = R.id.nav_example_2;\n                FragmentCities fragmentCities = FragmentCities.newInstance();\n                m_actualFragment = fragmentCities;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentCities, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n    @Override\n        protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_NAV_POS, m_navPos);\n    }\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        if (savedInstanceState != null) {\n            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);\n            // Select first menu item of drawer\n            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);\n        }\n    }\n"]], "pred": {"ppl": 1.3657541275024414, "ppl_lower": 1.5866302251815796, "ppl/lowercase_ppl": -1.4809188807667986, "ppl/zlib": 0.0002361414776059949, "Min_5.0% Prob": 4.688605792382184, "Min_10.0% Prob": 2.870615993644677, "Min_20.0% Prob": 1.5430957708215596, "Min_30.0% Prob": 1.0388663056963945, "Min_40.0% Prob": 0.7789761693026724, "Min_50.0% Prob": 0.6238390417897586, "Min_60.0% Prob": 0.5201379470479219}}
{"hexsha": "9911321d53109bf16da1df0c35f7787910b99c99", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\n@ComponentScan({\"com.song7749.incident.drs\"})\r\npublic class LogRepositoryTest{\r\n\r\n\tLogger logger = LoggerFactory.getLogger(getClass());\r\n\r\n\t@Autowired\r\n\tLogRepository logRepository;\r\n\r\n\t@Test\r\n\tpublic void testSaveLogLogin() {\r\n\t\t// give\r\n\t\tLogLogin ll = new LogLogin();\r\n\t\tll.setIp(\"111.111.111.111\");\r\n\t\tll.setLoginId(\"song7749\");\r\n\t\tll.setCipher(\"12314142341231\");\r\n\r\n\t\t// when\r\n\t\tlogRepository.saveAndFlush(ll);\r\n\t\t// then\r\n\t\tassertThat(ll.getId(), notNullValue());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testSaveLogQuery() {\r\n\t\t//give\r\n\t\tLogQuery lq = new LogQuery();\r\n\t\tlq.setIp(\"111.111.111.111\");\r\n\t\tlq.setDatabaseId(1L);\r\n\t\tlq.setAccount(\"song7749\");\r\n\t\tlq.setHost(\"11.11.11.11\");\r\n\t\tlq.setHostAlias(\"\ud14c\uc2a4\ud2b8 \uc11c\ubc84\");\r\n\t\tlq.setLoginId(\"song7749\");\r\n\t\tlq.setQuery(\"select * from dual\");\r\n\t\tlq.setSchemaName(\"song7749\");\r\n\t\t//when\r\n\t\tlogRepository.saveAndFlush(lq);\r\n\t\t//then\r\n\t\tassertThat(lq.getId(), notNullValue());\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "MS-Song/Spring4BootWithGradel", "file": "incidentAlert/src/test/java/com/song7749/incident/drs/repository/LogRepositoryTest.java", "last_update_at": "2021-09-16T04:20:54+00:00", "question_id": "9911321d53109bf16da1df0c35f7787910b99c99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\n@ComponentScan({\"com.song7749.incident.drs\"})\r\npublic class LogRepositoryTest{\r\n\r\n\tLogger logger = LoggerFactory.getLogger(getClass());\r\n\r\n\t@Autowired\r\n\tLogRepository logRepository;\r\n\r\n\t@Test\r\n\tpublic void testSaveLogLogin() {\r\n\t\t// give\r\n\t\tLogLogin ll = new LogLogin();\r\n\t\tll.setIp(\"111.111.111.111\");\r\n\t\tll.setLoginId(\"song7749\");\r\n\t\tll.setCipher(\"12314142341231\");\r\n\r\n\t\t// when\r\n\t\tlogRepository.saveAndFlush(ll);\r\n\t\t// then\r\n\t\tassertThat(ll.getId(), notNullValue());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testSaveLogQuery() {\r\n\t\t//give\r\n\t\tLogQuery lq = new LogQuery();\r\n\t\tlq.setIp(\"111.111.111.111\");\r\n\t\tlq.setDatabaseId(1L);\r\n\t\tlq.setAccount(\"song7749\");\r\n\t\tlq.setHost(\"11.11.11.11\");\r\n\t\tlq.setHostAlias(\"\ud14c\uc2a4\ud2b8 \uc11c\ubc84\");\r\n\t\tlq.setLoginId(\"song7749\");\r\n\t\tlq.setQuery(\"select * from dual\");\r\n\t\tlq.setSchemaName(\"song7749\");\r\n\t\t//when\r\n\t\tlogRepository.saveAndFlush(lq);\r\n\t\t//then\r\n\t\tassertThat(lq.getId(), notNullValue());\r\n\t}\r\n\r\n"]], "pred": {"ppl": 1.7747132778167725, "ppl_lower": 2.196995258331299, "ppl/lowercase_ppl": -1.3721012778833188, "ppl/zlib": 0.00125248662937787, "Min_5.0% Prob": 5.902696891264482, "Min_10.0% Prob": 4.196781706809998, "Min_20.0% Prob": 2.6481786959701115, "Min_30.0% Prob": 1.871057124822228, "Min_40.0% Prob": 1.4252680250960919, "Min_50.0% Prob": 1.1463736886862252, "Min_60.0% Prob": 0.9572759466814912}}
{"hexsha": "6c338a1f6834fb9094f88ce1c7d13fe385e54000", "ext": "java", "lang": "Java", "content": "@RunWith(value = YBTestRunnerNonTsanOnly.class)\npublic class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {\n  private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);\n\n  @Test\n  public void simplest() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n    }\n  }\n\n  @Test\n  public void duplicates() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 2)\");\n\n      // Note:\n      // PG error in this case mentions \"nopk_pkey\", not just \"nopk\"\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"duplicate key value violates unique constraint \\\"nopk\\\"\");\n\n      stmt.executeUpdate(\"DELETE FROM nopk WHERE v = 2\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n\n  @Test\n  public void nulls() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (NULL)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1)\");\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"column \\\"id\\\" contains null values\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row((Object) null)));\n    }\n  }\n\n  @Test\n  public void columnTypes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int[10][20], v2 text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, new Integer[] { 1, 2, 3 }, \"qwe\"),\n          new Row(2, new Integer[] { 3, 4 }, \"zxcv\")));\n    }\n  }\n\n  @Test\n  public void columnTypesUnsupported() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE typeid AS (i int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (id typeid, v int)\");\n\n      String msg = \"PRIMARY KEY containing column of type 'user_defined_type' not yet supported\";\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)\", msg);\n    }\n  }\n\n  @Test\n  public void missing() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n\n      String msg = \"column \\\"missme\\\" named in key does not exist\";\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)\", msg);\n    }\n  }\n\n  @Test\n  public void complexPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '111', '1', true)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '2', false)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)\");\n\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '3', true)\");\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, '222', '2', false)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY v1, v2, v3, v4\", Arrays.asList(\n          new Row(1, \"111\", \"1\", true),\n          new Row(2, \"222\", \"2\", false),\n          new Row(2, \"222\", \"3\", true)));\n    }\n  }\n\n  @Test\n  public void pkInclude() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int, v2 int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 11, 111)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 22, 222)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id) INCLUDE (v1, v2)\");\n\n      // Scan is supposed to be index-only scan, but it's index scan for us.\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 2\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(22));\n      }\n\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3, 11, 111)\");\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (3, 99, 999)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 11, 111),\n          new Row(2, 22, 222),\n          new Row(3, 11, 111)));\n\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 3\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(11));\n      }\n    }\n  }\n\n  @Test\n  public void pkUsingIndex() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)\");\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY\"\n          + \" USING INDEX nopk_idx\",\n          \"ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported\");\n    }\n  }\n\n  @Test\n  public void sequences() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \"id serial,\"\n          + \"v1 int GENERATED ALWAYS AS IDENTITY,\"\n          + \"v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10),\"\n          + \"stuff text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r1')\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\")));\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r2')\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\"),\n          new Row(2, 2, 11, \"r2\")));\n    }\n  }\n\n  @Test\n  public void typedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE nopk_type AS (id int, v int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk OF nopk_type\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 10)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 20)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 10),\n          new Row(2, 20)));\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk DROP COLUMN v\",\n          \"cannot drop column from typed table\");\n    }\n  }\n\n  @Ignore // TODO(alex): Enable after INHERITS is supported in #1129\n  public void inheritedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_parent (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (3, 30)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (4, 40)\");\n\n      alterAddPrimaryKey(stmt, \"nopk_parent\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_child\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk_parent ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_child ORDER BY id\", Arrays.asList(\n          new Row(3, 30),\n          new Row(4, 40)));\n    }\n  }\n\n  /** Adding PK to a partitioned table is not yet implemented. */\n  @Test\n  public void partitionedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part1 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (1, 2, 3)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (10, 20)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (30, 40)\");\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_whole ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n    }\n  }\n\n  @Test\n  public void tablesInColocatedDb() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE DATABASE clc WITH colocated = true\");\n    }\n\n    try (Connection conn2 = getConnectionBuilder().withDatabase(\"clc\").connect();\n        Statement stmt = conn2.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk_c (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (4)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk_nc (id int) WITH (colocated = false)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (6)\");\n\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n\n      // This doesn't really accomplish much though, since colocated property is invisible to SQL\n      // - we can't check whether a re-created table keeps/gains/loses it.\n      // See #6159\n      alterAddPrimaryKey(stmt, \"nopk_c\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_nc\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_c ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk_nc ORDER BY id\", Arrays.asList(\n          new Row(5),\n          new Row(6)));\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n    }\n  }\n\n  @Test\n  public void tablesInTablegroup() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLEGROUP tgroup1\");\n\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (4)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk2 (id int, id2 int unique)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (5, 5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (6, 6)\");\n\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk2\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk2 ORDER BY id\", Arrays.asList(\n          new Row(5, 5),\n          new Row(6, 6)));\n\n      assertRowList(stmt,\n        \"SELECT s.relname, pg_tablegroup.grpname \" +\n        \"FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) \" +\n        \"s, pg_tablegroup WHERE opts LIKE \" +\n        \"CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') \" +\n        \"ORDER BY s\", Arrays.asList(\n          new Row(\"nopk\", \"tgroup1\"),\n          new Row(\"nopk2\", \"tgroup1\"),\n          new Row(\"nopk2_id2_key\", \"tgroup1\"),\n          new Row(\"nopk2_pkey\", \"tgroup1\"),\n          new Row(\"nopk_pkey\", \"tgroup1\"),\n          new Row(\"normal_table\", \"tgroup1\"),\n          new Row(\"normal_table_pkey\", \"tgroup1\")));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n    }\n  }\n\n  @Test\n  public void defaults() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int DEFAULT 10, \"\n          + \" drop_me int DEFAULT 10, \"\n          + \" v int DEFAULT 10\"\n          + \")\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n\n      stmt.executeUpdate(\"INSERT INTO nopk (id) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10)));\n\n      stmt.executeUpdate(\"INSERT INTO nopk (v) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10),\n          new Row(10, 2)));\n    }\n  }\n\n  @Test\n  public void notNullAndCheck() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int CHECK (id > 0),\"\n          + \" drop_me int,\"\n          + \" v1 int CHECK (v1 > 0),\"\n          + \" v2 int NOT NULL\"\n          + \")\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (0, 2, 2)\",\n          \"violates check constraint \\\"nopk_id_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 0, 2)\",\n          \"violates check constraint \\\"nopk_v1_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, NULL)\",\n          \"violates not-null constraint\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n    }\n  }\n\n  /** Altered table references a FK table. */\n  @Test\n  public void foreignKeys() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (2, 2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" fk1 int REFERENCES fk_ref_table (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES fk_ref_table (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 2)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n\n      runInvalidQuery(stmt, \"DELETE FROM fk_ref_table WHERE id = 1\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\" on table \\\"nopk\\\"\");\n    }\n  }\n\n  /** Altered table itself is referenced through FK constraints from other table. */\n  @Test\n  public void foreignKeys2() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      stmt.executeUpdate(\"CREATE TABLE referencing_table (\"\n          + \" id int PRIMARY KEY,\"\n          + \" fk1 int REFERENCES nopk (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES nopk (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table DROP COLUMN drop_me\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 2)));\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (2, 2, 2, 2)\");\n\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n\n      runInvalidQuery(stmt, \"DELETE FROM nopk WHERE id = 1\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\"\n              + \" on table \\\"referencing_table\\\"\");\n    }\n  }\n\n  @Test\n  public void otherConstraintsAndIndexes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.\n      runInvalidQuery(stmt, \"CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))\",\n          \"EXCLUDE constraint not supported yet\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" v1 int UNIQUE,\"\n          + \" drop_me int,\"\n          + \" v2 int,\"\n          + \" v3 int,\"\n          + \" v4 int\"\n          + \")\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v2)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk (v3)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v4 * 2))\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      String v3query = \"SELECT v3 FROM nopk WHERE v3 = 1\";\n      String v4query = \"SELECT v4 FROM nopk WHERE v4 * 2 = 2\";\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 1, 2, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v1_key\\\"\");\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 1, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v2_idx\\\"\");\n\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 1, 2)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1),\n          new Row(2, 2, 2, 1, 2)));\n\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertRowList(stmt, v3query, Arrays.asList(\n          new Row(1),\n          new Row(1)));\n\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n      assertRowList(stmt, v4query, Arrays.asList(\n          new Row(1)));\n    }\n  }\n\n  @Test\n  public void triggers() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, drop_me int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\n          \"CREATE FUNCTION notice_on_trigger() RETURNS trigger\"\n              + \" LANGUAGE plpgsql\"\n              + \" AS $$\"\n              + \"   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;\"\n              + \"   RETURN NEW;\"\n              + \"   END;\"\n              + \" $$;\");\n      for (String timing : Arrays.asList(\"before\", \"after\")) {\n        for (String scope : Arrays.asList(\"statement\", \"row\")) {\n          for (String action : Arrays.asList(\"insert\", \"update\", \"delete\")) {\n            stmt.executeUpdate(MessageFormat.format(\n                \"CREATE TRIGGER nopk__{0}_{2}_{1}\"\n                    + \" {0} {2} ON nopk\"\n                    + \" FOR EACH {1}\"\n                    + \" EXECUTE PROCEDURE notice_on_trigger()\",\n                timing, scope, action));\n          }\n          String whenExpr = scope.equals(\"row\")\n              ? \"OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0\"\n              : \"RANDOM() >= 0\";\n          stmt.executeUpdate(MessageFormat.format(\n              \"CREATE TRIGGER nopk__{0}_update_c_{1}\"\n                  + \" {0} UPDATE OF id, v ON nopk\"\n                  + \" FOR EACH {1}\"\n                  + \" WHEN (\" + whenExpr + \")\"\n                  + \" EXECUTE PROCEDURE notice_on_trigger()\",\n              timing, scope));\n        }\n      }\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n\n  @Test\n  public void secondPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int PRIMARY KEY)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"multiple primary keys for table \\\"nopk\\\" are not allowed\");\n    }\n  }\n\n  @Test\n  public void splitInto() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n    }\n  }\n\n  @Test\n  public void roles() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE ROLE new_user\");\n      stmt.executeUpdate(\"ALTER TABLE nopk OWNER TO new_user\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n    }\n  }\n\n  /**\n   * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).\n   * <p>\n   * Source was a real output from pg_dump in its default configuration.\n   */\n  @Test\n  public void restorePgDump() throws Exception {\n    URL sqlFileRes = getClass().getClassLoader()\n        .getResource(\"TestPgAlterTableAddPrimaryKey/restorePgDump.sql\");\n    assertTrue(\"Dump SQL resource not found!\", sqlFileRes != null);\n    File sqlFile = new File(sqlFileRes.getFile());\n\n    String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), \"ysqlsh\").getAbsolutePath();\n    ProcessBuilder procBuilder = new ProcessBuilder(\n        ysqlshPath,\n        \"-h\", getPgHost(0),\n        \"-p\", Integer.toString(getPgPort(0)),\n        DEFAULT_PG_DATABASE);\n\n    procBuilder.redirectInput(sqlFile);\n\n    List<String> output = runProcess(procBuilder);\n\n    // Sanity checks.\n    assertTrue(output.size() > 0);\n    assertFalse(\"There was an error executing SQL: \" + output,\n        StringUtils.join(output, '\\n').toLowerCase().contains(\"error\"));\n\n    try (Statement stmt = connection.createStatement()) {\n      assertRowList(stmt, \"SELECT * FROM public.with_constraints_and_such ORDER BY id\",\n          Arrays.asList(\n              new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111),\n              new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222),\n              new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));\n    }\n  }\n\n  //\n  // Helpers\n  //\n\n  /**\n   * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.\n   */\n  private void alterAddPrimaryKey(\n      Statement stmt,\n      String tableName,\n      String alterSpec) throws Exception {\n    String countPgClass = \"SELECT COUNT(*) FROM pg_class\";\n    String getTableNames = \"SELECT table_name FROM information_schema.tables\"\n        + \" WHERE table_schema = 'public' ORDER BY table_name\";\n    String getOid = \"SELECT oid FROM pg_class WHERE relname = '\" + tableName + \"'\";\n    // This query is based on pg_dump.c query, with some columns removed.\n    // We're also selecting owning_tab_name instead of owning_tab OID.\n    String getSequences = \"SELECT c.oid, c.relname, \"\n        + \"     c.relkind, c.relnamespace, \"\n        + \"     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, \"\n        + \"     c.relchecks, c.relhastriggers, \"\n        + \"     c.relhasindex, c.relhasrules, c.relhasoids, \"\n        + \"     c.relrowsecurity, c.relforcerowsecurity, \"\n        + \"     c.relfrozenxid, c.relminmxid, tc.oid AS toid, \"\n        + \"     tc.relfrozenxid AS tfrozenxid, \"\n        + \"     tc.relminmxid AS tminmxid, \"\n        + \"     c.relpersistence, c.relispopulated, \"\n        + \"     c.relreplident, c.relpages, \"\n        + \"     CASE WHEN c.reloftype <> 0\"\n        + \"       THEN c.reloftype::pg_catalog.regtype ELSE NULL END\"\n        + \"     AS reloftype, \"\n        + \"     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, \"\n        + \"     d.refobjsubid AS owning_col, \"\n        + \"     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)\"\n        + \"       AS reltablespace, \"\n        + \"     array_remove(array_remove(c.reloptions,'check_option=local'),\"\n        + \"                  'check_option=cascaded')\"\n        + \"     AS reloptions, \"\n        + \"     CASE\"\n        + \"       WHEN 'check_option=local' = ANY (c.reloptions)\"\n        + \"         THEN 'LOCAL'::text \"\n        + \"       WHEN 'check_option=cascaded' = ANY (c.reloptions)\"\n        + \"         THEN 'CASCADED'::text ELSE NULL END\"\n        + \"     AS checkoption, \"\n        + \"     tc.reloptions AS toast_reloptions, \"\n        + \"     c.relkind = 'S' AND EXISTS (\"\n        + \"       SELECT 1 FROM pg_depend\"\n        + \"       WHERE classid = 'pg_class'::regclass\"\n        + \"         AND objid = c.oid\"\n        + \"         AND objsubid = 0\"\n        + \"         AND refclassid = 'pg_class'::regclass\"\n        + \"         AND deptype = 'i'\"\n        + \"     ) AS is_identity_sequence\"\n        + \" FROM pg_class c \"\n        + \" LEFT JOIN pg_depend d\"\n        + \"   ON (c.relkind = 'S' AND d.classid = c.tableoid AND\"\n        + \"     d.objid = c.oid AND d.objsubid = 0 AND \"\n        + \"     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) \"\n        + \" LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) \"\n        + \" LEFT JOIN pg_init_privs pip\"\n        + \"   ON (c.oid = pip.objoid AND\"\n        + \"     pip.classoid = 'pg_class'::regclass AND\"\n        + \"     pip.objsubid = 0) \"\n        + \" WHERE c.relkind in ('S') \"\n        + \" ORDER BY c.oid\";\n\n    // Saving stuff to verify after rename.\n\n    long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);\n\n    List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));\n    List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));\n\n    PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);\n\n    stmt.executeUpdate(\"ALTER TABLE \" + tableName + \" \" + alterSpec);\n\n    // OID has changed, but the pg_class row content did not.\n    long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    assertNotEquals(oldOid, newOid);\n\n    // Stuff targeting old OID should match the stuff targeting the new one.\n\n    // There's one more index in the pool now.\n    assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));\n\n    // Everything else should remain as it was.\n    assertRowList(stmt, getTableNames, oldTableNames);\n    assertRowList(stmt, getSequences, oldSequences);\n\n    PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);\n\n    assertPgStateEquals(oldState, newState);\n  }\n\n  private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {\n    ps.setLong(1, oid);\n    return getRowList(ps.executeQuery());\n  }\n\n  private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {\n    assertRow(oldState.pgClassRow, newState.pgClassRow);\n    assertRows(oldState.attrs, newState.attrs);\n    assertRows(oldState.defaults, newState.defaults);\n    assertRows(oldState.checkConstrs, newState.checkConstrs);\n    assertRows(oldState.indexes, newState.indexes);\n    assertRows(oldState.foreignKeys, newState.foreignKeys);\n    assertRows(oldState.triggers, newState.triggers);\n  }\n\n  private int getNumTablets(String databaseName, String tableName) throws Exception {\n    List<String> lines = runProcess(\n        TestUtils.findBinary(\"yb-admin\"),\n        \"--master_addresses\",\n        masterAddresses,\n        \"list_tablets\",\n        \"ysql.\" + databaseName,\n        tableName);\n    // We don't care about the output, just number of lines (minus header line).\n    return lines.size() - 1;\n  }\n\n  private class PgSystemTableInfo {\n    Row pgClassRow;\n    List<Row> attrs;\n    List<Row> defaults;\n    List<Row> checkConstrs;\n    List<Row> indexes;\n    List<Row> foreignKeys;\n    List<Row> triggers;\n\n    public PgSystemTableInfo(Connection conn, long oid) throws Exception {\n      // Columns not selected: reltype, relhasindex, relfilenode, relpartbound,\n      // relnatts (because it includes dropped attributes).\n      PreparedStatement getPgClassRow = conn.prepareStatement(\n          \"SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages,\"\n              + \"   reltuples, relallvisible, reltoastrelid, relisshared,\"\n              + \"   relpersistence, relkind, relchecks, relhasoids, relhasrules,\"\n              + \"   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity,\"\n              + \"   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid,\"\n              + \"   relminmxid, relacl\"\n              + \" FROM pg_class WHERE oid = ?\");\n\n      // These queries are taken from pg_dump.c, with the following changes:\n      //  * Formatting was changed slightly.\n      //  * Attributes query doesn't include attnotnull (they are changed for PK cols)\n      //      and dropped columns.\n      //  * Index query doesn't include PK index.\n      //  * Index query selects column names instead of attnums.\n      //  * Attribute-related queries don't include attnum (replaced by ORDER BY).\n      //  * Queries don't include tableoids because we don't care.\n      //  * Queries don't include OIDs that are expected to change.\n      //  * Added ORDER BY to all queries.\n      PreparedStatement getAttrs = conn.prepareStatement(\n          \"SELECT a.attname, a.atttypmod, \"\n              + \"   a.attstattarget, a.attstorage, t.typstorage, \"\n              + \"   a.atthasdef, a.attlen, a.attalign, a.attislocal, \"\n              + \"   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, \"\n              + \"   array_to_string(a.attoptions, ', ') AS attoptions, \"\n              + \"   CASE WHEN a.attcollation <> t.typcollation \"\n              + \"     THEN a.attcollation ELSE 0 END AS attcollation, \"\n              + \"   a.attidentity, \"\n              + \"   pg_catalog.array_to_string(ARRAY(\"\n              + \"     SELECT pg_catalog.quote_ident(option_name) || \"\n              + \"     ' ' || pg_catalog.quote_literal(option_value) \"\n              + \"     FROM pg_catalog.pg_options_to_table(attfdwoptions) \"\n              + \"     ORDER BY option_name\"\n              + \"   ), E',\\n    ') AS attfdwoptions ,\"\n              + \"   CASE WHEN a.atthasmissing AND NOT a.attisdropped \"\n              + \"     THEN a.attmissingval ELSE null END AS attmissingval \"\n              + \" FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t \"\n              + \"   ON a.atttypid = t.oid \"\n              + \" WHERE a.attrelid = ?::pg_catalog.oid \"\n              + \"   AND a.attnum > 0::pg_catalog.int2 \"\n              + \"   AND NOT a.attisdropped \"\n              + \" ORDER BY a.attnum\");\n      PreparedStatement getDefaults = conn.prepareStatement(\n          \"SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc \"\n              + \" FROM pg_catalog.pg_attrdef \"\n              + \" WHERE adrelid = ?::pg_catalog.oid \"\n              + \" ORDER BY adnum\");\n      PreparedStatement getCheckConstrs = conn.prepareStatement(\n          \"SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc,\"\n              + \"   conislocal, convalidated\"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getIndexes = conn.prepareStatement(\n          \"SELECT t.relname AS indexname, \"\n              + \"   inh.inhparent AS parentidx, \"\n              + \"   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, \"\n              + \"   i.indnkeyatts AS indnkeyatts, \"\n              + \"   i.indnatts AS indnatts, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) \"\n              + \"     AS indkey_colnames, \"\n              + \"   i.indisclustered, \"\n              + \"   i.indisreplident, i.indoption, t.relpages, \"\n              + \"   c.contype, c.conname, \"\n              + \"   c.condeferrable, c.condeferred, \"\n              + \"   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, \"\n              + \"   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)\"\n              + \"     AS tablespace, \"\n              + \"   t.reloptions AS indreloptions, \"\n              + \"   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatcols,\"\n              + \"   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatvals \"\n              + \" FROM pg_catalog.pg_index i \"\n              + \" JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) \"\n              + \" JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) \"\n              + \" LEFT JOIN pg_catalog.pg_constraint c \"\n              + \"   ON (i.indrelid = c.conrelid AND \"\n              + \"     i.indexrelid = c.conindid AND \"\n              + \"     c.contype IN ('u','x')) \"\n              + \" LEFT JOIN pg_catalog.pg_inherits inh \"\n              + \"   ON (inh.inhrelid = indexrelid) \"\n              + \" WHERE i.indrelid = ?::pg_catalog.oid \"\n              + \"   AND (i.indisvalid OR t2.relkind = 'p') \"\n              + \"   AND i.indisready \"\n              + \"   AND i.indisprimary = false \"\n              + \" ORDER BY indexname\");\n      PreparedStatement getForeignKeys = conn.prepareStatement(\n          \"SELECT conname, confrelid, \"\n              + \"   pg_catalog.pg_get_constraintdef(oid) AS condef \"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid \"\n              + \"  AND conparentid = 0 \"\n              + \"  AND contype = 'f'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getTriggers = conn.prepareStatement(\n          \"SELECT tgname, \"\n              + \"   tgfoid::pg_catalog.regproc AS tgfname, \"\n              + \"   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) \"\n              + \"     AS tgattr_colnames, \"\n              + \"   tgenabled \"\n              + \" FROM pg_catalog.pg_trigger t \"\n              + \" WHERE tgrelid = ?::pg_catalog.oid \"\n              + \"   AND NOT tgisinternal\"\n              + \" ORDER BY tgfname\");\n      List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);\n      assertTrue(\"Table with OID \" + oid + \" not found!\", pgClassRows.size() > 0);\n      this.pgClassRow = pgClassRows.get(0);\n      this.attrs = execCheckQuery(getAttrs, oid);\n      this.defaults = execCheckQuery(getDefaults, oid);\n      this.checkConstrs = execCheckQuery(getCheckConstrs, oid);\n      this.indexes = execCheckQuery(getIndexes, oid);\n      this.foreignKeys = execCheckQuery(getForeignKeys, oid);\n      this.triggers = execCheckQuery(getTriggers, oid);\n    }\n  }\n}", "class_id": 0, "repo": "nextgres/yugabyte-db", "file": "java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgAlterTableAddPrimaryKey.java", "last_update_at": "2021-06-14T23:51:05+00:00", "question_id": "6c338a1f6834fb9094f88ce1c7d13fe385e54000", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(value = YBTestRunnerNonTsanOnly.class)\npublic class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {\n  private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);\n  @Test\n  public void simplest() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n    }\n  }\n  @Test\n  public void duplicates() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 2)\");\n      // Note:\n      // PG error in this case mentions \"nopk_pkey\", not just \"nopk\"\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"duplicate key value violates unique constraint \\\"nopk\\\"\");\n      stmt.executeUpdate(\"DELETE FROM nopk WHERE v = 2\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n  @Test\n  public void nulls() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (NULL)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"column \\\"id\\\" contains null values\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row((Object) null)));\n    }\n  }\n  @Test\n  public void columnTypes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int[10][20], v2 text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, new Integer[] { 1, 2, 3 }, \"qwe\"),\n          new Row(2, new Integer[] { 3, 4 }, \"zxcv\")));\n    }\n  }\n  @Test\n  public void columnTypesUnsupported() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE typeid AS (i int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (id typeid, v int)\");\n      String msg = \"PRIMARY KEY containing column of type 'user_defined_type' not yet supported\";\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)\", msg);\n    }\n  }\n  @Test\n  public void missing() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      String msg = \"column \\\"missme\\\" named in key does not exist\";\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)\", msg);\n    }\n  }\n  @Test\n  public void complexPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '111', '1', true)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '2', false)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '3', true)\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, '222', '2', false)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY v1, v2, v3, v4\", Arrays.asList(\n          new Row(1, \"111\", \"1\", true),\n          new Row(2, \"222\", \"2\", false),\n          new Row(2, \"222\", \"3\", true)));\n    }\n  }\n  @Test\n  public void pkInclude() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int, v2 int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 11, 111)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 22, 222)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id) INCLUDE (v1, v2)\");\n      // Scan is supposed to be index-only scan, but it's index scan for us.\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 2\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(22));\n      }\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3, 11, 111)\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (3, 99, 999)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 11, 111),\n          new Row(2, 22, 222),\n          new Row(3, 11, 111)));\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 3\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(11));\n      }\n    }\n  }\n  @Test\n  public void pkUsingIndex() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY\"\n          + \" USING INDEX nopk_idx\",\n          \"ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported\");\n    }\n  }\n  @Test\n  public void sequences() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \"id serial,\"\n          + \"v1 int GENERATED ALWAYS AS IDENTITY,\"\n          + \"v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10),\"\n          + \"stuff text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r1')\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\")));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r2')\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\"),\n          new Row(2, 2, 11, \"r2\")));\n    }\n  }\n  @Test\n  public void typedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE nopk_type AS (id int, v int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk OF nopk_type\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 10)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 20)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 10),\n          new Row(2, 20)));\n      runInvalidQuery(stmt, \"ALTER TABLE nopk DROP COLUMN v\",\n          \"cannot drop column from typed table\");\n    }\n  }\n  @Ignore // TODO(alex): Enable after INHERITS is supported in #1129\n  public void inheritedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_parent (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (3, 30)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (4, 40)\");\n      alterAddPrimaryKey(stmt, \"nopk_parent\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_child\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk_parent ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_child ORDER BY id\", Arrays.asList(\n          new Row(3, 30),\n          new Row(4, 40)));\n    }\n  }\n  /** Adding PK to a partitioned table is not yet implemented. */\n  @Test\n  public void partitionedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part1 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (1, 2, 3)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (10, 20)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (30, 40)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_whole ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n    }\n  }\n  @Test\n  public void tablesInColocatedDb() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE DATABASE clc WITH colocated = true\");\n    }\n    try (Connection conn2 = getConnectionBuilder().withDatabase(\"clc\").connect();\n        Statement stmt = conn2.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_c (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (4)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_nc (id int) WITH (colocated = false)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (6)\");\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n      // This doesn't really accomplish much though, since colocated property is invisible to SQL\n      // - we can't check whether a re-created table keeps/gains/loses it.\n      // See #6159\n      alterAddPrimaryKey(stmt, \"nopk_c\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_nc\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_c ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk_nc ORDER BY id\", Arrays.asList(\n          new Row(5),\n          new Row(6)));\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n    }\n  }\n  @Test\n  public void tablesInTablegroup() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (4)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk2 (id int, id2 int unique)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (5, 5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (6, 6)\");\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk2\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk2 ORDER BY id\", Arrays.asList(\n          new Row(5, 5),\n          new Row(6, 6)));\n      assertRowList(stmt,\n        \"SELECT s.relname, pg_tablegroup.grpname \" +\n        \"FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) \" +\n        \"s, pg_tablegroup WHERE opts LIKE \" +\n        \"CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') \" +\n        \"ORDER BY s\", Arrays.asList(\n          new Row(\"nopk\", \"tgroup1\"),\n          new Row(\"nopk2\", \"tgroup1\"),\n          new Row(\"nopk2_id2_key\", \"tgroup1\"),\n          new Row(\"nopk2_pkey\", \"tgroup1\"),\n          new Row(\"nopk_pkey\", \"tgroup1\"),\n          new Row(\"normal_table\", \"tgroup1\"),\n          new Row(\"normal_table_pkey\", \"tgroup1\")));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n    }\n  }\n  @Test\n  public void defaults() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int DEFAULT 10, \"\n          + \" drop_me int DEFAULT 10, \"\n          + \" v int DEFAULT 10\"\n          + \")\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n      stmt.executeUpdate(\"INSERT INTO nopk (id) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10)));\n      stmt.executeUpdate(\"INSERT INTO nopk (v) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10),\n          new Row(10, 2)));\n    }\n  }\n  @Test\n  public void notNullAndCheck() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int CHECK (id > 0),\"\n          + \" drop_me int,\"\n          + \" v1 int CHECK (v1 > 0),\"\n          + \" v2 int NOT NULL\"\n          + \")\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (0, 2, 2)\",\n          \"violates check constraint \\\"nopk_id_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 0, 2)\",\n          \"violates check constraint \\\"nopk_v1_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, NULL)\",\n          \"violates not-null constraint\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n    }\n  }\n  /** Altered table references a FK table. */\n  @Test\n  public void foreignKeys() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (2, 2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" fk1 int REFERENCES fk_ref_table (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES fk_ref_table (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n      runInvalidQuery(stmt, \"DELETE FROM fk_ref_table WHERE id = 1\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\" on table \\\"nopk\\\"\");\n    }\n  }\n  /** Altered table itself is referenced through FK constraints from other table. */\n  @Test\n  public void foreignKeys2() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"CREATE TABLE referencing_table (\"\n          + \" id int PRIMARY KEY,\"\n          + \" fk1 int REFERENCES nopk (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES nopk (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table DROP COLUMN drop_me\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 2)));\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (2, 2, 2, 2)\");\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n      runInvalidQuery(stmt, \"DELETE FROM nopk WHERE id = 1\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\"\n              + \" on table \\\"referencing_table\\\"\");\n    }\n  }\n  @Test\n  public void otherConstraintsAndIndexes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.\n      runInvalidQuery(stmt, \"CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))\",\n          \"EXCLUDE constraint not supported yet\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" v1 int UNIQUE,\"\n          + \" drop_me int,\"\n          + \" v2 int,\"\n          + \" v3 int,\"\n          + \" v4 int\"\n          + \")\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v2)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk (v3)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v4 * 2))\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      String v3query = \"SELECT v3 FROM nopk WHERE v3 = 1\";\n      String v4query = \"SELECT v4 FROM nopk WHERE v4 * 2 = 2\";\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 1, 2, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v1_key\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 1, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v2_idx\\\"\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 1, 2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1),\n          new Row(2, 2, 2, 1, 2)));\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertRowList(stmt, v3query, Arrays.asList(\n          new Row(1),\n          new Row(1)));\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n      assertRowList(stmt, v4query, Arrays.asList(\n          new Row(1)));\n    }\n  }\n  @Test\n  public void triggers() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, drop_me int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\n          \"CREATE FUNCTION notice_on_trigger() RETURNS trigger\"\n              + \" LANGUAGE plpgsql\"\n              + \" AS $$\"\n              + \"   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;\"\n              + \"   RETURN NEW;\"\n              + \"   END;\"\n              + \" $$;\");\n      for (String timing : Arrays.asList(\"before\", \"after\")) {\n        for (String scope : Arrays.asList(\"statement\", \"row\")) {\n          for (String action : Arrays.asList(\"insert\", \"update\", \"delete\")) {\n            stmt.executeUpdate(MessageFormat.format(\n                \"CREATE TRIGGER nopk__{0}_{2}_{1}\"\n                    + \" {0} {2} ON nopk\"\n                    + \" FOR EACH {1}\"\n                    + \" EXECUTE PROCEDURE notice_on_trigger()\",\n                timing, scope, action));\n          }\n          String whenExpr = scope.equals(\"row\")\n              ? \"OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0\"\n              : \"RANDOM() >= 0\";\n          stmt.executeUpdate(MessageFormat.format(\n              \"CREATE TRIGGER nopk__{0}_update_c_{1}\"\n                  + \" {0} UPDATE OF id, v ON nopk\"\n                  + \" FOR EACH {1}\"\n                  + \" WHEN (\" + whenExpr + \")\"\n                  + \" EXECUTE PROCEDURE notice_on_trigger()\",\n              timing, scope));\n        }\n      }\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n  @Test\n  public void secondPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int PRIMARY KEY)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"multiple primary keys for table \\\"nopk\\\" are not allowed\");\n    }\n  }\n  @Test\n  public void splitInto() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n    }\n  }\n  @Test\n  public void roles() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE ROLE new_user\");\n      stmt.executeUpdate(\"ALTER TABLE nopk OWNER TO new_user\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n    }\n  }\n  /**\n   * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).\n   * <p>\n   * Source was a real output from pg_dump in its default configuration.\n   */\n  @Test\n  public void restorePgDump() throws Exception {\n    URL sqlFileRes = getClass().getClassLoader()\n        .getResource(\"TestPgAlterTableAddPrimaryKey/restorePgDump.sql\");\n    assertTrue(\"Dump SQL resource not found!\", sqlFileRes != null);\n    File sqlFile = new File(sqlFileRes.getFile());\n    String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), \"ysqlsh\").getAbsolutePath();\n    ProcessBuilder procBuilder = new ProcessBuilder(\n        ysqlshPath,\n        \"-h\", getPgHost(0),\n        \"-p\", Integer.toString(getPgPort(0)),\n        DEFAULT_PG_DATABASE);\n    procBuilder.redirectInput(sqlFile);\n    List<String> output = runProcess(procBuilder);\n    // Sanity checks.\n    assertTrue(output.size() > 0);\n    assertFalse(\"There was an error executing SQL: \" + output,\n        StringUtils.join(output, '\\n').toLowerCase().contains(\"error\"));\n    try (Statement stmt = connection.createStatement()) {\n      assertRowList(stmt, \"SELECT * FROM public.with_constraints_and_such ORDER BY id\",\n          Arrays.asList(\n              new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111),\n              new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222),\n              new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));\n    }\n  }\n  //\n  // Helpers\n  //\n  /**\n   * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.\n   */\n  private void alterAddPrimaryKey(\n      Statement stmt,\n      String tableName,\n      String alterSpec) throws Exception {\n    String countPgClass = \"SELECT COUNT(*) FROM pg_class\";\n    String getTableNames = \"SELECT table_name FROM information_schema.tables\"\n        + \" WHERE table_schema = 'public' ORDER BY table_name\";\n    String getOid = \"SELECT oid FROM pg_class WHERE relname = '\" + tableName + \"'\";\n    // This query is based on pg_dump.c query, with some columns removed.\n    // We're also selecting owning_tab_name instead of owning_tab OID.\n    String getSequences = \"SELECT c.oid, c.relname, \"\n        + \"     c.relkind, c.relnamespace, \"\n        + \"     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, \"\n        + \"     c.relchecks, c.relhastriggers, \"\n        + \"     c.relhasindex, c.relhasrules, c.relhasoids, \"\n        + \"     c.relrowsecurity, c.relforcerowsecurity, \"\n        + \"     c.relfrozenxid, c.relminmxid, tc.oid AS toid, \"\n        + \"     tc.relfrozenxid AS tfrozenxid, \"\n        + \"     tc.relminmxid AS tminmxid, \"\n        + \"     c.relpersistence, c.relispopulated, \"\n        + \"     c.relreplident, c.relpages, \"\n        + \"     CASE WHEN c.reloftype <> 0\"\n        + \"       THEN c.reloftype::pg_catalog.regtype ELSE NULL END\"\n        + \"     AS reloftype, \"\n        + \"     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, \"\n        + \"     d.refobjsubid AS owning_col, \"\n        + \"     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)\"\n        + \"       AS reltablespace, \"\n        + \"     array_remove(array_remove(c.reloptions,'check_option=local'),\"\n        + \"                  'check_option=cascaded')\"\n        + \"     AS reloptions, \"\n        + \"     CASE\"\n        + \"       WHEN 'check_option=local' = ANY (c.reloptions)\"\n        + \"         THEN 'LOCAL'::text \"\n        + \"       WHEN 'check_option=cascaded' = ANY (c.reloptions)\"\n        + \"         THEN 'CASCADED'::text ELSE NULL END\"\n        + \"     AS checkoption, \"\n        + \"     tc.reloptions AS toast_reloptions, \"\n        + \"     c.relkind = 'S' AND EXISTS (\"\n        + \"       SELECT 1 FROM pg_depend\"\n        + \"       WHERE classid = 'pg_class'::regclass\"\n        + \"         AND objid = c.oid\"\n        + \"         AND objsubid = 0\"\n        + \"         AND refclassid = 'pg_class'::regclass\"\n        + \"         AND deptype = 'i'\"\n        + \"     ) AS is_identity_sequence\"\n        + \" FROM pg_class c \"\n        + \" LEFT JOIN pg_depend d\"\n        + \"   ON (c.relkind = 'S' AND d.classid = c.tableoid AND\"\n        + \"     d.objid = c.oid AND d.objsubid = 0 AND \"\n        + \"     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) \"\n        + \" LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) \"\n        + \" LEFT JOIN pg_init_privs pip\"\n        + \"   ON (c.oid = pip.objoid AND\"\n        + \"     pip.classoid = 'pg_class'::regclass AND\"\n        + \"     pip.objsubid = 0) \"\n        + \" WHERE c.relkind in ('S') \"\n        + \" ORDER BY c.oid\";\n    // Saving stuff to verify after rename.\n    long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);\n    List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));\n    List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));\n    PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);\n    stmt.executeUpdate(\"ALTER TABLE \" + tableName + \" \" + alterSpec);\n    // OID has changed, but the pg_class row content did not.\n    long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    assertNotEquals(oldOid, newOid);\n    // Stuff targeting old OID should match the stuff targeting the new one.\n    // There's one more index in the pool now.\n    assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));\n    // Everything else should remain as it was.\n    assertRowList(stmt, getTableNames, oldTableNames);\n    assertRowList(stmt, getSequences, oldSequences);\n    PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);\n    assertPgStateEquals(oldState, newState);\n  }\n  private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {\n    ps.setLong(1, oid);\n    return getRowList(ps.executeQuery());\n  }\n  private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {\n    assertRow(oldState.pgClassRow, newState.pgClassRow);\n    assertRows(oldState.attrs, newState.attrs);\n    assertRows(oldState.defaults, newState.defaults);\n    assertRows(oldState.checkConstrs, newState.checkConstrs);\n    assertRows(oldState.indexes, newState.indexes);\n    assertRows(oldState.foreignKeys, newState.foreignKeys);\n    assertRows(oldState.triggers, newState.triggers);\n  }\n  private int getNumTablets(String databaseName, String tableName) throws Exception {\n    List<String> lines = runProcess(\n        TestUtils.findBinary(\"yb-admin\"),\n        \"--master_addresses\",\n        masterAddresses,\n        \"list_tablets\",\n        \"ysql.\" + databaseName,\n        tableName);\n    // We don't care about the output, just number of lines (minus header line).\n    return lines.size() - 1;\n  }\n  private class PgSystemTableInfo {\n    Row pgClassRow;\n    List<Row> attrs;\n    List<Row> defaults;\n    List<Row> checkConstrs;\n    List<Row> indexes;\n    List<Row> foreignKeys;\n    List<Row> triggers;\n    public PgSystemTableInfo(Connection conn, long oid) throws Exception {\n      // Columns not selected: reltype, relhasindex, relfilenode, relpartbound,\n      // relnatts (because it includes dropped attributes).\n      PreparedStatement getPgClassRow = conn.prepareStatement(\n          \"SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages,\"\n              + \"   reltuples, relallvisible, reltoastrelid, relisshared,\"\n              + \"   relpersistence, relkind, relchecks, relhasoids, relhasrules,\"\n              + \"   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity,\"\n              + \"   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid,\"\n              + \"   relminmxid, relacl\"\n              + \" FROM pg_class WHERE oid = ?\");\n      // These queries are taken from pg_dump.c, with the following changes:\n      //  * Formatting was changed slightly.\n      //  * Attributes query doesn't include attnotnull (they are changed for PK cols)\n      //      and dropped columns.\n      //  * Index query doesn't include PK index.\n      //  * Index query selects column names instead of attnums.\n      //  * Attribute-related queries don't include attnum (replaced by ORDER BY).\n      //  * Queries don't include tableoids because we don't care.\n      //  * Queries don't include OIDs that are expected to change.\n      //  * Added ORDER BY to all queries.\n      PreparedStatement getAttrs = conn.prepareStatement(\n          \"SELECT a.attname, a.atttypmod, \"\n              + \"   a.attstattarget, a.attstorage, t.typstorage, \"\n              + \"   a.atthasdef, a.attlen, a.attalign, a.attislocal, \"\n              + \"   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, \"\n              + \"   array_to_string(a.attoptions, ', ') AS attoptions, \"\n              + \"   CASE WHEN a.attcollation <> t.typcollation \"\n              + \"     THEN a.attcollation ELSE 0 END AS attcollation, \"\n              + \"   a.attidentity, \"\n              + \"   pg_catalog.array_to_string(ARRAY(\"\n              + \"     SELECT pg_catalog.quote_ident(option_name) || \"\n              + \"     ' ' || pg_catalog.quote_literal(option_value) \"\n              + \"     FROM pg_catalog.pg_options_to_table(attfdwoptions) \"\n              + \"     ORDER BY option_name\"\n              + \"   ), E',\\n    ') AS attfdwoptions ,\"\n              + \"   CASE WHEN a.atthasmissing AND NOT a.attisdropped \"\n              + \"     THEN a.attmissingval ELSE null END AS attmissingval \"\n              + \" FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t \"\n              + \"   ON a.atttypid = t.oid \"\n              + \" WHERE a.attrelid = ?::pg_catalog.oid \"\n              + \"   AND a.attnum > 0::pg_catalog.int2 \"\n              + \"   AND NOT a.attisdropped \"\n              + \" ORDER BY a.attnum\");\n      PreparedStatement getDefaults = conn.prepareStatement(\n          \"SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc \"\n              + \" FROM pg_catalog.pg_attrdef \"\n              + \" WHERE adrelid = ?::pg_catalog.oid \"\n              + \" ORDER BY adnum\");\n      PreparedStatement getCheckConstrs = conn.prepareStatement(\n          \"SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc,\"\n              + \"   conislocal, convalidated\"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getIndexes = conn.prepareStatement(\n          \"SELECT t.relname AS indexname, \"\n              + \"   inh.inhparent AS parentidx, \"\n              + \"   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, \"\n              + \"   i.indnkeyatts AS indnkeyatts, \"\n              + \"   i.indnatts AS indnatts, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) \"\n              + \"     AS indkey_colnames, \"\n              + \"   i.indisclustered, \"\n              + \"   i.indisreplident, i.indoption, t.relpages, \"\n              + \"   c.contype, c.conname, \"\n              + \"   c.condeferrable, c.condeferred, \"\n              + \"   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, \"\n              + \"   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)\"\n              + \"     AS tablespace, \"\n              + \"   t.reloptions AS indreloptions, \"\n              + \"   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatcols,\"\n              + \"   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatvals \"\n              + \" FROM pg_catalog.pg_index i \"\n              + \" JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) \"\n              + \" JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) \"\n              + \" LEFT JOIN pg_catalog.pg_constraint c \"\n              + \"   ON (i.indrelid = c.conrelid AND \"\n              + \"     i.indexrelid = c.conindid AND \"\n              + \"     c.contype IN ('u','x')) \"\n              + \" LEFT JOIN pg_catalog.pg_inherits inh \"\n              + \"   ON (inh.inhrelid = indexrelid) \"\n              + \" WHERE i.indrelid = ?::pg_catalog.oid \"\n              + \"   AND (i.indisvalid OR t2.relkind = 'p') \"\n              + \"   AND i.indisready \"\n              + \"   AND i.indisprimary = false \"\n              + \" ORDER BY indexname\");\n      PreparedStatement getForeignKeys = conn.prepareStatement(\n          \"SELECT conname, confrelid, \"\n              + \"   pg_catalog.pg_get_constraintdef(oid) AS condef \"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid \"\n              + \"  AND conparentid = 0 \"\n              + \"  AND contype = 'f'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getTriggers = conn.prepareStatement(\n          \"SELECT tgname, \"\n              + \"   tgfoid::pg_catalog.regproc AS tgfname, \"\n              + \"   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) \"\n              + \"     AS tgattr_colnames, \"\n              + \"   tgenabled \"\n              + \" FROM pg_catalog.pg_trigger t \"\n              + \" WHERE tgrelid = ?::pg_catalog.oid \"\n              + \"   AND NOT tgisinternal\"\n              + \" ORDER BY tgfname\");\n      List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);\n      assertTrue(\"Table with OID \" + oid + \" not found!\", pgClassRows.size() > 0);\n      this.pgClassRow = pgClassRows.get(0);\n      this.attrs = execCheckQuery(getAttrs, oid);\n      this.defaults = execCheckQuery(getDefaults, oid);\n      this.checkConstrs = execCheckQuery(getCheckConstrs, oid);\n      this.indexes = execCheckQuery(getIndexes, oid);\n      this.foreignKeys = execCheckQuery(getForeignKeys, oid);\n      this.triggers = execCheckQuery(getTriggers, oid);\n    }\n  }\n"]], "pred": {"ppl": 1.6420940160751343, "ppl_lower": 1.8763107061386108, "ppl/lowercase_ppl": -1.2688359835031595, "ppl/zlib": 6.496885858534531e-05, "Min_5.0% Prob": 6.00157819074743, "Min_10.0% Prob": 4.071099661144555, "Min_20.0% Prob": 2.383408040684812, "Min_30.0% Prob": 1.6397235671581785, "Min_40.0% Prob": 1.236811459670185, "Min_50.0% Prob": 0.9919214538870827, "Min_60.0% Prob": 0.827424431492409}}
{"hexsha": "469ab8b8135d229de2f22682bfe1f823e382cb62", "ext": "java", "lang": "Java", "content": "public class BaseKnowledgeManagerTest {\n\n\tprivate BaseKnowledgeManager tested;\n\n\t@Mock\n\tprivate TriggerListener triggerListener;\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\ttested.update(createKnowledge());\n\t\tinitMocks(this);\n\t}\n\n\tpublic static ChangeSet createKnowledge() {\n\t\tChangeSet result = new ChangeSet();\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"id\"), \"Test\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"number\"), 10);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapKeyInner\"), \"x\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"date\"), null);\n\t\tList<Integer> list = new LinkedList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"list\"), list);\n\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"a\", 1);\n\t\tmap.put(\"b\", 2);\n\t\tmap.put(\"c\", 3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"map\"), map);\n\t\tresult.setValue(\n\t\t\t\tRuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"),\n\t\t\t\tnew InnerKnowledge(\"innerA\", \"innerB\"));\n\t\tMap<String, String> mapNested = new HashMap<>();\n\t\tmapNested.put(\"x\", \"a\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapNested\"), mapNested);\n\t\t\n\t\treturn result;\n\t}\n\n\t@Test\n\tpublic void testUpdateIntegerField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for the 'number' field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the number field the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(17, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t}\n\n\t@Test\n\tpublic void testInnerKnowledgeUpdate() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for some nested inner field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, \"innerAModified\");\n\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the inner knowledge the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(\"innerAModified\", result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\")));\n\t}\n\n\t@Test\n\tpublic void testUpdateListField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 4);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(4, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"list\")));\n\t}\n\n\t@Test\n\tpublic void testUpdateMapField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(16, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"map\")));\n\t}\n\n\t@Test\n\tpublic void testRemovalFromList() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tObject nextItemValue = tested.get(knowledgePaths).getValue(kp);\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n\t\tknowledgePaths.clear();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\n\t\t// THEN when accessed the deleted item index, the KnowledgeManager\n\t\t// should return\n\t\t// the value of the next item\n\t\tassertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));\n\t}\n\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testDeleteFromMap() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'map' elements is\n\t\t// passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\n\t\t// THEN when accessed the removed element value the KnowledgeManager\n\t\t// should throw the KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\n\t@Test\n\tpublic void testGetIntegerField() throws Exception {\n\t\t// WHEN a field is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(10, result.getValue(kp));\n\t}\n\n\t@Test\n\tpublic void testInnerKnowledgeGet() throws Exception {\n\t\t// WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(\"innerA\", result.getValue(kp));\n\t}\n\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNullBaseKnowledgeAccess() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\t// WHEN a field is accessed from the knowledge manager initialized with\n\t\t// null base knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\t// THEN exception is thrown.\n\t\ttested.get(knowledgePaths);\n\t}\n\n\t@Test\n\tpublic void testGetListField() throws Exception {\n\t\t// WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(3, result.getValue(kp));\n\t}\n\n\t@Test\n\tpublic void testGetMapField() throws Exception {\n\t\t// WHEN an element of a map is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(1, result.getValue(kp));\n\t}\n\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNotExsistentAccess() throws Exception {\n\t\t// WHEN a not existent entry is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"dummy\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\t// THEN the ReadOnlyKnowledgeManager should throw the\n\t\t// KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\n\t@Test\n\tpublic void testRegisterListener() throws Exception {\n\t\t// WHEN a listener is registered at the KnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// and WHEN listener's releavant knowledge is updated\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\t\ttested.update(toUpdate);\n\t\t// THEN the listener is notify once.\n\t\tverify(triggerListener).triggered(trigger);\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\n\t@Test\n\tpublic void testUnregisterListener() throws Exception {\n\t\t// WHEN a previously registered listener\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// is unregistered from the KnowledgeManager\n\t\ttested.register(trigger, triggerListener);\n\t\t// THEN it is not notified about knowledge changes any more\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\n\t@Test\n\tpublic void testGetRootKnowledge() throws Exception {\n\t\t// WHEN empty knowledge path is created\n\t\tKnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(emptyKP);\n\t\t// and WHEN it is used to access knowledge manager data\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN as a result the knowledge manager should return its root\n\t\t// knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"id\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"date\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t}\n\n\tpublic void testForbiddenUpdate() throws Exception {\n\t\t// WHEN the knowledge manager update is required, with one list element\n\t\t// removal and number field update and incorrect inner knowledge change\n\t\tKnowledgePath numberPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"number\");\n\t\tKnowledgePath listElementPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"list\", \"1\");\n\t\tKnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tChangeSet toChange = new ChangeSet();\n\t\ttoChange.setValue(numberPath, 100);\n\t\ttoChange.setValue(innerPath, 66);\n\t\ttoChange.setDeleted(listElementPath);\n\n\t\tboolean exceptionThrown = false;\n\n\t\ttry {\n\t\t\ttested.update(toChange, \"update_author\");\n\t\t} catch (KnowledgeUpdateException e) {\n\t\t\texceptionThrown = true;\n\t\t}\n\t\t// THEN the KnowledgeUpdateException is thrown\n\t\tassertTrue(exceptionThrown);\n\n\t\tKnowledgePath listPath = RuntimeModelHelper.createKnowledgePath(\"list\");\n\t\tList<KnowledgePath> listOfPaths = new LinkedList<>();\n\t\t// and THEN list remains unchanged\n\t\tlistOfPaths.add(listPath);\n\t\tassertEquals(3,\n\t\t\t\t((List<?>) tested.get(listOfPaths).getValue(listPath)).size());\n\t\tlistOfPaths.clear();\n\t\t// and THEN inner knowledge has its original value\n\t\tlistOfPaths.add(innerPath);\n\t\tassertEquals(\"innerA\", tested.get(listOfPaths).getValue(innerPath));\n\t\tlistOfPaths.clear();\n\t\t// and THEN number field has its original value\n\t\tlistOfPaths.add(numberPath);\n\t\tassertEquals(10, tested.get(listOfPaths).getValue(numberPath));\n\t\t\n\t\t// then authors of knowledge remain the same\n\t\tassertEquals(\"TEST\", tested.getAuthor(numberPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(listElementPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(innerPath));\n\t}\n\n\t@Test\n\tpublic void securityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(expectedTags, actualTags);\n\t}\n\t\n\t@Test\n\tpublic void addSecurityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\ttested.addSecurityTag(kp, tag);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(2, actualTags.size());\n\t\tassertEquals(tag, actualTags.get(0));\n\t\tassertEquals(tag, actualTags.get(1));\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_MultiNodePathTest() {\n\t\t// given multi-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\", \"inner\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_IdPathTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath();\n\t\tkp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest1() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n\t\tKnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\");\n\t\t\n\t\t// when nested path is used and getAuthor() called\n\t\tString innerAuthor = tested.getAuthor(nestedPath);\n\t\tString outerAuthor = tested.getAuthor(basicPath);\n\t\t\n\t\t// then author is returned\n\t\tassertEquals(\"TEST\", innerAuthor);\n\t\tassertEquals(\"TEST\", outerAuthor);\n\t\t\n\t\t// then knowledge paths remain intact\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\"), nestedPath);\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), basicPath);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest2() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath(\"non\", \"existent\", \"path\");\n\t\t\n\t\t// when getAuthor() is called\n\t\tString author = tested.getAuthor(nonExistentPath);\n\t\t\n\t\t// then null is returned\n\t\tassertNull(author);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// WHEN the 'map' itself is then updated by a different author\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setValue(kp2, new HashMap<>());\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is set to Y\n\t\tassertEquals(\"Y\", tested.getAuthor(kp2));\n\t\tassertEquals(\"Y\", tested.getAuthor(kp));\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// WHEN the 'map' itself is then deleted\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setDeleted(kp2);\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is null\n\t\tassertNull(tested.getAuthor(kp2));\n\t\tassertNull(tested.getAuthor(kp));\n\t}\n\t\n\tpublic static class InnerKnowledge {\n\t\tpublic String a;\n\t\tpublic String b;\n\n\t\tpublic InnerKnowledge(String a, String b) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "d3scomp/JDEECo", "file": "jdeeco-core/test/cz/cuni/mff/d3s/deeco/knowledge/BaseKnowledgeManagerTest.java", "last_update_at": "2021-09-22T12:46:58+00:00", "question_id": "469ab8b8135d229de2f22682bfe1f823e382cb62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseKnowledgeManagerTest {\n\tprivate BaseKnowledgeManager tested;\n\t@Mock\n\tprivate TriggerListener triggerListener;\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\ttested.update(createKnowledge());\n\t\tinitMocks(this);\n\t}\n\tpublic static ChangeSet createKnowledge() {\n\t\tChangeSet result = new ChangeSet();\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"id\"), \"Test\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"number\"), 10);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapKeyInner\"), \"x\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"date\"), null);\n\t\tList<Integer> list = new LinkedList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"list\"), list);\n\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"a\", 1);\n\t\tmap.put(\"b\", 2);\n\t\tmap.put(\"c\", 3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"map\"), map);\n\t\tresult.setValue(\n\t\t\t\tRuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"),\n\t\t\t\tnew InnerKnowledge(\"innerA\", \"innerB\"));\n\t\tMap<String, String> mapNested = new HashMap<>();\n\t\tmapNested.put(\"x\", \"a\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapNested\"), mapNested);\n\t\t\n\t\treturn result;\n\t}\n\t@Test\n\tpublic void testUpdateIntegerField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for the 'number' field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the number field the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(17, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t}\n\t@Test\n\tpublic void testInnerKnowledgeUpdate() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for some nested inner field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, \"innerAModified\");\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the inner knowledge the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(\"innerAModified\", result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\")));\n\t}\n\t@Test\n\tpublic void testUpdateListField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 4);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(4, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"list\")));\n\t}\n\t@Test\n\tpublic void testUpdateMapField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(16, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"map\")));\n\t}\n\t@Test\n\tpublic void testRemovalFromList() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tObject nextItemValue = tested.get(knowledgePaths).getValue(kp);\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n\t\tknowledgePaths.clear();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\t\t// THEN when accessed the deleted item index, the KnowledgeManager\n\t\t// should return\n\t\t// the value of the next item\n\t\tassertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));\n\t}\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testDeleteFromMap() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'map' elements is\n\t\t// passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\t\t// THEN when accessed the removed element value the KnowledgeManager\n\t\t// should throw the KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\t@Test\n\tpublic void testGetIntegerField() throws Exception {\n\t\t// WHEN a field is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(10, result.getValue(kp));\n\t}\n\t@Test\n\tpublic void testInnerKnowledgeGet() throws Exception {\n\t\t// WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(\"innerA\", result.getValue(kp));\n\t}\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNullBaseKnowledgeAccess() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\t// WHEN a field is accessed from the knowledge manager initialized with\n\t\t// null base knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\t// THEN exception is thrown.\n\t\ttested.get(knowledgePaths);\n\t}\n\t@Test\n\tpublic void testGetListField() throws Exception {\n\t\t// WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(3, result.getValue(kp));\n\t}\n\t@Test\n\tpublic void testGetMapField() throws Exception {\n\t\t// WHEN an element of a map is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(1, result.getValue(kp));\n\t}\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNotExsistentAccess() throws Exception {\n\t\t// WHEN a not existent entry is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"dummy\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\t// THEN the ReadOnlyKnowledgeManager should throw the\n\t\t// KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\t@Test\n\tpublic void testRegisterListener() throws Exception {\n\t\t// WHEN a listener is registered at the KnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// and WHEN listener's releavant knowledge is updated\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\t\ttested.update(toUpdate);\n\t\t// THEN the listener is notify once.\n\t\tverify(triggerListener).triggered(trigger);\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\t@Test\n\tpublic void testUnregisterListener() throws Exception {\n\t\t// WHEN a previously registered listener\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// is unregistered from the KnowledgeManager\n\t\ttested.register(trigger, triggerListener);\n\t\t// THEN it is not notified about knowledge changes any more\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\t@Test\n\tpublic void testGetRootKnowledge() throws Exception {\n\t\t// WHEN empty knowledge path is created\n\t\tKnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(emptyKP);\n\t\t// and WHEN it is used to access knowledge manager data\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN as a result the knowledge manager should return its root\n\t\t// knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"id\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"date\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t}\n\tpublic void testForbiddenUpdate() throws Exception {\n\t\t// WHEN the knowledge manager update is required, with one list element\n\t\t// removal and number field update and incorrect inner knowledge change\n\t\tKnowledgePath numberPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"number\");\n\t\tKnowledgePath listElementPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"list\", \"1\");\n\t\tKnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tChangeSet toChange = new ChangeSet();\n\t\ttoChange.setValue(numberPath, 100);\n\t\ttoChange.setValue(innerPath, 66);\n\t\ttoChange.setDeleted(listElementPath);\n\t\tboolean exceptionThrown = false;\n\t\ttry {\n\t\t\ttested.update(toChange, \"update_author\");\n\t\t} catch (KnowledgeUpdateException e) {\n\t\t\texceptionThrown = true;\n\t\t}\n\t\t// THEN the KnowledgeUpdateException is thrown\n\t\tassertTrue(exceptionThrown);\n\t\tKnowledgePath listPath = RuntimeModelHelper.createKnowledgePath(\"list\");\n\t\tList<KnowledgePath> listOfPaths = new LinkedList<>();\n\t\t// and THEN list remains unchanged\n\t\tlistOfPaths.add(listPath);\n\t\tassertEquals(3,\n\t\t\t\t((List<?>) tested.get(listOfPaths).getValue(listPath)).size());\n\t\tlistOfPaths.clear();\n\t\t// and THEN inner knowledge has its original value\n\t\tlistOfPaths.add(innerPath);\n\t\tassertEquals(\"innerA\", tested.get(listOfPaths).getValue(innerPath));\n\t\tlistOfPaths.clear();\n\t\t// and THEN number field has its original value\n\t\tlistOfPaths.add(numberPath);\n\t\tassertEquals(10, tested.get(listOfPaths).getValue(numberPath));\n\t\t\n\t\t// then authors of knowledge remain the same\n\t\tassertEquals(\"TEST\", tested.getAuthor(numberPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(listElementPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(innerPath));\n\t}\n\t@Test\n\tpublic void securityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(expectedTags, actualTags);\n\t}\n\t\n\t@Test\n\tpublic void addSecurityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\ttested.addSecurityTag(kp, tag);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(2, actualTags.size());\n\t\tassertEquals(tag, actualTags.get(0));\n\t\tassertEquals(tag, actualTags.get(1));\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_MultiNodePathTest() {\n\t\t// given multi-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\", \"inner\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_IdPathTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath();\n\t\tkp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest1() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n\t\tKnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\");\n\t\t\n\t\t// when nested path is used and getAuthor() called\n\t\tString innerAuthor = tested.getAuthor(nestedPath);\n\t\tString outerAuthor = tested.getAuthor(basicPath);\n\t\t\n\t\t// then author is returned\n\t\tassertEquals(\"TEST\", innerAuthor);\n\t\tassertEquals(\"TEST\", outerAuthor);\n\t\t\n\t\t// then knowledge paths remain intact\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\"), nestedPath);\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), basicPath);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest2() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath(\"non\", \"existent\", \"path\");\n\t\t\n\t\t// when getAuthor() is called\n\t\tString author = tested.getAuthor(nonExistentPath);\n\t\t\n\t\t// then null is returned\n\t\tassertNull(author);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// WHEN the 'map' itself is then updated by a different author\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setValue(kp2, new HashMap<>());\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is set to Y\n\t\tassertEquals(\"Y\", tested.getAuthor(kp2));\n\t\tassertEquals(\"Y\", tested.getAuthor(kp));\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// WHEN the 'map' itself is then deleted\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setDeleted(kp2);\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is null\n\t\tassertNull(tested.getAuthor(kp2));\n\t\tassertNull(tested.getAuthor(kp));\n\t}\n\t\n\tpublic static class InnerKnowledge {\n\t\tpublic String a;\n\t\tpublic String b;\n\t\tpublic InnerKnowledge(String a, String b) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.8129621744155884, "ppl_lower": 1.9262161254882812, "ppl/lowercase_ppl": -1.1018475916401536, "ppl/zlib": 0.00021737744538639879, "Min_5.0% Prob": 6.185971559262743, "Min_10.0% Prob": 4.662605439915376, "Min_20.0% Prob": 2.833936407285578, "Min_30.0% Prob": 1.9595595266109977, "Min_40.0% Prob": 1.481303359930629, "Min_50.0% Prob": 1.1894038858879976, "Min_60.0% Prob": 0.9925222739601602}}
{"hexsha": "2f09050d499d8eb4df2f94048b0b44a79bf11ad5", "ext": "java", "lang": "Java", "content": "public class MockApnsServer extends BaseHttp2Server {\n\n    private final PushNotificationHandlerFactory handlerFactory;\n    private final MockApnsServerListener listener;\n\n    private final int maxConcurrentStreams;\n\n    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup,\n                   final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener,\n                   final int maxConcurrentStreams) {\n\n        super(sslContext, eventLoopGroup);\n\n        this.handlerFactory = handlerFactory;\n        this.listener = listener;\n\n        this.maxConcurrentStreams = maxConcurrentStreams;\n    }\n\n    @Override\n    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {\n        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);\n\n        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder()\n                .pushNotificationHandler(pushNotificationHandler)\n                .initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams))\n                .listener(this.listener)\n                .build();\n\n        pipeline.addLast(serverHandler);\n    }\n}", "class_id": 0, "repo": "Chatatata/pushy", "file": "pushy/src/main/java/sa/com/stcpay/blink/pushy/server/MockApnsServer.java", "last_update_at": "2021-01-04T11:06:26+00:00", "question_id": "2f09050d499d8eb4df2f94048b0b44a79bf11ad5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockApnsServer extends BaseHttp2Server {\n    private final PushNotificationHandlerFactory handlerFactory;\n    private final MockApnsServerListener listener;\n    private final int maxConcurrentStreams;\n    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup,\n                   final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener,\n                   final int maxConcurrentStreams) {\n        super(sslContext, eventLoopGroup);\n        this.handlerFactory = handlerFactory;\n        this.listener = listener;\n        this.maxConcurrentStreams = maxConcurrentStreams;\n    }\n    @Override\n    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {\n        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);\n        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder()\n                .pushNotificationHandler(pushNotificationHandler)\n                .initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams))\n                .listener(this.listener)\n                .build();\n        pipeline.addLast(serverHandler);\n    }\n"]], "pred": {"ppl": 1.885459065437317, "ppl_lower": 2.4224743843078613, "ppl/lowercase_ppl": -1.3951899945294923, "ppl/zlib": 0.001520794549858281, "Min_5.0% Prob": 6.219236405690511, "Min_10.0% Prob": 4.614577396710714, "Min_20.0% Prob": 2.8883765657742817, "Min_30.0% Prob": 2.0622123554348946, "Min_40.0% Prob": 1.5784679823244612, "Min_50.0% Prob": 1.2694826900959015, "Min_60.0% Prob": 1.0597051202190213}}
{"hexsha": "6121857566879d003fc4f936c4f45ac6ff2ab499", "ext": "java", "lang": "Java", "content": "public class GrobidCitationFetcher implements SearchBasedFetcher {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);\n\n    private static final String GROBID_URL = \"http://grobid.jabref.org:8070\";\n    private ImportFormatPreferences importFormatPreferences;\n    private GrobidService grobidService;\n\n    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {\n        this(importFormatPreferences, new GrobidService(GROBID_URL));\n    }\n\n    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {\n        this.importFormatPreferences = importFormatPreferences;\n        this.grobidService = grobidService;\n    }\n\n    /**\n     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the\n     * server has to look up the entry.\n     *\n     * @return A BibTeX string if extraction is successful\n     */\n    private Optional<String> parseUsingGrobid(String plainText) {\n        try {\n            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));\n        } catch (SocketTimeoutException e) {\n            String msg = \"Connection timed out.\";\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        } catch (IOException e) {\n            String msg = \"Could not process citation. \" + e.getMessage();\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        }\n    }\n\n    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {\n        try {\n            return BibtexParser.singleFromString(bibtexString,\n                    importFormatPreferences, new DummyFileUpdateMonitor());\n        } catch (ParseException e) {\n            return Optional.empty();\n        }\n    }\n\n    @Override\n    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {\n        List<BibEntry> bibEntries = null;\n        // This just treats the complex query like a normal string query until it it implemented correctly\n        String query = complexSearchQuery.toString();\n        try {\n            bibEntries = Arrays\n                    .stream(query.split(\"\\\\r\\\\r+|\\\\n\\\\n+|\\\\r\\\\n(\\\\r\\\\n)+\"))\n                    .map(String::trim)\n                    .filter(str -> !str.isBlank())\n                    .map(this::parseUsingGrobid)\n                    .flatMap(Optional::stream)\n                    .map(this::parseBibToBibEntry)\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toList());\n        } catch (RuntimeException e) {\n            // un-wrap the wrapped exceptions\n            throw new FetcherException(e.getMessage(), e.getCause());\n        }\n        return bibEntries;\n    }\n\n    @Override\n    public String getName() {\n        return \"GROBID\";\n    }\n\n}", "class_id": 0, "repo": "scfinniss/jabref", "file": "src/main/java/org/jabref/logic/importer/fetcher/GrobidCitationFetcher.java", "last_update_at": "2021-04-02T16:02:25+00:00", "question_id": "6121857566879d003fc4f936c4f45ac6ff2ab499", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GrobidCitationFetcher implements SearchBasedFetcher {\n    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);\n    private static final String GROBID_URL = \"http://grobid.jabref.org:8070\";\n    private ImportFormatPreferences importFormatPreferences;\n    private GrobidService grobidService;\n    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {\n        this(importFormatPreferences, new GrobidService(GROBID_URL));\n    }\n    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {\n        this.importFormatPreferences = importFormatPreferences;\n        this.grobidService = grobidService;\n    }\n    /**\n     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the\n     * server has to look up the entry.\n     *\n     * @return A BibTeX string if extraction is successful\n     */\n    private Optional<String> parseUsingGrobid(String plainText) {\n        try {\n            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));\n        } catch (SocketTimeoutException e) {\n            String msg = \"Connection timed out.\";\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        } catch (IOException e) {\n            String msg = \"Could not process citation. \" + e.getMessage();\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        }\n    }\n    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {\n        try {\n            return BibtexParser.singleFromString(bibtexString,\n                    importFormatPreferences, new DummyFileUpdateMonitor());\n        } catch (ParseException e) {\n            return Optional.empty();\n        }\n    }\n    @Override\n    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {\n        List<BibEntry> bibEntries = null;\n        // This just treats the complex query like a normal string query until it it implemented correctly\n        String query = complexSearchQuery.toString();\n        try {\n            bibEntries = Arrays\n                    .stream(query.split(\"\\\\r\\\\r+|\\\\n\\\\n+|\\\\r\\\\n(\\\\r\\\\n)+\"))\n                    .map(String::trim)\n                    .filter(str -> !str.isBlank())\n                    .map(this::parseUsingGrobid)\n                    .flatMap(Optional::stream)\n                    .map(this::parseBibToBibEntry)\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toList());\n        } catch (RuntimeException e) {\n            // un-wrap the wrapped exceptions\n            throw new FetcherException(e.getMessage(), e.getCause());\n        }\n        return bibEntries;\n    }\n    @Override\n    public String getName() {\n        return \"GROBID\";\n    }\n"]], "pred": {"ppl": 2.1105754375457764, "ppl_lower": 2.5788981914520264, "ppl/lowercase_ppl": -1.2682894020088982, "ppl/zlib": 0.0007507142005254848, "Min_5.0% Prob": 6.922426700592041, "Min_10.0% Prob": 5.1891543590105496, "Min_20.0% Prob": 3.4047944908722854, "Min_30.0% Prob": 2.4212870220852714, "Min_40.0% Prob": 1.8558390540046952, "Min_50.0% Prob": 1.4930710310068651, "Min_60.0% Prob": 1.2458539591459399}}
{"hexsha": "9687d6ab54c8b9d8f51dadc5b7c29d4734a45987", "ext": "java", "lang": "Java", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"AddClientsToClassesRequest\", propOrder = {\n    \"clientIDs\",\n    \"classIDs\",\n    \"test\",\n    \"requirePayment\",\n    \"waitlist\",\n    \"sendEmail\"\n})\npublic class AddClientsToClassesRequest\n    extends MBRequest\n    implements Serializable, Equals, HashCode, ToString\n{\n\n    private final static long serialVersionUID = 1L;\n    @XmlElement(name = \"ClientIDs\")\n    protected ArrayOfString clientIDs;\n    @XmlElement(name = \"ClassIDs\")\n    protected ArrayOfInt classIDs;\n    @XmlElement(name = \"Test\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean test;\n    @XmlElement(name = \"RequirePayment\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean requirePayment;\n    @XmlElement(name = \"Waitlist\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean waitlist;\n    @XmlElement(name = \"SendEmail\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean sendEmail;\n\n    /**\n     * Gets the value of the clientIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public ArrayOfString getClientIDs() {\n        return clientIDs;\n    }\n\n    /**\n     * Sets the value of the clientIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public void setClientIDs(ArrayOfString value) {\n        this.clientIDs = value;\n    }\n\n    /**\n     * Gets the value of the classIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public ArrayOfInt getClassIDs() {\n        return classIDs;\n    }\n\n    /**\n     * Sets the value of the classIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public void setClassIDs(ArrayOfInt value) {\n        this.classIDs = value;\n    }\n\n    /**\n     * Gets the value of the test property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getTest() {\n        return test;\n    }\n\n    /**\n     * Sets the value of the test property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setTest(Boolean value) {\n        this.test = value;\n    }\n\n    /**\n     * Gets the value of the requirePayment property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getRequirePayment() {\n        return requirePayment;\n    }\n\n    /**\n     * Sets the value of the requirePayment property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setRequirePayment(Boolean value) {\n        this.requirePayment = value;\n    }\n\n    /**\n     * Gets the value of the waitlist property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getWaitlist() {\n        return waitlist;\n    }\n\n    /**\n     * Sets the value of the waitlist property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setWaitlist(Boolean value) {\n        this.waitlist = value;\n    }\n\n    /**\n     * Gets the value of the sendEmail property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getSendEmail() {\n        return sendEmail;\n    }\n\n    /**\n     * Sets the value of the sendEmail property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setSendEmail(Boolean value) {\n        this.sendEmail = value;\n    }\n\n    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {\n        int currentHashCode = super.hashCode(locator, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"clientIDs\", theClientIDs), currentHashCode, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"classIDs\", theClassIDs), currentHashCode, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"test\", theTest), currentHashCode, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"requirePayment\", theRequirePayment), currentHashCode, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"waitlist\", theWaitlist), currentHashCode, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"sendEmail\", theSendEmail), currentHashCode, theSendEmail);\n        }\n        return currentHashCode;\n    }\n\n    public int hashCode() {\n        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;\n        return this.hashCode(null, strategy);\n    }\n\n    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {\n        if (!(object instanceof AddClientsToClassesRequest)) {\n            return false;\n        }\n        if (this == object) {\n            return true;\n        }\n        if (!super.equals(thisLocator, thatLocator, object, strategy)) {\n            return false;\n        }\n        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);\n        {\n            ArrayOfString lhsClientIDs;\n            lhsClientIDs = this.getClientIDs();\n            ArrayOfString rhsClientIDs;\n            rhsClientIDs = that.getClientIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"clientIDs\", lhsClientIDs), LocatorUtils.property(thatLocator, \"clientIDs\", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {\n                return false;\n            }\n        }\n        {\n            ArrayOfInt lhsClassIDs;\n            lhsClassIDs = this.getClassIDs();\n            ArrayOfInt rhsClassIDs;\n            rhsClassIDs = that.getClassIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"classIDs\", lhsClassIDs), LocatorUtils.property(thatLocator, \"classIDs\", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsTest;\n            lhsTest = this.getTest();\n            Boolean rhsTest;\n            rhsTest = that.getTest();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"test\", lhsTest), LocatorUtils.property(thatLocator, \"test\", rhsTest), lhsTest, rhsTest)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsRequirePayment;\n            lhsRequirePayment = this.getRequirePayment();\n            Boolean rhsRequirePayment;\n            rhsRequirePayment = that.getRequirePayment();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"requirePayment\", lhsRequirePayment), LocatorUtils.property(thatLocator, \"requirePayment\", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsWaitlist;\n            lhsWaitlist = this.getWaitlist();\n            Boolean rhsWaitlist;\n            rhsWaitlist = that.getWaitlist();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"waitlist\", lhsWaitlist), LocatorUtils.property(thatLocator, \"waitlist\", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsSendEmail;\n            lhsSendEmail = this.getSendEmail();\n            Boolean rhsSendEmail;\n            rhsSendEmail = that.getSendEmail();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"sendEmail\", lhsSendEmail), LocatorUtils.property(thatLocator, \"sendEmail\", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean equals(Object object) {\n        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;\n        return equals(null, null, object, strategy);\n    }\n\n    public String toString() {\n        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;\n        final StringBuilder buffer = new StringBuilder();\n        append(null, buffer, strategy);\n        return buffer.toString();\n    }\n\n    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        strategy.appendStart(locator, this, buffer);\n        appendFields(locator, buffer, strategy);\n        strategy.appendEnd(locator, this, buffer);\n        return buffer;\n    }\n\n    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        super.appendFields(locator, buffer, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            strategy.appendField(locator, this, \"clientIDs\", buffer, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            strategy.appendField(locator, this, \"classIDs\", buffer, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            strategy.appendField(locator, this, \"test\", buffer, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            strategy.appendField(locator, this, \"requirePayment\", buffer, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            strategy.appendField(locator, this, \"waitlist\", buffer, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            strategy.appendField(locator, this, \"sendEmail\", buffer, theSendEmail);\n        }\n        return buffer;\n    }\n\n}", "class_id": 0, "repo": "xaderfos/hyperjaxb3-support", "file": "m/MindBody/src/main/java/integration/mindbody/AddClientsToClassesRequest.java", "last_update_at": "2021-02-03T09:26:07+00:00", "question_id": "9687d6ab54c8b9d8f51dadc5b7c29d4734a45987", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"AddClientsToClassesRequest\", propOrder = {\n    \"clientIDs\",\n    \"classIDs\",\n    \"test\",\n    \"requirePayment\",\n    \"waitlist\",\n    \"sendEmail\"\n})\npublic class AddClientsToClassesRequest\n    extends MBRequest\n    implements Serializable, Equals, HashCode, ToString\n{\n    private final static long serialVersionUID = 1L;\n    @XmlElement(name = \"ClientIDs\")\n    protected ArrayOfString clientIDs;\n    @XmlElement(name = \"ClassIDs\")\n    protected ArrayOfInt classIDs;\n    @XmlElement(name = \"Test\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean test;\n    @XmlElement(name = \"RequirePayment\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean requirePayment;\n    @XmlElement(name = \"Waitlist\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean waitlist;\n    @XmlElement(name = \"SendEmail\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean sendEmail;\n    /**\n     * Gets the value of the clientIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public ArrayOfString getClientIDs() {\n        return clientIDs;\n    }\n    /**\n     * Sets the value of the clientIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public void setClientIDs(ArrayOfString value) {\n        this.clientIDs = value;\n    }\n    /**\n     * Gets the value of the classIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public ArrayOfInt getClassIDs() {\n        return classIDs;\n    }\n    /**\n     * Sets the value of the classIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public void setClassIDs(ArrayOfInt value) {\n        this.classIDs = value;\n    }\n    /**\n     * Gets the value of the test property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getTest() {\n        return test;\n    }\n    /**\n     * Sets the value of the test property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setTest(Boolean value) {\n        this.test = value;\n    }\n    /**\n     * Gets the value of the requirePayment property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getRequirePayment() {\n        return requirePayment;\n    }\n    /**\n     * Sets the value of the requirePayment property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setRequirePayment(Boolean value) {\n        this.requirePayment = value;\n    }\n    /**\n     * Gets the value of the waitlist property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getWaitlist() {\n        return waitlist;\n    }\n    /**\n     * Sets the value of the waitlist property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setWaitlist(Boolean value) {\n        this.waitlist = value;\n    }\n    /**\n     * Gets the value of the sendEmail property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getSendEmail() {\n        return sendEmail;\n    }\n    /**\n     * Sets the value of the sendEmail property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setSendEmail(Boolean value) {\n        this.sendEmail = value;\n    }\n    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {\n        int currentHashCode = super.hashCode(locator, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"clientIDs\", theClientIDs), currentHashCode, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"classIDs\", theClassIDs), currentHashCode, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"test\", theTest), currentHashCode, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"requirePayment\", theRequirePayment), currentHashCode, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"waitlist\", theWaitlist), currentHashCode, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"sendEmail\", theSendEmail), currentHashCode, theSendEmail);\n        }\n        return currentHashCode;\n    }\n    public int hashCode() {\n        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;\n        return this.hashCode(null, strategy);\n    }\n    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {\n        if (!(object instanceof AddClientsToClassesRequest)) {\n            return false;\n        }\n        if (this == object) {\n            return true;\n        }\n        if (!super.equals(thisLocator, thatLocator, object, strategy)) {\n            return false;\n        }\n        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);\n        {\n            ArrayOfString lhsClientIDs;\n            lhsClientIDs = this.getClientIDs();\n            ArrayOfString rhsClientIDs;\n            rhsClientIDs = that.getClientIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"clientIDs\", lhsClientIDs), LocatorUtils.property(thatLocator, \"clientIDs\", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {\n                return false;\n            }\n        }\n        {\n            ArrayOfInt lhsClassIDs;\n            lhsClassIDs = this.getClassIDs();\n            ArrayOfInt rhsClassIDs;\n            rhsClassIDs = that.getClassIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"classIDs\", lhsClassIDs), LocatorUtils.property(thatLocator, \"classIDs\", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsTest;\n            lhsTest = this.getTest();\n            Boolean rhsTest;\n            rhsTest = that.getTest();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"test\", lhsTest), LocatorUtils.property(thatLocator, \"test\", rhsTest), lhsTest, rhsTest)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsRequirePayment;\n            lhsRequirePayment = this.getRequirePayment();\n            Boolean rhsRequirePayment;\n            rhsRequirePayment = that.getRequirePayment();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"requirePayment\", lhsRequirePayment), LocatorUtils.property(thatLocator, \"requirePayment\", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsWaitlist;\n            lhsWaitlist = this.getWaitlist();\n            Boolean rhsWaitlist;\n            rhsWaitlist = that.getWaitlist();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"waitlist\", lhsWaitlist), LocatorUtils.property(thatLocator, \"waitlist\", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsSendEmail;\n            lhsSendEmail = this.getSendEmail();\n            Boolean rhsSendEmail;\n            rhsSendEmail = that.getSendEmail();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"sendEmail\", lhsSendEmail), LocatorUtils.property(thatLocator, \"sendEmail\", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public boolean equals(Object object) {\n        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;\n        return equals(null, null, object, strategy);\n    }\n    public String toString() {\n        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;\n        final StringBuilder buffer = new StringBuilder();\n        append(null, buffer, strategy);\n        return buffer.toString();\n    }\n    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        strategy.appendStart(locator, this, buffer);\n        appendFields(locator, buffer, strategy);\n        strategy.appendEnd(locator, this, buffer);\n        return buffer;\n    }\n    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        super.appendFields(locator, buffer, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            strategy.appendField(locator, this, \"clientIDs\", buffer, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            strategy.appendField(locator, this, \"classIDs\", buffer, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            strategy.appendField(locator, this, \"test\", buffer, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            strategy.appendField(locator, this, \"requirePayment\", buffer, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            strategy.appendField(locator, this, \"waitlist\", buffer, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            strategy.appendField(locator, this, \"sendEmail\", buffer, theSendEmail);\n        }\n        return buffer;\n    }\n"]], "pred": {"ppl": 1.1181129217147827, "ppl_lower": 1.297312617301941, "ppl/lowercase_ppl": -2.3315064027600467, "ppl/zlib": 7.147399036819395e-05, "Min_5.0% Prob": 2.218167945158248, "Min_10.0% Prob": 1.1186143438258738, "Min_20.0% Prob": 0.5598037595560776, "Min_30.0% Prob": 0.3732283396315134, "Min_40.0% Prob": 0.27924070002355866, "Min_50.0% Prob": 0.223502774522881, "Min_60.0% Prob": 0.18631336991924857}}
{"hexsha": "8a9bfb3171c29a5cac43a722a02e924726776612", "ext": "java", "lang": "Java", "content": "@Getter\n@Setter\npublic class NpcShop {\n    private int shopId;\n    private int selectNpcItemId;\n    private int npcTemplateId;\n    private int starCoin;\n    private int shopVerNo;\n    private List<NpcShopItem> items = new ArrayList<>();\n\n    public List<NpcShopItem> getItems() {\n        return items;\n    }\n\n    public void setItems(List<NpcShopItem> items) {\n        this.items = items;\n    }\n\n    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {\n        out.writeZeroBytes(20);\n        out.writeInt(DateUtil.getTime());\n        out.writeBool(false);\n        out.writeShort(items.size() + repurchaseItems.size());\n        items.forEach(npcShopItem -> npcShopItem.encode(out));\n        ListIterator<NpcShopItem> itemListIterator;\n        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {\n            itemListIterator.next();\n        }\n        while (itemListIterator.hasPrevious()) {\n            NpcShopItem shopItem = itemListIterator.previous();\n            shopItem.encode(out);\n        }\n    }\n\n    public NpcShopItem getItemByIndex(int idx) {\n        NpcShopItem item = null;\n        if (idx >= 0 && idx < getItems().size()) {\n            item = getItems().get(idx);\n        }\n        return item;\n    }\n\n}", "class_id": 0, "repo": "Heasn/ms", "file": "src/main/java/im/cave/ms/client/field/obj/npc/shop/NpcShop.java", "last_update_at": "2021-12-23T02:26:11+00:00", "question_id": "8a9bfb3171c29a5cac43a722a02e924726776612", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\n@Setter\npublic class NpcShop {\n    private int shopId;\n    private int selectNpcItemId;\n    private int npcTemplateId;\n    private int starCoin;\n    private int shopVerNo;\n    private List<NpcShopItem> items = new ArrayList<>();\n    public List<NpcShopItem> getItems() {\n        return items;\n    }\n    public void setItems(List<NpcShopItem> items) {\n        this.items = items;\n    }\n    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {\n        out.writeZeroBytes(20);\n        out.writeInt(DateUtil.getTime());\n        out.writeBool(false);\n        out.writeShort(items.size() + repurchaseItems.size());\n        items.forEach(npcShopItem -> npcShopItem.encode(out));\n        ListIterator<NpcShopItem> itemListIterator;\n        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {\n            itemListIterator.next();\n        }\n        while (itemListIterator.hasPrevious()) {\n            NpcShopItem shopItem = itemListIterator.previous();\n            shopItem.encode(out);\n        }\n    }\n    public NpcShopItem getItemByIndex(int idx) {\n        NpcShopItem item = null;\n        if (idx >= 0 && idx < getItems().size()) {\n            item = getItems().get(idx);\n        }\n        return item;\n    }\n"]], "pred": {"ppl": 2.065927028656006, "ppl_lower": 2.640390396118164, "ppl/lowercase_ppl": -1.3381405976225862, "ppl/zlib": 0.0015981917400115812, "Min_5.0% Prob": 7.542197327864797, "Min_10.0% Prob": 5.4607947625611954, "Min_20.0% Prob": 3.3767191682543074, "Min_30.0% Prob": 2.363094818489305, "Min_40.0% Prob": 1.799179938147145, "Min_50.0% Prob": 1.4482322808009447, "Min_60.0% Prob": 1.2097098154651378}}
{"hexsha": "13ff8592e8c99706938dc8f4175004a0e584dad8", "ext": "java", "lang": "Java", "content": "@Controller\npublic class IndexEditController\n\t{\n\t/**\n\t * Helper class used as form backing object\n\t */\n\tpublic static final class FormBackingObject\n\t\t{\n\t\tprivate String catalog;\n\t\tprivate String schema;\n\t\tprivate String object;\n\t\tprivate String name;\n\t\tprivate boolean unique;\n\t\tprivate final Map<Integer, String> columns;\n\t\t\n\t\t/**\n\t\t * Constructor\n\t\t */\n\t\tpublic FormBackingObject()\n\t\t\t{\n\t\t\tthis.columns = new TreeMap<Integer, String>();\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * Get the column names\n\t\t * @return column names\n\t\t */\n\t\tpublic List<String> getColumnNames()\n\t\t\t{\n\t\t\tfinal List<String> ret = new ArrayList<String>(columns.size());\n\t\t\t\n\t\t\tfor (int i = 0; ; i++)\n\t\t\t\t{\n\t\t\t\tfinal String s = columns.get(i);\n\t\t\t\tif (StringUtils.empty(s))\n\t\t\t\t\tbreak;\n\t\t\t\tret.add(s);\n\t\t\t\t}\n\t\t\t\n\t\t\treturn (ret);\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the catalog\n\t\t */\n\t\tpublic String getCatalog()\n\t\t\t{\n\t\t\treturn catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param catalog the catalog to set\n\t\t */\n\t\tpublic void setCatalog(String catalog)\n\t\t\t{\n\t\t\tthis.catalog = catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the schema\n\t\t */\n\t\tpublic String getSchema()\n\t\t\t{\n\t\t\treturn schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param schema the schema to set\n\t\t */\n\t\tpublic void setSchema(String schema)\n\t\t\t{\n\t\t\tthis.schema = schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the object\n\t\t */\n\t\tpublic String getObject()\n\t\t\t{\n\t\t\treturn object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param object the object to set\n\t\t */\n\t\tpublic void setObject(String object)\n\t\t\t{\n\t\t\tthis.object = object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the name\n\t\t */\n\t\tpublic String getName()\n\t\t\t{\n\t\t\treturn name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param name the name to set\n\t\t */\n\t\tpublic void setName(String name)\n\t\t\t{\n\t\t\tthis.name = name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the unique\n\t\t */\n\t\tpublic boolean isUnique()\n\t\t\t{\n\t\t\treturn unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param unique the unique to set\n\t\t */\n\t\tpublic void setUnique(boolean unique)\n\t\t\t{\n\t\t\tthis.unique = unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the columns\n\t\t */\n\t\tpublic Map<Integer, String> getColumns()\n\t\t\t{\n\t\t\treturn columns;\n\t\t\t}\n\t\t}\n\t\n\tprivate final MetadataService metadataService;\n\tprivate final QuerySettingsManager querySettingsManager;\n\tprivate final QueryPerformerService runner;\n\tprivate final QueryGeneratorService queryGeneratorService;\n\tprivate final ConnectionSettings connectionSettings;\n\tprivate final FrontendHelperService frontendHelperService;\n\t\n\t/**\n\t * Constructor\n\t * @param metadataService MetadataService\n\t * @param querySettingsManager QuerySettingsManager\n\t * @param runner QueryPerformerService\n\t * @param queryGeneratorService QueryGeneratorService\n\t * @param connectionSettings ConnectionSettings\n\t * @param frontendHelperService FrontendHelperService\n\t */\n\t@Autowired\n\tpublic IndexEditController(MetadataService metadataService,\n\t\t\tQuerySettingsManager querySettingsManager, QueryPerformerService runner,\n\t\t\tQueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings,\n\t\t\tFrontendHelperService frontendHelperService)\n\t\t{\n\t\tthis.metadataService = metadataService;\n\t\tthis.querySettingsManager = querySettingsManager;\n\t\tthis.runner = runner;\n\t\tthis.queryGeneratorService = queryGeneratorService;\n\t\tthis.connectionSettings = connectionSettings;\n\t\tthis.frontendHelperService = frontendHelperService;\n\t\t}\n\t\n\t/**\n\t * Get the FormBackingObject\n\t * @param obj DB object name\n\t * @return FormBackingObject\n\t */\n\t@ModelAttribute(\"model\")\n\tpublic FormBackingObject getFormBackingObject(@RequestParam(value = \"q\", required = false) String obj)\n\t\t{\n\t\tfinal FormBackingObject fbo = new FormBackingObject();\n\t\t// Hack to recognize object name in \"q\" as well as \"object\" parameter\n\t\tfbo.setObject(obj);\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tfbo.getColumns().put(i, \"\");\n\t\treturn (fbo);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfbo.setUnique(id.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : id.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfbo.setUnique(pk.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : pk.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\tprivate SQLDialect getSQLDialect()\n\t\t{\n\t\treturn (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));\n\t\t}\n\t}", "class_id": 0, "repo": "tweerlei/dbgrazer", "file": "web/plugins/jdbc-web/src/main/java/de/tweerlei/dbgrazer/web/controller/jdbc/IndexEditController.java", "last_update_at": "2021-09-26T03:05:18+00:00", "question_id": "13ff8592e8c99706938dc8f4175004a0e584dad8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\npublic class IndexEditController\n\t{\n\t/**\n\t * Helper class used as form backing object\n\t */\n\tpublic static final class FormBackingObject\n\t\t{\n\t\tprivate String catalog;\n\t\tprivate String schema;\n\t\tprivate String object;\n\t\tprivate String name;\n\t\tprivate boolean unique;\n\t\tprivate final Map<Integer, String> columns;\n\t\t\n\t\t/**\n\t\t * Constructor\n\t\t */\n\t\tpublic FormBackingObject()\n\t\t\t{\n\t\t\tthis.columns = new TreeMap<Integer, String>();\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * Get the column names\n\t\t * @return column names\n\t\t */\n\t\tpublic List<String> getColumnNames()\n\t\t\t{\n\t\t\tfinal List<String> ret = new ArrayList<String>(columns.size());\n\t\t\t\n\t\t\tfor (int i = 0; ; i++)\n\t\t\t\t{\n\t\t\t\tfinal String s = columns.get(i);\n\t\t\t\tif (StringUtils.empty(s))\n\t\t\t\t\tbreak;\n\t\t\t\tret.add(s);\n\t\t\t\t}\n\t\t\t\n\t\t\treturn (ret);\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the catalog\n\t\t */\n\t\tpublic String getCatalog()\n\t\t\t{\n\t\t\treturn catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param catalog the catalog to set\n\t\t */\n\t\tpublic void setCatalog(String catalog)\n\t\t\t{\n\t\t\tthis.catalog = catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the schema\n\t\t */\n\t\tpublic String getSchema()\n\t\t\t{\n\t\t\treturn schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param schema the schema to set\n\t\t */\n\t\tpublic void setSchema(String schema)\n\t\t\t{\n\t\t\tthis.schema = schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the object\n\t\t */\n\t\tpublic String getObject()\n\t\t\t{\n\t\t\treturn object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param object the object to set\n\t\t */\n\t\tpublic void setObject(String object)\n\t\t\t{\n\t\t\tthis.object = object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the name\n\t\t */\n\t\tpublic String getName()\n\t\t\t{\n\t\t\treturn name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param name the name to set\n\t\t */\n\t\tpublic void setName(String name)\n\t\t\t{\n\t\t\tthis.name = name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the unique\n\t\t */\n\t\tpublic boolean isUnique()\n\t\t\t{\n\t\t\treturn unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param unique the unique to set\n\t\t */\n\t\tpublic void setUnique(boolean unique)\n\t\t\t{\n\t\t\tthis.unique = unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the columns\n\t\t */\n\t\tpublic Map<Integer, String> getColumns()\n\t\t\t{\n\t\t\treturn columns;\n\t\t\t}\n\t\t}\n\t\n\tprivate final MetadataService metadataService;\n\tprivate final QuerySettingsManager querySettingsManager;\n\tprivate final QueryPerformerService runner;\n\tprivate final QueryGeneratorService queryGeneratorService;\n\tprivate final ConnectionSettings connectionSettings;\n\tprivate final FrontendHelperService frontendHelperService;\n\t\n\t/**\n\t * Constructor\n\t * @param metadataService MetadataService\n\t * @param querySettingsManager QuerySettingsManager\n\t * @param runner QueryPerformerService\n\t * @param queryGeneratorService QueryGeneratorService\n\t * @param connectionSettings ConnectionSettings\n\t * @param frontendHelperService FrontendHelperService\n\t */\n\t@Autowired\n\tpublic IndexEditController(MetadataService metadataService,\n\t\t\tQuerySettingsManager querySettingsManager, QueryPerformerService runner,\n\t\t\tQueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings,\n\t\t\tFrontendHelperService frontendHelperService)\n\t\t{\n\t\tthis.metadataService = metadataService;\n\t\tthis.querySettingsManager = querySettingsManager;\n\t\tthis.runner = runner;\n\t\tthis.queryGeneratorService = queryGeneratorService;\n\t\tthis.connectionSettings = connectionSettings;\n\t\tthis.frontendHelperService = frontendHelperService;\n\t\t}\n\t\n\t/**\n\t * Get the FormBackingObject\n\t * @param obj DB object name\n\t * @return FormBackingObject\n\t */\n\t@ModelAttribute(\"model\")\n\tpublic FormBackingObject getFormBackingObject(@RequestParam(value = \"q\", required = false) String obj)\n\t\t{\n\t\tfinal FormBackingObject fbo = new FormBackingObject();\n\t\t// Hack to recognize object name in \"q\" as well as \"object\" parameter\n\t\tfbo.setObject(obj);\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tfbo.getColumns().put(i, \"\");\n\t\treturn (fbo);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfbo.setUnique(id.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : id.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfbo.setUnique(pk.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : pk.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\tprivate SQLDialect getSQLDialect()\n\t\t{\n\t\treturn (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));\n\t\t}\n"]], "pred": {"ppl": 1.3480515480041504, "ppl_lower": 1.452474594116211, "ppl/lowercase_ppl": -1.2498104980547917, "ppl/zlib": 0.00016722298550847335, "Min_5.0% Prob": 4.729393893597173, "Min_10.0% Prob": 2.8348343781396452, "Min_20.0% Prob": 1.4871554185325901, "Min_30.0% Prob": 0.9969365557479167, "Min_40.0% Prob": 0.746693204585998, "Min_50.0% Prob": 0.5978248745933519, "Min_60.0% Prob": 0.49839824988254816}}
{"hexsha": "3e73974b19bd63eef0024f08c1d9d9f3549ef0b5", "ext": "java", "lang": "Java", "content": "public class RestClientLoadBalancerTest {\n\n  public static ResourceBundle messageBundle = ResourceBundle.getBundle(\"Messages\");\n  public static MessageUtils messageUtils = new MessageUtils(messageBundle);\n  public static HttpClient httpClient = HttpClient.newHttpClient();\n  public static MockWebServer mockServer;\n\n  @BeforeEach\n  void setUp() throws IOException {\n    mockServer = new MockWebServer();\n    mockServer.start();\n  }\n\n  @Test\n  public void happyMakeRequest() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    Integer statusCode = 200;\n    String body = \"someBody\";\n    mockServer.enqueue(new MockResponse()\n        .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n        .setBody(body)\n        .setResponseCode(statusCode));\n\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(body));\n  }\n\n  @Test\n  public void happyMakeRequestAfterRetries() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    Integer statusCode = 400;\n    String body = \"badBody\";\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n\n    statusCode = 200;\n    body = \"goodBody\";\n\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(\"goodBody0\"));\n\n    System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());\n  }\n\n  @Test\n  public void failedMakeRequestNoValidServer() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    String urlServer1 = \"https://incorrectServer1:100\";\n    String urlServer2 = \"https://incorrectServer2:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n\n  @Test\n  public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    Integer statusCode = 400;\n    String body = \"someBody\";\n\n    // put at least as many requests into the queue as the retry limit\n    for (int i = 0; i < 10; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n\n  @AfterEach\n  void tearDown() throws Exception {\n    mockServer.shutdown();\n  }\n}", "class_id": 0, "repo": "IBM/uni-resolver-driver-did-hpass", "file": "src/test/java/uniresolver/driver/did/hpass/utils/RestClientLoadBalancerTest.java", "last_update_at": "2021-12-13T15:56:55+00:00", "question_id": "3e73974b19bd63eef0024f08c1d9d9f3549ef0b5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RestClientLoadBalancerTest {\n  public static ResourceBundle messageBundle = ResourceBundle.getBundle(\"Messages\");\n  public static MessageUtils messageUtils = new MessageUtils(messageBundle);\n  public static HttpClient httpClient = HttpClient.newHttpClient();\n  public static MockWebServer mockServer;\n  @BeforeEach\n  void setUp() throws IOException {\n    mockServer = new MockWebServer();\n    mockServer.start();\n  }\n  @Test\n  public void happyMakeRequest() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    Integer statusCode = 200;\n    String body = \"someBody\";\n    mockServer.enqueue(new MockResponse()\n        .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n        .setBody(body)\n        .setResponseCode(statusCode));\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(body));\n  }\n  @Test\n  public void happyMakeRequestAfterRetries() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    Integer statusCode = 400;\n    String body = \"badBody\";\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n    statusCode = 200;\n    body = \"goodBody\";\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(\"goodBody0\"));\n    System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());\n  }\n  @Test\n  public void failedMakeRequestNoValidServer() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    String urlServer1 = \"https://incorrectServer1:100\";\n    String urlServer2 = \"https://incorrectServer2:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n  @Test\n  public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    Integer statusCode = 400;\n    String body = \"someBody\";\n    // put at least as many requests into the queue as the retry limit\n    for (int i = 0; i < 10; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n  @AfterEach\n  void tearDown() throws Exception {\n    mockServer.shutdown();\n  }\n"]], "pred": {"ppl": 1.6937389373779297, "ppl_lower": 1.8242875337600708, "ppl/lowercase_ppl": -1.1409102728333187, "ppl/zlib": 0.00047903497653378123, "Min_5.0% Prob": 5.913828840442732, "Min_10.0% Prob": 4.122561616056106, "Min_20.0% Prob": 2.5080014283166214, "Min_30.0% Prob": 1.7401930813014117, "Min_40.0% Prob": 1.313439126247153, "Min_50.0% Prob": 1.0538710047574733, "Min_60.0% Prob": 0.8790955482573791}}
{"hexsha": "720da52387d7399deb3c25aef1d5a296b400d45c", "ext": "java", "lang": "Java", "content": "public class BulkOperation extends ExtensibleObject {\n\n    /**\n     *  Status ACTIVE: when bulk operation is created.\n     */\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n\n    /**\n     *  Status IN_PROGRESS: when bulk operation is performing on all devices.\n     */\n    public static final String STATUS_IN_PROGRESS = \"IN_PROGRESS\";\n\n    /**\n     * Status COMPLETED: when the operation was performed on all devices.\n     */\n    public static final String STATUS_COMPLETED = \"COMPLETED\";\n\n    /**\n     * Status DELETED: when already created operation was cancelled by deleting the bulk operation\n     */\n    public static final String STATUS_DELETED = \"DELETED\";\n\n    /**\n     * Constructor to create a bulk operation.\n     */\n    public BulkOperation() {\n        super();\n    }\n\n    /**\n     * Internal constructor to create a bulk operation object.\n     *\n     * @param extensibleObject existing base class object.\n     */\n    BulkOperation(ExtensibleObject extensibleObject) {\n        super(extensibleObject);\n    }\n\n\n    /**\n     * Set the unique identifier of the bulk operation.\n     * Just used internally.\n     *\n     * @param id the new identifier created by storing the entity.\n     */\n    void setId(String id) {\n        anyObject.put(\"id\", id);\n    }\n\n    /**\n     * Get the unique identifier for the bulk operation.\n     *\n     * @return String with the unique identifier of the bulk operation or null if not\n     * available.\n     */\n    public String getId() {\n        Object id = anyObject.get(\"id\");\n        if (id == null) {\n            return null;\n        }\n        return id.toString();\n    }\n\n    /**\n     * Set the groupId of the target group on which the bulk operation should be performed.\n     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'\n     *\n     * @param groupId the unique identifier of the target group.\n     */\n    public void setGroupId(String groupId) {\n        anyObject.put(\"groupId\", groupId);\n    }\n\n    /**\n     * Get the groupId of the target group of the bulk operation.\n     *\n     * @return String with the unique identifier of the target group or null if not\n     * available.\n     */\n    public String getGroupId() {\n        return (String) anyObject.get(\"groupId\");\n    }\n\n    /**\n     * Set the bulk operation id to reschedule this operation on devices where it failed.\n     *\n     * @param failedBulkOperationId the unique identifier of the bulk operation.\n     */\n    public void setFailedBulkOperationId(String failedBulkOperationId) {\n        anyObject.put(\"failedBulkOperationId\", failedBulkOperationId);\n    }\n\n    /**\n     * Get the bulk operation id from which failed operation should be rescheduled.\n     *\n     * @return String with the unique identifier of the failed bulk operation id\n     * or null if not available.\n     */\n    public String getFailedBulkOperationId() {\n        return (String) anyObject.get(\"failedBulkOperationId\");\n    }\n\n    /**\n     * Get the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @return a String with the status\n     */\n    public String getStatus() {\n        return (String) anyObject.get(\"status\");\n    }\n\n    /**\n     * Set the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @param status String which represents the status of the bulk operation.\n     */\n    public void setStatus(String status) {\n        anyObject.put(\"status\", status);\n    }\n\n    /**\n     * Set the ramp up time, specifying the delay between every operation.\n     *\n     * @param creationRamp number in seconds.\n     */\n    public void setCreationRamp(Number creationRamp) {\n        anyObject.put(\"creationRamp\", creationRamp);\n    }\n\n    /**\n     * Get the ramp up time, specifying the delay between every operation.\n     *\n     * @return the number in seconds.\n     */\n    public Number getCreationRamp() {\n        return (Number) anyObject.get(\"creationRamp\");\n    }\n\n    /**\n     * Get the time when operation should be started.\n     *\n     * @return Date object representing the timestamp when bulk operation should be performed.\n     */\n    public Date getStartDate() {\n        return (Date) anyObject.get(\"startDate\");\n    }\n\n    /**\n     * Set the schedule time.\n     *\n     * @param startDate Date object with the time when bulk operation should be performed.\n     */\n    public void setStartDate(Date startDate) {\n        anyObject.put(\"startDate\", startDate);\n    }\n\n    /**\n     * Get the operation which will be executed for every device in the target group.\n     *\n     * @return Operation object representing the operation which will be executed for every device in the target group.\n     */\n    public Operation getOperation() {\n        Object operationPrototype = anyObject.get(\"operationPrototype\");\n        // since source value can be set as Operation Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Operation Object\n        if(operationPrototype instanceof Operation) {\n            return (Operation)operationPrototype;\n        }\n        return new Operation((ExtensibleObject) operationPrototype);\n    }\n\n    /**\n     * Set the operation which should be executed for every device in the target group.\n     *\n     * @param operation Operation object representing the operation which need to be executed for every device in the target group.\n     */\n    public void setOperation(Operation operation) {\n        anyObject.put(\"operationPrototype\", operation);\n    }\n\n    /**\n     * Get the progress of the bulk operation.\n     *\n     * @return Progress object containing the number of processed bulk operations.\n     */\n    public Progress getProgress() {\n        Object progress = anyObject.get(\"progress\");\n        // since source value can be set as Progress Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Progress Object\n        if(progress instanceof Progress) {\n            return (Progress)progress;\n        }\n        return new Progress((ExtensibleObject) progress);\n    }\n\n    /**\n     * Set the progress of the bulk operation.\n     *\n     * @param progress Progress object containing the number of processed bulk operations.\n     */\n    public void setProgress(Progress progress) {\n        anyObject.put(\"progress\", progress);\n    }\n\n}", "class_id": 0, "repo": "Matthimatiker/cot-java-rest-sdk", "file": "src/main/java/com/telekom/m2m/cot/restsdk/devicecontrol/BulkOperation.java", "last_update_at": "2021-04-30T23:56:52+00:00", "question_id": "720da52387d7399deb3c25aef1d5a296b400d45c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BulkOperation extends ExtensibleObject {\n    /**\n     *  Status ACTIVE: when bulk operation is created.\n     */\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n    /**\n     *  Status IN_PROGRESS: when bulk operation is performing on all devices.\n     */\n    public static final String STATUS_IN_PROGRESS = \"IN_PROGRESS\";\n    /**\n     * Status COMPLETED: when the operation was performed on all devices.\n     */\n    public static final String STATUS_COMPLETED = \"COMPLETED\";\n    /**\n     * Status DELETED: when already created operation was cancelled by deleting the bulk operation\n     */\n    public static final String STATUS_DELETED = \"DELETED\";\n    /**\n     * Constructor to create a bulk operation.\n     */\n    public BulkOperation() {\n        super();\n    }\n    /**\n     * Internal constructor to create a bulk operation object.\n     *\n     * @param extensibleObject existing base class object.\n     */\n    BulkOperation(ExtensibleObject extensibleObject) {\n        super(extensibleObject);\n    }\n    /**\n     * Set the unique identifier of the bulk operation.\n     * Just used internally.\n     *\n     * @param id the new identifier created by storing the entity.\n     */\n    void setId(String id) {\n        anyObject.put(\"id\", id);\n    }\n    /**\n     * Get the unique identifier for the bulk operation.\n     *\n     * @return String with the unique identifier of the bulk operation or null if not\n     * available.\n     */\n    public String getId() {\n        Object id = anyObject.get(\"id\");\n        if (id == null) {\n            return null;\n        }\n        return id.toString();\n    }\n    /**\n     * Set the groupId of the target group on which the bulk operation should be performed.\n     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'\n     *\n     * @param groupId the unique identifier of the target group.\n     */\n    public void setGroupId(String groupId) {\n        anyObject.put(\"groupId\", groupId);\n    }\n    /**\n     * Get the groupId of the target group of the bulk operation.\n     *\n     * @return String with the unique identifier of the target group or null if not\n     * available.\n     */\n    public String getGroupId() {\n        return (String) anyObject.get(\"groupId\");\n    }\n    /**\n     * Set the bulk operation id to reschedule this operation on devices where it failed.\n     *\n     * @param failedBulkOperationId the unique identifier of the bulk operation.\n     */\n    public void setFailedBulkOperationId(String failedBulkOperationId) {\n        anyObject.put(\"failedBulkOperationId\", failedBulkOperationId);\n    }\n    /**\n     * Get the bulk operation id from which failed operation should be rescheduled.\n     *\n     * @return String with the unique identifier of the failed bulk operation id\n     * or null if not available.\n     */\n    public String getFailedBulkOperationId() {\n        return (String) anyObject.get(\"failedBulkOperationId\");\n    }\n    /**\n     * Get the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @return a String with the status\n     */\n    public String getStatus() {\n        return (String) anyObject.get(\"status\");\n    }\n    /**\n     * Set the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @param status String which represents the status of the bulk operation.\n     */\n    public void setStatus(String status) {\n        anyObject.put(\"status\", status);\n    }\n    /**\n     * Set the ramp up time, specifying the delay between every operation.\n     *\n     * @param creationRamp number in seconds.\n     */\n    public void setCreationRamp(Number creationRamp) {\n        anyObject.put(\"creationRamp\", creationRamp);\n    }\n    /**\n     * Get the ramp up time, specifying the delay between every operation.\n     *\n     * @return the number in seconds.\n     */\n    public Number getCreationRamp() {\n        return (Number) anyObject.get(\"creationRamp\");\n    }\n    /**\n     * Get the time when operation should be started.\n     *\n     * @return Date object representing the timestamp when bulk operation should be performed.\n     */\n    public Date getStartDate() {\n        return (Date) anyObject.get(\"startDate\");\n    }\n    /**\n     * Set the schedule time.\n     *\n     * @param startDate Date object with the time when bulk operation should be performed.\n     */\n    public void setStartDate(Date startDate) {\n        anyObject.put(\"startDate\", startDate);\n    }\n    /**\n     * Get the operation which will be executed for every device in the target group.\n     *\n     * @return Operation object representing the operation which will be executed for every device in the target group.\n     */\n    public Operation getOperation() {\n        Object operationPrototype = anyObject.get(\"operationPrototype\");\n        // since source value can be set as Operation Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Operation Object\n        if(operationPrototype instanceof Operation) {\n            return (Operation)operationPrototype;\n        }\n        return new Operation((ExtensibleObject) operationPrototype);\n    }\n    /**\n     * Set the operation which should be executed for every device in the target group.\n     *\n     * @param operation Operation object representing the operation which need to be executed for every device in the target group.\n     */\n    public void setOperation(Operation operation) {\n        anyObject.put(\"operationPrototype\", operation);\n    }\n    /**\n     * Get the progress of the bulk operation.\n     *\n     * @return Progress object containing the number of processed bulk operations.\n     */\n    public Progress getProgress() {\n        Object progress = anyObject.get(\"progress\");\n        // since source value can be set as Progress Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Progress Object\n        if(progress instanceof Progress) {\n            return (Progress)progress;\n        }\n        return new Progress((ExtensibleObject) progress);\n    }\n    /**\n     * Set the progress of the bulk operation.\n     *\n     * @param progress Progress object containing the number of processed bulk operations.\n     */\n    public void setProgress(Progress progress) {\n        anyObject.put(\"progress\", progress);\n    }\n"]], "pred": {"ppl": 1.8907740116119385, "ppl_lower": 2.0359249114990234, "ppl/lowercase_ppl": -1.1161154412508791, "ppl/zlib": 0.0004448228178704287, "Min_5.0% Prob": 6.559155314576392, "Min_10.0% Prob": 4.881930741609311, "Min_20.0% Prob": 3.0114586812024022, "Min_30.0% Prob": 2.0956862071662945, "Min_40.0% Prob": 1.5858418723718608, "Min_50.0% Prob": 1.273402610857499, "Min_60.0% Prob": 1.0625578350498421}}
{"hexsha": "04baabdf7c25ae7771d5baa86ba14663503d9f40", "ext": "java", "lang": "Java", "content": "@ConstantFieldsFirstExcept({}) @ConstantFieldsSecondExcept({})\npublic class StratosphereSqlCrossOperator extends CrossFunction {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate Filter filter;\n\tpublic StratosphereSqlCrossOperator(Filter f) {\n\t\tthis.filter = f;\n\t}\n\n\t@Override\n\tpublic void open(Configuration parameters) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.open(parameters);\n\t\tfilter.prepareEvaluation();\n\t}\n\t@Override\n\tpublic void cross(Record record1, Record record2, Collector<Record> out)\n\t\t\tthrows Exception {\n\t\tif(filter.evaluateTwo(record1, record2)) {\n\t\t\tSystem.err.println(\"Cross got rec1=\"+record1+\" rec2=\"+record2);\n\t\t\trecord1.concatenate(record2);\n\t\t\tSystem.err.println(\"Cross is outputting \"+record1);\n\t\t\tout.collect(record1);\n\t\t\t\n\t\t}\n\t}\n\t\n}", "class_id": 0, "repo": "rmetzger/stratosphere-sql", "file": "src/main/java/eu/stratosphere/sql/relOpt/join/StratosphereSqlCrossOperator.java", "last_update_at": "2021-09-08T11:01:56+00:00", "question_id": "04baabdf7c25ae7771d5baa86ba14663503d9f40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ConstantFieldsFirstExcept({}) @ConstantFieldsSecondExcept({})\npublic class StratosphereSqlCrossOperator extends CrossFunction {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate Filter filter;\n\tpublic StratosphereSqlCrossOperator(Filter f) {\n\t\tthis.filter = f;\n\t}\n\t@Override\n\tpublic void open(Configuration parameters) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.open(parameters);\n\t\tfilter.prepareEvaluation();\n\t}\n\t@Override\n\tpublic void cross(Record record1, Record record2, Collector<Record> out)\n\t\t\tthrows Exception {\n\t\tif(filter.evaluateTwo(record1, record2)) {\n\t\t\tSystem.err.println(\"Cross got rec1=\"+record1+\" rec2=\"+record2);\n\t\t\trecord1.concatenate(record2);\n\t\t\tSystem.err.println(\"Cross is outputting \"+record1);\n\t\t\tout.collect(record1);\n\t\t\t\n\t\t}\n\t}\n\t\n"]], "pred": {"ppl": 2.769153594970703, "ppl_lower": 4.101275444030762, "ppl/lowercase_ppl": -1.3856064925425462, "ppl/zlib": 0.0024903220345316337, "Min_5.0% Prob": 8.360846959627592, "Min_10.0% Prob": 6.719023007612962, "Min_20.0% Prob": 4.5168046411478295, "Min_30.0% Prob": 3.2744230069220066, "Min_40.0% Prob": 2.5200885042687444, "Min_50.0% Prob": 2.027886963379917, "Min_60.0% Prob": 1.7023495109984652}}
{"hexsha": "f72f58de555633dae38ae5ca07680378374dc88b", "ext": "java", "lang": "Java", "content": "public class StickyKey {\n\tpublic static final StickyKey DEFAULT = new StickyKey(0, 0);\n\n\tpublic final long clusterId;\n\tpublic final long stickyId;\n\n\tprivate StickyKey(final long clusterId, final long stickyId) {\n\t\tthis.clusterId = (clusterId <= 0 ? 0 : clusterId);\n\t\tthis.stickyId = (stickyId <= 0 ? 0 : stickyId);\n\t}\n\n\tpublic static StickyKey valueOf(final String clusterName, final String stickyName) {\n\t\tfinal long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));\n\t\tfinal long stickyId = IOHelper.longIdFromString(stickyName);\n\t\tif (clusterName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped clusterName=\" + clusterName + \" clusterId=\" + clusterId);\n\t\t}\n\t\tif (stickyName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped stickyName=\" + stickyName + \" stickyId=\" + stickyId);\n\t\t}\n\t\treturn valueOf(clusterId, stickyId);\n\t}\n\n\tpublic static StickyKey valueOf(final long clusterId, final long stickyId) {\n\t\treturn new StickyKey(clusterId, stickyId);\n\t}\n\n\t@Override\n\tpublic boolean equals(final Object obj) {\n\t\tif (obj instanceof StickyKey) {\n\t\t\tfinal StickyKey o = (StickyKey) obj;\n\t\t\treturn ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString() + \"[clusterId=\" + clusterId + \" stickyId=\" + stickyId + \"]\";\n\t}\n}", "class_id": 0, "repo": "ggrandes/jrinetd", "file": "src/main/java/org/javastack/jrinetd/StickyKey.java", "last_update_at": "2021-11-10T10:37:44+00:00", "question_id": "f72f58de555633dae38ae5ca07680378374dc88b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StickyKey {\n\tpublic static final StickyKey DEFAULT = new StickyKey(0, 0);\n\tpublic final long clusterId;\n\tpublic final long stickyId;\n\tprivate StickyKey(final long clusterId, final long stickyId) {\n\t\tthis.clusterId = (clusterId <= 0 ? 0 : clusterId);\n\t\tthis.stickyId = (stickyId <= 0 ? 0 : stickyId);\n\t}\n\tpublic static StickyKey valueOf(final String clusterName, final String stickyName) {\n\t\tfinal long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));\n\t\tfinal long stickyId = IOHelper.longIdFromString(stickyName);\n\t\tif (clusterName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped clusterName=\" + clusterName + \" clusterId=\" + clusterId);\n\t\t}\n\t\tif (stickyName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped stickyName=\" + stickyName + \" stickyId=\" + stickyId);\n\t\t}\n\t\treturn valueOf(clusterId, stickyId);\n\t}\n\tpublic static StickyKey valueOf(final long clusterId, final long stickyId) {\n\t\treturn new StickyKey(clusterId, stickyId);\n\t}\n\t@Override\n\tpublic boolean equals(final Object obj) {\n\t\tif (obj instanceof StickyKey) {\n\t\t\tfinal StickyKey o = (StickyKey) obj;\n\t\t\treturn ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString() + \"[clusterId=\" + clusterId + \" stickyId=\" + stickyId + \"]\";\n\t}\n"]], "pred": {"ppl": 1.473032832145691, "ppl_lower": 1.6008143424987793, "ppl/lowercase_ppl": -1.2147792557665311, "ppl/zlib": 0.0007888460825594717, "Min_5.0% Prob": 4.6560965290776, "Min_10.0% Prob": 3.20542875263426, "Min_20.0% Prob": 1.8850586127351832, "Min_30.0% Prob": 1.2863426933088054, "Min_40.0% Prob": 0.9660915084835571, "Min_50.0% Prob": 0.775090297759679, "Min_60.0% Prob": 0.6467844009005393}}
{"hexsha": "2e39263ceb6cb884efccdb282a6247b85892ec0e", "ext": "java", "lang": "Java", "content": "public class ConfigTest {\n    Connection conn;\n    Session session;\n\n    public static final String uri = \"table:test_config06\";\n    public static final String key = \"keyABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    public static final String value = \"valueABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    public void session_config(String config) {\n        Exception e = null;\n\n        try {\n            session.create(uri, config);\n        }\n        catch (WiredTigerException wte) {\n            e = wte;\n        }\n\n        Assert.assertTrue(e != null &&\n                          e.toString().indexOf(\"Invalid argument\") >= 0);\n    }\n\n    // Edge cases for key/value formats.\n    @Test\n    public void test_session_config()\n    throws WiredTigerException {\n        setup();\n        System.err.println(\"\\n-- expect error output --\");\n        session_config(\"key_format=A,value_format=S\");\n        session_config(\"key_format=S,value_format=A\");\n        session_config(\"key_format=0s,value_format=s\");\n        session_config(\"key_format=s,value_format=0s\");\n        session_config(\"key_format=0t,value_format=4t\");\n        session_config(\"key_format=4t,value_format=0t\");\n        System.err.println(\"-- end expected error output --\");\n        teardown();\n    }\n\n    // Smoke-test the string formats with length specifiers; both formats should\n    // ignore trailing bytes, verify that.\n    public void format_string(String fmt, int len)\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=\" + len + fmt +\n                            \",value_format=\" + len + fmt);\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,len));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,len), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_S_1()\n    throws WiredTigerException {\n        format_string(\"S\", 1);\n    }\n    @Test\n    public void test_format_string_S_4()\n    throws WiredTigerException {\n        format_string(\"S\", 4);\n    }\n    @Test\n    public void test_format_string_S_10()\n    throws WiredTigerException {\n        format_string(\"S\", 10);\n    }\n    @Test\n    public void test_format_string_s_1()\n    throws WiredTigerException {\n        format_string(\"s\", 1);\n    }\n    @Test\n    public void test_format_string_s_4()\n    throws WiredTigerException {\n        format_string(\"s\", 4);\n    }\n    @Test\n    public void test_format_string_s_10()\n    throws WiredTigerException {\n        format_string(\"s\", 10);\n    }\n\n    @Test\n    public void test_format_string_S_default()\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=S,value_format=S\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key);\n        assertEquals(0, cursor.search());\n        assertEquals(value, cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_s_default()\n        throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=s,value_format=s\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,1));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,1), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    public static void main(String[] args) {\n        ConfigTest tester = new ConfigTest();\n        try {\n            tester.test_session_config();\n            tester.test_format_string_S_1();\n            tester.test_format_string_S_4();\n            tester.test_format_string_S_10();\n            tester.test_format_string_s_1();\n            tester.test_format_string_s_4();\n            tester.test_format_string_s_10();\n            tester.test_format_string_S_default();\n            tester.test_format_string_s_default();\n        } catch (WiredTigerException wte) {\n            System.err.println(\"WiredTigerException: \" + wte);\n        }\n    }\n\n    private void setup() {\n        conn = wiredtiger.open(\"WT_HOME\", \"create\");\n        session = conn.open_session(null);\n    }\n\n    private void teardown() {\n        session.close(\"\");\n        conn.close(\"\");\n    }\n\n}", "class_id": 0, "repo": "danx0r/mongo", "file": "src/third_party/wiredtiger/test/java/com/wiredtiger/test/ConfigTest.java", "last_update_at": "2021-03-22T03:15:56+00:00", "question_id": "2e39263ceb6cb884efccdb282a6247b85892ec0e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConfigTest {\n    Connection conn;\n    Session session;\n    public static final String uri = \"table:test_config06\";\n    public static final String key = \"keyABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    public static final String value = \"valueABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    public void session_config(String config) {\n        Exception e = null;\n        try {\n            session.create(uri, config);\n        }\n        catch (WiredTigerException wte) {\n            e = wte;\n        }\n        Assert.assertTrue(e != null &&\n                          e.toString().indexOf(\"Invalid argument\") >= 0);\n    }\n    // Edge cases for key/value formats.\n    @Test\n    public void test_session_config()\n    throws WiredTigerException {\n        setup();\n        System.err.println(\"\\n-- expect error output --\");\n        session_config(\"key_format=A,value_format=S\");\n        session_config(\"key_format=S,value_format=A\");\n        session_config(\"key_format=0s,value_format=s\");\n        session_config(\"key_format=s,value_format=0s\");\n        session_config(\"key_format=0t,value_format=4t\");\n        session_config(\"key_format=4t,value_format=0t\");\n        System.err.println(\"-- end expected error output --\");\n        teardown();\n    }\n    // Smoke-test the string formats with length specifiers; both formats should\n    // ignore trailing bytes, verify that.\n    public void format_string(String fmt, int len)\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=\" + len + fmt +\n                            \",value_format=\" + len + fmt);\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,len));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,len), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n    @Test\n    public void test_format_string_S_1()\n    throws WiredTigerException {\n        format_string(\"S\", 1);\n    }\n    @Test\n    public void test_format_string_S_4()\n    throws WiredTigerException {\n        format_string(\"S\", 4);\n    }\n    @Test\n    public void test_format_string_S_10()\n    throws WiredTigerException {\n        format_string(\"S\", 10);\n    }\n    @Test\n    public void test_format_string_s_1()\n    throws WiredTigerException {\n        format_string(\"s\", 1);\n    }\n    @Test\n    public void test_format_string_s_4()\n    throws WiredTigerException {\n        format_string(\"s\", 4);\n    }\n    @Test\n    public void test_format_string_s_10()\n    throws WiredTigerException {\n        format_string(\"s\", 10);\n    }\n    @Test\n    public void test_format_string_S_default()\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=S,value_format=S\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key);\n        assertEquals(0, cursor.search());\n        assertEquals(value, cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n    @Test\n    public void test_format_string_s_default()\n        throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=s,value_format=s\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,1));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,1), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n    public static void main(String[] args) {\n        ConfigTest tester = new ConfigTest();\n        try {\n            tester.test_session_config();\n            tester.test_format_string_S_1();\n            tester.test_format_string_S_4();\n            tester.test_format_string_S_10();\n            tester.test_format_string_s_1();\n            tester.test_format_string_s_4();\n            tester.test_format_string_s_10();\n            tester.test_format_string_S_default();\n            tester.test_format_string_s_default();\n        } catch (WiredTigerException wte) {\n            System.err.println(\"WiredTigerException: \" + wte);\n        }\n    }\n    private void setup() {\n        conn = wiredtiger.open(\"WT_HOME\", \"create\");\n        session = conn.open_session(null);\n    }\n    private void teardown() {\n        session.close(\"\");\n        conn.close(\"\");\n    }\n"]], "pred": {"ppl": 1.7382960319519043, "ppl_lower": 1.912859559059143, "ppl/lowercase_ppl": -1.1730747113293147, "ppl/zlib": 0.0005723657778727738, "Min_5.0% Prob": 6.241943251852896, "Min_10.0% Prob": 4.424288304413066, "Min_20.0% Prob": 2.6535254832284125, "Min_30.0% Prob": 1.8271399210481083, "Min_40.0% Prob": 1.37846233794115, "Min_50.0% Prob": 1.1058247828630114, "Min_60.0% Prob": 0.9224399354654101}}
{"hexsha": "0e0da15f7cbb858c23517f700b77e09fcb2e8e1f", "ext": "java", "lang": "Java", "content": "@WebServlet(name = \"smarthomeUpdate\", urlPatterns = \"/smarthome/update\")\npublic class SmartHomeUpdateServlet extends HttpServlet {\n  private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);\n  private static MyDataStore database = MyDataStore.getInstance();\n  private final SmartHomeApp actionsApp = new MySmartHomeApp();\n  //private String msg;\n  private static final List<String> UPDATE_DEVICE_PARAMS_KEYS =\n      Arrays.asList(new String[] {\"name\", \"nickname\", \"localDeviceId\", \"errorCode\", \"tfa\"});\n\n  {\n    try {\n      GoogleCredentials credentials =\n          GoogleCredentials.fromStream(getClass().getResourceAsStream(\"/smart-home-key.json\"));\n      actionsApp.setCredentials(credentials);\n    } catch (Exception e) {\n      LOGGER.error(\"couldn't load credentials\");\n    }\n  }\n\n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n    String body = req.getReader().lines().collect(Collectors.joining());\n    LOGGER.info(\"doPost, body = {}\", body);\n    JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();\n    String userId = bodyJson.get(\"userId\").getAsString();\n    String deviceId = bodyJson.get(\"deviceId\").getAsString();\n    JsonObject states = bodyJson.getAsJsonObject(\"states\");\n    Map<String, Object> deviceStates =\n        states != null ? new Gson().fromJson(states, HashMap.class) : null;\n    Map<String, String> deviceParams = new HashMap<>();\n    Set<String> deviceParamsKeys = bodyJson.keySet();\n    deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);\n    for (String k : deviceParamsKeys) {\n      deviceParams.put(k, bodyJson.get(k).getAsString());\n    }\n    try {\n      database.updateDevice(userId, deviceId, deviceStates, deviceParams);\n      if (deviceParams.containsKey(\"localDeviceId\")) {\n        actionsApp.requestSync(userId);\n      }\n      if (states != null) {\n        ReportState.makeRequest(actionsApp, userId, deviceId, states);\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"failed to update device: {}\", e);\n      res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n      res.setContentType(\"text/plain\");\n      res.getWriter().println(\"ERROR\");\n      return;\n    }\n\n    res.setStatus(HttpServletResponse.SC_OK);\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setContentType(\"text/plain\");\n    res.getWriter().println(\"OK\");\n    // --------- Mqtt implementation --------------\n    //String msg = states.get(\"on\").getAsString().equals(\"true\") ? \"on\" : \"off\";\n    /*msg = states.toString();\n    if (states.has(\"thermostatTemperatureSetpoint\")){\n      msg = \"{'thermostatTemperatureSetpoint':\"+states.get(\"thermostatTemperatureSetpoint\")+\"}\";\n    }\n    String topic = \"hello\";\n    CompletableFuture.runAsync(() -> {\n      publishMqtt(topic, msg); // method call or code to be asynch.\n    });\n    */\n\n    // ---------------------------------------------\n  }\n\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException {\n    response.setContentType(\"text/plain\");\n    response.getWriter().println(\"/smarthome/update is a POST call\");\n  }\n\n  @Override\n  protected void doOptions(HttpServletRequest req, HttpServletResponse res) {\n    // pre-flight request processing\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,Accept,Origin\");\n  }\n/*\n  public void publishMqtt(String topic, String msg){\n    try {\n      //SampleAsyncCallBack mqtt = new SampleAsyncCallBack();\n      Sample mqtt = MySmartHomeApp.getInstanceMqtt();\n      mqtt.publish(topic, 0, msg.getBytes());\n      LOGGER.debug(\"Message = \"+ msg +\" sent by MQTT from UpdateServelet\");\n    } catch (Throwable throwable) {\n      LOGGER.error(\"failed to publish device: {}\", throwable);\n    }\n  } */\n}", "class_id": 0, "repo": "aniketkumar2012/GH_Home_Smart_Devices", "file": "src/main/java/com/example/SmartHomeUpdateServlet.java", "last_update_at": "2021-09-25T07:01:30+00:00", "question_id": "0e0da15f7cbb858c23517f700b77e09fcb2e8e1f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(name = \"smarthomeUpdate\", urlPatterns = \"/smarthome/update\")\npublic class SmartHomeUpdateServlet extends HttpServlet {\n  private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);\n  private static MyDataStore database = MyDataStore.getInstance();\n  private final SmartHomeApp actionsApp = new MySmartHomeApp();\n  //private String msg;\n  private static final List<String> UPDATE_DEVICE_PARAMS_KEYS =\n      Arrays.asList(new String[] {\"name\", \"nickname\", \"localDeviceId\", \"errorCode\", \"tfa\"});\n  {\n    try {\n      GoogleCredentials credentials =\n          GoogleCredentials.fromStream(getClass().getResourceAsStream(\"/smart-home-key.json\"));\n      actionsApp.setCredentials(credentials);\n    } catch (Exception e) {\n      LOGGER.error(\"couldn't load credentials\");\n    }\n  }\n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n    String body = req.getReader().lines().collect(Collectors.joining());\n    LOGGER.info(\"doPost, body = {}\", body);\n    JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();\n    String userId = bodyJson.get(\"userId\").getAsString();\n    String deviceId = bodyJson.get(\"deviceId\").getAsString();\n    JsonObject states = bodyJson.getAsJsonObject(\"states\");\n    Map<String, Object> deviceStates =\n        states != null ? new Gson().fromJson(states, HashMap.class) : null;\n    Map<String, String> deviceParams = new HashMap<>();\n    Set<String> deviceParamsKeys = bodyJson.keySet();\n    deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);\n    for (String k : deviceParamsKeys) {\n      deviceParams.put(k, bodyJson.get(k).getAsString());\n    }\n    try {\n      database.updateDevice(userId, deviceId, deviceStates, deviceParams);\n      if (deviceParams.containsKey(\"localDeviceId\")) {\n        actionsApp.requestSync(userId);\n      }\n      if (states != null) {\n        ReportState.makeRequest(actionsApp, userId, deviceId, states);\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"failed to update device: {}\", e);\n      res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n      res.setContentType(\"text/plain\");\n      res.getWriter().println(\"ERROR\");\n      return;\n    }\n    res.setStatus(HttpServletResponse.SC_OK);\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setContentType(\"text/plain\");\n    res.getWriter().println(\"OK\");\n    // --------- Mqtt implementation --------------\n    //String msg = states.get(\"on\").getAsString().equals(\"true\") ? \"on\" : \"off\";\n    /*msg = states.toString();\n    if (states.has(\"thermostatTemperatureSetpoint\")){\n      msg = \"{'thermostatTemperatureSetpoint':\"+states.get(\"thermostatTemperatureSetpoint\")+\"}\";\n    }\n    String topic = \"hello\";\n    CompletableFuture.runAsync(() -> {\n      publishMqtt(topic, msg); // method call or code to be asynch.\n    });\n    */\n    // ---------------------------------------------\n  }\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException {\n    response.setContentType(\"text/plain\");\n    response.getWriter().println(\"/smarthome/update is a POST call\");\n  }\n  @Override\n  protected void doOptions(HttpServletRequest req, HttpServletResponse res) {\n    // pre-flight request processing\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,Accept,Origin\");\n  }\n/*\n  public void publishMqtt(String topic, String msg){\n    try {\n      //SampleAsyncCallBack mqtt = new SampleAsyncCallBack();\n      Sample mqtt = MySmartHomeApp.getInstanceMqtt();\n      mqtt.publish(topic, 0, msg.getBytes());\n      LOGGER.debug(\"Message = \"+ msg +\" sent by MQTT from UpdateServelet\");\n    } catch (Throwable throwable) {\n      LOGGER.error(\"failed to publish device: {}\", throwable);\n    }\n  } */\n"]], "pred": {"ppl": 2.0407915115356445, "ppl_lower": 2.3501429557800293, "ppl/lowercase_ppl": -1.197856393215268, "ppl/zlib": 0.0004922965689827503, "Min_5.0% Prob": 6.552399429620481, "Min_10.0% Prob": 4.828085934414583, "Min_20.0% Prob": 3.1659314699617087, "Min_30.0% Prob": 2.2849966565183566, "Min_40.0% Prob": 1.7608916204067488, "Min_50.0% Prob": 1.4229071052296638, "Min_60.0% Prob": 1.1892395258590969}}
{"hexsha": "b08f107779d239c4b7d57ae1d699871248d132d2", "ext": "java", "lang": "Java", "content": "public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {\n\n    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {\n\n        private JpaGpsDevice device;\n\n        public OpenJPAEventListener(JpaGpsDevice device) {\n            this.device = device;\n        }\n\n        @Override\n        protected JpaGpsDevice getDevice() {\n            return this.device;\n        }\n\n        public void beforeDelete(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterDelete(LifecycleEvent lifecycleEvent) {\n            postRemove(lifecycleEvent.getSource());\n        }\n\n        public void beforePersist(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterPersist(LifecycleEvent lifecycleEvent) {\n            postPersist(lifecycleEvent.getSource());\n        }\n\n        public void beforeStore(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterStore(LifecycleEvent lifecycleEvent) {\n            postUpdate(lifecycleEvent.getSource());\n        }\n    }\n\n    private boolean useSpecificClassEvents = true;\n\n    private ClassLoader classLoader;\n\n    private Object eventListener;\n\n    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {\n        this.useSpecificClassEvents = useSpecificClassEvents;\n    }\n\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Allows to directly inject the event listener that will be used with Open JPA. Will\n     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.\n     */\n    public void setEventListener(Object eventListener) {\n        this.eventListener = eventListener;\n    }\n\n    public boolean requireRefresh() {\n        return true;\n    }\n\n    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n\n        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();\n\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n\n        if (eventListener == null) {\n            eventListener = new OpenJPAEventListener(device);\n        }\n\n        if (useSpecificClassEvents) {\n            ArrayList<Class> matchedClasses = new ArrayList<Class>();\n            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);\n            for (Class clazz : classes) {\n                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);\n                Class mappedClass = classMetaData.getDescribedType();\n                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {\n                    matchedClasses.add(mappedClass);\n                }\n            }\n            if (matchedClasses.size() > 0) {\n                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));\n            }\n        } else {\n            emf.addLifecycleListener(eventListener);\n        }\n    }\n\n    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        eventListener = new OpenJPAEventListener(device);\n        emf.removeLifecycleListener(eventListener);\n    }\n}", "class_id": 0, "repo": "guaxinim/compass", "file": "src/main/src/org/compass/gps/device/jpa/lifecycle/OpenJPAJpaEntityLifecycleInjector.java", "last_update_at": "2021-11-10T06:48:02+00:00", "question_id": "b08f107779d239c4b7d57ae1d699871248d132d2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {\n    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {\n        private JpaGpsDevice device;\n        public OpenJPAEventListener(JpaGpsDevice device) {\n            this.device = device;\n        }\n        @Override\n        protected JpaGpsDevice getDevice() {\n            return this.device;\n        }\n        public void beforeDelete(LifecycleEvent lifecycleEvent) {\n        }\n        public void afterDelete(LifecycleEvent lifecycleEvent) {\n            postRemove(lifecycleEvent.getSource());\n        }\n        public void beforePersist(LifecycleEvent lifecycleEvent) {\n        }\n        public void afterPersist(LifecycleEvent lifecycleEvent) {\n            postPersist(lifecycleEvent.getSource());\n        }\n        public void beforeStore(LifecycleEvent lifecycleEvent) {\n        }\n        public void afterStore(LifecycleEvent lifecycleEvent) {\n            postUpdate(lifecycleEvent.getSource());\n        }\n    }\n    private boolean useSpecificClassEvents = true;\n    private ClassLoader classLoader;\n    private Object eventListener;\n    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {\n        this.useSpecificClassEvents = useSpecificClassEvents;\n    }\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n    /**\n     * Allows to directly inject the event listener that will be used with Open JPA. Will\n     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.\n     */\n    public void setEventListener(Object eventListener) {\n        this.eventListener = eventListener;\n    }\n    public boolean requireRefresh() {\n        return true;\n    }\n    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        if (eventListener == null) {\n            eventListener = new OpenJPAEventListener(device);\n        }\n        if (useSpecificClassEvents) {\n            ArrayList<Class> matchedClasses = new ArrayList<Class>();\n            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);\n            for (Class clazz : classes) {\n                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);\n                Class mappedClass = classMetaData.getDescribedType();\n                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {\n                    matchedClasses.add(mappedClass);\n                }\n            }\n            if (matchedClasses.size() > 0) {\n                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));\n            }\n        } else {\n            emf.addLifecycleListener(eventListener);\n        }\n    }\n    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        eventListener = new OpenJPAEventListener(device);\n        emf.removeLifecycleListener(eventListener);\n    }\n"]], "pred": {"ppl": 1.9224164485931396, "ppl_lower": 2.2916018962860107, "ppl/lowercase_ppl": -1.2687770943568637, "ppl/zlib": 0.0006445591338104148, "Min_5.0% Prob": 6.908652524153392, "Min_10.0% Prob": 5.0072570989529295, "Min_20.0% Prob": 3.0800502621448103, "Min_30.0% Prob": 2.1521709830596527, "Min_40.0% Prob": 1.6291581172236176, "Min_50.0% Prob": 1.3058221610282232, "Min_60.0% Prob": 1.0904514650352588}}
{"hexsha": "44cf8deda1243d30e680509d78d40d7907b51d93", "ext": "java", "lang": "Java", "content": "@Configuration\r\npublic class ShiroConfig {\r\n\r\n    @Bean(\"sessionManager\")\r\n    public SessionManager sessionManager(){\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n        sessionManager.setSessionValidationSchedulerEnabled(true);\r\n        sessionManager.setSessionIdCookieEnabled(true);\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean(\"securityManager\")\r\n    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(oAuth2Realm);\r\n        securityManager.setSessionManager(sessionManager);\r\n\r\n        return securityManager;\r\n    }\r\n\r\n    @Bean(\"shiroFilter\")\r\n    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n\r\n        //oauth\u8fc7\u6ee4\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"oauth2\", new OAuth2Filter());\r\n        shiroFilter.setFilters(filters);\r\n\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/webjars/**\", \"anon\");\r\n        filterMap.put(\"/druid/**\", \"anon\");\r\n        filterMap.put(\"/app/**\", \"anon\");\r\n        filterMap.put(\"/sys/login\", \"anon\");\r\n        filterMap.put(\"/swagger/**\", \"anon\");\r\n        filterMap.put(\"/v2/api-docs\", \"anon\");\r\n        filterMap.put(\"/swagger-ui.html\", \"anon\");\r\n        filterMap.put(\"/swagger-resources/**\", \"anon\");\r\n        filterMap.put(\"/captcha.jpg\", \"anon\");\r\n        filterMap.put(\"/webname\", \"anon\");\r\n        filterMap.put(\"/licence/**\", \"anon\");\r\n        filterMap.put(\"/report/**\", \"anon\");\r\n        filterMap.put(\"/**/*.html\", \"anon\");\r\n        filterMap.put(\"/fonts/**\", \"anon\");\r\n        filterMap.put(\"/**/*.js\", \"anon\");\r\n        filterMap.put(\"/**/*.css\", \"anon\");\r\n        filterMap.put(\"/plugins/**\", \"anon\");\r\n        filterMap.put(\"/**/*.jpg\", \"anon\");\r\n        filterMap.put(\"/**/*.mp4\", \"anon\");\r\n        filterMap.put(\"/**/*.zip\", \"anon\");\r\n        filterMap.put(\"/**/*.png\", \"anon\");\r\n        filterMap.put(\"/\", \"anon\");\r\n        filterMap.put(\"/**\", \"oauth2\");\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n\r\n        return shiroFilter;\r\n    }\r\n\r\n    @Bean(\"lifecycleBeanPostProcessor\")\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        proxyCreator.setProxyTargetClass(true);\r\n        return proxyCreator;\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n\r\n}", "class_id": 0, "repo": "stuMental/StudentMental", "file": "src/main/java/io/student/config/ShiroConfig.java", "last_update_at": "2021-09-20T20:44:43+00:00", "question_id": "44cf8deda1243d30e680509d78d40d7907b51d93", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\r\npublic class ShiroConfig {\r\n\r\n    @Bean(\"sessionManager\")\r\n    public SessionManager sessionManager(){\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n        sessionManager.setSessionValidationSchedulerEnabled(true);\r\n        sessionManager.setSessionIdCookieEnabled(true);\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean(\"securityManager\")\r\n    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(oAuth2Realm);\r\n        securityManager.setSessionManager(sessionManager);\r\n\r\n        return securityManager;\r\n    }\r\n\r\n    @Bean(\"shiroFilter\")\r\n    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n\r\n        //oauth\u8fc7\u6ee4\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"oauth2\", new OAuth2Filter());\r\n        shiroFilter.setFilters(filters);\r\n\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/webjars/**\", \"anon\");\r\n        filterMap.put(\"/druid/**\", \"anon\");\r\n        filterMap.put(\"/app/**\", \"anon\");\r\n        filterMap.put(\"/sys/login\", \"anon\");\r\n        filterMap.put(\"/swagger/**\", \"anon\");\r\n        filterMap.put(\"/v2/api-docs\", \"anon\");\r\n        filterMap.put(\"/swagger-ui.html\", \"anon\");\r\n        filterMap.put(\"/swagger-resources/**\", \"anon\");\r\n        filterMap.put(\"/captcha.jpg\", \"anon\");\r\n        filterMap.put(\"/webname\", \"anon\");\r\n        filterMap.put(\"/licence/**\", \"anon\");\r\n        filterMap.put(\"/report/**\", \"anon\");\r\n        filterMap.put(\"/**/*.html\", \"anon\");\r\n        filterMap.put(\"/fonts/**\", \"anon\");\r\n        filterMap.put(\"/**/*.js\", \"anon\");\r\n        filterMap.put(\"/**/*.css\", \"anon\");\r\n        filterMap.put(\"/plugins/**\", \"anon\");\r\n        filterMap.put(\"/**/*.jpg\", \"anon\");\r\n        filterMap.put(\"/**/*.mp4\", \"anon\");\r\n        filterMap.put(\"/**/*.zip\", \"anon\");\r\n        filterMap.put(\"/**/*.png\", \"anon\");\r\n        filterMap.put(\"/\", \"anon\");\r\n        filterMap.put(\"/**\", \"oauth2\");\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n\r\n        return shiroFilter;\r\n    }\r\n\r\n    @Bean(\"lifecycleBeanPostProcessor\")\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        proxyCreator.setProxyTargetClass(true);\r\n        return proxyCreator;\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n\r\n"]], "pred": {"ppl": 1.2498911619186401, "ppl_lower": 1.4806896448135376, "ppl/lowercase_ppl": -1.7596797037444722, "ppl/zlib": 0.00031729228600038245, "Min_5.0% Prob": 3.5652184656688144, "Min_10.0% Prob": 2.064506078759829, "Min_20.0% Prob": 1.099313335692776, "Min_30.0% Prob": 0.7401905094490574, "Min_40.0% Prob": 0.5577975909034957, "Min_50.0% Prob": 0.44593763327853914, "Min_60.0% Prob": 0.37201843022688874}}
{"hexsha": "117f3d055e06497bc9bf38c477b32879ef1305eb", "ext": "java", "lang": "Java", "content": "public class MultiAtlasTest\n{\n    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);\n\n    private final Atlas base = new PackedAtlasTest().getAtlas();\n    private Atlas other;\n\n    private MultiAtlas multi;\n\n    @Test\n    public void connectivityTest()\n    {\n        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));\n\n        // Out edges of CC2: 987\n        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());\n        Assert.assertEquals(987,\n                this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());\n        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());\n        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());\n        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());\n    }\n\n    public Atlas getAtlas()\n    {\n        if (this.multi == null)\n        {\n            setup();\n        }\n        return this.multi;\n    }\n\n    @Before\n    public void setup()\n    {\n        final PackedAtlasBuilder builder = new PackedAtlasBuilder()\n                .withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));\n        final Map<String, String> edge5Tags = new HashMap<>();\n        edge5Tags.put(\"highway\", \"primary\");\n        edge5Tags.put(\"name\", \"edge5\");\n        edge5Tags.put(\"surface\", \"concrete\");\n        edge5Tags.put(\"lanes\", \"3\");\n\n        final Map<String, String> edge6Tags = new HashMap<>();\n        edge6Tags.put(\"highway\", \"secondary\");\n        edge6Tags.put(\"name\", \"edge98\");\n        edge6Tags.put(\"bridge\", \"cantilever\");\n        edge6Tags.put(\"maxspeed\", \"100\");\n\n        final Map<String, String> nodeTags = new HashMap<>();\n        nodeTags.put(\"highway\", \"traffic_signal\");\n        // shared\n        builder.addNode(123, Location.TEST_6, nodeTags);\n        // shared\n        builder.addNode(12345, Location.TEST_2, nodeTags);\n        // private\n        builder.addNode(4, Location.TEST_1, nodeTags);\n        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);\n        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);\n\n        // Relation structure and tags\n        // This one is already in the base atlas\n        final RelationBean structure1 = new RelationBean();\n        // structure1.addItem(null, \"in\", ItemType.EDGE);\n        // structure1.addItem(null, \"node\", ItemType.NODE);\n        // structure1.addItem(null, \"out\", ItemType.EDGE);\n        structure1.addItem(4L, \"notThere\", ItemType.NODE);\n        final RelationBean structure3 = new RelationBean();\n        structure3.addItem(5L, \"in\", ItemType.EDGE);\n        structure3.addItem(12345L, \"node\", ItemType.NODE);\n        structure3.addItem(6L, \"out\", ItemType.EDGE);\n        // Add relations\n        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());\n        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());\n\n        this.other = builder.get();\n\n        this.multi = new MultiAtlas(this.base, this.other);\n    }\n\n    @Test\n    public void spatialIndexTest()\n    {\n        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);\n        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));\n        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());\n        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));\n        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();\n        Assert.assertEquals(6, edgeIterator.next().getIdentifier());\n        Assert.assertEquals(5, edgeIterator.next().getIdentifier());\n        Assert.assertFalse(edgeIterator.hasNext());\n    }\n\n    @Test\n    public void testSlicedRelation()\n    {\n        final Relation relation1 = this.multi.relation(1L);\n        final RelationMemberList members = relation1.members();\n        Assert.assertEquals(4, members.size());\n        for (int i = 0; i < members.size(); i++)\n        {\n            Assert.assertTrue(members.get(i) != null);\n        }\n        // Members are ordered by entity type and ascending member identifier\n        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());\n        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());\n        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());\n        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());\n\n        final Relation relation2 = this.multi.relation(2L);\n        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();\n        final Relation relation3 = this.multi.relation(3L);\n        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();\n        Assert.assertEquals(8, allMembers2.size());\n        Assert.assertEquals(8, allMembers3.size());\n    }\n\n    @Test\n    public void totalTest()\n    {\n        final Iterator<Edge> edges = this.multi.edges().iterator();\n        int numberEdges = 0;\n        while (edges.hasNext())\n        {\n            numberEdges++;\n            edges.next();\n        }\n        Assert.assertEquals(6, numberEdges);\n        // Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(3, Iterables.size(this.multi.relations()));\n    }\n}", "class_id": 0, "repo": "gitclonefun/atlas", "file": "src/test/java/org/openstreetmap/atlas/geography/atlas/multi/MultiAtlasTest.java", "last_update_at": "2021-07-07T12:27:00+00:00", "question_id": "117f3d055e06497bc9bf38c477b32879ef1305eb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MultiAtlasTest\n{\n    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);\n    private final Atlas base = new PackedAtlasTest().getAtlas();\n    private Atlas other;\n    private MultiAtlas multi;\n    @Test\n    public void connectivityTest()\n    {\n        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));\n        // Out edges of CC2: 987\n        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());\n        Assert.assertEquals(987,\n                this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());\n        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());\n        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());\n        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());\n    }\n    public Atlas getAtlas()\n    {\n        if (this.multi == null)\n        {\n            setup();\n        }\n        return this.multi;\n    }\n    @Before\n    public void setup()\n    {\n        final PackedAtlasBuilder builder = new PackedAtlasBuilder()\n                .withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));\n        final Map<String, String> edge5Tags = new HashMap<>();\n        edge5Tags.put(\"highway\", \"primary\");\n        edge5Tags.put(\"name\", \"edge5\");\n        edge5Tags.put(\"surface\", \"concrete\");\n        edge5Tags.put(\"lanes\", \"3\");\n        final Map<String, String> edge6Tags = new HashMap<>();\n        edge6Tags.put(\"highway\", \"secondary\");\n        edge6Tags.put(\"name\", \"edge98\");\n        edge6Tags.put(\"bridge\", \"cantilever\");\n        edge6Tags.put(\"maxspeed\", \"100\");\n        final Map<String, String> nodeTags = new HashMap<>();\n        nodeTags.put(\"highway\", \"traffic_signal\");\n        // shared\n        builder.addNode(123, Location.TEST_6, nodeTags);\n        // shared\n        builder.addNode(12345, Location.TEST_2, nodeTags);\n        // private\n        builder.addNode(4, Location.TEST_1, nodeTags);\n        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);\n        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);\n        // Relation structure and tags\n        // This one is already in the base atlas\n        final RelationBean structure1 = new RelationBean();\n        // structure1.addItem(null, \"in\", ItemType.EDGE);\n        // structure1.addItem(null, \"node\", ItemType.NODE);\n        // structure1.addItem(null, \"out\", ItemType.EDGE);\n        structure1.addItem(4L, \"notThere\", ItemType.NODE);\n        final RelationBean structure3 = new RelationBean();\n        structure3.addItem(5L, \"in\", ItemType.EDGE);\n        structure3.addItem(12345L, \"node\", ItemType.NODE);\n        structure3.addItem(6L, \"out\", ItemType.EDGE);\n        // Add relations\n        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());\n        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());\n        this.other = builder.get();\n        this.multi = new MultiAtlas(this.base, this.other);\n    }\n    @Test\n    public void spatialIndexTest()\n    {\n        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);\n        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));\n        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());\n        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));\n        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();\n        Assert.assertEquals(6, edgeIterator.next().getIdentifier());\n        Assert.assertEquals(5, edgeIterator.next().getIdentifier());\n        Assert.assertFalse(edgeIterator.hasNext());\n    }\n    @Test\n    public void testSlicedRelation()\n    {\n        final Relation relation1 = this.multi.relation(1L);\n        final RelationMemberList members = relation1.members();\n        Assert.assertEquals(4, members.size());\n        for (int i = 0; i < members.size(); i++)\n        {\n            Assert.assertTrue(members.get(i) != null);\n        }\n        // Members are ordered by entity type and ascending member identifier\n        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());\n        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());\n        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());\n        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());\n        final Relation relation2 = this.multi.relation(2L);\n        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();\n        final Relation relation3 = this.multi.relation(3L);\n        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();\n        Assert.assertEquals(8, allMembers2.size());\n        Assert.assertEquals(8, allMembers3.size());\n    }\n    @Test\n    public void totalTest()\n    {\n        final Iterator<Edge> edges = this.multi.edges().iterator();\n        int numberEdges = 0;\n        while (edges.hasNext())\n        {\n            numberEdges++;\n            edges.next();\n        }\n        Assert.assertEquals(6, numberEdges);\n        // Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(3, Iterables.size(this.multi.relations()));\n    }\n"]], "pred": {"ppl": 2.001552104949951, "ppl_lower": 2.4169793128967285, "ppl/lowercase_ppl": -1.2717817813893464, "ppl/zlib": 0.0005050385240625202, "Min_5.0% Prob": 6.151873869054458, "Min_10.0% Prob": 4.543119930753521, "Min_20.0% Prob": 3.090243292205474, "Min_30.0% Prob": 2.2471529648584476, "Min_40.0% Prob": 1.7202065317984898, "Min_50.0% Prob": 1.3856150273291974, "Min_60.0% Prob": 1.157275568547265}}
{"hexsha": "6bfcbd87be2fa0596ebe5830cc52201b86851996", "ext": "java", "lang": "Java", "content": "public class FeedJournalStorage implements JournalStorage {\n    private FeedJournalBridge mFeedJournalBridge;\n\n    /**\n     * Creates a {@link FeedJournalStorage} for storing journals for the current user.\n     *\n     * @param profile {@link Profile} of the user we are rendering the Feed for.\n     */\n    public FeedJournalStorage(Profile profile) {\n        mFeedJournalBridge = new FeedJournalBridge(profile);\n    }\n\n    /**\n     * Creates a {@link FeedJournalStorage} for testing.\n     *\n     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.\n     */\n    @VisibleForTesting\n    public FeedJournalStorage(FeedJournalBridge bridge) {\n        mFeedJournalBridge = bridge;\n    }\n\n    /** Cleans up {@link FeedJournalStorage}. */\n    public void destroy() {\n        assert mFeedJournalBridge != null;\n        mFeedJournalBridge.destroy();\n        mFeedJournalBridge = null;\n    }\n\n    @Override\n    public void read(String journalName, Consumer < Result < List<byte[]>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {\n                List<byte[]> journal = Arrays.asList(entries);\n                consumer.accept(Result.success(journal));\n            }, (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.commitJournalMutation(mutation,\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n\n    @Override\n    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.doesJournalExist(journalName,\n                    (Boolean exist)\n                            -> consumer.accept(Result.success(exist)),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void getAllJournals(Consumer < Result < List<String>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadAllJournalKeys(\n                    (String[] data)\n                            -> consumer.accept(Result.success(Arrays.asList(data))),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void deleteAll(Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.deleteAllJournals(\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n}", "class_id": 0, "repo": "jhonatasrm/chromium-android", "file": "app/src/main/java/org/chromium/chrome/browser/feed/FeedJournalStorage.java", "last_update_at": "2021-11-18T09:04:42+00:00", "question_id": "6bfcbd87be2fa0596ebe5830cc52201b86851996", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FeedJournalStorage implements JournalStorage {\n    private FeedJournalBridge mFeedJournalBridge;\n    /**\n     * Creates a {@link FeedJournalStorage} for storing journals for the current user.\n     *\n     * @param profile {@link Profile} of the user we are rendering the Feed for.\n     */\n    public FeedJournalStorage(Profile profile) {\n        mFeedJournalBridge = new FeedJournalBridge(profile);\n    }\n    /**\n     * Creates a {@link FeedJournalStorage} for testing.\n     *\n     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.\n     */\n    @VisibleForTesting\n    public FeedJournalStorage(FeedJournalBridge bridge) {\n        mFeedJournalBridge = bridge;\n    }\n    /** Cleans up {@link FeedJournalStorage}. */\n    public void destroy() {\n        assert mFeedJournalBridge != null;\n        mFeedJournalBridge.destroy();\n        mFeedJournalBridge = null;\n    }\n    @Override\n    public void read(String journalName, Consumer < Result < List<byte[]>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {\n                List<byte[]> journal = Arrays.asList(entries);\n                consumer.accept(Result.success(journal));\n            }, (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n    @Override\n    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.commitJournalMutation(mutation,\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n    @Override\n    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.doesJournalExist(journalName,\n                    (Boolean exist)\n                            -> consumer.accept(Result.success(exist)),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n    @Override\n    public void getAllJournals(Consumer < Result < List<String>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadAllJournalKeys(\n                    (String[] data)\n                            -> consumer.accept(Result.success(Arrays.asList(data))),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n    @Override\n    public void deleteAll(Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.deleteAllJournals(\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n"]], "pred": {"ppl": 1.5458457469940186, "ppl_lower": 1.7991526126861572, "ppl/lowercase_ppl": -1.3483807567403134, "ppl/zlib": 0.0006358703206330564, "Min_5.0% Prob": 5.230865679003975, "Min_10.0% Prob": 3.656345085664229, "Min_20.0% Prob": 2.114562469788573, "Min_30.0% Prob": 1.445294222808584, "Min_40.0% Prob": 1.0874596100733234, "Min_50.0% Prob": 0.8716718224278501, "Min_60.0% Prob": 0.7269385654630232}}
{"hexsha": "73f3690e36701a98e4dd08553207601b0f576d1b", "ext": "java", "lang": "Java", "content": "public class EnvLoadFileTest {\n    @Test\n    public void envTest0() throws IOException {\n        System.setProperty(\"CONFLICTS_VAR\", \"with app\");\n        StandardEnvironment env = null;\n        //\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\");\n        assert \"my my my\".equals(env.evalString(\"%MY_ENV%\"));\n        assert \"with app\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n        //\n        //\n        Map<String, String> envMap = new HashMap<String, String>();\n        envMap.put(\"CONFLICTS_VAR\", \"with env\");\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\", envMap, Thread.currentThread().getContextClassLoader());\n        assert \"with env\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n    }\n}", "class_id": 0, "repo": "corner4world/hasor", "file": "hasor-core/src/test/java/net/hasor/core/environment/EnvLoadFileTest.java", "last_update_at": "2021-06-01T06:52:08+00:00", "question_id": "73f3690e36701a98e4dd08553207601b0f576d1b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EnvLoadFileTest {\n    @Test\n    public void envTest0() throws IOException {\n        System.setProperty(\"CONFLICTS_VAR\", \"with app\");\n        StandardEnvironment env = null;\n        //\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\");\n        assert \"my my my\".equals(env.evalString(\"%MY_ENV%\"));\n        assert \"with app\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n        //\n        //\n        Map<String, String> envMap = new HashMap<String, String>();\n        envMap.put(\"CONFLICTS_VAR\", \"with env\");\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\", envMap, Thread.currentThread().getContextClassLoader());\n        assert \"with env\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n    }\n"]], "pred": {"ppl": 3.142084836959839, "ppl_lower": 3.8699216842651367, "ppl/lowercase_ppl": -1.181981115549856, "ppl/zlib": 0.003407400417889685, "Min_5.0% Prob": 8.13891025023027, "Min_10.0% Prob": 6.573941769807235, "Min_20.0% Prob": 4.832057372383449, "Min_30.0% Prob": 3.637197951475779, "Min_40.0% Prob": 2.833853768913642, "Min_50.0% Prob": 2.2897035032510757, "Min_60.0% Prob": 1.9137561710794335}}
{"hexsha": "ffa598d57403bf725a49c67af6e7b5b8fddbdb6f", "ext": "java", "lang": "Java", "content": "public final class BoruvkaMST {\r\n\r\n    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> compute(int vertices, Iterable<E> edges) {\r\n        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();\r\n        for (E e : edges)\r\n            wrapper.add(new ContractedEdge<>(e));\r\n        return recurse(vertices, wrapper);\r\n    }\r\n\r\n    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {\r\n\r\n        if (vertices < 2)\r\n            return new EdgeList<>();\r\n\r\n        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);\r\n        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);\r\n        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);\r\n\r\n        // extract original edges\r\n        EdgeList<E> markedEdges = new EdgeList<>();\r\n        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);\r\n\r\n        markedEdges.meld(recurse(contracted.vertices, contractedEdges));\r\n        return markedEdges;\r\n    }\r\n}", "class_id": 0, "repo": "lazyguyy/optimal-mst", "file": "src/mst/BoruvkaMST.java", "last_update_at": "2021-12-07T21:13:34+00:00", "question_id": "ffa598d57403bf725a49c67af6e7b5b8fddbdb6f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class BoruvkaMST {\r\n\r\n    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> compute(int vertices, Iterable<E> edges) {\r\n        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();\r\n        for (E e : edges)\r\n            wrapper.add(new ContractedEdge<>(e));\r\n        return recurse(vertices, wrapper);\r\n    }\r\n\r\n    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {\r\n\r\n        if (vertices < 2)\r\n            return new EdgeList<>();\r\n\r\n        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);\r\n        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);\r\n        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);\r\n\r\n        // extract original edges\r\n        EdgeList<E> markedEdges = new EdgeList<>();\r\n        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);\r\n\r\n        markedEdges.meld(recurse(contracted.vertices, contractedEdges));\r\n        return markedEdges;\r\n    }\r\n"]], "pred": {"ppl": 2.4000473022460938, "ppl_lower": 3.1025168895721436, "ppl/lowercase_ppl": -1.2932365773174728, "ppl/zlib": 0.0020697126393117746, "Min_5.0% Prob": 8.141949904592414, "Min_10.0% Prob": 5.948214449380574, "Min_20.0% Prob": 3.8710848579281256, "Min_30.0% Prob": 2.7996430938181125, "Min_40.0% Prob": 2.1640272171873796, "Min_50.0% Prob": 1.745074649331601, "Min_60.0% Prob": 1.4578252912646061}}
{"hexsha": "19807beaf0c29dd03789fd7847ec074e209b45d0", "ext": "java", "lang": "Java", "content": "public class Client {\n    private static final List<String> data = List.of(\"some\", \"data\", \"for\", \"test\");\n\n    public Client() {\n        exp02();\n    }\n\n    private void exp01() {\n        Dao dao = new XmlDao();\n        Service service = new ServiceImpl(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    private void exp02() {\n        Dao dao = new MongoDBDao();\n        Service service = new ServiceImplWithLog(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    public static void main(String[] args) {\n        new Client();\n    }\n\n}", "class_id": 0, "repo": "ismailbenhallam/Design-Patterns", "file": "07-Bridge/src/main/java/client/Client.java", "last_update_at": "2021-07-23T22:52:40+00:00", "question_id": "19807beaf0c29dd03789fd7847ec074e209b45d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Client {\n    private static final List<String> data = List.of(\"some\", \"data\", \"for\", \"test\");\n    public Client() {\n        exp02();\n    }\n    private void exp01() {\n        Dao dao = new XmlDao();\n        Service service = new ServiceImpl(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n    private void exp02() {\n        Dao dao = new MongoDBDao();\n        Service service = new ServiceImplWithLog(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n    public static void main(String[] args) {\n        new Client();\n    }\n"]], "pred": {"ppl": 2.3496975898742676, "ppl_lower": 2.8942878246307373, "ppl/lowercase_ppl": -1.2440076149157442, "ppl/zlib": 0.003337057166857562, "Min_5.0% Prob": 7.754796266555786, "Min_10.0% Prob": 6.433334042044247, "Min_20.0% Prob": 3.9854672925812857, "Min_30.0% Prob": 2.79039577718051, "Min_40.0% Prob": 2.1232839150118155, "Min_50.0% Prob": 1.7023507591462537, "Min_60.0% Prob": 1.432321763175698}}
{"hexsha": "e6daad92b85ef23f3921081ecaf6d618b18c2f1b", "ext": "java", "lang": "Java", "content": "public class OrmBenchmarksTask extends Task\n{\n    public static final  String  TAG              = \"OrmBenchmarksTask\";\n    private static final boolean USE_IN_MEMORY_DB = false;\n    private static final int     NUM_ITERATIONS   = 5;\n\n    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] {\n                    new SquidbExecutor(),\n                    new SugarOrmExecutor(),\n                    new SQLiteExecutor(),\n                    new DBFlowExecutor(),\n                    new SqueakyExecutor(),\n                    new CupboardExecutor(),\n                    new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(),\n                    new RealmExecutor(),\n                    new RequeryExecutor(),\n                    new OptimizedSQLiteExecutor(),\n                    new ORMLiteExecutor(),\n                    new GreenDaoExecutor()\n};\n\n    public String resultString;\n\n    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();\n\n    enum BenchmarkTask\n    {\n        CREATE_DB,\n        WRITE_DATA,\n        READ_DATA,\n        DROP_DB;\n    }\n\n    @Override\n    protected void run(Context context) throws Throwable\n    {\n        for(BenchmarkExecutable orm : mOrms)\n        {\n            orm.init(context, USE_IN_MEMORY_DB);\n            Log.w(TAG, orm.getOrmName() + \" init\");\n        }\n\n        List<BenchmarkExecutable> failed = new ArrayList<>();\n\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n\n            for(BenchmarkExecutable item : mOrms)\n            {\n                for(BenchmarkTask task : BenchmarkTask.values())\n                {\n                    long result = 0;\n\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" start\");\n\n                    try\n                    {\n                        switch(task)\n                        {\n                            case CREATE_DB:\n                                result = item.createDbStructure();\n                                break;\n                            case DROP_DB:\n                                result = item.dropDb();\n                                break;\n                            case READ_DATA:\n                                result = item.readWholeData();\n                                break;\n                            case WRITE_DATA:\n                                result = item.writeWholeData();\n                                break;\n                        }\n                    }\n                    catch(Exception e)\n                    {\n                        result = Long.MIN_VALUE;\n                        failed.add(item);\n                    }\n\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() +\" end\");\n                    addProfilerResult(item.getOrmName(), task, result);\n                }\n            }\n        }\n\n        buildResultString();\n    }\n\n    private void buildResultString()\n    {\n        StringBuilder sb = new StringBuilder();\n\n        BenchmarkTask[] bTasks = new BenchmarkTask[]{BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA};\n        for(BenchmarkTask bTask : bTasks)\n        {\n            sb.append(\"<b>\").append(bTask.name()).append(\"</b>\").append(\"<br/>\");\n            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());\n            if(stringLongMap != null)\n            {\n                for(String ormName : stringLongMap.keySet())\n                {\n\n                    long result = stringLongMap.get(ormName);\n                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);\n                    sb.append(ormName).append(\" - \");\n\n                    if(printResult < 0)\n                    {\n                        sb.append(\"(crashed)\");\n                    }\n                    else\n                    {\n                        sb.append(Math.round(printResult)).append(\"ms\");\n                    }\n\n                    sb.append(\"<br/>\");\n\n                    Log.w(\"FOR_SPREADSHEET\", ormName + \",\" + Math.round(printResult));\n                }\n            }\n        }\n\n        resultString = sb.toString();\n    }\n\n    private void addProfilerResult(String ormName, BenchmarkTask task, long result)\n    {\n        Map<String, Long> taskMap = benchmarkResults.get(task.name());\n        if(taskMap == null)\n        {\n            taskMap = new TreeMap<>();\n            benchmarkResults.put(task.name(), taskMap);\n        }\n        Long storedResult = taskMap.get(ormName);\n        if(storedResult == null)\n        {\n            storedResult = 0l;\n        }\n        long value = result + storedResult;\n        taskMap.put(ormName, value);\n        Log.w(TAG, \"adding \"+ task.name() +\"-\"+ ormName+\"-\"+value);\n    }\n\n    @Override\n    protected boolean handleError(Context context, Throwable e)\n    {\n        return false;\n    }\n\n    @Override\n    protected void onComplete(Context context)\n    {\n        EventBusExt.getDefault().post(this);\n    }\n}", "class_id": 0, "repo": "greenrobot/android-orm-benchmark-updated", "file": "ORM-Benchmark/src/main/java/com/littleinc/orm_benchmark/tasks/OrmBenchmarksTask.java", "last_update_at": "2021-06-14T18:42:56+00:00", "question_id": "e6daad92b85ef23f3921081ecaf6d618b18c2f1b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrmBenchmarksTask extends Task\n{\n    public static final  String  TAG              = \"OrmBenchmarksTask\";\n    private static final boolean USE_IN_MEMORY_DB = false;\n    private static final int     NUM_ITERATIONS   = 5;\n    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] {\n                    new SquidbExecutor(),\n                    new SugarOrmExecutor(),\n                    new SQLiteExecutor(),\n                    new DBFlowExecutor(),\n                    new SqueakyExecutor(),\n                    new CupboardExecutor(),\n                    new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(),\n                    new RealmExecutor(),\n                    new RequeryExecutor(),\n                    new OptimizedSQLiteExecutor(),\n                    new ORMLiteExecutor(),\n                    new GreenDaoExecutor()\n};\n    public String resultString;\n    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();\n    enum BenchmarkTask\n    {\n        CREATE_DB,\n        WRITE_DATA,\n        READ_DATA,\n        DROP_DB;\n    }\n    @Override\n    protected void run(Context context) throws Throwable\n    {\n        for(BenchmarkExecutable orm : mOrms)\n        {\n            orm.init(context, USE_IN_MEMORY_DB);\n            Log.w(TAG, orm.getOrmName() + \" init\");\n        }\n        List<BenchmarkExecutable> failed = new ArrayList<>();\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n            for(BenchmarkExecutable item : mOrms)\n            {\n                for(BenchmarkTask task : BenchmarkTask.values())\n                {\n                    long result = 0;\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" start\");\n                    try\n                    {\n                        switch(task)\n                        {\n                            case CREATE_DB:\n                                result = item.createDbStructure();\n                                break;\n                            case DROP_DB:\n                                result = item.dropDb();\n                                break;\n                            case READ_DATA:\n                                result = item.readWholeData();\n                                break;\n                            case WRITE_DATA:\n                                result = item.writeWholeData();\n                                break;\n                        }\n                    }\n                    catch(Exception e)\n                    {\n                        result = Long.MIN_VALUE;\n                        failed.add(item);\n                    }\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() +\" end\");\n                    addProfilerResult(item.getOrmName(), task, result);\n                }\n            }\n        }\n        buildResultString();\n    }\n    private void buildResultString()\n    {\n        StringBuilder sb = new StringBuilder();\n        BenchmarkTask[] bTasks = new BenchmarkTask[]{BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA};\n        for(BenchmarkTask bTask : bTasks)\n        {\n            sb.append(\"<b>\").append(bTask.name()).append(\"</b>\").append(\"<br/>\");\n            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());\n            if(stringLongMap != null)\n            {\n                for(String ormName : stringLongMap.keySet())\n                {\n                    long result = stringLongMap.get(ormName);\n                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);\n                    sb.append(ormName).append(\" - \");\n                    if(printResult < 0)\n                    {\n                        sb.append(\"(crashed)\");\n                    }\n                    else\n                    {\n                        sb.append(Math.round(printResult)).append(\"ms\");\n                    }\n                    sb.append(\"<br/>\");\n                    Log.w(\"FOR_SPREADSHEET\", ormName + \",\" + Math.round(printResult));\n                }\n            }\n        }\n        resultString = sb.toString();\n    }\n    private void addProfilerResult(String ormName, BenchmarkTask task, long result)\n    {\n        Map<String, Long> taskMap = benchmarkResults.get(task.name());\n        if(taskMap == null)\n        {\n            taskMap = new TreeMap<>();\n            benchmarkResults.put(task.name(), taskMap);\n        }\n        Long storedResult = taskMap.get(ormName);\n        if(storedResult == null)\n        {\n            storedResult = 0l;\n        }\n        long value = result + storedResult;\n        taskMap.put(ormName, value);\n        Log.w(TAG, \"adding \"+ task.name() +\"-\"+ ormName+\"-\"+value);\n    }\n    @Override\n    protected boolean handleError(Context context, Throwable e)\n    {\n        return false;\n    }\n    @Override\n    protected void onComplete(Context context)\n    {\n        EventBusExt.getDefault().post(this);\n    }\n"]], "pred": {"ppl": 2.0205726623535156, "ppl_lower": 2.3356356620788574, "ppl/lowercase_ppl": -1.2060094393811942, "ppl/zlib": 0.0005495163808205206, "Min_5.0% Prob": 6.709646337172565, "Min_10.0% Prob": 4.95968805808647, "Min_20.0% Prob": 3.1910455638871476, "Min_30.0% Prob": 2.272664569026115, "Min_40.0% Prob": 1.740157196056872, "Min_50.0% Prob": 1.4031643879703755, "Min_60.0% Prob": 1.1725506732911843}}
{"hexsha": "e0aa48a7e2cf1b6234970b1b127112d88e948138", "ext": "java", "lang": "Java", "content": "public class PrivateMessage extends Chat {\n\tprivate static Pattern privateMessageRegex = Pattern.compile(\"\\\\[([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16}) -> mir\\\\] (.*)$\");\n\tprivate static Pattern privateMessageSentRegex = Pattern.compile(\"\\\\[mir -> ([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16})\\\\] (.*)$\");\n\tprivate long lastAfkMessage = 0;\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"privateMessage\";\n\t}\n\n\tpublic boolean doAction(String unformatted) {\n\t\tif(unformatted.trim().length() > 0) {\n\t\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\n\t\t\treturn privateMessage.find() || privateMessageSent.find();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doActionHandleChatMessage(String unformatted, String formatted) {\n\t\treturn getSettings().isPrivateChatRight() && doAction(unformatted);\n\t}\n\n\t@Override\n\tpublic boolean doActionModifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\n\t\treturn doAction(unformatted);\n\t}\n\n\t@Override\n\tpublic ChatDisplayAction handleChatMessage(String unformatted, String formatted) {\n\t\treturn ChatDisplayAction.SWAP;\n\t}\n\n\t@Override\n\tpublic IChatComponent modifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\n\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\n\t\tString suggestMsgHoverTxt =\n\t\t\t\tLanguageManager.translateOrReturnKey(\"message_gg_suggestMsgHoverMsg\");\n\t\tIChatComponent hoverText = new ChatComponentText(ModColor.cl(\"a\") + suggestMsgHoverTxt);\n\n\t\tif (privateMessage.find()) {\n\t\t\tString playerName = privateMessage.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\n\t\t\tif (getSettings().isPrivateChatSound()) {\n\t\t\t\tLabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);\n\t\t\t}\n\n\t\t\tif (getSettings().isMsgDisplayNameClick()) {\n\t\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\t\tint siblingCnt = 0;\n\t\t\t\tint nameStart = 0;\n\t\t\t\tint nameEnd = 0;\n\t\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().contains(\"\u00a76[\u00a7r\")) {\n\t\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t\t}\n\t\t\t\t\tsiblingCnt++;\n\t\t\t\t}\n\t\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage+1000 <= System.currentTimeMillis()) {\n\t\t\t\tString message = getSettings().getAfkMsgText();\n\t\t\t\tif(message.length() > 0) {\n\t\t\t\t\tif(message.startsWith(\"~\")) message = message.replaceFirst(\"~\", \"\");\n\t\t\t\t\tMinecraft.getMinecraft().thePlayer.sendChatMessage(\"/msg \" + playerName + \" \" + message);\n\t\t\t\t\tlastAfkMessage = System.currentTimeMillis();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {\n\t\t\tString playerName = privateMessageSent.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\n\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\tint siblingCnt = 0;\n\t\t\tint nameStart = 0;\n\t\t\tint nameEnd = 0;\n\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t}\n\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76] \u00a7r\")) {\n\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t}\n\t\t\t\tsiblingCnt++;\n\t\t\t}\n\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t}\n\t\t}\n\n\t\treturn msg;\n\t}\n}", "class_id": 0, "repo": "Dominic11/LabyMod-GrieferGames-Addon-1.8.9", "file": "src/main/java/de/neocraftr/griefergames/chat/PrivateMessage.java", "last_update_at": "2021-12-22T00:27:11+00:00", "question_id": "e0aa48a7e2cf1b6234970b1b127112d88e948138", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PrivateMessage extends Chat {\n\tprivate static Pattern privateMessageRegex = Pattern.compile(\"\\\\[([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16}) -> mir\\\\] (.*)$\");\n\tprivate static Pattern privateMessageSentRegex = Pattern.compile(\"\\\\[mir -> ([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16})\\\\] (.*)$\");\n\tprivate long lastAfkMessage = 0;\n\t@Override\n\tpublic String getName() {\n\t\treturn \"privateMessage\";\n\t}\n\tpublic boolean doAction(String unformatted) {\n\t\tif(unformatted.trim().length() > 0) {\n\t\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\t\t\treturn privateMessage.find() || privateMessageSent.find();\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic boolean doActionHandleChatMessage(String unformatted, String formatted) {\n\t\treturn getSettings().isPrivateChatRight() && doAction(unformatted);\n\t}\n\t@Override\n\tpublic boolean doActionModifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\t\treturn doAction(unformatted);\n\t}\n\t@Override\n\tpublic ChatDisplayAction handleChatMessage(String unformatted, String formatted) {\n\t\treturn ChatDisplayAction.SWAP;\n\t}\n\t@Override\n\tpublic IChatComponent modifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\t\tString suggestMsgHoverTxt =\n\t\t\t\tLanguageManager.translateOrReturnKey(\"message_gg_suggestMsgHoverMsg\");\n\t\tIChatComponent hoverText = new ChatComponentText(ModColor.cl(\"a\") + suggestMsgHoverTxt);\n\t\tif (privateMessage.find()) {\n\t\t\tString playerName = privateMessage.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\t\t\tif (getSettings().isPrivateChatSound()) {\n\t\t\t\tLabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);\n\t\t\t}\n\t\t\tif (getSettings().isMsgDisplayNameClick()) {\n\t\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\t\tint siblingCnt = 0;\n\t\t\t\tint nameStart = 0;\n\t\t\t\tint nameEnd = 0;\n\t\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().contains(\"\u00a76[\u00a7r\")) {\n\t\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t\t}\n\t\t\t\t\tsiblingCnt++;\n\t\t\t\t}\n\t\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage+1000 <= System.currentTimeMillis()) {\n\t\t\t\tString message = getSettings().getAfkMsgText();\n\t\t\t\tif(message.length() > 0) {\n\t\t\t\t\tif(message.startsWith(\"~\")) message = message.replaceFirst(\"~\", \"\");\n\t\t\t\t\tMinecraft.getMinecraft().thePlayer.sendChatMessage(\"/msg \" + playerName + \" \" + message);\n\t\t\t\t\tlastAfkMessage = System.currentTimeMillis();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {\n\t\t\tString playerName = privateMessageSent.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\tint siblingCnt = 0;\n\t\t\tint nameStart = 0;\n\t\t\tint nameEnd = 0;\n\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t}\n\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76] \u00a7r\")) {\n\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t}\n\t\t\t\tsiblingCnt++;\n\t\t\t}\n\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t}\n\t\t}\n\t\treturn msg;\n\t}\n"]], "pred": {"ppl": 2.1220462322235107, "ppl_lower": 2.4513099193573, "ppl/lowercase_ppl": -1.191713704548145, "ppl/zlib": 0.0006553839956909309, "Min_5.0% Prob": 7.505225924884572, "Min_10.0% Prob": 5.3124047821643305, "Min_20.0% Prob": 3.4293650070241855, "Min_30.0% Prob": 2.4440184236546747, "Min_40.0% Prob": 1.8680474418409005, "Min_50.0% Prob": 1.5034204219265634, "Min_60.0% Prob": 1.2550048014288844}}
{"hexsha": "22f1d27c88a69020fcf20563969e6c9de6ef532c", "ext": "java", "lang": "Java", "content": "@ChannelHandler.Sharable\npublic class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {\n    public static final String POOL_KEY = \"AsyncRpcClientHandler\";\n    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);\n    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();\n\n    public AsyncRpcClientHandler(String address) {\n        super(address);\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {\n        String requestId = response.getRequestId();\n        LOGGER.info(\"Receive response : \" + requestId);\n        RpcFuture rpcFuture = pendingRPC.get(requestId);\n        if (rpcFuture != null) {\n            pendingRPC.remove(requestId);\n            rpcFuture.done(response);\n        }\n        AsyncRpcPool.getInstance().returnObject(address, this);\n    }\n\n    public void close() {\n        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n    }\n\n    public RpcFuture send(final Request request) throws Exception {\n        RpcFuture rpcFuture = new SwiftFuture(request);\n        pendingRPC.put(request.getRequestId(), rpcFuture);\n        final CountDownLatch latch = new CountDownLatch(1);\n        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {\n            LOGGER.info(\"Send request : \" + request.getRequestId());\n            latch.countDown();\n        });\n        return rpcFuture;\n    }\n}", "class_id": 0, "repo": "fanruan/swift-engine", "file": "swift-rpc-netty/src/main/java/com/fr/swift/cloud/netty/rpc/client/async/AsyncRpcClientHandler.java", "last_update_at": "2021-12-03T03:41:22+00:00", "question_id": "22f1d27c88a69020fcf20563969e6c9de6ef532c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ChannelHandler.Sharable\npublic class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {\n    public static final String POOL_KEY = \"AsyncRpcClientHandler\";\n    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);\n    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();\n    public AsyncRpcClientHandler(String address) {\n        super(address);\n    }\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {\n        String requestId = response.getRequestId();\n        LOGGER.info(\"Receive response : \" + requestId);\n        RpcFuture rpcFuture = pendingRPC.get(requestId);\n        if (rpcFuture != null) {\n            pendingRPC.remove(requestId);\n            rpcFuture.done(response);\n        }\n        AsyncRpcPool.getInstance().returnObject(address, this);\n    }\n    public void close() {\n        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n    }\n    public RpcFuture send(final Request request) throws Exception {\n        RpcFuture rpcFuture = new SwiftFuture(request);\n        pendingRPC.put(request.getRequestId(), rpcFuture);\n        final CountDownLatch latch = new CountDownLatch(1);\n        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {\n            LOGGER.info(\"Send request : \" + request.getRequestId());\n            latch.countDown();\n        });\n        return rpcFuture;\n    }\n"]], "pred": {"ppl": 1.9135918617248535, "ppl_lower": 2.564239501953125, "ppl/lowercase_ppl": -1.4509830748803918, "ppl/zlib": 0.0010907261040402623, "Min_5.0% Prob": 6.326504850387574, "Min_10.0% Prob": 4.5654344035357965, "Min_20.0% Prob": 2.912763801289768, "Min_30.0% Prob": 2.093315528660286, "Min_40.0% Prob": 1.6049257060285749, "Min_50.0% Prob": 1.2937828162548746, "Min_60.0% Prob": 1.0807813227184238}}
{"hexsha": "afdbd11a44ee520634dc2f62fa377a7a4d3f4e36", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"planes\")\npublic class Plane extends Vehicle{\n    @Column(name=\"passenger_capacity\")\n    private int passengerCapacity;\n    @ManyToOne\n    private Company company;\n\n    public Plane(){}\n\n    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(id, model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n\n    public void setPassengerCapacity(int seats) {\n        this.passengerCapacity = seats;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"Plane{\");\n        sb.append(super.toString());\n        sb.append(\"passengerCapacity=\").append(passengerCapacity);\n        sb.append('}');\n        return sb.toString();\n    }\n}", "class_id": 0, "repo": "TsvetomirN1/Soft-Uni-Spring-Data", "file": "Lections/spring-data-master/04-jpa-codefirst-lab/src/main/java/course/springdata/codefirst/entity/Plane.java", "last_update_at": "2021-04-24T20:29:56+00:00", "question_id": "afdbd11a44ee520634dc2f62fa377a7a4d3f4e36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"planes\")\npublic class Plane extends Vehicle{\n    @Column(name=\"passenger_capacity\")\n    private int passengerCapacity;\n    @ManyToOne\n    private Company company;\n    public Plane(){}\n    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(id, model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n    public void setPassengerCapacity(int seats) {\n        this.passengerCapacity = seats;\n    }\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"Plane{\");\n        sb.append(super.toString());\n        sb.append(\"passengerCapacity=\").append(passengerCapacity);\n        sb.append('}');\n        return sb.toString();\n    }\n"]], "pred": {"ppl": 1.4659862518310547, "ppl_lower": 1.7943307161331177, "ppl/lowercase_ppl": -1.5283371356371287, "ppl/zlib": 0.001039478873386409, "Min_5.0% Prob": 5.457383632659912, "Min_10.0% Prob": 3.4205778991022417, "Min_20.0% Prob": 1.8687936370334928, "Min_30.0% Prob": 1.268009521380851, "Min_40.0% Prob": 0.9543930305549362, "Min_50.0% Prob": 0.7640476316717342, "Min_60.0% Prob": 0.6399516500011821}}
{"hexsha": "b9f4d52f93a8b27867f96d7d2bf06ba3c97bf302", "ext": "java", "lang": "Java", "content": "public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {\n\n    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, \"textures/gui/dimmer_rack.png\");\n\n    private final ContainerDimmerRack inventoryPlayer;\n    private final TileEntityDimmerRack tileDimmerRack;\n    private final List<ISocapexReceiver> receivers;\n    private TextFieldWidget dmxStartField;\n    private final List<ButtonSocket> sockets;\n    private final List<ButtonPlug> plugs;\n    private int currentPage = 0;\n\n    private int activePlug = -1;\n\n    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {\n        super(container, inventory, title);\n        this.inventoryPlayer = container;\n        this.tileDimmerRack = container.dimmerRack;\n        this.xSize = 250;\n        this.ySize = 131;\n\n        sockets = new ArrayList<>();\n        plugs = new ArrayList<>();\n        receivers = inventoryPlayer.getDevices();\n    }\n\n    @Override\n    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {\n        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {\n            this.onClose();\n            this.getMinecraft().player.closeScreen();\n            return true;\n        }\n        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n        generateButtons();\n    }\n\n    @Override\n    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {\n        this.init(p_resize_1_, p_resize_2_, p_resize_3_);\n    }\n\n    public void generateButtons() {\n        this.buttons.removeAll(sockets);\n        this.buttons.removeAll(plugs);\n        this.children.removeAll(sockets);\n        this.children.removeAll(plugs);\n        this.plugs.clear();\n        this.sockets.clear();\n        int width = this.width / 2;\n        int height = (this.height - this.ySize) / 2;\n        for (int i = 0; i < 6; i++) {\n            SocapexPatch[] patch = inventoryPlayer.getPatch(i);\n            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);\n            int y = height + (i < 3 ? 25 : 70);\n            for (int j = 0; j < 2; j++) {\n                ButtonSocket buttonSocket;\n                if (patch == null || j >= patch.length) {\n                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                } else {\n                    SocapexPatch patch1 = patch[j];\n                    if (patch1 != null && patch1.getReceiver() != null) {\n                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);\n                    } else {\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j),  i, j == 1, this::handleSocket);\n                    }\n                }\n                this.addButton(buttonSocket);\n                sockets.add(buttonSocket);\n            }\n        }\n        if (receivers.size() > 0) {\n            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);\n            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {\n                for (int i = 0; i < channels.length; i++) {\n                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));\n                    int y = height + (i < 3 ? 45 : 65);\n                    if (channels[i] != 1) {\n                        int finalI = i;\n                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, \"\", activePlug == i, (button) -> {\n                            if (button instanceof ButtonPlug) {\n                                ButtonPlug plug = (ButtonPlug) button;\n                                if (activePlug == finalI) {\n                                    plug.setActive(false);\n                                    activePlug = -1;\n                                } else {\n                                    plug.setActive(true);\n                                    activePlug = finalI;\n                                }\n                            }\n                        });\n                        this.addButton(buttonPlug);\n                        plugs.add(buttonPlug);\n                    }\n                }\n            });\n        }\n    }\n\n\n    @Override\n    protected void init() {\n        super.init();\n        int lvt_1_1_ = (this.width - this.xSize) / 2;\n        int lvt_2_1_ = (this.height - this.ySize) / 2;\n        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\"<\"), (button) -> {\n            if (currentPage - 1 < 0) {\n                currentPage = receivers.size() - 1;\n            } else {\n                currentPage--;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\">\"), (button) -> {\n            if (currentPage + 1 > receivers.size() - 1) {\n                currentPage = 0;\n            } else {\n                currentPage++;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(\"\"));\n        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {\n            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));\n        }\n        this.dmxStartField.setCanLoseFocus(false);\n        this.dmxStartField.changeFocus(true);\n        this.dmxStartField.setTextColor(-1);\n        this.dmxStartField.setDisabledTextColour(-1);\n        this.dmxStartField.setEnableBackgroundDrawing(true);\n        this.dmxStartField.setMaxStringLength(35);\n        this.dmxStartField.setValidator(s -> {\n            if (s.length() == 0) {\n                return true;\n            }\n            try {\n                Integer.parseInt(s);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        });\n        this.children.add(this.dmxStartField);\n        this.setFocusedDefault(this.dmxStartField);\n        generateButtons();\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if(this.dmxStartField.isMouseOver(mouseX, mouseY)){\n            this.dmxStartField.setFocused2(true);\n        }\n        return super.mouseClicked(mouseX, mouseY, button);\n    }\n\n    @Override\n    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {\n        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);\n        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);\n        int lvt_4_1_ = this.guiLeft;\n        int lvt_5_1_ = (this.height - this.ySize) / 2;\n        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);\n    }\n\n    @Override\n    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {\n        this.renderBackground(ms);\n        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        RenderSystem.disableBlend();\n        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        this.renderHoveredTooltip(ms,  p_230430_2_, p_230430_3_);\n    }\n\n\n    @Override\n    public void onClose() {\n        super.onClose();\n        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));\n    }\n\n    @Override\n    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {\n        String name = container.dimmerRack.getDisplayName().getString();\n        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);\n        font.drawString(matrixStack, \"Plugs\", 180 + font.getStringWidth(\"Plugs\") / 2, 6, 0x404040);\n        for (int i = 0; i < 6; i++) {\n            int x1 = 33 + 46 * (i < 3 ? i : i - 3);\n            int y1 = (i < 3 ? 15 : 62);\n            font.drawString(matrixStack, \"\" + (i + 1), x1, y1, 0x000000);\n        }\n        if (receivers.size() > 0) {\n            String pageName = \"Panel \" + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());\n            font\n                    .drawString(matrixStack, pageName, 150 + font.getStringWidth(\n                            pageName\n                    ) / 2, 30, 0x404040);\n        }\n        if (activePlug != -1) {\n            int width = this.width / 2;\n            int height = (this.height - this.ySize) / 2;\n            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));\n            int plugY = height + (activePlug < 3 ? 45 : 65);\n            int xDist = plugX - x;\n            int yDist = plugY - y;\n            if (Minecraft.getInstance().currentScreen != null) {\n                long distanceSq = xDist * xDist + yDist * yDist;\n                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;\n                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);\n            }\n            final int color = 0x13C90A;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n            RenderSystem.disableTexture();\n            RenderSystem.disableCull();\n            RenderSystem.lineWidth(3);\n            RenderSystem.color4f(1F, 1F, 1F, 1F);\n            Tessellator tessellator = Tessellator.getInstance();\n            BufferBuilder bufferBuilder = tessellator.getBuffer();\n            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);\n            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();\n            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();\n            tessellator.draw();\n            RenderSystem.enableTexture();\n            RenderSystem.enableCull();\n        }\n    }\n\n    private void handleSocket(Button button) {\n        if (button instanceof ButtonSocket) {\n            ButtonSocket socket = (ButtonSocket) button;\n            int channel = socket.getChannelNumber();\n            int socketNumber = socket.isSecondSocket() ? 2 : 1;\n            if (activePlug == -1) {\n                if (socket.isPatched()) {\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));\n                    generateButtons();\n                }\n            } else {\n                if (!socket.isPatched()) {\n                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));\n                    activePlug = -1;\n                    generateButtons();\n                }\n            }\n        }\n    }\n}", "class_id": 0, "repo": "manmaed/theatrical-forge", "file": "src/main/java/dev/theatricalmod/theatrical/client/gui/screen/ScreenDimmerRack.java", "last_update_at": "2021-12-19T23:19:11+00:00", "question_id": "b9f4d52f93a8b27867f96d7d2bf06ba3c97bf302", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {\n    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, \"textures/gui/dimmer_rack.png\");\n    private final ContainerDimmerRack inventoryPlayer;\n    private final TileEntityDimmerRack tileDimmerRack;\n    private final List<ISocapexReceiver> receivers;\n    private TextFieldWidget dmxStartField;\n    private final List<ButtonSocket> sockets;\n    private final List<ButtonPlug> plugs;\n    private int currentPage = 0;\n    private int activePlug = -1;\n    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {\n        super(container, inventory, title);\n        this.inventoryPlayer = container;\n        this.tileDimmerRack = container.dimmerRack;\n        this.xSize = 250;\n        this.ySize = 131;\n        sockets = new ArrayList<>();\n        plugs = new ArrayList<>();\n        receivers = inventoryPlayer.getDevices();\n    }\n    @Override\n    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {\n        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {\n            this.onClose();\n            this.getMinecraft().player.closeScreen();\n            return true;\n        }\n        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);\n    }\n    @Override\n    public void tick() {\n        super.tick();\n        generateButtons();\n    }\n    @Override\n    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {\n        this.init(p_resize_1_, p_resize_2_, p_resize_3_);\n    }\n    public void generateButtons() {\n        this.buttons.removeAll(sockets);\n        this.buttons.removeAll(plugs);\n        this.children.removeAll(sockets);\n        this.children.removeAll(plugs);\n        this.plugs.clear();\n        this.sockets.clear();\n        int width = this.width / 2;\n        int height = (this.height - this.ySize) / 2;\n        for (int i = 0; i < 6; i++) {\n            SocapexPatch[] patch = inventoryPlayer.getPatch(i);\n            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);\n            int y = height + (i < 3 ? 25 : 70);\n            for (int j = 0; j < 2; j++) {\n                ButtonSocket buttonSocket;\n                if (patch == null || j >= patch.length) {\n                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                } else {\n                    SocapexPatch patch1 = patch[j];\n                    if (patch1 != null && patch1.getReceiver() != null) {\n                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);\n                    } else {\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j),  i, j == 1, this::handleSocket);\n                    }\n                }\n                this.addButton(buttonSocket);\n                sockets.add(buttonSocket);\n            }\n        }\n        if (receivers.size() > 0) {\n            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);\n            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {\n                for (int i = 0; i < channels.length; i++) {\n                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));\n                    int y = height + (i < 3 ? 45 : 65);\n                    if (channels[i] != 1) {\n                        int finalI = i;\n                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, \"\", activePlug == i, (button) -> {\n                            if (button instanceof ButtonPlug) {\n                                ButtonPlug plug = (ButtonPlug) button;\n                                if (activePlug == finalI) {\n                                    plug.setActive(false);\n                                    activePlug = -1;\n                                } else {\n                                    plug.setActive(true);\n                                    activePlug = finalI;\n                                }\n                            }\n                        });\n                        this.addButton(buttonPlug);\n                        plugs.add(buttonPlug);\n                    }\n                }\n            });\n        }\n    }\n    @Override\n    protected void init() {\n        super.init();\n        int lvt_1_1_ = (this.width - this.xSize) / 2;\n        int lvt_2_1_ = (this.height - this.ySize) / 2;\n        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\"<\"), (button) -> {\n            if (currentPage - 1 < 0) {\n                currentPage = receivers.size() - 1;\n            } else {\n                currentPage--;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\">\"), (button) -> {\n            if (currentPage + 1 > receivers.size() - 1) {\n                currentPage = 0;\n            } else {\n                currentPage++;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(\"\"));\n        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {\n            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));\n        }\n        this.dmxStartField.setCanLoseFocus(false);\n        this.dmxStartField.changeFocus(true);\n        this.dmxStartField.setTextColor(-1);\n        this.dmxStartField.setDisabledTextColour(-1);\n        this.dmxStartField.setEnableBackgroundDrawing(true);\n        this.dmxStartField.setMaxStringLength(35);\n        this.dmxStartField.setValidator(s -> {\n            if (s.length() == 0) {\n                return true;\n            }\n            try {\n                Integer.parseInt(s);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        });\n        this.children.add(this.dmxStartField);\n        this.setFocusedDefault(this.dmxStartField);\n        generateButtons();\n    }\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if(this.dmxStartField.isMouseOver(mouseX, mouseY)){\n            this.dmxStartField.setFocused2(true);\n        }\n        return super.mouseClicked(mouseX, mouseY, button);\n    }\n    @Override\n    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {\n        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);\n        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);\n        int lvt_4_1_ = this.guiLeft;\n        int lvt_5_1_ = (this.height - this.ySize) / 2;\n        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);\n    }\n    @Override\n    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {\n        this.renderBackground(ms);\n        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        RenderSystem.disableBlend();\n        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        this.renderHoveredTooltip(ms,  p_230430_2_, p_230430_3_);\n    }\n    @Override\n    public void onClose() {\n        super.onClose();\n        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));\n    }\n    @Override\n    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {\n        String name = container.dimmerRack.getDisplayName().getString();\n        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);\n        font.drawString(matrixStack, \"Plugs\", 180 + font.getStringWidth(\"Plugs\") / 2, 6, 0x404040);\n        for (int i = 0; i < 6; i++) {\n            int x1 = 33 + 46 * (i < 3 ? i : i - 3);\n            int y1 = (i < 3 ? 15 : 62);\n            font.drawString(matrixStack, \"\" + (i + 1), x1, y1, 0x000000);\n        }\n        if (receivers.size() > 0) {\n            String pageName = \"Panel \" + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());\n            font\n                    .drawString(matrixStack, pageName, 150 + font.getStringWidth(\n                            pageName\n                    ) / 2, 30, 0x404040);\n        }\n        if (activePlug != -1) {\n            int width = this.width / 2;\n            int height = (this.height - this.ySize) / 2;\n            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));\n            int plugY = height + (activePlug < 3 ? 45 : 65);\n            int xDist = plugX - x;\n            int yDist = plugY - y;\n            if (Minecraft.getInstance().currentScreen != null) {\n                long distanceSq = xDist * xDist + yDist * yDist;\n                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;\n                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);\n            }\n            final int color = 0x13C90A;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n            RenderSystem.disableTexture();\n            RenderSystem.disableCull();\n            RenderSystem.lineWidth(3);\n            RenderSystem.color4f(1F, 1F, 1F, 1F);\n            Tessellator tessellator = Tessellator.getInstance();\n            BufferBuilder bufferBuilder = tessellator.getBuffer();\n            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);\n            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();\n            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();\n            tessellator.draw();\n            RenderSystem.enableTexture();\n            RenderSystem.enableCull();\n        }\n    }\n    private void handleSocket(Button button) {\n        if (button instanceof ButtonSocket) {\n            ButtonSocket socket = (ButtonSocket) button;\n            int channel = socket.getChannelNumber();\n            int socketNumber = socket.isSecondSocket() ? 2 : 1;\n            if (activePlug == -1) {\n                if (socket.isPatched()) {\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));\n                    generateButtons();\n                }\n            } else {\n                if (!socket.isPatched()) {\n                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));\n                    activePlug = -1;\n                    generateButtons();\n                }\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.8576865196228027, "ppl_lower": 2.237908124923706, "ppl/lowercase_ppl": -1.3006621292364098, "ppl/zlib": 0.00021253668733740375, "Min_5.0% Prob": 6.069297304340437, "Min_10.0% Prob": 4.443543936692032, "Min_20.0% Prob": 2.851870551121001, "Min_30.0% Prob": 2.022691587558369, "Min_40.0% Prob": 1.5396356229695394, "Min_50.0% Prob": 1.2378627772747361, "Min_60.0% Prob": 1.0330850297439278}}
{"hexsha": "2f69a2cf43dadc045ceb638260afaf3f2210355e", "ext": "java", "lang": "Java", "content": "public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe\n{\n\tpublic Recipe_AA_Plating(ItemStack result, List components) \n\t{\n\t\tsuper(result, components);\n\t}\n\n\t@Override\n\tpublic ItemStack getCraftingResult(InventoryCrafting matrix)\n    {\n\t\tItemStack stack = this.getRecipeOutput().copy();\n\t\tItemStack previousAA = this.getAAFromMatrix(matrix);\n\t\t\n\t\tif (previousAA != null && previousAA.hasTagCompound())\t// Copying existing properties\n\t\t{\n\t\t\tstack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());\n\t\t}\n\t\telse\t// ...or just applying new ones\n\t\t{\n\t\t\tstack.setTagCompound(new NBTTagCompound());\n\t\t}\n\t\t\n\t\t// Apply the new upgrade now\n\t\tstack.getTagCompound().setBoolean(\"hasHeavyPlatingUpgrade\", true);\n\t\t\n        return stack;\n    }\n\t\n\t\n\tprivate ItemStack getAAFromMatrix(InventoryCrafting matrix)\n\t{\n\t\tint counter = 0;\n\t\t\n\t\twhile (counter < matrix.getSizeInventory())\n\t\t{\n\t\t\tif (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA)\n\t\t\t{\n\t\t\t\treturn matrix.getStackInSlot(counter);\t// Found it\n\t\t\t}\n\t\t\t\n\t\t\tcounter += 1;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}", "class_id": 0, "repo": "Domochevsky/minecraft-quiverbow", "file": "src/main/java/com/domochevsky/quiverbow/recipes/Recipe_AA_Plating.java", "last_update_at": "2021-05-10T04:57:25+00:00", "question_id": "2f69a2cf43dadc045ceb638260afaf3f2210355e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe\n{\n\tpublic Recipe_AA_Plating(ItemStack result, List components) \n\t{\n\t\tsuper(result, components);\n\t}\n\t@Override\n\tpublic ItemStack getCraftingResult(InventoryCrafting matrix)\n    {\n\t\tItemStack stack = this.getRecipeOutput().copy();\n\t\tItemStack previousAA = this.getAAFromMatrix(matrix);\n\t\t\n\t\tif (previousAA != null && previousAA.hasTagCompound())\t// Copying existing properties\n\t\t{\n\t\t\tstack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());\n\t\t}\n\t\telse\t// ...or just applying new ones\n\t\t{\n\t\t\tstack.setTagCompound(new NBTTagCompound());\n\t\t}\n\t\t\n\t\t// Apply the new upgrade now\n\t\tstack.getTagCompound().setBoolean(\"hasHeavyPlatingUpgrade\", true);\n\t\t\n        return stack;\n    }\n\t\n\t\n\tprivate ItemStack getAAFromMatrix(InventoryCrafting matrix)\n\t{\n\t\tint counter = 0;\n\t\t\n\t\twhile (counter < matrix.getSizeInventory())\n\t\t{\n\t\t\tif (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA)\n\t\t\t{\n\t\t\t\treturn matrix.getStackInSlot(counter);\t// Found it\n\t\t\t}\n\t\t\t\n\t\t\tcounter += 1;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n"]], "pred": {"ppl": 2.140855312347412, "ppl_lower": 2.670624017715454, "ppl/lowercase_ppl": -1.2904692001200924, "ppl/zlib": 0.001478068791942781, "Min_5.0% Prob": 7.074377489089966, "Min_10.0% Prob": 5.281768368511665, "Min_20.0% Prob": 3.4485891691173416, "Min_30.0% Prob": 2.4756925425702527, "Min_40.0% Prob": 1.8880991952785526, "Min_50.0% Prob": 1.5167243592351531, "Min_60.0% Prob": 1.270066474246452}}
{"hexsha": "1c582ac1b81910b0f81a82266c59f8c5b94e8164", "ext": "java", "lang": "Java", "content": "public class ShimBridgingClassloader extends ClassLoader implements BundleReference {\n  public static final String HADOOP_SPOON_PLUGIN = \"HadoopSpoonPlugin\";\n  private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();\n  private final BundleWiring bundleWiring;\n  private final PublicLoadResolveClassLoader bundleWiringClassloader;\n\n  public ShimBridgingClassloader( ClassLoader parentClassLoader, BundleContext bundleContext ) {\n    super( parentClassLoader );\n    this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt( BundleWiring.class );\n    this.bundleWiringClassloader = new PublicLoadResolveClassLoader( bundleWiring.getClassLoader() );\n  }\n\n  public static Object create( BundleContext bundleContext, String className, List<Object> arguments )\n    throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException,\n    InvocationTargetException {\n    ShimBridgingClassloader shimBridgingClassloader =\n      new ShimBridgingClassloader( pluginClassloaderGetter.getPluginClassloader(\n        LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN ), bundleContext );\n    Class<?> clazz = Class.forName( className, true, shimBridgingClassloader );\n    if ( arguments == null || arguments.size() == 0 ) {\n      return clazz.newInstance();\n    }\n    for ( Constructor<?> constructor : clazz.getConstructors() ) {\n      Class<?>[] parameterTypes = constructor.getParameterTypes();\n      if ( parameterTypes.length == arguments.size() ) {\n        boolean match = true;\n        for ( int i = 0; i < parameterTypes.length; i++ ) {\n          Object o = arguments.get( i );\n          if ( o != null && !parameterTypes[ i ].isInstance( o ) ) {\n            match = false;\n            break;\n          }\n        }\n        if ( match ) {\n          return constructor.newInstance( arguments.toArray() );\n        }\n      }\n    }\n    throw new InstantiationException(\n      \"Unable to find constructor for class \" + className + \" with arguments \" + arguments );\n  }\n\n  @VisibleForTesting\n  static PluginClassloaderGetter getPluginClassloaderGetter() {\n    return pluginClassloaderGetter;\n  }\n\n  @VisibleForTesting\n  static void setPluginClassloaderGetter( PluginClassloaderGetter pluginClassloaderGetter ) {\n    ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;\n  }\n\n  @Override\n  protected Class<?> findClass( String name ) throws ClassNotFoundException {\n    int lastIndexOfDot = name.lastIndexOf( '.' );\n    final String packageName;\n    final String translatedPath;\n    final String translatedName;\n    if ( lastIndexOfDot >= 0 ) {\n      packageName = name.substring( 0, lastIndexOfDot );\n      if ( getPackage( packageName ) == null ) {\n        definePackage( packageName, null, null, null, null, null, null, null );\n      }\n      translatedPath = \"/\" + packageName.replace( '.', '/' );\n      translatedName = name.substring( lastIndexOfDot + 1 ) + \".class\";\n    } else {\n      packageName = \"\";\n      translatedPath = \"/\";\n      translatedName = name;\n    }\n    if ( getPackage( packageName ) == null ) {\n      definePackage( packageName, null, null, null, null, null, null, null );\n    }\n    List<URL> entries = bundleWiring.findEntries( translatedPath, translatedName, 0 );\n    if ( entries.size() == 1 ) {\n      byte[] bytes;\n      try ( ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream() ) {\n        IOUtils.copy( entries.get( 0 ).openStream(), byteArrayOutputStream );\n        bytes = byteArrayOutputStream.toByteArray();\n      } catch ( IOException e ) {\n        throw new ClassNotFoundException( \"Unable to define class\", e );\n      }\n      return defineClass( name, bytes, 0, bytes.length );\n    }\n    throw new ClassNotFoundException();\n  }\n\n  @Override public URL getResource( String name ) {\n    int lastIndexOf = name.lastIndexOf( '/' );\n\n    List<URL> entries;\n    if ( lastIndexOf > 0 ) {\n      entries = bundleWiring.findEntries( name.substring( 0, lastIndexOf ), name.substring( lastIndexOf + 1 ), 0 );\n    } else {\n      entries = bundleWiring.findEntries( \"/\", name, 0 );\n    }\n    if ( entries.size() == 1 ) {\n      return entries.get( 0 );\n    }\n    URL resource = bundleWiringClassloader.getResource( name );\n    if ( resource == null ) {\n      resource = super.getResource( name );\n    }\n    return resource;\n  }\n\n  @Override\n  public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n    Class<?> result = null;\n    synchronized ( this ) {\n      result = findLoadedClass( name );\n    }\n    if ( result == null ) {\n      try {\n        result = findClass( name );\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      try {\n        Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass( name, resolve );\n        if ( osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader() ) {\n          // Give parent a chance to supercede the system classloader (workaround for boot delegation of packages we\n          // should have loaded from the parent)\n          try {\n            return super.loadClass( name, resolve );\n          } catch ( Exception e ) {\n            // Ignore\n          }\n        }\n        return osgiProvidedClass;\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      return super.loadClass( name, resolve );\n    }\n    if ( resolve ) {\n      resolveClass( result );\n    }\n    return result;\n  }\n\n  @Override\n  public Bundle getBundle() {\n    return this.bundleWiring.getBundle();\n  }\n\n  /**\n   * Trivial classloader subclass that lets us call loadClass with a resolve parameter\n   */\n  @VisibleForTesting\n  static class PublicLoadResolveClassLoader extends ClassLoader {\n    public PublicLoadResolveClassLoader( ClassLoader parent ) {\n      super( parent );\n    }\n\n    @Override\n    public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n      return super.loadClass( name, resolve );\n    }\n  }\n}", "class_id": 0, "repo": "plagoa/big-data-plugin", "file": "impl/shim/common/src/main/java/com/pentaho/big/data/bundles/impl/shim/common/ShimBridgingClassloader.java", "last_update_at": "2021-06-01T15:15:10+00:00", "question_id": "1c582ac1b81910b0f81a82266c59f8c5b94e8164", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShimBridgingClassloader extends ClassLoader implements BundleReference {\n  public static final String HADOOP_SPOON_PLUGIN = \"HadoopSpoonPlugin\";\n  private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();\n  private final BundleWiring bundleWiring;\n  private final PublicLoadResolveClassLoader bundleWiringClassloader;\n  public ShimBridgingClassloader( ClassLoader parentClassLoader, BundleContext bundleContext ) {\n    super( parentClassLoader );\n    this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt( BundleWiring.class );\n    this.bundleWiringClassloader = new PublicLoadResolveClassLoader( bundleWiring.getClassLoader() );\n  }\n  public static Object create( BundleContext bundleContext, String className, List<Object> arguments )\n    throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException,\n    InvocationTargetException {\n    ShimBridgingClassloader shimBridgingClassloader =\n      new ShimBridgingClassloader( pluginClassloaderGetter.getPluginClassloader(\n        LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN ), bundleContext );\n    Class<?> clazz = Class.forName( className, true, shimBridgingClassloader );\n    if ( arguments == null || arguments.size() == 0 ) {\n      return clazz.newInstance();\n    }\n    for ( Constructor<?> constructor : clazz.getConstructors() ) {\n      Class<?>[] parameterTypes = constructor.getParameterTypes();\n      if ( parameterTypes.length == arguments.size() ) {\n        boolean match = true;\n        for ( int i = 0; i < parameterTypes.length; i++ ) {\n          Object o = arguments.get( i );\n          if ( o != null && !parameterTypes[ i ].isInstance( o ) ) {\n            match = false;\n            break;\n          }\n        }\n        if ( match ) {\n          return constructor.newInstance( arguments.toArray() );\n        }\n      }\n    }\n    throw new InstantiationException(\n      \"Unable to find constructor for class \" + className + \" with arguments \" + arguments );\n  }\n  @VisibleForTesting\n  static PluginClassloaderGetter getPluginClassloaderGetter() {\n    return pluginClassloaderGetter;\n  }\n  @VisibleForTesting\n  static void setPluginClassloaderGetter( PluginClassloaderGetter pluginClassloaderGetter ) {\n    ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;\n  }\n  @Override\n  protected Class<?> findClass( String name ) throws ClassNotFoundException {\n    int lastIndexOfDot = name.lastIndexOf( '.' );\n    final String packageName;\n    final String translatedPath;\n    final String translatedName;\n    if ( lastIndexOfDot >= 0 ) {\n      packageName = name.substring( 0, lastIndexOfDot );\n      if ( getPackage( packageName ) == null ) {\n        definePackage( packageName, null, null, null, null, null, null, null );\n      }\n      translatedPath = \"/\" + packageName.replace( '.', '/' );\n      translatedName = name.substring( lastIndexOfDot + 1 ) + \".class\";\n    } else {\n      packageName = \"\";\n      translatedPath = \"/\";\n      translatedName = name;\n    }\n    if ( getPackage( packageName ) == null ) {\n      definePackage( packageName, null, null, null, null, null, null, null );\n    }\n    List<URL> entries = bundleWiring.findEntries( translatedPath, translatedName, 0 );\n    if ( entries.size() == 1 ) {\n      byte[] bytes;\n      try ( ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream() ) {\n        IOUtils.copy( entries.get( 0 ).openStream(), byteArrayOutputStream );\n        bytes = byteArrayOutputStream.toByteArray();\n      } catch ( IOException e ) {\n        throw new ClassNotFoundException( \"Unable to define class\", e );\n      }\n      return defineClass( name, bytes, 0, bytes.length );\n    }\n    throw new ClassNotFoundException();\n  }\n  @Override public URL getResource( String name ) {\n    int lastIndexOf = name.lastIndexOf( '/' );\n    List<URL> entries;\n    if ( lastIndexOf > 0 ) {\n      entries = bundleWiring.findEntries( name.substring( 0, lastIndexOf ), name.substring( lastIndexOf + 1 ), 0 );\n    } else {\n      entries = bundleWiring.findEntries( \"/\", name, 0 );\n    }\n    if ( entries.size() == 1 ) {\n      return entries.get( 0 );\n    }\n    URL resource = bundleWiringClassloader.getResource( name );\n    if ( resource == null ) {\n      resource = super.getResource( name );\n    }\n    return resource;\n  }\n  @Override\n  public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n    Class<?> result = null;\n    synchronized ( this ) {\n      result = findLoadedClass( name );\n    }\n    if ( result == null ) {\n      try {\n        result = findClass( name );\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      try {\n        Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass( name, resolve );\n        if ( osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader() ) {\n          // Give parent a chance to supercede the system classloader (workaround for boot delegation of packages we\n          // should have loaded from the parent)\n          try {\n            return super.loadClass( name, resolve );\n          } catch ( Exception e ) {\n            // Ignore\n          }\n        }\n        return osgiProvidedClass;\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      return super.loadClass( name, resolve );\n    }\n    if ( resolve ) {\n      resolveClass( result );\n    }\n    return result;\n  }\n  @Override\n  public Bundle getBundle() {\n    return this.bundleWiring.getBundle();\n  }\n  /**\n   * Trivial classloader subclass that lets us call loadClass with a resolve parameter\n   */\n  @VisibleForTesting\n  static class PublicLoadResolveClassLoader extends ClassLoader {\n    public PublicLoadResolveClassLoader( ClassLoader parent ) {\n      super( parent );\n    }\n    @Override\n    public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n      return super.loadClass( name, resolve );\n    }\n  }\n"]], "pred": {"ppl": 1.6393650770187378, "ppl_lower": 1.858406662940979, "ppl/lowercase_ppl": -1.2537086403731093, "ppl/zlib": 0.00029921853433147953, "Min_5.0% Prob": 5.86217916245554, "Min_10.0% Prob": 4.049567069493088, "Min_20.0% Prob": 2.384572656861707, "Min_30.0% Prob": 1.6389169769446834, "Min_40.0% Prob": 1.2338912717606372, "Min_50.0% Prob": 0.9889209538382896, "Min_60.0% Prob": 0.8247482123003048}}
{"hexsha": "0faf5feafc496ca15627b4ccf3b1a7b044eb1614", "ext": "java", "lang": "Java", "content": "@WebService(serviceName = \"vnfAdapterNotify\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\")\r\npublic class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify{\r\n\r\n\tprivate static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);\n\n\tprivate final String logMarker = \"[VNF-NOTIFY]\";\r\n\r\n\t@Context WebServiceContext wsContext;\r\n\r\n    @WebMethod(operationName = \"rollbackVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"rollbackVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification\")\r\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest\")\n    public void rollbackVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tRollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();\r\n\r\n\t\trollbackVnfNotification.setMessageId(messageId);\r\n\t\trollbackVnfNotification.setCompleted(completed);\r\n\t\trollbackVnfNotification.setException(exception);\r\n\t\trollbackVnfNotification.setErrorMessage(errorMessage);\r\n\r\n\t\tString method = \"rollbackVnfNotification\";\r\n\t\tObject message = rollbackVnfNotification;\r\n\t\tString messageEventName = \"rollbackVnfNotificationCallback\";\r\n\t\tString messageVariable = \"rollbackVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFRB_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n    @WebMethod(operationName = \"queryVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"queryVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest\")\n    public void queryVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"vnfExists\", targetNamespace = \"\")\r\n        Boolean vnfExists,\r\n        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n        String vnfId,\r\n        @WebParam(name = \"status\", targetNamespace = \"\")\r\n        VnfStatus status,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        QueryVnfNotification.Outputs outputs){\r\n\r\n\t\tString method = \"queryVnfNotification\";\r\n\t\tString messageEventName = \"queryVnfNotificationCallback\";\r\n\t\tString messageVariable = \"queryVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFQ_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tQueryVnfNotification message = new QueryVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setVnfExists(vnfExists);\r\n    \tmessage.setVnfId(vnfId);\r\n    \tmessage.setStatus(status);\r\n    \tmessage.setOutputs(outputs);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n\t@WebMethod(operationName = \"createVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"createVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest\")\n\tpublic void createVnfNotification(\r\n\t\t\t@WebParam(name = \"messageId\", targetNamespace = \"\")\r\n\t        String messageId,\r\n\t        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n\t        boolean completed,\r\n\t        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n\t        MsoExceptionCategory exception,\r\n\t        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n\t        String errorMessage,\r\n\t        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n\t        String vnfId,\r\n\t        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n\t        CreateVnfNotification.Outputs outputs,\r\n\t        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n\t        VnfRollback rollback){\r\n\r\n\t\tString method = \"createVnfNotification\";\r\n\t\tString messageEventName = \"createVnfNotificationCallback\";\r\n\t\tString messageVariable = \"createVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFC_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n\t\tCreateVnfNotification message = new CreateVnfNotification();\r\n\r\n\t\tmessage.setMessageId(messageId);\r\n\t\tmessage.setCompleted(completed);\r\n\t\tmessage.setException(exception);\r\n\t\tmessage.setErrorMessage(errorMessage);\r\n\t\tmessage.setVnfId(vnfId);\r\n\t\tmessage.setOutputs(outputs);\r\n\t\tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n\t@WebMethod(operationName = \"updateVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"updateVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest\")\n    public void updateVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        UpdateVnfNotification.Outputs outputs,\r\n        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n        VnfRollback rollback){\r\n\r\n\t\tString method = \"updateVnfNotification\";\r\n\t\tString messageEventName = \"updateVnfNotificationCallback\";\r\n\t\tString messageVariable = \"updateVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFU_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tUpdateVnfNotification message = new UpdateVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setOutputs(outputs);\r\n    \tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n    @WebMethod(operationName = \"deleteVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"deleteVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest\")\n    public void deleteVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tString method = \"deleteVnfNotification\";\r\n\t\tString messageEventName = \"deleteVnfACallback\";\r\n\t\tString messageVariable = \"deleteVnfACallback\";\r\n\t\tString correlationVariable = \"VNFDEL_uuid\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tDeleteVnfNotification message = new DeleteVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t}\r\n}", "class_id": 0, "repo": "onap/mso", "file": "bpmn/MSOCommonBPMN/src/main/java/org/openecomp/mso/bpmn/common/workflow/service/VnfAdapterNotifyServiceImpl.java", "last_update_at": "2021-10-15T19:28:17+00:00", "question_id": "0faf5feafc496ca15627b4ccf3b1a7b044eb1614", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebService(serviceName = \"vnfAdapterNotify\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\")\r\npublic class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify{\r\n\r\n\tprivate static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);\n\tprivate final String logMarker = \"[VNF-NOTIFY]\";\r\n\r\n\t@Context WebServiceContext wsContext;\r\n\r\n    @WebMethod(operationName = \"rollbackVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"rollbackVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification\")\r\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest\")\n    public void rollbackVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tRollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();\r\n\r\n\t\trollbackVnfNotification.setMessageId(messageId);\r\n\t\trollbackVnfNotification.setCompleted(completed);\r\n\t\trollbackVnfNotification.setException(exception);\r\n\t\trollbackVnfNotification.setErrorMessage(errorMessage);\r\n\r\n\t\tString method = \"rollbackVnfNotification\";\r\n\t\tObject message = rollbackVnfNotification;\r\n\t\tString messageEventName = \"rollbackVnfNotificationCallback\";\r\n\t\tString messageVariable = \"rollbackVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFRB_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n    @WebMethod(operationName = \"queryVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"queryVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest\")\n    public void queryVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"vnfExists\", targetNamespace = \"\")\r\n        Boolean vnfExists,\r\n        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n        String vnfId,\r\n        @WebParam(name = \"status\", targetNamespace = \"\")\r\n        VnfStatus status,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        QueryVnfNotification.Outputs outputs){\r\n\r\n\t\tString method = \"queryVnfNotification\";\r\n\t\tString messageEventName = \"queryVnfNotificationCallback\";\r\n\t\tString messageVariable = \"queryVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFQ_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tQueryVnfNotification message = new QueryVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setVnfExists(vnfExists);\r\n    \tmessage.setVnfId(vnfId);\r\n    \tmessage.setStatus(status);\r\n    \tmessage.setOutputs(outputs);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n\t@WebMethod(operationName = \"createVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"createVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest\")\n\tpublic void createVnfNotification(\r\n\t\t\t@WebParam(name = \"messageId\", targetNamespace = \"\")\r\n\t        String messageId,\r\n\t        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n\t        boolean completed,\r\n\t        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n\t        MsoExceptionCategory exception,\r\n\t        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n\t        String errorMessage,\r\n\t        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n\t        String vnfId,\r\n\t        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n\t        CreateVnfNotification.Outputs outputs,\r\n\t        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n\t        VnfRollback rollback){\r\n\r\n\t\tString method = \"createVnfNotification\";\r\n\t\tString messageEventName = \"createVnfNotificationCallback\";\r\n\t\tString messageVariable = \"createVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFC_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n\t\tCreateVnfNotification message = new CreateVnfNotification();\r\n\r\n\t\tmessage.setMessageId(messageId);\r\n\t\tmessage.setCompleted(completed);\r\n\t\tmessage.setException(exception);\r\n\t\tmessage.setErrorMessage(errorMessage);\r\n\t\tmessage.setVnfId(vnfId);\r\n\t\tmessage.setOutputs(outputs);\r\n\t\tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n\t@WebMethod(operationName = \"updateVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"updateVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest\")\n    public void updateVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        UpdateVnfNotification.Outputs outputs,\r\n        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n        VnfRollback rollback){\r\n\r\n\t\tString method = \"updateVnfNotification\";\r\n\t\tString messageEventName = \"updateVnfNotificationCallback\";\r\n\t\tString messageVariable = \"updateVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFU_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tUpdateVnfNotification message = new UpdateVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setOutputs(outputs);\r\n    \tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n    @WebMethod(operationName = \"deleteVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"deleteVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest\")\n    public void deleteVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tString method = \"deleteVnfNotification\";\r\n\t\tString messageEventName = \"deleteVnfACallback\";\r\n\t\tString messageVariable = \"deleteVnfACallback\";\r\n\t\tString correlationVariable = \"VNFDEL_uuid\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tDeleteVnfNotification message = new DeleteVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t}\r\n"]], "pred": {"ppl": 1.598794937133789, "ppl_lower": 1.9495571851730347, "ppl/lowercase_ppl": -1.4227000628480369, "ppl/zlib": 0.00040348252896271357, "Min_5.0% Prob": 5.942308841967115, "Min_10.0% Prob": 4.001646103812199, "Min_20.0% Prob": 2.2837418734150776, "Min_30.0% Prob": 1.5599669499651474, "Min_40.0% Prob": 1.1719427368214268, "Min_50.0% Prob": 0.9390265832572205, "Min_60.0% Prob": 0.7830095143171543}}
{"hexsha": "ef4088695a2bdbb3f8b94bb4019081cc3a616e2e", "ext": "java", "lang": "Java", "content": "public class MatrixCalculator {\n\n    private static ILexicalDatabase db;\n\n    public MatrixCalculator(ILexicalDatabase db) {\n        MatrixCalculator.db = db;\n    }\n\n    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);\n                result[i][j] = score;\n            }\n        }\n        return result;\n    }\n\n    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] scores = getSimilarityMatrix(words1, words2, rc);\n        double bestScore = 1.0D;\n        for (double[] score : scores) {\n            for (double aScore : score) {\n                if (aScore > bestScore && aScore != Double.MAX_VALUE) bestScore = aScore;\n            }\n        }\n        for (int i = 0; i < scores.length; i++) {\n            for (int j = 0; j < scores[i].length; j++) {\n                if (scores[i][j] == Double.MAX_VALUE) scores[i][j] = 1;\n                else scores[i][j] /= bestScore;\n            }\n        }\n        return scores;\n    }\n\n    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {\n        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);\n        Arrays.asList(words1).forEach(aWords1 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms1.add(synonyms);\n        });\n        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);\n        Arrays.asList(words2).forEach(aWords2 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms2.add(synonyms);\n        });\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                String w1 = words1[i];\n                String w2 = words2[j];\n                if (w1.equals(w2)) {\n                    result[i][j] = 1.0D;\n                    continue;\n                }\n                Set<String> s1 = synonyms1.get(i);\n                Set<String> s2 = synonyms2.get(j);\n                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;\n            }\n        }\n        return result;\n    }\n}", "class_id": 0, "repo": "iamani123/Disatt", "file": "OpenNlp/src/main/java/one/ws4j/util/MatrixCalculator.java", "last_update_at": "2021-03-31T21:12:45+00:00", "question_id": "ef4088695a2bdbb3f8b94bb4019081cc3a616e2e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MatrixCalculator {\n    private static ILexicalDatabase db;\n    public MatrixCalculator(ILexicalDatabase db) {\n        MatrixCalculator.db = db;\n    }\n    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);\n                result[i][j] = score;\n            }\n        }\n        return result;\n    }\n    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] scores = getSimilarityMatrix(words1, words2, rc);\n        double bestScore = 1.0D;\n        for (double[] score : scores) {\n            for (double aScore : score) {\n                if (aScore > bestScore && aScore != Double.MAX_VALUE) bestScore = aScore;\n            }\n        }\n        for (int i = 0; i < scores.length; i++) {\n            for (int j = 0; j < scores[i].length; j++) {\n                if (scores[i][j] == Double.MAX_VALUE) scores[i][j] = 1;\n                else scores[i][j] /= bestScore;\n            }\n        }\n        return scores;\n    }\n    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {\n        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);\n        Arrays.asList(words1).forEach(aWords1 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms1.add(synonyms);\n        });\n        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);\n        Arrays.asList(words2).forEach(aWords2 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms2.add(synonyms);\n        });\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                String w1 = words1[i];\n                String w2 = words2[j];\n                if (w1.equals(w2)) {\n                    result[i][j] = 1.0D;\n                    continue;\n                }\n                Set<String> s1 = synonyms1.get(i);\n                Set<String> s2 = synonyms2.get(j);\n                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;\n            }\n        }\n        return result;\n    }\n"]], "pred": {"ppl": 1.4390296936035156, "ppl_lower": 1.5651354789733887, "ppl/lowercase_ppl": -1.2307979834984737, "ppl/zlib": 0.0005126324825072035, "Min_5.0% Prob": 4.83983713388443, "Min_10.0% Prob": 3.1653788712587247, "Min_20.0% Prob": 1.7678739519259117, "Min_30.0% Prob": 1.2049252476070578, "Min_40.0% Prob": 0.9076825253113938, "Min_50.0% Prob": 0.728152739245057, "Min_60.0% Prob": 0.6064395485963981}}
{"hexsha": "2bb34c545567de1b63d21140f0cf44c5afcf6090", "ext": "java", "lang": "Java", "content": "public class WikiParserTest {\n    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));\n\n    @Test\n    public void parse() throws Exception {\n        final String sample = Resources.toString(getClass().getResource(\"/markdown/sample.md\"), StandardCharsets.UTF_8);\n        final WikiPageSource src = new WikiPageSource();\n        src.setMarkdownSource(sample);\n        final ParsedWikiPage page = toTest.parse(src);\n        System.out.println(page.getHtml());\n    }\n}", "class_id": 0, "repo": "voho/website", "file": "website/src/test/java/cz/voho/wiki/backend/WikiParserTest.java", "last_update_at": "2021-02-06T20:49:46+00:00", "question_id": "2bb34c545567de1b63d21140f0cf44c5afcf6090", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WikiParserTest {\n    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));\n    @Test\n    public void parse() throws Exception {\n        final String sample = Resources.toString(getClass().getResource(\"/markdown/sample.md\"), StandardCharsets.UTF_8);\n        final WikiPageSource src = new WikiPageSource();\n        src.setMarkdownSource(sample);\n        final ParsedWikiPage page = toTest.parse(src);\n        System.out.println(page.getHtml());\n    }\n"]], "pred": {"ppl": 2.8180644512176514, "ppl_lower": 4.032806396484375, "ppl/lowercase_ppl": -1.3459409555621524, "ppl/zlib": 0.003622553442228738, "Min_5.0% Prob": 8.133998394012451, "Min_10.0% Prob": 6.308100274630955, "Min_20.0% Prob": 4.272789158991405, "Min_30.0% Prob": 3.186521284636997, "Min_40.0% Prob": 2.509514869855983, "Min_50.0% Prob": 2.046031026542187, "Min_60.0% Prob": 1.719642259579684}}
{"hexsha": "aec0215d4dc6b60e41e0cce06ce6ef28c82d7239", "ext": "java", "lang": "Java", "content": "public class Julius {\n\n\tpublic static void test() throws FileNotFoundException {\n\t\tif (!Settings.julius_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_bin.getAbsolutePath());\n\t\tif (!Settings.julius_mklm_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());\n\t\t// TODO: check config files, etc...\n\t}\n\n\tpublic static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {\n\n\t\tString[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), \"-C\", conf.getAbsolutePath(), \"-filelist\",\n\t\t\t\tfilelist.getAbsolutePath(), \"-v\", dic.getAbsolutePath(), \"-d\", binlm.getAbsolutePath() };\n\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\n\t\tLog.verbose(\"julius: \" + filelist.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\n\tpublic static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {\n\t\tString[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), \"-nrl\", model_bkwd.getAbsolutePath(),\n\t\t\t\tbinlm.getAbsolutePath() };\n\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\n\t\tLog.verbose(\"mkbingram: \" + model_bkwd.getName() + \" -> \" + binlm.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\n\tpublic static Segmentation align(File sound, File text) throws IOException, RuntimeException {\n\n\t\tFile files[] = new File[] { sound };\n\t\tFile conf = new File(\"julius_model/julius.jconf\");\n\n\t\tFile scp = new File(Settings.temp_dir, \"julius.scp\");\n\t\tFile vocab = new File(Settings.temp_dir, \"julius.voc\");\n\t\tFile dict = new File(Settings.temp_dir, \"julius.dic\");\n\t\tFile model = new File(Settings.temp_dir, \"julius.lm\");\n\t\tFile text_b = new File(Settings.temp_dir, \"julius_rev.txt\");\n\t\tFile binlm = new File(Settings.temp_dir, \"julius.jlm\");\n\n\t\t// FileUtils.makeVocab(text, vocab);\n\n\t\tFileUtils.reverse(text, text_b);\n\n\t\tNGram.srilm_estimate(text_b, vocab, model, 3);\n\n\t\tmkbingram(model, binlm);\n\n\t\tTranscriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);\n\t\tFileUtils.makeSCPFile(scp, files, false);\n\n\t\tLog.verbose(\"Running julius...\");\n\t\tjulius(conf, scp, dict, binlm);\n\n\t\tLog.verbose(\"Parsing julius output...\");\n\t\tString soundname = sound.getAbsolutePath();\n\t\tsoundname = soundname.substring(0, soundname.lastIndexOf('.'));\n\t\tFile outfile = new File(soundname + \".out\");\n\t\tVector<JuliusOutput> julouts = null;\n\n\t\tjulouts = JuliusOutput.loadFromJulius(outfile);\n\n\t\tif (julouts.isEmpty())\n\t\t\tthrow new RuntimeException(\"Julius didn't provide any outputs!\");\n\n\t\tSegmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);\n\n\t\tfor (int i = 1; i < julouts.size(); i++) {\n\t\t\tdouble offset = ret.tiers.get(0).max();\n\t\t\tret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Unit tests.\n\t * \n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\tLocale.setDefault(Locale.ENGLISH);\n\n\t\t\tLog.init(\"JuliusUnitTest\", false);\n\n\t\t\tTranscriber.init();\n\t\t\tTranscriber.test();\n\n\t\t\tSegmentation seg = align(new File(\"/home/guest/Desktop/Respeaking/test/kopacz.wav\"),\n\t\t\t\t\tnew File(\"/home/guest/Desktop/Respeaking/test/kopacz.txt\"));\n\n\t\t\tTextGrid grid = new TextGrid(seg);\n\n\t\t\tgrid.write(new File(\"/home/guest/Desktop/Respeaking/test/out.TextGrid\"));\n\n\t\t\tLog.info(\"Julius Test complete!\");\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "class_id": 0, "repo": "danijel3/KaldiJava", "file": "src/main/java/pl/edu/pjwstk/kaldi/programs/Julius.java", "last_update_at": "2021-09-30T09:16:45+00:00", "question_id": "aec0215d4dc6b60e41e0cce06ce6ef28c82d7239", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Julius {\n\tpublic static void test() throws FileNotFoundException {\n\t\tif (!Settings.julius_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_bin.getAbsolutePath());\n\t\tif (!Settings.julius_mklm_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());\n\t\t// TODO: check config files, etc...\n\t}\n\tpublic static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {\n\t\tString[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), \"-C\", conf.getAbsolutePath(), \"-filelist\",\n\t\t\t\tfilelist.getAbsolutePath(), \"-v\", dic.getAbsolutePath(), \"-d\", binlm.getAbsolutePath() };\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\t\tLog.verbose(\"julius: \" + filelist.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\tpublic static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {\n\t\tString[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), \"-nrl\", model_bkwd.getAbsolutePath(),\n\t\t\t\tbinlm.getAbsolutePath() };\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\t\tLog.verbose(\"mkbingram: \" + model_bkwd.getName() + \" -> \" + binlm.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\tpublic static Segmentation align(File sound, File text) throws IOException, RuntimeException {\n\t\tFile files[] = new File[] { sound };\n\t\tFile conf = new File(\"julius_model/julius.jconf\");\n\t\tFile scp = new File(Settings.temp_dir, \"julius.scp\");\n\t\tFile vocab = new File(Settings.temp_dir, \"julius.voc\");\n\t\tFile dict = new File(Settings.temp_dir, \"julius.dic\");\n\t\tFile model = new File(Settings.temp_dir, \"julius.lm\");\n\t\tFile text_b = new File(Settings.temp_dir, \"julius_rev.txt\");\n\t\tFile binlm = new File(Settings.temp_dir, \"julius.jlm\");\n\t\t// FileUtils.makeVocab(text, vocab);\n\t\tFileUtils.reverse(text, text_b);\n\t\tNGram.srilm_estimate(text_b, vocab, model, 3);\n\t\tmkbingram(model, binlm);\n\t\tTranscriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);\n\t\tFileUtils.makeSCPFile(scp, files, false);\n\t\tLog.verbose(\"Running julius...\");\n\t\tjulius(conf, scp, dict, binlm);\n\t\tLog.verbose(\"Parsing julius output...\");\n\t\tString soundname = sound.getAbsolutePath();\n\t\tsoundname = soundname.substring(0, soundname.lastIndexOf('.'));\n\t\tFile outfile = new File(soundname + \".out\");\n\t\tVector<JuliusOutput> julouts = null;\n\t\tjulouts = JuliusOutput.loadFromJulius(outfile);\n\t\tif (julouts.isEmpty())\n\t\t\tthrow new RuntimeException(\"Julius didn't provide any outputs!\");\n\t\tSegmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);\n\t\tfor (int i = 1; i < julouts.size(); i++) {\n\t\t\tdouble offset = ret.tiers.get(0).max();\n\t\t\tret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);\n\t\t}\n\t\treturn ret;\n\t}\n\t/**\n\t * Unit tests.\n\t * \n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.ENGLISH);\n\t\t\tLog.init(\"JuliusUnitTest\", false);\n\t\t\tTranscriber.init();\n\t\t\tTranscriber.test();\n\t\t\tSegmentation seg = align(new File(\"/home/guest/Desktop/Respeaking/test/kopacz.wav\"),\n\t\t\t\t\tnew File(\"/home/guest/Desktop/Respeaking/test/kopacz.txt\"));\n\t\t\tTextGrid grid = new TextGrid(seg);\n\t\t\tgrid.write(new File(\"/home/guest/Desktop/Respeaking/test/out.TextGrid\"));\n\t\t\tLog.info(\"Julius Test complete!\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n"]], "pred": {"ppl": 2.165759563446045, "ppl_lower": 2.162846803665161, "ppl/lowercase_ppl": -0.9982584508186826, "ppl/zlib": 0.0006221989835303918, "Min_5.0% Prob": 7.192789077758789, "Min_10.0% Prob": 5.423365613993476, "Min_20.0% Prob": 3.498265584309896, "Min_30.0% Prob": 2.5094753857336793, "Min_40.0% Prob": 1.9199724951007546, "Min_50.0% Prob": 1.5444971903750342, "Min_60.0% Prob": 1.2890500931082929}}
{"hexsha": "67b397e218f28a428fff73d04687e53b5722b22e", "ext": "java", "lang": "Java", "content": "public class RDateTest {\n\n    @Test\n    public void testOf1() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));\n    }\n\n    @Test\n    public void testOf2() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));\n        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));\n    }\n\n    @Test\n    public void testOf3() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));\n        // Normal cases are handled by the converter test.\n    }\n\n    @Test\n    public void testOfInvalidSpecialDay() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));\n\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));\n        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));\n    }\n\n    @Test\n    public void testDecade() {\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());\n    }\n\n    @Test\n    public void testIsBefore() {\n        RDate d1 = RDate.of(6, RMonth.Floreal, 4);\n        RDate d2 = RDate.of(6, RMonth.Floreal, 5);\n        assertTrue(d1.isBefore(d2));\n        assertFalse(d2.isBefore(d1));\n        assertFalse(d1.isBefore(d1));\n        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));\n        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));\n    }\n\n    @Test\n    public void testIsSextile() {\n        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());\n    }\n\n    @Test\n    public void testIsSpecialDay() {\n        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());\n        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());\n    }\n\n    @Test\n    public void testGetSpecialDay() {\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());\n    }\n\n    @Test\n    public void testPlusDays_success() {\n        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));\n        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));\n        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));\n        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));\n    }\n\n    @Test\n    public void testPlusDays_invalid() {\n        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));\n    }\n\n    @Test\n    public void testCompareTo() {\n        RDate rd = RDate.of(12, RMonth.Brumaire, 18);\n        assertEquals(-1, rd.compareTo(null));\n        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);\n        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));\n    }\n\n    @Test\n    public void testEquals() {\n        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);\n        RDate rd2 = RDate.of(12, 2, 18);\n        assertEquals(rd1, rd2);\n        assertNotEquals(rd1, new Object());\n        assertNotEquals(rd1, null);\n        assertEquals(rd2.hashCode(), rd1.hashCode());\n    }\n}", "class_id": 0, "repo": "jarnaud/republican-calendar", "file": "src/test/java/com/github/jarnaud/republican/RDateTest.java", "last_update_at": "2021-04-13T16:23:41+00:00", "question_id": "67b397e218f28a428fff73d04687e53b5722b22e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RDateTest {\n    @Test\n    public void testOf1() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));\n    }\n    @Test\n    public void testOf2() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));\n        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));\n    }\n    @Test\n    public void testOf3() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));\n        // Normal cases are handled by the converter test.\n    }\n    @Test\n    public void testOfInvalidSpecialDay() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));\n        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));\n    }\n    @Test\n    public void testDecade() {\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());\n    }\n    @Test\n    public void testIsBefore() {\n        RDate d1 = RDate.of(6, RMonth.Floreal, 4);\n        RDate d2 = RDate.of(6, RMonth.Floreal, 5);\n        assertTrue(d1.isBefore(d2));\n        assertFalse(d2.isBefore(d1));\n        assertFalse(d1.isBefore(d1));\n        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));\n        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));\n    }\n    @Test\n    public void testIsSextile() {\n        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());\n    }\n    @Test\n    public void testIsSpecialDay() {\n        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());\n        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());\n    }\n    @Test\n    public void testGetSpecialDay() {\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());\n    }\n    @Test\n    public void testPlusDays_success() {\n        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));\n        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));\n        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));\n        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));\n    }\n    @Test\n    public void testPlusDays_invalid() {\n        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));\n    }\n    @Test\n    public void testCompareTo() {\n        RDate rd = RDate.of(12, RMonth.Brumaire, 18);\n        assertEquals(-1, rd.compareTo(null));\n        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);\n        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));\n    }\n    @Test\n    public void testEquals() {\n        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);\n        RDate rd2 = RDate.of(12, 2, 18);\n        assertEquals(rd1, rd2);\n        assertNotEquals(rd1, new Object());\n        assertNotEquals(rd1, null);\n        assertEquals(rd2.hashCode(), rd1.hashCode());\n    }\n"]], "pred": {"ppl": 1.5069282054901123, "ppl_lower": 1.5628736019134521, "ppl/lowercase_ppl": -1.0888936280829458, "ppl/zlib": 0.0004779408832472056, "Min_5.0% Prob": 5.2741826468823, "Min_10.0% Prob": 3.443924129593606, "Min_20.0% Prob": 1.9671728674541502, "Min_30.0% Prob": 1.354746616695052, "Min_40.0% Prob": 1.0221373083748488, "Min_50.0% Prob": 0.8200808551131498, "Min_60.0% Prob": 0.6841553336394522}}
{"hexsha": "f93ae094e9bce6ccecad58faf15cf654916b969b", "ext": "java", "lang": "Java", "content": "public class ProjectSaver {\n    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {\n        if (projectDef.getFileName() == null)\n            throw new IllegalArgumentException(\"Built-in projects cannot be exported.\");\n        final Path directory = Paths.get(rootDirectory);\n        if (!Files.exists(directory))\n            throw new IllegalArgumentException(\"Directory does not exist.\");\n\n        saveProjectFile(projectDef, directory);\n        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values())\n            saveNamespace(namespaceDef, directory);\n\n    }\n\n    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {\n        final ProjectFile projectFile = new ProjectFile();\n        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);\n        projectFile.Sources = new ProjectSource[]{new ProjectSource()};\n\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {\n            gson.toJson(projectFile, writer);\n        }\n    }\n\n    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {\n        Path currentDirectory = directory;\n        for (String component : namespaceDef.getNamespace().split(\"\\\\.\")) {\n            currentDirectory = currentDirectory.resolve(component);\n            Files.createDirectories(currentDirectory);\n        }\n\n        for (FileDef fileDef : namespaceDef.getFiles().values()) {\n            final CodeWriter writer = new CodeWriter(4);\n            writer.writeLine(String.format(\"namespace %s;\", namespaceDef.getNamespace()));\n\n            if (fileDef.getImports().size() > 0) {\n                writer.newLine();\n                for (ImportDef importDef : fileDef.getImports()) {\n                    switch (importDef.getKind()) {\n                        case NAMESPACE:\n                            writer.writeLine(String.format(\"import %s.*;\", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));\n                            break;\n\n                        case TYPE:\n                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;\n                            writer.writeLine(importTypeDef.getAlias() == null\n                                ? String.format(\"import %s.%s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName())\n                                : String.format(\"import %s.%s as %s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));\n                            break;\n\n                        default:\n                            throw new IllegalArgumentException(\"Type of import directive is unknown: \" + importDef.getKind());\n                    }\n                }\n            }\n\n            if (fileDef.getOptions().size() > 0) {\n                writer.newLine();\n                for (NameValuePair option : fileDef.getOptions())\n                    writer.writeLine(String.format(\"option %s = %s;\", option.getName(), option.getValue().toString()));\n            }\n\n            saveTypeScope(fileDef, writer);\n\n            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {\n                writer.saveTo(stream);\n            }\n        }\n    }\n\n    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {\n        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {\n            writer.newLine();\n            saveDecorator(decoratorDef, writer);\n        }\n        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {\n            writer.newLine();\n            saveEnumeration(enumerationDef, writer);\n        }\n        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {\n            writer.newLine();\n            saveInterface(interfaceDef, writer);\n        }\n        for (ClassDef classDef : scope.getDefinedClasses()) {\n            writer.newLine();\n            saveClass(classDef, writer);\n        }\n    }\n\n    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {\n        saveComments(decoratorDef, writer);\n        saveDecorators(decoratorDef, writer);\n\n        writer.write(String.format(\"decorator %s {\", decoratorDef.getName()));\n        writer.indent();\n\n        if (decoratorDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(decoratorDef, writer);\n        }\n\n        saveTypeScope(decoratorDef, writer);\n\n        if (decoratorDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < decoratorDef.getProperties().size(); i += 1) {\n                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s %s;\", propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s %s = %s;\", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < decoratorDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static String luminaryTypeName(IntegralType type) {\n        switch (type) {\n            case INT8:\n                return \"Int8\";\n\n            case UINT8:\n                return \"Int8\";\n\n            case INT16:\n                return \"Int8\";\n\n            case UINT16:\n                return \"Int8\";\n\n            case INT32:\n                return \"Int8\";\n\n            case UINT32:\n                return \"Int8\";\n\n            case INT64:\n                return \"Int8\";\n\n            case UINT64:\n                return \"Int8\";\n\n            default:\n                throw new IllegalArgumentException(\"Integral type '\" + type + \"' is unknown.\");\n        }\n    }\n\n    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {\n        saveComments(enumerationDef, writer);\n        saveDecorators(enumerationDef, writer);\n\n        writer.write(String.format(\"enum %s : %s {\", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));\n        writer.indent();\n\n        if (enumerationDef.getMembers().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < enumerationDef.getMembers().size(); i += 1) {\n                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);\n                saveComments(memberDef, writer);\n                saveDecorators(memberDef, writer);\n\n                writer.writeLine(String.format(\"%s = %s;\", memberDef.getName(), memberDef.getValue().toString()));\n                if (i + 1 < enumerationDef.getMembers().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {\n        saveComments(interfaceDef, writer);\n        saveDecorators(interfaceDef, writer);\n\n        writer.write(String.format(\"interface %s \", interfaceDef.getName()));\n        if (interfaceDef.getSuperInterfaces().size() > 0) {\n            writer.write(\": \" + interfaceDef.getSuperInterfaces().get(0).getName());\n            for (int i = 1; i < interfaceDef.getSuperInterfaces().size(); i += 1)\n                writer.write(\", \" + interfaceDef.getSuperInterfaces().get(i).getName());\n        }\n        writer.write(\" {\");\n        writer.indent();\n\n        saveTypeScope(interfaceDef, writer);\n\n        if (interfaceDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < interfaceDef.getProperties().size(); i += 1) {\n                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n\n                writer.write(String.format(\"%s %s\", propertyDef.getType().toString(), propertyDef.getName()));\n                if (propertyDef.isReadable())\n                    writer.write(\" get\");\n                if (propertyDef.isWritable())\n                    writer.write(\" set\");\n                writer.writeLine(\";\");\n                if (i + 1 < interfaceDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveClass(ClassDef classDef, CodeWriter writer) {\n        saveComments(classDef, writer);\n        saveDecorators(classDef, writer);\n\n        writer.write(String.format(classDef.isFinal() ? \"final class\" : \"class %s\", classDef.getName()));\n        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {\n            boolean isFirst = true;\n            if (classDef.getSuperClass() != null) {\n                isFirst = false;\n                writer.write(String.format(\": %s\", classDef.getSuperClass().getName()));\n            }\n            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {\n                if (isFirst) {\n                    isFirst = false;\n                    writer.write(String.format(\": %s\", superInterfaceDef.getName()));\n                } else\n                    writer.write(String.format(\", %s\", superInterfaceDef.getName()));\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n\n        if (classDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(classDef, writer);\n        }\n\n        saveTypeScope(classDef, writer);\n\n        if (classDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < classDef.getProperties().size(); i += 1) {\n                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n\n                final String prefix = propertyDef.isFinal()\n                    ? (propertyDef.isOverride() ? \"final override \" : \"final \")\n                    : (propertyDef.isOverride() ? \"override \" : \"\");\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s%s %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s%s %s = %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < classDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveComments(ItemDef commentable, CodeWriter writer) {\n        for (String comment : commentable.getComments())\n            writer.writeLine(\"/// \" + comment);\n    }\n\n    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {\n        for (Decorator decorator : decoratable.getDecorators()) {\n            final DecoratorDef decoratorDef = decorator.getDefinition();\n            writer.write(String.format(\"[%s\", decoratorDef.getName()));\n\n            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {\n                writer.write(\"(\");\n\n                boolean isFirst = true;\n                for (int i = 0; i < decorator.getArguments().size(); i += 1) {\n                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();\n                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {\n                        if (!isFirst)\n                            writer.write(\", \");\n                        else\n                            isFirst = false;\n\n                        writer.write(String.format(\"%s = %s\", propertyDef.getName(), decorator.getArguments().get(i).getValue()));\n                    }\n                }\n\n                writer.write(\")\");\n            }\n\n            writer.writeLine(\"]\");\n        }\n    }\n\n    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {\n        for (int i = 0; i < constantScope.getDefinedConstants().size(); i += 1) {\n            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);\n            saveComments(constantDef, writer);\n            saveDecorators(constantDef, writer);\n            writer.writeLine(String.format(\"const %s %s = %s;\", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));\n            if (i + 1 < constantScope.getDefinedConstants().size())\n                writer.newLine();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final ProjectLoader loader = new ProjectLoader();\n        System.setProperty(\"luminary.search.path\", \"C:\\\\Projects\\\\MaxiMarkets\\\\ProtocolGenerators\\\\luminary\");\n        final ProjectDef projectDef = loader.load(\"C:\\\\Projects\\\\MaxiMarkets\\\\TradingServer\\\\luminary\\\\External\\\\External.json\");\n        ProjectSaver.save(projectDef, \"D:\\\\Temporary\\\\Luminary\");\n    }\n}", "class_id": 0, "repo": "DeltixInc/Luminary", "file": "java/src/main/java/deltix/luminary/ProjectSaver.java", "last_update_at": "2021-08-19T12:50:45+00:00", "question_id": "f93ae094e9bce6ccecad58faf15cf654916b969b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProjectSaver {\n    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {\n        if (projectDef.getFileName() == null)\n            throw new IllegalArgumentException(\"Built-in projects cannot be exported.\");\n        final Path directory = Paths.get(rootDirectory);\n        if (!Files.exists(directory))\n            throw new IllegalArgumentException(\"Directory does not exist.\");\n        saveProjectFile(projectDef, directory);\n        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values())\n            saveNamespace(namespaceDef, directory);\n    }\n    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {\n        final ProjectFile projectFile = new ProjectFile();\n        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);\n        projectFile.Sources = new ProjectSource[]{new ProjectSource()};\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {\n            gson.toJson(projectFile, writer);\n        }\n    }\n    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {\n        Path currentDirectory = directory;\n        for (String component : namespaceDef.getNamespace().split(\"\\\\.\")) {\n            currentDirectory = currentDirectory.resolve(component);\n            Files.createDirectories(currentDirectory);\n        }\n        for (FileDef fileDef : namespaceDef.getFiles().values()) {\n            final CodeWriter writer = new CodeWriter(4);\n            writer.writeLine(String.format(\"namespace %s;\", namespaceDef.getNamespace()));\n            if (fileDef.getImports().size() > 0) {\n                writer.newLine();\n                for (ImportDef importDef : fileDef.getImports()) {\n                    switch (importDef.getKind()) {\n                        case NAMESPACE:\n                            writer.writeLine(String.format(\"import %s.*;\", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));\n                            break;\n                        case TYPE:\n                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;\n                            writer.writeLine(importTypeDef.getAlias() == null\n                                ? String.format(\"import %s.%s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName())\n                                : String.format(\"import %s.%s as %s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));\n                            break;\n                        default:\n                            throw new IllegalArgumentException(\"Type of import directive is unknown: \" + importDef.getKind());\n                    }\n                }\n            }\n            if (fileDef.getOptions().size() > 0) {\n                writer.newLine();\n                for (NameValuePair option : fileDef.getOptions())\n                    writer.writeLine(String.format(\"option %s = %s;\", option.getName(), option.getValue().toString()));\n            }\n            saveTypeScope(fileDef, writer);\n            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {\n                writer.saveTo(stream);\n            }\n        }\n    }\n    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {\n        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {\n            writer.newLine();\n            saveDecorator(decoratorDef, writer);\n        }\n        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {\n            writer.newLine();\n            saveEnumeration(enumerationDef, writer);\n        }\n        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {\n            writer.newLine();\n            saveInterface(interfaceDef, writer);\n        }\n        for (ClassDef classDef : scope.getDefinedClasses()) {\n            writer.newLine();\n            saveClass(classDef, writer);\n        }\n    }\n    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {\n        saveComments(decoratorDef, writer);\n        saveDecorators(decoratorDef, writer);\n        writer.write(String.format(\"decorator %s {\", decoratorDef.getName()));\n        writer.indent();\n        if (decoratorDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(decoratorDef, writer);\n        }\n        saveTypeScope(decoratorDef, writer);\n        if (decoratorDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < decoratorDef.getProperties().size(); i += 1) {\n                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s %s;\", propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s %s = %s;\", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < decoratorDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static String luminaryTypeName(IntegralType type) {\n        switch (type) {\n            case INT8:\n                return \"Int8\";\n            case UINT8:\n                return \"Int8\";\n            case INT16:\n                return \"Int8\";\n            case UINT16:\n                return \"Int8\";\n            case INT32:\n                return \"Int8\";\n            case UINT32:\n                return \"Int8\";\n            case INT64:\n                return \"Int8\";\n            case UINT64:\n                return \"Int8\";\n            default:\n                throw new IllegalArgumentException(\"Integral type '\" + type + \"' is unknown.\");\n        }\n    }\n    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {\n        saveComments(enumerationDef, writer);\n        saveDecorators(enumerationDef, writer);\n        writer.write(String.format(\"enum %s : %s {\", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));\n        writer.indent();\n        if (enumerationDef.getMembers().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < enumerationDef.getMembers().size(); i += 1) {\n                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);\n                saveComments(memberDef, writer);\n                saveDecorators(memberDef, writer);\n                writer.writeLine(String.format(\"%s = %s;\", memberDef.getName(), memberDef.getValue().toString()));\n                if (i + 1 < enumerationDef.getMembers().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {\n        saveComments(interfaceDef, writer);\n        saveDecorators(interfaceDef, writer);\n        writer.write(String.format(\"interface %s \", interfaceDef.getName()));\n        if (interfaceDef.getSuperInterfaces().size() > 0) {\n            writer.write(\": \" + interfaceDef.getSuperInterfaces().get(0).getName());\n            for (int i = 1; i < interfaceDef.getSuperInterfaces().size(); i += 1)\n                writer.write(\", \" + interfaceDef.getSuperInterfaces().get(i).getName());\n        }\n        writer.write(\" {\");\n        writer.indent();\n        saveTypeScope(interfaceDef, writer);\n        if (interfaceDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < interfaceDef.getProperties().size(); i += 1) {\n                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                writer.write(String.format(\"%s %s\", propertyDef.getType().toString(), propertyDef.getName()));\n                if (propertyDef.isReadable())\n                    writer.write(\" get\");\n                if (propertyDef.isWritable())\n                    writer.write(\" set\");\n                writer.writeLine(\";\");\n                if (i + 1 < interfaceDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static void saveClass(ClassDef classDef, CodeWriter writer) {\n        saveComments(classDef, writer);\n        saveDecorators(classDef, writer);\n        writer.write(String.format(classDef.isFinal() ? \"final class\" : \"class %s\", classDef.getName()));\n        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {\n            boolean isFirst = true;\n            if (classDef.getSuperClass() != null) {\n                isFirst = false;\n                writer.write(String.format(\": %s\", classDef.getSuperClass().getName()));\n            }\n            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {\n                if (isFirst) {\n                    isFirst = false;\n                    writer.write(String.format(\": %s\", superInterfaceDef.getName()));\n                } else\n                    writer.write(String.format(\", %s\", superInterfaceDef.getName()));\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n        if (classDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(classDef, writer);\n        }\n        saveTypeScope(classDef, writer);\n        if (classDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < classDef.getProperties().size(); i += 1) {\n                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                final String prefix = propertyDef.isFinal()\n                    ? (propertyDef.isOverride() ? \"final override \" : \"final \")\n                    : (propertyDef.isOverride() ? \"override \" : \"\");\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s%s %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s%s %s = %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < classDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static void saveComments(ItemDef commentable, CodeWriter writer) {\n        for (String comment : commentable.getComments())\n            writer.writeLine(\"/// \" + comment);\n    }\n    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {\n        for (Decorator decorator : decoratable.getDecorators()) {\n            final DecoratorDef decoratorDef = decorator.getDefinition();\n            writer.write(String.format(\"[%s\", decoratorDef.getName()));\n            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {\n                writer.write(\"(\");\n                boolean isFirst = true;\n                for (int i = 0; i < decorator.getArguments().size(); i += 1) {\n                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();\n                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {\n                        if (!isFirst)\n                            writer.write(\", \");\n                        else\n                            isFirst = false;\n                        writer.write(String.format(\"%s = %s\", propertyDef.getName(), decorator.getArguments().get(i).getValue()));\n                    }\n                }\n                writer.write(\")\");\n            }\n            writer.writeLine(\"]\");\n        }\n    }\n    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {\n        for (int i = 0; i < constantScope.getDefinedConstants().size(); i += 1) {\n            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);\n            saveComments(constantDef, writer);\n            saveDecorators(constantDef, writer);\n            writer.writeLine(String.format(\"const %s %s = %s;\", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));\n            if (i + 1 < constantScope.getDefinedConstants().size())\n                writer.newLine();\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        final ProjectLoader loader = new ProjectLoader();\n        System.setProperty(\"luminary.search.path\", \"C:\\\\Projects\\\\MaxiMarkets\\\\ProtocolGenerators\\\\luminary\");\n        final ProjectDef projectDef = loader.load(\"C:\\\\Projects\\\\MaxiMarkets\\\\TradingServer\\\\luminary\\\\External\\\\External.json\");\n        ProjectSaver.save(projectDef, \"D:\\\\Temporary\\\\Luminary\");\n    }\n"]], "pred": {"ppl": 1.637561321258545, "ppl_lower": 1.7859185934066772, "ppl/lowercase_ppl": -1.1758380666833035, "ppl/zlib": 0.00020346870293850197, "Min_5.0% Prob": 5.477121226927814, "Min_10.0% Prob": 3.8031435269935456, "Min_20.0% Prob": 2.3091523641464757, "Min_30.0% Prob": 1.6146408813256843, "Min_40.0% Prob": 1.2246130118123768, "Min_50.0% Prob": 0.9847911800296135, "Min_60.0% Prob": 0.8223629179258708}}
{"hexsha": "b03dd0c9940a7be99af35e2cda606850ecc8f431", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(\"/applications\")\npublic class ApplicationCrudController extends AbstractCrudController<Application> {\n\tprivate static final String[] ALLOWED_FIELDS = new String[] {\n\t\t\"name\", \"shortDescription\", \"scm.user\", \"scm.repo\"\n\t};\n\t\n\t@Inject private ApplicationService applicationService;\n\t@Inject private FarmService farmService;\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getService()\n\t */\n\t@Override\n\tpublic CIService<Application> getService() { return applicationService; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()\n\t */\n\t@Override\n\tprotected String[] getAllowedFields() { return ALLOWED_FIELDS; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)\n\t */\n\t@Override\n\tprotected Application doGetDetails(Long id, Model model) {\n\t\tApplication app = getService().findOne(id);\n\t\tList<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));\n\t\tmodel.addAttribute(farms);\n\t\treturn app;\n\t}\n}", "class_id": 0, "repo": "williewheeler/zkybase", "file": "ui/src/main/java/org/zkybase/web/controller/application/ApplicationCrudController.java", "last_update_at": "2021-11-12T21:51:18+00:00", "question_id": "b03dd0c9940a7be99af35e2cda606850ecc8f431", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@RequestMapping(\"/applications\")\npublic class ApplicationCrudController extends AbstractCrudController<Application> {\n\tprivate static final String[] ALLOWED_FIELDS = new String[] {\n\t\t\"name\", \"shortDescription\", \"scm.user\", \"scm.repo\"\n\t};\n\t\n\t@Inject private ApplicationService applicationService;\n\t@Inject private FarmService farmService;\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getService()\n\t */\n\t@Override\n\tpublic CIService<Application> getService() { return applicationService; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()\n\t */\n\t@Override\n\tprotected String[] getAllowedFields() { return ALLOWED_FIELDS; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)\n\t */\n\t@Override\n\tprotected Application doGetDetails(Long id, Model model) {\n\t\tApplication app = getService().findOne(id);\n\t\tList<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));\n\t\tmodel.addAttribute(farms);\n\t\treturn app;\n\t}\n"]], "pred": {"ppl": 1.8938922882080078, "ppl_lower": 2.726412534713745, "ppl/lowercase_ppl": -1.5705184217892403, "ppl/zlib": 0.0013222238574335293, "Min_5.0% Prob": 7.098727843340705, "Min_10.0% Prob": 4.9704026562826975, "Min_20.0% Prob": 3.0108547470938993, "Min_30.0% Prob": 2.0974749765384977, "Min_40.0% Prob": 1.5910939342127397, "Min_50.0% Prob": 1.2757880938078106, "Min_60.0% Prob": 1.068045920042852}}
{"hexsha": "f62399e89a1c3106290095c2b907f8016f2f0999", "ext": "java", "lang": "Java", "content": "public class SimilarRatingGraph {\n    public double maxLength(int[] date, int[] rating) {\n    \tint n = date.length;\n    \tdouble ans = 0;\n    \tint[] ps = new int[n - 1];\n    \tint[] qs = new int[n - 1];\n    \tdouble[] hypot = new double[n - 1];\n    \tfor (int i = 0; i + 1 < n; i++) {\n    \t\tps[i] = date[i + 1] - date[i];\n    \t\tqs[i] = rating[i + 1] - rating[i];\n    \t\thypot[i] = Math.hypot(ps[i], qs[i]);\n    \t}\n    \tfor (int i = 0; i < n; i++) {\n    \t\tfor (int j = i + 1; j < n; j++) {\n    \t\t\tlong p01 = 0, p02 = 0;\n    \t\t\tdouble cur = 0;\n    \t\t\tfor (int k = 0;; k++) {\n    \t\t\t\tif (i + k + 1 == n || j + k + 1 == n) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tlong p1 = ps[i + k];\n    \t\t\t\tlong q1 = qs[i + k];\n    \t\t\t\tlong p2 = ps[j + k];\n    \t\t\t\tlong q2 = qs[j + k];\n    \t\t\t\tif (p1 * q2 != p2 * q1) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tif (k == 0) {\n    \t\t\t\t\tp01 = p1;\n    \t\t\t\t\tp02 = p2;\n    \t\t\t\t} else {\n    \t\t\t\t\tif (p1 * p02 != p2 * p01) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif (p1 > p2) {\n    \t\t\t\t\tcur += hypot[i + k];\n    \t\t\t\t} else {\n    \t\t\t\t\tcur += hypot[j + k];\n    \t\t\t\t}\n    \t\t\t\tans = Math.max(ans, cur);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n\n}", "class_id": 0, "repo": "mikhail-dvorkin/competitions", "file": "topcoder/srm635/SimilarRatingGraph.java", "last_update_at": "2021-06-24T10:52:44+00:00", "question_id": "f62399e89a1c3106290095c2b907f8016f2f0999", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimilarRatingGraph {\n    public double maxLength(int[] date, int[] rating) {\n    \tint n = date.length;\n    \tdouble ans = 0;\n    \tint[] ps = new int[n - 1];\n    \tint[] qs = new int[n - 1];\n    \tdouble[] hypot = new double[n - 1];\n    \tfor (int i = 0; i + 1 < n; i++) {\n    \t\tps[i] = date[i + 1] - date[i];\n    \t\tqs[i] = rating[i + 1] - rating[i];\n    \t\thypot[i] = Math.hypot(ps[i], qs[i]);\n    \t}\n    \tfor (int i = 0; i < n; i++) {\n    \t\tfor (int j = i + 1; j < n; j++) {\n    \t\t\tlong p01 = 0, p02 = 0;\n    \t\t\tdouble cur = 0;\n    \t\t\tfor (int k = 0;; k++) {\n    \t\t\t\tif (i + k + 1 == n || j + k + 1 == n) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tlong p1 = ps[i + k];\n    \t\t\t\tlong q1 = qs[i + k];\n    \t\t\t\tlong p2 = ps[j + k];\n    \t\t\t\tlong q2 = qs[j + k];\n    \t\t\t\tif (p1 * q2 != p2 * q1) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tif (k == 0) {\n    \t\t\t\t\tp01 = p1;\n    \t\t\t\t\tp02 = p2;\n    \t\t\t\t} else {\n    \t\t\t\t\tif (p1 * p02 != p2 * p01) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif (p1 > p2) {\n    \t\t\t\t\tcur += hypot[i + k];\n    \t\t\t\t} else {\n    \t\t\t\t\tcur += hypot[j + k];\n    \t\t\t\t}\n    \t\t\t\tans = Math.max(ans, cur);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n"]], "pred": {"ppl": 1.5494675636291504, "ppl_lower": 1.5787898302078247, "ppl/lowercase_ppl": -1.0428106239058603, "ppl/zlib": 0.0010526715494782784, "Min_5.0% Prob": 5.5464576367409, "Min_10.0% Prob": 3.6849684023088023, "Min_20.0% Prob": 2.1247513964772224, "Min_30.0% Prob": 1.4489160077746517, "Min_40.0% Prob": 1.0930639610122588, "Min_50.0% Prob": 0.8761544340290129, "Min_60.0% Prob": 0.730683641652802}}
{"hexsha": "e2ac5750c6ffaf6424160a62dbcfd9d31d5d8011", "ext": "java", "lang": "Java", "content": "public class LOServer {\n\n    /**\n     * Entry point from the command line\n     *\n     * @param args Command line arguments (currently nothing is supported)\n     */\n    public static void main(String[] args) {\n        Game game = new Game();\n        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);\n\n        Javalin app = Javalin.create(config ->\n                config.server(() ->\n                        new Server(queuedThreadPool))).start(7000);\n\n        app.routes(() -> {\n            get(\"/api/state\", ctx -> ctx.json(game.getState()));\n            post(\"/api/update\", ctx -> {\n                if (Objects.equals(ctx.contentType(), \"application/json\")) {\n                    List<Integer> list = ctx.bodyAsClass(List.class);\n                    game.update(list.get(0), list.get(1));\n                    ctx.json(game.getState());\n                }\n            });\n            get(\"/api/reset\", ctx -> {\n                game.reset();\n                ctx.json(game.getState());\n            });\n            get(\"/api/status\", ctx -> {\n                ctx.result(\"OK\");\n            });\n        });\n    }\n}", "class_id": 0, "repo": "codemaxx1/java_lights_out", "file": "server/src/main/java/cs/isu/edu/cs3321/server/LOServer.java", "last_update_at": "2021-11-15T00:20:10+00:00", "question_id": "e2ac5750c6ffaf6424160a62dbcfd9d31d5d8011", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LOServer {\n    /**\n     * Entry point from the command line\n     *\n     * @param args Command line arguments (currently nothing is supported)\n     */\n    public static void main(String[] args) {\n        Game game = new Game();\n        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);\n        Javalin app = Javalin.create(config ->\n                config.server(() ->\n                        new Server(queuedThreadPool))).start(7000);\n        app.routes(() -> {\n            get(\"/api/state\", ctx -> ctx.json(game.getState()));\n            post(\"/api/update\", ctx -> {\n                if (Objects.equals(ctx.contentType(), \"application/json\")) {\n                    List<Integer> list = ctx.bodyAsClass(List.class);\n                    game.update(list.get(0), list.get(1));\n                    ctx.json(game.getState());\n                }\n            });\n            get(\"/api/reset\", ctx -> {\n                game.reset();\n                ctx.json(game.getState());\n            });\n            get(\"/api/status\", ctx -> {\n                ctx.result(\"OK\");\n            });\n        });\n    }\n"]], "pred": {"ppl": 2.0484766960144043, "ppl_lower": 2.574064016342163, "ppl/lowercase_ppl": -1.3184920801463496, "ppl/zlib": 0.0015065051298702456, "Min_5.0% Prob": 6.409798113505046, "Min_10.0% Prob": 4.825560975074768, "Min_20.0% Prob": 3.168281551202138, "Min_30.0% Prob": 2.2628971351372016, "Min_40.0% Prob": 1.7565739958985778, "Min_50.0% Prob": 1.4205686517648006, "Min_60.0% Prob": 1.193800935040709}}
{"hexsha": "54ecda69bf301ee6df3cd3d351eb78aa768b8338", "ext": "java", "lang": "Java", "content": "public class InferenceFrame<V extends Value> extends Frame<V> {\n    private V lostValue;\n\n    public InferenceFrame(int nLocals, int nStack) {\n        super(nLocals, nStack);\n    }\n\n    public InferenceFrame(Frame<? extends V> src) {\n        super(src);\n    }\n\n    public V getLostValue() {\n        return lostValue;\n    }\n\n    public void setLostValue(V lostValue) {\n        this.lostValue = lostValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Frame<V> init(Frame<? extends V> src) {\n        if (!(src instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)src;\n\n        super.init(inferenceFrame);\n\n        this.lostValue = inferenceFrame.lostValue;\n\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {\n        if (!(frame instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)frame;\n\n        boolean changed = super.merge(frame, interpreter);\n\n        if (lostValue == null) {\n            lostValue = inferenceFrame.lostValue;\n            changed |= lostValue != null;\n        } else if (inferenceFrame.lostValue != null) {\n            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);\n            changed |= lostValue != newLostValue;\n            lostValue = newLostValue;\n        }\n\n        return changed;\n    }\n}", "class_id": 0, "repo": "prezi/kannotator", "file": "src/org/jetbrains/kannotator/annotationsInference/engine/InferenceFrame.java", "last_update_at": "2021-11-08T09:49:52+00:00", "question_id": "54ecda69bf301ee6df3cd3d351eb78aa768b8338", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InferenceFrame<V extends Value> extends Frame<V> {\n    private V lostValue;\n    public InferenceFrame(int nLocals, int nStack) {\n        super(nLocals, nStack);\n    }\n    public InferenceFrame(Frame<? extends V> src) {\n        super(src);\n    }\n    public V getLostValue() {\n        return lostValue;\n    }\n    public void setLostValue(V lostValue) {\n        this.lostValue = lostValue;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Frame<V> init(Frame<? extends V> src) {\n        if (!(src instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)src;\n        super.init(inferenceFrame);\n        this.lostValue = inferenceFrame.lostValue;\n        return this;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {\n        if (!(frame instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)frame;\n        boolean changed = super.merge(frame, interpreter);\n        if (lostValue == null) {\n            lostValue = inferenceFrame.lostValue;\n            changed |= lostValue != null;\n        } else if (inferenceFrame.lostValue != null) {\n            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);\n            changed |= lostValue != newLostValue;\n            lostValue = newLostValue;\n        }\n        return changed;\n    }\n"]], "pred": {"ppl": 1.5672296285629272, "ppl_lower": 1.7363612651824951, "ppl/lowercase_ppl": -1.228088222912634, "ppl/zlib": 0.0009662569739403884, "Min_5.0% Prob": 5.08306342905218, "Min_10.0% Prob": 3.5271618392732407, "Min_20.0% Prob": 2.11001825267142, "Min_30.0% Prob": 1.4757174010911998, "Min_40.0% Prob": 1.1194372889509454, "Min_50.0% Prob": 0.8983784067041879, "Min_60.0% Prob": 0.7493244617263024}}
{"hexsha": "64bb9c2ab498522d17c515ad45125a5faeadbb58", "ext": "java", "lang": "Java", "content": "public class SaleRepository extends AbstractBaseRepository<Sale> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Sale get(Long id) {\n        Session session = getSession();\n\n        session.beginTransaction();\n\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale WHERE id = :id\", Sale.class);\n        query.setParameter(\"id\", id);\n\n        Sale result = query.getSingleResult();\n\n        session.getTransaction().commit();\n\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<Sale> getAll() {\n        Session session = getSession();\n\n        session.beginTransaction();\n\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale\", Sale.class);\n        List<Sale> result = query.getResultList();\n\n        session.getTransaction().commit();\n\n        return result;\n    }\n}", "class_id": 0, "repo": "clovergaze/dilithium-exchange-manager", "file": "src/main/java/org/infokin/repository/SaleRepository.java", "last_update_at": "2021-05-07T18:19:07+00:00", "question_id": "64bb9c2ab498522d17c515ad45125a5faeadbb58", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SaleRepository extends AbstractBaseRepository<Sale> {\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Sale get(Long id) {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale WHERE id = :id\", Sale.class);\n        query.setParameter(\"id\", id);\n        Sale result = query.getSingleResult();\n        session.getTransaction().commit();\n        return result;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<Sale> getAll() {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale\", Sale.class);\n        List<Sale> result = query.getResultList();\n        session.getTransaction().commit();\n        return result;\n    }\n"]], "pred": {"ppl": 1.4304420948028564, "ppl_lower": 1.7782565355300903, "ppl/lowercase_ppl": -1.6079884227608832, "ppl/zlib": 0.0011932785123245644, "Min_5.0% Prob": 4.735975742340088, "Min_10.0% Prob": 3.154329334696134, "Min_20.0% Prob": 1.7421831383059423, "Min_30.0% Prob": 1.1930415113456547, "Min_40.0% Prob": 0.8941937546562595, "Min_50.0% Prob": 0.7180990147527523, "Min_60.0% Prob": 0.5996496692203499}}
{"hexsha": "2ebc1707a010e070eba98804a31f5ec0cac11d57", "ext": "java", "lang": "Java", "content": "public class ProxyIT {\n\n    private static final int MOCK_SERVER_PORT = 8088;\n    public static final String MOCK_SERVER_BASE_URL = \"http://localhost:\" + MOCK_SERVER_PORT + \"/\";\n\n    private static final int PROXY_SERVER_PORT = 8080;\n    public static final String PROXY_SERVER_BASE_URL = \"http://localhost:\" + PROXY_SERVER_PORT + \"/\";\n\n    private final HttpClient client = new HttpClient();\n    {\n        try {\n            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, \"integration test client\"));\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @ClassRule\n    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);\n\n    @Test\n    public void forwardsSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL + \"boo\")\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n\n        assertEquals(202, response.getStatus());\n\n        Thread.sleep(500);\n\n        verify(postRequestedFor(urlMatching(\"/boo\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n    }\n\n    @Test\n    public void retriesSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(Scenario.STARTED)\n                .willReturn(aResponse().withStatus(503))\n                .willSetStateTo(\"retry1\"));\n\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retry1\")\n                .willReturn(aResponse().withStatus(202))\n                .willSetStateTo(\"retryN\"));\n\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retryN\")\n                .willReturn(aResponse().withStatus(208)));\n\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL)\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n\n        assertEquals(202, response.getStatus());\n\n        Thread.sleep(5000);\n\n        verify(2, postRequestedFor(urlMatching(\"/\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n\n        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:\n        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());\n    }\n\n\n    @Test\n    public void rejectsMalformedUri() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi.\\\"\";\n\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL.replace('/', '\\\\'))\n                .content(new StringContentProvider(body))\n                .send();\n\n        assertEquals(400, response.getStatus());\n    }\n\n    @Test\n    public void rejectsMissingUri() throws Exception {\n        final String body = \"\\\"boo\\\"\";\n\n        ContentResponse response = client.POST(\"http://localhost:\" + PROXY_SERVER_PORT + \"/\")\n                .content(new StringContentProvider(body))\n                .send();\n\n        assertEquals(400, response.getStatus());\n    }\n\n}", "class_id": 0, "repo": "XroadMedia/qproxy", "file": "src/test/java/tv/xrm/qproxy/ProxyIT.java", "last_update_at": "2021-06-17T12:13:24+00:00", "question_id": "2ebc1707a010e070eba98804a31f5ec0cac11d57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProxyIT {\n    private static final int MOCK_SERVER_PORT = 8088;\n    public static final String MOCK_SERVER_BASE_URL = \"http://localhost:\" + MOCK_SERVER_PORT + \"/\";\n    private static final int PROXY_SERVER_PORT = 8080;\n    public static final String PROXY_SERVER_BASE_URL = \"http://localhost:\" + PROXY_SERVER_PORT + \"/\";\n    private final HttpClient client = new HttpClient();\n    {\n        try {\n            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, \"integration test client\"));\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n    @ClassRule\n    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);\n    @Test\n    public void forwardsSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL + \"boo\")\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(500);\n        verify(postRequestedFor(urlMatching(\"/boo\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n    }\n    @Test\n    public void retriesSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(Scenario.STARTED)\n                .willReturn(aResponse().withStatus(503))\n                .willSetStateTo(\"retry1\"));\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retry1\")\n                .willReturn(aResponse().withStatus(202))\n                .willSetStateTo(\"retryN\"));\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retryN\")\n                .willReturn(aResponse().withStatus(208)));\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL)\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(5000);\n        verify(2, postRequestedFor(urlMatching(\"/\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:\n        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());\n    }\n    @Test\n    public void rejectsMalformedUri() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL.replace('/', '\\\\'))\n                .content(new StringContentProvider(body))\n                .send();\n        assertEquals(400, response.getStatus());\n    }\n    @Test\n    public void rejectsMissingUri() throws Exception {\n        final String body = \"\\\"boo\\\"\";\n        ContentResponse response = client.POST(\"http://localhost:\" + PROXY_SERVER_PORT + \"/\")\n                .content(new StringContentProvider(body))\n                .send();\n        assertEquals(400, response.getStatus());\n    }\n"]], "pred": {"ppl": 1.575527310371399, "ppl_lower": 1.9478569030761719, "ppl/lowercase_ppl": -1.4666616510950825, "ppl/zlib": 0.0004555010185173472, "Min_5.0% Prob": 5.467706778470208, "Min_10.0% Prob": 3.6951590858253778, "Min_20.0% Prob": 2.1742444866720367, "Min_30.0% Prob": 1.5024952221101795, "Min_40.0% Prob": 1.1331760598469554, "Min_50.0% Prob": 0.909119810962798, "Min_60.0% Prob": 0.7584036422324052}}
{"hexsha": "df29abba1282769ae50dd6b261a43891e13c91c9", "ext": "java", "lang": "Java", "content": "public class SortCapList extends Vector {\n    public SortCap getSortCap(int n) {\n        return (SortCap) get(n);\n    }\n\n    public SortCap getSortCap(String type) {\n        if (type == null) {\n            return null;\n        }\n        int nLists = size();\n        for (int n = 0; n < nLists; n++) {\n            SortCap scap = getSortCap(n);\n            if (type.compareTo(scap.getType()) == 0) {\n                return scap;\n            }\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "tiwer/letv", "file": "src/main/java/org/cybergarage/upnp/std/av/server/object/SortCapList.java", "last_update_at": "2021-09-29T09:31:39+00:00", "question_id": "df29abba1282769ae50dd6b261a43891e13c91c9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SortCapList extends Vector {\n    public SortCap getSortCap(int n) {\n        return (SortCap) get(n);\n    }\n    public SortCap getSortCap(String type) {\n        if (type == null) {\n            return null;\n        }\n        int nLists = size();\n        for (int n = 0; n < nLists; n++) {\n            SortCap scap = getSortCap(n);\n            if (type.compareTo(scap.getType()) == 0) {\n                return scap;\n            }\n        }\n        return null;\n    }\n"]], "pred": {"ppl": 2.1340489387512207, "ppl_lower": 2.5283608436584473, "ppl/lowercase_ppl": -1.2236746742844036, "ppl/zlib": 0.0035925169928422707, "Min_5.0% Prob": 8.648780345916748, "Min_10.0% Prob": 5.940631866455078, "Min_20.0% Prob": 3.5731521947630522, "Min_30.0% Prob": 2.487098590894179, "Min_40.0% Prob": 1.8992389566817527, "Min_50.0% Prob": 1.5216251256296764, "Min_60.0% Prob": 1.2673084542699409}}
{"hexsha": "d93af83b46884f4e33c75a2aeeab3e3f01c313cc", "ext": "java", "lang": "Java", "content": "public class CoreTests extends TestCase {\n\n    public static Test suite() {\n        TestSuite suite = new TestSuite(CoreTests.class.getName());\n        suite.addTest(AddImportTest.suite());\n        suite.addTest(SourceActionTests.suite());\n        suite.addTest(ASTNodesInsertTest.suite());\n        suite.addTest(BindingsNameTest.suite());\n        suite.addTest(CallHierarchyTest.suite());\n        suite.addTest(ClassPathDetectorTest.suite());\n        suite.addTest(CodeFormatterUtilTest.suite());\n        suite.addTest(CodeFormatterTest.suite());\n        suite.addTest(HierarchicalASTVisitorTest.suite());\n        suite.addTest(ImportOrganizeTest.suite());\n        suite.addTest(ImportOrganizeTest18.suite());\n        suite.addTest(JavaElementLabelsTest.suite());\n        suite.addTest(JavaElementLabelsTest18.suite());\n        suite.addTest(BindingLabelsTest.suite());\n        suite.addTest(BindingLabels18Test.suite());\n        suite.addTest(JavaElementPropertyTesterTest.suite());\n        suite.addTest(JavaModelUtilTest.suite());\n        suite.addTest(MethodOverrideTest.suite());\n        suite.addTest(MethodOverrideTest18.suite());\n        suite.addTest(NameProposerTest.suite());\n        suite.addTest(OverrideTest.suite());\n        suite.addTest(PartialASTTest.suite());\n        suite.addTest(ScopeAnalyzerTest.suite());\n        suite.addTest(TemplateStoreTest.suite());\n        suite.addTest(TypeHierarchyTest.suite());\n        suite.addTest(TypeRulesTest.suite());\n        suite.addTest(TypeInfoTest.suite());\n        suite.addTest(StringsTest.suite());\n        suite.addTest(IndentManipulationTest.suite());\n        suite.addTest(SelectionHistoryTest.suite());\n        suite.addTest(ASTProviderTest.suite());\n        suite.addTest(JDTFlagsTest18.suite());\n        return new ProjectTestSetup(suite);\n    }\n\n    public  CoreTests(String name) {\n        super(name);\n    }\n\n    public static void assertEqualString(String actual, String expected) {\n        StringAsserts.assertEqualString(actual, expected);\n    }\n\n    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {\n        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);\n    }\n\n    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {\n        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);\n    }\n\n    public static void assertNumberOf(String name, int is, int expected) {\n        assertTrue(\"Wrong number of \" + name + \", is: \" + is + \", expected: \" + expected, is == expected);\n    }\n\n    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {\n        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n\n    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {\n        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.ui/10378.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "d93af83b46884f4e33c75a2aeeab3e3f01c313cc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CoreTests extends TestCase {\n    public static Test suite() {\n        TestSuite suite = new TestSuite(CoreTests.class.getName());\n        suite.addTest(AddImportTest.suite());\n        suite.addTest(SourceActionTests.suite());\n        suite.addTest(ASTNodesInsertTest.suite());\n        suite.addTest(BindingsNameTest.suite());\n        suite.addTest(CallHierarchyTest.suite());\n        suite.addTest(ClassPathDetectorTest.suite());\n        suite.addTest(CodeFormatterUtilTest.suite());\n        suite.addTest(CodeFormatterTest.suite());\n        suite.addTest(HierarchicalASTVisitorTest.suite());\n        suite.addTest(ImportOrganizeTest.suite());\n        suite.addTest(ImportOrganizeTest18.suite());\n        suite.addTest(JavaElementLabelsTest.suite());\n        suite.addTest(JavaElementLabelsTest18.suite());\n        suite.addTest(BindingLabelsTest.suite());\n        suite.addTest(BindingLabels18Test.suite());\n        suite.addTest(JavaElementPropertyTesterTest.suite());\n        suite.addTest(JavaModelUtilTest.suite());\n        suite.addTest(MethodOverrideTest.suite());\n        suite.addTest(MethodOverrideTest18.suite());\n        suite.addTest(NameProposerTest.suite());\n        suite.addTest(OverrideTest.suite());\n        suite.addTest(PartialASTTest.suite());\n        suite.addTest(ScopeAnalyzerTest.suite());\n        suite.addTest(TemplateStoreTest.suite());\n        suite.addTest(TypeHierarchyTest.suite());\n        suite.addTest(TypeRulesTest.suite());\n        suite.addTest(TypeInfoTest.suite());\n        suite.addTest(StringsTest.suite());\n        suite.addTest(IndentManipulationTest.suite());\n        suite.addTest(SelectionHistoryTest.suite());\n        suite.addTest(ASTProviderTest.suite());\n        suite.addTest(JDTFlagsTest18.suite());\n        return new ProjectTestSetup(suite);\n    }\n    public  CoreTests(String name) {\n        super(name);\n    }\n    public static void assertEqualString(String actual, String expected) {\n        StringAsserts.assertEqualString(actual, expected);\n    }\n    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {\n        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);\n    }\n    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {\n        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);\n    }\n    public static void assertNumberOf(String name, int is, int expected) {\n        assertTrue(\"Wrong number of \" + name + \", is: \" + is + \", expected: \" + expected, is == expected);\n    }\n    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {\n        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {\n        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n"]], "pred": {"ppl": 1.9211866855621338, "ppl_lower": 2.316457986831665, "ppl/lowercase_ppl": -1.2865429468917144, "ppl/zlib": 0.0008286079448133024, "Min_5.0% Prob": 6.803606266671038, "Min_10.0% Prob": 5.060155447493208, "Min_20.0% Prob": 3.14516585308408, "Min_30.0% Prob": 2.164325868335714, "Min_40.0% Prob": 1.629402067361981, "Min_50.0% Prob": 1.3064916531133102, "Min_60.0% Prob": 1.0880621614191694}}
{"hexsha": "ffa7aaacd75d5ecdbf2cb0c38e1b729e373cae89", "ext": "java", "lang": "Java", "content": "public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {\n\n\n    private HashMap<String,HashMap<String,int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();\n    private int m_countSpectra = 0;\n    private int m_groups = 10;\n\n\n    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {\n        FragmentationSite fs = f.getFragmentationSites()[0];\n        String[] siteNames = new String[]{fs.NTerm.SequenceID,fs.CTerm.SequenceID};\n\n\n        if (fs.site==0) {\n            siteNames[0] += \"nt\";\n        }\n        if (fs.site == fs.peptide.length() - 1) {\n            siteNames[1] += \"ct\";\n        }\n\n        if (fs.site == match.getLinkingSite(fs.peptide)) {\n            siteNames[0] += \"xl\";\n        }\n\n        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {\n            siteNames[1] += \"xl\";\n        }\n\n        return siteNames;\n\n    }\n\n    protected boolean checkCrosslinked(Fragment f, int linkSide) {\n        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        }\n        return false;\n    }\n\n\n    /**\n     * @return the m_countSpectra\n     */\n    public int getSeenSpectra() {\n        return m_countSpectra;\n    }\n\n\n    // <editor-fold desc=\"construtors\">\n\n    public FragmentationSiteIntensityIonSpecific() {\n    }\n\n    // </editor-fold>\n    \n\n\n    public boolean validFragment(Fragment f) {\n        // no loss and no double fragmentation\n        return (! (f instanceof Loss)) && f.getFragmentationSites().length == 1;\n\n    }\n\n    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {\n        if (f.getFragmentationSites().length != 1) {\n            return false;\n        }\n        if (f instanceof Loss) {\n            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f,charge);\n            return mbf.isBaseFragmentFound();\n        } else\n            return true;\n    }\n\n    private void incrementSite(String n, String c, int group) {\n       HashMap<String,int[]> nGroup = m_FragmentationSiteOccurence.get(n);\n        if (nGroup == null) {\n            nGroup = new HashMap<String, int[]>();\n            int[] cGroup = new int[m_groups + 1];\n            java.util.Arrays.fill(cGroup, 0);\n            cGroup[group] = 1;\n            nGroup.put(c, cGroup);\n            m_FragmentationSiteOccurence.put(n,nGroup);\n        } else {\n            int[] cGroup = nGroup.get(c);\n            if (cGroup == null) {\n                cGroup = new int[m_groups + 1];\n                java.util.Arrays.fill(cGroup, 0);\n                cGroup[group] = 1;\n                nGroup.put(c, cGroup);\n            } else\n                cGroup[group]++;\n\n        }\n    }\n\n\n    public void countSpectraMatch(MatchedXlinkedPeptide match) {\n\n        MatchedFragmentCollection   mfc = match.getMatchedFragments();\n\n\n\n        Spectra deisotoped = match.getSpectrum().deIsotop();\n\n\n        HashMap<String,HashMap<String,Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();\n\n        HashMap<Fragment,Boolean> foundFragments = new HashMap<Fragment, Boolean>();\n\n        // read out all possible fragmentation sites\n        for (Fragment f: match.getPossibleFragments()) {\n            if (validFragment(f)) {\n                foundFragments.put(f, Boolean.FALSE);\n            }\n        }\n\n        // now look if and where we find them\n        // among all peaks sorted by intensity\n        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);\n\n        int group = 0;\n        int peakCount = peaks.size();\n        double groupSize = peakCount/(double)m_groups;\n        int currentPeak = -1;\n        int counted = 0;\n        for (SpectraPeak sp : peaks) {\n            currentPeak++;\n            group = (int) (currentPeak / groupSize);\n//            if (group > 9) {\n//                System.err.println(\"found it\");\n//            }\n\n            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {\n                Fragment f = mf.getFragment();\n                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());\n                \n                // only if the fragment matches the conditions and was not found yet\n                if (canCountFragment(f,mf.getCharge(),mfc) && ! foundFragments.get(mbf.getBaseFragment())) {\n\n                    String[] siteNames = convertFragmentationSite(match, f);\n                    String n = siteNames[0];\n                    String c = siteNames[1];\n\n                    // only if we didn't count that site combination already\n                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);\n                    incrementSite(n,c,group);\n                    counted++;\n \n                }\n            }\n        }\n\n        int found = 0;\n        int missed = 0;\n        // now look at all non matched fragmentation sites\n        for (Fragment f : foundFragments.keySet()) {\n            if (! foundFragments.get(f)) {\n                missed ++;\n\n                String[] siteNames = convertFragmentationSite(match, f);\n                String n = siteNames[0];\n                String c = siteNames[1];\n\n                incrementSite(n,c,m_groups);\n            } else {\n                found++;\n                //System.err.print('.');\n            }\n       }\n       System.err.println(\"counted : \" + counted + \",  found : \" + found + \",  missed : \" + missed);\n\n\n        m_countSpectra++;\n\n        \n\n    }\n\n    @Override\n    public void writeFile(OutputStream output) {\n        PrintStream out = new PrintStream(output);\n        out.print(\"C,N\");\n        for (int i=1;i<=m_groups;i++) {\n            out.print(\",\"+ (100.0 * i/(double)m_groups));\n        }\n        out.print(\", notFound\");\n        out.println(getTable());\n        out.flush();\n    }\n\n\n    public String getTable() {\n        //StringBuffer ret = new StringBuffer(\"#intesity based fragmentation events of aminoacid pairs\\n\");\n        StringBuffer ret = new StringBuffer();\n        String[] nList =  m_FragmentationSiteOccurence.keySet().toArray(new String[0]);\n        java.util.Arrays.sort(nList);\n\n        for (String n : nList) {\n            HashMap<String,int[]> cGroups = m_FragmentationSiteOccurence.get(n);\n            String[] cList = cGroups.keySet().toArray(new String[0]);\n            java.util.Arrays.sort(cList);\n            for (String c : cList) {\n                int[] groups = cGroups.get(c);\n                ret.append(n + \",\" + c);\n                for (int count : groups) {\n                    ret.append(\",\" + count);\n                }\n                ret.append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }\n\n\n}", "class_id": 0, "repo": "MireiaDiaz/XiSearch", "file": "src/main/java/rappsilber/ms/statistics/generator/FragmentationSiteIntensityIonSpecific.java", "last_update_at": "2021-02-16T00:30:24+00:00", "question_id": "ffa7aaacd75d5ecdbf2cb0c38e1b729e373cae89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {\n    private HashMap<String,HashMap<String,int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();\n    private int m_countSpectra = 0;\n    private int m_groups = 10;\n    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {\n        FragmentationSite fs = f.getFragmentationSites()[0];\n        String[] siteNames = new String[]{fs.NTerm.SequenceID,fs.CTerm.SequenceID};\n        if (fs.site==0) {\n            siteNames[0] += \"nt\";\n        }\n        if (fs.site == fs.peptide.length() - 1) {\n            siteNames[1] += \"ct\";\n        }\n        if (fs.site == match.getLinkingSite(fs.peptide)) {\n            siteNames[0] += \"xl\";\n        }\n        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {\n            siteNames[1] += \"xl\";\n        }\n        return siteNames;\n    }\n    protected boolean checkCrosslinked(Fragment f, int linkSide) {\n        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @return the m_countSpectra\n     */\n    public int getSeenSpectra() {\n        return m_countSpectra;\n    }\n    // <editor-fold desc=\"construtors\">\n    public FragmentationSiteIntensityIonSpecific() {\n    }\n    // </editor-fold>\n    public boolean validFragment(Fragment f) {\n        // no loss and no double fragmentation\n        return (! (f instanceof Loss)) && f.getFragmentationSites().length == 1;\n    }\n    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {\n        if (f.getFragmentationSites().length != 1) {\n            return false;\n        }\n        if (f instanceof Loss) {\n            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f,charge);\n            return mbf.isBaseFragmentFound();\n        } else\n            return true;\n    }\n    private void incrementSite(String n, String c, int group) {\n       HashMap<String,int[]> nGroup = m_FragmentationSiteOccurence.get(n);\n        if (nGroup == null) {\n            nGroup = new HashMap<String, int[]>();\n            int[] cGroup = new int[m_groups + 1];\n            java.util.Arrays.fill(cGroup, 0);\n            cGroup[group] = 1;\n            nGroup.put(c, cGroup);\n            m_FragmentationSiteOccurence.put(n,nGroup);\n        } else {\n            int[] cGroup = nGroup.get(c);\n            if (cGroup == null) {\n                cGroup = new int[m_groups + 1];\n                java.util.Arrays.fill(cGroup, 0);\n                cGroup[group] = 1;\n                nGroup.put(c, cGroup);\n            } else\n                cGroup[group]++;\n        }\n    }\n    public void countSpectraMatch(MatchedXlinkedPeptide match) {\n        MatchedFragmentCollection   mfc = match.getMatchedFragments();\n        Spectra deisotoped = match.getSpectrum().deIsotop();\n        HashMap<String,HashMap<String,Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();\n        HashMap<Fragment,Boolean> foundFragments = new HashMap<Fragment, Boolean>();\n        // read out all possible fragmentation sites\n        for (Fragment f: match.getPossibleFragments()) {\n            if (validFragment(f)) {\n                foundFragments.put(f, Boolean.FALSE);\n            }\n        }\n        // now look if and where we find them\n        // among all peaks sorted by intensity\n        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);\n        int group = 0;\n        int peakCount = peaks.size();\n        double groupSize = peakCount/(double)m_groups;\n        int currentPeak = -1;\n        int counted = 0;\n        for (SpectraPeak sp : peaks) {\n            currentPeak++;\n            group = (int) (currentPeak / groupSize);\n//            if (group > 9) {\n//                System.err.println(\"found it\");\n//            }\n            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {\n                Fragment f = mf.getFragment();\n                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());\n                // only if the fragment matches the conditions and was not found yet\n                if (canCountFragment(f,mf.getCharge(),mfc) && ! foundFragments.get(mbf.getBaseFragment())) {\n                    String[] siteNames = convertFragmentationSite(match, f);\n                    String n = siteNames[0];\n                    String c = siteNames[1];\n                    // only if we didn't count that site combination already\n                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);\n                    incrementSite(n,c,group);\n                    counted++;\n                }\n            }\n        }\n        int found = 0;\n        int missed = 0;\n        // now look at all non matched fragmentation sites\n        for (Fragment f : foundFragments.keySet()) {\n            if (! foundFragments.get(f)) {\n                missed ++;\n                String[] siteNames = convertFragmentationSite(match, f);\n                String n = siteNames[0];\n                String c = siteNames[1];\n                incrementSite(n,c,m_groups);\n            } else {\n                found++;\n                //System.err.print('.');\n            }\n       }\n       System.err.println(\"counted : \" + counted + \",  found : \" + found + \",  missed : \" + missed);\n        m_countSpectra++;\n    }\n    @Override\n    public void writeFile(OutputStream output) {\n        PrintStream out = new PrintStream(output);\n        out.print(\"C,N\");\n        for (int i=1;i<=m_groups;i++) {\n            out.print(\",\"+ (100.0 * i/(double)m_groups));\n        }\n        out.print(\", notFound\");\n        out.println(getTable());\n        out.flush();\n    }\n    public String getTable() {\n        //StringBuffer ret = new StringBuffer(\"#intesity based fragmentation events of aminoacid pairs\\n\");\n        StringBuffer ret = new StringBuffer();\n        String[] nList =  m_FragmentationSiteOccurence.keySet().toArray(new String[0]);\n        java.util.Arrays.sort(nList);\n        for (String n : nList) {\n            HashMap<String,int[]> cGroups = m_FragmentationSiteOccurence.get(n);\n            String[] cList = cGroups.keySet().toArray(new String[0]);\n            java.util.Arrays.sort(cList);\n            for (String c : cList) {\n                int[] groups = cGroups.get(c);\n                ret.append(n + \",\" + c);\n                for (int count : groups) {\n                    ret.append(\",\" + count);\n                }\n                ret.append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }\n"]], "pred": {"ppl": 2.429030656814575, "ppl_lower": 2.6608266830444336, "ppl/lowercase_ppl": -1.102699020002584, "ppl/zlib": 0.00046661002687032666, "Min_5.0% Prob": 7.155012841318168, "Min_10.0% Prob": 5.522022850373212, "Min_20.0% Prob": 3.7692482161755656, "Min_30.0% Prob": 2.8013692490415636, "Min_40.0% Prob": 2.1784868775923854, "Min_50.0% Prob": 1.7668387771177665, "Min_60.0% Prob": 1.478654387302174}}
{"hexsha": "3ede65710f688d01a47e728a22d61210d6155313", "ext": "java", "lang": "Java", "content": "public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest\n        implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {\n\n    public static final String COLOR = \"color\";\n    public static final String IS_MUTED = \"is_muted\";\n    public static final String PIN_TO_TOP = \"pin_to_top\";\n    public static final String DESKTOP_NOTIFICATIONS = \"desktop_notifications\";\n    public static final String AUDIBLE_NOTIFICATIONS = \"audible_notifications\";\n    public static final String PUSH_NOTIFICATIONS = \"push_notifications\";\n    public static final String EMAIL_NOTIFICATIONS = \"email_notifications\";\n    public static final String SUBSCRIPTION_DATA = \"subscription_data\";\n\n    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();\n\n    /**\n     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.\n     *\n     * @param client The Zulip HTTP client\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {\n        super(client);\n    }\n\n    /**\n     * Sets the hex value of the color to display on the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  color    The hex value of the color\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {\n        addSetting(streamId, COLOR, color);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be muted.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {\n        addSetting(streamId, IS_MUTED, muted);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be pinned to the top in the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {\n        addSetting(streamId, PIN_TO_TOP, pinToTop);\n        return this;\n    }\n\n    /**\n     * Sets whether to show desktop notifications for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {\n        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to play a sound for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {\n        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId          The id of the stream for which the setting should be updated\n     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push\n     *                           notifications.\n     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {\n        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId           The id of the stream for which the setting should be updated\n     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.\n     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {\n        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);\n        return this;\n    }\n\n    private void addSetting(long streamId, String property, Object value) {\n        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);\n        settings.remove(setting);\n        settings.add(setting);\n    }\n\n    /**\n     * Executes the Zulip API request for updating stream subscription settings.\n     *\n     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}\n     * @throws ZulipClientException if the request was not successful\n     */\n    @Override\n    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {\n        putParamAsJsonString(SUBSCRIPTION_DATA, settings);\n\n        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(),\n                UpdateStreamSubscriptionSettingsApiResponse.class);\n        return response.getSubscriptionData();\n    }\n}", "class_id": 0, "repo": "mrchaos/zulip-java-client", "file": "src/main/java/com/github/jamesnetherton/zulip/client/api/stream/request/UpdateStreamSubscriptionSettingsApiRequest.java", "last_update_at": "2021-12-10T13:20:55+00:00", "question_id": "3ede65710f688d01a47e728a22d61210d6155313", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest\n        implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {\n    public static final String COLOR = \"color\";\n    public static final String IS_MUTED = \"is_muted\";\n    public static final String PIN_TO_TOP = \"pin_to_top\";\n    public static final String DESKTOP_NOTIFICATIONS = \"desktop_notifications\";\n    public static final String AUDIBLE_NOTIFICATIONS = \"audible_notifications\";\n    public static final String PUSH_NOTIFICATIONS = \"push_notifications\";\n    public static final String EMAIL_NOTIFICATIONS = \"email_notifications\";\n    public static final String SUBSCRIPTION_DATA = \"subscription_data\";\n    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();\n    /**\n     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.\n     *\n     * @param client The Zulip HTTP client\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {\n        super(client);\n    }\n    /**\n     * Sets the hex value of the color to display on the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  color    The hex value of the color\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {\n        addSetting(streamId, COLOR, color);\n        return this;\n    }\n    /**\n     * Sets whether the stream should be muted.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {\n        addSetting(streamId, IS_MUTED, muted);\n        return this;\n    }\n    /**\n     * Sets whether the stream should be pinned to the top in the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {\n        addSetting(streamId, PIN_TO_TOP, pinToTop);\n        return this;\n    }\n    /**\n     * Sets whether to show desktop notifications for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {\n        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);\n        return this;\n    }\n    /**\n     * Sets whether to play a sound for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {\n        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);\n        return this;\n    }\n    /**\n     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId          The id of the stream for which the setting should be updated\n     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push\n     *                           notifications.\n     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {\n        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);\n        return this;\n    }\n    /**\n     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId           The id of the stream for which the setting should be updated\n     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.\n     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {\n        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);\n        return this;\n    }\n    private void addSetting(long streamId, String property, Object value) {\n        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);\n        settings.remove(setting);\n        settings.add(setting);\n    }\n    /**\n     * Executes the Zulip API request for updating stream subscription settings.\n     *\n     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}\n     * @throws ZulipClientException if the request was not successful\n     */\n    @Override\n    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {\n        putParamAsJsonString(SUBSCRIPTION_DATA, settings);\n        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(),\n                UpdateStreamSubscriptionSettingsApiResponse.class);\n        return response.getSubscriptionData();\n    }\n"]], "pred": {"ppl": 1.3199671506881714, "ppl_lower": 1.4600374698638916, "ppl/lowercase_ppl": -1.363302451192326, "ppl/zlib": 0.00023328306760195578, "Min_5.0% Prob": 3.8641318456799376, "Min_10.0% Prob": 2.4919119640892626, "Min_20.0% Prob": 1.3704319754432814, "Min_30.0% Prob": 0.9250464679314176, "Min_40.0% Prob": 0.6937786530592868, "Min_50.0% Prob": 0.5555920391735382, "Min_60.0% Prob": 0.4632267572578148}}
{"hexsha": "8ed1c75425218a94e5c8b30fb96444eeac5d7691", "ext": "java", "lang": "Java", "content": "public class PointPlot extends Plot2D {\n\tprotected double m_x;\n\tprotected double m_y;\n\tprotected boolean m_first;\n\t\n\tpublic PointPlot(double x, double y, ChartX chart, Color color)\n\t{\n\t\tsuper(chart, color);\n\t\tm_maxX=m_minX=m_x=x;\n\t\tm_maxY=m_minY=m_y=y;\n\t}\n\t\n\tpublic void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY)\n\t{\n\t\tg.setColor(m_color);\n\t\t\n\t\tint GX=projectX(m_x, minGX, maxGX);\n\t\tint GY=projectY(m_y, minGY, maxGY);\n\t\tg.fillOval(GX-5, GY-5, 10, 10);\n\t}\n\t\n\t\n\n}", "class_id": 0, "repo": "chen0040/cpp-ogre-mllab", "file": "ML/src/visualizer/simpleui/PointPlot.java", "last_update_at": "2021-10-04T09:40:26+00:00", "question_id": "8ed1c75425218a94e5c8b30fb96444eeac5d7691", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PointPlot extends Plot2D {\n\tprotected double m_x;\n\tprotected double m_y;\n\tprotected boolean m_first;\n\t\n\tpublic PointPlot(double x, double y, ChartX chart, Color color)\n\t{\n\t\tsuper(chart, color);\n\t\tm_maxX=m_minX=m_x=x;\n\t\tm_maxY=m_minY=m_y=y;\n\t}\n\t\n\tpublic void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY)\n\t{\n\t\tg.setColor(m_color);\n\t\t\n\t\tint GX=projectX(m_x, minGX, maxGX);\n\t\tint GY=projectY(m_y, minGY, maxGY);\n\t\tg.fillOval(GX-5, GY-5, 10, 10);\n\t}\n\t\n\t\n"]], "pred": {"ppl": 2.0993263721466064, "ppl_lower": 2.308241605758667, "ppl/lowercase_ppl": -1.1279225915562894, "ppl/zlib": 0.0027775899554372116, "Min_5.0% Prob": 7.610102653503418, "Min_10.0% Prob": 5.30533188322316, "Min_20.0% Prob": 3.359289505380265, "Min_30.0% Prob": 2.3967868731894963, "Min_40.0% Prob": 1.8520517859687196, "Min_50.0% Prob": 1.4840392413059786, "Min_60.0% Prob": 1.2358366266929244}}
{"hexsha": "58a1281ad64f50e807c784278332fa731843ae46", "ext": "java", "lang": "Java", "content": "public class FCBlockTorchBaseBurning extends FCBlockTorchBase\r\n{\r\n    protected FCBlockTorchBaseBurning( int iBlockID )\r\n    {\r\n    \tsuper( iBlockID );\r\n    }\r\n    \r\n    @Override\r\n    public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )\r\n    {\r\n    \treturn true;\r\n    }    \r\n    \r\n    @Override\r\n\tpublic void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid newBlock )\r\n\t{\r\n    \tif ( newBlock.blockMaterial == Material.water )\r\n    \t{\r\n\t        world.playAuxSFX( FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0 );\r\n\t        \r\n\t        dropBlockAsItem_do( world, i, j, k, new ItemStack( FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0 ) );\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tsuper.OnFluidFlowIntoBlock( world, i, j, k, newBlock );\r\n    \t}\r\n\t}\r\n\r\n\t//----------- Client Side Functionality -----------//\r\n    \r\n    @Override\r\n    public void randomDisplayTick( World world, int i, int j, int k, Random rand )\r\n    {\r\n    \tVec3 pos = GetParticalPos( world, i, j, k );\r\n    \t\r\n        world.spawnParticle( \"smoke\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n        world.spawnParticle( \"flame\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n    }\r\n    \r\n    protected Vec3 GetParticalPos( World world, int i, int j, int k )\r\n    {\r\n    \tVec3 pos = Vec3.createVectorHelper( i + 0.5D, j + 0.92D, k + 0.5D );\r\n    \t\r\n        int iOrientation = GetOrientation( world, i, j, k );\r\n        \r\n        double dHorizontalOffset = 0.27D;\r\n\r\n        if ( iOrientation == 1 )\r\n        {\r\n        \tpos.xCoord -= dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 2 )\r\n        {\r\n        \tpos.xCoord += dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 3 )\r\n        {\r\n        \tpos.zCoord -= dHorizontalOffset;        \t\r\n        }\r\n        else if ( iOrientation == 4 )\r\n        {\r\n        \tpos.zCoord += dHorizontalOffset;\r\n        }\r\n        else\r\n        {\r\n        \tpos.yCoord -= 0.22D;\r\n        }\r\n        \r\n    \treturn \tpos;\r\n    }\r\n}", "class_id": 0, "repo": "sargunv/better-than-wolves-mod", "file": "Src/FCBlockTorchBaseBurning.java", "last_update_at": "2021-04-11T22:29:23+00:00", "question_id": "58a1281ad64f50e807c784278332fa731843ae46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FCBlockTorchBaseBurning extends FCBlockTorchBase\r\n{\r\n    protected FCBlockTorchBaseBurning( int iBlockID )\r\n    {\r\n    \tsuper( iBlockID );\r\n    }\r\n    \r\n    @Override\r\n    public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )\r\n    {\r\n    \treturn true;\r\n    }    \r\n    \r\n    @Override\r\n\tpublic void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid newBlock )\r\n\t{\r\n    \tif ( newBlock.blockMaterial == Material.water )\r\n    \t{\r\n\t        world.playAuxSFX( FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0 );\r\n\t        \r\n\t        dropBlockAsItem_do( world, i, j, k, new ItemStack( FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0 ) );\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tsuper.OnFluidFlowIntoBlock( world, i, j, k, newBlock );\r\n    \t}\r\n\t}\r\n\r\n\t//----------- Client Side Functionality -----------//\r\n    \r\n    @Override\r\n    public void randomDisplayTick( World world, int i, int j, int k, Random rand )\r\n    {\r\n    \tVec3 pos = GetParticalPos( world, i, j, k );\r\n    \t\r\n        world.spawnParticle( \"smoke\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n        world.spawnParticle( \"flame\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n    }\r\n    \r\n    protected Vec3 GetParticalPos( World world, int i, int j, int k )\r\n    {\r\n    \tVec3 pos = Vec3.createVectorHelper( i + 0.5D, j + 0.92D, k + 0.5D );\r\n    \t\r\n        int iOrientation = GetOrientation( world, i, j, k );\r\n        \r\n        double dHorizontalOffset = 0.27D;\r\n\r\n        if ( iOrientation == 1 )\r\n        {\r\n        \tpos.xCoord -= dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 2 )\r\n        {\r\n        \tpos.xCoord += dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 3 )\r\n        {\r\n        \tpos.zCoord -= dHorizontalOffset;        \t\r\n        }\r\n        else if ( iOrientation == 4 )\r\n        {\r\n        \tpos.zCoord += dHorizontalOffset;\r\n        }\r\n        else\r\n        {\r\n        \tpos.yCoord -= 0.22D;\r\n        }\r\n        \r\n    \treturn \tpos;\r\n    }\r\n"]], "pred": {"ppl": 1.5092029571533203, "ppl_lower": 2.1474952697753906, "ppl/lowercase_ppl": -1.8569878851729957, "ppl/zlib": 0.0006097506200353825, "Min_5.0% Prob": 5.066125051395313, "Min_10.0% Prob": 3.358612162272135, "Min_20.0% Prob": 1.9795303803682327, "Min_30.0% Prob": 1.3652612661984231, "Min_40.0% Prob": 1.0274266639068426, "Min_50.0% Prob": 0.8238027771963351, "Min_60.0% Prob": 0.6870784561567683}}
{"hexsha": "76e896093e16ee748c72b09602331499e4880900", "ext": "java", "lang": "Java", "content": "public final class ClassTools {\n\n    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];\n    public static final Object[] ZERO_PARAMETERS = new Object[0];\n    private static final String CR = StringTools.CR;\n\n    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';\n\n    public static final char ARRAY_INDICATOR = '[';\n\n    public static final char REFERENCE_CLASS_CODE = 'L';\n    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';\n\n    private static PrimitiveClassCode[] primitiveClassCodes;\n    public static final char BYTE_CODE = 'B';\n    public static final char CHAR_CODE = 'C';\n    public static final char DOUBLE_CODE = 'D';\n    public static final char FLOAT_CODE = 'F';\n    public static final char INT_CODE = 'I';\n    public static final char LONG_CODE = 'J';\n    public static final char SHORT_CODE = 'S';\n    public static final char BOOLEAN_CODE = 'Z';\n    public static final char VOID_CODE = 'V';\n\n\n    /**\n     * Return all the fields for the\n     * specified class, including inherited fields.\n     * Class#allFields()\n     */\n    public static Field[] allFields(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredFields(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Field[]) stack.toArray(new Field[stack.size()]);\n    }\n\n    /**\n     * Return all the methods for the\n     * specified class, including inherited methods.\n     * Class#allMethods()\n     */\n    public static Method[] allMethods(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredMethods(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Method[]) stack.toArray(new Method[stack.size()]);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Throw an exception if the default constructor is not defined.\n     * Class#newInstance() throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        try {\n            return constructor(javaClass, parameterTypes).newInstance(parameters);\n        } catch (InstantiationException ie) {\n            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Attempt to get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#getFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(object, fieldName).get(object);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to get a static field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(javaClass, fieldName).get(null);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument method,\n     * given the receiver and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * If the invoked method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable, NoSuchMethodException\n    {\n        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Attempt to set a field value, given the\n     * containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(object, fieldName).set(object, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to set a static field value, given the\n     * containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(javaClass, fieldName).set(null, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor() throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return the constructor for the specified class\n     * and formal parameter types.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {\n        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);\n        constructor.setAccessible(true);\n        return constructor;\n    }\n\n    /**\n     * Convenience method.\n     * Return the constructor for the specified class\n     * and formal parameter type.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class parameterType) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {\n        return constructor(javaClass, new Class[] {parameterType});\n    }\n\n    /**\n     * Return the declared fields for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     * Class#accessibleDeclaredFields()\n     */\n    public static Field[] declaredFields(Class javaClass) {\n        Field[] fields = javaClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n        return fields;\n    }\n\n    /**\n     * Return the declared methods for the\n     * specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     * Class#accessibleDeclaredMethods()\n     */\n    public static Method[] declaredMethods(Class javaClass) {\n        Method[] methods = javaClass.getDeclaredMethods();\n        for (int i = 0; i < methods.length; i++) {\n            methods[i].setAccessible(true);\n        }\n        return methods;\n    }\n\n    /**\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#defaultConstructor()\n     */\n    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass);\n    }\n\n    /**\n     * Return a field for the specified class and field name.\n     * If the class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {\n        Field field = null;\n        try {\n            field = javaClass.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return field(superclass, fieldName);\n        }\n        field.setAccessible(true);\n        return field;\n    }\n\n    /**\n     * Convenience method.\n     * Return a field for the specified object and field name.\n     * If the object's class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Object object, String fieldName) throws NoSuchFieldException {\n        return field(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified constructor.\n     */\n    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        sb.append('.');\n        sb.append(fieldName);\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Object object, String fieldName) {\n        return fullyQualifiedFieldName(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        // this check allows us to use this code for constructors, where the methodName is null\n        if (methodName != null) {\n            sb.append('.');\n            sb.append(methodName);\n        }\n        sb.append('(');\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sb.append(parameterTypes[i].getName());\n            if (i < parameterTypes.length - 1)\n                sb.append(\", \");\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Object#getFieldValue(String fieldName)\n     */\n    public static Object getFieldValue(Object object, String fieldName) {\n        try {\n            return attemptToGetFieldValue(object, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Get a static field value, given the containing class and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Class#getStaticFieldValue(String fieldName)\n     */\n    public static Object getStaticFieldValue(Class javaClass, String fieldName) {\n        try {\n            return attemptToGetStaticFieldValue(javaClass, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethod(Object receiver, String methodName) {\n        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {\n        return invokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(method + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Convert all other exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause == null) {\n                throw new RuntimeException(method.toString(), ite);\n            }\n            throw cause;\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName) {\n        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {\n        return invokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Invoke the specified static method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeStaticMethod(Method method, Object[] parameters) {\n        return invokeMethod(method, null, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {\n        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = null;\n        try {\n            method = javaClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return method(superclass, methodName, parameterTypes);\n        }\n        method.setAccessible(true);\n        return method;\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(javaClass, methodName, new Class[] {parameterType});\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified object\n     * and method name. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName) throws NoSuchMethodException {\n        return method(object.getClass(), methodName);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter types. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter type. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterType);\n    }\n\n    /**\n     * Convenience method.\n     * Return the specified class (w/o the checked exception).\n     */\n    public static Class classForName(String className) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(className, ex);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(Class javaClass) {\n        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className) throws ClassNotFoundException {\n        return newInstance(className, null);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader));\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptNewInstance(javaClass, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {\n        return newInstance(className, parameterTypes, parameters, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {\n        return newInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {\n        return newInstance(className, parameterType, parameter, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);\n    }\n\n    /**\n     * Push the declared fields for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredFields(Class javaClass, Stack stack) {\n        Field[] fields = declaredFields(javaClass);\n        for (int i = fields.length - 1; i >= 0; i--) {\n            stack.push(fields[i]);\n        }\n    }\n\n    /**\n     * Push the declared methods for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredMethods(Class javaClass, Stack stack) {\n        Method[] methods = declaredMethods(javaClass);\n        for (int i = methods.length - 1; i >= 0; i--) {\n            stack.push(methods[i]);\n        }\n    }\n\n    /**\n     * Set a field value, given the containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Object#setFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetFieldValue(object, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Set a static field value, given the containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Return the short name of the object's class.\n     * Class#getShortName()\n     */\n    public static String shortClassNameForObject(Object object) {\n        return shortNameFor(object.getClass());\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameFor(Class javaClass) {\n        return shortNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the nested name of the object's class.\n     * Class#getNestedName()\n     */\n    public static String nestedClassNameForObject(Object object) {\n        return nestedNameFor(object.getClass());\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameFor(Class javaClass) {\n        return nestedNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the \"toString()\" name of the object's class.\n     */\n    public static String toStringClassNameForObject(Object object) {\n        return toStringNameFor(object.getClass());\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     * \"Member\" classes will return only the final name:\n     *     \"com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass\"\n     *         => \"NestedMemberClass\"\n     * \"Local\" and \"anonymous\" classes will still return the embedded '$'s:\n     *     \"com.foo.bar.TopLevelClass$1LocalClass\"\n     *         => \"TopLevelClass$1LocalClass\"\n     *     \"com.foo.bar.TopLevelClass$1\"\n     *         => \"TopLevelClass$1\"\n     */\n    public static String toStringNameForClassNamed(String className) {\n        return classNamedIsMember(className) ?\n            className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1)\n        :\n            className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     */\n    public static String toStringNameFor(Class javaClass) {\n        return toStringNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameFor(Class javaClass) {\n        return packageNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameForClassNamed(String className) {\n        int lastPeriod = className.lastIndexOf('.');\n        if (lastPeriod == -1) {\n            return \"\";\n        }\n        return className.substring(0, lastPeriod);\n    }\n\n    /**\n     * Return the short name of the class,\n     * followed by its package name (e.g. \"Object (java.lang)\").\n     * Class#getShortNameWithPackage()\n     */\n    public static String shortNameWithPackage(Class javaClass) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(shortNameFor(javaClass));\n        if ( ! javaClass.isPrimitive()) {\n            sb.append(\" (\");\n            sb.append(packageNameFor(javaClass));\n            sb.append(')');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument, static method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a static method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = method(javaClass, methodName, parameterTypes);\n        if (Modifier.isStatic(method.getModifiers())) {\n            return method;\n        }\n        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));\n    }\n\n    /**\n     * Convenience method.\n     * Return a static method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, new Class[] {parameterTypes});\n    }\n\n    /**\n     * Return whether the specified class can be \"declared\" in code;\n     * i.e. it is either a \"top-level\" class or a \"member\" class, but it\n     * is not an \"array\" class. This method rolls together all the checks\n     * from the other methods for a bit of a performance tweak.\n     * Class#isDeclarable()\n     */\n    public static boolean classNamedIsDeclarable(String className) {\n        if (className.charAt(0) == ARRAY_INDICATOR) {\n            return false;        // it is an \"array\" class\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return true;        // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"top-level\" class,\n     * as opposed to a \"member\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name does NOT contain a '$': \"TopLevelClass\").\n     * Class#isTopLevel()\n     */\n    public static boolean classNamedIsTopLevel(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;\n    }\n\n    /**\n     * Return whether the specified class is a \"member\" class,\n     * as opposed to a \"top-level\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name contains at least one '$' and all the names between\n     * each '$' are legal class names:\n     * \"TopLevelClass$MemberClass$NestedMemberClass\").\n     * Class#isMember()\n     */\n    public static boolean classNamedIsMember(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return false;    // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"local\" class,\n     * as opposed to a \"top-level\", \"member\", or \"anonymous\" class,\n     * using the standard jdk (or Eclipse) naming conventions.\n     * In the jdk, the class name ends with '$nnnXXX' where the '$' is\n     * followed by a series of numeric digits which are followed by the\n     * local class name: \"TopLevelClass$1LocalClass\".\n     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is\n     * followed by a series of numeric digits which are separated from\n     * the local class name by another '$': \"TopLevelClass$1$LocalClass\".\n     * Class#isLocal()\n     */\n    public static boolean classNamedIsLocal(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        if ( ! Character.isDigit(className.charAt(dollar + 1))) {\n            return false;\n        }\n        for (int i = dollar + 2; i < className.length(); i++) {\n            if (Character.isJavaIdentifierStart(className.charAt(i))) {\n                return true;\n            }\n        }\n        // all the characters past the $ are digits (anonymous)\n        return false;\n    }\n\n    /**\n     * Return whether the specified class is an \"anonymous\" class,\n     * as opposed to a \"top-level\", \"member\", or \"local\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name ends with '$nnn' where all the characters past the\n     * last '$' are numeric digits: \"TopLevelClass$1\").\n     * Class#isAnonymous()\n     */\n    public static boolean classNamedIsAnonymous(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        int start = dollar + 1;\n        for (int i = className.length(); i-- > start; ) {\n            if ( ! Character.isDigit(className.charAt(i))) {\n                return false;\n            }\n        }\n        // all the characters past the $ are digits\n        return true;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthFor(Class javaClass) {\n        int depth = 0;\n        while (javaClass.isArray()) {\n            depth++;\n            javaClass = javaClass.getComponentType();\n        }\n        return depth;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified object.\n     * The depth is the number of dimensions for an array.\n     * Non-arrays have a depth of zero.\n     */\n    public static int arrayDepthForObject(Object object) {\n        return arrayDepthFor(object.getClass());\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * @see java.lang.Class#getName()\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthForClassNamed(String className) {\n        int depth = 0;\n        while (className.charAt(depth) == ARRAY_INDICATOR) {\n            depth++;\n        }\n        return depth;\n    }\n\n    /**\n     * Return whether the specified class is an array type.\n     * @see java.lang.Class#getName()\n     */\n    public static boolean classNamedIsArray(String className) {\n        return className.charAt(0) == ARRAY_INDICATOR;\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * A non-array type simply returns itself.\n     * Class#getElementType()\n     */\n    public static Class elementTypeFor(Class javaClass) {\n        while (javaClass.isArray()) {\n            javaClass = javaClass.getComponentType();\n        }\n        return javaClass;\n    }\n\n    /**\n     * Return the \"element type\" of the specified object.\n     * The element type is the base type held by an array.\n     * A non-array simply returns its class.\n     */\n    public static Class elementTypeForObject(Object object) {\n        return elementTypeFor(object.getClass());\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * Class#getElementType()\n     */\n    public static String elementTypeNameFor(Class javaClass) {\n        return elementTypeFor(javaClass).getName();\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * @see java.lang.Class#getName()\n     * Class#getElementType()\n     */\n    public static String elementTypeNameForClassNamed(String className) {\n        int depth = arrayDepthForClassNamed(className);\n        if (depth == 0) {\n            // the name is in the form: \"java.lang.Object\" or \"int\"\n            return className;\n        }\n        int last = className.length() - 1;\n        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {\n            // the name is in the form: \"[[[Ljava.lang.Object;\"\n            return className.substring(depth + 1, last);    // drop the trailing ';'\n        }\n        // the name is in the form: \"[[[I\"\n        return classNameForCode(className.charAt(last));\n    }\n\n    /**\n     * Return whether the specified class is a \"reference\"\n     * class (i.e. not void or one of the primitives).\n     */\n    public static boolean classNamedIsReference(String className) {\n        return ! classNamedIsNonReference(className);\n    }\n\n    /**\n     * Return whether the specified class is a \"non-reference\"\n     * class (i.e. void or one of the primitives).\n     */\n    public static boolean classNamedIsNonReference(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(char classCode) {\n        return classForCode(classCode).getName();\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(int classCode) {\n        return classNameForCode((char) classCode);\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(char classCode) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].code == classCode) {\n                return codes[i].javaClass;\n            }\n        }\n        throw new IllegalArgumentException(String.valueOf(classCode));\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(int classCode) {\n        return classForCode((char) classCode);\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClass(Class javaClass) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass == javaClass) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(javaClass.getName());\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClassNamed(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(className);\n    }\n\n    /**\n     * Return the class for specified \"type declaration\".\n     */\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {\n        return classForTypeDeclaration(elementTypeName, arrayDepth, null);\n    }\n\n    /**\n     * Return the class for specified \"type declaration\",\n     * using the specified class loader.\n     */\n    // see the \"Evaluation\" of jdk bug 6446627 for a discussion of loading classes\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {\n        // primitives cannot be loaded via Class#forName(),\n        // so check for a primitive class name first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n\n        // non-array\n        if (arrayDepth == 0) {\n            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;\n        }\n\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return Class.forName(sb.toString(), false, classLoader);\n    }\n\n    /**\n     * Return the class name for specified \"type declaration\".\n     */\n    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {\n        // non-array\n        if (arrayDepth == 0) {\n            return elementTypeName;\n        }\n\n        if (elementTypeName.equals(void.class.getName())) {\n            throw new IllegalArgumentException(\"'void' must have an array depth of zero: \" + arrayDepth + '.');\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n\n        // look for a primitive first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n\n        return sb.toString();\n    }\n\n    private static PrimitiveClassCode[] getPrimitiveClassCodes() {\n        if (primitiveClassCodes == null) {\n            primitiveClassCodes = buildPrimitiveClassCodes();\n        }\n        return primitiveClassCodes;\n    }\n\n    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {\n        PrimitiveClassCode[] result = new PrimitiveClassCode[9];\n        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);\n        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);\n        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);\n        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);\n        result[4] = new PrimitiveClassCode(INT_CODE, int.class);\n        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);\n        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);\n        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);\n        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);\n        return result;\n    }\n\n    /**\n     * Suppress default constructor, ensuring non-instantiability.\n     */\n    private ClassTools() {\n        super();\n        throw new UnsupportedOperationException();\n    }\n\n\n    // ********** member class **********\n\n    private static class PrimitiveClassCode {\n        char code;\n        Class javaClass;\n        PrimitiveClassCode(char code, Class javaClass) {\n            this.code = code;\n            this.javaClass = javaClass;\n        }\n    }\n\n}", "class_id": 0, "repo": "Pandrex247/patched-src-eclipselink", "file": "utils/eclipselink.utils.workbench/utility/source/org/eclipse/persistence/tools/workbench/utility/ClassTools.java", "last_update_at": "2021-12-14T20:59:52+00:00", "question_id": "76e896093e16ee748c72b09602331499e4880900", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ClassTools {\n    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];\n    public static final Object[] ZERO_PARAMETERS = new Object[0];\n    private static final String CR = StringTools.CR;\n    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';\n    public static final char ARRAY_INDICATOR = '[';\n    public static final char REFERENCE_CLASS_CODE = 'L';\n    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';\n    private static PrimitiveClassCode[] primitiveClassCodes;\n    public static final char BYTE_CODE = 'B';\n    public static final char CHAR_CODE = 'C';\n    public static final char DOUBLE_CODE = 'D';\n    public static final char FLOAT_CODE = 'F';\n    public static final char INT_CODE = 'I';\n    public static final char LONG_CODE = 'J';\n    public static final char SHORT_CODE = 'S';\n    public static final char BOOLEAN_CODE = 'Z';\n    public static final char VOID_CODE = 'V';\n    /**\n     * Return all the fields for the\n     * specified class, including inherited fields.\n     * Class#allFields()\n     */\n    public static Field[] allFields(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredFields(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Field[]) stack.toArray(new Field[stack.size()]);\n    }\n    /**\n     * Return all the methods for the\n     * specified class, including inherited methods.\n     * Class#allMethods()\n     */\n    public static Method[] allMethods(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredMethods(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Method[]) stack.toArray(new Method[stack.size()]);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Throw an exception if the default constructor is not defined.\n     * Class#newInstance() throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        try {\n            return constructor(javaClass, parameterTypes).newInstance(parameters);\n        } catch (InstantiationException ie) {\n            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);\n        }\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Attempt to get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#getFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(object, fieldName).get(object);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n    /**\n     * Attempt to get a static field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(javaClass, fieldName).get(null);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument method,\n     * given the receiver and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * If the invoked method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable, NoSuchMethodException\n    {\n        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Attempt to set a field value, given the\n     * containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(object, fieldName).set(object, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n    /**\n     * Attempt to set a static field value, given the\n     * containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(javaClass, fieldName).set(null, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n    /**\n     * Convenience method.\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor() throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass, ZERO_PARAMETER_TYPES);\n    }\n    /**\n     * Return the constructor for the specified class\n     * and formal parameter types.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {\n        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);\n        constructor.setAccessible(true);\n        return constructor;\n    }\n    /**\n     * Convenience method.\n     * Return the constructor for the specified class\n     * and formal parameter type.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class parameterType) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {\n        return constructor(javaClass, new Class[] {parameterType});\n    }\n    /**\n     * Return the declared fields for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     * Class#accessibleDeclaredFields()\n     */\n    public static Field[] declaredFields(Class javaClass) {\n        Field[] fields = javaClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n        return fields;\n    }\n    /**\n     * Return the declared methods for the\n     * specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     * Class#accessibleDeclaredMethods()\n     */\n    public static Method[] declaredMethods(Class javaClass) {\n        Method[] methods = javaClass.getDeclaredMethods();\n        for (int i = 0; i < methods.length; i++) {\n            methods[i].setAccessible(true);\n        }\n        return methods;\n    }\n    /**\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#defaultConstructor()\n     */\n    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass);\n    }\n    /**\n     * Return a field for the specified class and field name.\n     * If the class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {\n        Field field = null;\n        try {\n            field = javaClass.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return field(superclass, fieldName);\n        }\n        field.setAccessible(true);\n        return field;\n    }\n    /**\n     * Convenience method.\n     * Return a field for the specified object and field name.\n     * If the object's class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Object object, String fieldName) throws NoSuchFieldException {\n        return field(object.getClass(), fieldName);\n    }\n    /**\n     * Return a string representation of the specified constructor.\n     */\n    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);\n    }\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        sb.append('.');\n        sb.append(fieldName);\n        return sb.toString();\n    }\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Object object, String fieldName) {\n        return fullyQualifiedFieldName(object.getClass(), fieldName);\n    }\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        // this check allows us to use this code for constructors, where the methodName is null\n        if (methodName != null) {\n            sb.append('.');\n            sb.append(methodName);\n        }\n        sb.append('(');\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sb.append(parameterTypes[i].getName());\n            if (i < parameterTypes.length - 1)\n                sb.append(\", \");\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);\n    }\n    /**\n     * Get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Object#getFieldValue(String fieldName)\n     */\n    public static Object getFieldValue(Object object, String fieldName) {\n        try {\n            return attemptToGetFieldValue(object, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n    /**\n     * Get a static field value, given the containing class and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Class#getStaticFieldValue(String fieldName)\n     */\n    public static Object getStaticFieldValue(Class javaClass, String fieldName) {\n        try {\n            return attemptToGetStaticFieldValue(javaClass, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethod(Object receiver, String methodName) {\n        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {\n        return invokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(method + CR + ite.getTargetException(), ite);\n        }\n    }\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Convert all other exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause == null) {\n                throw new RuntimeException(method.toString(), ite);\n            }\n            throw cause;\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName) {\n        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {\n        return invokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Invoke the specified static method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeStaticMethod(Method method, Object[] parameters) {\n        return invokeMethod(method, null, parameters);\n    }\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {\n        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n    /**\n     * Return a method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = null;\n        try {\n            method = javaClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return method(superclass, methodName, parameterTypes);\n        }\n        method.setAccessible(true);\n        return method;\n    }\n    /**\n     * Convenience method.\n     * Return a method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(javaClass, methodName, new Class[] {parameterType});\n    }\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified object\n     * and method name. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName) throws NoSuchMethodException {\n        return method(object.getClass(), methodName);\n    }\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter types. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterTypes);\n    }\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter type. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterType);\n    }\n    /**\n     * Convenience method.\n     * Return the specified class (w/o the checked exception).\n     */\n    public static Class classForName(String className) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(className, ex);\n        }\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(Class javaClass) {\n        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className) throws ClassNotFoundException {\n        return newInstance(className, null);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader));\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptNewInstance(javaClass, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {\n        return newInstance(className, parameterTypes, parameters, null);\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {\n        return newInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {\n        return newInstance(className, parameterType, parameter, null);\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);\n    }\n    /**\n     * Push the declared fields for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredFields(Class javaClass, Stack stack) {\n        Field[] fields = declaredFields(javaClass);\n        for (int i = fields.length - 1; i >= 0; i--) {\n            stack.push(fields[i]);\n        }\n    }\n    /**\n     * Push the declared methods for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredMethods(Class javaClass, Stack stack) {\n        Method[] methods = declaredMethods(javaClass);\n        for (int i = methods.length - 1; i >= 0; i--) {\n            stack.push(methods[i]);\n        }\n    }\n    /**\n     * Set a field value, given the containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Object#setFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetFieldValue(object, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n    /**\n     * Set a static field value, given the containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n    /**\n     * Return the short name of the object's class.\n     * Class#getShortName()\n     */\n    public static String shortClassNameForObject(Object object) {\n        return shortNameFor(object.getClass());\n    }\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf('.') + 1);\n    }\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameFor(Class javaClass) {\n        return shortNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the nested name of the object's class.\n     * Class#getNestedName()\n     */\n    public static String nestedClassNameForObject(Object object) {\n        return nestedNameFor(object.getClass());\n    }\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);\n    }\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameFor(Class javaClass) {\n        return nestedNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the \"toString()\" name of the object's class.\n     */\n    public static String toStringClassNameForObject(Object object) {\n        return toStringNameFor(object.getClass());\n    }\n    /**\n     * Return the \"toString()\" name of the class.\n     * \"Member\" classes will return only the final name:\n     *     \"com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass\"\n     *         => \"NestedMemberClass\"\n     * \"Local\" and \"anonymous\" classes will still return the embedded '$'s:\n     *     \"com.foo.bar.TopLevelClass$1LocalClass\"\n     *         => \"TopLevelClass$1LocalClass\"\n     *     \"com.foo.bar.TopLevelClass$1\"\n     *         => \"TopLevelClass$1\"\n     */\n    public static String toStringNameForClassNamed(String className) {\n        return classNamedIsMember(className) ?\n            className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1)\n        :\n            className.substring(className.lastIndexOf('.') + 1);\n    }\n    /**\n     * Return the \"toString()\" name of the class.\n     */\n    public static String toStringNameFor(Class javaClass) {\n        return toStringNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameFor(Class javaClass) {\n        return packageNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameForClassNamed(String className) {\n        int lastPeriod = className.lastIndexOf('.');\n        if (lastPeriod == -1) {\n            return \"\";\n        }\n        return className.substring(0, lastPeriod);\n    }\n    /**\n     * Return the short name of the class,\n     * followed by its package name (e.g. \"Object (java.lang)\").\n     * Class#getShortNameWithPackage()\n     */\n    public static String shortNameWithPackage(Class javaClass) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(shortNameFor(javaClass));\n        if ( ! javaClass.isPrimitive()) {\n            sb.append(\" (\");\n            sb.append(packageNameFor(javaClass));\n            sb.append(')');\n        }\n        return sb.toString();\n    }\n    /**\n     * Convenience method.\n     * Return a zero-argument, static method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n    /**\n     * Return a static method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = method(javaClass, methodName, parameterTypes);\n        if (Modifier.isStatic(method.getModifiers())) {\n            return method;\n        }\n        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));\n    }\n    /**\n     * Convenience method.\n     * Return a static method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, new Class[] {parameterTypes});\n    }\n    /**\n     * Return whether the specified class can be \"declared\" in code;\n     * i.e. it is either a \"top-level\" class or a \"member\" class, but it\n     * is not an \"array\" class. This method rolls together all the checks\n     * from the other methods for a bit of a performance tweak.\n     * Class#isDeclarable()\n     */\n    public static boolean classNamedIsDeclarable(String className) {\n        if (className.charAt(0) == ARRAY_INDICATOR) {\n            return false;        // it is an \"array\" class\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return true;        // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n    /**\n     * Return whether the specified class is a \"top-level\" class,\n     * as opposed to a \"member\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name does NOT contain a '$': \"TopLevelClass\").\n     * Class#isTopLevel()\n     */\n    public static boolean classNamedIsTopLevel(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;\n    }\n    /**\n     * Return whether the specified class is a \"member\" class,\n     * as opposed to a \"top-level\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name contains at least one '$' and all the names between\n     * each '$' are legal class names:\n     * \"TopLevelClass$MemberClass$NestedMemberClass\").\n     * Class#isMember()\n     */\n    public static boolean classNamedIsMember(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return false;    // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n    /**\n     * Return whether the specified class is a \"local\" class,\n     * as opposed to a \"top-level\", \"member\", or \"anonymous\" class,\n     * using the standard jdk (or Eclipse) naming conventions.\n     * In the jdk, the class name ends with '$nnnXXX' where the '$' is\n     * followed by a series of numeric digits which are followed by the\n     * local class name: \"TopLevelClass$1LocalClass\".\n     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is\n     * followed by a series of numeric digits which are separated from\n     * the local class name by another '$': \"TopLevelClass$1$LocalClass\".\n     * Class#isLocal()\n     */\n    public static boolean classNamedIsLocal(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        if ( ! Character.isDigit(className.charAt(dollar + 1))) {\n            return false;\n        }\n        for (int i = dollar + 2; i < className.length(); i++) {\n            if (Character.isJavaIdentifierStart(className.charAt(i))) {\n                return true;\n            }\n        }\n        // all the characters past the $ are digits (anonymous)\n        return false;\n    }\n    /**\n     * Return whether the specified class is an \"anonymous\" class,\n     * as opposed to a \"top-level\", \"member\", or \"local\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name ends with '$nnn' where all the characters past the\n     * last '$' are numeric digits: \"TopLevelClass$1\").\n     * Class#isAnonymous()\n     */\n    public static boolean classNamedIsAnonymous(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        int start = dollar + 1;\n        for (int i = className.length(); i-- > start; ) {\n            if ( ! Character.isDigit(className.charAt(i))) {\n                return false;\n            }\n        }\n        // all the characters past the $ are digits\n        return true;\n    }\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthFor(Class javaClass) {\n        int depth = 0;\n        while (javaClass.isArray()) {\n            depth++;\n            javaClass = javaClass.getComponentType();\n        }\n        return depth;\n    }\n    /**\n     * Return the \"array depth\" of the specified object.\n     * The depth is the number of dimensions for an array.\n     * Non-arrays have a depth of zero.\n     */\n    public static int arrayDepthForObject(Object object) {\n        return arrayDepthFor(object.getClass());\n    }\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * @see java.lang.Class#getName()\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthForClassNamed(String className) {\n        int depth = 0;\n        while (className.charAt(depth) == ARRAY_INDICATOR) {\n            depth++;\n        }\n        return depth;\n    }\n    /**\n     * Return whether the specified class is an array type.\n     * @see java.lang.Class#getName()\n     */\n    public static boolean classNamedIsArray(String className) {\n        return className.charAt(0) == ARRAY_INDICATOR;\n    }\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * A non-array type simply returns itself.\n     * Class#getElementType()\n     */\n    public static Class elementTypeFor(Class javaClass) {\n        while (javaClass.isArray()) {\n            javaClass = javaClass.getComponentType();\n        }\n        return javaClass;\n    }\n    /**\n     * Return the \"element type\" of the specified object.\n     * The element type is the base type held by an array.\n     * A non-array simply returns its class.\n     */\n    public static Class elementTypeForObject(Object object) {\n        return elementTypeFor(object.getClass());\n    }\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * Class#getElementType()\n     */\n    public static String elementTypeNameFor(Class javaClass) {\n        return elementTypeFor(javaClass).getName();\n    }\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * @see java.lang.Class#getName()\n     * Class#getElementType()\n     */\n    public static String elementTypeNameForClassNamed(String className) {\n        int depth = arrayDepthForClassNamed(className);\n        if (depth == 0) {\n            // the name is in the form: \"java.lang.Object\" or \"int\"\n            return className;\n        }\n        int last = className.length() - 1;\n        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {\n            // the name is in the form: \"[[[Ljava.lang.Object;\"\n            return className.substring(depth + 1, last);    // drop the trailing ';'\n        }\n        // the name is in the form: \"[[[I\"\n        return classNameForCode(className.charAt(last));\n    }\n    /**\n     * Return whether the specified class is a \"reference\"\n     * class (i.e. not void or one of the primitives).\n     */\n    public static boolean classNamedIsReference(String className) {\n        return ! classNamedIsNonReference(className);\n    }\n    /**\n     * Return whether the specified class is a \"non-reference\"\n     * class (i.e. void or one of the primitives).\n     */\n    public static boolean classNamedIsNonReference(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(char classCode) {\n        return classForCode(classCode).getName();\n    }\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(int classCode) {\n        return classNameForCode((char) classCode);\n    }\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(char classCode) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].code == classCode) {\n                return codes[i].javaClass;\n            }\n        }\n        throw new IllegalArgumentException(String.valueOf(classCode));\n    }\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(int classCode) {\n        return classForCode((char) classCode);\n    }\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClass(Class javaClass) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass == javaClass) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(javaClass.getName());\n    }\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClassNamed(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(className);\n    }\n    /**\n     * Return the class for specified \"type declaration\".\n     */\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {\n        return classForTypeDeclaration(elementTypeName, arrayDepth, null);\n    }\n    /**\n     * Return the class for specified \"type declaration\",\n     * using the specified class loader.\n     */\n    // see the \"Evaluation\" of jdk bug 6446627 for a discussion of loading classes\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {\n        // primitives cannot be loaded via Class#forName(),\n        // so check for a primitive class name first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        // non-array\n        if (arrayDepth == 0) {\n            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return Class.forName(sb.toString(), false, classLoader);\n    }\n    /**\n     * Return the class name for specified \"type declaration\".\n     */\n    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {\n        // non-array\n        if (arrayDepth == 0) {\n            return elementTypeName;\n        }\n        if (elementTypeName.equals(void.class.getName())) {\n            throw new IllegalArgumentException(\"'void' must have an array depth of zero: \" + arrayDepth + '.');\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        // look for a primitive first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return sb.toString();\n    }\n    private static PrimitiveClassCode[] getPrimitiveClassCodes() {\n        if (primitiveClassCodes == null) {\n            primitiveClassCodes = buildPrimitiveClassCodes();\n        }\n        return primitiveClassCodes;\n    }\n    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {\n        PrimitiveClassCode[] result = new PrimitiveClassCode[9];\n        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);\n        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);\n        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);\n        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);\n        result[4] = new PrimitiveClassCode(INT_CODE, int.class);\n        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);\n        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);\n        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);\n        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);\n        return result;\n    }\n    /**\n     * Suppress default constructor, ensuring non-instantiability.\n     */\n    private ClassTools() {\n        super();\n        throw new UnsupportedOperationException();\n    }\n    // ********** member class **********\n    private static class PrimitiveClassCode {\n        char code;\n        Class javaClass;\n        PrimitiveClassCode(char code, Class javaClass) {\n            this.code = code;\n            this.javaClass = javaClass;\n        }\n    }\n"]], "pred": {"ppl": 1.5657808780670166, "ppl_lower": 1.785494327545166, "ppl/lowercase_ppl": -1.292852674732706, "ppl/zlib": 7.041216444287978e-05, "Min_5.0% Prob": 5.650718352373908, "Min_10.0% Prob": 3.746740888146793, "Min_20.0% Prob": 2.1563956501583257, "Min_30.0% Prob": 1.4804970120000684, "Min_40.0% Prob": 1.1169604949225058, "Min_50.0% Prob": 0.8963500612758013, "Min_60.0% Prob": 0.7479083249865778}}
{"hexsha": "7a7b8318fe1ee8708edc850e3756a533331a9ffb", "ext": "java", "lang": "Java", "content": "public class ConsumerAuthInterceptor implements HandlerInterceptor {\n\n    private WeChatUserRepository weChatUserRepository;\n\n    @Autowired\n    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {\n        this.weChatUserRepository = weChatUserRepository;\n    }\n\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {\n        this.jwtTokenUtil = jwtTokenUtil;\n    }\n\n    @Override\n    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object)\n            throws NullTokenException, UserNotExistException {\n        // check annotation\n        if (!(object instanceof HandlerMethod)) {\n            return true;\n        }\n        final HandlerMethod handlerMethod = (HandlerMethod) object;\n        final Method method = handlerMethod.getMethod();\n        // request\n        if (method.isAnnotationPresent(WeChatUser.class)) {\n            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);\n            if (!weChatUser.required()) {\n                return true;\n            }\n            // get token\n            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);\n            if (token == null || token.replace(\" \", \"\").equals(\"\")) {\n                throw new NullTokenException(\"Null token.\");\n            }\n            // verify user exist in database\n            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);\n            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);\n            if (wechatUserDoList.isEmpty()) {\n                throw new UserNotExistException();\n            }\n        }\n        return true;\n    }\n\n}", "class_id": 0, "repo": "Kenhuey/freethru", "file": "src/main/java/com/mythsart/freethru/framework/common/interceptor/ConsumerAuthInterceptor.java", "last_update_at": "2021-01-08T18:53:12+00:00", "question_id": "7a7b8318fe1ee8708edc850e3756a533331a9ffb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConsumerAuthInterceptor implements HandlerInterceptor {\n    private WeChatUserRepository weChatUserRepository;\n    @Autowired\n    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {\n        this.weChatUserRepository = weChatUserRepository;\n    }\n    private JwtTokenUtil jwtTokenUtil;\n    @Autowired\n    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {\n        this.jwtTokenUtil = jwtTokenUtil;\n    }\n    @Override\n    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object)\n            throws NullTokenException, UserNotExistException {\n        // check annotation\n        if (!(object instanceof HandlerMethod)) {\n            return true;\n        }\n        final HandlerMethod handlerMethod = (HandlerMethod) object;\n        final Method method = handlerMethod.getMethod();\n        // request\n        if (method.isAnnotationPresent(WeChatUser.class)) {\n            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);\n            if (!weChatUser.required()) {\n                return true;\n            }\n            // get token\n            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);\n            if (token == null || token.replace(\" \", \"\").equals(\"\")) {\n                throw new NullTokenException(\"Null token.\");\n            }\n            // verify user exist in database\n            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);\n            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);\n            if (wechatUserDoList.isEmpty()) {\n                throw new UserNotExistException();\n            }\n        }\n        return true;\n    }\n"]], "pred": {"ppl": 1.875665307044983, "ppl_lower": 2.1553990840911865, "ppl/lowercase_ppl": -1.2210183667084296, "ppl/zlib": 0.0009936231072811023, "Min_5.0% Prob": 6.5852668596350625, "Min_10.0% Prob": 4.762573292914857, "Min_20.0% Prob": 2.968592528333055, "Min_30.0% Prob": 2.0701556431365686, "Min_40.0% Prob": 1.5707209920362821, "Min_50.0% Prob": 1.2564465184754963, "Min_60.0% Prob": 1.0494254913810692}}
{"hexsha": "fa6beaa76b8c1e5865d612bbe2c25921a6e42fb2", "ext": "java", "lang": "Java", "content": "public class S3ArtifactContentProvider implements ArtifactContentProvider {\n\n  private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());\n  private final ServerPaths myServerPaths;\n\n  public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {\n    myServerPaths = serverPaths;\n  }\n\n  @NotNull\n  @Override\n  public String getType() {\n    return S3Constants.S3_STORAGE_TYPE;\n  }\n\n  @NotNull\n  @Override\n  public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {\n    final Map<String, String> params;\n    final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();\n    if (artifactData == null) {\n      throw new IOException(\"Invalid artifact data: S3 object path property is not set\");\n    }\n\n    final String artifactPath = artifactData.getPath();\n    try {\n      params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());\n    } catch (IllegalArgumentException e) {\n      throw new IOException(\"Failed to get artifact \" + artifactPath + \" content: Invalid storage settings \" + e.getMessage(), e);\n    }\n\n    final String bucketName = S3Util.getBucketName(params);\n    final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;\n\n    try {\n      return S3Util.withS3Client(\n        ParamUtil.putSslValues(myServerPaths, params),\n        client -> client.getObject(bucketName, key).getObjectContent()\n      );\n    } catch (Throwable t) {\n      final AWSException awsException = new AWSException(t);\n      final String details = awsException.getDetails();\n      if (StringUtil.isNotEmpty(details)) {\n        final String message = awsException.getMessage() + details;\n        LOG.warn(message);\n      }\n      throw new IOException(String.format(\n        \"Failed to get artifact '%s' content in bucket '%s': %s\",\n        artifactPath, bucketName, awsException.getMessage()\n      ), awsException);\n    }\n  }\n}", "class_id": 0, "repo": "ChildOfJustice/teamcity-s3-artifact-storage-plugin", "file": "s3-artifact-storage-server/src/main/java/jetbrains/buildServer/artifacts/s3/S3ArtifactContentProvider.java", "last_update_at": "2021-11-08T09:50:20+00:00", "question_id": "fa6beaa76b8c1e5865d612bbe2c25921a6e42fb2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class S3ArtifactContentProvider implements ArtifactContentProvider {\n  private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());\n  private final ServerPaths myServerPaths;\n  public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {\n    myServerPaths = serverPaths;\n  }\n  @NotNull\n  @Override\n  public String getType() {\n    return S3Constants.S3_STORAGE_TYPE;\n  }\n  @NotNull\n  @Override\n  public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {\n    final Map<String, String> params;\n    final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();\n    if (artifactData == null) {\n      throw new IOException(\"Invalid artifact data: S3 object path property is not set\");\n    }\n    final String artifactPath = artifactData.getPath();\n    try {\n      params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());\n    } catch (IllegalArgumentException e) {\n      throw new IOException(\"Failed to get artifact \" + artifactPath + \" content: Invalid storage settings \" + e.getMessage(), e);\n    }\n    final String bucketName = S3Util.getBucketName(params);\n    final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;\n    try {\n      return S3Util.withS3Client(\n        ParamUtil.putSslValues(myServerPaths, params),\n        client -> client.getObject(bucketName, key).getObjectContent()\n      );\n    } catch (Throwable t) {\n      final AWSException awsException = new AWSException(t);\n      final String details = awsException.getDetails();\n      if (StringUtil.isNotEmpty(details)) {\n        final String message = awsException.getMessage() + details;\n        LOG.warn(message);\n      }\n      throw new IOException(String.format(\n        \"Failed to get artifact '%s' content in bucket '%s': %s\",\n        artifactPath, bucketName, awsException.getMessage()\n      ), awsException);\n    }\n  }\n"]], "pred": {"ppl": 2.0132389068603516, "ppl_lower": 2.4775421619415283, "ppl/lowercase_ppl": -1.296568373202511, "ppl/zlib": 0.0009317507611354159, "Min_5.0% Prob": 6.177754952357366, "Min_10.0% Prob": 4.669098165799987, "Min_20.0% Prob": 3.0321406276426583, "Min_30.0% Prob": 2.223408630730943, "Min_40.0% Prob": 1.7254436022320458, "Min_50.0% Prob": 1.3961299142789885, "Min_60.0% Prob": 1.1666065065028728}}
{"hexsha": "b73d67eeb7296ad974a93d8acc1f52b681a08a15", "ext": "java", "lang": "Java", "content": "public class AnnotationTest extends RecognationExtended{\n\n\t@Test\n\tpublic void testSamePackage(){\n\t\tboolean annotationFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(5, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageA(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageB(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageC(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n}", "class_id": 0, "repo": "senkz/HUSACCT", "file": "src/husaccttest/analyse/java/recognition/AnnotationTest.java", "last_update_at": "2021-02-02T12:58:55+00:00", "question_id": "b73d67eeb7296ad974a93d8acc1f52b681a08a15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnnotationTest extends RecognationExtended{\n\t@Test\n\tpublic void testSamePackage(){\n\t\tboolean annotationFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(5, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageA(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageB(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageC(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n"]], "pred": {"ppl": 1.2991634607315063, "ppl_lower": 1.3416649103164673, "ppl/lowercase_ppl": -1.1229966298404197, "ppl/zlib": 0.0006869306183538603, "Min_5.0% Prob": 4.292044652269242, "Min_10.0% Prob": 2.4923206884610027, "Min_20.0% Prob": 1.3000474542967584, "Min_30.0% Prob": 0.8699260401910731, "Min_40.0% Prob": 0.6544538055151808, "Min_50.0% Prob": 0.5231678241866775, "Min_60.0% Prob": 0.43641682611668475}}
{"hexsha": "ddca8f972e4ef486dd342e78f4884eef0e4fa00e", "ext": "java", "lang": "Java", "content": "@lombok.extern.slf4j.Slf4j\npublic abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C>\n        extends ClientBuilderBase<B, C> {\n    public RegionalClientBuilder(Service service) {\n        super(service);\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param region region\n     * @return this builder\n     */\n    public B region(com.oracle.bmc.Region region) {\n        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);\n        if (endpoint.isPresent()) {\n            endpoint(endpoint.get());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Endpoint for \" + service + \" is not known in region \" + region);\n        }\n        return (B) this;\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param regionId region\n     * @return this builder\n     */\n    public B region(String regionId) {\n        regionId = regionId.toLowerCase(Locale.ENGLISH);\n        try {\n            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);\n            return region(region);\n        } catch (IllegalArgumentException e) {\n            LOG.info(\"Unknown regionId '{}', falling back to default endpoint format\", regionId);\n            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);\n            return endpoint(endpoint);\n        }\n    }\n}", "class_id": 0, "repo": "skichiku/oci-java-sdk", "file": "bmc-common/src/main/java/com/oracle/bmc/common/RegionalClientBuilder.java", "last_update_at": "2021-04-09T18:17:14+00:00", "question_id": "ddca8f972e4ef486dd342e78f4884eef0e4fa00e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@lombok.extern.slf4j.Slf4j\npublic abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C>\n        extends ClientBuilderBase<B, C> {\n    public RegionalClientBuilder(Service service) {\n        super(service);\n    }\n    /**\n     * Set the region for the client to be created.\n     * @param region region\n     * @return this builder\n     */\n    public B region(com.oracle.bmc.Region region) {\n        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);\n        if (endpoint.isPresent()) {\n            endpoint(endpoint.get());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Endpoint for \" + service + \" is not known in region \" + region);\n        }\n        return (B) this;\n    }\n    /**\n     * Set the region for the client to be created.\n     * @param regionId region\n     * @return this builder\n     */\n    public B region(String regionId) {\n        regionId = regionId.toLowerCase(Locale.ENGLISH);\n        try {\n            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);\n            return region(region);\n        } catch (IllegalArgumentException e) {\n            LOG.info(\"Unknown regionId '{}', falling back to default endpoint format\", regionId);\n            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);\n            return endpoint(endpoint);\n        }\n    }\n"]], "pred": {"ppl": 1.8564519882202148, "ppl_lower": 2.4688737392425537, "ppl/lowercase_ppl": -1.4608212116751242, "ppl/zlib": 0.0011851860782600332, "Min_5.0% Prob": 5.415090460526316, "Min_10.0% Prob": 4.065576478054649, "Min_20.0% Prob": 2.7449041565782144, "Min_30.0% Prob": 1.9861371784106545, "Min_40.0% Prob": 1.5359628615913048, "Min_50.0% Prob": 1.23359853355214, "Min_60.0% Prob": 1.0320502548721497}}
{"hexsha": "681fd5b93140fff33f986615cacd9efcac085276", "ext": "java", "lang": "Java", "content": "public class DecisionMaker extends Thread {\n\tprivate ArrayList<Integer> preferredPeers = new ArrayList<Integer>();                       // An array that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// maintains preferred\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// peerInfos.\n\tprivate int optUnchockedPeer = -1;\n\n\tprivate ArrayList<Integer> previousRequestList = new ArrayList<>();\n\tprivate ArrayList<Integer> requestingList = new ArrayList<>();\n\t\n\t/**\n\t * Update preferred peers\n\t */\n\tprivate class updatePreferredPeers extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\tif (PeerProcess.peers.size() > 0) {\n\t\t\t\t\tpreferredPeers.clear();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {\n\t\t\t\t\tArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();\n\t\t\t\t\tCollections.shuffle(interestedPeers);\n\t\t\t\t\tfor(int peerId: interestedPeers) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();\n\t\t\t\t\tfor(int peerId: PeerProcess.getInterestedPeers()) {\n\t\t\t\t\t\tpeerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));\n\t\t\t\t\t}\n\t\t\t\t\tpeerId_ChunkCounts.sort(null);\n\t\t\t\t\t\n\t\t\t\t\tfor(PeerId_ChunkCount tuple: peerId_ChunkCounts) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(tuple.peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\t\tp.resetChunkCount();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// iterate over all peers to check and send proper choke/unchoke msgs\n\t\t\t\tfor (DynamicPeerInfo p : PeerProcess.peers) {\n\t\t\t\t\tif (p.isConnected) {\n\t\t\t\t\t\tif (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Unchoking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Choking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPeerProcess.write(\"has the preferred neighbors \" + preferredPeers);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Optimistically unchoke a peer\n\t */\n\tprivate class optimisiticUnchoke extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\ttry {\n\t\t\t\t\tPeerProcess.checkTermination();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> chockedList = new ArrayList<>();\n\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\tif(p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {\n\t\t\t\t\t\tchockedList.add(p.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!chockedList.isEmpty()) {\n\t\t\t\t\tint index = (int) (Math.random() * chockedList.size());\n\t\t\t\t\toptUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;\n\t\t\t\t\tPeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));\n\t\t\t\t\tPeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\tPeerProcess.write(\"has the optimistically unchoked neighbor \" + optUnchockedPeer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate class requestTimeout extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized(requestingList) {\n\t\t\t\tfor(int i = 0; i < previousRequestList.size(); i++) {\n\t\t\t\t\tif(requestingList.contains(previousRequestList.get(i))) {\n\t\t\t\t\t\trequestingList.remove(Integer.valueOf(previousRequestList.get(i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousRequestList = requestingList;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void removeRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\trequestingList.remove(Integer.valueOf(pieceIndex));\n\t\t}\n\t}\n\t\n\tpublic boolean addRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\tif(requestingList.contains(pieceIndex)) {\n\t\t\t\treturn false;\n\t\t\t}else {\n\t\t\t\trequestingList.add(pieceIndex);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Main method of decision maker as a thread.\n\t */\n\t@Override\n\tpublic void run() {\n\t\tTimer timerUpdate = new Timer();// create a new Timer\n\t\tTimer timerOptUpdate = new Timer();\n\t\tTimer timerRequestTimeout = new Timer();\n\t\tTimerTask task1 = new optimisiticUnchoke();\n\t\tTimerTask task2 = new updatePreferredPeers();\n\t\tTimerTask task3 = new requestTimeout();\n\t\ttimerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);\n\t\ttimerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);\n\t\ttimerRequestTimeout.schedule(task3, 0, 10000);\n\t}\n}", "class_id": 0, "repo": "rajatraiuf/BitTorrent-Java-CN5106C", "file": "src/cnt5106C/DecisionMaker.java", "last_update_at": "2021-01-18T18:08:54+00:00", "question_id": "681fd5b93140fff33f986615cacd9efcac085276", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DecisionMaker extends Thread {\n\tprivate ArrayList<Integer> preferredPeers = new ArrayList<Integer>();                       // An array that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// maintains preferred\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// peerInfos.\n\tprivate int optUnchockedPeer = -1;\n\tprivate ArrayList<Integer> previousRequestList = new ArrayList<>();\n\tprivate ArrayList<Integer> requestingList = new ArrayList<>();\n\t\n\t/**\n\t * Update preferred peers\n\t */\n\tprivate class updatePreferredPeers extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\tif (PeerProcess.peers.size() > 0) {\n\t\t\t\t\tpreferredPeers.clear();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {\n\t\t\t\t\tArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();\n\t\t\t\t\tCollections.shuffle(interestedPeers);\n\t\t\t\t\tfor(int peerId: interestedPeers) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();\n\t\t\t\t\tfor(int peerId: PeerProcess.getInterestedPeers()) {\n\t\t\t\t\t\tpeerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));\n\t\t\t\t\t}\n\t\t\t\t\tpeerId_ChunkCounts.sort(null);\n\t\t\t\t\t\n\t\t\t\t\tfor(PeerId_ChunkCount tuple: peerId_ChunkCounts) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(tuple.peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\t\tp.resetChunkCount();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// iterate over all peers to check and send proper choke/unchoke msgs\n\t\t\t\tfor (DynamicPeerInfo p : PeerProcess.peers) {\n\t\t\t\t\tif (p.isConnected) {\n\t\t\t\t\t\tif (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Unchoking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Choking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPeerProcess.write(\"has the preferred neighbors \" + preferredPeers);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Optimistically unchoke a peer\n\t */\n\tprivate class optimisiticUnchoke extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\ttry {\n\t\t\t\t\tPeerProcess.checkTermination();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> chockedList = new ArrayList<>();\n\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\tif(p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {\n\t\t\t\t\t\tchockedList.add(p.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!chockedList.isEmpty()) {\n\t\t\t\t\tint index = (int) (Math.random() * chockedList.size());\n\t\t\t\t\toptUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;\n\t\t\t\t\tPeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));\n\t\t\t\t\tPeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\tPeerProcess.write(\"has the optimistically unchoked neighbor \" + optUnchockedPeer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate class requestTimeout extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized(requestingList) {\n\t\t\t\tfor(int i = 0; i < previousRequestList.size(); i++) {\n\t\t\t\t\tif(requestingList.contains(previousRequestList.get(i))) {\n\t\t\t\t\t\trequestingList.remove(Integer.valueOf(previousRequestList.get(i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousRequestList = requestingList;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void removeRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\trequestingList.remove(Integer.valueOf(pieceIndex));\n\t\t}\n\t}\n\t\n\tpublic boolean addRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\tif(requestingList.contains(pieceIndex)) {\n\t\t\t\treturn false;\n\t\t\t}else {\n\t\t\t\trequestingList.add(pieceIndex);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Main method of decision maker as a thread.\n\t */\n\t@Override\n\tpublic void run() {\n\t\tTimer timerUpdate = new Timer();// create a new Timer\n\t\tTimer timerOptUpdate = new Timer();\n\t\tTimer timerRequestTimeout = new Timer();\n\t\tTimerTask task1 = new optimisiticUnchoke();\n\t\tTimerTask task2 = new updatePreferredPeers();\n\t\tTimerTask task3 = new requestTimeout();\n\t\ttimerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);\n\t\ttimerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);\n\t\ttimerRequestTimeout.schedule(task3, 0, 10000);\n\t}\n"]], "pred": {"ppl": 1.8712891340255737, "ppl_lower": 1.9464553594589233, "ppl/lowercase_ppl": -1.0628481511389678, "ppl/zlib": 0.00048054261490793, "Min_5.0% Prob": 6.512892227546842, "Min_10.0% Prob": 4.7312119030484965, "Min_20.0% Prob": 2.9762486143439424, "Min_30.0% Prob": 2.070944688118556, "Min_40.0% Prob": 1.5622891679743174, "Min_50.0% Prob": 1.2534501004851115, "Min_60.0% Prob": 1.045515068297557}}
{"hexsha": "4998e4e78f75aacee3fa24faf1e1124b33ea528c", "ext": "java", "lang": "Java", "content": "public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {\n\n    public TypeBinding resolveType(BlockScope scope) {\n        this.argumentTypes = Binding.NO_PARAMETERS;\n        if (this.arguments != null) {\n            int argsLength = this.arguments.length;\n            int length = this.arguments.length;\n            this.argumentTypes = new TypeBinding[length];\n            for (int a = argsLength; --a >= 0; ) {\n                this.argumentTypes[a] = this.arguments[a].resolveType(scope);\n            }\n        }\n        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;\n        if (this.enclosingInstance != null) {\n            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);\n            if (enclosingType == null) {\n                // Eg.: new Test<>().new Test<>(#cursor#\n                if (this.enclosingInstance instanceof AllocationExpression) {\n                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;\n                    if (enclosingInstanceType != null) {\n                        enclosingType = enclosingInstanceType.resolvedType;\n                    }\n                }\n            }\n            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {\n                throw new CompletionNodeFound();\n            }\n            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n            if (// handle the anonymous class definition case\n            this.resolvedType.isInterface())\n                this.resolvedType = scope.getJavaLangObject();\n        } else {\n            this.resolvedType = this.type.resolveType(scope, /* check bounds*/\n            true);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n        }\n        throw new CompletionNodeFound(this, this.resolvedType, scope);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        if (this.enclosingInstance == null)\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnAllocationExpression:\");\n        else\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnQualifiedAllocationExpression:\");\n        return super.printExpression(indent, output).append('>');\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.core/176.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "4998e4e78f75aacee3fa24faf1e1124b33ea528c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {\n    public TypeBinding resolveType(BlockScope scope) {\n        this.argumentTypes = Binding.NO_PARAMETERS;\n        if (this.arguments != null) {\n            int argsLength = this.arguments.length;\n            int length = this.arguments.length;\n            this.argumentTypes = new TypeBinding[length];\n            for (int a = argsLength; --a >= 0; ) {\n                this.argumentTypes[a] = this.arguments[a].resolveType(scope);\n            }\n        }\n        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;\n        if (this.enclosingInstance != null) {\n            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);\n            if (enclosingType == null) {\n                // Eg.: new Test<>().new Test<>(#cursor#\n                if (this.enclosingInstance instanceof AllocationExpression) {\n                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;\n                    if (enclosingInstanceType != null) {\n                        enclosingType = enclosingInstanceType.resolvedType;\n                    }\n                }\n            }\n            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {\n                throw new CompletionNodeFound();\n            }\n            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n            if (// handle the anonymous class definition case\n            this.resolvedType.isInterface())\n                this.resolvedType = scope.getJavaLangObject();\n        } else {\n            this.resolvedType = this.type.resolveType(scope, /* check bounds*/\n            true);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n        }\n        throw new CompletionNodeFound(this, this.resolvedType, scope);\n    }\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        if (this.enclosingInstance == null)\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnAllocationExpression:\");\n        else\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnQualifiedAllocationExpression:\");\n        return super.printExpression(indent, output).append('>');\n    }\n"]], "pred": {"ppl": 1.8216029405593872, "ppl_lower": 2.3109657764434814, "ppl/lowercase_ppl": -1.3967683618471112, "ppl/zlib": 0.0006568640197578532, "Min_5.0% Prob": 6.246969883640607, "Min_10.0% Prob": 4.414254569758971, "Min_20.0% Prob": 2.7813420395056405, "Min_30.0% Prob": 1.9634419935755432, "Min_40.0% Prob": 1.4951940618436008, "Min_50.0% Prob": 1.199695549113676, "Min_60.0% Prob": 1.0003476413694443}}
{"hexsha": "6b004f72007f03d3e280511f6add5590dab3610a", "ext": "java", "lang": "Java", "content": "public class Configuration\n    implements Comparable<Configuration> {\n\n    /**\n     * Prefix for instructions for the configurator.\n     */\n    public static final String CONFIGURATOR_PREFIX = \":configurator:\";\n\n    /**\n     * Prefix for special properties which are not configuration properties.\n     */\n    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + \"feature-\";\n\n    /**\n     * This optional configuration property stores the artifact id (mvn id) of the\n     * bundle this configuration belongs to.\n     */\n    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + \"service.bundleLocation\";\n\n    /**\n     * This optional configuration property stores the artifact ids (array) of the\n     * features this configuration has been specified.\n     * @since 1.6\n     */\n    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + \"origins\";\n\n    /** The pid or name for factory pids. */\n    private final String pid;\n\n    /** The ordered properties. */\n    private final Dictionary<String, Object> properties = Configurations.newConfiguration();\n\n    /**\n     * Create a new configuration\n     * @param pid The pid\n     * @throws IllegalArgumentException If pid is {@code null}\n     */\n    public Configuration(final String pid) {\n        if ( pid == null ) {\n            throw new IllegalArgumentException(\"pid must not be null\");\n        }\n        this.pid = pid;\n    }\n\n    @Override\n    public int compareTo(final Configuration o) {\n        return this.pid.compareTo(o.pid);\n    }\n\n    /**\n     * Get the pid.\n     *\n     * @return The pid\n     */\n    public String getPid() {\n        return this.pid;\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @return {@code true} if it's a factory pid\n     * @since 1.3\n     */\n    public boolean isFactoryConfiguration() {\n        return isFactoryConfiguration(this.pid);\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getFactoryPid() {\n        return getFactoryPid(this.pid);\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getName() {\n        return getName(this.pid);\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @param pid The pid\n     * @return {@code true} if it's a factory pid\n     */\n    public static boolean isFactoryConfiguration(final String pid) {\n        return pid.contains(\"~\");\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @param pid The pid\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getFactoryPid(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(0, pos);\n        }\n        return null;\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @param pid The pid\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getName(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(pos + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Get all properties of the configuration. This method returns a mutable\n     * dictionary which can be mutated to alter the properties for this\n     * configuration.\n     *\n     * @return The properties\n     */\n    public Dictionary<String, Object> getProperties() {\n        return this.properties;\n    }\n\n    /**\n     * Get the feature origins - if recorded\n     * \n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.6\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins() {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n   /**\n     * Get the feature origins.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.7\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.6\n     */\n    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS);\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS, values);\n        }\n    }\n\n    /**\n     * Get the feature origins for a property - if recorded\n     * \n     * @param propertyName The name of the property\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Get the feature origins for a property.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param propertyName The name of the property\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins for a property\n     * @param propertyName The name of the property\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.8\n     */\n    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName), values);\n        }\n    }\n\n    /**\n     * Get the configuration properties of the configuration. This configuration\n     * properties are all properties minus properties used to manage the\n     * configuration. Managing properties have to start with\n     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which\n     * represents a snapshot of the properties at the time this method is called.\n     *\n     * @return The configuration properties\n     */\n    public Dictionary<String, Object> getConfigurationProperties() {\n        final Dictionary<String, Object> p = new Hashtable<>();\n        final Enumeration<String> keys = this.properties.keys();\n        while (keys.hasMoreElements()) {\n            final String key = keys.nextElement();\n            if (!key.startsWith(CONFIGURATOR_PREFIX)) {\n                p.put(key, this.properties.get(key));\n            }\n        }\n        return p;\n    }\n\n    /**\n     * Create a copy of the configuration with a provided PID.\n     *\n     * @param aPid The pid of the configuration\n     * @return A copy of this configuration with the given PID\n     */\n    public Configuration copy(final String aPid) {\n        final Configuration result = new Configuration(aPid);\n        final Enumeration<String> keyEnum = this.getProperties().keys();\n        while (keyEnum.hasMoreElements()) {\n            final String key = keyEnum.nextElement();\n            result.getProperties().put(key, this.getProperties().get(key));\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Configuration [pid=\" + pid\n                + \", properties=\" + properties\n                + \"]\";\n    }\n}", "class_id": 0, "repo": "hboutemy/sling-org-apache-sling-feature", "file": "src/main/java/org/apache/sling/feature/Configuration.java", "last_update_at": "2021-11-08T14:02:09+00:00", "question_id": "6b004f72007f03d3e280511f6add5590dab3610a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Configuration\n    implements Comparable<Configuration> {\n    /**\n     * Prefix for instructions for the configurator.\n     */\n    public static final String CONFIGURATOR_PREFIX = \":configurator:\";\n    /**\n     * Prefix for special properties which are not configuration properties.\n     */\n    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + \"feature-\";\n    /**\n     * This optional configuration property stores the artifact id (mvn id) of the\n     * bundle this configuration belongs to.\n     */\n    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + \"service.bundleLocation\";\n    /**\n     * This optional configuration property stores the artifact ids (array) of the\n     * features this configuration has been specified.\n     * @since 1.6\n     */\n    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + \"origins\";\n    /** The pid or name for factory pids. */\n    private final String pid;\n    /** The ordered properties. */\n    private final Dictionary<String, Object> properties = Configurations.newConfiguration();\n    /**\n     * Create a new configuration\n     * @param pid The pid\n     * @throws IllegalArgumentException If pid is {@code null}\n     */\n    public Configuration(final String pid) {\n        if ( pid == null ) {\n            throw new IllegalArgumentException(\"pid must not be null\");\n        }\n        this.pid = pid;\n    }\n    @Override\n    public int compareTo(final Configuration o) {\n        return this.pid.compareTo(o.pid);\n    }\n    /**\n     * Get the pid.\n     *\n     * @return The pid\n     */\n    public String getPid() {\n        return this.pid;\n    }\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @return {@code true} if it's a factory pid\n     * @since 1.3\n     */\n    public boolean isFactoryConfiguration() {\n        return isFactoryConfiguration(this.pid);\n    }\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getFactoryPid() {\n        return getFactoryPid(this.pid);\n    }\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getName() {\n        return getName(this.pid);\n    }\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @param pid The pid\n     * @return {@code true} if it's a factory pid\n     */\n    public static boolean isFactoryConfiguration(final String pid) {\n        return pid.contains(\"~\");\n    }\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @param pid The pid\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getFactoryPid(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(0, pos);\n        }\n        return null;\n    }\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @param pid The pid\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getName(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(pos + 1);\n        }\n        return null;\n    }\n    /**\n     * Get all properties of the configuration. This method returns a mutable\n     * dictionary which can be mutated to alter the properties for this\n     * configuration.\n     *\n     * @return The properties\n     */\n    public Dictionary<String, Object> getProperties() {\n        return this.properties;\n    }\n    /**\n     * Get the feature origins - if recorded\n     * \n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.6\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins() {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n   /**\n     * Get the feature origins.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.7\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n    /**\n     * Set the feature origins\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.6\n     */\n    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS);\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS, values);\n        }\n    }\n    /**\n     * Get the feature origins for a property - if recorded\n     * \n     * @param propertyName The name of the property\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n    /**\n     * Get the feature origins for a property.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param propertyName The name of the property\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n    /**\n     * Set the feature origins for a property\n     * @param propertyName The name of the property\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.8\n     */\n    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName), values);\n        }\n    }\n    /**\n     * Get the configuration properties of the configuration. This configuration\n     * properties are all properties minus properties used to manage the\n     * configuration. Managing properties have to start with\n     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which\n     * represents a snapshot of the properties at the time this method is called.\n     *\n     * @return The configuration properties\n     */\n    public Dictionary<String, Object> getConfigurationProperties() {\n        final Dictionary<String, Object> p = new Hashtable<>();\n        final Enumeration<String> keys = this.properties.keys();\n        while (keys.hasMoreElements()) {\n            final String key = keys.nextElement();\n            if (!key.startsWith(CONFIGURATOR_PREFIX)) {\n                p.put(key, this.properties.get(key));\n            }\n        }\n        return p;\n    }\n    /**\n     * Create a copy of the configuration with a provided PID.\n     *\n     * @param aPid The pid of the configuration\n     * @return A copy of this configuration with the given PID\n     */\n    public Configuration copy(final String aPid) {\n        final Configuration result = new Configuration(aPid);\n        final Enumeration<String> keyEnum = this.getProperties().keys();\n        while (keyEnum.hasMoreElements()) {\n            final String key = keyEnum.nextElement();\n            result.getProperties().put(key, this.getProperties().get(key));\n        }\n        return result;\n    }\n    @Override\n    public String toString() {\n        return \"Configuration [pid=\" + pid\n                + \", properties=\" + properties\n                + \"]\";\n    }\n"]], "pred": {"ppl": 1.7143551111221313, "ppl_lower": 1.8403748273849487, "ppl/lowercase_ppl": -1.1315907487912693, "ppl/zlib": 0.00027871612275141865, "Min_5.0% Prob": 5.599191408531339, "Min_10.0% Prob": 4.095258373840182, "Min_20.0% Prob": 2.526718534675299, "Min_30.0% Prob": 1.7727414295807773, "Min_40.0% Prob": 1.341513396402443, "Min_50.0% Prob": 1.0772833069695302, "Min_60.0% Prob": 0.8990545287773128}}
{"hexsha": "135e2861092daaa6b77ef88ad408f7b6a510cb30", "ext": "java", "lang": "Java", "content": "public class TestMySQLDialect {\n\n  @Test\n  public void testGetLimitString() {\n    MySQLDialect mySQLDialect = new MySQLDialect();\n\n    String sql = \"select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}\";\n\n    System.out.println(mySQLDialect.getLimitString(sql, 1, 5));\n\n    System.out.println(mySQLDialect.getCountString(sql));\n\n    System.out.print(sql);\n  }\n}", "class_id": 0, "repo": "limaofeng/jfantasy-framework", "file": "core/src/test/java/org/jfantasy/framework/dao/mybatis/dialect/TestMySQLDialect.java", "last_update_at": "2021-08-13T15:25:01+00:00", "question_id": "135e2861092daaa6b77ef88ad408f7b6a510cb30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestMySQLDialect {\n  @Test\n  public void testGetLimitString() {\n    MySQLDialect mySQLDialect = new MySQLDialect();\n    String sql = \"select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}\";\n    System.out.println(mySQLDialect.getLimitString(sql, 1, 5));\n    System.out.println(mySQLDialect.getCountString(sql));\n    System.out.print(sql);\n  }\n"]], "pred": {"ppl": 2.9252638816833496, "ppl_lower": 3.7842092514038086, "ppl/lowercase_ppl": -1.23985087346942, "ppl/zlib": 0.005015816320442637, "Min_5.0% Prob": 7.856869697570801, "Min_10.0% Prob": 6.151814130636362, "Min_20.0% Prob": 4.374827539479291, "Min_30.0% Prob": 3.3330082416534426, "Min_40.0% Prob": 2.618368676415196, "Min_50.0% Prob": 2.132104610038154, "Min_60.0% Prob": 1.7995723843298577}}
{"hexsha": "89aaa2b36a7cb677b7e7a1d9c911382031ef7316", "ext": "java", "lang": "Java", "content": "public class ExtensionUtility {\n\n    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {\n        Project project = event.getData(PlatformDataKeys.PROJECT);\n        if (project == null) {\n            return null;\n        }\n\n        DataContext dataContext = event.getDataContext();\n        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n        if (view == null) {\n            return null;\n        }\n\n        PsiDirectory[] directories = view.getDirectories();\n        if (directories.length == 0) {\n            return null;\n        }\n\n        return FilesystemUtil.findParentExtensionDirectory(directories[0]);\n    }\n\n    @Nullable\n    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory(\"Classes\");\n        if (classesDirectory == null) {\n            return null;\n        }\n\n        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);\n        if (composerManifest != null) {\n            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n\n        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);\n        if (extEmConf != null) {\n            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n\n        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);\n        if (strings.size() == 0 || strings.get(0).isEmpty()) {\n            return null;\n        }\n\n        return strings.get(0);\n    }\n\n    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {\n        return new String[0];\n    }\n\n    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {\n        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();\n\n        phpElementVisitor.visitFile(extEmConf);\n\n        return phpElementVisitor.getNamespaces();\n    }\n\n    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"ext_emconf.php\");\n        if (file == null) {\n            return null;\n        }\n\n        return file.getVirtualFile();\n    }\n\n    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {\n        return extensionRootDirectory.findFile(\"ext_emconf.php\");\n    }\n\n    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"composer.json\");\n        if (file == null) {\n            return null;\n        }\n\n        return file.getVirtualFile();\n    }\n\n    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {\n        private List<String> ns;\n\n        @Override\n        public void visitElement(@NotNull PsiElement element) {\n\n            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(\n                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(\n                            PlatformPatterns.psiElement(ArrayHashElement.class).withParent(\n                                    PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(\n                                            PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(\n                                                    PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(\n                                                            PlatformPatterns.or(\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"'psr-4'\"),\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"\\\"psr-4\\\"\")\n                                                            )\n                                                    )\n                                            )\n                                    )\n                            )\n                    )\n            ).accepts(element)) {\n                if (ns == null) {\n                    ns = new ArrayList<>();\n                }\n\n                String contents = ((StringLiteralExpression) element).getContents();\n                if (contents.contains(\"\\\\\")) {\n                    contents = contents.replace(\"\\\\\\\\\", \"\\\\\");\n                }\n\n                if (contents.endsWith(\"\\\\\")) {\n                    ns.add(contents);\n                }\n\n                ns.add((contents + \"\\\\\"));\n            }\n\n            super.visitElement(element);\n        }\n\n        public String[] getNamespaces() {\n            if (ns == null) {\n                return new String[0];\n            }\n\n            return ns.toArray(new String[0]);\n        }\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {\n        return findExtensionKeyFromFile(file.getVirtualFile());\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {\n        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);\n        if (extensionRootFolder == null) {\n            return null;\n        }\n\n        String extensionKey;\n        VirtualFile composerJsonFile = extensionRootFolder.findChild(\"composer.json\");\n        if (composerJsonFile != null) {\n            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);\n            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);\n        } else {\n            extensionKey = extensionRootFolder.getName();\n        }\n\n        return extensionKey;\n    }\n}", "class_id": 0, "repo": "cedricziel/idea-php-typo3-plugin", "file": "typo3-cms/src/main/java/com/cedricziel/idea/typo3/util/ExtensionUtility.java", "last_update_at": "2021-12-11T18:44:02+00:00", "question_id": "89aaa2b36a7cb677b7e7a1d9c911382031ef7316", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExtensionUtility {\n    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {\n        Project project = event.getData(PlatformDataKeys.PROJECT);\n        if (project == null) {\n            return null;\n        }\n        DataContext dataContext = event.getDataContext();\n        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n        if (view == null) {\n            return null;\n        }\n        PsiDirectory[] directories = view.getDirectories();\n        if (directories.length == 0) {\n            return null;\n        }\n        return FilesystemUtil.findParentExtensionDirectory(directories[0]);\n    }\n    @Nullable\n    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory(\"Classes\");\n        if (classesDirectory == null) {\n            return null;\n        }\n        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);\n        if (composerManifest != null) {\n            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);\n        if (extEmConf != null) {\n            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);\n        if (strings.size() == 0 || strings.get(0).isEmpty()) {\n            return null;\n        }\n        return strings.get(0);\n    }\n    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {\n        return new String[0];\n    }\n    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {\n        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();\n        phpElementVisitor.visitFile(extEmConf);\n        return phpElementVisitor.getNamespaces();\n    }\n    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"ext_emconf.php\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {\n        return extensionRootDirectory.findFile(\"ext_emconf.php\");\n    }\n    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"composer.json\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {\n        private List<String> ns;\n        @Override\n        public void visitElement(@NotNull PsiElement element) {\n            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(\n                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(\n                            PlatformPatterns.psiElement(ArrayHashElement.class).withParent(\n                                    PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(\n                                            PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(\n                                                    PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(\n                                                            PlatformPatterns.or(\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"'psr-4'\"),\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"\\\"psr-4\\\"\")\n                                                            )\n                                                    )\n                                            )\n                                    )\n                            )\n                    )\n            ).accepts(element)) {\n                if (ns == null) {\n                    ns = new ArrayList<>();\n                }\n                String contents = ((StringLiteralExpression) element).getContents();\n                if (contents.contains(\"\\\\\")) {\n                    contents = contents.replace(\"\\\\\\\\\", \"\\\\\");\n                }\n                if (contents.endsWith(\"\\\\\")) {\n                    ns.add(contents);\n                }\n                ns.add((contents + \"\\\\\"));\n            }\n            super.visitElement(element);\n        }\n        public String[] getNamespaces() {\n            if (ns == null) {\n                return new String[0];\n            }\n            return ns.toArray(new String[0]);\n        }\n    }\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {\n        return findExtensionKeyFromFile(file.getVirtualFile());\n    }\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {\n        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);\n        if (extensionRootFolder == null) {\n            return null;\n        }\n        String extensionKey;\n        VirtualFile composerJsonFile = extensionRootFolder.findChild(\"composer.json\");\n        if (composerJsonFile != null) {\n            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);\n            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);\n        } else {\n            extensionKey = extensionRootFolder.getName();\n        }\n        return extensionKey;\n    }\n"]], "pred": {"ppl": 1.6304328441619873, "ppl_lower": 2.12214732170105, "ppl/lowercase_ppl": -1.5391947360726494, "ppl/zlib": 0.00037459427443105564, "Min_5.0% Prob": 5.686152570387897, "Min_10.0% Prob": 3.977249193425272, "Min_20.0% Prob": 2.33917993833037, "Min_30.0% Prob": 1.612819395691546, "Min_40.0% Prob": 1.217991894165687, "Min_50.0% Prob": 0.977442166553865, "Min_60.0% Prob": 0.8155068815898509}}
{"hexsha": "12c6b162778cfc33f04b38dd1d9c10eacd9db16e", "ext": "java", "lang": "Java", "content": "public class LocalBoundary {\n\n\tprivate static final int MAX_LOCAL_SEGS = 8;\n\n\tprivate static class Segment {\n\t\t/** Segment start/end */\n\t\tfloat[] s = new float[6];\n\t\t/** Distance for pruning. */\n\t\tfloat d;\n\t}\n\n\tfloat[] m_center = new float[3];\n\tList<Segment> m_segs = new ArrayList<>();\n\tList<Long> m_polys = new ArrayList<>();\n\n\tprotected LocalBoundary() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t}\n\n\tprotected void reset() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t\tm_polys.clear();\n\t\tm_segs.clear();\n\t}\n\n\tprotected void addSegment(float dist, float[] s) {\n\t\t// Insert neighbour based on the distance.\n\t\tSegment seg = new Segment();\n\t\tSystem.arraycopy(s, 0, seg.s, 0, 6);\n\t\tseg.d = dist;\n\t\tif (m_segs.isEmpty()) {\n\t\t\tm_segs.add(seg);\n\t\t} else if (dist >= m_segs.get(m_segs.size() - 1).d) {\n\t\t\tif (m_segs.size() >= MAX_LOCAL_SEGS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tm_segs.add(seg);\n\t\t} else {\n\t\t\t// Insert inbetween.\n\t\t\tint i;\n\t\t\tfor (i = 0; i < m_segs.size(); ++i)\n\t\t\t\tif (dist <= m_segs.get(i).d)\n\t\t\t\t\tbreak;\n\t\t\tm_segs.add(i, seg);\n\t\t}\n\t\twhile (m_segs.size() > MAX_LOCAL_SEGS) {\n\t\t\tm_segs.remove(m_segs.size() - 1);\n\t\t}\n\t}\n\n\tpublic void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (ref == 0) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\t\tvCopy(m_center, pos);\n\t\t// First query non-overlapping polygons.\n\t\tFindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);\n\t\tthis.m_polys = res.getRefs();\n\t\tm_segs.clear();\n\t\t// Secondly, store all polygon edges.\n\t\tfor (int j = 0; j < m_polys.size(); ++j) {\n\t\t\tGetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);\n\t\t\tfor (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {\n\t\t\t\tfloat[] s = gpws.getSegmentVerts().get(k);\n\t\t\t\t// Skip too distant segments.\n\t\t\t\tTupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);\n\t\t\t\tif (distseg.first > sqr(collisionQueryRange))\n\t\t\t\t\tcontinue;\n\t\t\t\taddSegment(distseg.first, s);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean isValid(NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (m_polys.isEmpty())\n\t\t\treturn false;\n\n\t\t// Check that all polygons still pass query filter.\n\t\tfor (long ref : m_polys) {\n\t\t\tif (!navquery.isValidPolyRef(ref, filter))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic float[] getCenter() {\n\t\treturn m_center;\n\t}\n\n\tpublic float[] getSegment(int j) {\n\t\treturn m_segs.get(j).s;\n\t}\n\n\tpublic int getSegmentCount() {\n\t\treturn m_segs.size();\n\t}\n}", "class_id": 0, "repo": "Warkdev/recast4j", "file": "detourcrowd/src/main/java/org/recast4j/detour/crowd/LocalBoundary.java", "last_update_at": "2021-06-25T15:46:37+00:00", "question_id": "12c6b162778cfc33f04b38dd1d9c10eacd9db16e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocalBoundary {\n\tprivate static final int MAX_LOCAL_SEGS = 8;\n\tprivate static class Segment {\n\t\t/** Segment start/end */\n\t\tfloat[] s = new float[6];\n\t\t/** Distance for pruning. */\n\t\tfloat d;\n\t}\n\tfloat[] m_center = new float[3];\n\tList<Segment> m_segs = new ArrayList<>();\n\tList<Long> m_polys = new ArrayList<>();\n\tprotected LocalBoundary() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t}\n\tprotected void reset() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t\tm_polys.clear();\n\t\tm_segs.clear();\n\t}\n\tprotected void addSegment(float dist, float[] s) {\n\t\t// Insert neighbour based on the distance.\n\t\tSegment seg = new Segment();\n\t\tSystem.arraycopy(s, 0, seg.s, 0, 6);\n\t\tseg.d = dist;\n\t\tif (m_segs.isEmpty()) {\n\t\t\tm_segs.add(seg);\n\t\t} else if (dist >= m_segs.get(m_segs.size() - 1).d) {\n\t\t\tif (m_segs.size() >= MAX_LOCAL_SEGS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tm_segs.add(seg);\n\t\t} else {\n\t\t\t// Insert inbetween.\n\t\t\tint i;\n\t\t\tfor (i = 0; i < m_segs.size(); ++i)\n\t\t\t\tif (dist <= m_segs.get(i).d)\n\t\t\t\t\tbreak;\n\t\t\tm_segs.add(i, seg);\n\t\t}\n\t\twhile (m_segs.size() > MAX_LOCAL_SEGS) {\n\t\t\tm_segs.remove(m_segs.size() - 1);\n\t\t}\n\t}\n\tpublic void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (ref == 0) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\t\tvCopy(m_center, pos);\n\t\t// First query non-overlapping polygons.\n\t\tFindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);\n\t\tthis.m_polys = res.getRefs();\n\t\tm_segs.clear();\n\t\t// Secondly, store all polygon edges.\n\t\tfor (int j = 0; j < m_polys.size(); ++j) {\n\t\t\tGetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);\n\t\t\tfor (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {\n\t\t\t\tfloat[] s = gpws.getSegmentVerts().get(k);\n\t\t\t\t// Skip too distant segments.\n\t\t\t\tTupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);\n\t\t\t\tif (distseg.first > sqr(collisionQueryRange))\n\t\t\t\t\tcontinue;\n\t\t\t\taddSegment(distseg.first, s);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isValid(NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (m_polys.isEmpty())\n\t\t\treturn false;\n\t\t// Check that all polygons still pass query filter.\n\t\tfor (long ref : m_polys) {\n\t\t\tif (!navquery.isValidPolyRef(ref, filter))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic float[] getCenter() {\n\t\treturn m_center;\n\t}\n\tpublic float[] getSegment(int j) {\n\t\treturn m_segs.get(j).s;\n\t}\n\tpublic int getSegmentCount() {\n\t\treturn m_segs.size();\n\t}\n"]], "pred": {"ppl": 1.7871830463409424, "ppl_lower": 1.9918655157089233, "ppl/lowercase_ppl": -1.186743692687815, "ppl/zlib": 0.0005748917456744706, "Min_5.0% Prob": 5.856074749254713, "Min_10.0% Prob": 4.259677155345094, "Min_20.0% Prob": 2.706429360251801, "Min_30.0% Prob": 1.9075162847057667, "Min_40.0% Prob": 1.4460465865332661, "Min_50.0% Prob": 1.1610768888138394, "Min_60.0% Prob": 0.9687109363909513}}
{"hexsha": "88dd300f77e53e19d8f96d18b70087d68f88fb62", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class InstantiatedLambdasTestRunner extends TestBase {\n\n  static final Class<?> CLASS = InstantiatedLambdasTest.class;\n  static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;\n  static final String EXPECTED = StringUtils.lines(\"Class implementation\", \"Lambda implementation\");\n\n  private final TestParameters parameters;\n\n  private Path inputJar;\n\n  @Parameters(name = \"{0}\")\n  public static TestParametersCollection data() {\n    return getTestParameters().withAllRuntimesAndApiLevels().build();\n  }\n\n  public InstantiatedLambdasTestRunner(TestParameters parameters) {\n    this.parameters = parameters;\n  }\n\n  @Before\n  public void writeAndRunInputJar() throws IOException {\n    inputJar = temp.getRoot().toPath().resolve(\"input.jar\");\n    ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);\n    for (Class<?> clazz : CLASSES) {\n      buildInput.accept(\n          ByteDataView.of(ToolHelper.getClassAsBytes(clazz)),\n          DescriptorUtils.javaTypeToDescriptor(clazz.getName()),\n          null);\n    }\n    buildInput.finished(null);\n  }\n\n  @Test\n  public void testProguard() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg.jar\", false);\n  }\n\n  @Test\n  public void testProguardAggressive() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg-aggressive.jar\", true);\n  }\n\n  @Test\n  public void testR8() throws Exception {\n    testR8(false);\n  }\n\n  @Test\n  public void testR8Aggressive() throws Exception {\n    testR8(true);\n  }\n\n  private void testR8(boolean aggressive) throws Exception {\n    testForR8(parameters.getBackend())\n        .addProgramFiles(inputJar)\n        .addKeepMainRule(CLASS)\n        .applyIf(aggressive, builder -> builder.addKeepRules(\"-overloadaggressively\"))\n        .debug()\n        .setMinApi(parameters.getApiLevel())\n        .compile()\n        .apply(\n            compileResult ->\n                compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED))\n        .applyIf(\n            parameters.isDexRuntime(),\n            compileResult ->\n                compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());\n  }\n\n  private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {\n    Path pgConfig = writeProguardRules(aggressive);\n    Path outPg = temp.getRoot().toPath().resolve(outName);\n    ProcessResult proguardResult =\n        ToolHelper.runProguard6Raw(\n            inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);\n    System.out.println(proguardResult.stdout);\n    if (proguardResult.exitCode != 0) {\n      System.out.println(proguardResult.stderr);\n    }\n    assertEquals(0, proguardResult.exitCode);\n    ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());\n    assertEquals(0, runPg.exitCode);\n  }\n\n  private Path writeProguardRules(boolean aggressive) throws IOException {\n    Path pgConfig = temp.getRoot().toPath().resolve(\"keep.txt\");\n    FileUtils.writeTextFile(\n        pgConfig,\n        \"-keep public class \" + CLASS.getCanonicalName() + \" {\",\n        \"  public static void main(...);\",\n        \"}\",\n        aggressive ? \"-overloadaggressively\" : \"# Not overloading aggressively\");\n    return pgConfig;\n  }\n}", "class_id": 0, "repo": "kami-lang/madex-r8", "file": "src/test/java/com/android/tools/r8/shaking/InstantiatedLambdasTestRunner.java", "last_update_at": "2021-09-01T09:50:44+00:00", "question_id": "88dd300f77e53e19d8f96d18b70087d68f88fb62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class InstantiatedLambdasTestRunner extends TestBase {\n  static final Class<?> CLASS = InstantiatedLambdasTest.class;\n  static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;\n  static final String EXPECTED = StringUtils.lines(\"Class implementation\", \"Lambda implementation\");\n  private final TestParameters parameters;\n  private Path inputJar;\n  @Parameters(name = \"{0}\")\n  public static TestParametersCollection data() {\n    return getTestParameters().withAllRuntimesAndApiLevels().build();\n  }\n  public InstantiatedLambdasTestRunner(TestParameters parameters) {\n    this.parameters = parameters;\n  }\n  @Before\n  public void writeAndRunInputJar() throws IOException {\n    inputJar = temp.getRoot().toPath().resolve(\"input.jar\");\n    ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);\n    for (Class<?> clazz : CLASSES) {\n      buildInput.accept(\n          ByteDataView.of(ToolHelper.getClassAsBytes(clazz)),\n          DescriptorUtils.javaTypeToDescriptor(clazz.getName()),\n          null);\n    }\n    buildInput.finished(null);\n  }\n  @Test\n  public void testProguard() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg.jar\", false);\n  }\n  @Test\n  public void testProguardAggressive() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg-aggressive.jar\", true);\n  }\n  @Test\n  public void testR8() throws Exception {\n    testR8(false);\n  }\n  @Test\n  public void testR8Aggressive() throws Exception {\n    testR8(true);\n  }\n  private void testR8(boolean aggressive) throws Exception {\n    testForR8(parameters.getBackend())\n        .addProgramFiles(inputJar)\n        .addKeepMainRule(CLASS)\n        .applyIf(aggressive, builder -> builder.addKeepRules(\"-overloadaggressively\"))\n        .debug()\n        .setMinApi(parameters.getApiLevel())\n        .compile()\n        .apply(\n            compileResult ->\n                compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED))\n        .applyIf(\n            parameters.isDexRuntime(),\n            compileResult ->\n                compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());\n  }\n  private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {\n    Path pgConfig = writeProguardRules(aggressive);\n    Path outPg = temp.getRoot().toPath().resolve(outName);\n    ProcessResult proguardResult =\n        ToolHelper.runProguard6Raw(\n            inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);\n    System.out.println(proguardResult.stdout);\n    if (proguardResult.exitCode != 0) {\n      System.out.println(proguardResult.stderr);\n    }\n    assertEquals(0, proguardResult.exitCode);\n    ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());\n    assertEquals(0, runPg.exitCode);\n  }\n  private Path writeProguardRules(boolean aggressive) throws IOException {\n    Path pgConfig = temp.getRoot().toPath().resolve(\"keep.txt\");\n    FileUtils.writeTextFile(\n        pgConfig,\n        \"-keep public class \" + CLASS.getCanonicalName() + \" {\",\n        \"  public static void main(...);\",\n        \"}\",\n        aggressive ? \"-overloadaggressively\" : \"# Not overloading aggressively\");\n    return pgConfig;\n  }\n"]], "pred": {"ppl": 1.5848774909973145, "ppl_lower": 2.5570287704467773, "ppl/lowercase_ppl": -2.0387219312066267, "ppl/zlib": 0.0004108002779623835, "Min_5.0% Prob": 5.4288084069076845, "Min_10.0% Prob": 3.8298422584728318, "Min_20.0% Prob": 2.2172675604747636, "Min_30.0% Prob": 1.524064381040532, "Min_40.0% Prob": 1.150234090044057, "Min_50.0% Prob": 0.9213223525941342, "Min_60.0% Prob": 0.7678792124944323}}
{"hexsha": "176afd6c9a0292ae4cd8a03ac5d1212ccc2d7dc6", "ext": "java", "lang": "Java", "content": "class Arithmatic\r\n{\r\n    public static void main(String args[])\r\n    {\r\n        if(args.length != 2)\r\n        {\r\n            System.out.println(\"Please Enter Values \");\r\n            return;\r\n        }\r\n\r\n        // take the numbers from args, would be in string form \r\n        String s1 = args[0];\r\n        String s2 = args[1];\r\n\r\n        // convert them into numeric\r\n        double d1 = Double.parseDouble(s1);\r\n        double d2 = Double.parseDouble(s2);\r\n\r\n        double d3 = d1 + d2;\r\n        System.out.println(\"The Sum is : \" + d3);\r\n    }\r\n}", "class_id": 0, "repo": "PRASAD-DANGARE/JAVA", "file": "Command_Line_args2.java", "last_update_at": "2021-07-06T16:41:07+00:00", "question_id": "176afd6c9a0292ae4cd8a03ac5d1212ccc2d7dc6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Arithmatic\r\n{\r\n    public static void main(String args[])\r\n    {\r\n        if(args.length != 2)\r\n        {\r\n            System.out.println(\"Please Enter Values \");\r\n            return;\r\n        }\r\n\r\n        // take the numbers from args, would be in string form \r\n        String s1 = args[0];\r\n        String s2 = args[1];\r\n\r\n        // convert them into numeric\r\n        double d1 = Double.parseDouble(s1);\r\n        double d2 = Double.parseDouble(s2);\r\n\r\n        double d3 = d1 + d2;\r\n        System.out.println(\"The Sum is : \" + d3);\r\n    }\r\n"]], "pred": {"ppl": 2.4112884998321533, "ppl_lower": 2.7483861446380615, "ppl/lowercase_ppl": -1.148668929444106, "ppl/zlib": 0.003110110430610998, "Min_5.0% Prob": 7.081078827381134, "Min_10.0% Prob": 5.372930624905755, "Min_20.0% Prob": 3.778996393961065, "Min_30.0% Prob": 2.8057865325142357, "Min_40.0% Prob": 2.1711499410517074, "Min_50.0% Prob": 1.7514335920705515, "Min_60.0% Prob": 1.4649262275802446}}
{"hexsha": "b58650221f683f40085428f04a18ec28d51489f9", "ext": "java", "lang": "Java", "content": "public class c {\n    private static final String a;\n\n    static {\n        a = c.class.getSimpleName();\n    }\n\n    public static void a(a aVar) {\n        if (DownloadService.a() == null) {\n            Bundle bundle;\n            Intent intent = new Intent();\n            intent.setClass(BrothersApplication.a(), LoadingActivity.class);\n            intent.addFlags(268435456);\n            intent.addFlags(67108864);\n            if (aVar == null) {\n                bundle = null;\n            } else {\n                bundle = new Bundle();\n                bundle.putString(\"cooperation_url\", aVar.a);\n                bundle.putString(\"cooperation_decode_url\", aVar.b);\n                bundle.putString(\"cooperation_title\", aVar.c);\n                bundle.putInt(\"cooperation_type\", aVar.d);\n                bundle.putInt(\"cooperation_play_time\", aVar.e);\n            }\n            if (bundle != null) {\n                intent.putExtras(bundle);\n            }\n            BrothersApplication.a().startActivity(intent);\n            return;\n        }\n        Object obj;\n        String str = aVar.a;\n        if (str.isEmpty() || !str.endsWith(\".torrent\")) {\n            obj = null;\n        } else {\n            obj = 1;\n        }\n        if (obj == null) {\n            aVar.b = aVar.a;\n            VodUtil.a();\n            VodUtil.a(aVar);\n        } else if (TextUtils.isEmpty(aVar.b)) {\n            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);\n            intent2.putExtra(\"cooperation_url\", aVar.a);\n            intent2.putExtra(\"cooperation_caller_packagename\", aVar.g);\n            intent2.setFlags(268435456);\n            intent2.addFlags(67108864);\n            BrothersApplication.a().startActivity(intent2);\n        } else {\n            VodUtil.a();\n            VodUtil.a(aVar);\n        }\n    }\n\n    public static a a(Intent intent) {\n        if (intent == null) {\n            return null;\n        }\n        a aVar;\n        int intExtra = intent.getIntExtra(\"cooperation_type\", 0);\n        if (b.a(intExtra)) {\n            String stringExtra = intent.getStringExtra(\"cooperation_url\");\n            intent.getStringExtra(\"cooperation_decode_url\");\n            aVar = new a(stringExtra, intent.getStringExtra(\"cooperation_title\"), intExtra, intent.getIntExtra(\"cooperation_play_time\", 0), null);\n        } else {\n            aVar = null;\n        }\n        return aVar;\n    }\n\n    public static String a(int i) {\n        return i == 1 ? \"uc\" : a.d;\n    }\n\n    public static int a(String str) {\n        return \"uc\".equals(str) ? 1 : 0;\n    }\n}", "class_id": 0, "repo": "megahertz0/android_thunder", "file": "dex_src/com/xunlei/downloadprovider/vod/a/c.java", "last_update_at": "2021-11-18T02:55:40+00:00", "question_id": "b58650221f683f40085428f04a18ec28d51489f9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class c {\n    private static final String a;\n    static {\n        a = c.class.getSimpleName();\n    }\n    public static void a(a aVar) {\n        if (DownloadService.a() == null) {\n            Bundle bundle;\n            Intent intent = new Intent();\n            intent.setClass(BrothersApplication.a(), LoadingActivity.class);\n            intent.addFlags(268435456);\n            intent.addFlags(67108864);\n            if (aVar == null) {\n                bundle = null;\n            } else {\n                bundle = new Bundle();\n                bundle.putString(\"cooperation_url\", aVar.a);\n                bundle.putString(\"cooperation_decode_url\", aVar.b);\n                bundle.putString(\"cooperation_title\", aVar.c);\n                bundle.putInt(\"cooperation_type\", aVar.d);\n                bundle.putInt(\"cooperation_play_time\", aVar.e);\n            }\n            if (bundle != null) {\n                intent.putExtras(bundle);\n            }\n            BrothersApplication.a().startActivity(intent);\n            return;\n        }\n        Object obj;\n        String str = aVar.a;\n        if (str.isEmpty() || !str.endsWith(\".torrent\")) {\n            obj = null;\n        } else {\n            obj = 1;\n        }\n        if (obj == null) {\n            aVar.b = aVar.a;\n            VodUtil.a();\n            VodUtil.a(aVar);\n        } else if (TextUtils.isEmpty(aVar.b)) {\n            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);\n            intent2.putExtra(\"cooperation_url\", aVar.a);\n            intent2.putExtra(\"cooperation_caller_packagename\", aVar.g);\n            intent2.setFlags(268435456);\n            intent2.addFlags(67108864);\n            BrothersApplication.a().startActivity(intent2);\n        } else {\n            VodUtil.a();\n            VodUtil.a(aVar);\n        }\n    }\n    public static a a(Intent intent) {\n        if (intent == null) {\n            return null;\n        }\n        a aVar;\n        int intExtra = intent.getIntExtra(\"cooperation_type\", 0);\n        if (b.a(intExtra)) {\n            String stringExtra = intent.getStringExtra(\"cooperation_url\");\n            intent.getStringExtra(\"cooperation_decode_url\");\n            aVar = new a(stringExtra, intent.getStringExtra(\"cooperation_title\"), intExtra, intent.getIntExtra(\"cooperation_play_time\", 0), null);\n        } else {\n            aVar = null;\n        }\n        return aVar;\n    }\n    public static String a(int i) {\n        return i == 1 ? \"uc\" : a.d;\n    }\n    public static int a(String str) {\n        return \"uc\".equals(str) ? 1 : 0;\n    }\n"]], "pred": {"ppl": 1.727325439453125, "ppl_lower": 2.0199222564697266, "ppl/lowercase_ppl": -1.286301097953856, "ppl/zlib": 0.0007612454366024277, "Min_5.0% Prob": 6.001752803200169, "Min_10.0% Prob": 4.054857715180046, "Min_20.0% Prob": 2.4906355824345856, "Min_30.0% Prob": 1.7704133988074635, "Min_40.0% Prob": 1.3578455781363896, "Min_50.0% Prob": 1.0912267524836352, "Min_60.0% Prob": 0.9121764434739421}}
{"hexsha": "3821c2ca9d58dbb74b7f64e42156ebd845507391", "ext": "java", "lang": "Java", "content": "@Data\r\npublic class RouteClientInit {\r\n\tprivate final String url;\r\n\tprivate final int maxContentLength;\r\n\tprivate final String headerRouteValue;\r\n\tprivate Channel channel;\r\n\tprivate CompletableFuture<DefaultFullHttpResponse> response;\r\n\r\n\tpublic RouteClientInit(String url, int maxContentLength, String headerRouteValue) {\r\n\t\tthis.url = url;\r\n\t\tthis.maxContentLength = maxContentLength;\r\n\t\tthis.headerRouteValue = headerRouteValue;\r\n\t}\r\n\r\n\tpublic DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {\r\n\t\tinit().writeAndFlush(defaultFullHttpRequest);\r\n\t\treturn response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);\r\n\t}\r\n\r\n\tpublic void call(DefaultFullHttpResponse defaultFullHttpResponse) {\r\n\t\tresponse.complete(defaultFullHttpResponse);\r\n\t}\r\n\r\n\tprivate Channel init() throws InterruptedException {\r\n\t\tresponse = new CompletableFuture<>();\r\n\t\tif (ChannelUtils.channelIsActive(channel)) {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\t\tchannel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue))\r\n\t\t\t\t.channel(NioSocketChannel.class)\r\n\t\t\t\t.handler(new RouteClientInitializer(this))\r\n\t\t\t\t.connect(SocketAddressUtils.getInetSocketAddress(url))\r\n\t\t\t\t.sync()\r\n\t\t\t\t.channel();\r\n\t\treturn channel;\r\n\t}\r\n\r\n\r\n}", "class_id": 0, "repo": "15662664518/web-route-spring-boot-starter", "file": "web-route-spring-boot-autoconfigure/src/main/java/com/github/thierrysquirrel/web/route/netty/client/init/RouteClientInit.java", "last_update_at": "2021-05-22T03:56:42+00:00", "question_id": "3821c2ca9d58dbb74b7f64e42156ebd845507391", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\r\npublic class RouteClientInit {\r\n\tprivate final String url;\r\n\tprivate final int maxContentLength;\r\n\tprivate final String headerRouteValue;\r\n\tprivate Channel channel;\r\n\tprivate CompletableFuture<DefaultFullHttpResponse> response;\r\n\r\n\tpublic RouteClientInit(String url, int maxContentLength, String headerRouteValue) {\r\n\t\tthis.url = url;\r\n\t\tthis.maxContentLength = maxContentLength;\r\n\t\tthis.headerRouteValue = headerRouteValue;\r\n\t}\r\n\r\n\tpublic DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {\r\n\t\tinit().writeAndFlush(defaultFullHttpRequest);\r\n\t\treturn response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);\r\n\t}\r\n\r\n\tpublic void call(DefaultFullHttpResponse defaultFullHttpResponse) {\r\n\t\tresponse.complete(defaultFullHttpResponse);\r\n\t}\r\n\r\n\tprivate Channel init() throws InterruptedException {\r\n\t\tresponse = new CompletableFuture<>();\r\n\t\tif (ChannelUtils.channelIsActive(channel)) {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\t\tchannel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue))\r\n\t\t\t\t.channel(NioSocketChannel.class)\r\n\t\t\t\t.handler(new RouteClientInitializer(this))\r\n\t\t\t\t.connect(SocketAddressUtils.getInetSocketAddress(url))\r\n\t\t\t\t.sync()\r\n\t\t\t\t.channel();\r\n\t\treturn channel;\r\n\t}\r\n\r\n\r\n"]], "pred": {"ppl": 2.076364278793335, "ppl_lower": 2.6573827266693115, "ppl/lowercase_ppl": -1.3376910196252125, "ppl/zlib": 0.0013759292304910255, "Min_5.0% Prob": 6.950626047034013, "Min_10.0% Prob": 5.252984567692406, "Min_20.0% Prob": 3.379281408600993, "Min_30.0% Prob": 2.3902683439182826, "Min_40.0% Prob": 1.8157993104669357, "Min_50.0% Prob": 1.4592999324740208, "Min_60.0% Prob": 1.2214959286733387}}
{"hexsha": "ff542139117e2ec97abdccaa834b9817bd33a05d", "ext": "java", "lang": "Java", "content": "public class DBController {\n    private static final String DB_NAME = \"fruits_db.db\";\n    private DaoMaster.DevOpenHelper mHelpler;\n    private SQLiteDatabase mDb;\n    private DaoMaster mDaoMaster;\n    private DaoSession mDaoSession;\n    private Context mContext;\n    private UserDao mUserDao;\n    private HistoryDao mHistoryDao;\n    private CollectionDao mCollectionDao;\n    private QuickDao mQuickDao;\n    private static DBController sDbController;\n\n    public static DBController getInstance(Context context) {\n        if (sDbController == null) {\n            synchronized (DBController.class){\n                if (sDbController == null) {\n                    sDbController = new DBController(context);\n                }\n            }\n        }\n        return sDbController;\n    }\n\n    public DBController(Context context) {\n        mContext = context;\n        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        mDaoMaster = new DaoMaster(getWrittableDatabase());\n        mDaoSession = mDaoMaster.newSession();\n        mUserDao = mDaoSession.getUserDao();\n        mHistoryDao = mDaoSession.getHistoryDao();\n        mCollectionDao = mDaoSession.getCollectionDao();\n        mQuickDao = mDaoSession.getQuickDao();\n    }\n\n    private SQLiteDatabase getWrittableDatabase() {\n        if (mHelpler == null) {\n            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        }\n        mDb = mHelpler.getWritableDatabase();\n        return mDb;\n    }\n\n    public long insertUser(User user) {\n        return mUserDao.insert(user);\n    }\n\n    public User checkUserAndPassword(String whereUser, String wherePassword) {\n        User user = mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser),\n                        UserDao.Properties.Password.eq(wherePassword)).build().unique();\n        return user;\n    }\n\n    public boolean checkUserExist(String whereUser) {\n        List<User>users = (List<User>)mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser)).build().list();\n        return !users.isEmpty();\n    }\n\n    public void insertHistory(List<History> histories) {\n        for (int i = 0; i < histories.size(); i++) {\n            List<History>res = mHistoryDao.queryBuilder()\n                    .where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(histories.get(i).getTime()))\n                    .build().list();\n            if (res == null || res.isEmpty()) {\n                mHistoryDao.insert(histories.get(i));\n            } else {\n                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                        HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete()\n                        .executeDeleteWithoutDetachingEntities();\n                mHistoryDao.insert(histories.get(i));\n            }\n        }\n    }\n\n    public void deleteAllHistory() {\n        mHistoryDao.deleteAll();\n    }\n\n    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < historiesToBeDeleted.size(); i++) {\n                    mHistoryDao.queryBuilder()\n                            .where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public List<History> getAll() {\n        List<History> all = (List<History>)mHistoryDao.queryBuilder().build().list();\n        return all;\n    }\n\n    public List<Collection> getUserCollection(String username) {\n        List<Collection> res = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username)).build().list();\n        return res;\n    }\n\n    public void addCollection(String username, String url, String title) {\n        List<Collection> exist = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username),\n                        CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title))\n                .build().list();\n        if (exist == null || exist.isEmpty()) {\n            mCollectionDao.insert(new Collection(username, url, title));\n        } else {\n            return;\n        }\n    }\n\n    public void deleteAllCollection(String username) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void deleteSelectedCollection(List<Collection> toBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < toBeDeleted.size(); i++) {\n                    mCollectionDao.queryBuilder()\n                            .where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()),\n                            CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()),\n                            CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public void changeUsername(String name, String newName) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setCustomizeName(newName);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public String getProfile(String name) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        return findUser.getProfile();\n    }\n\n    public void setProfile(String name, String profile) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setProfile(profile);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void changePassword(String name, String newPassword) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setPassword(newPassword);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void deleteUser(String name) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public boolean insertQuick(String title, String url) {\n        Quick quick = new Quick(null, title, url);\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        if (res != null) {\n            return false;\n        } else {\n            mQuickDao.insert(quick);\n            return true;\n        }\n    }\n\n    public List<Quick> getQuick() {\n        return mQuickDao.loadAll();\n    }\n\n    public void deleteQuick(String title, String url) {\n        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void changeQuick(String title, String url, String newTitle, String newUrl) {\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        res.setTitle(newTitle);\n        res.setUrl(newUrl);\n        mQuickDao.update(res);\n    }\n}", "class_id": 0, "repo": "HeXavi8/Orange-Browser", "file": "app/src/main/java/com/example/fruit/dao/DBController.java", "last_update_at": "2021-11-28T01:58:02+00:00", "question_id": "ff542139117e2ec97abdccaa834b9817bd33a05d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DBController {\n    private static final String DB_NAME = \"fruits_db.db\";\n    private DaoMaster.DevOpenHelper mHelpler;\n    private SQLiteDatabase mDb;\n    private DaoMaster mDaoMaster;\n    private DaoSession mDaoSession;\n    private Context mContext;\n    private UserDao mUserDao;\n    private HistoryDao mHistoryDao;\n    private CollectionDao mCollectionDao;\n    private QuickDao mQuickDao;\n    private static DBController sDbController;\n    public static DBController getInstance(Context context) {\n        if (sDbController == null) {\n            synchronized (DBController.class){\n                if (sDbController == null) {\n                    sDbController = new DBController(context);\n                }\n            }\n        }\n        return sDbController;\n    }\n    public DBController(Context context) {\n        mContext = context;\n        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        mDaoMaster = new DaoMaster(getWrittableDatabase());\n        mDaoSession = mDaoMaster.newSession();\n        mUserDao = mDaoSession.getUserDao();\n        mHistoryDao = mDaoSession.getHistoryDao();\n        mCollectionDao = mDaoSession.getCollectionDao();\n        mQuickDao = mDaoSession.getQuickDao();\n    }\n    private SQLiteDatabase getWrittableDatabase() {\n        if (mHelpler == null) {\n            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        }\n        mDb = mHelpler.getWritableDatabase();\n        return mDb;\n    }\n    public long insertUser(User user) {\n        return mUserDao.insert(user);\n    }\n    public User checkUserAndPassword(String whereUser, String wherePassword) {\n        User user = mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser),\n                        UserDao.Properties.Password.eq(wherePassword)).build().unique();\n        return user;\n    }\n    public boolean checkUserExist(String whereUser) {\n        List<User>users = (List<User>)mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser)).build().list();\n        return !users.isEmpty();\n    }\n    public void insertHistory(List<History> histories) {\n        for (int i = 0; i < histories.size(); i++) {\n            List<History>res = mHistoryDao.queryBuilder()\n                    .where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(histories.get(i).getTime()))\n                    .build().list();\n            if (res == null || res.isEmpty()) {\n                mHistoryDao.insert(histories.get(i));\n            } else {\n                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                        HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete()\n                        .executeDeleteWithoutDetachingEntities();\n                mHistoryDao.insert(histories.get(i));\n            }\n        }\n    }\n    public void deleteAllHistory() {\n        mHistoryDao.deleteAll();\n    }\n    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < historiesToBeDeleted.size(); i++) {\n                    mHistoryDao.queryBuilder()\n                            .where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n    public List<History> getAll() {\n        List<History> all = (List<History>)mHistoryDao.queryBuilder().build().list();\n        return all;\n    }\n    public List<Collection> getUserCollection(String username) {\n        List<Collection> res = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username)).build().list();\n        return res;\n    }\n    public void addCollection(String username, String url, String title) {\n        List<Collection> exist = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username),\n                        CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title))\n                .build().list();\n        if (exist == null || exist.isEmpty()) {\n            mCollectionDao.insert(new Collection(username, url, title));\n        } else {\n            return;\n        }\n    }\n    public void deleteAllCollection(String username) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n    public void deleteSelectedCollection(List<Collection> toBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < toBeDeleted.size(); i++) {\n                    mCollectionDao.queryBuilder()\n                            .where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()),\n                            CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()),\n                            CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n    public void changeUsername(String name, String newName) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setCustomizeName(newName);\n            mUserDao.update(findUser);\n        }\n    }\n    public String getProfile(String name) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        return findUser.getProfile();\n    }\n    public void setProfile(String name, String profile) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setProfile(profile);\n            mUserDao.update(findUser);\n        }\n    }\n    public void changePassword(String name, String newPassword) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setPassword(newPassword);\n            mUserDao.update(findUser);\n        }\n    }\n    public void deleteUser(String name) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n    public boolean insertQuick(String title, String url) {\n        Quick quick = new Quick(null, title, url);\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        if (res != null) {\n            return false;\n        } else {\n            mQuickDao.insert(quick);\n            return true;\n        }\n    }\n    public List<Quick> getQuick() {\n        return mQuickDao.loadAll();\n    }\n    public void deleteQuick(String title, String url) {\n        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n    public void changeQuick(String title, String url, String newTitle, String newUrl) {\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        res.setTitle(newTitle);\n        res.setUrl(newUrl);\n        mQuickDao.update(res);\n    }\n"]], "pred": {"ppl": 1.424075961112976, "ppl_lower": 1.6512430906295776, "ppl/lowercase_ppl": -1.4186578314908942, "ppl/zlib": 0.0002339663501292421, "Min_5.0% Prob": 5.040740200117523, "Min_10.0% Prob": 3.1606585582097373, "Min_20.0% Prob": 1.7285670575631016, "Min_30.0% Prob": 1.171741705978277, "Min_40.0% Prob": 0.8812625600334739, "Min_50.0% Prob": 0.7067627055304391, "Min_60.0% Prob": 0.58967185230754}}
{"hexsha": "48e6cf123eb4cbfdcdfdd0e229d4bb6928328e8c", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class CommonFloatService {\n\n    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);\n\n    private final CommonFloatRepository commonFloatRepository;\n\n    private final CacheManager cacheManager;\n\n    private final CommonFloatMapper commonFloatMapper;\n\n    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {\n        this.commonFloatRepository = commonFloatRepository;\n        this.cacheManager = cacheManager;\n        this.commonFloatMapper = commonFloatMapper;\n    }\n\n    /**\n     * Save a commonFloat.\n     *\n     * @param commonFloatDTO the entity to save.\n     * @return the persisted entity.\n     */\n    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {\n        log.debug(\"Request to save CommonFloat : {}\", commonFloatDTO);\n        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);\n        commonFloat = commonFloatRepository.save(commonFloat);\n        return commonFloatMapper.toDto(commonFloat);\n    }\n\n    /**\n     * Get all the commonFloats.\n     *\n     * @param pageable the pagination information.\n     * @return the list of entities.\n     */\n    @Transactional(readOnly = true)\n    public Page<CommonFloatDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all CommonFloats\");\n        return commonFloatRepository.findAll(pageable)\n            .map(commonFloatMapper::toDto);\n    }\n\n    /**\n    * count all the commonFloats.\n    *\n    * @return the count of entities\n    * by wangxin\n    */\n    @Transactional(readOnly = true)\n    public long count() {\n        log.debug(\"Request to count all CommonFloats\");\n        return commonFloatRepository.count();\n    }\n\n    /**\n     * Get one commonFloat by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Transactional(readOnly = true)\n    public Optional<CommonFloatDTO> findOne(Long id) {\n        log.debug(\"Request to get CommonFloat : {}\", id);\n        return commonFloatRepository.findById(id)\n            .map(commonFloatMapper::toDto);\n    }\n\n    /**\n     * Delete the commonFloat by id.\n     *\n     * @param id the id of the entity.\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete CommonFloat : {}\", id);\n        commonFloatRepository.deleteById(id);\n    }\n\n    /**\n     * Update specified fields by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n\n    /**\n     * Update specified field by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO,fieldName));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n    // jhipster-needle-service-add-method - JHipster will add getters and setters here, do not remove\n\n}", "class_id": 0, "repo": "wangxinxx/jhi-ant-vue", "file": "src/main/java/com/aidriveall/cms/service/CommonFloatService.java", "last_update_at": "2021-08-18T18:54:11+00:00", "question_id": "48e6cf123eb4cbfdcdfdd0e229d4bb6928328e8c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class CommonFloatService {\n    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);\n    private final CommonFloatRepository commonFloatRepository;\n    private final CacheManager cacheManager;\n    private final CommonFloatMapper commonFloatMapper;\n    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {\n        this.commonFloatRepository = commonFloatRepository;\n        this.cacheManager = cacheManager;\n        this.commonFloatMapper = commonFloatMapper;\n    }\n    /**\n     * Save a commonFloat.\n     *\n     * @param commonFloatDTO the entity to save.\n     * @return the persisted entity.\n     */\n    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {\n        log.debug(\"Request to save CommonFloat : {}\", commonFloatDTO);\n        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);\n        commonFloat = commonFloatRepository.save(commonFloat);\n        return commonFloatMapper.toDto(commonFloat);\n    }\n    /**\n     * Get all the commonFloats.\n     *\n     * @param pageable the pagination information.\n     * @return the list of entities.\n     */\n    @Transactional(readOnly = true)\n    public Page<CommonFloatDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all CommonFloats\");\n        return commonFloatRepository.findAll(pageable)\n            .map(commonFloatMapper::toDto);\n    }\n    /**\n    * count all the commonFloats.\n    *\n    * @return the count of entities\n    * by wangxin\n    */\n    @Transactional(readOnly = true)\n    public long count() {\n        log.debug(\"Request to count all CommonFloats\");\n        return commonFloatRepository.count();\n    }\n    /**\n     * Get one commonFloat by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Transactional(readOnly = true)\n    public Optional<CommonFloatDTO> findOne(Long id) {\n        log.debug(\"Request to get CommonFloat : {}\", id);\n        return commonFloatRepository.findById(id)\n            .map(commonFloatMapper::toDto);\n    }\n    /**\n     * Delete the commonFloat by id.\n     *\n     * @param id the id of the entity.\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete CommonFloat : {}\", id);\n        commonFloatRepository.deleteById(id);\n    }\n    /**\n     * Update specified fields by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n    /**\n     * Update specified field by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO,fieldName));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n    // jhipster-needle-service-add-method - JHipster will add getters and setters here, do not remove\n"]], "pred": {"ppl": 1.0969938039779663, "ppl_lower": 1.3023936748504639, "ppl/lowercase_ppl": -2.853989156507706, "ppl/zlib": 0.00011113269282807903, "Min_5.0% Prob": 1.7458453289371856, "Min_10.0% Prob": 0.9110885934626802, "Min_20.0% Prob": 0.46184249945539746, "Min_30.0% Prob": 0.30860890066214003, "Min_40.0% Prob": 0.2315897936839858, "Min_50.0% Prob": 0.18531256837131296, "Min_60.0% Prob": 0.15444221851874265}}
{"hexsha": "a38fec13b412ae11bdd8b5e9e7e1fe1d7cd98108", "ext": "java", "lang": "Java", "content": "public class IndustrialJackhammerItem extends JackhammerItem {\n\n\tpublic IndustrialJackhammerItem() {\n\t\tsuper(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);\n\t}\n\n\t// Cycle Inactive, Active 3*3 and Active 5*5\n\tprivate void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {\n\t\tItemUtils.checkActive(stack, cost, isClient, messageId);\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\tif (isClient) {\n\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"3*3\"));\n\t\t\t}\n\t\t} else {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\t} else {\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", true);\n\t\t\t\tif (isClient) {\n\t\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"5*5\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {\n\t\tif (originalPos.equals(pos)) {\n\t\t\treturn false;\n\t\t}\n\t\tBlockState blockState = worldIn.getBlockState(pos);\n\t\tif (blockState.getMaterial() == Material.AIR) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getMaterial().isLiquid()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof OreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof RedstoneOreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (Items.IRON_PICKAXE.isEffectiveOn(blockState));\n\t}\n\n\tprivate boolean isAOE5(ItemStack stack) {\n\t\treturn !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean(\"AOE5\");\n\t}\n\n\t// JackhammerItem\n\t@Override\n\tpublic boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t\t}\n\t\tint radius = isAOE5(stack) ? 2 : 1;\n\t\tfor (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {\n\t\t\tif (shouldBreak(worldIn, pos, additionalPos)) {\n\t\t\t\tToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);\n\t\t\t}\n\t\t}\n\n\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t}\n\n\t// PickaxeItem\n\t@Override\n\tpublic float getMiningSpeed(ItemStack stack, BlockState state) {\n\t\tif (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {\n\t\t\t// x4 diamond mining speed\n\t\t\treturn 32.0F;\n\t\t} else {\n\t\t\treturn 0.5F;\n\t\t}\n\t}\n\n\t// Item\n\t@Override\n\tpublic TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {\n\t\tfinal ItemStack stack = player.getStackInHand(hand);\n\t\tif (player.isSneaking()) {\n\t\t\tswitchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);\n\t\t\treturn new TypedActionResult<>(ActionResult.SUCCESS, stack);\n\t\t}\n\t\treturn new TypedActionResult<>(ActionResult.PASS, stack);\n\t}\n\n\t@Override\n\tpublic void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {\n\t\tItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);\n\t}\n\n\t@Environment(EnvType.CLIENT)\n\t@Override\n\tpublic void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {\n\t\tItemUtils.buildActiveTooltip(stack, tooltip);\n\t\tif (ItemUtils.isActive(stack)) {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\ttooltip.add(new LiteralText(\"5*5\").formatted(Formatting.RED));\n\t\t\t} else {\n\t\t\t\ttooltip.add(new LiteralText(\"3*3\").formatted(Formatting.RED));\n\t\t\t}\n\t\t}\n\t}\n}", "class_id": 0, "repo": "PhoneixS/TechReborn", "file": "src/main/java/techreborn/items/tool/industrial/IndustrialJackhammerItem.java", "last_update_at": "2021-03-12T06:48:49+00:00", "question_id": "a38fec13b412ae11bdd8b5e9e7e1fe1d7cd98108", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IndustrialJackhammerItem extends JackhammerItem {\n\tpublic IndustrialJackhammerItem() {\n\t\tsuper(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);\n\t}\n\t// Cycle Inactive, Active 3*3 and Active 5*5\n\tprivate void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {\n\t\tItemUtils.checkActive(stack, cost, isClient, messageId);\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\tif (isClient) {\n\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"3*3\"));\n\t\t\t}\n\t\t} else {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\t} else {\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", true);\n\t\t\t\tif (isClient) {\n\t\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"5*5\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {\n\t\tif (originalPos.equals(pos)) {\n\t\t\treturn false;\n\t\t}\n\t\tBlockState blockState = worldIn.getBlockState(pos);\n\t\tif (blockState.getMaterial() == Material.AIR) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getMaterial().isLiquid()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof OreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof RedstoneOreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (Items.IRON_PICKAXE.isEffectiveOn(blockState));\n\t}\n\tprivate boolean isAOE5(ItemStack stack) {\n\t\treturn !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean(\"AOE5\");\n\t}\n\t// JackhammerItem\n\t@Override\n\tpublic boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t\t}\n\t\tint radius = isAOE5(stack) ? 2 : 1;\n\t\tfor (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {\n\t\t\tif (shouldBreak(worldIn, pos, additionalPos)) {\n\t\t\t\tToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);\n\t\t\t}\n\t\t}\n\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t}\n\t// PickaxeItem\n\t@Override\n\tpublic float getMiningSpeed(ItemStack stack, BlockState state) {\n\t\tif (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {\n\t\t\t// x4 diamond mining speed\n\t\t\treturn 32.0F;\n\t\t} else {\n\t\t\treturn 0.5F;\n\t\t}\n\t}\n\t// Item\n\t@Override\n\tpublic TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {\n\t\tfinal ItemStack stack = player.getStackInHand(hand);\n\t\tif (player.isSneaking()) {\n\t\t\tswitchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);\n\t\t\treturn new TypedActionResult<>(ActionResult.SUCCESS, stack);\n\t\t}\n\t\treturn new TypedActionResult<>(ActionResult.PASS, stack);\n\t}\n\t@Override\n\tpublic void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {\n\t\tItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);\n\t}\n\t@Environment(EnvType.CLIENT)\n\t@Override\n\tpublic void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {\n\t\tItemUtils.buildActiveTooltip(stack, tooltip);\n\t\tif (ItemUtils.isActive(stack)) {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\ttooltip.add(new LiteralText(\"5*5\").formatted(Formatting.RED));\n\t\t\t} else {\n\t\t\t\ttooltip.add(new LiteralText(\"3*3\").formatted(Formatting.RED));\n\t\t\t}\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.7043228149414062, "ppl_lower": 2.10040283203125, "ppl/lowercase_ppl": -1.3919240309848828, "ppl/zlib": 0.0004341757783817278, "Min_5.0% Prob": 5.864806937236412, "Min_10.0% Prob": 4.142654823321922, "Min_20.0% Prob": 2.5243961580243766, "Min_30.0% Prob": 1.7581303568642124, "Min_40.0% Prob": 1.3292596291404555, "Min_50.0% Prob": 1.066595989269425, "Min_60.0% Prob": 0.8895867094849532}}
{"hexsha": "0258fec1fbbbd04e532d61c0a501cd3898fe0f43", "ext": "java", "lang": "Java", "content": "public class MockXDSBridge extends XDSBridge {\n\n    /**\n     * Constructs ...\n     *\n     *\n     * @param config\n     */\n    public MockXDSBridge(XDSBridgeServiceContext config) {\n\n        super();\n        XDSBridge.serviceContext = config;\n    }\n\n    /**\n     * Method description\n     *\n     *\n     * @param service_name\n     * @param request\n     *\n     * @return\n     *\n     * @throws AxisFault\n     */\n    @Override\n    protected void beginTransaction(String service_name,\n            OMElement request)\n            throws SOAPFaultException {\n\n        String remoteIP = \"127.0.0.2\";\n        XLogger xlogger = XLogger.getInstance();\n\n        log_message = xlogger.getNewMessage(remoteIP);\n        log_message.setTestMessage(\"TEST\");\n    }\n\n    /**\n     * Method description\n     *\n     *\n     * @return\n     */\n    @Override\n    protected MessageContext getCurrentMessageContext() {\n\n        return new MockMessageContext();\n    }\n}", "class_id": 0, "repo": "kef/hieos", "file": "src/xdsbridge/src/test/java/com/vangent/hieos/services/xds/bridge/mock/MockXDSBridge.java", "last_update_at": "2021-11-27T10:56:53+00:00", "question_id": "0258fec1fbbbd04e532d61c0a501cd3898fe0f43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockXDSBridge extends XDSBridge {\n    /**\n     * Constructs ...\n     *\n     *\n     * @param config\n     */\n    public MockXDSBridge(XDSBridgeServiceContext config) {\n        super();\n        XDSBridge.serviceContext = config;\n    }\n    /**\n     * Method description\n     *\n     *\n     * @param service_name\n     * @param request\n     *\n     * @return\n     *\n     * @throws AxisFault\n     */\n    @Override\n    protected void beginTransaction(String service_name,\n            OMElement request)\n            throws SOAPFaultException {\n        String remoteIP = \"127.0.0.2\";\n        XLogger xlogger = XLogger.getInstance();\n        log_message = xlogger.getNewMessage(remoteIP);\n        log_message.setTestMessage(\"TEST\");\n    }\n    /**\n     * Method description\n     *\n     *\n     * @return\n     */\n    @Override\n    protected MessageContext getCurrentMessageContext() {\n        return new MockMessageContext();\n    }\n"]], "pred": {"ppl": 2.8396060466766357, "ppl_lower": 3.6706643104553223, "ppl/lowercase_ppl": -1.2459670965166312, "ppl/zlib": 0.0027108190301097014, "Min_5.0% Prob": 7.394419229947603, "Min_10.0% Prob": 6.275155085104483, "Min_20.0% Prob": 4.411584542014382, "Min_30.0% Prob": 3.323421795920628, "Min_40.0% Prob": 2.573856888305057, "Min_50.0% Prob": 2.076267337102605, "Min_60.0% Prob": 1.7434651272766517}}
{"hexsha": "9118fce3ef781ce323072a537ba766e7bc58d1c4", "ext": "java", "lang": "Java", "content": "public class EinfacheGui implements ActionListener, KeyListener {\n  private JFrame myFrame;\n  private Container myContentPane;\n  private JButton myButtonClickMich;\n\n  private int height = 350;\n  private int width = 350;\n  private double factor = 0.3;\n\n  public EinfacheGui() {\n    myFrame = new JFrame(\"Einfache Gui\");\n    myFrame.setSize(width, height);\n    myFrame.setLocationRelativeTo(null);\n    myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    myButtonClickMich = new JButton(\"Button\");\n    myButtonClickMich.addActionListener(this);\n    myButtonClickMich.addKeyListener(this);\n\n    myFrame.add(myButtonClickMich);\n    myFrame.setVisible(true);\n\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    double w = myFrame.getWidth() - myFrame.getWidth() * factor;\n    double h = myFrame.getHeight() - myFrame.getHeight() * factor;\n\n    if ((w + h) < 150)\n      myFrame.setSize(width, height);\n    else\n      myFrame.setSize((int) w, (int) h);\n\n    myFrame.setLocationRelativeTo(null);\n  }\n\n  @Override\n  public void keyTyped(KeyEvent e) {\n  }\n\n  @Override\n  public void keyPressed(KeyEvent e) {\n    if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {\n      JOptionPane.showMessageDialog(myFrame, \"Geschafft\");\n    }\n    System.out.println(e.getExtendedKeyCode() + \" pressed\");\n  }\n\n  @Override\n  public void keyReleased(KeyEvent e) {\n  }\n\n}", "class_id": 0, "repo": "thieleju/studium", "file": "Programmiertechnik_II/Workbook4/EinfacheGui.java", "last_update_at": "2021-11-17T12:30:49+00:00", "question_id": "9118fce3ef781ce323072a537ba766e7bc58d1c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EinfacheGui implements ActionListener, KeyListener {\n  private JFrame myFrame;\n  private Container myContentPane;\n  private JButton myButtonClickMich;\n  private int height = 350;\n  private int width = 350;\n  private double factor = 0.3;\n  public EinfacheGui() {\n    myFrame = new JFrame(\"Einfache Gui\");\n    myFrame.setSize(width, height);\n    myFrame.setLocationRelativeTo(null);\n    myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    myButtonClickMich = new JButton(\"Button\");\n    myButtonClickMich.addActionListener(this);\n    myButtonClickMich.addKeyListener(this);\n    myFrame.add(myButtonClickMich);\n    myFrame.setVisible(true);\n  }\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    double w = myFrame.getWidth() - myFrame.getWidth() * factor;\n    double h = myFrame.getHeight() - myFrame.getHeight() * factor;\n    if ((w + h) < 150)\n      myFrame.setSize(width, height);\n    else\n      myFrame.setSize((int) w, (int) h);\n    myFrame.setLocationRelativeTo(null);\n  }\n  @Override\n  public void keyTyped(KeyEvent e) {\n  }\n  @Override\n  public void keyPressed(KeyEvent e) {\n    if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {\n      JOptionPane.showMessageDialog(myFrame, \"Geschafft\");\n    }\n    System.out.println(e.getExtendedKeyCode() + \" pressed\");\n  }\n  @Override\n  public void keyReleased(KeyEvent e) {\n  }\n"]], "pred": {"ppl": 1.720384955406189, "ppl_lower": 1.9583091735839844, "ppl/lowercase_ppl": -1.2387500072384274, "ppl/zlib": 0.0010010112122989317, "Min_5.0% Prob": 5.387653257535852, "Min_10.0% Prob": 3.9196560175522515, "Min_20.0% Prob": 2.48906957520091, "Min_30.0% Prob": 1.7595483527766715, "Min_40.0% Prob": 1.3473357635978105, "Min_50.0% Prob": 1.0818789542235177, "Min_60.0% Prob": 0.9047621287231287}}
{"hexsha": "895b29ca56c1e747cd96f886c95fd5020c83bf5d", "ext": "java", "lang": "Java", "content": "public class ConnectionOpeningImpl implements IBestPractice {\n\n\t@Value(\"${connections.connectionOpening.title}\")\n\tprivate String overviewTitle;\n\t\n\t@Value(\"${connections.connectionOpening.detailedTitle}\")\n\tprivate String detailTitle;\n\t\n\t@Value(\"${connections.connectionOpening.desc}\")\n\tprivate String aboutText;\n\t\n\t@Value(\"${connections.connectionOpening.url}\")\n\tprivate String learnMoreUrl;\n\t\n\t@Value(\"${connections.connectionOpening.selfEvaluation}\")\n\tprivate String textResult;\n\t\n\t\n\t@Override\n\tpublic AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {\n\t\tConnectionOpeningResult result = new ConnectionOpeningResult();\n\t\tresult.setSelfTest(true);\n\t\tresult.setAboutText(aboutText);\n\t\tresult.setDetailTitle(detailTitle);\n\t\tresult.setLearnMoreUrl(learnMoreUrl);\n\t\tresult.setOverviewTitle(overviewTitle);\n\t\tresult.setResultText(textResult);\n\t\tresult.setResultType(BPResultType.SELF_TEST);\n\t\t\n\t\treturn result;\n\t}\n\n}", "class_id": 0, "repo": "j420247/ARO", "file": "5.0.0/ARO.Core/src/main/java/com/att/aro/core/bestpractice/impl/ConnectionOpeningImpl.java", "last_update_at": "2021-11-12T11:34:34+00:00", "question_id": "895b29ca56c1e747cd96f886c95fd5020c83bf5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConnectionOpeningImpl implements IBestPractice {\n\t@Value(\"${connections.connectionOpening.title}\")\n\tprivate String overviewTitle;\n\t\n\t@Value(\"${connections.connectionOpening.detailedTitle}\")\n\tprivate String detailTitle;\n\t\n\t@Value(\"${connections.connectionOpening.desc}\")\n\tprivate String aboutText;\n\t\n\t@Value(\"${connections.connectionOpening.url}\")\n\tprivate String learnMoreUrl;\n\t\n\t@Value(\"${connections.connectionOpening.selfEvaluation}\")\n\tprivate String textResult;\n\t\n\t\n\t@Override\n\tpublic AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {\n\t\tConnectionOpeningResult result = new ConnectionOpeningResult();\n\t\tresult.setSelfTest(true);\n\t\tresult.setAboutText(aboutText);\n\t\tresult.setDetailTitle(detailTitle);\n\t\tresult.setLearnMoreUrl(learnMoreUrl);\n\t\tresult.setOverviewTitle(overviewTitle);\n\t\tresult.setResultText(textResult);\n\t\tresult.setResultType(BPResultType.SELF_TEST);\n\t\t\n\t\treturn result;\n\t}\n"]], "pred": {"ppl": 2.1080336570739746, "ppl_lower": 2.797118902206421, "ppl/lowercase_ppl": -1.379258738660706, "ppl/zlib": 0.0021869665598402725, "Min_5.0% Prob": 7.822323526654925, "Min_10.0% Prob": 5.799966951896405, "Min_20.0% Prob": 3.48357006654901, "Min_30.0% Prob": 2.439620886291011, "Min_40.0% Prob": 1.8638490277768698, "Min_50.0% Prob": 1.4921982976658321, "Min_60.0% Prob": 1.2427740384761787}}
{"hexsha": "b7cad21f3c37603e9f2c3cc34f0e1a6e357d10f3", "ext": "java", "lang": "Java", "content": "public class BulletEffectAttractive implements BulletEffect {\n\t@Override\n\tpublic String getID() {\n\t\treturn \"attractive\";\n\t}\n\n\t@Override\n\tpublic boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {\n\t\tif (hitEntity instanceof EntityAnimal) {\n\t\t\t((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.setCollision(true);\n\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {\n\t\t\tbuild.setLifetime(RandUtil.nextInt(20, 40));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));\n\t\t\tbuild.setAlphaFunction(new InterpFadeInOut(0f, 1f));\n\t\t\tbuild.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));\n\t\t\tbuild.setDeceleration(new Vec3d(0.7, 0.7, 0.7));\n\n\t\t\tdouble radius = 2 * RandUtil.nextFloat();\n\t\t\tdouble theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();\n\t\t\tdouble x = radius * MathHelper.cos((float) theta);\n\t\t\tdouble z = radius * MathHelper.sin((float) theta);\n\n\t\t\tbuild.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));\n\t\t});\n\t}\n\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.setCollision(true);\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.disableRandom();\n\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {\n\t\t\tbuild.setScaleFunction(new InterpScale(0.5f, 0));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));\n\t\t});\n\t}\n\n\t@Override\n\tpublic @Nullable\n\tSoundEvent getImpactSound() {\n\t\treturn RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;\n\t}\n}", "class_id": 0, "repo": "Demoniaque/Shotguns-And-Glitter", "file": "src/main/java/com/teamwizardry/shotgunsandglitter/common/effects/BulletEffectAttractive.java", "last_update_at": "2021-01-07T21:18:51+00:00", "question_id": "b7cad21f3c37603e9f2c3cc34f0e1a6e357d10f3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BulletEffectAttractive implements BulletEffect {\n\t@Override\n\tpublic String getID() {\n\t\treturn \"attractive\";\n\t}\n\t@Override\n\tpublic boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {\n\t\tif (hitEntity instanceof EntityAnimal) {\n\t\t\t((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.setCollision(true);\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {\n\t\t\tbuild.setLifetime(RandUtil.nextInt(20, 40));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));\n\t\t\tbuild.setAlphaFunction(new InterpFadeInOut(0f, 1f));\n\t\t\tbuild.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));\n\t\t\tbuild.setDeceleration(new Vec3d(0.7, 0.7, 0.7));\n\t\t\tdouble radius = 2 * RandUtil.nextFloat();\n\t\t\tdouble theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();\n\t\t\tdouble x = radius * MathHelper.cos((float) theta);\n\t\t\tdouble z = radius * MathHelper.sin((float) theta);\n\t\t\tbuild.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));\n\t\t});\n\t}\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.setCollision(true);\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.disableRandom();\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {\n\t\t\tbuild.setScaleFunction(new InterpScale(0.5f, 0));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));\n\t\t});\n\t}\n\t@Override\n\tpublic @Nullable\n\tSoundEvent getImpactSound() {\n\t\treturn RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;\n\t}\n"]], "pred": {"ppl": 1.86583411693573, "ppl_lower": 2.3562963008880615, "ppl/lowercase_ppl": -1.374185911248368, "ppl/zlib": 0.0007905046904905726, "Min_5.0% Prob": 5.650747094835554, "Min_10.0% Prob": 4.357656731325037, "Min_20.0% Prob": 2.865312219016692, "Min_30.0% Prob": 2.0329178860958885, "Min_40.0% Prob": 1.5507878351408768, "Min_50.0% Prob": 1.2443768932164905, "Min_60.0% Prob": 1.0392603210443285}}
{"hexsha": "71f70801a9b50116a217f6493cec5ea7f30a0487", "ext": "java", "lang": "Java", "content": "@ServiceComponentRenderer\npublic class CryptoAdapterRegistrationRenderer implements Renderer {\n\tprivate final String INLINE_JS =\n        \"function setCryptoKey(key) {\\n\" +\n        \"    var buffer, view;\\n\" +\n        \"    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\\n\" +\n        \"        try {\\n\" +\n        \"            buffer = new ArrayBuffer(key.length);\\n\" +\n        \"            view = new Uint8Array(buffer);\\n\" +\n        \"            view.set(key);\\n\" +\n        \"        } catch (ignored) {}\\n\" +\n        \"    }\\n\" +\n        \"    CryptoAdapter.setKey(buffer);\\n\" +\n        \"}\\n\" +\n        \"debug && $A.log('CryptoAdapter registering');\\n\" +\n        \"var CryptoAdapter = $A.storageService.CryptoAdapter;\\n\" +\n        \"CryptoAdapter.register();\\n\" +\n        \"if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\\n\" +\n        \"    $A.log('CryptoAdapter was not registered');\\n\" +\n        \"    return;\\n\" +\n        \"}\\n\" +\n        \"setCryptoKey(key);\\n\"\n    ;\n\n    private ConfigAdapter configAdapter;\n\n    @Override\n    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {\n\n        Boolean debug = (Boolean) component.getAttributes().getValue(\"debugLoggingEnabled\");\n        String key = configAdapter.getEncryptionKey();\n        \n        renderContext.pushScript();\n        renderContext.getCurrent()\n                .append(\"(function(debug, key){\\n\")\n                .append(INLINE_JS)\n                .append(\"\\n}(\").append(String.valueOf(debug)).append(\",\").append(String.valueOf(key)).append(\"));\");\n        renderContext.popScript();\n    }\n\n    @Inject\n    public void setConfigAdapter(ConfigAdapter configAdapter) {\n        this.configAdapter = configAdapter;\n    }\n}", "class_id": 0, "repo": "madmax983/aura", "file": "aura-components/src/main/java/org/auraframework/components/aura/CryptoAdapterRegistrationRenderer.java", "last_update_at": "2021-08-11T08:25:14+00:00", "question_id": "71f70801a9b50116a217f6493cec5ea7f30a0487", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ServiceComponentRenderer\npublic class CryptoAdapterRegistrationRenderer implements Renderer {\n\tprivate final String INLINE_JS =\n        \"function setCryptoKey(key) {\\n\" +\n        \"    var buffer, view;\\n\" +\n        \"    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\\n\" +\n        \"        try {\\n\" +\n        \"            buffer = new ArrayBuffer(key.length);\\n\" +\n        \"            view = new Uint8Array(buffer);\\n\" +\n        \"            view.set(key);\\n\" +\n        \"        } catch (ignored) {}\\n\" +\n        \"    }\\n\" +\n        \"    CryptoAdapter.setKey(buffer);\\n\" +\n        \"}\\n\" +\n        \"debug && $A.log('CryptoAdapter registering');\\n\" +\n        \"var CryptoAdapter = $A.storageService.CryptoAdapter;\\n\" +\n        \"CryptoAdapter.register();\\n\" +\n        \"if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\\n\" +\n        \"    $A.log('CryptoAdapter was not registered');\\n\" +\n        \"    return;\\n\" +\n        \"}\\n\" +\n        \"setCryptoKey(key);\\n\"\n    ;\n    private ConfigAdapter configAdapter;\n    @Override\n    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {\n        Boolean debug = (Boolean) component.getAttributes().getValue(\"debugLoggingEnabled\");\n        String key = configAdapter.getEncryptionKey();\n        renderContext.pushScript();\n        renderContext.getCurrent()\n                .append(\"(function(debug, key){\\n\")\n                .append(INLINE_JS)\n                .append(\"\\n}(\").append(String.valueOf(debug)).append(\",\").append(String.valueOf(key)).append(\"));\");\n        renderContext.popScript();\n    }\n    @Inject\n    public void setConfigAdapter(ConfigAdapter configAdapter) {\n        this.configAdapter = configAdapter;\n    }\n"]], "pred": {"ppl": 2.1804704666137695, "ppl_lower": 2.7048799991607666, "ppl/lowercase_ppl": -1.2764665075275214, "ppl/zlib": 0.00117933534627924, "Min_5.0% Prob": 6.787300091523391, "Min_10.0% Prob": 5.12532613827632, "Min_20.0% Prob": 3.425374674109312, "Min_30.0% Prob": 2.502243680258592, "Min_40.0% Prob": 1.9256378774029703, "Min_50.0% Prob": 1.553103106490408, "Min_60.0% Prob": 1.2974260434305342}}
{"hexsha": "99d08e11b8fd9b4837646757477e56f3f5aea269", "ext": "java", "lang": "Java", "content": "public class ForLoopCalculator implements Calculator {\n    public long sumUp(long[] numbers) {\n        long total = 0;\n        for (long i : numbers) {\n            total += i;\n        }\n        return total;\n    }\n}", "class_id": 0, "repo": "gaohanghang/Java-Concurrency-Multithreading-in-Practice", "file": "doc/doc1/ForLoopCalculator.java", "last_update_at": "2021-11-04T13:49:22+00:00", "question_id": "99d08e11b8fd9b4837646757477e56f3f5aea269", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ForLoopCalculator implements Calculator {\n    public long sumUp(long[] numbers) {\n        long total = 0;\n        for (long i : numbers) {\n            total += i;\n        }\n        return total;\n    }\n"]], "pred": {"ppl": 2.5726187229156494, "ppl_lower": 3.177631378173828, "ppl/lowercase_ppl": -1.2235223737743588, "ppl/zlib": 0.007104694274093293, "Min_5.0% Prob": 8.3847017288208, "Min_10.0% Prob": 6.384952974319458, "Min_20.0% Prob": 4.234941027381203, "Min_30.0% Prob": 3.079077184200287, "Min_40.0% Prob": 2.3725924809341845, "Min_50.0% Prob": 1.9049971527580558, "Min_60.0% Prob": 1.5880958622055394}}
{"hexsha": "3895af397ca10b213eeedd58eb68713c339171f4", "ext": "java", "lang": "Java", "content": "public class BinaryTree {\n\n    private String symbol;\n    private int start;\n    private int end;\n    private BinaryTree leftChild;\n    private BinaryTree rightChild;\n    private boolean isLexical;\n    private BinaryTree parent;\n    \n    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode,\n            BinaryTree rightChildNode, boolean isLexical) {\n        this.symbol = symbol;\n        this.start = start;\n        this.end = end;\n        this.leftChild = leftChildNode;\n        this.rightChild = rightChildNode;\n        this.isLexical = isLexical;\n        this.parent = null;\n        if (leftChild != null) {\n            leftChild.parent = this;\n        }\n        if (rightChild != null) {\n            rightChild.parent = this;\n        }\n    }\n\n//    public Span getSpan() {\n//        return new Span(start, end);\n//    }\n       \n    private static String canonicalizeTreeString(String newTreeStr) {\n        return newTreeStr.trim().replaceAll(\"\\\\s+\\\\)\", \")\").replaceAll(\"\\\\s+\", \" \");\n    }\n    \n    public String getAsOneLineString() {\n        // TODO: speedup.\n        return canonicalizeTreeString(getAsPennTreebankString());\n    }\n    \n    /**\n     * Gets a string representation of this parse that looks like the typical \n     * Penn Treebank style parse.\n     * \n     * Example:\n     *  ((ROOT (S (NP (NN time))\n     *           (VP (VBZ flies)\n     *               (PP (IN like)\n     *                   (NP (DT an)\n     *                       (NN arrow)))))))\n     *                       \n     * @return A string representing this parse.\n     */\n    public String getAsPennTreebankString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        getAsPennTreebankString(1, 1, sb);\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {\n        int numSpaces = indent - numOnLine;\n        for (int i=0; i<numSpaces; i++) {\n            sb.append(\" \");\n        }\n        if (isLexical) {\n            sb.append(getSymbol());\n        } else {\n            sb.append(\"(\");\n            sb.append(getSymbol());\n            \n            // If this is a constant instead, then we have each depth in one column.\n            int numNewChars = 1 + getSymbol().length();\n\n            if (leftChild != null) {\n                //sb.append(\"\\n\");\n                leftChild.getAsPennTreebankString(indent+numNewChars+1, indent + numNewChars, sb);\n            }\n            if (rightChild != null) {\n                sb.append(\"\\n\");\n                rightChild.getAsPennTreebankString(indent+numNewChars+1, 0, sb);\n            }\n            sb.append(\")\");\n        }\n    }\n\n    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Visit this node.\n        function.call(this);\n        // Pre-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.preOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.preOrderTraversal(function);\n        }\n    }\n\n    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // In-order traversal of left child.\n        if (leftChild != null) {\n            leftChild.inOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n        // In-order traversal of right child.\n        if (rightChild != null) {\n            rightChild.inOrderTraversal(function);\n        }\n    }\n    \n    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Post-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.postOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.postOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n    }\n    \n    public int getStart() {\n        return start;\n    }\n    \n    public int getEnd() {\n        return end;\n    }\n\n    public boolean isLeaf() {\n        return leftChild == null && rightChild == null;\n    }\n\n    public boolean isLexical() {\n        return isLexical;\n    }\n    \n    public BinaryTree getLeftChild() {\n        return leftChild;\n    }\n\n    public BinaryTree getRightChild() {\n        return rightChild;\n    }\n    \n    public String getSymbol() {\n        return symbol;\n    }\n\n    public void setSymbol(String symbol) {\n        this.symbol = symbol;\n    }\n    \n    public BinaryTree getParent() {\n        return parent;\n    }\n    \n    /**\n     * Updates all the start end fields, treating the current node as the root.\n     */\n    public void updateStartEnd() {\n        ArrayList<BinaryTree> leaves = getLeaves();\n        for (int i=0; i<leaves.size(); i++) {\n            BinaryTree leaf = leaves.get(i);\n            leaf.start = i;\n            leaf.end = i+1;\n        }\n        postOrderTraversal(new UpdateStartEnd());\n    }\n\n    /**\n     * Gets the leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLeaves() {\n        LeafCollector leafCollector = new LeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n    \n    /**\n     * Gets the lexical leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLexicalLeaves() {\n        LexicalLeafCollector leafCollector = new LexicalLeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n\n    /** Gets the leaf containing the specified token index. */\n    public BinaryTree getLeafAt(int idx) {\n        BinaryTree leaf = null;\n        for (BinaryTree l : this.getLeaves()) {\n            if (l.start <= idx && idx < l.end) {\n                leaf = l;\n            }\n        }\n        return leaf;\n    }\n    \n    /**\n     * Gets the lexical item ids comprising the sentence.\n     */\n    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        int[] sent = new int[leaves.size()];\n        for (int i=0; i<sent.length; i++) {\n            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);\n        }\n        return sent;\n    }\n\n    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> labels = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {\n            labels.add(leaves.get(i).symbol);\n        }\n        return new Sentence(lexAlphabet, labels);\n    }\n\n    public List<String> getWords() {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> words = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {            \n            words.add(leaves.get(i).symbol);\n        }\n        return words;\n    }\n\n    private class LeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        \n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf()) {\n                leaves.add(node);\n            }\n        }\n        \n    }\n    \n    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        \n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf() && node.isLexical()) {\n                leaves.add(node);\n            }\n        }\n        \n    }\n    \n    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {\n\n        @Override\n        public void call(BinaryTree node) {\n            if (!node.isLeaf()) {\n                node.start = node.leftChild.start;\n                if (node.rightChild == null) {\n                    node.end = node.leftChild.end;\n                } else {\n                    node.end = node.rightChild.end;\n                }\n            }\n        }\n        \n    }\n    \n    /** Intern all the strings. */\n    public void intern() {\n        symbol = symbol.intern();\n        if (leftChild != null) {\n            leftChild.intern();\n        }\n        if (rightChild != null) {\n            rightChild.intern();\n        }\n    }\n\n    public NaryTree collapseToNary() {        \n        ArrayList<NaryTree> children = null;\n        if (!isLeaf()) {\n            assert (leftChild != null);\n            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();\n            addToQueue(queue, leftChild);\n            addToQueue(queue, rightChild);\n            children = new ArrayList<NaryTree>(queue);\n        }\n        \n        return new NaryTree(symbol, start, end, children, isLexical);\n    }\n\n    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {\n        if (child == null) {\n            return;\n        }\n        String symbolStr = child.getSymbol();\n        if (GrammarConstants.isBinarized(symbolStr)) {\n            addToQueue(queue, child.leftChild);\n            addToQueue(queue, child.rightChild);\n        } else {\n            queue.add(child.collapseToNary());\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"BinaryTreeNode [symbol=\" + getSymbol() + \"_{\" + start + \", \"\n                + end + \"}, leftChildNode=\" + leftChild\n                + \", rightChildNode=\" + rightChild + \"]\";\n    }\n    \n}", "class_id": 0, "repo": "mgormley/pacaya", "file": "src/main/java/edu/jhu/pacaya/parse/cky/data/BinaryTree.java", "last_update_at": "2021-07-25T23:58:37+00:00", "question_id": "3895af397ca10b213eeedd58eb68713c339171f4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinaryTree {\n    private String symbol;\n    private int start;\n    private int end;\n    private BinaryTree leftChild;\n    private BinaryTree rightChild;\n    private boolean isLexical;\n    private BinaryTree parent;\n    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode,\n            BinaryTree rightChildNode, boolean isLexical) {\n        this.symbol = symbol;\n        this.start = start;\n        this.end = end;\n        this.leftChild = leftChildNode;\n        this.rightChild = rightChildNode;\n        this.isLexical = isLexical;\n        this.parent = null;\n        if (leftChild != null) {\n            leftChild.parent = this;\n        }\n        if (rightChild != null) {\n            rightChild.parent = this;\n        }\n    }\n//    public Span getSpan() {\n//        return new Span(start, end);\n//    }\n    private static String canonicalizeTreeString(String newTreeStr) {\n        return newTreeStr.trim().replaceAll(\"\\\\s+\\\\)\", \")\").replaceAll(\"\\\\s+\", \" \");\n    }\n    public String getAsOneLineString() {\n        // TODO: speedup.\n        return canonicalizeTreeString(getAsPennTreebankString());\n    }\n    /**\n     * Gets a string representation of this parse that looks like the typical \n     * Penn Treebank style parse.\n     * \n     * Example:\n     *  ((ROOT (S (NP (NN time))\n     *           (VP (VBZ flies)\n     *               (PP (IN like)\n     *                   (NP (DT an)\n     *                       (NN arrow)))))))\n     *                       \n     * @return A string representing this parse.\n     */\n    public String getAsPennTreebankString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        getAsPennTreebankString(1, 1, sb);\n        sb.append(\")\");\n        return sb.toString();\n    }\n    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {\n        int numSpaces = indent - numOnLine;\n        for (int i=0; i<numSpaces; i++) {\n            sb.append(\" \");\n        }\n        if (isLexical) {\n            sb.append(getSymbol());\n        } else {\n            sb.append(\"(\");\n            sb.append(getSymbol());\n            // If this is a constant instead, then we have each depth in one column.\n            int numNewChars = 1 + getSymbol().length();\n            if (leftChild != null) {\n                //sb.append(\"\\n\");\n                leftChild.getAsPennTreebankString(indent+numNewChars+1, indent + numNewChars, sb);\n            }\n            if (rightChild != null) {\n                sb.append(\"\\n\");\n                rightChild.getAsPennTreebankString(indent+numNewChars+1, 0, sb);\n            }\n            sb.append(\")\");\n        }\n    }\n    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Visit this node.\n        function.call(this);\n        // Pre-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.preOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.preOrderTraversal(function);\n        }\n    }\n    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // In-order traversal of left child.\n        if (leftChild != null) {\n            leftChild.inOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n        // In-order traversal of right child.\n        if (rightChild != null) {\n            rightChild.inOrderTraversal(function);\n        }\n    }\n    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Post-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.postOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.postOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n    }\n    public int getStart() {\n        return start;\n    }\n    public int getEnd() {\n        return end;\n    }\n    public boolean isLeaf() {\n        return leftChild == null && rightChild == null;\n    }\n    public boolean isLexical() {\n        return isLexical;\n    }\n    public BinaryTree getLeftChild() {\n        return leftChild;\n    }\n    public BinaryTree getRightChild() {\n        return rightChild;\n    }\n    public String getSymbol() {\n        return symbol;\n    }\n    public void setSymbol(String symbol) {\n        this.symbol = symbol;\n    }\n    public BinaryTree getParent() {\n        return parent;\n    }\n    /**\n     * Updates all the start end fields, treating the current node as the root.\n     */\n    public void updateStartEnd() {\n        ArrayList<BinaryTree> leaves = getLeaves();\n        for (int i=0; i<leaves.size(); i++) {\n            BinaryTree leaf = leaves.get(i);\n            leaf.start = i;\n            leaf.end = i+1;\n        }\n        postOrderTraversal(new UpdateStartEnd());\n    }\n    /**\n     * Gets the leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLeaves() {\n        LeafCollector leafCollector = new LeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n    /**\n     * Gets the lexical leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLexicalLeaves() {\n        LexicalLeafCollector leafCollector = new LexicalLeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n    /** Gets the leaf containing the specified token index. */\n    public BinaryTree getLeafAt(int idx) {\n        BinaryTree leaf = null;\n        for (BinaryTree l : this.getLeaves()) {\n            if (l.start <= idx && idx < l.end) {\n                leaf = l;\n            }\n        }\n        return leaf;\n    }\n    /**\n     * Gets the lexical item ids comprising the sentence.\n     */\n    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        int[] sent = new int[leaves.size()];\n        for (int i=0; i<sent.length; i++) {\n            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);\n        }\n        return sent;\n    }\n    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> labels = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {\n            labels.add(leaves.get(i).symbol);\n        }\n        return new Sentence(lexAlphabet, labels);\n    }\n    public List<String> getWords() {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> words = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {            \n            words.add(leaves.get(i).symbol);\n        }\n        return words;\n    }\n    private class LeafCollector implements FnO1ToVoid<BinaryTree> {\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf()) {\n                leaves.add(node);\n            }\n        }\n    }\n    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf() && node.isLexical()) {\n                leaves.add(node);\n            }\n        }\n    }\n    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {\n        @Override\n        public void call(BinaryTree node) {\n            if (!node.isLeaf()) {\n                node.start = node.leftChild.start;\n                if (node.rightChild == null) {\n                    node.end = node.leftChild.end;\n                } else {\n                    node.end = node.rightChild.end;\n                }\n            }\n        }\n    }\n    /** Intern all the strings. */\n    public void intern() {\n        symbol = symbol.intern();\n        if (leftChild != null) {\n            leftChild.intern();\n        }\n        if (rightChild != null) {\n            rightChild.intern();\n        }\n    }\n    public NaryTree collapseToNary() {        \n        ArrayList<NaryTree> children = null;\n        if (!isLeaf()) {\n            assert (leftChild != null);\n            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();\n            addToQueue(queue, leftChild);\n            addToQueue(queue, rightChild);\n            children = new ArrayList<NaryTree>(queue);\n        }\n        return new NaryTree(symbol, start, end, children, isLexical);\n    }\n    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {\n        if (child == null) {\n            return;\n        }\n        String symbolStr = child.getSymbol();\n        if (GrammarConstants.isBinarized(symbolStr)) {\n            addToQueue(queue, child.leftChild);\n            addToQueue(queue, child.rightChild);\n        } else {\n            queue.add(child.collapseToNary());\n        }\n    }\n    @Override\n    public String toString() {\n        return \"BinaryTreeNode [symbol=\" + getSymbol() + \"_{\" + start + \", \"\n                + end + \"}, leftChildNode=\" + leftChild\n                + \", rightChildNode=\" + rightChild + \"]\";\n    }\n"]], "pred": {"ppl": 1.8478920459747314, "ppl_lower": 2.0900986194610596, "ppl/lowercase_ppl": -1.2005807149099597, "ppl/zlib": 0.0002969272508862822, "Min_5.0% Prob": 6.2688912877849505, "Min_10.0% Prob": 4.617823144968818, "Min_20.0% Prob": 2.871986168856714, "Min_30.0% Prob": 2.012356698659121, "Min_40.0% Prob": 1.5264646297726043, "Min_50.0% Prob": 1.2267613548388132, "Min_60.0% Prob": 1.0240183908820493}}
{"hexsha": "6010ce895b3af2938615bae54d10caa4a458667d", "ext": "java", "lang": "Java", "content": "public class SegmentHandler {\n\n\tpublic LinkedList<vec> segments;\n\tpublic LinkedList<EnumFacing> segmentbottomsides;\n\tpublic LinkedList<EnumFacing> segmenttopsides;\n\tpublic World world;\n\tpublic grappleArrow arrow;\n\t\n\tvec prevhookpos = null;\n\tvec prevplayerpos = null;;\n\t\n\tfinal double bendoffset = 0.05;\n\tfinal double intoblock = 0.05;\n\t\n\tpublic SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {\n\t\tsegments = new LinkedList<vec>();\n\t\tsegments.add(hookpos);\n\t\tsegments.add(playerpos);\n\t\tsegmentbottomsides = new LinkedList<EnumFacing>();\n\t\tsegmentbottomsides.add(null);\n\t\tsegmentbottomsides.add(null);\n\t\tsegmenttopsides = new LinkedList<EnumFacing>();\n\t\tsegmenttopsides.add(null);\n\t\tsegmenttopsides.add(null);\n\t\tthis.world = w;\n\t\tthis.arrow = arrow;\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n\t\t\n//\t\tSystem.out.println(\"segments:\");\n//\t\thookpos.print();\n//\t\tplayerpos.print();\n\t}\n\t\n\tpublic void forceSetPos(vec hookpos, vec playerpos) {\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n    \tthis.segments.set(0, new vec(hookpos));\n    \tthis.segments.set(this.segments.size() - 1, new vec(playerpos));\n\t}\n\t\n\tdouble ropelen;\n\t\n\tpublic void updatepos(vec hookpos, vec playerpos, double ropelen) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t}\n\t\n\tpublic void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {\n\t\tif (prevhookpos == null) {\n\t        prevhookpos = hookpos;\n\t        prevplayerpos = playerpos;\n\t\t}\n\t\t\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t\t\n\t\t\n\t\tvec closest = segments.get(segments.size()-2);\n\t\t\n\t\twhile (true) {\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint index = segments.size()-2;\n\t\t\tclosest = segments.get(index);\n\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\tvec ropevec = playerpos.sub(closest);\n\t\t\t\n\t\t\tvec beforepoint = segments.get(index-1);\n\t\t\t\n\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\tvec planenormal = beforepoint.sub(closest).cross(edgevec);\n//\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\n//\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\n\t\t\tif (ropevec.dot(planenormal) > 0) {\n\t\t\t\tthis.removesegment(index);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec farthest = segments.get(1);\n\t\t\n\t\tif (movinghook) {\n\t\t\twhile (true) {\n\t\t\t\tif (segments.size() == 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint index = 1;\n\t\t\t\tfarthest = segments.get(index);\n\t\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\t\tvec ropevec = farthest.sub(hookpos);\n\t\t\t\t\n\t\t\t\tvec beforepoint = segments.get(index+1);\n\t\t\t\t\n\t\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\t\tvec planenormal = beforepoint.sub(farthest).cross(edgevec);\n//\t\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\t\n\t\t\t\tif (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {\n//\t\t\t\t\tSystem.out.println(\"removed farthest\");\n\t\t\t\t\tthis.removesegment(index);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tif (this.getDistToFarthest() > ropelen) {\n\t\t\t\t\tthis.removesegment(1);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (movinghook) {\n\t\t\tfarthest = segments.get(1);\n\t\t\tvec prevfarthest = farthest;\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tprevfarthest = prevplayerpos;\n\t\t\t}\n\t\t\tupdatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);\n\t\t}\n\t\t\n\t\tvec prevclosest = closest;\n\t\tif (segments.size() == 2) {\n\t\t\tprevclosest = prevhookpos;\n\t\t}\n\t\tupdatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);\n\t\t\n\t\t\n        prevhookpos = hookpos;\n        prevplayerpos = playerpos;\n\t}\n\t\n\tpublic void removesegment(int index) {\n/*\t\tSystem.out.println(\"removed segment\");*/\n\t\t\n\t\tsegments.remove(index);\n\t\tsegmentbottomsides.remove(index);\n\t\tsegmenttopsides.remove(index);\n\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {\n        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);\n        \n        // if rope hit block\n        if (bottomraytraceresult != null)\n        {\n        \tif (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {\n//        \t\tSystem.out.println(\"Warning: prev collision\");\n        \t\treturn;\n        \t}\n        \t\n//        \tSystem.out.println(bottomraytraceresult.typeOfHit);\n            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);\n/*            this.arrow.debugpos = bottomhitvec;\n            this.arrow.debugpos2 = bottom;\n            this.arrow.debugpos3 = top;*/\n            EnumFacing bottomside = bottomraytraceresult.sideHit;\n            vec bottomnormal = this.getnormal(bottomside);\n            \n            // calculate where bottomhitvec was along the rope in the previous tick\n//            double ropelen = top.sub(bottom).length();\n            double prevropelen = prevtop.sub(prevbottom).length();\n            \n//            double bottomtohit = bottom.sub(bottomhitvec).length();\n//            double prevbottomtohit = bottomtohit * ropelen / prevropelen;\n            \n//            vec prevbottomhit = prevtop.sub(prevbottom).changelen(prevbottomtohit).add(prevbottom);\n            \n            // use prevbottomhit to calculate the velocity of that part of the rope when it hit the block\n //           vec motionalonghit = bottomhitvec.sub(prevbottomhit);\n            \n            // calculate the motion parallel to the block side\n//            vec motionparallel = motionalonghit.removealong(bottomnormal);\n            \n            // the rope must have hit the corner on the plane across the edge of the block\n            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom\n            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));\n            \n//            vec cornerbound2 = null;\n//            double cornerlinedist = Double.POSITIVE_INFINITY;\n            \n            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option1;\n            \tcornerlinedist = cornerbound1.sub(bound_option1).length();\n            }*/\n            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option2;\n            \tcornerlinedist = cornerbound1.sub(bound_option2).length();\n            }*/\n            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option3).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option3;\n            \tcornerlinedist = cornerbound1.sub(bound_option3).length();\n            }*/\n            \n//            if (cornerbound2 != null) {\n            for (vec cornerbound2 : new vec[] {bound_option1, bound_option2, bound_option3}) {\n            \tif (cornerbound2 == null) {\n            \t\tcontinue;\n            \t}\n            \t\n            \t// the corner must be in the line (cornerbound2, cornerbound1)\n                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);\n                if (cornerraytraceresult != null) {\n                \tvec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);\n                \tEnumFacing cornerside = cornerraytraceresult.sideHit;\n                \t\n                \tif (cornerside == bottomside || \n                \t\t\tcornerside.getOpposite() == bottomside) {\n                \t\t// this should not happen\n//                \t\tSystem.out.println(\"Warning: corner is same or opposite of bottomside\");\n                \t\tcontinue;\n                \t} else {\n                \t\t// add a bend around the corner\n                \t\tvec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));\n                \t\tvec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));\n                \t\tvec topropevec = bend.sub(top);\n                \t\tvec bottomropevec = bend.sub(bottom);\n                \t\t\n                \t\t// ignore bends that are too close to another bend\n                \t\tif (topropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: top bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\tif (bottomropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: bottom bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\t\n                \t\tthis.actuallyaddsegment(index, bend, bottomside, cornerside);\n                \t\t\n                \t\t// if not enough rope length left, undo\n                \t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n//                \t\t\tSystem.out.println(\"Warning: not enough length left, removing\");\n                \t\t\tthis.removesegment(index);\n                \t\t\tcontinue;\n                \t\t}\n                \t\t\n                \t\t// now to recurse on top section of rope\n                \t\tdouble newropelen = topropevec.length() + bottomropevec.length();\n                \t\t\n                \t\tdouble prevtoptobend = topropevec.length() * prevropelen / newropelen;\n                \t\tvec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));\n                \t\t\n                \t\tif (numberrecursions < 10) {\n                    \t\tupdatesegment(top, prevtop, bend, prevbend, index, numberrecursions+1);\n                \t\t} else {\n                \t\t\tSystem.out.println(\"Warning: number recursions exceeded\");\n                \t\t}\n                \t\tbreak;\n                \t}\n//                } else {\n//                \tSystem.out.println(\"Warning: no corner collision\");\n                }\n//            } else {\n//            \tSystem.out.println(\"Warning: cornerbound2 is null\");\n            }\n            \n            \n            \n/*            RayTraceResult topraytraceresult = this.world.rayTraceBlocks(top.toVec3d(), bottom.toVec3d());\n            vec tophitvec = new vec(topraytraceresult.hitVec.x, topraytraceresult.hitVec.y, topraytraceresult.hitVec.z);\n            EnumFacing topside = topraytraceresult.sideHit;\n            \n            if (bottomhitvec.sub(top).length() > 0.01 && tophitvec.sub(bottom).length() > 0.01) {\n            \tif (bottomside == topside) {\n            \t\tSystem.out.println(\"Warning: bottomside == topside\");\n            \t} else if ((bottomside == EnumFacing.DOWN && topside == EnumFacing.UP) || \n\t            \t\t(bottomside == EnumFacing.UP && topside == EnumFacing.DOWN) || \n\t            \t\t(bottomside == EnumFacing.EAST && topside == EnumFacing.WEST) || \n\t            \t\t(bottomside == EnumFacing.WEST && topside == EnumFacing.EAST) || \n\t            \t\t(bottomside == EnumFacing.NORTH && topside == EnumFacing.SOUTH) || \n\t            \t\t(bottomside == EnumFacing.SOUTH && topside == EnumFacing.NORTH)) {\n\t            \tSystem.out.println(\"two sides\");\n\t            \t// binary search to find 3rd side\n\t            \tvec newprevtop = prevtop;\n\t            \tvec newprevbottom = prevbottom;\n            \t\tvec center = bottomhitvec.add(tophitvec).mult(0.5);\n\t            \tfor (int i = 0; i < 20; i++) {\n\t            \t\tvec prevcenter = newprevtop.add(newprevbottom).mult(0.5);\n\t            \t\tRayTraceResult thirdsidetrace = this.world.rayTraceBlocks(prevcenter.toVec3d(), center.toVec3d());\n\t            \t\tif (thirdsidetrace == null) {\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t\tEnumFacing thirdside = thirdsidetrace.sideHit;\n\t            \t\tif (thirdside == bottomside) {\n\t            \t\t\tnewprevbottom = prevcenter;\n\t            \t\t} else if (thirdside == topside) {\n\t            \t\t\tnewprevtop = prevcenter;\n\t            \t\t} else {\n\t            \t\t\tvec collisionpoint = new vec(thirdsidetrace.hitVec.x, thirdsidetrace.hitVec.y, thirdsidetrace.hitVec.z);\n\t            \t\t\tthis.addsegment(bottomhitvec, collisionpoint, bottomside, thirdside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tthis.addsegment(collisionpoint, tophitvec, thirdside, topside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t}\n\t            } else {\n                    this.addsegment(bottomhitvec, tophitvec, bottomside, topside, index, top, prevtop, bottom, prevbottom);\n\t            }\n            }*/\n        }\n\t}\n\t\n\tpublic vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {\n\t\t// calculate the intersection of a line and a plane\n\t\t// formula: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n\t\t\n\t\tvec linevec = linepoint2.sub(linepoint1);\n\t\t\n\t\tif (linevec.dot(planenormal) == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tdouble d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);\n\t\treturn linepoint1.add(linevec.mult(d));\n\t}\n\t\n\tpublic vec getnormal(EnumFacing facing) {\n\t\tVec3i facingvec = facing.getDirectionVec();\n\t\treturn new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());\n\t}\n\t\n\tpublic boolean hookpastbend(double ropelen) {\n\t\treturn (this.getDistToFarthest() > ropelen);\n\t}\n\t\n\tpublic BlockPos getbendblock(int index) {\n\t\tvec bendpos = this.segments.get(index);\n\t\tbendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));\n\t\tbendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));\n\t\treturn new BlockPos(bendpos.x, bendpos.y, bendpos.z);\n\t}\n\t\n/*\tpublic void addsegment(vec bottomhit, vec tophit, EnumFacing bottomside, EnumFacing topside, int index, vec top, vec prevtop, vec bottom, vec prevbottom) {\n\t\tSystem.out.println(\"Computing bend point\");\n\t\t\n\t\tvec bottomnormal = getnormal(bottomside);\n\t\tvec topnormal = getnormal(topside);\n\t\tvec edgevec = bottomnormal.cross(topnormal);\n\t\t\n\t\tedgevec.print();\n\t\t\n\t\tdouble d = (tophit.sub(bottomhit)).dot(topnormal) / topnormal.dot(topnormal);\n\t\tvec edgepoint = topnormal.mult(d).add(bottomhit);\n\t\t\n\t\tedgepoint.print();\n\t\t\n\t\tvec movement = bottom.sub(prevbottom);\n\t\tif (movement.length() == 0) {\n\t\t\tmovement = top.sub(prevtop);\n\t\t}\n\t\tvec planenormal = movement.cross(top.sub(bottom));\n\t\t\n\t\tmovement.print();\n\t\tplanenormal.print();\n\t\t\n\t\tif (edgevec.dot(planenormal) == 0) {\n\t\t\tSystem.out.println(\"warning: can't compute bend point\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdouble d2 = (top.sub(edgepoint)).dot(planenormal) / edgevec.dot(planenormal);\n\t\t\n\t\tvec intersectionpoint = edgevec.mult(d2).add(edgepoint);\n\t\t\n\t\tintersectionpoint.print();\n\t\t\n\t\tvec offset = bottomnormal.add(topnormal).mult(0.1);\n\t\tvec bendpoint = intersectionpoint.add(offset);\n\t\t\n\t\tthis.actuallyaddsegment(index, bendpoint, bottomside, topside);\n\n\t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n\t\t\tSystem.out.println(\"not enough length left, removing\");\n\t\t\tthis.removesegment(index);\n\t\t\treturn;\n\t\t}\n\t}*/\n\t\n\tpublic void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {\n        segments.add(index, bendpoint);\n        segmentbottomsides.add(index, bottomside);\n        segmenttopsides.add(index, topside);\n\n        /*System.out.println(\"added segment\");\n\t\tthis.print();*/\n\t\t\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void print() {\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tSystem.out.print(i);\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmenttopsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmentbottomsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tsegments.get(i).print();\n\t\t}\n\t}\n\t\n\tpublic vec getclosest(vec hookpos) {\n\t\tsegments.set(0, hookpos);\n\t\t\n\t\treturn segments.get(segments.size() - 2);\n\t}\n\t\n\tpublic double getDistToAnchor() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 2; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic vec getfarthest() {\n\t\treturn segments.get(1);\n\t}\n\t\n\tpublic double getDistToFarthest() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic double getDist(vec hookpos, vec playerpos) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {\n\t\tthis.updatepos(hookpos, playerpos, this.ropelen);\n\t\tvec minvec = new vec(hookpos);\n\t\tvec maxvec = new vec(hookpos);\n\t\tfor (int i = 1; i < segments.size(); i++) {\n\t\t\tvec segpos = segments.get(i);\n\t\t\tif (segpos.x < minvec.x) {\n\t\t\t\tminvec.x = segpos.x;\n\t\t\t} else if (segpos.x > maxvec.x) {\n\t\t\t\tmaxvec.x = segpos.x;\n\t\t\t}\n\t\t\tif (segpos.y < minvec.y) {\n\t\t\t\tminvec.y = segpos.y;\n\t\t\t} else if (segpos.y > maxvec.y) {\n\t\t\t\tmaxvec.y = segpos.y;\n\t\t\t}\n\t\t\tif (segpos.z < minvec.z) {\n\t\t\t\tminvec.z = segpos.z;\n\t\t\t} else if (segpos.z > maxvec.z) {\n\t\t\t\tmaxvec.z = segpos.z;\n\t\t\t}\n\t\t}\n\t\tAxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);\n//\t\tSystem.out.print(bb.minX);\n//\t\tSystem.out.print(\" \");\n//\t\tSystem.out.println(bb.maxX);\n\t\treturn bb;\n\t}\n}", "class_id": 0, "repo": "Nyfaria/grapplemod", "file": "main/java/com/yyon/grapplinghook/controllers/SegmentHandler.java", "last_update_at": "2021-10-31T06:34:38+00:00", "question_id": "6010ce895b3af2938615bae54d10caa4a458667d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SegmentHandler {\n\tpublic LinkedList<vec> segments;\n\tpublic LinkedList<EnumFacing> segmentbottomsides;\n\tpublic LinkedList<EnumFacing> segmenttopsides;\n\tpublic World world;\n\tpublic grappleArrow arrow;\n\t\n\tvec prevhookpos = null;\n\tvec prevplayerpos = null;;\n\t\n\tfinal double bendoffset = 0.05;\n\tfinal double intoblock = 0.05;\n\t\n\tpublic SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {\n\t\tsegments = new LinkedList<vec>();\n\t\tsegments.add(hookpos);\n\t\tsegments.add(playerpos);\n\t\tsegmentbottomsides = new LinkedList<EnumFacing>();\n\t\tsegmentbottomsides.add(null);\n\t\tsegmentbottomsides.add(null);\n\t\tsegmenttopsides = new LinkedList<EnumFacing>();\n\t\tsegmenttopsides.add(null);\n\t\tsegmenttopsides.add(null);\n\t\tthis.world = w;\n\t\tthis.arrow = arrow;\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n\t\t\n//\t\tSystem.out.println(\"segments:\");\n//\t\thookpos.print();\n//\t\tplayerpos.print();\n\t}\n\t\n\tpublic void forceSetPos(vec hookpos, vec playerpos) {\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n    \tthis.segments.set(0, new vec(hookpos));\n    \tthis.segments.set(this.segments.size() - 1, new vec(playerpos));\n\t}\n\t\n\tdouble ropelen;\n\t\n\tpublic void updatepos(vec hookpos, vec playerpos, double ropelen) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t}\n\t\n\tpublic void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {\n\t\tif (prevhookpos == null) {\n\t        prevhookpos = hookpos;\n\t        prevplayerpos = playerpos;\n\t\t}\n\t\t\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t\t\n\t\t\n\t\tvec closest = segments.get(segments.size()-2);\n\t\t\n\t\twhile (true) {\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint index = segments.size()-2;\n\t\t\tclosest = segments.get(index);\n\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\tvec ropevec = playerpos.sub(closest);\n\t\t\t\n\t\t\tvec beforepoint = segments.get(index-1);\n\t\t\t\n\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\tvec planenormal = beforepoint.sub(closest).cross(edgevec);\n//\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\n//\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\n\t\t\tif (ropevec.dot(planenormal) > 0) {\n\t\t\t\tthis.removesegment(index);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec farthest = segments.get(1);\n\t\t\n\t\tif (movinghook) {\n\t\t\twhile (true) {\n\t\t\t\tif (segments.size() == 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint index = 1;\n\t\t\t\tfarthest = segments.get(index);\n\t\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\t\tvec ropevec = farthest.sub(hookpos);\n\t\t\t\t\n\t\t\t\tvec beforepoint = segments.get(index+1);\n\t\t\t\t\n\t\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\t\tvec planenormal = beforepoint.sub(farthest).cross(edgevec);\n//\t\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\t\n\t\t\t\tif (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {\n//\t\t\t\t\tSystem.out.println(\"removed farthest\");\n\t\t\t\t\tthis.removesegment(index);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tif (this.getDistToFarthest() > ropelen) {\n\t\t\t\t\tthis.removesegment(1);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (movinghook) {\n\t\t\tfarthest = segments.get(1);\n\t\t\tvec prevfarthest = farthest;\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tprevfarthest = prevplayerpos;\n\t\t\t}\n\t\t\tupdatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);\n\t\t}\n\t\t\n\t\tvec prevclosest = closest;\n\t\tif (segments.size() == 2) {\n\t\t\tprevclosest = prevhookpos;\n\t\t}\n\t\tupdatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);\n\t\t\n\t\t\n        prevhookpos = hookpos;\n        prevplayerpos = playerpos;\n\t}\n\t\n\tpublic void removesegment(int index) {\n/*\t\tSystem.out.println(\"removed segment\");*/\n\t\t\n\t\tsegments.remove(index);\n\t\tsegmentbottomsides.remove(index);\n\t\tsegmenttopsides.remove(index);\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {\n        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);\n        // if rope hit block\n        if (bottomraytraceresult != null)\n        {\n        \tif (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {\n//        \t\tSystem.out.println(\"Warning: prev collision\");\n        \t\treturn;\n        \t}\n        \t\n//        \tSystem.out.println(bottomraytraceresult.typeOfHit);\n            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);\n/*            this.arrow.debugpos = bottomhitvec;\n            this.arrow.debugpos2 = bottom;\n            this.arrow.debugpos3 = top;*/\n            EnumFacing bottomside = bottomraytraceresult.sideHit;\n            vec bottomnormal = this.getnormal(bottomside);\n            // calculate where bottomhitvec was along the rope in the previous tick\n//            double ropelen = top.sub(bottom).length();\n            double prevropelen = prevtop.sub(prevbottom).length();\n//            double bottomtohit = bottom.sub(bottomhitvec).length();\n//            double prevbottomtohit = bottomtohit * ropelen / prevropelen;\n//            vec prevbottomhit = prevtop.sub(prevbottom).changelen(prevbottomtohit).add(prevbottom);\n            // use prevbottomhit to calculate the velocity of that part of the rope when it hit the block\n //           vec motionalonghit = bottomhitvec.sub(prevbottomhit);\n            // calculate the motion parallel to the block side\n//            vec motionparallel = motionalonghit.removealong(bottomnormal);\n            // the rope must have hit the corner on the plane across the edge of the block\n            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom\n            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));\n//            vec cornerbound2 = null;\n//            double cornerlinedist = Double.POSITIVE_INFINITY;\n            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option1;\n            \tcornerlinedist = cornerbound1.sub(bound_option1).length();\n            }*/\n            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option2;\n            \tcornerlinedist = cornerbound1.sub(bound_option2).length();\n            }*/\n            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option3).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option3;\n            \tcornerlinedist = cornerbound1.sub(bound_option3).length();\n            }*/\n//            if (cornerbound2 != null) {\n            for (vec cornerbound2 : new vec[] {bound_option1, bound_option2, bound_option3}) {\n            \tif (cornerbound2 == null) {\n            \t\tcontinue;\n            \t}\n            \t\n            \t// the corner must be in the line (cornerbound2, cornerbound1)\n                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);\n                if (cornerraytraceresult != null) {\n                \tvec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);\n                \tEnumFacing cornerside = cornerraytraceresult.sideHit;\n                \t\n                \tif (cornerside == bottomside || \n                \t\t\tcornerside.getOpposite() == bottomside) {\n                \t\t// this should not happen\n//                \t\tSystem.out.println(\"Warning: corner is same or opposite of bottomside\");\n                \t\tcontinue;\n                \t} else {\n                \t\t// add a bend around the corner\n                \t\tvec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));\n                \t\tvec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));\n                \t\tvec topropevec = bend.sub(top);\n                \t\tvec bottomropevec = bend.sub(bottom);\n                \t\t\n                \t\t// ignore bends that are too close to another bend\n                \t\tif (topropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: top bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\tif (bottomropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: bottom bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\t\n                \t\tthis.actuallyaddsegment(index, bend, bottomside, cornerside);\n                \t\t\n                \t\t// if not enough rope length left, undo\n                \t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n//                \t\t\tSystem.out.println(\"Warning: not enough length left, removing\");\n                \t\t\tthis.removesegment(index);\n                \t\t\tcontinue;\n                \t\t}\n                \t\t\n                \t\t// now to recurse on top section of rope\n                \t\tdouble newropelen = topropevec.length() + bottomropevec.length();\n                \t\t\n                \t\tdouble prevtoptobend = topropevec.length() * prevropelen / newropelen;\n                \t\tvec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));\n                \t\t\n                \t\tif (numberrecursions < 10) {\n                    \t\tupdatesegment(top, prevtop, bend, prevbend, index, numberrecursions+1);\n                \t\t} else {\n                \t\t\tSystem.out.println(\"Warning: number recursions exceeded\");\n                \t\t}\n                \t\tbreak;\n                \t}\n//                } else {\n//                \tSystem.out.println(\"Warning: no corner collision\");\n                }\n//            } else {\n//            \tSystem.out.println(\"Warning: cornerbound2 is null\");\n            }\n/*            RayTraceResult topraytraceresult = this.world.rayTraceBlocks(top.toVec3d(), bottom.toVec3d());\n            vec tophitvec = new vec(topraytraceresult.hitVec.x, topraytraceresult.hitVec.y, topraytraceresult.hitVec.z);\n            EnumFacing topside = topraytraceresult.sideHit;\n            if (bottomhitvec.sub(top).length() > 0.01 && tophitvec.sub(bottom).length() > 0.01) {\n            \tif (bottomside == topside) {\n            \t\tSystem.out.println(\"Warning: bottomside == topside\");\n            \t} else if ((bottomside == EnumFacing.DOWN && topside == EnumFacing.UP) || \n\t            \t\t(bottomside == EnumFacing.UP && topside == EnumFacing.DOWN) || \n\t            \t\t(bottomside == EnumFacing.EAST && topside == EnumFacing.WEST) || \n\t            \t\t(bottomside == EnumFacing.WEST && topside == EnumFacing.EAST) || \n\t            \t\t(bottomside == EnumFacing.NORTH && topside == EnumFacing.SOUTH) || \n\t            \t\t(bottomside == EnumFacing.SOUTH && topside == EnumFacing.NORTH)) {\n\t            \tSystem.out.println(\"two sides\");\n\t            \t// binary search to find 3rd side\n\t            \tvec newprevtop = prevtop;\n\t            \tvec newprevbottom = prevbottom;\n            \t\tvec center = bottomhitvec.add(tophitvec).mult(0.5);\n\t            \tfor (int i = 0; i < 20; i++) {\n\t            \t\tvec prevcenter = newprevtop.add(newprevbottom).mult(0.5);\n\t            \t\tRayTraceResult thirdsidetrace = this.world.rayTraceBlocks(prevcenter.toVec3d(), center.toVec3d());\n\t            \t\tif (thirdsidetrace == null) {\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t\tEnumFacing thirdside = thirdsidetrace.sideHit;\n\t            \t\tif (thirdside == bottomside) {\n\t            \t\t\tnewprevbottom = prevcenter;\n\t            \t\t} else if (thirdside == topside) {\n\t            \t\t\tnewprevtop = prevcenter;\n\t            \t\t} else {\n\t            \t\t\tvec collisionpoint = new vec(thirdsidetrace.hitVec.x, thirdsidetrace.hitVec.y, thirdsidetrace.hitVec.z);\n\t            \t\t\tthis.addsegment(bottomhitvec, collisionpoint, bottomside, thirdside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tthis.addsegment(collisionpoint, tophitvec, thirdside, topside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t}\n\t            } else {\n                    this.addsegment(bottomhitvec, tophitvec, bottomside, topside, index, top, prevtop, bottom, prevbottom);\n\t            }\n            }*/\n        }\n\t}\n\t\n\tpublic vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {\n\t\t// calculate the intersection of a line and a plane\n\t\t// formula: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n\t\t\n\t\tvec linevec = linepoint2.sub(linepoint1);\n\t\t\n\t\tif (linevec.dot(planenormal) == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tdouble d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);\n\t\treturn linepoint1.add(linevec.mult(d));\n\t}\n\t\n\tpublic vec getnormal(EnumFacing facing) {\n\t\tVec3i facingvec = facing.getDirectionVec();\n\t\treturn new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());\n\t}\n\t\n\tpublic boolean hookpastbend(double ropelen) {\n\t\treturn (this.getDistToFarthest() > ropelen);\n\t}\n\t\n\tpublic BlockPos getbendblock(int index) {\n\t\tvec bendpos = this.segments.get(index);\n\t\tbendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));\n\t\tbendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));\n\t\treturn new BlockPos(bendpos.x, bendpos.y, bendpos.z);\n\t}\n\t\n/*\tpublic void addsegment(vec bottomhit, vec tophit, EnumFacing bottomside, EnumFacing topside, int index, vec top, vec prevtop, vec bottom, vec prevbottom) {\n\t\tSystem.out.println(\"Computing bend point\");\n\t\t\n\t\tvec bottomnormal = getnormal(bottomside);\n\t\tvec topnormal = getnormal(topside);\n\t\tvec edgevec = bottomnormal.cross(topnormal);\n\t\t\n\t\tedgevec.print();\n\t\t\n\t\tdouble d = (tophit.sub(bottomhit)).dot(topnormal) / topnormal.dot(topnormal);\n\t\tvec edgepoint = topnormal.mult(d).add(bottomhit);\n\t\t\n\t\tedgepoint.print();\n\t\t\n\t\tvec movement = bottom.sub(prevbottom);\n\t\tif (movement.length() == 0) {\n\t\t\tmovement = top.sub(prevtop);\n\t\t}\n\t\tvec planenormal = movement.cross(top.sub(bottom));\n\t\t\n\t\tmovement.print();\n\t\tplanenormal.print();\n\t\t\n\t\tif (edgevec.dot(planenormal) == 0) {\n\t\t\tSystem.out.println(\"warning: can't compute bend point\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdouble d2 = (top.sub(edgepoint)).dot(planenormal) / edgevec.dot(planenormal);\n\t\t\n\t\tvec intersectionpoint = edgevec.mult(d2).add(edgepoint);\n\t\t\n\t\tintersectionpoint.print();\n\t\t\n\t\tvec offset = bottomnormal.add(topnormal).mult(0.1);\n\t\tvec bendpoint = intersectionpoint.add(offset);\n\t\t\n\t\tthis.actuallyaddsegment(index, bendpoint, bottomside, topside);\n\t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n\t\t\tSystem.out.println(\"not enough length left, removing\");\n\t\t\tthis.removesegment(index);\n\t\t\treturn;\n\t\t}\n\t}*/\n\t\n\tpublic void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {\n        segments.add(index, bendpoint);\n        segmentbottomsides.add(index, bottomside);\n        segmenttopsides.add(index, topside);\n        /*System.out.println(\"added segment\");\n\t\tthis.print();*/\n\t\t\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void print() {\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tSystem.out.print(i);\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmenttopsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmentbottomsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tsegments.get(i).print();\n\t\t}\n\t}\n\t\n\tpublic vec getclosest(vec hookpos) {\n\t\tsegments.set(0, hookpos);\n\t\t\n\t\treturn segments.get(segments.size() - 2);\n\t}\n\t\n\tpublic double getDistToAnchor() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 2; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic vec getfarthest() {\n\t\treturn segments.get(1);\n\t}\n\t\n\tpublic double getDistToFarthest() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic double getDist(vec hookpos, vec playerpos) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {\n\t\tthis.updatepos(hookpos, playerpos, this.ropelen);\n\t\tvec minvec = new vec(hookpos);\n\t\tvec maxvec = new vec(hookpos);\n\t\tfor (int i = 1; i < segments.size(); i++) {\n\t\t\tvec segpos = segments.get(i);\n\t\t\tif (segpos.x < minvec.x) {\n\t\t\t\tminvec.x = segpos.x;\n\t\t\t} else if (segpos.x > maxvec.x) {\n\t\t\t\tmaxvec.x = segpos.x;\n\t\t\t}\n\t\t\tif (segpos.y < minvec.y) {\n\t\t\t\tminvec.y = segpos.y;\n\t\t\t} else if (segpos.y > maxvec.y) {\n\t\t\t\tmaxvec.y = segpos.y;\n\t\t\t}\n\t\t\tif (segpos.z < minvec.z) {\n\t\t\t\tminvec.z = segpos.z;\n\t\t\t} else if (segpos.z > maxvec.z) {\n\t\t\t\tmaxvec.z = segpos.z;\n\t\t\t}\n\t\t}\n\t\tAxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);\n//\t\tSystem.out.print(bb.minX);\n//\t\tSystem.out.print(\" \");\n//\t\tSystem.out.println(bb.maxX);\n\t\treturn bb;\n\t}\n"]], "pred": {"ppl": 1.8671479225158691, "ppl_lower": 1.904847264289856, "ppl/lowercase_ppl": -1.0320136940550224, "ppl/zlib": 0.00015575257956541679, "Min_5.0% Prob": 7.094859618766635, "Min_10.0% Prob": 4.762486466005737, "Min_20.0% Prob": 2.915957615948191, "Min_30.0% Prob": 2.041609691054213, "Min_40.0% Prob": 1.5502203753568724, "Min_50.0% Prob": 1.24653505157395, "Min_60.0% Prob": 1.04081674489811}}
{"hexsha": "771fae9bb70c50c42d7f3b36993cef4a89b3c044", "ext": "java", "lang": "Java", "content": "public class Reassociate {\n\tprivate static Log log = LogFactory.getLog(Reassociate.class);\n\t\n\tprivate List<String> errorList = new ArrayList<String>();\n\tprivate List<String> msgList = new ArrayList<String>();\n\tprivate Map<String,String> locMap = new HashMap<String,String>();\n\tprivate Map<String,String> toMap = new HashMap<String,String>();\n\tInventoryQuery iq = InventoryFactory.getInstance().getQuery();\n\tInventoryAccess ia = InventoryFactory.getInstance().getAccess();\n\tprivate boolean testMode = true;\n\tprivate boolean interactive = true;\n\t//the default, overwrite files\n\tprivate boolean updateMetaOnMissing = false;\n\tprivate boolean overwrite = true;\n\t\n\t\n\tpublic void setTestMode(boolean val){\n\t\tthis.testMode = val;\n\t}\n\t\n\t\n\tpublic Map<String,Object> productReassociate(Long productId, String toProductType){\n\t\tinteractive = false;\n\t\tProduct g = iq.getProductMetadata(productId).getProduct();\n\n\t\tlog.debug(\"From ProductType:\" +g.getPtId());\n\t\tProductType fromD = iq.fetchProductType(g.getPtId());\n\t\t\n\t\t\n\t\tlog.debug(\"To ProductType:\" +toProductType);\n\n\t\tProductType toD = iq.fetchProductTypeByPersistentId(toProductType);\n\t\tString toBasePath = null;\n\t\t\n\t\t//make sure locMaps are defined (location policies).\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\t\n\t\tHashMap<String,Object> ret = new HashMap<String,Object>();\n\t\t\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\terrorList.add(\"No 'to basepath' found for productType [\"+toProductType+\"]. Failed to reassociate product.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tlog.info(\"Reassociating Product [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\treassociateProduct(g,toBasePath,toD, fromD);\n\t\tif(errorList.size() > 0 ){\n\t\t\tlog.debug(\"Errors processing reassociate.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\telse{\n\t\t\tlog.debug(\"Successfully processed product\");\n\t\t\tret.put(\"type\", \"success\");\n\t\t\tret.put(\"msgs\", msgList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void reassociateProducts(ProductType fromD, ProductType toD,\n\t\t\tString gnp, boolean moveAll) {\n\t\t\n\t\t\n\t\tString toBasePath = null;\n\t\tList<Long> productIds;\n\t\t\n\t\t//get products by name/pattern\n\t\tif(moveAll){\n\t\t\tproductIds = iq.getProductIdList(fromD.getId());\n\t\t}\n\t\telse{\n\t\t\t//find the products by pattern...\n\t\t\tproductIds = new ArrayList<Long>();\n\t\t\tList<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);\n\t\t\tfor(Product g: gList){\n\t\t\t\tproductIds.add(g.getId());\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Number of products to reassociate: \" + productIds.size());\n\t\t\n\t\t//fetch fromBasePaths\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\tSystem.exit(99);\n\t\t}\n\t\tint count = 1;\n\t\tfor(Long i : productIds){\n\n\t\t\tProduct g  = iq.getProductMetadata(i).getProduct();\n\t\t\tSystem.out.println(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\tlog.info(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\treassociateProduct(g, toBasePath, toD,fromD);\n\t\t\t++count;\n\t\t}\n\t\t\n\t\tif(errorList.size() > 0){\n\t\t\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed with errors:\");\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tSystem.out.println(\"\\t\" + s);\n\t\t\t}\n\t\t\t\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tlog.debug(\"Processing completed with errors:\");\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tlog.debug(\"\\t\" + s);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed without errors\");\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\t\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t\tlog.debug(\"Processing completed without errors\");\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t}\n\t}\n\n\tprivate void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD){\n\t\t/*\n\t\tif(this.testMode){\n\t\t\tString fromLoc=null, toLoc=null;\n\t\t\tfor(ProductArchive ga : iq.getProductArchiveSet()){\n\t\t\t\t//create old,new file locations\n\t\t\t\tfromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\ttoLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*/\n\t\t\n\t\t//offlineProduct\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"OFFLINE\");\n\t\t\n\t\t//move files\n\t\tif(!moveFiles(g,toBasePath)){\n\t\t\t//ERROR OCCURED, should we skip the rest?\n\t\t\tlog.warn(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.\");\n\t\t\terrorList.add(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.)\");\n\t\t\t\n\t\t\treturn;\n\t\t}\t\n\t\tlog.debug(\"Set product root, productType to [\"+toBasePath+\",\" + toD.getId()+\"]\");\n\t\tg.setRootPath(toBasePath);\n\t\tg.setPtId(toD.getId());\n\t\tString at = null;\n\t\ttry{\n\t\t\tat = iq.getProductTypeAccessType(toD.getId());\n\t\t}catch(Exception e){\n\t\t\tlog.debug(\"error getting productType info.\");\n\t\t\t//at = iq.getProductTypeMetadata(toD.getId()).getProductType().getProductTypePolicy().getAccessType();\n\t\t}\n\t\t//TODO see if this was necessary at all\n\t\t//g.setAccessType(at);\n\t\t\n\t\t\n\t\t//see if there exists a product for the toProductType already\n\t\tlog.debug(\"Delete Checks\");\n\t\tProduct exists =  iq.fetchProduct(toD.getId(), g.getName());\n\t\tif(exists != null){\n\t\t\tlog.debug(\"Product exists in destination product type.Removing product[\"+exists.getId()+\"]\");\n\n\t\t\tia.deleteProduct(exists, false);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tia.updateProductInfo(g);  //UNCOMMENT THIS \n\t\t\n\t\t//update productRefs\n\t\tlog.debug(\"Changing local product reference paths\");\n\t\t//reReference(g,toMap, locMap);\n\t\t\n\t\t\n\t\t//TODO\n\t\t//update product_real, date, int, char, spatial\n\t\t//Productelements will need to be mapped to the new DEIDS and updated in the product_* tables\n\t\tlog.debug(\"Chagning product elements to use new productType IDs\");\n\t\t//reElement(g, toD, fromD);\n\t\n\t\t//set product to online\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"ONLINE\");\n\t}\n\t\n\t//TODO reimplement when ready\n\t/*\n\tprivate void reElement(Product g, ProductType toD, ProductType fromD) {\n\t\t\n\t\tia.reElement(g,toD,fromD);\n//\t\tMap<Integer,String> deIDmapping = new HashMap<Integer,String>();\n//\t\tfor(ProductTypeElement toDE : toD.getProductTypeElementSet()){\n//\t\t\t\n//\t\t\tfor(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){\n//\t\t\t\tif(toDE.getElementDD().equals(fromDE.getElementDD()))\n//\t\t\t\t\tdeIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+\",\"+toDE.getDeId());\n//\t\t\t}\t\n//\t\t}\n//\t\tlog.debug(\"DEID Mappings\");\n//\t\tfor(Entry<Integer,String> me : deIDmapping.entrySet()){\n//\t\t\tString[] ary = me.getValue().split(\",\"); \n//\t\t\tString type = ary[0].trim();\n//\t\t\tInteger deId = Integer.valueOf(ary[1].trim());\n//\t\t\tif(type.equals(\"time\"))\n//\t\t\t\ttype = \"DATETIME\";\n//\t\t\t\n//\t\t\tlog.debug(\"map \"+ me.getKey() + \" to \" + deId + \"[\"+type+\"]\");\n//\t\t\tia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);\n//\t\t}\n\t}\n\n\tprivate void reReference(Product g, Map<String, String> toMap,\n\t\t\tMap<String, String> locMap) {\n\t\tfor(ProductReference ref : g.getProductReferenceSet()){\n\t\t\tif(ref.getType().contains(\"LOCAL\")){\n\t\t\t\tlog.debug(\"from: \" + ref.getPath());\n\t\t\t\t//check to make sure the *Map.gets are not null\n\t\t\t\tString replaceWith = toMap.get(ref.getType());\n\t\t\t\tif(replaceWith == null)\n\t\t\t\t{\n\t\t\t\t\terrorList.add(\"No entry in \\\"toProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString replace = locMap.get(ref.getType());\n\t\t\t\tif(replace == null){\n\t\t\t\t\terrorList.add(\"No entry in \\\"fromProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\t//this should never happen\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString newRef = ref.getPath().replaceAll(replace, replaceWith);\n\t\t\t\tlog.debug(\"newRef: \" + newRef);\n\t\t\t\t//make sure newRef is different that oldRef\n\t\t\t\tif(newRef.equals(ref.getPath())){\n\t\t\t\t\tlog.debug(\"newRef same as oldRef.\");\n\t\t\t\t\terrorList.add(\"product [\"+g.getProductId()+\"] newReference same as old reference.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n   */\n   private boolean moveFiles(Product g, String toBasePath) {\n\n      boolean noErrors = true;\n      log.debug(\"Product name: \" + g.getName());\n      String fromLoc = null, toLoc = null;\n      for (ProductArchive ga : iq.getProductArchives(g.getId())) {\n         // create old,new file locations\n         fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n         toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n         if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {\n            errorList.add(\"Error moving product file [\" + fromLoc + \"] to [\" + toLoc + \"]. Run with debug mode for more details.\");\n            noErrors = false;\n         } else\n            log.info(\"Successfully moved product file [\" + fromLoc + \"] to [\" + toLoc + \"].\");\n      }\n\n      // return true if we had an error.\n      return noErrors;\n\n   }\n\n}", "class_id": 0, "repo": "dataplumber/horizon", "file": "archive/src/main/java/gov/nasa/horizon/archive/core/Reassociate.java", "last_update_at": "2021-07-02T23:50:52+00:00", "question_id": "771fae9bb70c50c42d7f3b36993cef4a89b3c044", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Reassociate {\n\tprivate static Log log = LogFactory.getLog(Reassociate.class);\n\t\n\tprivate List<String> errorList = new ArrayList<String>();\n\tprivate List<String> msgList = new ArrayList<String>();\n\tprivate Map<String,String> locMap = new HashMap<String,String>();\n\tprivate Map<String,String> toMap = new HashMap<String,String>();\n\tInventoryQuery iq = InventoryFactory.getInstance().getQuery();\n\tInventoryAccess ia = InventoryFactory.getInstance().getAccess();\n\tprivate boolean testMode = true;\n\tprivate boolean interactive = true;\n\t//the default, overwrite files\n\tprivate boolean updateMetaOnMissing = false;\n\tprivate boolean overwrite = true;\n\t\n\t\n\tpublic void setTestMode(boolean val){\n\t\tthis.testMode = val;\n\t}\n\t\n\t\n\tpublic Map<String,Object> productReassociate(Long productId, String toProductType){\n\t\tinteractive = false;\n\t\tProduct g = iq.getProductMetadata(productId).getProduct();\n\t\tlog.debug(\"From ProductType:\" +g.getPtId());\n\t\tProductType fromD = iq.fetchProductType(g.getPtId());\n\t\t\n\t\t\n\t\tlog.debug(\"To ProductType:\" +toProductType);\n\t\tProductType toD = iq.fetchProductTypeByPersistentId(toProductType);\n\t\tString toBasePath = null;\n\t\t\n\t\t//make sure locMaps are defined (location policies).\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\t\n\t\tHashMap<String,Object> ret = new HashMap<String,Object>();\n\t\t\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\terrorList.add(\"No 'to basepath' found for productType [\"+toProductType+\"]. Failed to reassociate product.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tlog.info(\"Reassociating Product [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\treassociateProduct(g,toBasePath,toD, fromD);\n\t\tif(errorList.size() > 0 ){\n\t\t\tlog.debug(\"Errors processing reassociate.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\telse{\n\t\t\tlog.debug(\"Successfully processed product\");\n\t\t\tret.put(\"type\", \"success\");\n\t\t\tret.put(\"msgs\", msgList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void reassociateProducts(ProductType fromD, ProductType toD,\n\t\t\tString gnp, boolean moveAll) {\n\t\t\n\t\t\n\t\tString toBasePath = null;\n\t\tList<Long> productIds;\n\t\t\n\t\t//get products by name/pattern\n\t\tif(moveAll){\n\t\t\tproductIds = iq.getProductIdList(fromD.getId());\n\t\t}\n\t\telse{\n\t\t\t//find the products by pattern...\n\t\t\tproductIds = new ArrayList<Long>();\n\t\t\tList<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);\n\t\t\tfor(Product g: gList){\n\t\t\t\tproductIds.add(g.getId());\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Number of products to reassociate: \" + productIds.size());\n\t\t\n\t\t//fetch fromBasePaths\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\tSystem.exit(99);\n\t\t}\n\t\tint count = 1;\n\t\tfor(Long i : productIds){\n\t\t\tProduct g  = iq.getProductMetadata(i).getProduct();\n\t\t\tSystem.out.println(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\tlog.info(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\treassociateProduct(g, toBasePath, toD,fromD);\n\t\t\t++count;\n\t\t}\n\t\t\n\t\tif(errorList.size() > 0){\n\t\t\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed with errors:\");\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tSystem.out.println(\"\\t\" + s);\n\t\t\t}\n\t\t\t\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tlog.debug(\"Processing completed with errors:\");\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tlog.debug(\"\\t\" + s);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed without errors\");\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\t\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t\tlog.debug(\"Processing completed without errors\");\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t}\n\t}\n\tprivate void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD){\n\t\t/*\n\t\tif(this.testMode){\n\t\t\tString fromLoc=null, toLoc=null;\n\t\t\tfor(ProductArchive ga : iq.getProductArchiveSet()){\n\t\t\t\t//create old,new file locations\n\t\t\t\tfromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\ttoLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*/\n\t\t\n\t\t//offlineProduct\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"OFFLINE\");\n\t\t\n\t\t//move files\n\t\tif(!moveFiles(g,toBasePath)){\n\t\t\t//ERROR OCCURED, should we skip the rest?\n\t\t\tlog.warn(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.\");\n\t\t\terrorList.add(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.)\");\n\t\t\t\n\t\t\treturn;\n\t\t}\t\n\t\tlog.debug(\"Set product root, productType to [\"+toBasePath+\",\" + toD.getId()+\"]\");\n\t\tg.setRootPath(toBasePath);\n\t\tg.setPtId(toD.getId());\n\t\tString at = null;\n\t\ttry{\n\t\t\tat = iq.getProductTypeAccessType(toD.getId());\n\t\t}catch(Exception e){\n\t\t\tlog.debug(\"error getting productType info.\");\n\t\t\t//at = iq.getProductTypeMetadata(toD.getId()).getProductType().getProductTypePolicy().getAccessType();\n\t\t}\n\t\t//TODO see if this was necessary at all\n\t\t//g.setAccessType(at);\n\t\t\n\t\t\n\t\t//see if there exists a product for the toProductType already\n\t\tlog.debug(\"Delete Checks\");\n\t\tProduct exists =  iq.fetchProduct(toD.getId(), g.getName());\n\t\tif(exists != null){\n\t\t\tlog.debug(\"Product exists in destination product type.Removing product[\"+exists.getId()+\"]\");\n\t\t\tia.deleteProduct(exists, false);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tia.updateProductInfo(g);  //UNCOMMENT THIS \n\t\t\n\t\t//update productRefs\n\t\tlog.debug(\"Changing local product reference paths\");\n\t\t//reReference(g,toMap, locMap);\n\t\t\n\t\t\n\t\t//TODO\n\t\t//update product_real, date, int, char, spatial\n\t\t//Productelements will need to be mapped to the new DEIDS and updated in the product_* tables\n\t\tlog.debug(\"Chagning product elements to use new productType IDs\");\n\t\t//reElement(g, toD, fromD);\n\t\n\t\t//set product to online\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"ONLINE\");\n\t}\n\t\n\t//TODO reimplement when ready\n\t/*\n\tprivate void reElement(Product g, ProductType toD, ProductType fromD) {\n\t\t\n\t\tia.reElement(g,toD,fromD);\n//\t\tMap<Integer,String> deIDmapping = new HashMap<Integer,String>();\n//\t\tfor(ProductTypeElement toDE : toD.getProductTypeElementSet()){\n//\t\t\t\n//\t\t\tfor(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){\n//\t\t\t\tif(toDE.getElementDD().equals(fromDE.getElementDD()))\n//\t\t\t\t\tdeIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+\",\"+toDE.getDeId());\n//\t\t\t}\t\n//\t\t}\n//\t\tlog.debug(\"DEID Mappings\");\n//\t\tfor(Entry<Integer,String> me : deIDmapping.entrySet()){\n//\t\t\tString[] ary = me.getValue().split(\",\"); \n//\t\t\tString type = ary[0].trim();\n//\t\t\tInteger deId = Integer.valueOf(ary[1].trim());\n//\t\t\tif(type.equals(\"time\"))\n//\t\t\t\ttype = \"DATETIME\";\n//\t\t\t\n//\t\t\tlog.debug(\"map \"+ me.getKey() + \" to \" + deId + \"[\"+type+\"]\");\n//\t\t\tia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);\n//\t\t}\n\t}\n\tprivate void reReference(Product g, Map<String, String> toMap,\n\t\t\tMap<String, String> locMap) {\n\t\tfor(ProductReference ref : g.getProductReferenceSet()){\n\t\t\tif(ref.getType().contains(\"LOCAL\")){\n\t\t\t\tlog.debug(\"from: \" + ref.getPath());\n\t\t\t\t//check to make sure the *Map.gets are not null\n\t\t\t\tString replaceWith = toMap.get(ref.getType());\n\t\t\t\tif(replaceWith == null)\n\t\t\t\t{\n\t\t\t\t\terrorList.add(\"No entry in \\\"toProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString replace = locMap.get(ref.getType());\n\t\t\t\tif(replace == null){\n\t\t\t\t\terrorList.add(\"No entry in \\\"fromProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\t//this should never happen\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString newRef = ref.getPath().replaceAll(replace, replaceWith);\n\t\t\t\tlog.debug(\"newRef: \" + newRef);\n\t\t\t\t//make sure newRef is different that oldRef\n\t\t\t\tif(newRef.equals(ref.getPath())){\n\t\t\t\t\tlog.debug(\"newRef same as oldRef.\");\n\t\t\t\t\terrorList.add(\"product [\"+g.getProductId()+\"] newReference same as old reference.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n   */\n   private boolean moveFiles(Product g, String toBasePath) {\n      boolean noErrors = true;\n      log.debug(\"Product name: \" + g.getName());\n      String fromLoc = null, toLoc = null;\n      for (ProductArchive ga : iq.getProductArchives(g.getId())) {\n         // create old,new file locations\n         fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n         toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n         if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {\n            errorList.add(\"Error moving product file [\" + fromLoc + \"] to [\" + toLoc + \"]. Run with debug mode for more details.\");\n            noErrors = false;\n         } else\n            log.info(\"Successfully moved product file [\" + fromLoc + \"] to [\" + toLoc + \"].\");\n      }\n      // return true if we had an error.\n      return noErrors;\n   }\n"]], "pred": {"ppl": 2.459155797958374, "ppl_lower": 2.582515239715576, "ppl/lowercase_ppl": -1.0543951078521854, "ppl/zlib": 0.0003118953620401385, "Min_5.0% Prob": 7.252735119239957, "Min_10.0% Prob": 5.701077136338926, "Min_20.0% Prob": 3.910302996051078, "Min_30.0% Prob": 2.884860062813447, "Min_40.0% Prob": 2.222236250989449, "Min_50.0% Prob": 1.7933462681412813, "Min_60.0% Prob": 1.4991944667991086}}
{"hexsha": "aaf5418ef49cbe5565f0b3cf9c16a929b43a0ec1", "ext": "java", "lang": "Java", "content": "public class BaconHistogram {\r\n\tpublic static void main(String[] args) {\r\n\t\tSymbolGraph sg = new SymbolGraph(\"movies.txt\", \"/\");\r\n\r\n\t\tGraph G = sg.G();\r\n\r\n\t\tString source = \"Bacon, Kevin\";\r\n\t\tif (!sg.contains(source)) {\r\n\t\t\tStdOut.println(source + \"not in database.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint s = sg.index(source);\r\n\t\tBreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\r\n\r\n\t\tint[] num = new int[G.V()];\r\n\t\tint infinite = 0;\r\n\t\tfor (int v = 0; v < G.V(); v++) {\r\n\t\t\tint distance = bfs.distTo(v);\r\n\t\t\tif (distance != Integer.MAX_VALUE) {\r\n\t\t\t\tnum[distance]++;\r\n\t\t\t} else {\r\n\t\t\t\tinfinite++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0; i < num.length; i += 2) {\r\n\t\t\tif (num[i] != 0) {\r\n\t\t\t\tSystem.out.println(\"Kevin Bacon = \" + i / 2 + \" : \" + num[i]);\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Infinite(actors and movies): \" + infinite);\r\n\t}\r\n}", "class_id": 0, "repo": "wenghengcong/Algorithms", "file": "cs61b_algo4_other/src/com/luci/algorithms/chapter4_1/BaconHistogram.java", "last_update_at": "2021-12-14T21:17:40+00:00", "question_id": "aaf5418ef49cbe5565f0b3cf9c16a929b43a0ec1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaconHistogram {\r\n\tpublic static void main(String[] args) {\r\n\t\tSymbolGraph sg = new SymbolGraph(\"movies.txt\", \"/\");\r\n\r\n\t\tGraph G = sg.G();\r\n\r\n\t\tString source = \"Bacon, Kevin\";\r\n\t\tif (!sg.contains(source)) {\r\n\t\t\tStdOut.println(source + \"not in database.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint s = sg.index(source);\r\n\t\tBreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\r\n\r\n\t\tint[] num = new int[G.V()];\r\n\t\tint infinite = 0;\r\n\t\tfor (int v = 0; v < G.V(); v++) {\r\n\t\t\tint distance = bfs.distTo(v);\r\n\t\t\tif (distance != Integer.MAX_VALUE) {\r\n\t\t\t\tnum[distance]++;\r\n\t\t\t} else {\r\n\t\t\t\tinfinite++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0; i < num.length; i += 2) {\r\n\t\t\tif (num[i] != 0) {\r\n\t\t\t\tSystem.out.println(\"Kevin Bacon = \" + i / 2 + \" : \" + num[i]);\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Infinite(actors and movies): \" + infinite);\r\n\t}\r\n"]], "pred": {"ppl": 1.8177390098571777, "ppl_lower": 2.4288783073425293, "ppl/lowercase_ppl": -1.4850055397022728, "ppl/zlib": 0.0013339138984715876, "Min_5.0% Prob": 6.73868203163147, "Min_10.0% Prob": 4.761665795300458, "Min_20.0% Prob": 2.8564519870281218, "Min_30.0% Prob": 1.965348522483775, "Min_40.0% Prob": 1.4880519518196977, "Min_50.0% Prob": 1.1931639844748787, "Min_60.0% Prob": 0.9990023443664927}}
{"hexsha": "bd5b15cd144abcfa59c8caa88db76b914d05a608", "ext": "java", "lang": "Java", "content": "public class CalendarFormatterStressTest {\n\n  private static final int DATE = 0x01;\n  private static final int TIME = 0x02;\n  private static final int WRAPPER = 0x04;\n  private static final int DATESKEL = 0x08;\n  private static final int TIMESKEL = 0x10;\n  \n  private static final CalendarFormat[] FORMATS = CalendarFormat.values();\n  private static final int FORMATS_LEN = FORMATS.length;\n  private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();\n  private static final int SKELETONS_LEN = SKELETONS.length;\n  \n  @Test\n  public void testCalendarFormatter() {\n    StringBuilder buffer = new StringBuilder();\n    long epoch = 1288648500000L;\n    CLDR.Locale[] locales = new CLDR.Locale[] {\n      CLDR.Locale.en_US,\n      CLDR.Locale.am,\n      CLDR.Locale.ar,\n      CLDR.Locale.fr,\n      CLDR.Locale.de,\n      CLDR.Locale.en_GB\n    };\n    \n    ZoneId zoneId = ZoneId.of(\"America/New_York\");\n    ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);\n\n    for (CLDR.Locale locale : locales) {\n      CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);\n      int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;\n      int inner = FORMATS_LEN * SKELETONS_LEN;\n      for (int i = 0; i < outer; i++) {\n        for (int j = 0; j < inner; j++) {\n          CalendarFormatOptions options = options(i, j);\n          buffer.setLength(0);\n          f.format(datetime, options, buffer);\n        }\n      }\n    }\n  }\n  \n  private static CalendarFormatOptions options(int flag, int choice) {\n    CalendarFormatOptions opts = new CalendarFormatOptions();\n    if ((flag & DATE) != 0) {\n      opts.setDateFormat(format(choice));\n    }\n    if ((flag & TIME) != 0) {\n      opts.setTimeFormat(format(choice));\n    }\n    if ((flag & WRAPPER) != 0) {\n      opts.setWrapperFormat(format(choice));\n    }\n    if ((flag & DATESKEL) != 0) {\n      opts.setDateSkeleton(skeleton(choice));\n    }\n    if ((flag & TIMESKEL) != 0) {\n      opts.setTimeSkeleton(skeleton(choice));\n    }\n    return opts;\n  }\n  \n  private static CalendarFormat format(int choice) {\n    return FORMATS[choice % FORMATS_LEN];\n  }\n  \n  private static CalendarSkeleton skeleton(int choice) {\n    return SKELETONS[choice % SKELETONS_LEN];\n  }\n  \n}", "class_id": 0, "repo": "Squarespace/cldr", "file": "runtime/src/test/java/com/squarespace/cldr/dates/CalendarFormatterStressTest.java", "last_update_at": "2021-03-10T13:56:40+00:00", "question_id": "bd5b15cd144abcfa59c8caa88db76b914d05a608", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CalendarFormatterStressTest {\n  private static final int DATE = 0x01;\n  private static final int TIME = 0x02;\n  private static final int WRAPPER = 0x04;\n  private static final int DATESKEL = 0x08;\n  private static final int TIMESKEL = 0x10;\n  private static final CalendarFormat[] FORMATS = CalendarFormat.values();\n  private static final int FORMATS_LEN = FORMATS.length;\n  private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();\n  private static final int SKELETONS_LEN = SKELETONS.length;\n  @Test\n  public void testCalendarFormatter() {\n    StringBuilder buffer = new StringBuilder();\n    long epoch = 1288648500000L;\n    CLDR.Locale[] locales = new CLDR.Locale[] {\n      CLDR.Locale.en_US,\n      CLDR.Locale.am,\n      CLDR.Locale.ar,\n      CLDR.Locale.fr,\n      CLDR.Locale.de,\n      CLDR.Locale.en_GB\n    };\n    ZoneId zoneId = ZoneId.of(\"America/New_York\");\n    ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);\n    for (CLDR.Locale locale : locales) {\n      CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);\n      int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;\n      int inner = FORMATS_LEN * SKELETONS_LEN;\n      for (int i = 0; i < outer; i++) {\n        for (int j = 0; j < inner; j++) {\n          CalendarFormatOptions options = options(i, j);\n          buffer.setLength(0);\n          f.format(datetime, options, buffer);\n        }\n      }\n    }\n  }\n  private static CalendarFormatOptions options(int flag, int choice) {\n    CalendarFormatOptions opts = new CalendarFormatOptions();\n    if ((flag & DATE) != 0) {\n      opts.setDateFormat(format(choice));\n    }\n    if ((flag & TIME) != 0) {\n      opts.setTimeFormat(format(choice));\n    }\n    if ((flag & WRAPPER) != 0) {\n      opts.setWrapperFormat(format(choice));\n    }\n    if ((flag & DATESKEL) != 0) {\n      opts.setDateSkeleton(skeleton(choice));\n    }\n    if ((flag & TIMESKEL) != 0) {\n      opts.setTimeSkeleton(skeleton(choice));\n    }\n    return opts;\n  }\n  private static CalendarFormat format(int choice) {\n    return FORMATS[choice % FORMATS_LEN];\n  }\n  private static CalendarSkeleton skeleton(int choice) {\n    return SKELETONS[choice % SKELETONS_LEN];\n  }\n"]], "pred": {"ppl": 1.6112639904022217, "ppl_lower": 1.8373610973358154, "ppl/lowercase_ppl": -1.275275008519845, "ppl/zlib": 0.0006756642467180794, "Min_5.0% Prob": 5.732043926532452, "Min_10.0% Prob": 3.9341405796099314, "Min_20.0% Prob": 2.2985685808853535, "Min_30.0% Prob": 1.578404127616264, "Min_40.0% Prob": 1.1910282285346834, "Min_50.0% Prob": 0.9541505782300126, "Min_60.0% Prob": 0.7954076026874499}}
{"hexsha": "2861105d837d7c45ed2e603975d65a33155fbc51", "ext": "java", "lang": "Java", "content": "@ObjectHolder(Reference.MOD_ID)\npublic class ModSoundEvents\n{\n    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();\n\n    static\n    {\n        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS)\n        {\n            Instrument instrument = handHeld.getInstrument();\n            if (!SOUNDS.containsKey(instrument.sounds.timbre))\n            {\n                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));\n            }\n        }\n    }\n\n    /**\n     * Register a {@link SoundEvent}.\n     *\n     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound\n     *                  resources. Without the prefix it will reference vanilla sound resources.\n     * @return The SoundEvent\n     */\n    @Nullable\n    private static SoundEvent registerSound(String soundName)\n    {\n        final ResourceLocation soundID = new ResourceLocation(soundName);\n        SoundEvent soundEvent;\n\n        if (soundName.contains(Reference.MOD_DOMAIN))\n            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);\n        else\n            soundEvent = SoundEvent.REGISTRY.getObject(soundID);\n\n        return soundEvent;\n    }\n\n    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)\n    public static class RegistrationHandler\n    {\n        @SubscribeEvent\n        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event)\n        {\n            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));\n        }\n    }\n\n    /**\n     * Get a {@link SoundEvent} by name\n     *\n     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the\n     *                  instruments.json file can be returned. However, in the event a key is not found the default\n     *                  will be the vanilla note block 'pling' sound.\n     * @return The SoundEvent\n     */\n    public static SoundEvent getSound(String soundName) {return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);}\n}", "class_id": 0, "repo": "Aeronica/BardMania", "file": "src/main/java/net/aeronica/mods/bard_mania/server/init/ModSoundEvents.java", "last_update_at": "2021-02-28T19:44:44+00:00", "question_id": "2861105d837d7c45ed2e603975d65a33155fbc51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ObjectHolder(Reference.MOD_ID)\npublic class ModSoundEvents\n{\n    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();\n    static\n    {\n        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS)\n        {\n            Instrument instrument = handHeld.getInstrument();\n            if (!SOUNDS.containsKey(instrument.sounds.timbre))\n            {\n                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));\n            }\n        }\n    }\n    /**\n     * Register a {@link SoundEvent}.\n     *\n     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound\n     *                  resources. Without the prefix it will reference vanilla sound resources.\n     * @return The SoundEvent\n     */\n    @Nullable\n    private static SoundEvent registerSound(String soundName)\n    {\n        final ResourceLocation soundID = new ResourceLocation(soundName);\n        SoundEvent soundEvent;\n        if (soundName.contains(Reference.MOD_DOMAIN))\n            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);\n        else\n            soundEvent = SoundEvent.REGISTRY.getObject(soundID);\n        return soundEvent;\n    }\n    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)\n    public static class RegistrationHandler\n    {\n        @SubscribeEvent\n        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event)\n        {\n            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));\n        }\n    }\n    /**\n     * Get a {@link SoundEvent} by name\n     *\n     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the\n     *                  instruments.json file can be returned. However, in the event a key is not found the default\n     *                  will be the vanilla note block 'pling' sound.\n     * @return The SoundEvent\n     */\n    public static SoundEvent getSound(String soundName) {return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);}\n"]], "pred": {"ppl": 2.2188732624053955, "ppl_lower": 2.98762845993042, "ppl/lowercase_ppl": -1.3732503942491856, "ppl/zlib": 0.0010025151290382543, "Min_5.0% Prob": 7.34870249649574, "Min_10.0% Prob": 5.441796969559233, "Min_20.0% Prob": 3.5521443851855623, "Min_30.0% Prob": 2.5696050625168874, "Min_40.0% Prob": 1.9717319859426563, "Min_50.0% Prob": 1.5925971623823698, "Min_60.0% Prob": 1.327427743001468}}
{"hexsha": "6ae321693fd396814c3cd664d6f460c3b1c7fca7", "ext": "java", "lang": "Java", "content": "public class ChangePasswordRequestValidator implements Validator {\n\n  static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(\n      new LengthRule(8, 30),\n      new CharacterRule(EnglishCharacterData.UpperCase, 1),\n      new CharacterRule(EnglishCharacterData.LowerCase, 1),\n      new CharacterRule(EnglishCharacterData.Digit, 1),\n      new CharacterRule(EnglishCharacterData.Special, 1),\n      new WhitespaceRule()));\n\n  @Override\n  public boolean supports(Class<?> clazz) {\n    return ChangePasswordRequest.class.equals(clazz);\n  }\n\n  @Override\n  public void validate(Object target, Errors e) {\n    ChangePasswordRequest request = (ChangePasswordRequest) target;\n    if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {\n      e.rejectValue(\"newPasswordAgain\", \"password.mismatch\");\n    }\n\n    RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));\n    if (!result.isValid()) {\n      List<String> messages = PASSWORD_VALIDATOR.getMessages(result);\n      String messageTemplate = messages.stream()\n          .collect(Collectors.joining(\",\"));\n      e.rejectValue(\"newPassword\", messageTemplate);\n    }\n  }\n}", "class_id": 0, "repo": "tsvetinakalcheva/air-quality-hackathon-project", "file": "src/main/java/bg/startit/hackathon/airquiality/validation/ChangePasswordRequestValidator.java", "last_update_at": "2021-01-06T18:37:06+00:00", "question_id": "6ae321693fd396814c3cd664d6f460c3b1c7fca7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChangePasswordRequestValidator implements Validator {\n  static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(\n      new LengthRule(8, 30),\n      new CharacterRule(EnglishCharacterData.UpperCase, 1),\n      new CharacterRule(EnglishCharacterData.LowerCase, 1),\n      new CharacterRule(EnglishCharacterData.Digit, 1),\n      new CharacterRule(EnglishCharacterData.Special, 1),\n      new WhitespaceRule()));\n  @Override\n  public boolean supports(Class<?> clazz) {\n    return ChangePasswordRequest.class.equals(clazz);\n  }\n  @Override\n  public void validate(Object target, Errors e) {\n    ChangePasswordRequest request = (ChangePasswordRequest) target;\n    if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {\n      e.rejectValue(\"newPasswordAgain\", \"password.mismatch\");\n    }\n    RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));\n    if (!result.isValid()) {\n      List<String> messages = PASSWORD_VALIDATOR.getMessages(result);\n      String messageTemplate = messages.stream()\n          .collect(Collectors.joining(\",\"));\n      e.rejectValue(\"newPassword\", messageTemplate);\n    }\n  }\n"]], "pred": {"ppl": 1.5548396110534668, "ppl_lower": 2.1426711082458496, "ppl/lowercase_ppl": -1.7265538998906496, "ppl/zlib": 0.0008898637022065008, "Min_5.0% Prob": 5.195654883980751, "Min_10.0% Prob": 3.4832520521048345, "Min_20.0% Prob": 2.06991530799154, "Min_30.0% Prob": 1.4540729536116124, "Min_40.0% Prob": 1.0980396586706611, "Min_50.0% Prob": 0.8838444932637189, "Min_60.0% Prob": 0.7351938567740556}}
{"hexsha": "4cd1cd9c2d1e80e72112eab945a3b2e22ef7b82b", "ext": "java", "lang": "Java", "content": "public class LoginSessionHandler implements MinecraftSessionHandler {\n    private final ServerConnection connection;\n    private boolean informationForwarded;\n\n    public LoginSessionHandler(ServerConnection connection) {\n        this.connection = connection;\n    }\n\n    @Override\n    public void handle(MinecraftPacket packet) {\n        if (packet instanceof EncryptionRequest) {\n            throw new IllegalStateException(\"Backend server is online-mode!\");\n        } else if (packet instanceof LoginPluginMessage) {\n            LoginPluginMessage message = (LoginPluginMessage) packet;\n            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();\n            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(true);\n                response.setId(message.getId());\n                response.setData(createForwardingData(configuration.getForwardingSecret(),\n                        connection.getProxyPlayer().getRemoteAddress().getHostString(),\n                        connection.getProxyPlayer().getProfile()));\n                connection.getMinecraftConnection().write(response);\n                informationForwarded = true;\n            } else {\n                // Don't understand\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(false);\n                response.setId(message.getId());\n                response.setData(Unpooled.EMPTY_BUFFER);\n                connection.getMinecraftConnection().write(response);\n            }\n        } else if (packet instanceof Disconnect) {\n            Disconnect disconnect = (Disconnect) packet;\n            // Do we have an outstanding notification? If so, fulfill it.\n            doNotify(ConnectionRequestResults.forDisconnect(disconnect));\n            connection.disconnect();\n        } else if (packet instanceof SetCompression) {\n            SetCompression sc = (SetCompression) packet;\n            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());\n        } else if (packet instanceof ServerLoginSuccess) {\n            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    !informationForwarded) {\n                doNotify(ConnectionRequestResults.forDisconnect(\n                        TextComponent.of(\"Your server did not send a forwarding request to the proxy. Is it set up correctly?\")));\n                connection.disconnect();\n                return;\n            }\n\n            // The player has been logged on to the backend server.\n            connection.getMinecraftConnection().setState(StateRegistry.PLAY);\n            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();\n            if (existingConnection == null) {\n                // Strap on the play session handler\n                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));\n            } else {\n                // The previous server connection should become obsolete.\n                existingConnection.disconnect();\n            }\n\n            doNotify(ConnectionRequestResults.SUCCESSFUL);\n            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));\n            connection.getProxyPlayer().setConnectedServer(connection);\n        }\n    }\n\n    @Override\n    public void exception(Throwable throwable) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.completeExceptionally(throwable);\n        }\n    }\n\n    private void doNotify(ConnectionRequestBuilder.Result result) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.complete(result);\n        }\n    }\n\n    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {\n        ByteBuf dataToForward = Unpooled.buffer();\n        ByteBuf finalData = Unpooled.buffer();\n        try {\n            ProtocolUtils.writeString(dataToForward, address);\n            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());\n            ProtocolUtils.writeString(dataToForward, profile.getName());\n            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());\n            for (GameProfile.Property property : profile.getProperties()) {\n                ProtocolUtils.writeString(dataToForward, property.getName());\n                ProtocolUtils.writeString(dataToForward, property.getValue());\n                String signature = property.getSignature();\n                if (signature != null) {\n                    dataToForward.writeBoolean(true);\n                    ProtocolUtils.writeString(dataToForward, signature);\n                } else {\n                    dataToForward.writeBoolean(false);\n                }\n            }\n\n            SecretKey key = new SecretKeySpec(hmacSecret, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(key);\n            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());\n            byte[] sig = mac.doFinal();\n            finalData.writeBytes(sig);\n            finalData.writeBytes(dataToForward);\n            return finalData;\n        } catch (InvalidKeyException e) {\n            finalData.release();\n            throw new RuntimeException(\"Unable to authenticate data\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen\n            finalData.release();\n            throw new AssertionError(e);\n        } finally {\n            dataToForward.release();\n        }\n    }\n}", "class_id": 0, "repo": "phase/Velocity", "file": "proxy/src/main/java/com/velocitypowered/proxy/connection/backend/LoginSessionHandler.java", "last_update_at": "2021-09-24T22:44:49+00:00", "question_id": "4cd1cd9c2d1e80e72112eab945a3b2e22ef7b82b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoginSessionHandler implements MinecraftSessionHandler {\n    private final ServerConnection connection;\n    private boolean informationForwarded;\n    public LoginSessionHandler(ServerConnection connection) {\n        this.connection = connection;\n    }\n    @Override\n    public void handle(MinecraftPacket packet) {\n        if (packet instanceof EncryptionRequest) {\n            throw new IllegalStateException(\"Backend server is online-mode!\");\n        } else if (packet instanceof LoginPluginMessage) {\n            LoginPluginMessage message = (LoginPluginMessage) packet;\n            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();\n            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(true);\n                response.setId(message.getId());\n                response.setData(createForwardingData(configuration.getForwardingSecret(),\n                        connection.getProxyPlayer().getRemoteAddress().getHostString(),\n                        connection.getProxyPlayer().getProfile()));\n                connection.getMinecraftConnection().write(response);\n                informationForwarded = true;\n            } else {\n                // Don't understand\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(false);\n                response.setId(message.getId());\n                response.setData(Unpooled.EMPTY_BUFFER);\n                connection.getMinecraftConnection().write(response);\n            }\n        } else if (packet instanceof Disconnect) {\n            Disconnect disconnect = (Disconnect) packet;\n            // Do we have an outstanding notification? If so, fulfill it.\n            doNotify(ConnectionRequestResults.forDisconnect(disconnect));\n            connection.disconnect();\n        } else if (packet instanceof SetCompression) {\n            SetCompression sc = (SetCompression) packet;\n            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());\n        } else if (packet instanceof ServerLoginSuccess) {\n            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    !informationForwarded) {\n                doNotify(ConnectionRequestResults.forDisconnect(\n                        TextComponent.of(\"Your server did not send a forwarding request to the proxy. Is it set up correctly?\")));\n                connection.disconnect();\n                return;\n            }\n            // The player has been logged on to the backend server.\n            connection.getMinecraftConnection().setState(StateRegistry.PLAY);\n            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();\n            if (existingConnection == null) {\n                // Strap on the play session handler\n                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));\n            } else {\n                // The previous server connection should become obsolete.\n                existingConnection.disconnect();\n            }\n            doNotify(ConnectionRequestResults.SUCCESSFUL);\n            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));\n            connection.getProxyPlayer().setConnectedServer(connection);\n        }\n    }\n    @Override\n    public void exception(Throwable throwable) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.completeExceptionally(throwable);\n        }\n    }\n    private void doNotify(ConnectionRequestBuilder.Result result) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.complete(result);\n        }\n    }\n    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {\n        ByteBuf dataToForward = Unpooled.buffer();\n        ByteBuf finalData = Unpooled.buffer();\n        try {\n            ProtocolUtils.writeString(dataToForward, address);\n            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());\n            ProtocolUtils.writeString(dataToForward, profile.getName());\n            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());\n            for (GameProfile.Property property : profile.getProperties()) {\n                ProtocolUtils.writeString(dataToForward, property.getName());\n                ProtocolUtils.writeString(dataToForward, property.getValue());\n                String signature = property.getSignature();\n                if (signature != null) {\n                    dataToForward.writeBoolean(true);\n                    ProtocolUtils.writeString(dataToForward, signature);\n                } else {\n                    dataToForward.writeBoolean(false);\n                }\n            }\n            SecretKey key = new SecretKeySpec(hmacSecret, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(key);\n            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());\n            byte[] sig = mac.doFinal();\n            finalData.writeBytes(sig);\n            finalData.writeBytes(dataToForward);\n            return finalData;\n        } catch (InvalidKeyException e) {\n            finalData.release();\n            throw new RuntimeException(\"Unable to authenticate data\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen\n            finalData.release();\n            throw new AssertionError(e);\n        } finally {\n            dataToForward.release();\n        }\n    }\n"]], "pred": {"ppl": 1.9322782754898071, "ppl_lower": 2.490050792694092, "ppl/lowercase_ppl": -1.3850059827786918, "ppl/zlib": 0.00039776555576745393, "Min_5.0% Prob": 6.386443825329051, "Min_10.0% Prob": 4.591072779075772, "Min_20.0% Prob": 2.9881344948913537, "Min_30.0% Prob": 2.1463910687008716, "Min_40.0% Prob": 1.6373298021903249, "Min_50.0% Prob": 1.3164828140179239, "Min_60.0% Prob": 1.0987484766539568}}
{"hexsha": "e221bba277ec3b7366089248282c8d030b848dd5", "ext": "java", "lang": "Java", "content": "public class GtidSet {\n\n    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();\n\n    /**\n     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).\n     */\n    public GtidSet(String gtidSet) {\n        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(\",\");\n        for (String uuidSet : uuidSets) {\n            int uuidSeparatorIndex = uuidSet.indexOf(\":\");\n            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);\n            List<Interval> intervals = new ArrayList<Interval>();\n            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(\":\");\n            for (String interval : rawIntervals) {\n                String[] is = interval.split(\"-\");\n                long[] split = new long[is.length];\n                for (int i = 0, e = is.length; i < e; i++) {\n                    split[i] = Long.parseLong(is[i]);\n                }\n                if (split.length == 1) {\n                    split = new long[] {split[0], split[0]};\n                }\n                intervals.add(new Interval(split[0], split[1]));\n            }\n            map.put(sourceId, new UUIDSet(sourceId, intervals));\n        }\n    }\n\n    public Collection<UUIDSet> getUUIDSets() {\n        return map.values();\n    }\n\n    /**\n     * @param gtid GTID (\"source_id:transaction_id\")\n     * @return whether or not gtid was added to the set (false if it was already there)\n     */\n    public boolean add(String gtid) {\n        String[] split = gtid.split(\":\");\n        String sourceId = split[0];\n        long transactionId = Long.parseLong(split[1]);\n        UUIDSet uuidSet = map.get(sourceId);\n        if (uuidSet == null) {\n            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));\n        }\n        List<Interval> intervals = (List<Interval>) uuidSet.intervals;\n        int index = findInterval(intervals, transactionId);\n        boolean addedToExisting = false;\n        if (index < intervals.size()) {\n            Interval interval = intervals.get(index);\n            if (interval.start == transactionId + 1) {\n                interval.start = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.end + 1 == transactionId) {\n                interval.end = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.start <= transactionId && transactionId <= interval.end) {\n                return false;\n            }\n        }\n        if (!addedToExisting) {\n            intervals.add(index, new Interval(transactionId, transactionId));\n        }\n        if (intervals.size() > 1) {\n            joinAdjacentIntervals(intervals, index);\n        }\n        return true;\n    }\n\n    /**\n     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).\n     */\n    private void joinAdjacentIntervals(List<Interval> intervals, int index) {\n        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {\n            Interval a = intervals.get(i - 1), b = intervals.get(i);\n            if (a.end + 1 == b.start) {\n                a.end = b.end;\n                intervals.remove(i);\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        List<String> gtids = new ArrayList<String>();\n        for (UUIDSet uuidSet : map.values()) {\n            gtids.add(uuidSet.getUUID() + \":\" + join(uuidSet.intervals, \":\"));\n        }\n        return join(gtids, \",\");\n    }\n\n    /**\n     * @return index which is either a pointer to the interval containing v or a position at which v can be added\n     */\n    private static int findInterval(List<Interval> ii, long v) {\n        int l = 0, p = 0, r = ii.size();\n        while (l < r) {\n            p = (l + r) / 2;\n            Interval i = ii.get(p);\n            if (i.end < v) {\n                l = p + 1;\n            } else\n            if (v < i.start) {\n                r = p;\n            } else {\n                return p;\n            }\n        }\n        if (!ii.isEmpty() && ii.get(p).end < v) {\n            p++;\n        }\n        return p;\n    }\n\n    private String join(Collection o, String delimiter) {\n        if (o.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Object o1 : o) {\n            sb.append(o1).append(delimiter);\n        }\n        return sb.substring(0, sb.length() - delimiter.length());\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class UUIDSet {\n\n        private String uuid;\n        private Collection<Interval> intervals;\n\n        private UUIDSet(String uuid, Collection<Interval> intervals) {\n            this.uuid = uuid;\n            this.intervals = intervals;\n        }\n\n        public String getUUID() {\n            return uuid;\n        }\n\n        public Collection<Interval> getIntervals() {\n            return intervals;\n        }\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class Interval implements Comparable<Interval> {\n\n        private long start;\n        private long end;\n\n        private Interval(long start, long end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        public long getStart() {\n            return start;\n        }\n\n        public long getEnd() {\n            return end;\n        }\n\n        @Override\n        public String toString() {\n            return start + \"-\" + end;\n        }\n\n        @Override\n        public int compareTo(Interval o) {\n            return saturatedCast(this.start - o.start);\n        }\n\n        private static int saturatedCast(long value) {\n            if (value > Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n            if (value < Integer.MIN_VALUE) {\n                return Integer.MIN_VALUE;\n            }\n            return (int) value;\n        }\n    }\n\n}", "class_id": 0, "repo": "rong360/cdc", "file": "src/main/java/com/github/shyiko/mysql/binlog/GtidSet.java", "last_update_at": "2021-07-20T01:41:18+00:00", "question_id": "e221bba277ec3b7366089248282c8d030b848dd5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GtidSet {\n    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();\n    /**\n     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).\n     */\n    public GtidSet(String gtidSet) {\n        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(\",\");\n        for (String uuidSet : uuidSets) {\n            int uuidSeparatorIndex = uuidSet.indexOf(\":\");\n            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);\n            List<Interval> intervals = new ArrayList<Interval>();\n            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(\":\");\n            for (String interval : rawIntervals) {\n                String[] is = interval.split(\"-\");\n                long[] split = new long[is.length];\n                for (int i = 0, e = is.length; i < e; i++) {\n                    split[i] = Long.parseLong(is[i]);\n                }\n                if (split.length == 1) {\n                    split = new long[] {split[0], split[0]};\n                }\n                intervals.add(new Interval(split[0], split[1]));\n            }\n            map.put(sourceId, new UUIDSet(sourceId, intervals));\n        }\n    }\n    public Collection<UUIDSet> getUUIDSets() {\n        return map.values();\n    }\n    /**\n     * @param gtid GTID (\"source_id:transaction_id\")\n     * @return whether or not gtid was added to the set (false if it was already there)\n     */\n    public boolean add(String gtid) {\n        String[] split = gtid.split(\":\");\n        String sourceId = split[0];\n        long transactionId = Long.parseLong(split[1]);\n        UUIDSet uuidSet = map.get(sourceId);\n        if (uuidSet == null) {\n            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));\n        }\n        List<Interval> intervals = (List<Interval>) uuidSet.intervals;\n        int index = findInterval(intervals, transactionId);\n        boolean addedToExisting = false;\n        if (index < intervals.size()) {\n            Interval interval = intervals.get(index);\n            if (interval.start == transactionId + 1) {\n                interval.start = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.end + 1 == transactionId) {\n                interval.end = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.start <= transactionId && transactionId <= interval.end) {\n                return false;\n            }\n        }\n        if (!addedToExisting) {\n            intervals.add(index, new Interval(transactionId, transactionId));\n        }\n        if (intervals.size() > 1) {\n            joinAdjacentIntervals(intervals, index);\n        }\n        return true;\n    }\n    /**\n     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).\n     */\n    private void joinAdjacentIntervals(List<Interval> intervals, int index) {\n        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {\n            Interval a = intervals.get(i - 1), b = intervals.get(i);\n            if (a.end + 1 == b.start) {\n                a.end = b.end;\n                intervals.remove(i);\n            }\n        }\n    }\n    @Override\n    public String toString() {\n        List<String> gtids = new ArrayList<String>();\n        for (UUIDSet uuidSet : map.values()) {\n            gtids.add(uuidSet.getUUID() + \":\" + join(uuidSet.intervals, \":\"));\n        }\n        return join(gtids, \",\");\n    }\n    /**\n     * @return index which is either a pointer to the interval containing v or a position at which v can be added\n     */\n    private static int findInterval(List<Interval> ii, long v) {\n        int l = 0, p = 0, r = ii.size();\n        while (l < r) {\n            p = (l + r) / 2;\n            Interval i = ii.get(p);\n            if (i.end < v) {\n                l = p + 1;\n            } else\n            if (v < i.start) {\n                r = p;\n            } else {\n                return p;\n            }\n        }\n        if (!ii.isEmpty() && ii.get(p).end < v) {\n            p++;\n        }\n        return p;\n    }\n    private String join(Collection o, String delimiter) {\n        if (o.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Object o1 : o) {\n            sb.append(o1).append(delimiter);\n        }\n        return sb.substring(0, sb.length() - delimiter.length());\n    }\n    /**\n     * @see GtidSet\n     */\n    public static final class UUIDSet {\n        private String uuid;\n        private Collection<Interval> intervals;\n        private UUIDSet(String uuid, Collection<Interval> intervals) {\n            this.uuid = uuid;\n            this.intervals = intervals;\n        }\n        public String getUUID() {\n            return uuid;\n        }\n        public Collection<Interval> getIntervals() {\n            return intervals;\n        }\n    }\n    /**\n     * @see GtidSet\n     */\n    public static final class Interval implements Comparable<Interval> {\n        private long start;\n        private long end;\n        private Interval(long start, long end) {\n            this.start = start;\n            this.end = end;\n        }\n        public long getStart() {\n            return start;\n        }\n        public long getEnd() {\n            return end;\n        }\n        @Override\n        public String toString() {\n            return start + \"-\" + end;\n        }\n        @Override\n        public int compareTo(Interval o) {\n            return saturatedCast(this.start - o.start);\n        }\n        private static int saturatedCast(long value) {\n            if (value > Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n            if (value < Integer.MIN_VALUE) {\n                return Integer.MIN_VALUE;\n            }\n            return (int) value;\n        }\n    }\n"]], "pred": {"ppl": 1.6639286279678345, "ppl_lower": 1.7729148864746094, "ppl/lowercase_ppl": -1.124599140404989, "ppl/zlib": 0.00031314972302145264, "Min_5.0% Prob": 5.623673906513289, "Min_10.0% Prob": 3.9926456785669515, "Min_20.0% Prob": 2.4220000991926476, "Min_30.0% Prob": 1.6757980893834743, "Min_40.0% Prob": 1.267001054192777, "Min_50.0% Prob": 1.0174303529929887, "Min_60.0% Prob": 0.8491711908112756}}
{"hexsha": "76a729674dee4fe36c1fccda5f23c96fd9c3eae6", "ext": "java", "lang": "Java", "content": "public class ECSTaskTemplateTest {\n\n    @Test\n    public void shouldMerge() throws Exception {\n\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n\n\n        ECSTaskTemplate result = child.merge(parent);\n\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnSettingsFromParent() throws Exception {\n\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, null, \"child-repository-credentials\", \"EC2\", \"child-network-mode\",  \"child-remoteFSRoot\", // image is set to null\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"parent-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate result = child.merge(parent);\n\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnChildIfNoParent() throws Exception {\n\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null); // inheritFrom is null\n\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate result = child.merge(null);\n\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n}", "class_id": 0, "repo": "kdvy/amazon-ecs-plugin", "file": "src/test/java/com/cloudbees/jenkins/plugins/amazonecs/ECSTaskTemplateTest.java", "last_update_at": "2021-04-11T06:11:28+00:00", "question_id": "76a729674dee4fe36c1fccda5f23c96fd9c3eae6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ECSTaskTemplateTest {\n    @Test\n    public void shouldMerge() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n    @Test\n    public void shouldReturnSettingsFromParent() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, null, \"child-repository-credentials\", \"EC2\", \"child-network-mode\",  \"child-remoteFSRoot\", // image is set to null\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"parent-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n    @Test\n    public void shouldReturnChildIfNoParent() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null); // inheritFrom is null\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(null);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n"]], "pred": {"ppl": 1.357432246208191, "ppl_lower": 1.439523696899414, "ppl/lowercase_ppl": -1.1921414247467919, "ppl/zlib": 0.000688276713667059, "Min_5.0% Prob": 4.542686090469361, "Min_10.0% Prob": 2.7965096217393874, "Min_20.0% Prob": 1.5055191935226322, "Min_30.0% Prob": 1.0137843368233492, "Min_40.0% Prob": 0.762619308566209, "Min_50.0% Prob": 0.6107579791331663, "Min_60.0% Prob": 0.5091849530288406}}
{"hexsha": "21acef61c95ebaa70ee8aa8170419592df0fc1f2", "ext": "java", "lang": "Java", "content": "public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {\n\n    private HttpServletResponse response;\n    private MessageBodyWriter<Object> wrapped;\n\n    @SuppressWarnings(\"unchecked\") //\n    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {\n        this.response = response;\n        this.wrapped = (MessageBodyWriter<Object>) writer;\n    }\n\n    @Override //\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.isWriteable(type, genericType, annotations, mediaType);\n    }\n\n    @Override //\n    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.getSize(entity, type, genericType, annotations, mediaType);\n    }\n\n    @Override //\n    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType,\n            MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n\n        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\n            throws IOException, WebApplicationException {\n\n        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    private static class HeadersWriterOutputStream extends FilterOutputStream {\n\n        private static final Http HTTP = new Http();\n\n        private boolean done;\n        private HttpServletResponse response;\n        private MultivaluedMap<String, Object> httpHeaders;\n\n        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {\n            super(out);\n            this.response = response;\n            this.httpHeaders = httpHeaders;\n        }\n\n        private void writeHeaders() {\n            if (done) {\n                return;\n            }\n            done = true;\n            if (httpHeaders == null) {\n                return;\n            }\n            HTTP.writeHeaders(response, httpHeaders);\n        }\n\n        @Override //\n        public void write(int b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        @Override //\n        public void write(byte[] b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        @Override //\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeHeaders();\n            super.write(b, off, len);\n        }\n\n        @Override //\n        public void flush() throws IOException {\n            writeHeaders();\n            super.flush();\n        }\n\n        @Override //\n        public void close() throws IOException {\n            writeHeaders();\n            super.close();\n        }\n    }\n}", "class_id": 0, "repo": "Gmugra/net.cactusthorn.routing", "file": "core/src/main/java/net/cactusthorn/routing/body/writer/MessageBodyHeadersWriter.java", "last_update_at": "2021-08-30T09:07:33+00:00", "question_id": "21acef61c95ebaa70ee8aa8170419592df0fc1f2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {\n    private HttpServletResponse response;\n    private MessageBodyWriter<Object> wrapped;\n    @SuppressWarnings(\"unchecked\") //\n    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {\n        this.response = response;\n        this.wrapped = (MessageBodyWriter<Object>) writer;\n    }\n    @Override //\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.isWriteable(type, genericType, annotations, mediaType);\n    }\n    @Override //\n    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.getSize(entity, type, genericType, annotations, mediaType);\n    }\n    @Override //\n    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType,\n            MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\n            throws IOException, WebApplicationException {\n        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n    private static class HeadersWriterOutputStream extends FilterOutputStream {\n        private static final Http HTTP = new Http();\n        private boolean done;\n        private HttpServletResponse response;\n        private MultivaluedMap<String, Object> httpHeaders;\n        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {\n            super(out);\n            this.response = response;\n            this.httpHeaders = httpHeaders;\n        }\n        private void writeHeaders() {\n            if (done) {\n                return;\n            }\n            done = true;\n            if (httpHeaders == null) {\n                return;\n            }\n            HTTP.writeHeaders(response, httpHeaders);\n        }\n        @Override //\n        public void write(int b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n        @Override //\n        public void write(byte[] b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n        @Override //\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeHeaders();\n            super.write(b, off, len);\n        }\n        @Override //\n        public void flush() throws IOException {\n            writeHeaders();\n            super.flush();\n        }\n        @Override //\n        public void close() throws IOException {\n            writeHeaders();\n            super.close();\n        }\n    }\n"]], "pred": {"ppl": 1.3699655532836914, "ppl_lower": 1.4821993112564087, "ppl/lowercase_ppl": -1.250142989195857, "ppl/zlib": 0.0004496937084791169, "Min_5.0% Prob": 4.575421352135508, "Min_10.0% Prob": 2.780858312782488, "Min_20.0% Prob": 1.532447261833831, "Min_30.0% Prob": 1.041753035716778, "Min_40.0% Prob": 0.7852358174047702, "Min_50.0% Prob": 0.6290266234856589, "Min_60.0% Prob": 0.5244743019988833}}
{"hexsha": "94049e169d9faa662dadee598b08f54cfa434623", "ext": "java", "lang": "Java", "content": "public class FilesTest {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\t// \u83b7\u53d6\u5de5\u4f5c\u76ee\u5f55\r\n\t\tString workDir = System.getProperty(\"user.dir\");\r\n\t\t// \u83b7\u53d6\u7c7b\u540d\r\n\t\tString className = Thread.currentThread().getStackTrace()[1]\r\n\t\t\t\t.getClassName();\r\n\t\t// \u7c7b\u7684\u8def\u5f84\r\n\t\tString classPath = workDir + \"\\\\src\\\\main\\\\java\\\\\" + className;\r\n\t\t// \u53cd\u659c\u6760\u66ff\u6362\u6389\".\"\r\n\t\tString currentClass = classPath.replace(\".\", \"\\\\\") + \".java\";\r\n\r\n\t\t// \u590d\u5236\u6587\u4ef6\uff0c\u628acurrentClass\u5185\u5bb9\u590d\u5236\u5230files.txt\r\n\t\tFiles.copy(Paths.get(currentClass), new FileOutputStream(\r\n\t\t\t\t\"testFile\\\\files.txt\"));\r\n\t\t// \u5224\u8bfbFilesTest.java\u662f\u5426\u4e3a\u9690\u85cf\u6587\u4ef6\r\n\t\tSystem.out.println(Files.isHidden(Paths.get(currentClass)));\r\n\t\t// \u4e00\u6b21\u6027\u8bfb\u53d6FilesTest.java\u6587\u4ef6\u7684\u6240\u6709\u884c\r\n\t\tList<String> lines = Files.readAllLines(Paths.get(currentClass),\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\tSystem.out.println(lines);\r\n\t\t// \u83b7\u53d6\u6307\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\r\n\t\tSystem.out.println(\"FilesTest.java\u6587\u4ef6\u5927\u5c0f\uff1a\"\r\n\t\t\t\t+ Files.size(Paths.get(currentClass)));\r\n\t\tList<String> poem = new ArrayList<String>();\r\n\t\tpoem.add(\"\u5e74\u5e74\u5fc6\u4eca\u671d\");\r\n\t\tpoem.add(\"\u832b\u832b\u8d76\u56fd\u8003\");\r\n\t\t// \u5c06\u591a\u4e2a\u5b57\u7b26\u4e32\u5185\u5bb9\u5199\u5165\u6307\u5b9a\u6587\u4ef6files.txt\u4e2d\r\n\t\tFiles.write(Paths.get(\"testFile\\\\files.txt\"), poem,\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\t// \u5224\u65adC\u76d8\u7684\u603b\u7a7a\u95f4\u548c\u53ef\u7528\u7a7a\u95f4\r\n\t\tFileStore cStore = Files.getFileStore(Paths.get(currentClass));\r\n\t\tSystem.out.println(\"C\u76d8\u5171\u6709\u7a7a\u95f4\uff1a\" + cStore.getTotalSpace());\r\n\t\tSystem.out.println(\"C\u76d8\u7684\u53ef\u7528\u7a7a\u95f4\uff1a\" + cStore.getUsableSpace());\r\n\t}\r\n}", "class_id": 0, "repo": "longjiazuo/j2se-project", "file": "j2se-project/java-nio/src/main/java/org/light4j/nio/nio2/FilesTest.java", "last_update_at": "2021-03-01T09:19:06+00:00", "question_id": "94049e169d9faa662dadee598b08f54cfa434623", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FilesTest {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\t// \u83b7\u53d6\u5de5\u4f5c\u76ee\u5f55\r\n\t\tString workDir = System.getProperty(\"user.dir\");\r\n\t\t// \u83b7\u53d6\u7c7b\u540d\r\n\t\tString className = Thread.currentThread().getStackTrace()[1]\r\n\t\t\t\t.getClassName();\r\n\t\t// \u7c7b\u7684\u8def\u5f84\r\n\t\tString classPath = workDir + \"\\\\src\\\\main\\\\java\\\\\" + className;\r\n\t\t// \u53cd\u659c\u6760\u66ff\u6362\u6389\".\"\r\n\t\tString currentClass = classPath.replace(\".\", \"\\\\\") + \".java\";\r\n\r\n\t\t// \u590d\u5236\u6587\u4ef6\uff0c\u628acurrentClass\u5185\u5bb9\u590d\u5236\u5230files.txt\r\n\t\tFiles.copy(Paths.get(currentClass), new FileOutputStream(\r\n\t\t\t\t\"testFile\\\\files.txt\"));\r\n\t\t// \u5224\u8bfbFilesTest.java\u662f\u5426\u4e3a\u9690\u85cf\u6587\u4ef6\r\n\t\tSystem.out.println(Files.isHidden(Paths.get(currentClass)));\r\n\t\t// \u4e00\u6b21\u6027\u8bfb\u53d6FilesTest.java\u6587\u4ef6\u7684\u6240\u6709\u884c\r\n\t\tList<String> lines = Files.readAllLines(Paths.get(currentClass),\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\tSystem.out.println(lines);\r\n\t\t// \u83b7\u53d6\u6307\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\r\n\t\tSystem.out.println(\"FilesTest.java\u6587\u4ef6\u5927\u5c0f\uff1a\"\r\n\t\t\t\t+ Files.size(Paths.get(currentClass)));\r\n\t\tList<String> poem = new ArrayList<String>();\r\n\t\tpoem.add(\"\u5e74\u5e74\u5fc6\u4eca\u671d\");\r\n\t\tpoem.add(\"\u832b\u832b\u8d76\u56fd\u8003\");\r\n\t\t// \u5c06\u591a\u4e2a\u5b57\u7b26\u4e32\u5185\u5bb9\u5199\u5165\u6307\u5b9a\u6587\u4ef6files.txt\u4e2d\r\n\t\tFiles.write(Paths.get(\"testFile\\\\files.txt\"), poem,\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\t// \u5224\u65adC\u76d8\u7684\u603b\u7a7a\u95f4\u548c\u53ef\u7528\u7a7a\u95f4\r\n\t\tFileStore cStore = Files.getFileStore(Paths.get(currentClass));\r\n\t\tSystem.out.println(\"C\u76d8\u5171\u6709\u7a7a\u95f4\uff1a\" + cStore.getTotalSpace());\r\n\t\tSystem.out.println(\"C\u76d8\u7684\u53ef\u7528\u7a7a\u95f4\uff1a\" + cStore.getUsableSpace());\r\n\t}\r\n"]], "pred": {"ppl": 2.029067277908325, "ppl_lower": 2.3863720893859863, "ppl/lowercase_ppl": -1.2292304853762597, "ppl/zlib": 0.0009083135025093563, "Min_5.0% Prob": 6.320056835810344, "Min_10.0% Prob": 4.86834572182327, "Min_20.0% Prob": 3.201126216872921, "Min_30.0% Prob": 2.3074126598303732, "Min_40.0% Prob": 1.757303223316747, "Min_50.0% Prob": 1.4114681485399314, "Min_60.0% Prob": 1.180346506468568}}
{"hexsha": "d435c5d4df7f64a11710b7026aabff7141738bd6", "ext": "java", "lang": "Java", "content": "public class Check implements Report {\n    public static Boolean check() {\n        File epubFile = new File(\"D:\\\\play\\\\epub\\\\public\\\\epub\\\\epub3.0\\\\q.epub\");\n\n        // simple constructor; errors are printed on stderr stream\n        EpubCheck epubcheck = new EpubCheck(epubFile);\n\n        // validate() returns true if no errors or warnings are found\n        Boolean result = epubcheck.validate();\n        return result;\n    }\n\n    @Override\n    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {\n\n    }\n\n    @Override\n    public void message(Message message, EPUBLocation epubLocation, Object... objects) {\n\n    }\n\n    @Override\n    public void info(String s, FeatureEnum featureEnum, String s2) {\n\n    }\n\n    @Override\n    public int getErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int getWarningCount() {\n        return 0;\n    }\n\n    @Override\n    public int getFatalErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int generate() {\n        return 0;\n    }\n\n    @Override\n    public void initialize() {\n\n    }\n\n    @Override\n    public void setEpubFileName(String s) {\n\n    }\n\n    @Override\n    public String getEpubFileName() {\n        return null;\n    }\n\n    @Override\n    public void setCustomMessageFile(String s) {\n\n    }\n\n    @Override\n    public String getCustomMessageFile() {\n        return null;\n    }\n\n    @Override\n    public int getReportingLevel() {\n        return 0;\n    }\n\n    @Override\n    public void setReportingLevel(int i) {\n\n    }\n\n    @Override\n    public void close() {\n\n    }\n\n    @Override\n    public void setOverrideFile(File file) {\n\n    }\n\n    @Override\n    public MessageDictionary getDictionary() {\n        return null;\n    }\n}", "class_id": 0, "repo": "seaalan/epub", "file": "app/controllers/EPUBCheck/Check.java", "last_update_at": "2021-05-08T11:24:20+00:00", "question_id": "d435c5d4df7f64a11710b7026aabff7141738bd6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Check implements Report {\n    public static Boolean check() {\n        File epubFile = new File(\"D:\\\\play\\\\epub\\\\public\\\\epub\\\\epub3.0\\\\q.epub\");\n        // simple constructor; errors are printed on stderr stream\n        EpubCheck epubcheck = new EpubCheck(epubFile);\n        // validate() returns true if no errors or warnings are found\n        Boolean result = epubcheck.validate();\n        return result;\n    }\n    @Override\n    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {\n    }\n    @Override\n    public void message(Message message, EPUBLocation epubLocation, Object... objects) {\n    }\n    @Override\n    public void info(String s, FeatureEnum featureEnum, String s2) {\n    }\n    @Override\n    public int getErrorCount() {\n        return 0;\n    }\n    @Override\n    public int getWarningCount() {\n        return 0;\n    }\n    @Override\n    public int getFatalErrorCount() {\n        return 0;\n    }\n    @Override\n    public int generate() {\n        return 0;\n    }\n    @Override\n    public void initialize() {\n    }\n    @Override\n    public void setEpubFileName(String s) {\n    }\n    @Override\n    public String getEpubFileName() {\n        return null;\n    }\n    @Override\n    public void setCustomMessageFile(String s) {\n    }\n    @Override\n    public String getCustomMessageFile() {\n        return null;\n    }\n    @Override\n    public int getReportingLevel() {\n        return 0;\n    }\n    @Override\n    public void setReportingLevel(int i) {\n    }\n    @Override\n    public void close() {\n    }\n    @Override\n    public void setOverrideFile(File file) {\n    }\n    @Override\n    public MessageDictionary getDictionary() {\n        return null;\n    }\n"]], "pred": {"ppl": 2.1819865703582764, "ppl_lower": 2.4300029277801514, "ppl/lowercase_ppl": -1.13797974771186, "ppl/zlib": 0.0015923178217395447, "Min_5.0% Prob": 7.513702888488769, "Min_10.0% Prob": 5.63428939557543, "Min_20.0% Prob": 3.6340591720506255, "Min_30.0% Prob": 2.5656458394589765, "Min_40.0% Prob": 1.9471962086710275, "Min_50.0% Prob": 1.5619953707554468, "Min_60.0% Prob": 1.302615046485942}}
{"hexsha": "d4b842cf649bd0cd1ede7fa0da8285f1b5d69bd0", "ext": "java", "lang": "Java", "content": "public final class SeaSlater64RNG implements RandomnessSource, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private long stateA, stateB;\n\n    /**\n     * Creates a new generator seeded using two calls to Math.random().\n     */\n    public SeaSlater64RNG() {\n        setState((long) ((Math.random() - 0.5) * 0x10000000000000L)\n                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),\n                (long) ((Math.random() - 0.5) * 0x10000000000000L)\n                        ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));\n    }\n    /**\n     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for\n     * the two parts of state this has with {@link #setSeed(long)}.\n     * @param seed a long that will be used to generate both components of state\n     */\n    public SeaSlater64RNG(final long seed) {\n        setSeed(seed);\n    }\n    /**\n     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that\n     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).\n     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0\n     * @param stateB the number to use as the second part of the state\n     */\n    public SeaSlater64RNG(final long stateA, final long stateB) {\n        setState(stateA, stateB);\n    }\n    \n    @Override\n    public final int next(int bits) {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));\n    }\n\n    /**\n     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.\n     * @return any int, all 32 bits are random\n     */\n    public final int nextInt() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);\n    }\n\n    @Override\n    public final long nextLong() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (result << 12) - (result << 9 | result >>> 55);\n    }\n\n    /**\n     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the\n     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to\n     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.\n     *\n     * @return a copy of this RandomnessSource\n     */\n    @Override\n    public SeaSlater64RNG copy() {\n        return new SeaSlater64RNG(stateA, stateB);\n    }\n\n    /**\n     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get \n     * two longs. If the states would both be 0, state A is assigned 1 instead.\n     * @param seed the long to use to produce this generator's state\n     */\n    public void setSeed(final long seed) {\n        long z = seed;\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateA = z ^ (z >>> 31);\n        z = (seed + 0x9E3779B97F4A7C15L);\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateB = z ^ (z >>> 31);\n        // not possible with SplitMix64\n//        if((stateA | stateB) == 0)\n//            stateA = 1;\n    }\n\n    public long getStateA()\n    {\n        return stateA;\n    }\n    /**\n     * Sets the first part of the state to the given int. As a special case, if the parameter is 0 and stateB is\n     * already 0, this will set stateA to 1 instead, since both states cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateA any int\n     */\n\n    public void setStateA(long stateA)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n    }\n    public long getStateB()\n    {\n        return stateB;\n    }\n\n    /**\n     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is\n     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateB any int\n     */\n    public void setStateB(long stateB)\n    {\n        this.stateB = stateB;\n        if((stateB | stateA) == 0) stateA = 1;\n    }\n\n    /**\n     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any\n     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).\n     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)\n     * @param stateB any int\n     */\n    public void setState(long stateA, long stateB)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n        this.stateB = stateB;\n    }\n    \n    @Override\n    public String toString() {\n        return \"SeaSlater32RNG with stateA 0x\" + StringKit.hex(stateA) + \"L and stateB 0x\" + StringKit.hex(stateB) + 'L';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;\n\n        if (stateA != seaSlater64RNG.stateA) return false;\n        return stateB == seaSlater64RNG.stateB;\n    }\n\n    @Override\n    public int hashCode() {\n        final long h = (31L * stateA + stateB);\n        return (int)(h ^ h >>> 32);\n    }\n}", "class_id": 0, "repo": "Solido/sarong", "file": "src/main/java/sarong/SeaSlater64RNG.java", "last_update_at": "2021-07-24T14:10:33+00:00", "question_id": "d4b842cf649bd0cd1ede7fa0da8285f1b5d69bd0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SeaSlater64RNG implements RandomnessSource, Serializable {\n    private static final long serialVersionUID = 1L;\n    private long stateA, stateB;\n    /**\n     * Creates a new generator seeded using two calls to Math.random().\n     */\n    public SeaSlater64RNG() {\n        setState((long) ((Math.random() - 0.5) * 0x10000000000000L)\n                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),\n                (long) ((Math.random() - 0.5) * 0x10000000000000L)\n                        ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));\n    }\n    /**\n     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for\n     * the two parts of state this has with {@link #setSeed(long)}.\n     * @param seed a long that will be used to generate both components of state\n     */\n    public SeaSlater64RNG(final long seed) {\n        setSeed(seed);\n    }\n    /**\n     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that\n     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).\n     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0\n     * @param stateB the number to use as the second part of the state\n     */\n    public SeaSlater64RNG(final long stateA, final long stateB) {\n        setState(stateA, stateB);\n    }\n    @Override\n    public final int next(int bits) {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));\n    }\n    /**\n     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.\n     * @return any int, all 32 bits are random\n     */\n    public final int nextInt() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);\n    }\n    @Override\n    public final long nextLong() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (result << 12) - (result << 9 | result >>> 55);\n    }\n    /**\n     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the\n     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to\n     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.\n     *\n     * @return a copy of this RandomnessSource\n     */\n    @Override\n    public SeaSlater64RNG copy() {\n        return new SeaSlater64RNG(stateA, stateB);\n    }\n    /**\n     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get \n     * two longs. If the states would both be 0, state A is assigned 1 instead.\n     * @param seed the long to use to produce this generator's state\n     */\n    public void setSeed(final long seed) {\n        long z = seed;\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateA = z ^ (z >>> 31);\n        z = (seed + 0x9E3779B97F4A7C15L);\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateB = z ^ (z >>> 31);\n        // not possible with SplitMix64\n//        if((stateA | stateB) == 0)\n//            stateA = 1;\n    }\n    public long getStateA()\n    {\n        return stateA;\n    }\n    /**\n     * Sets the first part of the state to the given int. As a special case, if the parameter is 0 and stateB is\n     * already 0, this will set stateA to 1 instead, since both states cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateA any int\n     */\n    public void setStateA(long stateA)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n    }\n    public long getStateB()\n    {\n        return stateB;\n    }\n    /**\n     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is\n     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateB any int\n     */\n    public void setStateB(long stateB)\n    {\n        this.stateB = stateB;\n        if((stateB | stateA) == 0) stateA = 1;\n    }\n    /**\n     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any\n     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).\n     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)\n     * @param stateB any int\n     */\n    public void setState(long stateA, long stateB)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n        this.stateB = stateB;\n    }\n    @Override\n    public String toString() {\n        return \"SeaSlater32RNG with stateA 0x\" + StringKit.hex(stateA) + \"L and stateB 0x\" + StringKit.hex(stateB) + 'L';\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;\n        if (stateA != seaSlater64RNG.stateA) return false;\n        return stateB == seaSlater64RNG.stateB;\n    }\n    @Override\n    public int hashCode() {\n        final long h = (31L * stateA + stateB);\n        return (int)(h ^ h >>> 32);\n    }\n"]], "pred": {"ppl": 2.0158214569091797, "ppl_lower": 2.093914270401001, "ppl/lowercase_ppl": -1.0542181678087466, "ppl/zlib": 0.0003881654392281855, "Min_5.0% Prob": 6.514777305079441, "Min_10.0% Prob": 4.868470816051259, "Min_20.0% Prob": 3.2045940172438527, "Min_30.0% Prob": 2.288109183360159, "Min_40.0% Prob": 1.7422786228140146, "Min_50.0% Prob": 1.4005153150135494, "Min_60.0% Prob": 1.1690729180446615}}
{"hexsha": "4f01c8a8bfaf6520ab50b8203cdbd576b2539387", "ext": "java", "lang": "Java", "content": "@TypeCapability(inputs = { \"de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS\" })\npublic class POSTokenRatio\nextends FeatureExtractorResource_ImplBase\nimplements FeatureExtractor\n{\n\tpublic static final String FN_NounRatio = \"NounRatio\";\n\tpublic static final String FN_VerbRatio = \"VerbRatio\";\n\tpublic static final String FN_AdjectivRatio = \"AdjectivRatio\";\n\t\n\n\t@Override\n\tpublic Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget)\n\t\t\tthrows TextClassificationException\n\t{\n\t\t\n\t\tint numberOfTokens = JCasUtil.select(jcas, POS.class).size();\n\t\t\n\t\t//Nouns, Verbs\n\t\tint numberOfNouns = 0;\n\t\tint numberOfVerbs = 0;\n\t\tint numberOfAdjectives = 0;\n\t\t\n\t\tfor (POS pos : JCasUtil.select(jcas, POS.class)) {\n\t\t\tSystem.out.println(pos.getCoarseValue());\n\t\t\tif (pos.getCoarseValue().startsWith(\"N\")){\n\t\t\t\tnumberOfNouns++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"VERB\")){\n\t\t\t\tnumberOfVerbs++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"ADJ\")){\n\t\t\t\tnumberOfAdjectives++;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tdouble nr = (1.0*numberOfNouns)/numberOfTokens;\n\t\tdouble vr = (1.0*numberOfVerbs)/numberOfTokens;\n\t\tdouble ar = (1.0*numberOfAdjectives)/numberOfTokens;\n\n\t\t\n\t\tSet<Feature> features = new HashSet<Feature>();\n\t\tfeatures.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));\n\t\treturn features;\n\t}\n\n}", "class_id": 0, "repo": "ltl-ude/escrito", "file": "de.unidue.ltl.escrito/de.unidue.ltl.escrito.features/src/main/java/de/unidue/ltl/escrito/features/complexity/POSTokenRatio.java", "last_update_at": "2021-04-17T16:57:54+00:00", "question_id": "4f01c8a8bfaf6520ab50b8203cdbd576b2539387", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TypeCapability(inputs = { \"de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS\" })\npublic class POSTokenRatio\nextends FeatureExtractorResource_ImplBase\nimplements FeatureExtractor\n{\n\tpublic static final String FN_NounRatio = \"NounRatio\";\n\tpublic static final String FN_VerbRatio = \"VerbRatio\";\n\tpublic static final String FN_AdjectivRatio = \"AdjectivRatio\";\n\t\n\t@Override\n\tpublic Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget)\n\t\t\tthrows TextClassificationException\n\t{\n\t\t\n\t\tint numberOfTokens = JCasUtil.select(jcas, POS.class).size();\n\t\t\n\t\t//Nouns, Verbs\n\t\tint numberOfNouns = 0;\n\t\tint numberOfVerbs = 0;\n\t\tint numberOfAdjectives = 0;\n\t\t\n\t\tfor (POS pos : JCasUtil.select(jcas, POS.class)) {\n\t\t\tSystem.out.println(pos.getCoarseValue());\n\t\t\tif (pos.getCoarseValue().startsWith(\"N\")){\n\t\t\t\tnumberOfNouns++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"VERB\")){\n\t\t\t\tnumberOfVerbs++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"ADJ\")){\n\t\t\t\tnumberOfAdjectives++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble nr = (1.0*numberOfNouns)/numberOfTokens;\n\t\tdouble vr = (1.0*numberOfVerbs)/numberOfTokens;\n\t\tdouble ar = (1.0*numberOfAdjectives)/numberOfTokens;\n\t\t\n\t\tSet<Feature> features = new HashSet<Feature>();\n\t\tfeatures.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));\n\t\treturn features;\n\t}\n"]], "pred": {"ppl": 1.4640560150146484, "ppl_lower": 1.9778459072113037, "ppl/lowercase_ppl": -1.7890588302072177, "ppl/zlib": 0.0006699660394186121, "Min_5.0% Prob": 4.7313679004537645, "Min_10.0% Prob": 3.2390963849374805, "Min_20.0% Prob": 1.8577081533306736, "Min_30.0% Prob": 1.2642400206650717, "Min_40.0% Prob": 0.9500291700109462, "Min_50.0% Prob": 0.7625270678482421, "Min_60.0% Prob": 0.636448274680715}}
{"hexsha": "0b6a14048aa7baf6a73dc2a1cc1f8a4284ce3354", "ext": "java", "lang": "Java", "content": "@TestPropertySource(\"classpath:testFm.properties\")\npublic class DgFmTest extends AbstractWebTest {\n\n    @Autowired\n    private DgFmService fmService;\n\n    @Test\n    public void testFmInit() {\n        assertTrue(\"Must have at least one feature\", fmService.featuresCount() > 0);\n    }\n\n    @Test\n    public void testBasics() {\n        assertThatFeature(\"defaults\", allOf(visible(), enabled(), not(mandatory())));\n        assertThatFeature(\"allEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"allDisabled\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"reverseDefaults\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testMixins() {\n        assertThatFeature(\"allDisabledMixin\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"mandatoryWithAllDisabledMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mandatoryWithAllDisabledChainedMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mixingInAllEnabled\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testVisibleDeps() {\n        assertThatFeature(\"visibleDepsAllDisabled\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllDisabledChained\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllEnabled\", allOf(not(visible()), enabled(), not(mandatory())));\n    }\n\n    @Test\n    public void testMandatoryDeps() {\n        assertThatFeature(\"mandatoryDepsAllDisabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabledChained\", allOf(visible(), enabled(), mandatory()));\n    }\n\n    @Test\n    public void testEnabledDeps() {\n        assertThatFeature(\"enabledDepsAllDisabled\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllDisabledChained\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllEnabled\", allOf(visible(), not(enabled()), not(mandatory())));\n    }\n\n    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {\n        assertThat(fmService.getFeature(featureName), matcher);\n    }\n\n    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {\n        assertEquals(fmService.isFeatureVisible(featureName), visible);\n        assertEquals(fmService.isFeatureEnabled(featureName), enabled);\n        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);\n    }\n\n    private Matcher<DgFeature> visible() {\n        return describedAs(\"visible\", hasProperty(\"visible\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> mandatory() {\n        return describedAs(\"mandatory\", hasProperty(\"mandatory\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> enabled() {\n        return describedAs(\"enabled\", hasProperty(\"enabled\", equalTo(true)));\n    }\n}", "class_id": 0, "repo": "devgateway/ocportal", "file": "web/src/test/java/org/devgateway/toolkit/web/fm/DgFmTest.java", "last_update_at": "2021-11-06T19:24:23+00:00", "question_id": "0b6a14048aa7baf6a73dc2a1cc1f8a4284ce3354", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TestPropertySource(\"classpath:testFm.properties\")\npublic class DgFmTest extends AbstractWebTest {\n    @Autowired\n    private DgFmService fmService;\n    @Test\n    public void testFmInit() {\n        assertTrue(\"Must have at least one feature\", fmService.featuresCount() > 0);\n    }\n    @Test\n    public void testBasics() {\n        assertThatFeature(\"defaults\", allOf(visible(), enabled(), not(mandatory())));\n        assertThatFeature(\"allEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"allDisabled\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"reverseDefaults\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n    @Test\n    public void testMixins() {\n        assertThatFeature(\"allDisabledMixin\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"mandatoryWithAllDisabledMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mandatoryWithAllDisabledChainedMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mixingInAllEnabled\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n    @Test\n    public void testVisibleDeps() {\n        assertThatFeature(\"visibleDepsAllDisabled\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllDisabledChained\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllEnabled\", allOf(not(visible()), enabled(), not(mandatory())));\n    }\n    @Test\n    public void testMandatoryDeps() {\n        assertThatFeature(\"mandatoryDepsAllDisabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabledChained\", allOf(visible(), enabled(), mandatory()));\n    }\n    @Test\n    public void testEnabledDeps() {\n        assertThatFeature(\"enabledDepsAllDisabled\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllDisabledChained\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllEnabled\", allOf(visible(), not(enabled()), not(mandatory())));\n    }\n    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {\n        assertThat(fmService.getFeature(featureName), matcher);\n    }\n    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {\n        assertEquals(fmService.isFeatureVisible(featureName), visible);\n        assertEquals(fmService.isFeatureEnabled(featureName), enabled);\n        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);\n    }\n    private Matcher<DgFeature> visible() {\n        return describedAs(\"visible\", hasProperty(\"visible\", equalTo(true)));\n    }\n    private Matcher<DgFeature> mandatory() {\n        return describedAs(\"mandatory\", hasProperty(\"mandatory\", equalTo(true)));\n    }\n    private Matcher<DgFeature> enabled() {\n        return describedAs(\"enabled\", hasProperty(\"enabled\", equalTo(true)));\n    }\n"]], "pred": {"ppl": 1.6216906309127808, "ppl_lower": 1.7739280462265015, "ppl/lowercase_ppl": -1.185590142366658, "ppl/zlib": 0.0008004457026522434, "Min_5.0% Prob": 6.02713409135508, "Min_10.0% Prob": 4.020902348660875, "Min_20.0% Prob": 2.3208135119506292, "Min_30.0% Prob": 1.5943868406711876, "Min_40.0% Prob": 1.205638186321554, "Min_50.0% Prob": 0.9666850747793048, "Min_60.0% Prob": 0.8060579897139568}}
{"hexsha": "65080318e0435ec7c0c7d4789c2b76ffc5799d38", "ext": "java", "lang": "Java", "content": "public class CSSRule {\n    private Set<String> selectors;\n    private Map<String, String> properties;\n\n    public CSSRule() {\n        this.selectors = new HashSet<>();\n        this.properties = new HashMap<>();\n    }\n\n    public CSSRule(Set<String> selectors, Map<String, String> properties) {\n        this.selectors = selectors;\n        this.properties = properties;\n    }\n\n    public static List<CSSRule> fromString(String text) {\n        List<CSSRule> rep = new ArrayList<>();\n\n        text = text.replaceAll(\"\\\\s+\", \"\");\n\n        String[] declarations = text.split(\"}\");\n\n        for (String declaration : declarations) {\n            Set<String> selectors = new HashSet<>();\n            Map<String, String> properties = new HashMap<>();\n            CSSRule current = new CSSRule(selectors, properties);\n\n            String[] strings = declaration.split(\"\\\\{\");\n            \n            if(strings.length < 2) {\n                continue;\n            }\n\n            String[] selectorsStr = strings[0].split(\",\");\n            String[] propertiesStr = strings[1].split(\";\");\n\n            selectors.addAll(Arrays.asList(selectorsStr));\n\n            for (String property : propertiesStr) {\n                String[] parts = property.split(\":\");\n                properties.put(parts[0], parts[1]);\n            }\n\n            rep.add(current);\n        }\n        return rep;\n    }\n\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    public boolean hasStyle(String style) {\n        return hasProperty(style);\n    }\n\n    public String getPropertyValue(String name) {\n        return properties.get(name);\n    }\n\n    public void setProperty(String name, String value) {\n        properties.put(name, value);\n    }\n\n    public Set<String> getSelectors() {\n        return selectors;\n    }\n\n    public void addSelector(String selector) {\n        this.selectors.add(selector);\n    }\n\n    public boolean hasSelector(String selector) {\n        return selectors.contains(selector);\n    }\n\n    public boolean hasClass(String clazz) {\n        return selectors.contains(\".\" + clazz);\n    }\n\n    public String toString(int indent) {\n        StringBuilder rep = new StringBuilder();\n        rep.append(spaces(indent)).append(String.join(\", \", selectors)).append(\" {\").append(\"\\n\");\n        for (Map.Entry<String, String> entry : properties.entrySet()) {\n            rep.append(spaces(indent + 2)).append(entry.getKey()).append(\": \").append(entry.getValue()).append(\";\\n\");\n        }\n        rep.append(spaces(indent)).append(\"}\\n\");\n        return rep.toString();\n    }\n\n    @Override\n    public String toString() {\n        return toString(0);\n    }\n\n    @Override\n    public CSSRule clone() {\n        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));\n    }\n}", "class_id": 0, "repo": "Feavy/Fea-XML-CSS-Parser", "file": "src/main/java/fr/feavy/xml/CSSRule.java", "last_update_at": "2021-04-20T20:07:40+00:00", "question_id": "65080318e0435ec7c0c7d4789c2b76ffc5799d38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CSSRule {\n    private Set<String> selectors;\n    private Map<String, String> properties;\n    public CSSRule() {\n        this.selectors = new HashSet<>();\n        this.properties = new HashMap<>();\n    }\n    public CSSRule(Set<String> selectors, Map<String, String> properties) {\n        this.selectors = selectors;\n        this.properties = properties;\n    }\n    public static List<CSSRule> fromString(String text) {\n        List<CSSRule> rep = new ArrayList<>();\n        text = text.replaceAll(\"\\\\s+\", \"\");\n        String[] declarations = text.split(\"}\");\n        for (String declaration : declarations) {\n            Set<String> selectors = new HashSet<>();\n            Map<String, String> properties = new HashMap<>();\n            CSSRule current = new CSSRule(selectors, properties);\n            String[] strings = declaration.split(\"\\\\{\");\n            if(strings.length < 2) {\n                continue;\n            }\n            String[] selectorsStr = strings[0].split(\",\");\n            String[] propertiesStr = strings[1].split(\";\");\n            selectors.addAll(Arrays.asList(selectorsStr));\n            for (String property : propertiesStr) {\n                String[] parts = property.split(\":\");\n                properties.put(parts[0], parts[1]);\n            }\n            rep.add(current);\n        }\n        return rep;\n    }\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n    public boolean hasStyle(String style) {\n        return hasProperty(style);\n    }\n    public String getPropertyValue(String name) {\n        return properties.get(name);\n    }\n    public void setProperty(String name, String value) {\n        properties.put(name, value);\n    }\n    public Set<String> getSelectors() {\n        return selectors;\n    }\n    public void addSelector(String selector) {\n        this.selectors.add(selector);\n    }\n    public boolean hasSelector(String selector) {\n        return selectors.contains(selector);\n    }\n    public boolean hasClass(String clazz) {\n        return selectors.contains(\".\" + clazz);\n    }\n    public String toString(int indent) {\n        StringBuilder rep = new StringBuilder();\n        rep.append(spaces(indent)).append(String.join(\", \", selectors)).append(\" {\").append(\"\\n\");\n        for (Map.Entry<String, String> entry : properties.entrySet()) {\n            rep.append(spaces(indent + 2)).append(entry.getKey()).append(\": \").append(entry.getValue()).append(\";\\n\");\n        }\n        rep.append(spaces(indent)).append(\"}\\n\");\n        return rep.toString();\n    }\n    @Override\n    public String toString() {\n        return toString(0);\n    }\n    @Override\n    public CSSRule clone() {\n        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));\n    }\n"]], "pred": {"ppl": 1.4387905597686768, "ppl_lower": 1.5432929992675781, "ppl/lowercase_ppl": -1.1927295756512208, "ppl/zlib": 0.00046942306017284805, "Min_5.0% Prob": 4.27369106732882, "Min_10.0% Prob": 2.8952685181911173, "Min_20.0% Prob": 1.7261928614133444, "Min_30.0% Prob": 1.193022350517985, "Min_40.0% Prob": 0.9044417844941983, "Min_50.0% Prob": 0.7264111069819101, "Min_60.0% Prob": 0.6063891977716523}}
{"hexsha": "60326de5da5cf57c599ba2b10b06462f073332a3", "ext": "java", "lang": "Java", "content": "public class APIResponse {\n    private String responseMessage;\n    private int responseCode;\n    private String body;\n\n    APIResponse(int responseCode, String responseMessage, String body) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.body = body;\n    }\n\n    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {\n        final int responseCode = conn.getResponseCode();\n        final String responseMessage = conn.getResponseMessage();\n\n        String body;\n\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            body = read(conn.getInputStream());\n        } else {\n            body = read(conn.getErrorStream());\n        }\n\n        return new APIResponse(responseCode, responseMessage, body);\n    }\n\n    public String getResponseMessage() {\n        return responseMessage;\n    }\n\n    public int getResponseCode() {\n        return responseCode;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public boolean isOK() {\n        return responseCode == HttpURLConnection.HTTP_OK;\n    }\n\n    public boolean isNotFound() {\n        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;\n    }\n\n    public boolean isError() {\n        return !isOK();\n    }\n\n    /**\n     * Read an input stream to a String.\n     *\n     * @param is The input stream.\n     * @return The data from the input stream as a String.\n     */\n    private static String read(InputStream is) {\n        if (is == null){\n            return \"\";\n        }\n        Scanner scanner = new Scanner(is);\n\n        StringBuilder sb = new StringBuilder();\n\n        while (scanner.hasNextLine()) {\n            sb.append(scanner.nextLine());\n        }\n\n        return sb.toString();\n    }\n\n}", "class_id": 0, "repo": "dalelane/ML4K-AI-Extension", "file": "src/com/kylecorry/ml4k/APIResponse.java", "last_update_at": "2021-12-05T13:30:19+00:00", "question_id": "60326de5da5cf57c599ba2b10b06462f073332a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class APIResponse {\n    private String responseMessage;\n    private int responseCode;\n    private String body;\n    APIResponse(int responseCode, String responseMessage, String body) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.body = body;\n    }\n    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {\n        final int responseCode = conn.getResponseCode();\n        final String responseMessage = conn.getResponseMessage();\n        String body;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            body = read(conn.getInputStream());\n        } else {\n            body = read(conn.getErrorStream());\n        }\n        return new APIResponse(responseCode, responseMessage, body);\n    }\n    public String getResponseMessage() {\n        return responseMessage;\n    }\n    public int getResponseCode() {\n        return responseCode;\n    }\n    public String getBody() {\n        return body;\n    }\n    public boolean isOK() {\n        return responseCode == HttpURLConnection.HTTP_OK;\n    }\n    public boolean isNotFound() {\n        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;\n    }\n    public boolean isError() {\n        return !isOK();\n    }\n    /**\n     * Read an input stream to a String.\n     *\n     * @param is The input stream.\n     * @return The data from the input stream as a String.\n     */\n    private static String read(InputStream is) {\n        if (is == null){\n            return \"\";\n        }\n        Scanner scanner = new Scanner(is);\n        StringBuilder sb = new StringBuilder();\n        while (scanner.hasNextLine()) {\n            sb.append(scanner.nextLine());\n        }\n        return sb.toString();\n    }\n"]], "pred": {"ppl": 1.4312289953231812, "ppl_lower": 1.6003555059432983, "ppl/lowercase_ppl": -1.311525364974636, "ppl/zlib": 0.0006664191681338168, "Min_5.0% Prob": 3.9752901684154165, "Min_10.0% Prob": 2.7719369888305665, "Min_20.0% Prob": 1.7145018332534365, "Min_30.0% Prob": 1.180616513141157, "Min_40.0% Prob": 0.8951270162174221, "Min_50.0% Prob": 0.7159547399409476, "Min_60.0% Prob": 0.5980797294563244}}
{"hexsha": "c100f09e24353bbe744b998aaca1669e27678b45", "ext": "java", "lang": "Java", "content": "public class exercicio5 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.print(\"Ol\u00e1! Por favor informe qual o valor do seu sal\u00e1rio: R$ \");\n        Double salario = scanner.nextDouble();\n\n        final Double salarioMinimo = 788.0;\n\n        Double quantidadeSalariosMinimos = salario/salarioMinimo;\n\n       /* System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + Math.round(quantidadeSalariosMinimos)); ESSE FORMATO IR\u00c1 ARREDONDAR O VALOR. */\n        \n        DecimalFormat df = new DecimalFormat(\"##.##\");\n\n        System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + df.format(quantidadeSalariosMinimos));\n\n        scanner.close();\n    }\n}", "class_id": 0, "repo": "jpshimidt/Estudojava", "file": "ListaExercicios/ListaExercicios/src/exercicio5.java", "last_update_at": "2021-04-03T04:11:55+00:00", "question_id": "c100f09e24353bbe744b998aaca1669e27678b45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class exercicio5 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Ol\u00e1! Por favor informe qual o valor do seu sal\u00e1rio: R$ \");\n        Double salario = scanner.nextDouble();\n        final Double salarioMinimo = 788.0;\n        Double quantidadeSalariosMinimos = salario/salarioMinimo;\n       /* System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + Math.round(quantidadeSalariosMinimos)); ESSE FORMATO IR\u00c1 ARREDONDAR O VALOR. */\n        DecimalFormat df = new DecimalFormat(\"##.##\");\n        System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + df.format(quantidadeSalariosMinimos));\n        scanner.close();\n    }\n"]], "pred": {"ppl": 2.367335796356201, "ppl_lower": 2.953474283218384, "ppl/lowercase_ppl": -1.2567021942350856, "ppl/zlib": 0.0023805668129089964, "Min_5.0% Prob": 7.334336497566917, "Min_10.0% Prob": 5.28983770717274, "Min_20.0% Prob": 3.5966886932199653, "Min_30.0% Prob": 2.7261279297597483, "Min_40.0% Prob": 2.1168095278605987, "Min_50.0% Prob": 1.7175446764842883, "Min_60.0% Prob": 1.4404659261997033}}
{"hexsha": "225847a731ab9bc895536af2abea87cf195f916c", "ext": "java", "lang": "Java", "content": "@DynamicSerialize\npublic class FFMPBasinData {\n\n    public static final double GUIDANCE_MISSING = -999999.0;\n\n    // defaults\n    @DynamicSerializeElement\n    private String hucLevel;\n\n    @DynamicSerializeElement\n    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();\n\n    /**\n     * Pending load tasks that need to be run to fully populate basins\n     */\n    private final List<LoadTask> tasks = new ArrayList<LoadTask>();\n\n    /**\n     * Cache of basins in order for easy population from Load Tasks.\n     */\n    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();\n\n    /**\n     * Shared factory for efficient storage of data in basins.\n     */\n    private BasinMapFactory<Date> mapFactory = null;\n\n    /**\n     * Public one arg constructor\n     * \n     * @param huc_level\n     */\n    public FFMPBasinData(String hucLevel) {\n        setHucLevel(hucLevel);\n    }\n\n    /**\n     * No arg hibernate constructor\n     */\n    public FFMPBasinData() {\n\n    }\n\n    /**\n     * get the basin map\n     * \n     * @return\n     */\n    public Map<Long, FFMPBasin> getBasins() {\n        if (!tasks.isEmpty()) {\n            loadNow();\n        }\n        return basins;\n    }\n\n    /**\n     * Sets the basin map\n     * \n     * @param basins\n     */\n    public void setBasins(Map<Long, FFMPBasin> basins) {\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n        this.basins = basins;\n    }\n\n    /**\n     * Gets the HUC Level for this map\n     * \n     * @return\n     */\n    public String getHucLevel() {\n        return hucLevel;\n    }\n\n    /**\n     * Sets the HUC Level for this map\n     */\n    public void setHucLevel(String hucLevel) {\n        this.hucLevel = hucLevel;\n    }\n\n    /**\n     * Add to the hash\n     * \n     * @param key\n     * @param basin\n     */\n    public void put(Long key, FFMPBasin basin) {\n        getBasins().put(key, basin);\n    }\n\n    /**\n     * Gets the FFMPBasin from the hash\n     * \n     * @param key\n     * @return\n     */\n    public FFMPBasin get(Long key) {\n        return getBasins().get(key);\n    }\n\n    /**\n     * Gets a list of pfaf ids from the keys\n     * \n     * @return\n     */\n    public List<Long> getPfafIds() {\n        return new ArrayList<Long>(getBasins().keySet());\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param startDate\n     * @param finishDate\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(beforeDate, afterDate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param exact\n     *            date\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(date);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expirationTime\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date,\n            long epirationTime) {\n\n        float tvalue = 0.0f;\n        int i = 0;\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = getBasins().get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAverageValue(date, epirationTime);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins with areal\n     * weighting\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids,\n            ArrayList<Double> areas) {\n\n        float tvalue = 0.0f;\n        float tarea = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                if (basin.getValue() != FFMPUtils.MISSING) {\n                    tvalue += (basin.getValue() * areas.get(i));\n                    tarea += areas.get(i);\n                }\n            }\n        }\n\n        if (tvalue < 0.0f) {\n            tvalue = FFMPUtils.MISSING;\n        } else {\n            tvalue = tvalue / tarea;\n        }\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins to a given time\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a range of times in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(beforeDate, afterDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(List<Long> pfaf_ids, Date date,\n            long expiration) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(date, expiration);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate,\n            Date beforeDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(afterDate, beforeDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a specific time in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(List<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(date);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Average Guidance\n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, float guidance,\n            List<Long> forcedPfafs, long expiration) {\n        float tvalue = 0.0f;\n        float value;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n\n            if (basin == null) {\n                return guidance;\n            }\n\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (forcedPfafs.contains(pfaf)) {\n                    if (interpolation.isInterpolate()) {\n                        value = fgb.getInterpolatedValue(interpolation,\n                                expiration);\n                    } else {\n                        value = fgb.getValue(interpolation.getStandardSource(),\n                                interpolation, expiration);\n                    }\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    tvalue += value;\n                    i++;\n                } else {\n                    if (interpolation.isInterpolate()) {\n                        float nvalue;\n                        if (new Float(guidance).isNaN()) {\n                            nvalue = fgb.getInterpolatedValue(interpolation,\n                                    expiration);\n                        } else {\n                            nvalue = guidance;\n                        }\n\n                        if (nvalue > 0.0f) {\n                            tvalue += nvalue;\n                        }\n                        i++;\n                    } else {\n                        if (new Float(guidance).isNaN()) {\n                            value = fgb.getValue(\n                                    interpolation.getStandardSource(),\n                                    interpolation, expiration);\n                        } else {\n                            value = guidance;\n                        }\n                        if (value > 0.0f) {\n                            tvalue += value;\n                        }\n                        i++;\n                    }\n                }\n            }\n        }\n\n        if (tvalue == 0.0f) {\n            return Float.NaN;\n        }\n\n        return tvalue / i;\n    }\n\n    /**\n     * Extracts the Max value for a guidance aggregation of basins THIS IS\n     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse\n     * \n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getMaxGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration,\n            long parentPfaf) {\n        float tvalue = Float.NaN;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                fgb.setCountyFips(parentPfaf);\n                if (interpolation.isInterpolate()) {\n                    float nvalue = fgb.getInterpolatedValue(interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (nvalue < -999) {\n                        continue;\n                    }\n                    if (((nvalue < tvalue) && (nvalue > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = nvalue;\n                    }\n                } else {\n                    float value = fgb.getValue(\n                            interpolation.getStandardSource(), interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    if (((value < tvalue) && (value > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = value;\n                    }\n                }\n            }\n        }\n\n        if (tvalue == 0.0f) {\n            tvalue = Float.NaN;\n        }\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Accumulated Max value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @return\n     */\n    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n\n                float val = basin.getAccumValue(afterDate, beforeDate,\n                        expirationTime, rate);\n\n                if (val > tvalue) {\n                    tvalue = val;\n                }\n            }\n        }\n\n        return tvalue;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @return\n     */\n    public List<Float> getGuidanceValues(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (interpolation.isInterpolate()) {\n                    values.add(fgb.getInterpolatedValue(interpolation,\n                            expiration));\n                } else {\n                    values.add(fgb.getValue(interpolation.getStandardSource(),\n                            interpolation, expiration));\n                }\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Gets the average guidance value for an aggregate basin\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @param expiration\n     * @return\n     */\n    public Float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n\n        float tvalue = 0.0f;\n        int i = 0;\n\n        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation,\n                expiration);\n        if (vals != null) {\n            for (Float val : vals) {\n                tvalue += val;\n                i++;\n            }\n        } else {\n            return null;\n        }\n\n        return tvalue / i;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @param rate\n     * @return\n     */\n    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                values.add(basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate));\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Purge out old data\n     * \n     * @param date\n     */\n    public void purgeData(Date date) {\n        // remove old tasks before calling getBasins() since that may\n        // cause them to run\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                Iterator<LoadTask> itr = tasks.iterator();\n                {\n                    while (itr.hasNext()) {\n                        LoadTask task = itr.next();\n                        if (task instanceof LoadMapTask) {\n                            LoadMapTask mtask = (LoadMapTask) task;\n                            if (mtask.date.before(date)) {\n                                itr.remove();\n                            }\n                        }\n                    }\n                }\n                if (tasks.isEmpty()) {\n                    orderedBasinsCache.clear();\n                }\n            }\n        }\n        for (FFMPBasin basin : basins.values()) {\n            basin.purgeData(date);\n        }\n    }\n\n    /**\n     * deserialize data from the aggregate record\n     * \n     * @param times\n     */\n    public void populate(List<Long> times) {\n        if (mapFactory == null) {\n            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(),\n                    getBasins().size());\n        }\n\n        long[] timesArr = new long[times.size()];\n        for (int i = 0; i < timesArr.length; i += 1) {\n            timesArr[i] = times.get(i);\n        }\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.deserialize(timesArr, mapFactory);\n        }\n    }\n\n    /**\n     * populates the serialized array/objects\n     */\n    public void serialize() {\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.serialize();\n        }\n    }\n\n    /**\n     * Add basins some basins from a datastoreFile. The basins will not be\n     * loaded immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param siteKey\n     *            - siteKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param huc\n     *            - huc to load\n     * @param sourceName\n     *            - the sourceName for the data.\n     * @param date\n     *            - the date of the data.\n     * @param orderedPfafs\n     *            - a collection of Longs which is in the same order as the data\n     *            in the dataStore.\n     * @param aggregate\n     */\n    public void addBasins(File datastoreFile, String uri, String siteKey,\n            String cwa, String huc, String sourceName, Date date,\n            Collection<Long> orderedPfafs, boolean aggregate) {\n        SourceXML source = FFMPSourceConfigurationManager.getInstance()\n                .getSource(sourceName);\n        boolean guidance = source.getSourceType().equals(\n                SOURCE_TYPE.GUIDANCE.getSourceType());\n        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + huc;\n\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedPfafs.size()];\n                int j = 0;\n                for (Long pfaf : orderedPfafs) {\n                    FFMPBasin basin = this.basins.get(pfaf);\n                    if (basin == null) {\n                        if (guidance) {\n                            basin = new FFMPGuidanceBasin(pfaf, aggregate);\n                        } else {\n                            if (mapFactory == null) {\n                                mapFactory = new BasinMapFactory<Date>(\n                                        Collections.reverseOrder(),\n                                        orderedPfafs.size());\n                            }\n                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);\n                        }\n                        this.basins.put(pfaf, basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            if (guidance) {\n                tasks.add(new LoadGuidanceMapTask(datastoreFile,\n                        datasetGroupPath, basins, date, sourceName));\n            } else {\n                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath,\n                        basins, date));\n            }\n        }\n    }\n\n    /**\n     * Add virtual basins from a datastoreFile. The basins will not be loaded\n     * immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param dataKey\n     *            - dataKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param date\n     *            - the date of the data.\n     * @param orderedMetadata\n     *            - a collection of FFMPVirtualGageBasinMetaData which is in the\n     *            same order as the data in the dataStore.\n     */\n    public void addVirtualBasins(File datastoreFile, String uri,\n            String dataKey, String cwa, Date date,\n            Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {\n        String basinsKey = dataKey + ' ' + cwa;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedMetadata.size()];\n                int j = 0;\n                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {\n                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());\n                    if (basin == null) {\n                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(),\n                                fvgbmd.getParentPfaf(), false);\n                        this.basins.put(fvgbmd.getLookupId(), basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath,\n                    basins, date));\n        }\n    }\n\n    /**\n     * Returns whether or not any basins have been put in the basins map. Faster\n     * than calling getBasins().size() or getBasins().isEmpty().\n     * \n     * @return\n     */\n    public boolean hasAnyBasins() {\n        return !basins.isEmpty();\n    }\n\n    /**\n     * Load now.\n     */\n    public void loadNow() {\n        synchronized (tasks) {\n            if (!tasks.isEmpty()) {\n                FFMPDataRecordLoader.loadRecords(tasks);\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n    }\n\n    /**\n     * Base task for loading data from a dataRecord into FFMPBasins\n     */\n    private class LoadMapTask extends LoadTask {\n\n        protected final FFMPBasin[] basins;\n\n        protected final Date date;\n\n        public LoadMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath);\n            this.basins = basins;\n            this.date = date;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void process(FloatDataRecord record) {\n            float[] values = record.getFloatData();\n            for (int j = 0; j < values.length; j += 1) {\n                applyValue(basins[j], values[j]);\n            }\n        }\n\n        /**\n         * Apply the value to the basin/\n         */\n        protected void applyValue(FFMPBasin basin, float value) {\n            if (basin.contains(date)) {\n                float curval = basin.getValue(date);\n                // These are QPF and QPE so, 0.0 is a valid amount\n                if (curval >= 0.0f && value >= 0.0f) {\n                    basin.setValue(date, (curval + value) / 2);\n                } else if (value >= 0.0f) {\n                    basin.setValue(date, value);\n                } \n                // do not overwrite original value\n            } else {\n                // no value at time exists, write regardless\n                basin.setValue(date, value);\n            }\n        }\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPGuidanceBasins\n     */\n    private class LoadGuidanceMapTask extends LoadMapTask {\n\n        private final String sourceName;\n\n        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date, String sourceName) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n            this.sourceName = sourceName;\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            \n            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;\n            Float curval = gBasin.getValue(date, sourceName);\n\n            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {\n                // average of original and new value\n                if (curval > 0.0f && value > 0.0f) {\n                    gBasin.setValue(sourceName, date, (curval + value) / 2);\n                } else {\n                    // curval zero, overwrite original value \n                    if (curval == 0.0f) {\n                        gBasin.setValue(sourceName, date, value);\n                    }\n                }\n            } else {\n                // curval NaN or MISSING, Overwrite original value \n                gBasin.setValue(sourceName, date, value);\n            }\n        }\n\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPVirtualGageBasins\n     */\n    private class LoadVirtualMapTask extends LoadMapTask {\n\n        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            basin.setValue(date, value);\n        }\n\n    }\n\n}", "class_id": 0, "repo": "srcarter3/awips2", "file": "edexOsgi/com.raytheon.uf.common.dataplugin.ffmp/src/com/raytheon/uf/common/dataplugin/ffmp/FFMPBasinData.java", "last_update_at": "2021-10-30T00:03:05+00:00", "question_id": "225847a731ab9bc895536af2abea87cf195f916c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@DynamicSerialize\npublic class FFMPBasinData {\n    public static final double GUIDANCE_MISSING = -999999.0;\n    // defaults\n    @DynamicSerializeElement\n    private String hucLevel;\n    @DynamicSerializeElement\n    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();\n    /**\n     * Pending load tasks that need to be run to fully populate basins\n     */\n    private final List<LoadTask> tasks = new ArrayList<LoadTask>();\n    /**\n     * Cache of basins in order for easy population from Load Tasks.\n     */\n    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();\n    /**\n     * Shared factory for efficient storage of data in basins.\n     */\n    private BasinMapFactory<Date> mapFactory = null;\n    /**\n     * Public one arg constructor\n     * \n     * @param huc_level\n     */\n    public FFMPBasinData(String hucLevel) {\n        setHucLevel(hucLevel);\n    }\n    /**\n     * No arg hibernate constructor\n     */\n    public FFMPBasinData() {\n    }\n    /**\n     * get the basin map\n     * \n     * @return\n     */\n    public Map<Long, FFMPBasin> getBasins() {\n        if (!tasks.isEmpty()) {\n            loadNow();\n        }\n        return basins;\n    }\n    /**\n     * Sets the basin map\n     * \n     * @param basins\n     */\n    public void setBasins(Map<Long, FFMPBasin> basins) {\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n        this.basins = basins;\n    }\n    /**\n     * Gets the HUC Level for this map\n     * \n     * @return\n     */\n    public String getHucLevel() {\n        return hucLevel;\n    }\n    /**\n     * Sets the HUC Level for this map\n     */\n    public void setHucLevel(String hucLevel) {\n        this.hucLevel = hucLevel;\n    }\n    /**\n     * Add to the hash\n     * \n     * @param key\n     * @param basin\n     */\n    public void put(Long key, FFMPBasin basin) {\n        getBasins().put(key, basin);\n    }\n    /**\n     * Gets the FFMPBasin from the hash\n     * \n     * @param key\n     * @return\n     */\n    public FFMPBasin get(Long key) {\n        return getBasins().get(key);\n    }\n    /**\n     * Gets a list of pfaf ids from the keys\n     * \n     * @return\n     */\n    public List<Long> getPfafIds() {\n        return new ArrayList<Long>(getBasins().keySet());\n    }\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param startDate\n     * @param finishDate\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(beforeDate, afterDate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param exact\n     *            date\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(date);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expirationTime\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date,\n            long epirationTime) {\n        float tvalue = 0.0f;\n        int i = 0;\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = getBasins().get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAverageValue(date, epirationTime);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins with areal\n     * weighting\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids,\n            ArrayList<Double> areas) {\n        float tvalue = 0.0f;\n        float tarea = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                if (basin.getValue() != FFMPUtils.MISSING) {\n                    tvalue += (basin.getValue() * areas.get(i));\n                    tarea += areas.get(i);\n                }\n            }\n        }\n        if (tvalue < 0.0f) {\n            tvalue = FFMPUtils.MISSING;\n        } else {\n            tvalue = tvalue / tarea;\n        }\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins to a given time\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the Max value for a range of times in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(beforeDate, afterDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(List<Long> pfaf_ids, Date date,\n            long expiration) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(date, expiration);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate,\n            Date beforeDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(afterDate, beforeDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Extracts the Max value for a specific time in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(List<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(date);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Average Guidance\n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, float guidance,\n            List<Long> forcedPfafs, long expiration) {\n        float tvalue = 0.0f;\n        float value;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin == null) {\n                return guidance;\n            }\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (forcedPfafs.contains(pfaf)) {\n                    if (interpolation.isInterpolate()) {\n                        value = fgb.getInterpolatedValue(interpolation,\n                                expiration);\n                    } else {\n                        value = fgb.getValue(interpolation.getStandardSource(),\n                                interpolation, expiration);\n                    }\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    tvalue += value;\n                    i++;\n                } else {\n                    if (interpolation.isInterpolate()) {\n                        float nvalue;\n                        if (new Float(guidance).isNaN()) {\n                            nvalue = fgb.getInterpolatedValue(interpolation,\n                                    expiration);\n                        } else {\n                            nvalue = guidance;\n                        }\n                        if (nvalue > 0.0f) {\n                            tvalue += nvalue;\n                        }\n                        i++;\n                    } else {\n                        if (new Float(guidance).isNaN()) {\n                            value = fgb.getValue(\n                                    interpolation.getStandardSource(),\n                                    interpolation, expiration);\n                        } else {\n                            value = guidance;\n                        }\n                        if (value > 0.0f) {\n                            tvalue += value;\n                        }\n                        i++;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            return Float.NaN;\n        }\n        return tvalue / i;\n    }\n    /**\n     * Extracts the Max value for a guidance aggregation of basins THIS IS\n     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse\n     * \n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getMaxGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration,\n            long parentPfaf) {\n        float tvalue = Float.NaN;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                fgb.setCountyFips(parentPfaf);\n                if (interpolation.isInterpolate()) {\n                    float nvalue = fgb.getInterpolatedValue(interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (nvalue < -999) {\n                        continue;\n                    }\n                    if (((nvalue < tvalue) && (nvalue > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = nvalue;\n                    }\n                } else {\n                    float value = fgb.getValue(\n                            interpolation.getStandardSource(), interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    if (((value < tvalue) && (value > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = value;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            tvalue = Float.NaN;\n        }\n        return tvalue;\n    }\n    /**\n     * Extracts the Accumulated Max value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @return\n     */\n    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                float val = basin.getAccumValue(afterDate, beforeDate,\n                        expirationTime, rate);\n                if (val > tvalue) {\n                    tvalue = val;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @return\n     */\n    public List<Float> getGuidanceValues(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (interpolation.isInterpolate()) {\n                    values.add(fgb.getInterpolatedValue(interpolation,\n                            expiration));\n                } else {\n                    values.add(fgb.getValue(interpolation.getStandardSource(),\n                            interpolation, expiration));\n                }\n            }\n        }\n        return values;\n    }\n    /**\n     * Gets the average guidance value for an aggregate basin\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @param expiration\n     * @return\n     */\n    public Float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n        float tvalue = 0.0f;\n        int i = 0;\n        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation,\n                expiration);\n        if (vals != null) {\n            for (Float val : vals) {\n                tvalue += val;\n                i++;\n            }\n        } else {\n            return null;\n        }\n        return tvalue / i;\n    }\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @param rate\n     * @return\n     */\n    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                values.add(basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate));\n            }\n        }\n        return values;\n    }\n    /**\n     * Purge out old data\n     * \n     * @param date\n     */\n    public void purgeData(Date date) {\n        // remove old tasks before calling getBasins() since that may\n        // cause them to run\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                Iterator<LoadTask> itr = tasks.iterator();\n                {\n                    while (itr.hasNext()) {\n                        LoadTask task = itr.next();\n                        if (task instanceof LoadMapTask) {\n                            LoadMapTask mtask = (LoadMapTask) task;\n                            if (mtask.date.before(date)) {\n                                itr.remove();\n                            }\n                        }\n                    }\n                }\n                if (tasks.isEmpty()) {\n                    orderedBasinsCache.clear();\n                }\n            }\n        }\n        for (FFMPBasin basin : basins.values()) {\n            basin.purgeData(date);\n        }\n    }\n    /**\n     * deserialize data from the aggregate record\n     * \n     * @param times\n     */\n    public void populate(List<Long> times) {\n        if (mapFactory == null) {\n            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(),\n                    getBasins().size());\n        }\n        long[] timesArr = new long[times.size()];\n        for (int i = 0; i < timesArr.length; i += 1) {\n            timesArr[i] = times.get(i);\n        }\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.deserialize(timesArr, mapFactory);\n        }\n    }\n    /**\n     * populates the serialized array/objects\n     */\n    public void serialize() {\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.serialize();\n        }\n    }\n    /**\n     * Add basins some basins from a datastoreFile. The basins will not be\n     * loaded immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param siteKey\n     *            - siteKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param huc\n     *            - huc to load\n     * @param sourceName\n     *            - the sourceName for the data.\n     * @param date\n     *            - the date of the data.\n     * @param orderedPfafs\n     *            - a collection of Longs which is in the same order as the data\n     *            in the dataStore.\n     * @param aggregate\n     */\n    public void addBasins(File datastoreFile, String uri, String siteKey,\n            String cwa, String huc, String sourceName, Date date,\n            Collection<Long> orderedPfafs, boolean aggregate) {\n        SourceXML source = FFMPSourceConfigurationManager.getInstance()\n                .getSource(sourceName);\n        boolean guidance = source.getSourceType().equals(\n                SOURCE_TYPE.GUIDANCE.getSourceType());\n        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + huc;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedPfafs.size()];\n                int j = 0;\n                for (Long pfaf : orderedPfafs) {\n                    FFMPBasin basin = this.basins.get(pfaf);\n                    if (basin == null) {\n                        if (guidance) {\n                            basin = new FFMPGuidanceBasin(pfaf, aggregate);\n                        } else {\n                            if (mapFactory == null) {\n                                mapFactory = new BasinMapFactory<Date>(\n                                        Collections.reverseOrder(),\n                                        orderedPfafs.size());\n                            }\n                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);\n                        }\n                        this.basins.put(pfaf, basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            if (guidance) {\n                tasks.add(new LoadGuidanceMapTask(datastoreFile,\n                        datasetGroupPath, basins, date, sourceName));\n            } else {\n                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath,\n                        basins, date));\n            }\n        }\n    }\n    /**\n     * Add virtual basins from a datastoreFile. The basins will not be loaded\n     * immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param dataKey\n     *            - dataKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param date\n     *            - the date of the data.\n     * @param orderedMetadata\n     *            - a collection of FFMPVirtualGageBasinMetaData which is in the\n     *            same order as the data in the dataStore.\n     */\n    public void addVirtualBasins(File datastoreFile, String uri,\n            String dataKey, String cwa, Date date,\n            Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {\n        String basinsKey = dataKey + ' ' + cwa;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedMetadata.size()];\n                int j = 0;\n                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {\n                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());\n                    if (basin == null) {\n                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(),\n                                fvgbmd.getParentPfaf(), false);\n                        this.basins.put(fvgbmd.getLookupId(), basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath,\n                    basins, date));\n        }\n    }\n    /**\n     * Returns whether or not any basins have been put in the basins map. Faster\n     * than calling getBasins().size() or getBasins().isEmpty().\n     * \n     * @return\n     */\n    public boolean hasAnyBasins() {\n        return !basins.isEmpty();\n    }\n    /**\n     * Load now.\n     */\n    public void loadNow() {\n        synchronized (tasks) {\n            if (!tasks.isEmpty()) {\n                FFMPDataRecordLoader.loadRecords(tasks);\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n    }\n    /**\n     * Base task for loading data from a dataRecord into FFMPBasins\n     */\n    private class LoadMapTask extends LoadTask {\n        protected final FFMPBasin[] basins;\n        protected final Date date;\n        public LoadMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath);\n            this.basins = basins;\n            this.date = date;\n        }\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void process(FloatDataRecord record) {\n            float[] values = record.getFloatData();\n            for (int j = 0; j < values.length; j += 1) {\n                applyValue(basins[j], values[j]);\n            }\n        }\n        /**\n         * Apply the value to the basin/\n         */\n        protected void applyValue(FFMPBasin basin, float value) {\n            if (basin.contains(date)) {\n                float curval = basin.getValue(date);\n                // These are QPF and QPE so, 0.0 is a valid amount\n                if (curval >= 0.0f && value >= 0.0f) {\n                    basin.setValue(date, (curval + value) / 2);\n                } else if (value >= 0.0f) {\n                    basin.setValue(date, value);\n                } \n                // do not overwrite original value\n            } else {\n                // no value at time exists, write regardless\n                basin.setValue(date, value);\n            }\n        }\n    }\n    /**\n     * Task for loading data from a dataRecord into FFMPGuidanceBasins\n     */\n    private class LoadGuidanceMapTask extends LoadMapTask {\n        private final String sourceName;\n        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date, String sourceName) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n            this.sourceName = sourceName;\n        }\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;\n            Float curval = gBasin.getValue(date, sourceName);\n            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {\n                // average of original and new value\n                if (curval > 0.0f && value > 0.0f) {\n                    gBasin.setValue(sourceName, date, (curval + value) / 2);\n                } else {\n                    // curval zero, overwrite original value \n                    if (curval == 0.0f) {\n                        gBasin.setValue(sourceName, date, value);\n                    }\n                }\n            } else {\n                // curval NaN or MISSING, Overwrite original value \n                gBasin.setValue(sourceName, date, value);\n            }\n        }\n    }\n    /**\n     * Task for loading data from a dataRecord into FFMPVirtualGageBasins\n     */\n    private class LoadVirtualMapTask extends LoadMapTask {\n        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n        }\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            basin.setValue(date, value);\n        }\n    }\n"]], "pred": {"ppl": 1.9466818571090698, "ppl_lower": 2.1133928298950195, "ppl/lowercase_ppl": -1.123352462541054, "ppl/zlib": 0.0001594366470682226, "Min_5.0% Prob": 6.944330617493274, "Min_10.0% Prob": 5.110053817431132, "Min_20.0% Prob": 3.164879375813054, "Min_30.0% Prob": 2.195568854610125, "Min_40.0% Prob": 1.6598460455504782, "Min_50.0% Prob": 1.332301908338519, "Min_60.0% Prob": 1.11140040267976}}
{"hexsha": "e32741ad1544b9465ebc4976051bd0b87f903644", "ext": "java", "lang": "Java", "content": "public class SupplierCompileCompletionTest extends OfficeFrameTestCase {\n\n\t/**\n\t * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeFloorCompileScope() {\n\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeFloorMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();\n\t\tMockTeamSource team = new MockTeamSource();\n\t\tMockExecutiveSource executive = new MockExecutiveSource();\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockSupplierSource officeSupplier = new MockSupplierSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.officeFloor((context) -> {\n\t\t\tOfficeFloorDeployer deployer = context.getOfficeFloorDeployer();\n\t\t\tDeployedOffice office = context.getDeployedOffice();\n\n\t\t\t// Managed Object\n\t\t\tOfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource(\"MOS\", officeFloorMos);\n\t\t\tdeployer.link(mos.getManagingOffice(), office);\n\t\t\tmos.addOfficeFloorManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tOfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool(\"POOL\", officeFloorPool);\n\t\t\tdeployer.link(mos, pool);\n\n\t\t\t// Team\n\t\t\tdeployer.addTeam(\"TEAM\", team);\n\n\t\t\t// Executive\n\t\t\tdeployer.setExecutive(executive);\n\n\t\t\t// Supplier\n\t\t\tdeployer.addSupplier(\"SUPPLIER\", completeSupplier);\n\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after OfficeFloor sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\n\t\t\t// Ensure the supplier is now available\n\t\t\tassertNotNull(\"Supplier should have setup context\", compileScopedSources.get());\n\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", officeSupplier);\n\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing (OfficeFloor) supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object\", completeSupplier.completed.contains(officeFloorMos));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object pool\",\n\t\t\t\t\tcompleteSupplier.completed.contains(officeFloorPool));\n\t\t\tassertTrue(\"Missing team\", completeSupplier.completed.contains(team));\n\t\t\tassertTrue(\"Missing executive\", completeSupplier.completed.contains(executive));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing (office) supplier\", completeSupplier.completed.contains(officeSupplier));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 13,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Ensure capture {@link Office} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeCompileScope() {\n\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", completeSupplier);\n\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after Office sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 8,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\n\tprivate static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {\n\t\tassertIllegalStateException(() -> context.addManagedObjectSource(null, null, null),\n\t\t\t\t\"Unable to add further ManagedObject as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addSupplierThreadLocal(null, null),\n\t\t\t\t\"Unable to add further SupplierThreadLocal as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addThreadSynchroniser(null),\n\t\t\t\t\"Unable to add further ThreadSynchroniser as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addInternalSupplier(null),\n\t\t\t\t\"Unable to add further InternalSupplier as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null),\n\t\t\t\t\"Unable to add further SupplierCompileCompletion as SupplierSource completing\");\n\t}\n\n\tprivate static void assertIllegalStateException(Runnable logic, String message) {\n\t\ttry {\n\t\t\tlogic.run();\n\t\t\tfail(\"Should not be successful. \" + message);\n\t\t} catch (IllegalStateException ex) {\n\t\t\tassertEquals(\"Incorrect cause\", message, ex.getMessage());\n\t\t}\n\t}\n\n\tprivate static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();\n\n\t@TestSource\n\tprivate static class CompleteSupplierSource extends AbstractSupplierSource {\n\n\t\tprivate final List<Object> completed = new ArrayList<>();\n\n\t\t/**\n\t\t * Initial {@link SupplierSourceContext}.\n\t\t */\n\t\tprivate SupplierSourceContext initialContext;\n\n\t\t/**\n\t\t * Completion {@link SupplierCompileContext}.\n\t\t */\n\t\tprivate SupplierCompileContext completeContext;\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tthis.initialContext = context;\n\n\t\t\t// Clear scoped objects\n\t\t\tLinkedList<Object> sources = new LinkedList<>();\n\t\t\tsources.add(this);\n\t\t\tcompileScopedSources.set(sources);\n\n\t\t\t// Capture sources on completion\n\t\t\tcontext.addCompileCompletion((completion) -> {\n\t\t\t\tthis.completeContext = completion;\n\t\t\t\tthis.completed.addAll(compileScopedSources.get());\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockSupplierSource extends AbstractSupplierSource {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<None, None> context) throws Exception {\n\t\t\tcontext.setObjectClass(Object.class);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\n\t\t@Override\n\t\tprotected ManagedObject getManagedObject() throws Throwable {\n\t\t\tfail(\"Should not be run\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource\n\t\t\timplements ManagedObjectPoolFactory {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext context) throws Exception {\n\t\t\tcontext.setPooledObjectType(Object.class);\n\t\t\tcontext.setManagedObjectPoolFactory(this);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext)\n\t\t\t\tthrows Throwable {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockTeamSource extends AbstractTeamSource implements Team {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic Team createTeam(TeamSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic void startWorking() {\n\t\t\t// nothing to start\n\t\t}\n\n\t\t@Override\n\t\tpublic void assignJob(Job job) throws TeamOverloadException, Exception {\n\t\t\tfail(\"Should not run\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void stopWorking() {\n\t\t\t// nothing to stop\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockExecutiveSource extends DefaultExecutive {\n\n\t\t@Override\n\t\tpublic Executive createExecutive(ExecutiveSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn super.createExecutive(context);\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setAdministrationFactory(() -> (adminContext) -> {\n\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setGovernanceFactory(() -> null);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockManagedFunctionSource extends AbstractManagedFunctionSource {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder,\n\t\t\t\tManagedFunctionSourceContext context) throws Exception {\n\t\t\tfunctionNamespaceTypeBuilder.addManagedFunctionType(\"function\", None.class, None.class)\n\t\t\t\t\t.setFunctionFactory(() -> (mfContext) -> {\n\t\t\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "officefloor/OfficeFloor", "file": "officefloor/core/officecompiler/src/test/java/net/officefloor/compile/impl/supplier/SupplierCompileCompletionTest.java", "last_update_at": "2021-12-20T04:51:03+00:00", "question_id": "e32741ad1544b9465ebc4976051bd0b87f903644", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SupplierCompileCompletionTest extends OfficeFrameTestCase {\n\t/**\n\t * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeFloorCompileScope() {\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeFloorMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();\n\t\tMockTeamSource team = new MockTeamSource();\n\t\tMockExecutiveSource executive = new MockExecutiveSource();\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockSupplierSource officeSupplier = new MockSupplierSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.officeFloor((context) -> {\n\t\t\tOfficeFloorDeployer deployer = context.getOfficeFloorDeployer();\n\t\t\tDeployedOffice office = context.getDeployedOffice();\n\t\t\t// Managed Object\n\t\t\tOfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource(\"MOS\", officeFloorMos);\n\t\t\tdeployer.link(mos.getManagingOffice(), office);\n\t\t\tmos.addOfficeFloorManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tOfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool(\"POOL\", officeFloorPool);\n\t\t\tdeployer.link(mos, pool);\n\t\t\t// Team\n\t\t\tdeployer.addTeam(\"TEAM\", team);\n\t\t\t// Executive\n\t\t\tdeployer.setExecutive(executive);\n\t\t\t// Supplier\n\t\t\tdeployer.addSupplier(\"SUPPLIER\", completeSupplier);\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after OfficeFloor sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\t\t\t// Ensure the supplier is now available\n\t\t\tassertNotNull(\"Supplier should have setup context\", compileScopedSources.get());\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", officeSupplier);\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing (OfficeFloor) supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object\", completeSupplier.completed.contains(officeFloorMos));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object pool\",\n\t\t\t\t\tcompleteSupplier.completed.contains(officeFloorPool));\n\t\t\tassertTrue(\"Missing team\", completeSupplier.completed.contains(team));\n\t\t\tassertTrue(\"Missing executive\", completeSupplier.completed.contains(executive));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing (office) supplier\", completeSupplier.completed.contains(officeSupplier));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 13,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\t/**\n\t * Ensure capture {@link Office} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeCompileScope() {\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", completeSupplier);\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after Office sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 8,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\tprivate static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {\n\t\tassertIllegalStateException(() -> context.addManagedObjectSource(null, null, null),\n\t\t\t\t\"Unable to add further ManagedObject as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addSupplierThreadLocal(null, null),\n\t\t\t\t\"Unable to add further SupplierThreadLocal as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addThreadSynchroniser(null),\n\t\t\t\t\"Unable to add further ThreadSynchroniser as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addInternalSupplier(null),\n\t\t\t\t\"Unable to add further InternalSupplier as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null),\n\t\t\t\t\"Unable to add further SupplierCompileCompletion as SupplierSource completing\");\n\t}\n\tprivate static void assertIllegalStateException(Runnable logic, String message) {\n\t\ttry {\n\t\t\tlogic.run();\n\t\t\tfail(\"Should not be successful. \" + message);\n\t\t} catch (IllegalStateException ex) {\n\t\t\tassertEquals(\"Incorrect cause\", message, ex.getMessage());\n\t\t}\n\t}\n\tprivate static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();\n\t@TestSource\n\tprivate static class CompleteSupplierSource extends AbstractSupplierSource {\n\t\tprivate final List<Object> completed = new ArrayList<>();\n\t\t/**\n\t\t * Initial {@link SupplierSourceContext}.\n\t\t */\n\t\tprivate SupplierSourceContext initialContext;\n\t\t/**\n\t\t * Completion {@link SupplierCompileContext}.\n\t\t */\n\t\tprivate SupplierCompileContext completeContext;\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tthis.initialContext = context;\n\t\t\t// Clear scoped objects\n\t\t\tLinkedList<Object> sources = new LinkedList<>();\n\t\t\tsources.add(this);\n\t\t\tcompileScopedSources.set(sources);\n\t\t\t// Capture sources on completion\n\t\t\tcontext.addCompileCompletion((completion) -> {\n\t\t\t\tthis.completeContext = completion;\n\t\t\t\tthis.completed.addAll(compileScopedSources.get());\n\t\t\t});\n\t\t}\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockSupplierSource extends AbstractSupplierSource {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<None, None> context) throws Exception {\n\t\t\tcontext.setObjectClass(Object.class);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t\t@Override\n\t\tprotected ManagedObject getManagedObject() throws Throwable {\n\t\t\tfail(\"Should not be run\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource\n\t\t\timplements ManagedObjectPoolFactory {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext context) throws Exception {\n\t\t\tcontext.setPooledObjectType(Object.class);\n\t\t\tcontext.setManagedObjectPoolFactory(this);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t\t@Override\n\t\tpublic ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext)\n\t\t\t\tthrows Throwable {\n\t\t\treturn null;\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockTeamSource extends AbstractTeamSource implements Team {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic Team createTeam(TeamSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn this;\n\t\t}\n\t\t@Override\n\t\tpublic void startWorking() {\n\t\t\t// nothing to start\n\t\t}\n\t\t@Override\n\t\tpublic void assignJob(Job job) throws TeamOverloadException, Exception {\n\t\t\tfail(\"Should not run\");\n\t\t}\n\t\t@Override\n\t\tpublic void stopWorking() {\n\t\t\t// nothing to stop\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockExecutiveSource extends DefaultExecutive {\n\t\t@Override\n\t\tpublic Executive createExecutive(ExecutiveSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn super.createExecutive(context);\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setAdministrationFactory(() -> (adminContext) -> {\n\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setGovernanceFactory(() -> null);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockManagedFunctionSource extends AbstractManagedFunctionSource {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder,\n\t\t\t\tManagedFunctionSourceContext context) throws Exception {\n\t\t\tfunctionNamespaceTypeBuilder.addManagedFunctionType(\"function\", None.class, None.class)\n\t\t\t\t\t.setFunctionFactory(() -> (mfContext) -> {\n\t\t\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.8300087451934814, "ppl_lower": 2.411794662475586, "ppl/lowercase_ppl": -1.4567945084702572, "ppl/zlib": 0.00024951310719907653, "Min_5.0% Prob": 6.737935533710554, "Min_10.0% Prob": 4.779040161301108, "Min_20.0% Prob": 2.881748928158891, "Min_30.0% Prob": 1.9956840621490104, "Min_40.0% Prob": 1.5069100431697147, "Min_50.0% Prob": 1.2089219869464387, "Min_60.0% Prob": 1.0083383373915389}}
{"hexsha": "d620dafeb60e8e45312cbc5cd34054b25cd5a7e5", "ext": "java", "lang": "Java", "content": "public class Conta \n{\n\tprivate static int chave_conta;\n\t\n\tprivate String nome;\n\tprivate String descricao;\n\tprivate String senha;\n\t\n\tprivate Pessoa pessoa;\n\tprivate java.util.Date data;\n\t\n\tpublic Conta() { Conta.chave_conta++; }\n\t\n\tpublic Conta(String nome) {\n\t\tthis.nome = nome;\n\t\tConta.chave_conta++; \n\t}\n\n\tpublic static int CHAVE_CONTA() { return Conta.chave_conta; }\n\n\tpublic String getNome() { return this.nome; }\n\tpublic void setNome(String nome) { this.nome = nome; }\n\n\tpublic String getDescricao() { return this.descricao; }\n\tpublic void setDescricao(String descricao) { this.descricao = descricao; }\n\n\tpublic String getSenha() { return this.senha; }\n\tpublic void setSenha(String senha) { this.senha = senha; }\n\t\n\tpublic Pessoa getPessoa() { return this.pessoa; }\n\tpublic void setPessoa(Pessoa pessoa) { this.pessoa = pessoa; }\n\t\n\tpublic java.util.Date getData() { return this.data; }\n\tpublic void setData(java.util.Date data) {\n\t\tGregorianCalendar gc = new GregorianCalendar(2021, 2, 31);\n\t\tif (data.equals(gc.getTime())) {\n\t\t\tthis.data = null;\n\t\t}\n\t\t\n\t\tthis.data = data; \n\t}\n}", "class_id": 0, "repo": "RyanCasf/Java", "file": "src/main/java/br/com/estatico/aplication/Conta.java", "last_update_at": "2021-08-02T22:32:24+00:00", "question_id": "d620dafeb60e8e45312cbc5cd34054b25cd5a7e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Conta \n{\n\tprivate static int chave_conta;\n\t\n\tprivate String nome;\n\tprivate String descricao;\n\tprivate String senha;\n\t\n\tprivate Pessoa pessoa;\n\tprivate java.util.Date data;\n\t\n\tpublic Conta() { Conta.chave_conta++; }\n\t\n\tpublic Conta(String nome) {\n\t\tthis.nome = nome;\n\t\tConta.chave_conta++; \n\t}\n\tpublic static int CHAVE_CONTA() { return Conta.chave_conta; }\n\tpublic String getNome() { return this.nome; }\n\tpublic void setNome(String nome) { this.nome = nome; }\n\tpublic String getDescricao() { return this.descricao; }\n\tpublic void setDescricao(String descricao) { this.descricao = descricao; }\n\tpublic String getSenha() { return this.senha; }\n\tpublic void setSenha(String senha) { this.senha = senha; }\n\t\n\tpublic Pessoa getPessoa() { return this.pessoa; }\n\tpublic void setPessoa(Pessoa pessoa) { this.pessoa = pessoa; }\n\t\n\tpublic java.util.Date getData() { return this.data; }\n\tpublic void setData(java.util.Date data) {\n\t\tGregorianCalendar gc = new GregorianCalendar(2021, 2, 31);\n\t\tif (data.equals(gc.getTime())) {\n\t\t\tthis.data = null;\n\t\t}\n\t\t\n\t\tthis.data = data; \n\t}\n"]], "pred": {"ppl": 1.542448878288269, "ppl_lower": 1.6748303174972534, "ppl/lowercase_ppl": -1.1899999297134272, "ppl/zlib": 0.0011404508792989985, "Min_5.0% Prob": 5.231287206922259, "Min_10.0% Prob": 3.5722880278314864, "Min_20.0% Prob": 2.0813850360758166, "Min_30.0% Prob": 1.4288807255506981, "Min_40.0% Prob": 1.0835054997464313, "Min_50.0% Prob": 0.8670302088145044, "Min_60.0% Prob": 0.7222403414907603}}
{"hexsha": "3f156fc483ff7ed9a55cefd3b01cbbcdd2d04d3a", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/passwordSecurityPolicy\")\n@Extension\n@Tag(name = \"passwordSecurityPolicy\")\n@ProtectedREST\n@OperationsInside\npublic class PasswordSecurityPolicyController implements Plugin {\n\n\t@Autowired\n\tprivate PasswordSecurityPolicyService passwordSecurityPolicyService;\n\n\t@PostMapping(\"/create\")\n\t@Operation(description = \"creates Security Policy\",summary = \"creates Security Policy\")\n\tpublic PasswordSecurityPolicy create(@RequestHeader(value = \"authenticationKey\",required = false)String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyCreate,securityContext);\n\t\treturn passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate,securityContext);\n\t}\n\n\t@PostMapping(\"/getAll\")\n\t@Operation(description = \"returns Security Policies\",summary = \"returns Security Policies\")\n\n\tpublic PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyFilter securityPolicyFilter,  @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyFilter,securityContext);\n\t\treturn passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter,securityContext);\n\t}\n\n\t@PutMapping(\"/update\")\n\t@Operation(description = \"updates Security Policies\",summary = \"updates Security Policies\")\n\n\tpublic PasswordSecurityPolicy update(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext){\n\t\tString id=securityPolicyUpdate.getId();\n\t\tPasswordSecurityPolicy passwordSecurityPolicy=id!=null? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id,PasswordSecurityPolicy.class,securityContext):null;\n\t\tif(passwordSecurityPolicy==null){\n\t\t\tthrow new ResponseStatusException(HttpStatus.BAD_REQUEST,\"no PasswordSecurityPolicy user with id \"+id);\n\t\t}\n\t\tsecurityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);\n\t\tpasswordSecurityPolicyService.validate(securityPolicyUpdate,securityContext);\n\t\treturn passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate,securityContext);\n\t}\n}", "class_id": 0, "repo": "wizzdi/flexicore-base-service", "file": "src/main/java/com/flexicore/rest/PasswordSecurityPolicyController.java", "last_update_at": "2021-06-11T04:13:36+00:00", "question_id": "3f156fc483ff7ed9a55cefd3b01cbbcdd2d04d3a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/passwordSecurityPolicy\")\n@Extension\n@Tag(name = \"passwordSecurityPolicy\")\n@ProtectedREST\n@OperationsInside\npublic class PasswordSecurityPolicyController implements Plugin {\n\t@Autowired\n\tprivate PasswordSecurityPolicyService passwordSecurityPolicyService;\n\t@PostMapping(\"/create\")\n\t@Operation(description = \"creates Security Policy\",summary = \"creates Security Policy\")\n\tpublic PasswordSecurityPolicy create(@RequestHeader(value = \"authenticationKey\",required = false)String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyCreate,securityContext);\n\t\treturn passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate,securityContext);\n\t}\n\t@PostMapping(\"/getAll\")\n\t@Operation(description = \"returns Security Policies\",summary = \"returns Security Policies\")\n\tpublic PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyFilter securityPolicyFilter,  @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyFilter,securityContext);\n\t\treturn passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter,securityContext);\n\t}\n\t@PutMapping(\"/update\")\n\t@Operation(description = \"updates Security Policies\",summary = \"updates Security Policies\")\n\tpublic PasswordSecurityPolicy update(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext){\n\t\tString id=securityPolicyUpdate.getId();\n\t\tPasswordSecurityPolicy passwordSecurityPolicy=id!=null? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id,PasswordSecurityPolicy.class,securityContext):null;\n\t\tif(passwordSecurityPolicy==null){\n\t\t\tthrow new ResponseStatusException(HttpStatus.BAD_REQUEST,\"no PasswordSecurityPolicy user with id \"+id);\n\t\t}\n\t\tsecurityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);\n\t\tpasswordSecurityPolicyService.validate(securityPolicyUpdate,securityContext);\n\t\treturn passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate,securityContext);\n\t}\n"]], "pred": {"ppl": 2.1080002784729004, "ppl_lower": 2.4856302738189697, "ppl/lowercase_ppl": -1.2209705102867883, "ppl/zlib": 0.0012387703700697692, "Min_5.0% Prob": 7.668464095504196, "Min_10.0% Prob": 5.495905094676548, "Min_20.0% Prob": 3.451213495047004, "Min_30.0% Prob": 2.431838268207179, "Min_40.0% Prob": 1.8474904943927093, "Min_50.0% Prob": 1.488121240746876, "Min_60.0% Prob": 1.2440368443326308}}
{"hexsha": "18b49af96dd5814b6f008015faacfeda2a05682a", "ext": "java", "lang": "Java", "content": "@Component\n@Description(\"Ends execution of entity event.\")\npublic class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {\n\t\n\tpublic static final String PROCESSOR_NAME = \"entity-event-end-processor\";\n\t//\n\t@Autowired private IdmEntityEventService service;\n\t\n\tpublic EntityEventEndProcessor() {\n\t\tsuper(EntityEventType.EXECUTE);\n\t}\n\t\n\t@Override\n\tpublic String getName() {\n\t\treturn PROCESSOR_NAME;\n\t}\n\n\t@Override\n\tpublic EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {\n\t\tIdmEntityEventDto entityEvent = event.getContent();\n\t\tentityEvent.setEventEnded(ZonedDateTime.now());\n\t\tentityEvent = service.save(entityEvent);\n\t\tevent.setContent(entityEvent);\n\t\t//\n\t\treturn new DefaultEventResult<>(event, this);\n\t}\n\t\n\t/**\n\t * Asynchronous processing can be disabled\n\t */\n\t@Override\n\tpublic boolean conditional(EntityEvent<IdmEntityEventDto> event) {\n\t\treturn event.getContent().getId() != null;\n\t}\n\t\n\t@Override\n\tpublic int getOrder() {\n\t\t// after process\n\t\treturn 1000;\n\t}\n}", "class_id": 0, "repo": "piougy/CzechIdMng", "file": "Realization/backend/core/core-impl/src/main/java/eu/bcvsolutions/idm/core/model/event/processor/event/EntityEventEndProcessor.java", "last_update_at": "2021-08-06T19:55:05+00:00", "question_id": "18b49af96dd5814b6f008015faacfeda2a05682a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Description(\"Ends execution of entity event.\")\npublic class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {\n\t\n\tpublic static final String PROCESSOR_NAME = \"entity-event-end-processor\";\n\t//\n\t@Autowired private IdmEntityEventService service;\n\t\n\tpublic EntityEventEndProcessor() {\n\t\tsuper(EntityEventType.EXECUTE);\n\t}\n\t\n\t@Override\n\tpublic String getName() {\n\t\treturn PROCESSOR_NAME;\n\t}\n\t@Override\n\tpublic EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {\n\t\tIdmEntityEventDto entityEvent = event.getContent();\n\t\tentityEvent.setEventEnded(ZonedDateTime.now());\n\t\tentityEvent = service.save(entityEvent);\n\t\tevent.setContent(entityEvent);\n\t\t//\n\t\treturn new DefaultEventResult<>(event, this);\n\t}\n\t\n\t/**\n\t * Asynchronous processing can be disabled\n\t */\n\t@Override\n\tpublic boolean conditional(EntityEvent<IdmEntityEventDto> event) {\n\t\treturn event.getContent().getId() != null;\n\t}\n\t\n\t@Override\n\tpublic int getOrder() {\n\t\t// after process\n\t\treturn 1000;\n\t}\n"]], "pred": {"ppl": 1.7752010822296143, "ppl_lower": 3.4084689617156982, "ppl/lowercase_ppl": -2.1366682844097453, "ppl/zlib": 0.001244932109054652, "Min_5.0% Prob": 5.974488079547882, "Min_10.0% Prob": 4.265146522810965, "Min_20.0% Prob": 2.683263575488871, "Min_30.0% Prob": 1.8848407408504775, "Min_40.0% Prob": 1.4318430974063547, "Min_50.0% Prob": 1.1489517870443788, "Min_60.0% Prob": 0.9587741653397303}}
{"hexsha": "2b5d7a6df824e402ae1c26cbf10970eb75941eb6", "ext": "java", "lang": "Java", "content": "public class PlaceLocation {\n    public String name;\n    public String address;\n\n    public boolean isNotInUsa() {\n        return address != null && !address.endsWith(\"USA\") && !address.endsWith(\"United States\");\n    }\n\n    public String country() {\n        if (address == null) {\n            return null;\n        }\n        String countryMatch = address.substring(address.lastIndexOf(\"\\n\") + 1);\n        String trimmedCountry;\n        if (!countryMatch.contains(\",\")) {\n            trimmedCountry = countryMatch.trim();\n        } else  {\n            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(\",\") + 1).trim();\n        }\n\n        switch (trimmedCountry) {\n        case \"United States\":\n            return \"USA\";\n        case \"Italia\":\n            return \"Italy\";\n        case \"Tanz\u00e1nie\":\n            return \"Tanzania\";\n        case \"\u00c9ire\":\n            return \"Ireland\";\n        case \"United Kingdom\":\n            return \"UK\";\n        default:\n            return trimmedCountry;\n        }\n    }\n\n\n}", "class_id": 0, "repo": "vmware/workflowTools", "file": "core/src/test/java/PlaceLocation.java", "last_update_at": "2021-12-06T22:26:15+00:00", "question_id": "2b5d7a6df824e402ae1c26cbf10970eb75941eb6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlaceLocation {\n    public String name;\n    public String address;\n    public boolean isNotInUsa() {\n        return address != null && !address.endsWith(\"USA\") && !address.endsWith(\"United States\");\n    }\n    public String country() {\n        if (address == null) {\n            return null;\n        }\n        String countryMatch = address.substring(address.lastIndexOf(\"\\n\") + 1);\n        String trimmedCountry;\n        if (!countryMatch.contains(\",\")) {\n            trimmedCountry = countryMatch.trim();\n        } else  {\n            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(\",\") + 1).trim();\n        }\n        switch (trimmedCountry) {\n        case \"United States\":\n            return \"USA\";\n        case \"Italia\":\n            return \"Italy\";\n        case \"Tanz\u00e1nie\":\n            return \"Tanzania\";\n        case \"\u00c9ire\":\n            return \"Ireland\";\n        case \"United Kingdom\":\n            return \"UK\";\n        default:\n            return trimmedCountry;\n        }\n    }\n"]], "pred": {"ppl": 2.197988271713257, "ppl_lower": 2.4539270401000977, "ppl/lowercase_ppl": -1.1398617750168847, "ppl/zlib": 0.0021517555193359445, "Min_5.0% Prob": 6.959394711714524, "Min_10.0% Prob": 5.545883531923647, "Min_20.0% Prob": 3.565092924568388, "Min_30.0% Prob": 2.5500009361608527, "Min_40.0% Prob": 1.958350778936788, "Min_50.0% Prob": 1.5676790876587963, "Min_60.0% Prob": 1.3119279231270489}}
{"hexsha": "d337b228a1e219df9c9fd234cc3062ebe9e0e205", "ext": "java", "lang": "Java", "content": "public class InMemoryBulkDataSorterTest\n{\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n    \n    /* A counter of tuple files */\n    private int counter = 0;\n\n    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>()\n    {\n\n        @Override\n        public int compare( Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2 )\n        {\n            return o1.getKey().compareTo( o2.getKey() );\n        }\n    };\n\n\n    @Test\n    public void testSortedFileCount() throws IOException\n    {\n        int count = 7;\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n\n        File dataFile = tempFolder.newFile( \"tuple.data\" );\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( 100 );\n\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n\n            arr[i] = t;\n\n            itrw.storeSortedTuple( t, out );\n        }\n\n        out.close();\n\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, 4 );\n        bds.sort( dataFile );\n\n        assertEquals( 2, bds.getWorkDir().list().length );\n\n        deleteDir( bds.getWorkDir() );\n    }\n\n\n    @Test\n    public void testSortedFileMerge() throws IOException\n    {\n        testSortedFileMerge( 10, 2 );\n        testSortedFileMerge( 100, 7 );\n        testSortedFileMerge( 1000, 25 );\n        testSortedFileMerge( 10000, 100 );\n        testSortedFileMerge( 10000, 101 );\n        testSortedFileMerge( 100000, 501 );\n    }\n\n\n    private void testSortedFileMerge( int count, int splitAfter ) throws IOException\n    {\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n\n        File dataFile = tempFolder.newFile( \"tuple.data\" + counter );\n        counter++;\n        dataFile.deleteOnExit();\n\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n\n        int randUpper = count;\n        if ( count < 100 )\n        {\n            randUpper = 100;\n        }\n\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( randUpper );\n\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n\n            arr[i] = t;\n\n            itrw.storeSortedTuple( t, out );\n        }\n\n        out.close();\n\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, splitAfter );\n        bds.sort( dataFile );\n\n        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();\n\n        Integer prev = null;\n\n        while ( itr.hasNext() )\n        {\n            Tuple<Integer, Integer> t = itr.next();\n\n            if ( prev == null )\n            {\n                prev = t.getKey();\n            }\n            else\n            {\n                assertTrue( prev <= t.getKey() );\n            }\n        }\n\n        deleteDir( bds.getWorkDir() );\n    }\n\n\n    private void deleteDir( File dir )\n    {\n        if ( dir.isFile() )\n        {\n            dir.delete();\n        }\n\n        File[] files = dir.listFiles();\n\n        for ( File f : files )\n        {\n            f.delete();\n        }\n\n        dir.delete();\n    }\n}", "class_id": 0, "repo": "kupl/starlab-benchmarks", "file": "Benchmarks_with_Safety_Bugs/Java/directory-mavibot/src/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBulkDataSorterTest.java", "last_update_at": "2021-11-08T13:39:38+00:00", "question_id": "d337b228a1e219df9c9fd234cc3062ebe9e0e205", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InMemoryBulkDataSorterTest\n{\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n    /* A counter of tuple files */\n    private int counter = 0;\n    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>()\n    {\n        @Override\n        public int compare( Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2 )\n        {\n            return o1.getKey().compareTo( o2.getKey() );\n        }\n    };\n    @Test\n    public void testSortedFileCount() throws IOException\n    {\n        int count = 7;\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile( \"tuple.data\" );\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( 100 );\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n            arr[i] = t;\n            itrw.storeSortedTuple( t, out );\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, 4 );\n        bds.sort( dataFile );\n        assertEquals( 2, bds.getWorkDir().list().length );\n        deleteDir( bds.getWorkDir() );\n    }\n    @Test\n    public void testSortedFileMerge() throws IOException\n    {\n        testSortedFileMerge( 10, 2 );\n        testSortedFileMerge( 100, 7 );\n        testSortedFileMerge( 1000, 25 );\n        testSortedFileMerge( 10000, 100 );\n        testSortedFileMerge( 10000, 101 );\n        testSortedFileMerge( 100000, 501 );\n    }\n    private void testSortedFileMerge( int count, int splitAfter ) throws IOException\n    {\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile( \"tuple.data\" + counter );\n        counter++;\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n        int randUpper = count;\n        if ( count < 100 )\n        {\n            randUpper = 100;\n        }\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( randUpper );\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n            arr[i] = t;\n            itrw.storeSortedTuple( t, out );\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, splitAfter );\n        bds.sort( dataFile );\n        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();\n        Integer prev = null;\n        while ( itr.hasNext() )\n        {\n            Tuple<Integer, Integer> t = itr.next();\n            if ( prev == null )\n            {\n                prev = t.getKey();\n            }\n            else\n            {\n                assertTrue( prev <= t.getKey() );\n            }\n        }\n        deleteDir( bds.getWorkDir() );\n    }\n    private void deleteDir( File dir )\n    {\n        if ( dir.isFile() )\n        {\n            dir.delete();\n        }\n        File[] files = dir.listFiles();\n        for ( File f : files )\n        {\n            f.delete();\n        }\n        dir.delete();\n    }\n"]], "pred": {"ppl": 1.641234278678894, "ppl_lower": 1.7891747951507568, "ppl/lowercase_ppl": -1.1741975719878883, "ppl/zlib": 0.0005560589985617884, "Min_5.0% Prob": 5.392893758474612, "Min_10.0% Prob": 3.8037583769536485, "Min_20.0% Prob": 2.335389171745263, "Min_30.0% Prob": 1.629731446188065, "Min_40.0% Prob": 1.233213756871034, "Min_50.0% Prob": 0.9904960124952074, "Min_60.0% Prob": 0.8265206213648542}}
{"hexsha": "7bdc9937970a43098edff3a966f21a3d4997caf4", "ext": "java", "lang": "Java", "content": "public class HomePage extends TestBase {\n\n    @Override\n    public void excute() throws Exception {\n\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(\"http://atealxt.appspot.com/guestbook\");\n        Assert.assertEquals(\"Guestbook - Hero's Grave\", page.getTitleText());\n\n        String pageAsXml = page.asXml();// \u548c\u5b9e\u9645\u7684\u7f51\u9875\u6e90\u7801\u4e0d\u5b8c\u5168\u4e00\u81f4\uff0c\u7ecf\u8fc7\u4e86\u683c\u5f0f\u5316\u7b49\u5904\u7406\u3002\u5c0f\u5fc3\u4f7f\u7528\uff01\n        Assert.assertTrue(pageAsXml.contains(\"<script src=\\\"/javascripts/guestbook.js\\\" type=\\\"text/javascript\\\">\"));\n        logger.info(pageAsXml);\n\n        String pageAsText = page.asText();\n        Assert.assertTrue(pageAsText\n                .contains(\"Welcome to my personal website, hope you to find out your own territory!\"));\n        logger.info(pageAsText);\n\n        webClient.closeAllWindows();\n    }\n\n}", "class_id": 0, "repo": "atealxt/work-workspaces", "file": "HtmlUnitDemo/test/htmlunitdemo/test/getstarted/HomePage.java", "last_update_at": "2021-12-18T18:17:34+00:00", "question_id": "7bdc9937970a43098edff3a966f21a3d4997caf4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HomePage extends TestBase {\n    @Override\n    public void excute() throws Exception {\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(\"http://atealxt.appspot.com/guestbook\");\n        Assert.assertEquals(\"Guestbook - Hero's Grave\", page.getTitleText());\n        String pageAsXml = page.asXml();// \u548c\u5b9e\u9645\u7684\u7f51\u9875\u6e90\u7801\u4e0d\u5b8c\u5168\u4e00\u81f4\uff0c\u7ecf\u8fc7\u4e86\u683c\u5f0f\u5316\u7b49\u5904\u7406\u3002\u5c0f\u5fc3\u4f7f\u7528\uff01\n        Assert.assertTrue(pageAsXml.contains(\"<script src=\\\"/javascripts/guestbook.js\\\" type=\\\"text/javascript\\\">\"));\n        logger.info(pageAsXml);\n        String pageAsText = page.asText();\n        Assert.assertTrue(pageAsText\n                .contains(\"Welcome to my personal website, hope you to find out your own territory!\"));\n        logger.info(pageAsText);\n        webClient.closeAllWindows();\n    }\n"]], "pred": {"ppl": 3.677990674972534, "ppl_lower": 4.80473518371582, "ppl/lowercase_ppl": -1.2051921012943316, "ppl/zlib": 0.002538726297906728, "Min_5.0% Prob": 9.19465446472168, "Min_10.0% Prob": 7.509306828180949, "Min_20.0% Prob": 5.337122863652755, "Min_30.0% Prob": 4.008350123424788, "Min_40.0% Prob": 3.1500980565042207, "Min_50.0% Prob": 2.5704320041883375, "Min_60.0% Prob": 2.1738631749475323}}
{"hexsha": "919def75c26c20661ebc949f53445ab95efa46ca", "ext": "java", "lang": "Java", "content": "@Service\npublic class LinkManager implements LinkService {\n\t\n\tprivate LinkDao linkDao;\n\n\t@Autowired\n\tpublic LinkManager(LinkDao linkDao) {\n\t\tsuper();\n\t\tthis.linkDao = linkDao;\n\t}\n\t\n\t@Override\n\tpublic Result add(Link link) {\n\t\tvar result = this.linkDao.save(link);\n\t\tif (result != null) {\n\t\t\treturn new SuccessResult(\"link add ok\");\n\t\t}\n\t\treturn new ErrorResult(\"link add NOT ok\");\n\t}\n\n\t@Override\n\tpublic DataResult<List<Link>> getAll() {\n\t\tvar result = this.linkDao.findAll();\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get NOT ok\");\n\t}\n\n\t@Override\n\tpublic DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {\n\t\tvar result = this.linkDao.getByJobSeekerId(jobSeekerId);\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get by jobSeeker Id ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get by jobSeeker Id NOT ok\");\n\t}\n\n}", "class_id": 0, "repo": "CerenSusuz/HRMS", "file": "hrms/src/main/java/com/hrms/business/concretes/LinkManager.java", "last_update_at": "2021-08-18T23:17:34+00:00", "question_id": "919def75c26c20661ebc949f53445ab95efa46ca", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class LinkManager implements LinkService {\n\t\n\tprivate LinkDao linkDao;\n\t@Autowired\n\tpublic LinkManager(LinkDao linkDao) {\n\t\tsuper();\n\t\tthis.linkDao = linkDao;\n\t}\n\t\n\t@Override\n\tpublic Result add(Link link) {\n\t\tvar result = this.linkDao.save(link);\n\t\tif (result != null) {\n\t\t\treturn new SuccessResult(\"link add ok\");\n\t\t}\n\t\treturn new ErrorResult(\"link add NOT ok\");\n\t}\n\t@Override\n\tpublic DataResult<List<Link>> getAll() {\n\t\tvar result = this.linkDao.findAll();\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get NOT ok\");\n\t}\n\t@Override\n\tpublic DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {\n\t\tvar result = this.linkDao.getByJobSeekerId(jobSeekerId);\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get by jobSeeker Id ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get by jobSeeker Id NOT ok\");\n\t}\n"]], "pred": {"ppl": 1.4972176551818848, "ppl_lower": 1.6951584815979004, "ppl/lowercase_ppl": -1.3076440416077082, "ppl/zlib": 0.001273212899406463, "Min_5.0% Prob": 5.1790954926434685, "Min_10.0% Prob": 3.389831100191389, "Min_20.0% Prob": 1.9543627693619527, "Min_30.0% Prob": 1.336048030964682, "Min_40.0% Prob": 1.008614008073936, "Min_50.0% Prob": 0.8079656456212133, "Min_60.0% Prob": 0.6734019610337739}}
{"hexsha": "fe322982427c837c12bccb9a2b78b51af11bbe10", "ext": "java", "lang": "Java", "content": "public class DefaultDockerImageMigrationHandlerTest {\n\n    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"bar\").saveNode();\n\n    @Test\n    public void invalidConstructorInput() {\n        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler\n                (null));\n    }\n\n    @Test\n    public void noopMigrationScript() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE);\n    }\n\n    @Test\n    public void effectiveMigration() {\n        URL url = TestURLBuilder.forContent(script(\"input.foo = 'baz';\")).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"foo\", \"baz\"));\n    }\n\n    @Test\n    public void globalStateMustBeCleared() {\n        URL url = TestURLBuilder.forContent(\"var globalVar = 0;\" +\n                script(\"input.cpt = globalVar; globalVar++;\")).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n\n        result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n    }\n\n    @Test\n    public void mustHandleJSONEscapeCharacters() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"{\\\"\\':\").saveNode();\n\n        Node result = migrationHandler.performMigration(testNode);\n\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void mustHandleMultiByteCharSequences() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"\ud83d\ude00\").saveNode();\n\n        Node result = migrationHandler.performMigration(testNode);\n\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void invalidScriptMustThrowException() {\n        URL url = TestURLBuilder.forContent(script(\"throw 'invalid script';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        assertThatExceptionOfType(IllegalArgumentException.class).\n                isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));\n    }\n\n    private String noopScript() {\n        return script(\"\");\n    }\n\n    private String script(String content) {\n        return \"module.exports = function(input) { \" + content + \"};\";\n    }\n}", "class_id": 0, "repo": "JeanRev/TeamcityDockerCloudPlugin", "file": "server/src/test/java/run/var/teamcity/cloud/docker/DefaultDockerImageMigrationHandlerTest.java", "last_update_at": "2021-10-14T10:42:50+00:00", "question_id": "fe322982427c837c12bccb9a2b78b51af11bbe10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultDockerImageMigrationHandlerTest {\n    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"bar\").saveNode();\n    @Test\n    public void invalidConstructorInput() {\n        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler\n                (null));\n    }\n    @Test\n    public void noopMigrationScript() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE);\n    }\n    @Test\n    public void effectiveMigration() {\n        URL url = TestURLBuilder.forContent(script(\"input.foo = 'baz';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"foo\", \"baz\"));\n    }\n    @Test\n    public void globalStateMustBeCleared() {\n        URL url = TestURLBuilder.forContent(\"var globalVar = 0;\" +\n                script(\"input.cpt = globalVar; globalVar++;\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n        result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n    }\n    @Test\n    public void mustHandleJSONEscapeCharacters() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"{\\\"\\':\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n    @Test\n    public void mustHandleMultiByteCharSequences() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"\ud83d\ude00\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n    @Test\n    public void invalidScriptMustThrowException() {\n        URL url = TestURLBuilder.forContent(script(\"throw 'invalid script';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        assertThatExceptionOfType(IllegalArgumentException.class).\n                isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));\n    }\n    private String noopScript() {\n        return script(\"\");\n    }\n    private String script(String content) {\n        return \"module.exports = function(input) { \" + content + \"};\";\n    }\n"]], "pred": {"ppl": 1.7134345769882202, "ppl_lower": 1.9257252216339111, "ppl/lowercase_ppl": -1.2169039563660569, "ppl/zlib": 0.0008159089101219523, "Min_5.0% Prob": 6.320579642599279, "Min_10.0% Prob": 4.485252404754812, "Min_20.0% Prob": 2.6160766915076197, "Min_30.0% Prob": 1.7830391890068251, "Min_40.0% Prob": 1.346739557971599, "Min_50.0% Prob": 1.0776062790040584, "Min_60.0% Prob": 0.897697082118926}}
{"hexsha": "312f282becf9715a6ec29fbea270e619ab8bcb3b", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({ \"SpringJavaAutowiringInspection\" })\npublic abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {\n    protected AbstractApplicationContext appContext;\n    protected Class<? extends T> targetArgsClass;\n    protected Class<? extends U> targetReturnTypeClass;\n    protected boolean resolveArgs;\n    protected boolean handleReturnValue;\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);\n\n    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs,\n        boolean handleReturnValue) {\n        this.targetArgsClass = targetArgsClass;\n        this.targetReturnTypeClass = targetReturnTypeClass;\n        this.resolveArgs = resolveArgs;\n        this.handleReturnValue = handleReturnValue;\n    }\n\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter methodParam) {\n        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);\n    }\n\n    @Override\n    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n        throws Exception {\n        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);\n\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(),\n            ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));\n    }\n\n    @Nullable\n    @Override\n    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);\n\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(),\n            ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));\n\n        return argObj;\n    }\n\n    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,\n        NativeWebRequest webRequest) throws Exception {\n    }\n\n    @Nullable\n    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext appContext) throws BeansException {\n        this.appContext = (AbstractApplicationContext) appContext;\n    }\n}", "class_id": 0, "repo": "elizabethso/direct-certificate-discovery-tool", "file": "dcdt-web/src/main/java/gov/hhs/onc/dcdt/web/handler/impl/AbstractToolHandlerMethodProcessor.java", "last_update_at": "2021-06-25T19:17:50+00:00", "question_id": "312f282becf9715a6ec29fbea270e619ab8bcb3b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({ \"SpringJavaAutowiringInspection\" })\npublic abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {\n    protected AbstractApplicationContext appContext;\n    protected Class<? extends T> targetArgsClass;\n    protected Class<? extends U> targetReturnTypeClass;\n    protected boolean resolveArgs;\n    protected boolean handleReturnValue;\n    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);\n    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs,\n        boolean handleReturnValue) {\n        this.targetArgsClass = targetArgsClass;\n        this.targetReturnTypeClass = targetReturnTypeClass;\n        this.resolveArgs = resolveArgs;\n        this.handleReturnValue = handleReturnValue;\n    }\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);\n    }\n    @Override\n    public boolean supportsParameter(MethodParameter methodParam) {\n        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);\n    }\n    @Override\n    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n        throws Exception {\n        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(),\n            ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));\n    }\n    @Nullable\n    @Override\n    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(),\n            ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));\n        return argObj;\n    }\n    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,\n        NativeWebRequest webRequest) throws Exception {\n    }\n    @Nullable\n    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n    @Override\n    public void setApplicationContext(ApplicationContext appContext) throws BeansException {\n        this.appContext = (AbstractApplicationContext) appContext;\n    }\n"]], "pred": {"ppl": 1.520201563835144, "ppl_lower": 1.8372116088867188, "ppl/lowercase_ppl": -1.4522126149951502, "ppl/zlib": 0.0005095412820594024, "Min_5.0% Prob": 4.851344722509384, "Min_10.0% Prob": 3.3594936191299816, "Min_20.0% Prob": 2.0023244864370193, "Min_30.0% Prob": 1.3793583664967088, "Min_40.0% Prob": 1.0437926526725383, "Min_50.0% Prob": 0.8366732709280563, "Min_60.0% Prob": 0.6989421556404393}}
{"hexsha": "82ffa0c5c43034bbc57a5c1a00a6cd9ed811d54a", "ext": "java", "lang": "Java", "content": "public class AWSV4AuthParser implements AWSAuthParser {\n\n  private final static Logger LOG =\n      LoggerFactory.getLogger(AWSV4AuthParser.class);\n  private MultivaluedMap<String, String> headerMap;\n  private MultivaluedMap<String, String> queryMap;\n  private String uri;\n  private String method;\n  private AuthorizationHeaderV4 v4Header;\n  private String stringToSign;\n  private String amzContentPayload;\n\n  public AWSV4AuthParser(ContainerRequestContext context)\n      throws OS3Exception {\n    this.headerMap = context.getHeaders();\n    this.queryMap = context.getUriInfo().getQueryParameters();\n    try {\n      this.uri = new URI(context.getUriInfo().getRequestUri()\n          .getPath().replaceAll(\"\\\\/+\",\n              \"/\")).normalize().getPath();\n    } catch (URISyntaxException e) {\n      throw S3_TOKEN_CREATION_ERROR;\n    }\n\n    this.method = context.getMethod();\n    v4Header = new AuthorizationHeaderV4(\n        headerMap.getFirst(AUTHORIZATION_HEADER));\n  }\n\n  public void parse() throws Exception {\n    StringBuilder strToSign = new StringBuilder();\n\n    // According to AWS sigv4 documentation, authorization header should be\n    // in following format.\n    // Authorization: algorithm Credential=access key ID/credential scope,\n    // SignedHeaders=SignedHeaders, Signature=signature\n\n    // Construct String to sign in below format.\n    // StringToSign =\n    //    Algorithm + \\n +\n    //    RequestDateTime + \\n +\n    //    CredentialScope + \\n +\n    //    HashedCanonicalRequest\n    String algorithm, requestDateTime, credentialScope, canonicalRequest;\n    algorithm = v4Header.getAlgorithm();\n    requestDateTime = headerMap.getFirst(X_AMAZ_DATE);\n    Credential credential = v4Header.getCredentialObj();\n    credentialScope = String.format(\"%s/%s/%s/%s\", credential.getDate(),\n        credential.getAwsRegion(), credential.getAwsService(),\n        credential.getAwsRequest());\n\n    // If the absolute path is empty, use a forward slash (/)\n    uri = (uri.trim().length() > 0) ? uri : \"/\";\n    // Encode URI and preserve forward slashes\n    strToSign.append(algorithm + NEWLINE);\n    strToSign.append(requestDateTime + NEWLINE);\n    strToSign.append(credentialScope + NEWLINE);\n\n    canonicalRequest = buildCanonicalRequest();\n    strToSign.append(hash(canonicalRequest));\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n    }\n\n    if (LOG.isTraceEnabled()) {\n      headerMap.keySet().forEach(k -> LOG.trace(\"Header:{},value:{}\", k,\n          headerMap.get(k)));\n    }\n\n    LOG.debug(\"StringToSign:[{}]\", strToSign);\n    stringToSign = strToSign.toString();\n  }\n\n  private String buildCanonicalRequest() throws OS3Exception {\n    Iterable<String> parts = split(\"/\", uri);\n    List<String> encParts = new ArrayList<>();\n    for (String p : parts) {\n      encParts.add(urlEncode(p));\n    }\n    String canonicalUri = join(\"/\", encParts);\n\n    String canonicalQueryStr = getQueryParamString();\n\n    StringBuilder canonicalHeaders = new StringBuilder();\n\n    for (String header : v4Header.getSignedHeaders()) {\n      List<String> headerValue = new ArrayList<>();\n      canonicalHeaders.append(header.toLowerCase());\n      canonicalHeaders.append(\":\");\n      for (String originalHeader : headerMap.keySet()) {\n        if (originalHeader.toLowerCase().equals(header)) {\n          headerValue.add(headerMap.getFirst(originalHeader).trim());\n        }\n      }\n\n      if (headerValue.size() == 0) {\n        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n            \"request\");\n      }\n      if (headerValue.size() > 1) {\n        Collections.sort(headerValue);\n      }\n\n      // Set for testing purpose only to skip date and host validation.\n      validateSignedHeader(header, headerValue.get(0));\n\n      canonicalHeaders.append(join(\",\", headerValue));\n      canonicalHeaders.append(NEWLINE);\n    }\n\n    String payloadHash;\n    if (UNSIGNED_PAYLOAD.equals(\n        headerMap.get(X_AMZ_CONTENT_SHA256))) {\n      payloadHash = UNSIGNED_PAYLOAD;\n    } else {\n      payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);\n    }\n\n    String signedHeaderStr = v4Header.getSignedHeaderString();\n    String canonicalRequest = method + NEWLINE\n        + canonicalUri + NEWLINE\n        + canonicalQueryStr + NEWLINE\n        + canonicalHeaders + NEWLINE\n        + signedHeaderStr + NEWLINE\n        + payloadHash;\n\n    return canonicalRequest;\n  }\n\n  @VisibleForTesting\n  void validateSignedHeader(String header, String headerValue)\n      throws OS3Exception {\n    switch (header) {\n    case HOST:\n      try {\n        URI hostUri = new URI(headerValue);\n        InetAddress.getByName(hostUri.getHost());\n        // TODO: Validate if current request is coming from same host.\n      } catch (UnknownHostException|URISyntaxException e) {\n        LOG.error(\"Host value mentioned in signed header is not valid. \" +\n            \"Host:{}\", headerValue);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMAZ_DATE:\n      LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);\n      LocalDate now = LocalDate.now();\n      if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))\n          || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS,\n          SECONDS))) {\n        LOG.error(\"AWS date not in valid range. Request timestamp:{} should \" +\n                \"not be older than {} seconds.\", headerValue,\n            PRESIGN_URL_MAX_EXPIRATION_SECONDS);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMZ_CONTENT_SHA256:\n      // TODO: Construct request payload and match HEX(SHA256(requestPayload))\n      break;\n    default:\n      break;\n    }\n  }\n\n  /**\n   * String join that also works with empty strings.\n   *\n   * @return joined string\n   */\n  private static String join(String glue, List<String> parts) {\n    StringBuilder result = new StringBuilder();\n    boolean addSeparator = false;\n    for (String p : parts) {\n      if (addSeparator) {\n        result.append(glue);\n      }\n      result.append(p);\n      addSeparator = true;\n    }\n    return result.toString();\n  }\n\n  /**\n   * Returns matching strings.\n   *\n   * @param regex Regular expression to split by\n   * @param whole The string to split\n   * @return pieces\n   */\n  private static Iterable<String> split(String regex, String whole) {\n    Pattern p = Pattern.compile(regex);\n    Matcher m = p.matcher(whole);\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    while (m.find()) {\n      result.add(whole.substring(pos, m.start()));\n      pos = m.end();\n    }\n    result.add(whole.substring(pos));\n    return result;\n  }\n\n  private String urlEncode(String str) {\n    try {\n\n      return URLEncoder.encode(str, UTF_8.name())\n          .replaceAll(\"\\\\+\", \"%20\")\n          .replaceAll(\"%7E\", \"~\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private String getQueryParamString() {\n    List<String> params = new ArrayList<>(queryMap.keySet());\n\n    // Sort by name, then by value\n    Collections.sort(params, (o1, o2) -> o1.equals(o2) ?\n        queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) :\n        o1.compareTo(o2));\n\n    StringBuilder result = new StringBuilder();\n    for (String p : params) {\n      if (result.length() > 0) {\n        result.append(\"&\");\n      }\n      result.append(urlEncode(p));\n      result.append('=');\n\n      result.append(urlEncode(queryMap.getFirst(p)));\n    }\n    return result.toString();\n  }\n\n  public static String hash(String payload) throws NoSuchAlgorithmException {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(payload.getBytes(UTF_8));\n    return Hex.encode(md.digest()).toLowerCase();\n  }\n\n  public String getAwsAccessId() {\n    return v4Header.getAccessKeyID();\n  }\n\n  public String getSignature() {\n    return v4Header.getSignature();\n  }\n\n  public String getStringToSign() throws Exception {\n    return stringToSign;\n  }\n}", "class_id": 0, "repo": "mohammadjkhan/hadoop-ozone", "file": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/AWSV4AuthParser.java", "last_update_at": "2021-09-02T16:12:45+00:00", "question_id": "82ffa0c5c43034bbc57a5c1a00a6cd9ed811d54a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AWSV4AuthParser implements AWSAuthParser {\n  private final static Logger LOG =\n      LoggerFactory.getLogger(AWSV4AuthParser.class);\n  private MultivaluedMap<String, String> headerMap;\n  private MultivaluedMap<String, String> queryMap;\n  private String uri;\n  private String method;\n  private AuthorizationHeaderV4 v4Header;\n  private String stringToSign;\n  private String amzContentPayload;\n  public AWSV4AuthParser(ContainerRequestContext context)\n      throws OS3Exception {\n    this.headerMap = context.getHeaders();\n    this.queryMap = context.getUriInfo().getQueryParameters();\n    try {\n      this.uri = new URI(context.getUriInfo().getRequestUri()\n          .getPath().replaceAll(\"\\\\/+\",\n              \"/\")).normalize().getPath();\n    } catch (URISyntaxException e) {\n      throw S3_TOKEN_CREATION_ERROR;\n    }\n    this.method = context.getMethod();\n    v4Header = new AuthorizationHeaderV4(\n        headerMap.getFirst(AUTHORIZATION_HEADER));\n  }\n  public void parse() throws Exception {\n    StringBuilder strToSign = new StringBuilder();\n    // According to AWS sigv4 documentation, authorization header should be\n    // in following format.\n    // Authorization: algorithm Credential=access key ID/credential scope,\n    // SignedHeaders=SignedHeaders, Signature=signature\n    // Construct String to sign in below format.\n    // StringToSign =\n    //    Algorithm + \\n +\n    //    RequestDateTime + \\n +\n    //    CredentialScope + \\n +\n    //    HashedCanonicalRequest\n    String algorithm, requestDateTime, credentialScope, canonicalRequest;\n    algorithm = v4Header.getAlgorithm();\n    requestDateTime = headerMap.getFirst(X_AMAZ_DATE);\n    Credential credential = v4Header.getCredentialObj();\n    credentialScope = String.format(\"%s/%s/%s/%s\", credential.getDate(),\n        credential.getAwsRegion(), credential.getAwsService(),\n        credential.getAwsRequest());\n    // If the absolute path is empty, use a forward slash (/)\n    uri = (uri.trim().length() > 0) ? uri : \"/\";\n    // Encode URI and preserve forward slashes\n    strToSign.append(algorithm + NEWLINE);\n    strToSign.append(requestDateTime + NEWLINE);\n    strToSign.append(credentialScope + NEWLINE);\n    canonicalRequest = buildCanonicalRequest();\n    strToSign.append(hash(canonicalRequest));\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n    }\n    if (LOG.isTraceEnabled()) {\n      headerMap.keySet().forEach(k -> LOG.trace(\"Header:{},value:{}\", k,\n          headerMap.get(k)));\n    }\n    LOG.debug(\"StringToSign:[{}]\", strToSign);\n    stringToSign = strToSign.toString();\n  }\n  private String buildCanonicalRequest() throws OS3Exception {\n    Iterable<String> parts = split(\"/\", uri);\n    List<String> encParts = new ArrayList<>();\n    for (String p : parts) {\n      encParts.add(urlEncode(p));\n    }\n    String canonicalUri = join(\"/\", encParts);\n    String canonicalQueryStr = getQueryParamString();\n    StringBuilder canonicalHeaders = new StringBuilder();\n    for (String header : v4Header.getSignedHeaders()) {\n      List<String> headerValue = new ArrayList<>();\n      canonicalHeaders.append(header.toLowerCase());\n      canonicalHeaders.append(\":\");\n      for (String originalHeader : headerMap.keySet()) {\n        if (originalHeader.toLowerCase().equals(header)) {\n          headerValue.add(headerMap.getFirst(originalHeader).trim());\n        }\n      }\n      if (headerValue.size() == 0) {\n        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n            \"request\");\n      }\n      if (headerValue.size() > 1) {\n        Collections.sort(headerValue);\n      }\n      // Set for testing purpose only to skip date and host validation.\n      validateSignedHeader(header, headerValue.get(0));\n      canonicalHeaders.append(join(\",\", headerValue));\n      canonicalHeaders.append(NEWLINE);\n    }\n    String payloadHash;\n    if (UNSIGNED_PAYLOAD.equals(\n        headerMap.get(X_AMZ_CONTENT_SHA256))) {\n      payloadHash = UNSIGNED_PAYLOAD;\n    } else {\n      payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);\n    }\n    String signedHeaderStr = v4Header.getSignedHeaderString();\n    String canonicalRequest = method + NEWLINE\n        + canonicalUri + NEWLINE\n        + canonicalQueryStr + NEWLINE\n        + canonicalHeaders + NEWLINE\n        + signedHeaderStr + NEWLINE\n        + payloadHash;\n    return canonicalRequest;\n  }\n  @VisibleForTesting\n  void validateSignedHeader(String header, String headerValue)\n      throws OS3Exception {\n    switch (header) {\n    case HOST:\n      try {\n        URI hostUri = new URI(headerValue);\n        InetAddress.getByName(hostUri.getHost());\n        // TODO: Validate if current request is coming from same host.\n      } catch (UnknownHostException|URISyntaxException e) {\n        LOG.error(\"Host value mentioned in signed header is not valid. \" +\n            \"Host:{}\", headerValue);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMAZ_DATE:\n      LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);\n      LocalDate now = LocalDate.now();\n      if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))\n          || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS,\n          SECONDS))) {\n        LOG.error(\"AWS date not in valid range. Request timestamp:{} should \" +\n                \"not be older than {} seconds.\", headerValue,\n            PRESIGN_URL_MAX_EXPIRATION_SECONDS);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMZ_CONTENT_SHA256:\n      // TODO: Construct request payload and match HEX(SHA256(requestPayload))\n      break;\n    default:\n      break;\n    }\n  }\n  /**\n   * String join that also works with empty strings.\n   *\n   * @return joined string\n   */\n  private static String join(String glue, List<String> parts) {\n    StringBuilder result = new StringBuilder();\n    boolean addSeparator = false;\n    for (String p : parts) {\n      if (addSeparator) {\n        result.append(glue);\n      }\n      result.append(p);\n      addSeparator = true;\n    }\n    return result.toString();\n  }\n  /**\n   * Returns matching strings.\n   *\n   * @param regex Regular expression to split by\n   * @param whole The string to split\n   * @return pieces\n   */\n  private static Iterable<String> split(String regex, String whole) {\n    Pattern p = Pattern.compile(regex);\n    Matcher m = p.matcher(whole);\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    while (m.find()) {\n      result.add(whole.substring(pos, m.start()));\n      pos = m.end();\n    }\n    result.add(whole.substring(pos));\n    return result;\n  }\n  private String urlEncode(String str) {\n    try {\n      return URLEncoder.encode(str, UTF_8.name())\n          .replaceAll(\"\\\\+\", \"%20\")\n          .replaceAll(\"%7E\", \"~\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private String getQueryParamString() {\n    List<String> params = new ArrayList<>(queryMap.keySet());\n    // Sort by name, then by value\n    Collections.sort(params, (o1, o2) -> o1.equals(o2) ?\n        queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) :\n        o1.compareTo(o2));\n    StringBuilder result = new StringBuilder();\n    for (String p : params) {\n      if (result.length() > 0) {\n        result.append(\"&\");\n      }\n      result.append(urlEncode(p));\n      result.append('=');\n      result.append(urlEncode(queryMap.getFirst(p)));\n    }\n    return result.toString();\n  }\n  public static String hash(String payload) throws NoSuchAlgorithmException {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(payload.getBytes(UTF_8));\n    return Hex.encode(md.digest()).toLowerCase();\n  }\n  public String getAwsAccessId() {\n    return v4Header.getAccessKeyID();\n  }\n  public String getSignature() {\n    return v4Header.getSignature();\n  }\n  public String getStringToSign() throws Exception {\n    return stringToSign;\n  }\n"]], "pred": {"ppl": 2.010301351547241, "ppl_lower": 2.302584171295166, "ppl/lowercase_ppl": -1.1944012524332495, "ppl/zlib": 0.000266724460265886, "Min_5.0% Prob": 6.244872420441871, "Min_10.0% Prob": 4.591448825948379, "Min_20.0% Prob": 3.039198201076657, "Min_30.0% Prob": 2.224676213525479, "Min_40.0% Prob": 1.7182694104816627, "Min_50.0% Prob": 1.3909262448345145, "Min_60.0% Prob": 1.1636945530103724}}
{"hexsha": "f162c0c0620935df0e24658be449595dcc99b9e7", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest(classes={ShiroAdminApplication.class})// \u6307\u5b9a\u542f\u52a8\u7c7b\npublic class MonsterlanApplicationTests {\n    @Autowired\n    DataSourceProperties dataSourceProperties;\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    @Test\n    public void contextLoads() {\n        // \u83b7\u53d6\u914d\u7f6e\u7684\u6570\u636e\u6e90\n        DataSource dataSource = applicationContext.getBean(DataSource.class);\n        // \u67e5\u770b\u914d\u7f6e\u6570\u636e\u6e90\u4fe1\u606f\n        //System.out.println(dataSource);\n        //System.out.println(data/Source.getClass().getName());\n        System.out.println(dataSourceProperties.getUrl());\n    }\n}", "class_id": 0, "repo": "supertonsystem/project_management", "file": "shiro-admin/src/test/java/com/suteng/shiro/MonsterlanApplicationTests.java", "last_update_at": "2021-09-24T14:40:48+00:00", "question_id": "f162c0c0620935df0e24658be449595dcc99b9e7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest(classes={ShiroAdminApplication.class})// \u6307\u5b9a\u542f\u52a8\u7c7b\npublic class MonsterlanApplicationTests {\n    @Autowired\n    DataSourceProperties dataSourceProperties;\n    @Autowired\n    ApplicationContext applicationContext;\n    @Test\n    public void contextLoads() {\n        // \u83b7\u53d6\u914d\u7f6e\u7684\u6570\u636e\u6e90\n        DataSource dataSource = applicationContext.getBean(DataSource.class);\n        // \u67e5\u770b\u914d\u7f6e\u6570\u636e\u6e90\u4fe1\u606f\n        //System.out.println(dataSource);\n        //System.out.println(data/Source.getClass().getName());\n        System.out.println(dataSourceProperties.getUrl());\n    }\n"]], "pred": {"ppl": 2.9357106685638428, "ppl_lower": 4.054279804229736, "ppl/lowercase_ppl": -1.2997573119841532, "ppl/zlib": 0.0032147748052740264, "Min_5.0% Prob": 10.4632248878479, "Min_10.0% Prob": 7.321539093466366, "Min_20.0% Prob": 4.64448390688215, "Min_30.0% Prob": 3.431035225207989, "Min_40.0% Prob": 2.640061676927975, "Min_50.0% Prob": 2.1510467133645355, "Min_60.0% Prob": 1.7916535502033575}}
{"hexsha": "5d1826baaf2a8d3a3ee04fea5ba7cdaf784abf75", "ext": "java", "lang": "Java", "content": "public class PaymentPlansApi {\n    private ApiClient apiClient;\n\n    public PaymentPlansApi() {\n        this(Environment.getGlobalEnv().getApiClient());\n    }\n\n    public PaymentPlansApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    /**\n     * Build call for paymentPlansGet\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        if (count != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"count\", count));\n        if (offset != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"offset\", offset));\n        if (fields != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"fields\", fields));\n        if (q != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"q\", q));\n        if (sort != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"sort\", sort));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n\n        return paymentPlansGetCall(count, offset, fields, q, sort);\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return PaymentPlansList\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return ApiResponse&lt;PaymentPlansList&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans (asynchronously)\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansGetById\n     * @param paymentPlanId Payment plan id (required)\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)\");\n        }\n\n        return paymentPlansGetByIdCall(paymentPlanId);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId} (asynchronously)\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPatch\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)\");\n        }\n\n        return paymentPlansPatchCall(paymentPlanId, body);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPost\n     * @param body Payment plan properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {\n\n        return paymentPlansPostCall(body);\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);\n        return resp.getData();\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * POST Payment/Plans (asynchronously)\n     * Add new plan\n     * @param body Payment plan properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPut\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)\");\n        }\n\n        return paymentPlansPutCall(paymentPlanId, body);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}", "class_id": 0, "repo": "secuconnect/secuconnect-java-sdk", "file": "src/main/java/com/secuconnect/client/api/PaymentPlansApi.java", "last_update_at": "2021-12-13T21:45:02+00:00", "question_id": "5d1826baaf2a8d3a3ee04fea5ba7cdaf784abf75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PaymentPlansApi {\n    private ApiClient apiClient;\n    public PaymentPlansApi() {\n        this(Environment.getGlobalEnv().getApiClient());\n    }\n    public PaymentPlansApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n    /**\n     * Build call for paymentPlansGet\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        if (count != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"count\", count));\n        if (offset != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"offset\", offset));\n        if (fields != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"fields\", fields));\n        if (q != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"q\", q));\n        if (sort != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"sort\", sort));\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        return paymentPlansGetCall(count, offset, fields, q, sort);\n    }\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return PaymentPlansList\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);\n        return resp.getData();\n    }\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return ApiResponse&lt;PaymentPlansList&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * GET Payment/Plans (asynchronously)\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansGetById\n     * @param paymentPlanId Payment plan id (required)\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)\");\n        }\n        return paymentPlansGetByIdCall(paymentPlanId);\n    }\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);\n        return resp.getData();\n    }\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * GET Payment/Plans/{paymentPlanId} (asynchronously)\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansPatch\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)\");\n        }\n        return paymentPlansPatchCall(paymentPlanId, body);\n    }\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansPost\n     * @param body Payment plan properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {\n        return paymentPlansPostCall(body);\n    }\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);\n        return resp.getData();\n    }\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * POST Payment/Plans (asynchronously)\n     * Add new plan\n     * @param body Payment plan properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansPut\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)\");\n        }\n        return paymentPlansPutCall(paymentPlanId, body);\n    }\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * PUT Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n"]], "pred": {"ppl": 1.2935388088226318, "ppl_lower": 1.6304208040237427, "ppl/lowercase_ppl": -1.8992729308777478, "ppl/zlib": 0.00010441449296110727, "Min_5.0% Prob": 4.190467832135219, "Min_10.0% Prob": 2.4368335888081907, "Min_20.0% Prob": 1.2827787372995825, "Min_30.0% Prob": 0.8595797607212577, "Min_40.0% Prob": 0.6436240164281841, "Min_50.0% Prob": 0.5152374237092688, "Min_60.0% Prob": 0.42952286064436346}}
{"hexsha": "343375c62eaba4f174329b4d7593ae534bc80666", "ext": "java", "lang": "Java", "content": "public class IOHelper {\n\n    public static void copy(Reader in, Writer out) throws IOException {\n        int c = -1;\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    }\n\n    public static String readFile(File file) throws IOException {\n        Reader in = new FileReader(file);\n        StringWriter out = new StringWriter();\n        copy(in, out);\n        return out.toString();\n    }\n\n    public static void saveFile(File file, String content) throws IOException {\n        Writer writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n}", "class_id": 0, "repo": "uupu/CodeWrench", "file": "src/main/java/com/uupu/wrench/util/IOHelper.java", "last_update_at": "2021-11-25T09:58:54+00:00", "question_id": "343375c62eaba4f174329b4d7593ae534bc80666", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IOHelper {\n    public static void copy(Reader in, Writer out) throws IOException {\n        int c = -1;\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    }\n    public static String readFile(File file) throws IOException {\n        Reader in = new FileReader(file);\n        StringWriter out = new StringWriter();\n        copy(in, out);\n        return out.toString();\n    }\n    public static void saveFile(File file, String content) throws IOException {\n        Writer writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n"]], "pred": {"ppl": 1.48872971534729, "ppl_lower": 1.8722825050354004, "ppl/lowercase_ppl": -1.5760786297057372, "ppl/zlib": 0.0015666268358387986, "Min_5.0% Prob": 4.225889712572098, "Min_10.0% Prob": 2.9114584401249886, "Min_20.0% Prob": 1.8297578524798155, "Min_30.0% Prob": 1.2880151277902174, "Min_40.0% Prob": 0.9930015686612863, "Min_50.0% Prob": 0.7935177993211078, "Min_60.0% Prob": 0.6651301111370249}}
{"hexsha": "5494e9ba86572e92df36c029d9a6c0fb67dd4722", "ext": "java", "lang": "Java", "content": "@XmlRootElement\npublic class IssueUpdates {\n    @XmlElement(name = \"issueUpdate\")\n    public final List<IssueUpdate> issueUpdates = new ArrayList<>();\n\n    @Override\n    public boolean equals(Object otherObject) {\n        return this == otherObject\n            || (otherObject instanceof IssueUpdates\n                && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(issueUpdates);\n    }\n\n    public static class IssueUpdate {\n        public @Nullable String issueKey;\n        public @Nullable Issue issue;\n\n        @Override\n        public boolean equals(@Nullable Object otherObject) {\n            if (this == otherObject) {\n                return true;\n            } else if (otherObject == null || getClass() != otherObject.getClass()) {\n                return false;\n            }\n\n            IssueUpdate other = (IssueUpdate) otherObject;\n            return Objects.equals(issueKey, other.issueKey)\n                && Objects.equals(issue, other.issue);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(issueKey, issue);\n        }\n    }\n}", "class_id": 0, "repo": "fschopp/asana-to-youtrack", "file": "issue-tracking-youtrack/src/main/java/net/florianschoppmann/issuetracking/youtrack/IssueUpdates.java", "last_update_at": "2021-12-07T18:28:16+00:00", "question_id": "5494e9ba86572e92df36c029d9a6c0fb67dd4722", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@XmlRootElement\npublic class IssueUpdates {\n    @XmlElement(name = \"issueUpdate\")\n    public final List<IssueUpdate> issueUpdates = new ArrayList<>();\n    @Override\n    public boolean equals(Object otherObject) {\n        return this == otherObject\n            || (otherObject instanceof IssueUpdates\n                && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(issueUpdates);\n    }\n    public static class IssueUpdate {\n        public @Nullable String issueKey;\n        public @Nullable Issue issue;\n        @Override\n        public boolean equals(@Nullable Object otherObject) {\n            if (this == otherObject) {\n                return true;\n            } else if (otherObject == null || getClass() != otherObject.getClass()) {\n                return false;\n            }\n            IssueUpdate other = (IssueUpdate) otherObject;\n            return Objects.equals(issueKey, other.issueKey)\n                && Objects.equals(issue, other.issue);\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(issueKey, issue);\n        }\n    }\n"]], "pred": {"ppl": 1.4982879161834717, "ppl_lower": 1.8527641296386719, "ppl/lowercase_ppl": -1.525212629289247, "ppl/zlib": 0.0010556738042203648, "Min_5.0% Prob": 4.737276538213094, "Min_10.0% Prob": 3.2546334425608316, "Min_20.0% Prob": 1.9338751212983836, "Min_30.0% Prob": 1.3375150450802111, "Min_40.0% Prob": 1.0072905525687288, "Min_50.0% Prob": 0.810445341189686, "Min_60.0% Prob": 0.6736307368585789}}
{"hexsha": "4731e4fd483b82796b665b993ea78c300897dbb5", "ext": "java", "lang": "Java", "content": "public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {\n\n  /**\n   * the logging facility provided by log4j\n   */\n  private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return type.equals(MediaPackageElement.Type.Track);\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)\n   */\n  @Override\n  public boolean accept(Node elementNode) {\n    String name = elementNode.getNodeName();\n    if (name.contains(\":\")) {\n      name = name.substring(name.indexOf(\":\") + 1);\n    }\n    return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,\n   *      org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return MediaPackageElement.Type.Track.equals(type);\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)\n   */\n  @Override\n  public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {\n    logger.trace(\"Creating track from \" + uri);\n    Track track = TrackImpl.fromURI(uri);\n    return track;\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type\n   *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    Track track = new TrackImpl();\n    track.setFlavor(flavor);\n    return track;\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,\n   *      org.opencastproject.mediapackage.MediaPackageSerializer)\n   */\n  @Override\n  public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer)\n          throws UnsupportedElementException {\n\n    String id = null;\n    MimeType mimeType = null;\n    MediaPackageElementFlavor flavor = null;\n    TrackImpl.StreamingProtocol transport = null;\n    String reference = null;\n    URI url = null;\n    long size = -1;\n    Checksum checksum = null;\n\n    try {\n      // id\n      id = (String) xpath.evaluate(\"@id\", elementNode, XPathConstants.STRING);\n\n      // url\n      url = serializer.decodeURI(new URI(xpath.evaluate(\"url/text()\", elementNode).trim()));\n\n      // reference\n      reference = (String) xpath.evaluate(\"@ref\", elementNode, XPathConstants.STRING);\n\n      // size\n      String trackSize = xpath.evaluate(\"size/text()\", elementNode).trim();\n      if (!\"\".equals(trackSize))\n        size = Long.parseLong(trackSize);\n\n      // flavor\n      String flavorValue = (String) xpath.evaluate(\"@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(flavorValue))\n        flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);\n\n      // transport\n      String transportValue = (String) xpath.evaluate(\"@transport\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(transportValue))\n        transport = TrackImpl.StreamingProtocol.valueOf(transportValue);\n\n      // checksum\n      String checksumValue = (String) xpath.evaluate(\"checksum/text()\", elementNode, XPathConstants.STRING);\n      String checksumType = (String) xpath.evaluate(\"checksum/@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)\n        checksum = Checksum.create(checksumType.trim(), checksumValue.trim());\n\n      // mimetype\n      String mimeTypeValue = (String) xpath.evaluate(\"mimetype/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(mimeTypeValue))\n        mimeType = MimeTypes.parseMimeType(mimeTypeValue);\n\n      //\n      // Build the track\n\n      TrackImpl track = TrackImpl.fromURI(url);\n\n      if (StringUtils.isNotBlank(id))\n        track.setIdentifier(id);\n\n      // Add url\n      track.setURI(url);\n\n      // Add reference\n      if (StringUtils.isNotEmpty(reference))\n        track.referTo(MediaPackageReferenceImpl.fromString(reference));\n\n      // Set size\n      if (size > 0)\n        track.setSize(size);\n\n      // Set checksum\n      if (checksum != null)\n        track.setChecksum(checksum);\n\n      // Set mimetpye\n      if (mimeType != null)\n        track.setMimeType(mimeType);\n\n      if (flavor != null)\n        track.setFlavor(flavor);\n\n      //set transport\n      if (transport != null)\n        track.setTransport(transport);\n\n      // description\n      String description = (String) xpath.evaluate(\"description/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotBlank(description))\n        track.setElementDescription(description.trim());\n\n      // tags\n      NodeList tagNodes = (NodeList) xpath.evaluate(\"tags/tag\", elementNode, XPathConstants.NODESET);\n      for (int i = 0; i < tagNodes.getLength(); i++) {\n        track.addTag(tagNodes.item(i).getTextContent());\n      }\n\n      // duration\n      try {\n        String strDuration = (String) xpath.evaluate(\"duration/text()\", elementNode, XPathConstants.STRING);\n        if (StringUtils.isNotEmpty(strDuration)) {\n          long duration = Long.parseLong(strDuration.trim());\n          track.setDuration(duration);\n        }\n      } catch (NumberFormatException e) {\n        throw new UnsupportedElementException(\"Duration of track \" + url + \" is malformatted\");\n      }\n\n      // is live\n      String strLive = (String) xpath.evaluate(\"live/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(strLive)) {\n        boolean live = Boolean.parseBoolean(strLive.trim());\n        track.setLive(live);\n      }\n\n      // audio settings\n      Node audioSettingsNode = (Node) xpath.evaluate(\"audio\", elementNode, XPathConstants.NODE);\n      if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {\n        try {\n          AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);\n          track.addStream(as);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading audio settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing audio settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n\n      // video settings\n      Node videoSettingsNode = (Node) xpath.evaluate(\"video\", elementNode, XPathConstants.NODE);\n      if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {\n        try {\n          VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);\n          track.addStream(vs);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading video settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing video settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n\n      return track;\n    } catch (XPathExpressionException e) {\n      throw new UnsupportedElementException(\"Error while reading track information from manifest: \" + e.getMessage());\n    } catch (NoSuchAlgorithmException e) {\n      throw new UnsupportedElementException(\"Unsupported digest algorithm: \" + e.getMessage());\n    } catch (URISyntaxException e) {\n      throw new UnsupportedElementException(\"Error while reading presenter track \" + url + \": \" + e.getMessage());\n    }\n  }\n\n  private String createStreamID(Track track) {\n    return \"stream-\" + (track.getStreams().length + 1);\n  }\n\n  @Override\n  public String toString() {\n    return \"Track Builder Plugin\";\n  }\n\n}", "class_id": 0, "repo": "Rillke/opencast", "file": "modules/common/src/main/java/org/opencastproject/mediapackage/elementbuilder/TrackBuilderPlugin.java", "last_update_at": "2021-07-10T13:16:24+00:00", "question_id": "4731e4fd483b82796b665b993ea78c300897dbb5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {\n  /**\n   * the logging facility provided by log4j\n   */\n  private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return type.equals(MediaPackageElement.Type.Track);\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)\n   */\n  @Override\n  public boolean accept(Node elementNode) {\n    String name = elementNode.getNodeName();\n    if (name.contains(\":\")) {\n      name = name.substring(name.indexOf(\":\") + 1);\n    }\n    return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,\n   *      org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return MediaPackageElement.Type.Track.equals(type);\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)\n   */\n  @Override\n  public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {\n    logger.trace(\"Creating track from \" + uri);\n    Track track = TrackImpl.fromURI(uri);\n    return track;\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type\n   *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    Track track = new TrackImpl();\n    track.setFlavor(flavor);\n    return track;\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,\n   *      org.opencastproject.mediapackage.MediaPackageSerializer)\n   */\n  @Override\n  public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer)\n          throws UnsupportedElementException {\n    String id = null;\n    MimeType mimeType = null;\n    MediaPackageElementFlavor flavor = null;\n    TrackImpl.StreamingProtocol transport = null;\n    String reference = null;\n    URI url = null;\n    long size = -1;\n    Checksum checksum = null;\n    try {\n      // id\n      id = (String) xpath.evaluate(\"@id\", elementNode, XPathConstants.STRING);\n      // url\n      url = serializer.decodeURI(new URI(xpath.evaluate(\"url/text()\", elementNode).trim()));\n      // reference\n      reference = (String) xpath.evaluate(\"@ref\", elementNode, XPathConstants.STRING);\n      // size\n      String trackSize = xpath.evaluate(\"size/text()\", elementNode).trim();\n      if (!\"\".equals(trackSize))\n        size = Long.parseLong(trackSize);\n      // flavor\n      String flavorValue = (String) xpath.evaluate(\"@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(flavorValue))\n        flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);\n      // transport\n      String transportValue = (String) xpath.evaluate(\"@transport\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(transportValue))\n        transport = TrackImpl.StreamingProtocol.valueOf(transportValue);\n      // checksum\n      String checksumValue = (String) xpath.evaluate(\"checksum/text()\", elementNode, XPathConstants.STRING);\n      String checksumType = (String) xpath.evaluate(\"checksum/@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)\n        checksum = Checksum.create(checksumType.trim(), checksumValue.trim());\n      // mimetype\n      String mimeTypeValue = (String) xpath.evaluate(\"mimetype/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(mimeTypeValue))\n        mimeType = MimeTypes.parseMimeType(mimeTypeValue);\n      //\n      // Build the track\n      TrackImpl track = TrackImpl.fromURI(url);\n      if (StringUtils.isNotBlank(id))\n        track.setIdentifier(id);\n      // Add url\n      track.setURI(url);\n      // Add reference\n      if (StringUtils.isNotEmpty(reference))\n        track.referTo(MediaPackageReferenceImpl.fromString(reference));\n      // Set size\n      if (size > 0)\n        track.setSize(size);\n      // Set checksum\n      if (checksum != null)\n        track.setChecksum(checksum);\n      // Set mimetpye\n      if (mimeType != null)\n        track.setMimeType(mimeType);\n      if (flavor != null)\n        track.setFlavor(flavor);\n      //set transport\n      if (transport != null)\n        track.setTransport(transport);\n      // description\n      String description = (String) xpath.evaluate(\"description/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotBlank(description))\n        track.setElementDescription(description.trim());\n      // tags\n      NodeList tagNodes = (NodeList) xpath.evaluate(\"tags/tag\", elementNode, XPathConstants.NODESET);\n      for (int i = 0; i < tagNodes.getLength(); i++) {\n        track.addTag(tagNodes.item(i).getTextContent());\n      }\n      // duration\n      try {\n        String strDuration = (String) xpath.evaluate(\"duration/text()\", elementNode, XPathConstants.STRING);\n        if (StringUtils.isNotEmpty(strDuration)) {\n          long duration = Long.parseLong(strDuration.trim());\n          track.setDuration(duration);\n        }\n      } catch (NumberFormatException e) {\n        throw new UnsupportedElementException(\"Duration of track \" + url + \" is malformatted\");\n      }\n      // is live\n      String strLive = (String) xpath.evaluate(\"live/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(strLive)) {\n        boolean live = Boolean.parseBoolean(strLive.trim());\n        track.setLive(live);\n      }\n      // audio settings\n      Node audioSettingsNode = (Node) xpath.evaluate(\"audio\", elementNode, XPathConstants.NODE);\n      if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {\n        try {\n          AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);\n          track.addStream(as);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading audio settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing audio settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n      // video settings\n      Node videoSettingsNode = (Node) xpath.evaluate(\"video\", elementNode, XPathConstants.NODE);\n      if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {\n        try {\n          VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);\n          track.addStream(vs);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading video settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing video settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n      return track;\n    } catch (XPathExpressionException e) {\n      throw new UnsupportedElementException(\"Error while reading track information from manifest: \" + e.getMessage());\n    } catch (NoSuchAlgorithmException e) {\n      throw new UnsupportedElementException(\"Unsupported digest algorithm: \" + e.getMessage());\n    } catch (URISyntaxException e) {\n      throw new UnsupportedElementException(\"Error while reading presenter track \" + url + \": \" + e.getMessage());\n    }\n  }\n  private String createStreamID(Track track) {\n    return \"stream-\" + (track.getStreams().length + 1);\n  }\n  @Override\n  public String toString() {\n    return \"Track Builder Plugin\";\n  }\n"]], "pred": {"ppl": 1.5428866147994995, "ppl_lower": 1.7725739479064941, "ppl/lowercase_ppl": -1.3200184090178237, "ppl/zlib": 0.00023517087151696153, "Min_5.0% Prob": 4.974636133979349, "Min_10.0% Prob": 3.532119019358766, "Min_20.0% Prob": 2.0959564384584333, "Min_30.0% Prob": 1.436668515022771, "Min_40.0% Prob": 1.082133859243417, "Min_50.0% Prob": 0.8675926010991919, "Min_60.0% Prob": 0.7235660390885847}}
{"hexsha": "cd257f0dce4bba1a21fbdb15fd284702dd48600f", "ext": "java", "lang": "Java", "content": "public class SimpleBlockingQueueTest {\n    @Test\n    public void whenUseBlockingQueue() {\n//        SimpleBlockingQueue<Integer> testQueue = new SimpleBlockingQueue<Integer>();\n//\n//        Thread producer = new Thread(() -> {\n//            for (int i = 0; i <= 20;) {\n//                testQueue.offer(++i);\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \" + i);\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        Thread consumer = new Thread(() -> {\n//            try {\n//                Thread.sleep(1000);\n//            } catch (InterruptedException e) {\n//                e.printStackTrace();\n//            }\n//            for (int i = 1; i <= 20; i++) {\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u044b\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u0435\u0442 \" + testQueue.poll());\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        consumer.start();\n//        producer.start();\n//        try {\n//            consumer.join();\n//            producer.join();\n//        } catch (InterruptedException e) {\n//            e.printStackTrace();\n//        }\n    }\n}", "class_id": 0, "repo": "NURGALIMOV/inurgalimov", "file": "level_junior_002/src/test/java/ru/inurgalimov/wait/SimpleBlockingQueueTest.java", "last_update_at": "2021-12-14T21:18:26+00:00", "question_id": "cd257f0dce4bba1a21fbdb15fd284702dd48600f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimpleBlockingQueueTest {\n    @Test\n    public void whenUseBlockingQueue() {\n//        SimpleBlockingQueue<Integer> testQueue = new SimpleBlockingQueue<Integer>();\n//\n//        Thread producer = new Thread(() -> {\n//            for (int i = 0; i <= 20;) {\n//                testQueue.offer(++i);\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \" + i);\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        Thread consumer = new Thread(() -> {\n//            try {\n//                Thread.sleep(1000);\n//            } catch (InterruptedException e) {\n//                e.printStackTrace();\n//            }\n//            for (int i = 1; i <= 20; i++) {\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u044b\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u0435\u0442 \" + testQueue.poll());\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        consumer.start();\n//        producer.start();\n//        try {\n//            consumer.join();\n//            producer.join();\n//        } catch (InterruptedException e) {\n//            e.printStackTrace();\n//        }\n    }\n"]], "pred": {"ppl": 1.4288774728775024, "ppl_lower": 1.6318379640579224, "ppl/lowercase_ppl": -1.3721542448882738, "ppl/zlib": 0.0008579066154057625, "Min_5.0% Prob": 4.670128107070923, "Min_10.0% Prob": 3.030068428088457, "Min_20.0% Prob": 1.736283292687392, "Min_30.0% Prob": 1.1793582741202426, "Min_40.0% Prob": 0.8936814702339942, "Min_50.0% Prob": 0.7147210059955603, "Min_60.0% Prob": 0.5950299334544062}}
{"hexsha": "2fdee659338464d3cee41b3776ec8893a1c5cafb", "ext": "java", "lang": "Java", "content": "public class HttpClientUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);\n\t\n    public static CloseableHttpClient getHttpClient (HasProxySettings proxySetting) {\n    \t// http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e475\n    \t\n    \tCloseableHttpClient httpclient = null ;\n    \tif (proxySetting != null && proxySetting.isActive()) {\n    \t\tlogger.info(\"Set the http proxy (\" + proxySetting.getHost() + \":\" + proxySetting.getPort() + \")\") ;\n    \t\tCredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider()) ;\n        \tHttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());\n        \tDefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);\n        \thttpclient = HttpClients.custom()\n        \t        .setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider)\n        \t        .build();\n    \t} else {\n    \t\thttpclient = HttpClients.createDefault();\n    \t}\n    \treturn httpclient ;\n    }\n}", "class_id": 0, "repo": "hjg0706/google_Drive", "file": "src/main/java/io/uploader/drive/drive/largefile/HttpClientUtils.java", "last_update_at": "2021-11-27T05:58:07+00:00", "question_id": "2fdee659338464d3cee41b3776ec8893a1c5cafb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HttpClientUtils {\n\tprivate static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);\n\t\n    public static CloseableHttpClient getHttpClient (HasProxySettings proxySetting) {\n    \t// http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e475\n    \t\n    \tCloseableHttpClient httpclient = null ;\n    \tif (proxySetting != null && proxySetting.isActive()) {\n    \t\tlogger.info(\"Set the http proxy (\" + proxySetting.getHost() + \":\" + proxySetting.getPort() + \")\") ;\n    \t\tCredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider()) ;\n        \tHttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());\n        \tDefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);\n        \thttpclient = HttpClients.custom()\n        \t        .setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider)\n        \t        .build();\n    \t} else {\n    \t\thttpclient = HttpClients.createDefault();\n    \t}\n    \treturn httpclient ;\n    }\n"]], "pred": {"ppl": 1.9087103605270386, "ppl_lower": 2.339200019836426, "ppl/lowercase_ppl": -1.3146232043000157, "ppl/zlib": 0.0014301500223300242, "Min_5.0% Prob": 6.6966568311055505, "Min_10.0% Prob": 4.792721970876058, "Min_20.0% Prob": 2.9524646401405334, "Min_30.0% Prob": 2.0936308364073435, "Min_40.0% Prob": 1.6045581909207007, "Min_50.0% Prob": 1.2920394749070208, "Min_60.0% Prob": 1.079593242953221}}
{"hexsha": "382e9cd082afd4101e37c36d08eb9143aed3b34e", "ext": "java", "lang": "Java", "content": "public class Resources {\n  public static Path getResourcePath(String path) throws URISyntaxException {\n    ClassLoader classLoader = Stream\n        .of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null)\n        .findFirst().get();\n\n    return Paths.get(classLoader.getResource(path).toURI());\n  }\n\n  public static String getResource(String file) throws IOException, URISyntaxException {\n    Path path = getResourcePath(file);\n    return new String(Files.readAllBytes(path));\n  }\n\n  public static List<String> listResources(String dir) throws IOException, URISyntaxException {\n    Path dirpath = getResourcePath(dir);\n\n    List<String> filenames = null;\n\n    try (Stream<Path> walk = Files.walk(dirpath)) {\n      filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString())\n          .collect(Collectors.toList());\n    } catch (IOException e) {\n      throw e;\n    }\n\n    return filenames;\n  }\n}", "class_id": 0, "repo": "craft-ai/craft-ai-client-java", "file": "src/test/java/com/craft_ai/interpreter/tools/Resources.java", "last_update_at": "2021-12-09T21:16:39+00:00", "question_id": "382e9cd082afd4101e37c36d08eb9143aed3b34e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Resources {\n  public static Path getResourcePath(String path) throws URISyntaxException {\n    ClassLoader classLoader = Stream\n        .of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null)\n        .findFirst().get();\n    return Paths.get(classLoader.getResource(path).toURI());\n  }\n  public static String getResource(String file) throws IOException, URISyntaxException {\n    Path path = getResourcePath(file);\n    return new String(Files.readAllBytes(path));\n  }\n  public static List<String> listResources(String dir) throws IOException, URISyntaxException {\n    Path dirpath = getResourcePath(dir);\n    List<String> filenames = null;\n    try (Stream<Path> walk = Files.walk(dirpath)) {\n      filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString())\n          .collect(Collectors.toList());\n    } catch (IOException e) {\n      throw e;\n    }\n    return filenames;\n  }\n"]], "pred": {"ppl": 1.716704249382019, "ppl_lower": 2.3342714309692383, "ppl/lowercase_ppl": -1.5686341780969504, "ppl/zlib": 0.001256758880492523, "Min_5.0% Prob": 6.062876786504473, "Min_10.0% Prob": 4.106003931590489, "Min_20.0% Prob": 2.5213176513973035, "Min_30.0% Prob": 1.7778071122134433, "Min_40.0% Prob": 1.3433952141030316, "Min_50.0% Prob": 1.082390431898423, "Min_60.0% Prob": 0.8999091480104308}}
{"hexsha": "1933efc9aa1b1d5e9b432865d575e9d6ff573c10", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"api/v1\")\npublic class CollaboratorController {\n\n\t@Autowired\n\tCollaboratorService collaboratorServ;\n\t\n\t@ApiOperation(value = \"Get All the Collaborators\")\n\t@GetMapping(\"/collaborators\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators(){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaborators();\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\n\t@ApiOperation(value = \"Get Collaborators by Organization\")\n\t@GetMapping(\"/collaborators/organization_id/{org_id}\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable(\"org_id\") Long org_id){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\n\t@ApiOperation(value = \"Get All the Collaborator Types\")\n\t@GetMapping(\"/collaborators/type\")\n\tpublic ResponseEntity<List<CollaboratorType>> getCollaboratorTypes(){\n\t\tList<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(types);\n\t}\n\t\n\t@ApiOperation(value = \"Get one Collaborator\")\n\t@GetMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable(\"id\") Long id){\n\t\tCollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\n\t@ApiOperation(value = \"Get one Main Contact\")\n\t@GetMapping(\"/main_contact/{id}\")\n\tpublic ResponseEntity<MainContactResponse> getMainContactId(@PathVariable(\"id\") Long id){\n\t\tMainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Create a Collaborator\")\n\t@PostMapping(\"/collaborator\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator){\n\t\tCollaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);\n\t}\n\n\t@ApiOperation(value = \"Create a Main Contact\")\n\t@PostMapping(\"/main_contact\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact){\n\t\tCollaborator new_main_contact = collaboratorServ.createMainContact(main_contact);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);\n\t}\n\t\n\t@ApiOperation(value = \"Update a Collaborator\")\n\t@PatchMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<Collaborator> updateCollaborator(@PathVariable(\"id\") Long id, @RequestBody Collaborator collaborator){\n\t\tCollaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Delete a Collaborator\")\n\t@DeleteMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<?> deleteCollaborator(@PathVariable(\"id\") Long id){\n\t\tcollaboratorServ.deleteCollaborator(id);\n\t\treturn ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"Delete Collaborator with ID: \" + id);\n\t}\n\n\t@ResponseStatus(HttpStatus.BAD_REQUEST)\n\t@ExceptionHandler(MethodArgumentNotValidException.class)\n\tpublic Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {\n\t\tMap<String, String> errors = new HashMap<>();\n\t\tex.getBindingResult().getAllErrors().forEach((error) -> {\n\t\t\tString fieldName = ((FieldError) error).getField();\n\t\t\tString errorMessage = error.getDefaultMessage();\n\t\t\terrors.put(fieldName, errorMessage);\n\t\t});\n\t\treturn errors;\n\t}\n}", "class_id": 0, "repo": "Mongen-Initiative/mongen-core", "file": "src/main/java/org/mongen/core/controller/CollaboratorController.java", "last_update_at": "2021-03-12T01:49:51+00:00", "question_id": "1933efc9aa1b1d5e9b432865d575e9d6ff573c10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"api/v1\")\npublic class CollaboratorController {\n\t@Autowired\n\tCollaboratorService collaboratorServ;\n\t\n\t@ApiOperation(value = \"Get All the Collaborators\")\n\t@GetMapping(\"/collaborators\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators(){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaborators();\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\t@ApiOperation(value = \"Get Collaborators by Organization\")\n\t@GetMapping(\"/collaborators/organization_id/{org_id}\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable(\"org_id\") Long org_id){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\t@ApiOperation(value = \"Get All the Collaborator Types\")\n\t@GetMapping(\"/collaborators/type\")\n\tpublic ResponseEntity<List<CollaboratorType>> getCollaboratorTypes(){\n\t\tList<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(types);\n\t}\n\t\n\t@ApiOperation(value = \"Get one Collaborator\")\n\t@GetMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable(\"id\") Long id){\n\t\tCollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\t@ApiOperation(value = \"Get one Main Contact\")\n\t@GetMapping(\"/main_contact/{id}\")\n\tpublic ResponseEntity<MainContactResponse> getMainContactId(@PathVariable(\"id\") Long id){\n\t\tMainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Create a Collaborator\")\n\t@PostMapping(\"/collaborator\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator){\n\t\tCollaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);\n\t}\n\t@ApiOperation(value = \"Create a Main Contact\")\n\t@PostMapping(\"/main_contact\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact){\n\t\tCollaborator new_main_contact = collaboratorServ.createMainContact(main_contact);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);\n\t}\n\t\n\t@ApiOperation(value = \"Update a Collaborator\")\n\t@PatchMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<Collaborator> updateCollaborator(@PathVariable(\"id\") Long id, @RequestBody Collaborator collaborator){\n\t\tCollaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Delete a Collaborator\")\n\t@DeleteMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<?> deleteCollaborator(@PathVariable(\"id\") Long id){\n\t\tcollaboratorServ.deleteCollaborator(id);\n\t\treturn ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"Delete Collaborator with ID: \" + id);\n\t}\n\t@ResponseStatus(HttpStatus.BAD_REQUEST)\n\t@ExceptionHandler(MethodArgumentNotValidException.class)\n\tpublic Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {\n\t\tMap<String, String> errors = new HashMap<>();\n\t\tex.getBindingResult().getAllErrors().forEach((error) -> {\n\t\t\tString fieldName = ((FieldError) error).getField();\n\t\t\tString errorMessage = error.getDefaultMessage();\n\t\t\terrors.put(fieldName, errorMessage);\n\t\t});\n\t\treturn errors;\n\t}\n"]], "pred": {"ppl": 1.372091293334961, "ppl_lower": 1.4702492952346802, "ppl/lowercase_ppl": -1.2184256387478942, "ppl/zlib": 0.000356635927194575, "Min_5.0% Prob": 4.338679825558382, "Min_10.0% Prob": 2.727745426051757, "Min_20.0% Prob": 1.532650046488818, "Min_30.0% Prob": 1.0456669164784984, "Min_40.0% Prob": 0.7876876440368283, "Min_50.0% Prob": 0.6321166764813568, "Min_60.0% Prob": 0.5275658122548715}}
{"hexsha": "359cc5c8d7ac575f7adc9a4e147dd319b2dcdb15", "ext": "java", "lang": "Java", "content": "public class GetFilingPackageSD {\r\n\r\n    private final OauthService oauthService;\r\n    private final SubmissionService submissionService;\r\n    private final UUID actualTransactionId;\r\n    private UserIdentity actualUserIdentity;\r\n    private Response actualFilingPackageResponse;\r\n\r\n    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);\r\n\r\n    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {\r\n        this.oauthService = oauthService;\r\n        this.submissionService = submissionService;\r\n        actualTransactionId = UUID.randomUUID();\r\n    }\r\n\r\n    @Given(\"valid user account is authenticated\")\r\n    public void validAdminAccountThatAuthenticated() {\r\n\r\n        actualUserIdentity = oauthService.getUserIdentity();\r\n    }\r\n\r\n    @When(\"user submits request to get filing package information\")\r\n    public void filingPackageRequest() throws IOException {\r\n        logger.info(\"Submitting get filing package request\");\r\n\r\n\r\n        File resource = new ClassPathResource(\r\n                MessageFormat.format(\"data/{0}\", Keys.TEST_DOCUMENT_PDF)).getFile();\r\n\r\n        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, \"text/application.pdf\");\r\n\r\n        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId,\r\n                actualUserIdentity.getUniversalId(), fileSpec);\r\n\r\n        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);\r\n\r\n        // Generate Url Response\r\n        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(),\r\n                                                    actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);\r\n\r\n        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(),actualTransactionId,\r\n                actualSubmissionId, Keys.FILING_PACKAGE_PATH);\r\n\r\n        logger.info(\"Api response status code: {}\", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));\r\n        logger.info(\"Api response: {}\", actualFilingPackageResponse.asString());\r\n    }\r\n\r\n    @Then(\"a valid filing package information is returned\")\r\n    public void getFilingPackageResults() {\r\n\r\n        logger.info(\"Asserting get filing package response\");\r\n\r\n        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());\r\n\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"submissionFeeAmount\"));\r\n\r\n        Assert.assertEquals(\"1211\", filingPackageJsonPath.get(\"court.location\"));\r\n        Assert.assertEquals(\"P\", filingPackageJsonPath.get(\"court.level\"));\r\n        Assert.assertEquals(\"F\", filingPackageJsonPath.get(\"court.courtClass\"));\r\n        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get(\"court.agencyId\"));\r\n\r\n        Assert.assertEquals(\"Imma Court\", filingPackageJsonPath.get(\"court.locationDescription\"));\r\n        Assert.assertEquals(\"Imma Level\", filingPackageJsonPath.get(\"court.levelDescription\"));\r\n        Assert.assertEquals(\"Imma Class\", filingPackageJsonPath.get(\"court.classDescription\"));\r\n\r\n        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get(\"documents.documentProperties.name[0]\"));\r\n\r\n        Assert.assertEquals(\"AFF\", filingPackageJsonPath.get(\"documents.documentProperties.type[0]\"));\r\n        Assert.assertEquals(\"This is a doc\", filingPackageJsonPath.get(\"documents.description[0]\"));\r\n        Assert.assertEquals(\"application/pdf\", filingPackageJsonPath.get(\"documents.mimeType[0]\"));\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"documents.statutoryFeeAmount[0]\"));\r\n\r\n        Assert.assertEquals(\"first\", filingPackageJsonPath.get(\"parties.firstName[0]\"));\r\n        Assert.assertEquals(\"middle\", filingPackageJsonPath.get(\"parties.middleName[0]\"));\r\n        Assert.assertEquals(\"last\", filingPackageJsonPath.get(\"parties.lastName[0]\"));\r\n\r\n        logger.info(\"Response matches the requirements\");\r\n\r\n    }\r\n\r\n}", "class_id": 0, "repo": "yousiefc/jag-file-submission", "file": "tests/src/test/java/ca/bc/gov/open/jag/efiling/stepDefinitions/GetFilingPackageSD.java", "last_update_at": "2021-12-13T16:25:39+00:00", "question_id": "359cc5c8d7ac575f7adc9a4e147dd319b2dcdb15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetFilingPackageSD {\r\n\r\n    private final OauthService oauthService;\r\n    private final SubmissionService submissionService;\r\n    private final UUID actualTransactionId;\r\n    private UserIdentity actualUserIdentity;\r\n    private Response actualFilingPackageResponse;\r\n\r\n    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);\r\n\r\n    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {\r\n        this.oauthService = oauthService;\r\n        this.submissionService = submissionService;\r\n        actualTransactionId = UUID.randomUUID();\r\n    }\r\n\r\n    @Given(\"valid user account is authenticated\")\r\n    public void validAdminAccountThatAuthenticated() {\r\n\r\n        actualUserIdentity = oauthService.getUserIdentity();\r\n    }\r\n\r\n    @When(\"user submits request to get filing package information\")\r\n    public void filingPackageRequest() throws IOException {\r\n        logger.info(\"Submitting get filing package request\");\r\n\r\n\r\n        File resource = new ClassPathResource(\r\n                MessageFormat.format(\"data/{0}\", Keys.TEST_DOCUMENT_PDF)).getFile();\r\n\r\n        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, \"text/application.pdf\");\r\n\r\n        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId,\r\n                actualUserIdentity.getUniversalId(), fileSpec);\r\n\r\n        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);\r\n\r\n        // Generate Url Response\r\n        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(),\r\n                                                    actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);\r\n\r\n        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(),actualTransactionId,\r\n                actualSubmissionId, Keys.FILING_PACKAGE_PATH);\r\n\r\n        logger.info(\"Api response status code: {}\", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));\r\n        logger.info(\"Api response: {}\", actualFilingPackageResponse.asString());\r\n    }\r\n\r\n    @Then(\"a valid filing package information is returned\")\r\n    public void getFilingPackageResults() {\r\n\r\n        logger.info(\"Asserting get filing package response\");\r\n\r\n        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());\r\n\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"submissionFeeAmount\"));\r\n\r\n        Assert.assertEquals(\"1211\", filingPackageJsonPath.get(\"court.location\"));\r\n        Assert.assertEquals(\"P\", filingPackageJsonPath.get(\"court.level\"));\r\n        Assert.assertEquals(\"F\", filingPackageJsonPath.get(\"court.courtClass\"));\r\n        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get(\"court.agencyId\"));\r\n\r\n        Assert.assertEquals(\"Imma Court\", filingPackageJsonPath.get(\"court.locationDescription\"));\r\n        Assert.assertEquals(\"Imma Level\", filingPackageJsonPath.get(\"court.levelDescription\"));\r\n        Assert.assertEquals(\"Imma Class\", filingPackageJsonPath.get(\"court.classDescription\"));\r\n\r\n        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get(\"documents.documentProperties.name[0]\"));\r\n\r\n        Assert.assertEquals(\"AFF\", filingPackageJsonPath.get(\"documents.documentProperties.type[0]\"));\r\n        Assert.assertEquals(\"This is a doc\", filingPackageJsonPath.get(\"documents.description[0]\"));\r\n        Assert.assertEquals(\"application/pdf\", filingPackageJsonPath.get(\"documents.mimeType[0]\"));\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"documents.statutoryFeeAmount[0]\"));\r\n\r\n        Assert.assertEquals(\"first\", filingPackageJsonPath.get(\"parties.firstName[0]\"));\r\n        Assert.assertEquals(\"middle\", filingPackageJsonPath.get(\"parties.middleName[0]\"));\r\n        Assert.assertEquals(\"last\", filingPackageJsonPath.get(\"parties.lastName[0]\"));\r\n\r\n        logger.info(\"Response matches the requirements\");\r\n\r\n    }\r\n\r\n"]], "pred": {"ppl": 2.155470848083496, "ppl_lower": 2.4908690452575684, "ppl/lowercase_ppl": -1.1883082583125029, "ppl/zlib": 0.0007078425720553478, "Min_5.0% Prob": 6.88613998188692, "Min_10.0% Prob": 5.229507072299135, "Min_20.0% Prob": 3.4394887142321644, "Min_30.0% Prob": 2.489318874828956, "Min_40.0% Prob": 1.9064861110304563, "Min_50.0% Prob": 1.5347519372890608, "Min_60.0% Prob": 1.2812227041264586}}
{"hexsha": "86b5e913c45589f56c85f9e8a132f6c76a82df60", "ext": "java", "lang": "Java", "content": "public final class ConverterStore {\r\n  private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] {\r\n      new ArrayConverter(), new CollectionConverter(), new MapConverter(),\r\n      new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(),\r\n      new BooleanConverter(), new CharacterConverter(), new DateConverter(),\r\n      new CalendarConverter() };\r\n\r\n  private final List<ConditionalConverter<?, ?>> converters;\r\n\r\n  public ConverterStore() {\r\n    this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));\r\n  }\r\n\r\n  ConverterStore(List<ConditionalConverter<?, ?>> converters) {\r\n    this.converters = converters;\r\n  }\r\n\r\n  /**\r\n   * Returns the first converter that supports converting from {@code sourceType} to\r\n   * {@code destinationType}. It will select converter that was full match first.\r\n   * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter\r\n   * exists.\r\n   */\r\n  @SuppressWarnings(\"unchecked\")\r\n  public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType,\r\n      Class<?> destinationType) {\r\n    ConditionalConverter<S, D> firstPartialMatchConverter = null;\r\n\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      MatchResult matchResult = converter.match(sourceType, destinationType);\r\n      if (matchResult == MatchResult.FULL)\r\n        return (ConditionalConverter<S, D>) converter;\r\n      if (firstPartialMatchConverter == null\r\n          && matchResult == MatchResult.PARTIAL)\r\n        firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;\r\n    }\r\n    return firstPartialMatchConverter;\r\n  }\r\n\r\n  public List<ConditionalConverter<?, ?>> getConverters() {\r\n    return converters;\r\n  }\r\n\r\n  public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);\r\n    if (matchConverter != null)\r\n      converters.remove(matchConverter);\r\n    return this;\r\n  }\r\n\r\n  public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    return getConverterByType(converterClass) != null;\r\n  }\r\n\r\n  public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {\r\n    converters.add(converter);\r\n    return this;\r\n  }\r\n\r\n  private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      if (converter.getClass().equals(converterClass))\r\n        return converter;\r\n    }\r\n    return null;\r\n  }\r\n}", "class_id": 0, "repo": "codehumane/modelmapper", "file": "core/src/main/java/org/modelmapper/internal/converter/ConverterStore.java", "last_update_at": "2021-01-27T15:06:18+00:00", "question_id": "86b5e913c45589f56c85f9e8a132f6c76a82df60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ConverterStore {\r\n  private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] {\r\n      new ArrayConverter(), new CollectionConverter(), new MapConverter(),\r\n      new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(),\r\n      new BooleanConverter(), new CharacterConverter(), new DateConverter(),\r\n      new CalendarConverter() };\r\n\r\n  private final List<ConditionalConverter<?, ?>> converters;\r\n\r\n  public ConverterStore() {\r\n    this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));\r\n  }\r\n\r\n  ConverterStore(List<ConditionalConverter<?, ?>> converters) {\r\n    this.converters = converters;\r\n  }\r\n\r\n  /**\r\n   * Returns the first converter that supports converting from {@code sourceType} to\r\n   * {@code destinationType}. It will select converter that was full match first.\r\n   * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter\r\n   * exists.\r\n   */\r\n  @SuppressWarnings(\"unchecked\")\r\n  public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType,\r\n      Class<?> destinationType) {\r\n    ConditionalConverter<S, D> firstPartialMatchConverter = null;\r\n\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      MatchResult matchResult = converter.match(sourceType, destinationType);\r\n      if (matchResult == MatchResult.FULL)\r\n        return (ConditionalConverter<S, D>) converter;\r\n      if (firstPartialMatchConverter == null\r\n          && matchResult == MatchResult.PARTIAL)\r\n        firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;\r\n    }\r\n    return firstPartialMatchConverter;\r\n  }\r\n\r\n  public List<ConditionalConverter<?, ?>> getConverters() {\r\n    return converters;\r\n  }\r\n\r\n  public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);\r\n    if (matchConverter != null)\r\n      converters.remove(matchConverter);\r\n    return this;\r\n  }\r\n\r\n  public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    return getConverterByType(converterClass) != null;\r\n  }\r\n\r\n  public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {\r\n    converters.add(converter);\r\n    return this;\r\n  }\r\n\r\n  private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      if (converter.getClass().equals(converterClass))\r\n        return converter;\r\n    }\r\n    return null;\r\n  }\r\n"]], "pred": {"ppl": 1.62165105342865, "ppl_lower": 1.7280466556549072, "ppl/lowercase_ppl": -1.1314459704975446, "ppl/zlib": 0.0006489191933255142, "Min_5.0% Prob": 5.133561611175537, "Min_10.0% Prob": 3.659115050520216, "Min_20.0% Prob": 2.279668834826625, "Min_30.0% Prob": 1.5908164334887605, "Min_40.0% Prob": 1.2082497667428767, "Min_50.0% Prob": 0.9674209582410943, "Min_60.0% Prob": 0.8059377354324821}}
{"hexsha": "538720e56e824c6567f939adc18ccbf7ee54aa80", "ext": "java", "lang": "Java", "content": "public class LevelSelectFragment extends Fragment implements View.OnClickListener {\n\n  @Nullable\n  @Override\n  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n      @Nullable Bundle savedInstanceState) {\n    View view= inflater.inflate(R.layout.fragment_level_select, container, false);\n    view.findViewById(R.id.button_one).setOnClickListener(this);\n    view.findViewById(R.id.button_two).setOnClickListener(this);\n    view.findViewById(R.id.button_three).setOnClickListener(this);\n    view.findViewById(R.id.button_four).setOnClickListener(this);\n    view.findViewById(R.id.button_five).setOnClickListener(this);\n    view.findViewById(R.id.button_six).setOnClickListener(this);\n    view.findViewById(R.id.button_seven).setOnClickListener(this);\n    view.findViewById(R.id.button_eight).setOnClickListener(this);\n    view.findViewById(R.id.button_nine).setOnClickListener(this);\n    view.findViewById(R.id.button_ten).setOnClickListener(this);\n    view.findViewById(R.id.button_eleven).setOnClickListener(this);\n    view.findViewById(R.id.button_twelve).setOnClickListener(this);\n    view.findViewById(R.id.button_thirteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fourteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fifteen).setOnClickListener(this);\n    return view;\n  }\n\n  @Override\n  public void onClick(View v) {\n    int level = Integer.parseInt(v.getTag().toString());\n    int sizeColumns = level + 3;\n    int sizeRows= (int)(sizeColumns * 4/3);\n    System.out.println(\"v.getTag='\" + v.getTag() +\"', level = \" + level);\n\n    MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);\n    FragmentTransaction ft= getFragmentManager().beginTransaction();\n    ft.addToBackStack(MazeFragment.class.getSimpleName());\n    ft.replace(R.id.fragment_container, maze).commit();\n  }\n\n  @Override\n  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n  }\n}", "class_id": 0, "repo": "edubois9119/a-maze-ballz", "file": "app/src/main/java/com/ericadubois/amazeballz/controller/LevelSelectFragment.java", "last_update_at": "2021-11-28T22:43:26+00:00", "question_id": "538720e56e824c6567f939adc18ccbf7ee54aa80", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LevelSelectFragment extends Fragment implements View.OnClickListener {\n  @Nullable\n  @Override\n  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n      @Nullable Bundle savedInstanceState) {\n    View view= inflater.inflate(R.layout.fragment_level_select, container, false);\n    view.findViewById(R.id.button_one).setOnClickListener(this);\n    view.findViewById(R.id.button_two).setOnClickListener(this);\n    view.findViewById(R.id.button_three).setOnClickListener(this);\n    view.findViewById(R.id.button_four).setOnClickListener(this);\n    view.findViewById(R.id.button_five).setOnClickListener(this);\n    view.findViewById(R.id.button_six).setOnClickListener(this);\n    view.findViewById(R.id.button_seven).setOnClickListener(this);\n    view.findViewById(R.id.button_eight).setOnClickListener(this);\n    view.findViewById(R.id.button_nine).setOnClickListener(this);\n    view.findViewById(R.id.button_ten).setOnClickListener(this);\n    view.findViewById(R.id.button_eleven).setOnClickListener(this);\n    view.findViewById(R.id.button_twelve).setOnClickListener(this);\n    view.findViewById(R.id.button_thirteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fourteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fifteen).setOnClickListener(this);\n    return view;\n  }\n  @Override\n  public void onClick(View v) {\n    int level = Integer.parseInt(v.getTag().toString());\n    int sizeColumns = level + 3;\n    int sizeRows= (int)(sizeColumns * 4/3);\n    System.out.println(\"v.getTag='\" + v.getTag() +\"', level = \" + level);\n    MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);\n    FragmentTransaction ft= getFragmentManager().beginTransaction();\n    ft.addToBackStack(MazeFragment.class.getSimpleName());\n    ft.replace(R.id.fragment_container, maze).commit();\n  }\n  @Override\n  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n  }\n"]], "pred": {"ppl": 1.455249547958374, "ppl_lower": 1.5251555442810059, "ppl/lowercase_ppl": -1.1250581858048014, "ppl/zlib": 0.0006391437760502593, "Min_5.0% Prob": 4.986384128702098, "Min_10.0% Prob": 3.2944912591884874, "Min_20.0% Prob": 1.842758539140734, "Min_30.0% Prob": 1.247352710438215, "Min_40.0% Prob": 0.9389324690591782, "Min_50.0% Prob": 0.7513809596207373, "Min_60.0% Prob": 0.6259498552848135}}
{"hexsha": "e94bc548a7921195722fe2cbedc8ac5317dc5070", "ext": "java", "lang": "Java", "content": "public class Location {\n    private static Pattern pattern = Pattern.compile(\"(\\\\S+), (\\\\S+), (\\\\S+)\");\n    private double x;\n    private double y;\n    private double z;\n\n    Location(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    private Location(String x, String y, String z) {\n        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));\n    }\n\n    /**\n     * Construct Location object from comma separated string\n     *\n     * @param str comma separated string, e.g. 1.0, 2.0, 3.0\n     * @return Location object from string data\n     */\n    public static Location fromString(String str) {\n        if (str == null) throw new IllegalArgumentException(\"str must not be null\");\n\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));\n        }\n        return null;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public void setX(long x) {\n        this.x = x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setY(long y) {\n        this.y = y;\n    }\n\n    public double getZ() {\n        return z;\n    }\n\n    public void setZ(long z) {\n        this.z = z;\n    }\n\n    @Override\n    public String toString() {\n        return this.x + \", \" + this.y + \", \" + this.z;\n    }\n}", "class_id": 0, "repo": "Trikolon/GitHubTickets", "file": "src/main/java/com/tallcraft/githubtickets/ticket/Location.java", "last_update_at": "2021-04-21T18:39:59+00:00", "question_id": "e94bc548a7921195722fe2cbedc8ac5317dc5070", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Location {\n    private static Pattern pattern = Pattern.compile(\"(\\\\S+), (\\\\S+), (\\\\S+)\");\n    private double x;\n    private double y;\n    private double z;\n    Location(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    private Location(String x, String y, String z) {\n        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));\n    }\n    /**\n     * Construct Location object from comma separated string\n     *\n     * @param str comma separated string, e.g. 1.0, 2.0, 3.0\n     * @return Location object from string data\n     */\n    public static Location fromString(String str) {\n        if (str == null) throw new IllegalArgumentException(\"str must not be null\");\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));\n        }\n        return null;\n    }\n    public double getX() {\n        return x;\n    }\n    public void setX(long x) {\n        this.x = x;\n    }\n    public double getY() {\n        return y;\n    }\n    public void setY(long y) {\n        this.y = y;\n    }\n    public double getZ() {\n        return z;\n    }\n    public void setZ(long z) {\n        this.z = z;\n    }\n    @Override\n    public String toString() {\n        return this.x + \", \" + this.y + \", \" + this.z;\n    }\n"]], "pred": {"ppl": 1.4416950941085815, "ppl_lower": 1.6087919473648071, "ppl/lowercase_ppl": -1.2997761550173732, "ppl/zlib": 0.000745050040688689, "Min_5.0% Prob": 4.58752517266707, "Min_10.0% Prob": 3.1104071492498573, "Min_20.0% Prob": 1.7745579546422101, "Min_30.0% Prob": 1.2131137199588675, "Min_40.0% Prob": 0.9131008356070801, "Min_50.0% Prob": 0.7309469489617706, "Min_60.0% Prob": 0.6112662986782726}}
{"hexsha": "b194a3017d75dc57bcc64346c80eb6e40c252975", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2022-01-08T01:37:46.955Z\")\npublic class RegisterTopicExample {\n  @SerializedName(\"id\")\n  private String id = null;\n\n  @SerializedName(\"kind\")\n  private String kind = null;\n\n  @SerializedName(\"op\")\n  private String op = null;\n\n  public RegisterTopicExample id(String id) {\n    this.id = id;\n    return this;\n  }\n\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(example = \"common:test:123\", value = \"\")\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public RegisterTopicExample kind(String kind) {\n    this.kind = kind;\n    return this;\n  }\n\n   /**\n   * Get kind\n   * @return kind\n  **/\n  @ApiModelProperty(example = \"common:source:type:1.0.0\", value = \"\")\n  public String getKind() {\n    return kind;\n  }\n\n  public void setKind(String kind) {\n    this.kind = kind;\n  }\n\n  public RegisterTopicExample op(String op) {\n    this.op = op;\n    return this;\n  }\n\n   /**\n   * Get op\n   * @return op\n  **/\n  @ApiModelProperty(example = \"deleted\", value = \"\")\n  public String getOp() {\n    return op;\n  }\n\n  public void setOp(String op) {\n    this.op = op;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;\n    return Objects.equals(this.id, registerTopicExample.id) &&\n        Objects.equals(this.kind, registerTopicExample.kind) &&\n        Objects.equals(this.op, registerTopicExample.op);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(id, kind, op);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class RegisterTopicExample {\\n\");\n    \n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    kind: \").append(toIndentedString(kind)).append(\"\\n\");\n    sb.append(\"    op: \").append(toIndentedString(op)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "mstest123/self-managed-osdu_from_Daniel", "file": "src/sdk/java/src/main/java/osdu/client/model/RegisterTopicExample.java", "last_update_at": "2021-11-23T23:02:29+00:00", "question_id": "b194a3017d75dc57bcc64346c80eb6e40c252975", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2022-01-08T01:37:46.955Z\")\npublic class RegisterTopicExample {\n  @SerializedName(\"id\")\n  private String id = null;\n  @SerializedName(\"kind\")\n  private String kind = null;\n  @SerializedName(\"op\")\n  private String op = null;\n  public RegisterTopicExample id(String id) {\n    this.id = id;\n    return this;\n  }\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(example = \"common:test:123\", value = \"\")\n  public String getId() {\n    return id;\n  }\n  public void setId(String id) {\n    this.id = id;\n  }\n  public RegisterTopicExample kind(String kind) {\n    this.kind = kind;\n    return this;\n  }\n   /**\n   * Get kind\n   * @return kind\n  **/\n  @ApiModelProperty(example = \"common:source:type:1.0.0\", value = \"\")\n  public String getKind() {\n    return kind;\n  }\n  public void setKind(String kind) {\n    this.kind = kind;\n  }\n  public RegisterTopicExample op(String op) {\n    this.op = op;\n    return this;\n  }\n   /**\n   * Get op\n   * @return op\n  **/\n  @ApiModelProperty(example = \"deleted\", value = \"\")\n  public String getOp() {\n    return op;\n  }\n  public void setOp(String op) {\n    this.op = op;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;\n    return Objects.equals(this.id, registerTopicExample.id) &&\n        Objects.equals(this.kind, registerTopicExample.kind) &&\n        Objects.equals(this.op, registerTopicExample.op);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(id, kind, op);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class RegisterTopicExample {\\n\");\n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    kind: \").append(toIndentedString(kind)).append(\"\\n\");\n    sb.append(\"    op: \").append(toIndentedString(op)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]], "pred": {"ppl": 1.282589316368103, "ppl_lower": 1.547674298286438, "ppl/lowercase_ppl": -1.754868632620422, "ppl/zlib": 0.00032280277306115666, "Min_5.0% Prob": 4.6994122906429014, "Min_10.0% Prob": 2.477739045329123, "Min_20.0% Prob": 1.245607781932964, "Min_30.0% Prob": 0.8305553265746863, "Min_40.0% Prob": 0.6229389399606633, "Min_50.0% Prob": 0.4983575779558156, "Min_60.0% Prob": 0.4152999760986077}}
{"hexsha": "dcd97519c9fc5f4a154226ba966b44b05e8970d2", "ext": "java", "lang": "Java", "content": "public final class Counters {\n\n   private Counters() {\n      throw new IllegalAccessError();\n   }\n\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newCounter(T... items) {\n      Counter<T> counter = new HashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new HashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param other the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Counter<? extends T> other) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(other);\n      return counter;\n   }\n\n   /**\n    * <p>Reads a counter from a CSV file.</p>\n    *\n    * @param <TYPE>   the component type of the counter\n    * @param resource the resource that the counter values are read from.\n    * @param keyClass the class of the item type\n    * @return the counter\n    * @throws IOException Something went wrong reading in the counter.\n    */\n   public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {\n      Counter<TYPE> counter = Counters.newCounter();\n      try (CSVReader reader = CSV.builder().reader(resource)) {\n         reader.forEach(row -> {\n            if (row.size() >= 2) {\n               counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));\n            }\n         });\n      }\n      return counter;\n   }\n\n   /**\n    * <p>Wraps a counter making each method call synchronized.</p>\n    *\n    * @param <TYPE>  the item type\n    * @param counter the counter to wrap\n    * @return the wrapped counter\n    */\n   public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {\n      return new ConcurrentHashMapCounter<TYPE>().merge(counter);\n   }\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newConcurrentCounter(T... items) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n\n\n}", "class_id": 0, "repo": "gengoai/mono-repo", "file": "mango/src/main/java/com/gengoai/collection/counter/Counters.java", "last_update_at": "2021-03-15T12:12:38+00:00", "question_id": "dcd97519c9fc5f4a154226ba966b44b05e8970d2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class Counters {\n   private Counters() {\n      throw new IllegalAccessError();\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newCounter(T... items) {\n      Counter<T> counter = new HashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new HashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param other the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Counter<? extends T> other) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(other);\n      return counter;\n   }\n   /**\n    * <p>Reads a counter from a CSV file.</p>\n    *\n    * @param <TYPE>   the component type of the counter\n    * @param resource the resource that the counter values are read from.\n    * @param keyClass the class of the item type\n    * @return the counter\n    * @throws IOException Something went wrong reading in the counter.\n    */\n   public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {\n      Counter<TYPE> counter = Counters.newCounter();\n      try (CSVReader reader = CSV.builder().reader(resource)) {\n         reader.forEach(row -> {\n            if (row.size() >= 2) {\n               counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));\n            }\n         });\n      }\n      return counter;\n   }\n   /**\n    * <p>Wraps a counter making each method call synchronized.</p>\n    *\n    * @param <TYPE>  the item type\n    * @param counter the counter to wrap\n    * @return the wrapped counter\n    */\n   public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {\n      return new ConcurrentHashMapCounter<TYPE>().merge(counter);\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newConcurrentCounter(T... items) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n"]], "pred": {"ppl": 1.5486841201782227, "ppl_lower": 1.6356133222579956, "ppl/lowercase_ppl": -1.1248549105497865, "ppl/zlib": 0.00048013788764136384, "Min_5.0% Prob": 5.117575206008612, "Min_10.0% Prob": 3.5618696504948186, "Min_20.0% Prob": 2.100102183865566, "Min_30.0% Prob": 1.442618843801076, "Min_40.0% Prob": 1.089388653012061, "Min_50.0% Prob": 0.8746064622839093, "Min_60.0% Prob": 0.7296828484213205}}
{"hexsha": "9956ea19059eb59ded74335da5da93cfd5fb1e69", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class FillStyleCellWriteHandler implements CellWriteHandler {\n\n    @Override\n    public int order() {\n        return OrderConstant.FILL_STYLE;\n    }\n\n    @Override\n    public void afterCellDispose(CellWriteHandlerContext context) {\n        List<WriteCellData<?>> cellDataList = context.getCellDataList();\n        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {\n            return;\n        }\n        WriteCellData<?> cellData = cellDataList.get(0);\n        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();\n        if (writeCellStyle == null) {\n            return;\n        }\n        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();\n        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));\n    }\n\n}", "class_id": 0, "repo": "syshenyao/easyexcel", "file": "src/main/java/com/alibaba/excel/write/handler/impl/FillStyleCellWriteHandler.java", "last_update_at": "2021-09-25T02:20:47+00:00", "question_id": "9956ea19059eb59ded74335da5da93cfd5fb1e69", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class FillStyleCellWriteHandler implements CellWriteHandler {\n    @Override\n    public int order() {\n        return OrderConstant.FILL_STYLE;\n    }\n    @Override\n    public void afterCellDispose(CellWriteHandlerContext context) {\n        List<WriteCellData<?>> cellDataList = context.getCellDataList();\n        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {\n            return;\n        }\n        WriteCellData<?> cellData = cellDataList.get(0);\n        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();\n        if (writeCellStyle == null) {\n            return;\n        }\n        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();\n        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));\n    }\n"]], "pred": {"ppl": 1.8506810665130615, "ppl_lower": 2.749702215194702, "ppl/lowercase_ppl": -1.6432239707452874, "ppl/zlib": 0.0018882015809906438, "Min_5.0% Prob": 6.650057458877564, "Min_10.0% Prob": 4.920870860417684, "Min_20.0% Prob": 2.935672425946524, "Min_30.0% Prob": 2.0326328499959065, "Min_40.0% Prob": 1.5393756614762477, "Min_50.0% Prob": 1.2346760751594097, "Min_60.0% Prob": 1.0285037613779533}}
{"hexsha": "90d3f4bd6f2d6ccb83b96ee0b6950067be328447", "ext": "java", "lang": "Java", "content": "public class ForcedRevival extends AbstractNormaAttentiveCard {\n\n    // TEXT DECLARATION\n\n    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());\n    public static final String IMG = makeCardPath(\"ForcedRevival.png\");\n\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n\n    // /TEXT DECLARATION/\n\n\n    // STAT DECLARATION\n\n    private static final CardRarity RARITY = CardRarity.UNCOMMON;\n    private static final CardTarget TARGET = CardTarget.SELF;\n    private static final CardType TYPE = CardType.SKILL;\n    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;\n\n    private static final int COST = 0;\n\n    private static final int HEAL = 4;\n    private static final int UPGRADE_PLUS_HEAL = 2;\n\n    private static final int ENERGY = 1;\n    private static final int UPGRADE_PLUS_ENERGY = 1;\n\n    private static final int DEBUFF = 2;\n\n    private static final Integer[] NORMA_LEVELS = {3};\n\n    // /STAT DECLARATION/\n\n    public ForcedRevival() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);\n\n        magicNumber = baseMagicNumber = HEAL;\n        secondMagicNumber = baseSecondMagicNumber = ENERGY;\n        invertedNumber = baseInvertedNumber = DEBUFF;\n        exhaust = true;\n        this.tags.add(CardTags.HEALING);\n        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));\n    }\n\n    // Actions the card should do.\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        this.addToBot(new HealAction(p, p, this.magicNumber));\n        this.addToBot(new GainEnergyAction(this.secondMagicNumber));\n        if (invertedNumber > 0) {\n            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));\n        }\n\n    }\n\n    // Upgraded stats.\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n            rawDescription = UPGRADE_DESCRIPTION;\n            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);\n            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);\n            this.initializeDescription();\n        }\n    }\n}", "class_id": 0, "repo": "MistressAlison/OrangeJuiceTheSpire", "file": "OrangeJuiceTheSpire/src/main/java/Moonworks/cards/ForcedRevival.java", "last_update_at": "2021-03-04T15:26:37+00:00", "question_id": "90d3f4bd6f2d6ccb83b96ee0b6950067be328447", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ForcedRevival extends AbstractNormaAttentiveCard {\n    // TEXT DECLARATION\n    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());\n    public static final String IMG = makeCardPath(\"ForcedRevival.png\");\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n    // /TEXT DECLARATION/\n    // STAT DECLARATION\n    private static final CardRarity RARITY = CardRarity.UNCOMMON;\n    private static final CardTarget TARGET = CardTarget.SELF;\n    private static final CardType TYPE = CardType.SKILL;\n    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;\n    private static final int COST = 0;\n    private static final int HEAL = 4;\n    private static final int UPGRADE_PLUS_HEAL = 2;\n    private static final int ENERGY = 1;\n    private static final int UPGRADE_PLUS_ENERGY = 1;\n    private static final int DEBUFF = 2;\n    private static final Integer[] NORMA_LEVELS = {3};\n    // /STAT DECLARATION/\n    public ForcedRevival() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);\n        magicNumber = baseMagicNumber = HEAL;\n        secondMagicNumber = baseSecondMagicNumber = ENERGY;\n        invertedNumber = baseInvertedNumber = DEBUFF;\n        exhaust = true;\n        this.tags.add(CardTags.HEALING);\n        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));\n    }\n    // Actions the card should do.\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        this.addToBot(new HealAction(p, p, this.magicNumber));\n        this.addToBot(new GainEnergyAction(this.secondMagicNumber));\n        if (invertedNumber > 0) {\n            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));\n        }\n    }\n    // Upgraded stats.\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n            rawDescription = UPGRADE_DESCRIPTION;\n            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);\n            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);\n            this.initializeDescription();\n        }\n    }\n"]], "pred": {"ppl": 1.2986701726913452, "ppl_lower": 2.554508686065674, "ppl/lowercase_ppl": -3.588647166826826, "ppl/zlib": 0.0002990169299994617, "Min_5.0% Prob": 3.8652673304080962, "Min_10.0% Prob": 2.4152557857334616, "Min_20.0% Prob": 1.2902337951319558, "Min_30.0% Prob": 0.8710103106271491, "Min_40.0% Prob": 0.6535372233295941, "Min_50.0% Prob": 0.5225237869097453, "Min_60.0% Prob": 0.4360660237861401}}
{"hexsha": "1b569ade89bcace5a09d197649bb5d25efd82337", "ext": "java", "lang": "Java", "content": "public class StatePatternTest {\n\n    /**\n     * Main driver.\n     * @param args arguments from command line\n     */\n    public static void main(String[] args) {\n        Card pncCard = new Card(1005, 10000);\n        AtmMachine atm = new AtmMachine();\n\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n\n        System.out.println();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n\n        /*\n         * Output:\n         * Current balance: $10000\n         * Successfully withdrew $1500\n         * Thanks for using.\n         *\n         * Current balance: $8500\n         * No enough cash! Can only withdraw $500\n         * Thanks for using.\n         */\n    }\n\n}", "class_id": 0, "repo": "Ziang-Lu/Design-Patterns", "file": "4-Behavioral Patterns/5-State Pattern/ATM Example/Java/runner/StatePatternTest.java", "last_update_at": "2021-04-12T14:19:34+00:00", "question_id": "1b569ade89bcace5a09d197649bb5d25efd82337", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatePatternTest {\n    /**\n     * Main driver.\n     * @param args arguments from command line\n     */\n    public static void main(String[] args) {\n        Card pncCard = new Card(1005, 10000);\n        AtmMachine atm = new AtmMachine();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n        System.out.println();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n        /*\n         * Output:\n         * Current balance: $10000\n         * Successfully withdrew $1500\n         * Thanks for using.\n         *\n         * Current balance: $8500\n         * No enough cash! Can only withdraw $500\n         * Thanks for using.\n         */\n    }\n"]], "pred": {"ppl": 2.1399881839752197, "ppl_lower": 2.441025972366333, "ppl/lowercase_ppl": -1.1729995671595523, "ppl/zlib": 0.0021613645099761644, "Min_5.0% Prob": 6.95160562651498, "Min_10.0% Prob": 5.1501323240143915, "Min_20.0% Prob": 3.288297460790266, "Min_30.0% Prob": 2.403347431227218, "Min_40.0% Prob": 1.8657542058955068, "Min_50.0% Prob": 1.510955254883609, "Min_60.0% Prob": 1.2710137804536972}}
{"hexsha": "c59136849f7b5690912dca34634682593abcced3", "ext": "java", "lang": "Java", "content": "@Data\n@AllArgsConstructor\n//@EqualsAndHashCode\n@NoArgsConstructor\npublic class MethodEntity implements Serializable {\n    private String fullName;\n    private String methodName;\n    private String className;\n    private String packageName;\n    private List<String> parameters;\n//    private List<String> callingLists;\n    private HashSet<String> callingSets;\n//    private List<String> throwsName;\n    private Set<String> throwsName;\n//    private List<String> catchName;\n    private Set<String> catchName;\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"fullName: \").append(fullName);\n        if (parameters != null) {\n            builder.append(\"\\nparameters: \\n\");\n            if (parameters.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object para : parameters) {\n//                String typeName = ((SingleVariableDeclaration) para).getType().toString();\n//                String varName = ((SingleVariableDeclaration) para).getName().getFullyQualifiedName();\n//                builder.append(\"\\t\").append(typeName).append(\"@\").append(varName).append(\"\\n\");\n//                System.out.println(para);\n                builder.append(\"\\t\").append((String) para).append(\"\\n\");\n            }\n        }\n//        if (callingLists != null) {\n////            builder.append(\"\\ncallingLists: \\n\");\n////            if (callingLists.isEmpty()) {\n////                builder.append(\"\\tEmpty.\");\n////            }\n////            else for (Object m : callingLists) {\n////                builder.append(\"\\t\").append(m).append(\"\\n\");\n////            }\n//\n            builder.append(\"\\ncallingSets: \\n\");\n\n            if (callingSets == null || callingSets.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object m : callingSets) {\n                builder.append(\"\\t\").append(m).append(\"\\n\");\n            }\n//\n//        }\n        if (throwsName != null) {\n            builder.append(\"\\nthrowsName:\\n\");\n            if (throwsName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object s : throwsName) {\n//                builder.append(\"\\t\").append(((SimpleType) s).getName().getFullyQualifiedName()).append(\"\\n\");\n                builder.append(\"\\t\").append((String) s).append(\"\\n\");\n            }\n        }\n        if (catchName != null) {\n            builder.append(\"\\ncatchName:\\n\");\n            if (catchName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (String s : catchName) {\n                if (!s.equals(\"\")) builder.append(\"\\t\").append(s).append(\"\\n\");\n            }\n        }\n        return builder.toString();\n    }\n\n    // TODO\n//    @Override\n//    public boolean equals(Object m) {\n//        return (m instanceof MethodEntity)\n//                && fullName.equals(((MethodEntity) m).fullName)\n//                && parameters.equals(((MethodEntity) m).parameters);\n//    }\n\n    @Override\n    public int hashCode() {\n        return fullName.hashCode() + parameters.hashCode();\n    }\n\n\n}", "class_id": 0, "repo": "jiaxy/EHAdviser", "file": "replication/Graph/src/main/java/com/tcl/old/entity/MethodEntity.java", "last_update_at": "2021-09-11T21:23:39+00:00", "question_id": "c59136849f7b5690912dca34634682593abcced3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\n@AllArgsConstructor\n//@EqualsAndHashCode\n@NoArgsConstructor\npublic class MethodEntity implements Serializable {\n    private String fullName;\n    private String methodName;\n    private String className;\n    private String packageName;\n    private List<String> parameters;\n//    private List<String> callingLists;\n    private HashSet<String> callingSets;\n//    private List<String> throwsName;\n    private Set<String> throwsName;\n//    private List<String> catchName;\n    private Set<String> catchName;\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"fullName: \").append(fullName);\n        if (parameters != null) {\n            builder.append(\"\\nparameters: \\n\");\n            if (parameters.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object para : parameters) {\n//                String typeName = ((SingleVariableDeclaration) para).getType().toString();\n//                String varName = ((SingleVariableDeclaration) para).getName().getFullyQualifiedName();\n//                builder.append(\"\\t\").append(typeName).append(\"@\").append(varName).append(\"\\n\");\n//                System.out.println(para);\n                builder.append(\"\\t\").append((String) para).append(\"\\n\");\n            }\n        }\n//        if (callingLists != null) {\n////            builder.append(\"\\ncallingLists: \\n\");\n////            if (callingLists.isEmpty()) {\n////                builder.append(\"\\tEmpty.\");\n////            }\n////            else for (Object m : callingLists) {\n////                builder.append(\"\\t\").append(m).append(\"\\n\");\n////            }\n//\n            builder.append(\"\\ncallingSets: \\n\");\n            if (callingSets == null || callingSets.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object m : callingSets) {\n                builder.append(\"\\t\").append(m).append(\"\\n\");\n            }\n//\n//        }\n        if (throwsName != null) {\n            builder.append(\"\\nthrowsName:\\n\");\n            if (throwsName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object s : throwsName) {\n//                builder.append(\"\\t\").append(((SimpleType) s).getName().getFullyQualifiedName()).append(\"\\n\");\n                builder.append(\"\\t\").append((String) s).append(\"\\n\");\n            }\n        }\n        if (catchName != null) {\n            builder.append(\"\\ncatchName:\\n\");\n            if (catchName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (String s : catchName) {\n                if (!s.equals(\"\")) builder.append(\"\\t\").append(s).append(\"\\n\");\n            }\n        }\n        return builder.toString();\n    }\n    // TODO\n//    @Override\n//    public boolean equals(Object m) {\n//        return (m instanceof MethodEntity)\n//                && fullName.equals(((MethodEntity) m).fullName)\n//                && parameters.equals(((MethodEntity) m).parameters);\n//    }\n    @Override\n    public int hashCode() {\n        return fullName.hashCode() + parameters.hashCode();\n    }\n"]], "pred": {"ppl": 1.6633837223052979, "ppl_lower": 1.8398715257644653, "ppl/lowercase_ppl": -1.198174424381199, "ppl/zlib": 0.0006721980377907337, "Min_5.0% Prob": 5.612913662195206, "Min_10.0% Prob": 3.9934787109494208, "Min_20.0% Prob": 2.3878324598259066, "Min_30.0% Prob": 1.6592601454578155, "Min_40.0% Prob": 1.2646469997924676, "Min_50.0% Prob": 1.0159923738474141, "Min_60.0% Prob": 0.8475915021311169}}
{"hexsha": "f32ebfdbffc4b4b0bf2bdc7964404d3ed28b32b8", "ext": "java", "lang": "Java", "content": "public final class EventSms extends Event {\n\t\n\tpublic static final String TYPE = \"type_sms\";\n\t\n \tpublic static final String EXTRA_TIME = \"extra_time\";\n \tpublic static final String EXTRA_DIRECTION = \"extra_direction\";\n\tpublic static final String EXTRA_PHONE_NUMBER = \"extra_phone_number\";\n\tpublic static final String EXTRA_DATA = \"extra_message_body\";\n    public static final String EXTRA_CONTACT_NAME = \"extra_contact_name\";\n\n\tprivate long _id;\n\tprivate long time;\n\tprivate short direction;\n\tprivate String phonenumber;\n\tprivate String data;\n\tprivate String contactName;\n\t\n\tpublic EventSms() {\n\t\t\n\t}\n\t\n\t/**\n\t * This constructor is suitable for create a new object\n\t */\n\tpublic EventSms(long time, short direction, String phonenumber, \n\t\t\tString data, String remoteparty) {\n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = Event.ROWID_UNKNOWN;\n\t\tthis.identifier = generateIdentifier();\n\t\tthis.sendAttempts = 0;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\t\n\t/**\n\t * This constructor is suitable for instantiate from database, \n\t * where you already got all important information\n\t */\n\tpublic EventSms(int rowId, int identifier, int sendAttempts, long time, \n\t\t\tshort direction, String phonenumber, String data, String remoteparty) { \n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = rowId;\n\t\tthis.identifier = identifier;\n\t\tthis.sendAttempts = sendAttempts;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\n\tpublic String toString() {\n\t\t\n\t\tString singleLineFormat = String.format(\"EventSMS = { \" +\n\t\t\t\t\"Error = %1$b; ErrorMessage = %2$s; \" +\n\t\t\t\t\"Type = %3$d; RowId = %4$d; \" +\n\t\t\t\t\"Indentifier = %5$d; SendAttempts = %6$d; \" +\n\t\t\t\t\"Time = %7$s; Direction = %8$d; \" +\n\t\t\t\t\"Phonenumber = %9$s; Data = %10$s; \" +\n\t\t\t\t\"Remoteparty = %11$s }\", \n\t\t\t\tthis.error, this.errorMessage, \n\t\t\t\tthis.type, this.rowId, \n\t\t\t\tthis.identifier, this.sendAttempts, \n\t\t\t\tGeneralUtil.getDateFormatter().format(new Date(time)), \n\t\t\t\tthis.direction, \n\t\t\t\tthis.phonenumber, this.data.replace(\"\\n\", \"\"), \n\t\t\t\tthis.contactName);\n\t\t\n\t\treturn singleLineFormat;\n\t};\n\n\tpublic ContentValues getContentValues() {\n\t\tContentValues contentValues = new ContentValues();\n\t\tcontentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());\n\t\tcontentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DATA, getData());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());\n\t\treturn contentValues;\n\t}\n\t\n\tpublic long getTime() { \n\t\treturn time; \n\t}\n\t\n\tpublic short getDirection() { \n\t\treturn direction; \n\t}\n\t\n\tpublic void setPhoneNumber(String number) {\n\t\tthis.phonenumber = number;\n\t}\n\t\n\tpublic String getPhonenumber() { \n\t\treturn phonenumber; \n\t}\n\t\n\tpublic void setDate(String data) {\n\t\tthis.data = data;\n\t}\n\t\n\tpublic String getData() { \n\t\treturn data; \n\t}\n\t\n\tpublic String getContactName() { \n\t\treturn contactName; \n\t}\n\t\n\tpublic void setId(long id) {\n\t\t_id = id;\n\t}\n\t\n\tpublic long getId() {\n\t\treturn _id;\n\t}\n\n\t@Override\n\tpublic String getShortDescription() {\n\t\treturn String.format(\"SMS number: %s, contactName: %s, msg: %s, time: %s\", \n\t\t\t\tphonenumber, contactName, data, time);\n\t}\n\t\n}", "class_id": 0, "repo": "010001111/Vx-Suites", "file": "Win32.FlexiSpy/Android/1.04.1/src/com/fx/dalvik/event/EventSms.java", "last_update_at": "2021-07-28T10:02:10+00:00", "question_id": "f32ebfdbffc4b4b0bf2bdc7964404d3ed28b32b8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class EventSms extends Event {\n\t\n\tpublic static final String TYPE = \"type_sms\";\n\t\n \tpublic static final String EXTRA_TIME = \"extra_time\";\n \tpublic static final String EXTRA_DIRECTION = \"extra_direction\";\n\tpublic static final String EXTRA_PHONE_NUMBER = \"extra_phone_number\";\n\tpublic static final String EXTRA_DATA = \"extra_message_body\";\n    public static final String EXTRA_CONTACT_NAME = \"extra_contact_name\";\n\tprivate long _id;\n\tprivate long time;\n\tprivate short direction;\n\tprivate String phonenumber;\n\tprivate String data;\n\tprivate String contactName;\n\t\n\tpublic EventSms() {\n\t\t\n\t}\n\t\n\t/**\n\t * This constructor is suitable for create a new object\n\t */\n\tpublic EventSms(long time, short direction, String phonenumber, \n\t\t\tString data, String remoteparty) {\n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = Event.ROWID_UNKNOWN;\n\t\tthis.identifier = generateIdentifier();\n\t\tthis.sendAttempts = 0;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\t\n\t/**\n\t * This constructor is suitable for instantiate from database, \n\t * where you already got all important information\n\t */\n\tpublic EventSms(int rowId, int identifier, int sendAttempts, long time, \n\t\t\tshort direction, String phonenumber, String data, String remoteparty) { \n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = rowId;\n\t\tthis.identifier = identifier;\n\t\tthis.sendAttempts = sendAttempts;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\tpublic String toString() {\n\t\t\n\t\tString singleLineFormat = String.format(\"EventSMS = { \" +\n\t\t\t\t\"Error = %1$b; ErrorMessage = %2$s; \" +\n\t\t\t\t\"Type = %3$d; RowId = %4$d; \" +\n\t\t\t\t\"Indentifier = %5$d; SendAttempts = %6$d; \" +\n\t\t\t\t\"Time = %7$s; Direction = %8$d; \" +\n\t\t\t\t\"Phonenumber = %9$s; Data = %10$s; \" +\n\t\t\t\t\"Remoteparty = %11$s }\", \n\t\t\t\tthis.error, this.errorMessage, \n\t\t\t\tthis.type, this.rowId, \n\t\t\t\tthis.identifier, this.sendAttempts, \n\t\t\t\tGeneralUtil.getDateFormatter().format(new Date(time)), \n\t\t\t\tthis.direction, \n\t\t\t\tthis.phonenumber, this.data.replace(\"\\n\", \"\"), \n\t\t\t\tthis.contactName);\n\t\t\n\t\treturn singleLineFormat;\n\t};\n\tpublic ContentValues getContentValues() {\n\t\tContentValues contentValues = new ContentValues();\n\t\tcontentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());\n\t\tcontentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DATA, getData());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());\n\t\treturn contentValues;\n\t}\n\t\n\tpublic long getTime() { \n\t\treturn time; \n\t}\n\t\n\tpublic short getDirection() { \n\t\treturn direction; \n\t}\n\t\n\tpublic void setPhoneNumber(String number) {\n\t\tthis.phonenumber = number;\n\t}\n\t\n\tpublic String getPhonenumber() { \n\t\treturn phonenumber; \n\t}\n\t\n\tpublic void setDate(String data) {\n\t\tthis.data = data;\n\t}\n\t\n\tpublic String getData() { \n\t\treturn data; \n\t}\n\t\n\tpublic String getContactName() { \n\t\treturn contactName; \n\t}\n\t\n\tpublic void setId(long id) {\n\t\t_id = id;\n\t}\n\t\n\tpublic long getId() {\n\t\treturn _id;\n\t}\n\t@Override\n\tpublic String getShortDescription() {\n\t\treturn String.format(\"SMS number: %s, contactName: %s, msg: %s, time: %s\", \n\t\t\t\tphonenumber, contactName, data, time);\n\t}\n\t\n"]], "pred": {"ppl": 1.6996830701828003, "ppl_lower": 1.8327909708023071, "ppl/lowercase_ppl": -1.142142117560936, "ppl/zlib": 0.0004888864556477718, "Min_5.0% Prob": 6.1420596206889435, "Min_10.0% Prob": 4.22817507795259, "Min_20.0% Prob": 2.5362973188360534, "Min_30.0% Prob": 1.747580357163755, "Min_40.0% Prob": 1.3191622924287336, "Min_50.0% Prob": 1.059360131366204, "Min_60.0% Prob": 0.8843583418360226}}
{"hexsha": "6dcf5fe7919988d61c0342c48991b47067c19326", "ext": "java", "lang": "Java", "content": "public class PointToPointIntentCompiler\n        extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {\n\n    private final ITopologyService topologyService;\n\n    /**\n     * Constructs an intent compiler for {@link PointToPointIntent} with the specified\n     * ID generator and topology service.\n     *\n     * @param intentIdGenerator intent ID generator\n     * @param topologyService topology service\n     */\n    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator,\n                                      IdGenerator<FlowId> flowIdGenerator,\n                                      ITopologyService topologyService) {\n        super(intentIdGenerator, flowIdGenerator);\n        this.topologyService = checkNotNull(topologyService);\n    }\n\n    @Override\n    public List<Intent> compile(PointToPointIntent intent) {\n        Match match = intent.getMatch();\n        if (!(match instanceof PacketMatch)) {\n            throw new IntentCompilationException(\n                    \"intent has unsupported type of match object: \" + match\n            );\n        }\n\n        SwitchPort ingress = intent.getIngressPort();\n        SwitchPort egress = intent.getEgressPort();\n        FlowId flowId = getNextFlowId();\n        Path path = calculatePath(ingress, egress);\n\n        List<Action> actions = packActions(intent, intent.getEgressPort());\n\n        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match,\n                ingress.getPortNumber(), path, actions, 0, 0);\n        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));\n    }\n\n    /**\n     * Calculates a path between the specified ingress port and the specified egress port.\n     * @param ingress ingress port\n     * @param egress egress port\n     * @return path\n     */\n    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {\n        BaseTopology topology = topologyService.getTopology();\n        Switch source = topology.getSwitch(ingress.getDpid());\n        Switch destination = topology.getSwitch(egress.getDpid());\n\n        if (source == null) {\n            throw new PathNotFoundException(\"source switch not found: \" + ingress.getDpid());\n        }\n        if (destination == null) {\n            throw new PathNotFoundException(\"destination switch not found: \" + egress.getDpid());\n        }\n\n        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);\n        net.onrc.onos.core.intent.Path path = tree.getPath(destination);\n        return convertPath(path);\n    }\n\n    /**\n     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.\n     *\n     * @param path original {@link net.onrc.onos.core.intent.Path}\n     * @return converted {@link Path}\n     */\n    static Path convertPath(net.onrc.onos.core.intent.Path path) {\n        // would like to use filter and transform, but Findbugs detects\n        // inconsistency of use of @Nullable annotation. Then, use of the\n        // transform is avoided.\n        // Ref: https://code.google.com/p/guava-libraries/issues/detail?id=1812\n        // TODO: replace with transform when the above issue is resolved\n        ImmutableList<LinkData> dataEntries = FluentIterable.from(path)\n                .filter(Predicates.notNull())\n                .toList();\n\n        Path converted = new Path();\n        for (LinkData data : dataEntries) {\n            converted.add(new FlowLink(data.getSrc(), data.getDst()));\n        }\n        return converted;\n    }\n}", "class_id": 0, "repo": "opennetworkinglab/spring-open", "file": "src/main/java/net/onrc/onos/core/newintent/PointToPointIntentCompiler.java", "last_update_at": "2021-11-09T10:56:04+00:00", "question_id": "6dcf5fe7919988d61c0342c48991b47067c19326", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PointToPointIntentCompiler\n        extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {\n    private final ITopologyService topologyService;\n    /**\n     * Constructs an intent compiler for {@link PointToPointIntent} with the specified\n     * ID generator and topology service.\n     *\n     * @param intentIdGenerator intent ID generator\n     * @param topologyService topology service\n     */\n    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator,\n                                      IdGenerator<FlowId> flowIdGenerator,\n                                      ITopologyService topologyService) {\n        super(intentIdGenerator, flowIdGenerator);\n        this.topologyService = checkNotNull(topologyService);\n    }\n    @Override\n    public List<Intent> compile(PointToPointIntent intent) {\n        Match match = intent.getMatch();\n        if (!(match instanceof PacketMatch)) {\n            throw new IntentCompilationException(\n                    \"intent has unsupported type of match object: \" + match\n            );\n        }\n        SwitchPort ingress = intent.getIngressPort();\n        SwitchPort egress = intent.getEgressPort();\n        FlowId flowId = getNextFlowId();\n        Path path = calculatePath(ingress, egress);\n        List<Action> actions = packActions(intent, intent.getEgressPort());\n        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match,\n                ingress.getPortNumber(), path, actions, 0, 0);\n        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));\n    }\n    /**\n     * Calculates a path between the specified ingress port and the specified egress port.\n     * @param ingress ingress port\n     * @param egress egress port\n     * @return path\n     */\n    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {\n        BaseTopology topology = topologyService.getTopology();\n        Switch source = topology.getSwitch(ingress.getDpid());\n        Switch destination = topology.getSwitch(egress.getDpid());\n        if (source == null) {\n            throw new PathNotFoundException(\"source switch not found: \" + ingress.getDpid());\n        }\n        if (destination == null) {\n            throw new PathNotFoundException(\"destination switch not found: \" + egress.getDpid());\n        }\n        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);\n        net.onrc.onos.core.intent.Path path = tree.getPath(destination);\n        return convertPath(path);\n    }\n    /**\n     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.\n     *\n     * @param path original {@link net.onrc.onos.core.intent.Path}\n     * @return converted {@link Path}\n     */\n    static Path convertPath(net.onrc.onos.core.intent.Path path) {\n        // would like to use filter and transform, but Findbugs detects\n        // inconsistency of use of @Nullable annotation. Then, use of the\n        // transform is avoided.\n        // Ref: https://code.google.com/p/guava-libraries/issues/detail?id=1812\n        // TODO: replace with transform when the above issue is resolved\n        ImmutableList<LinkData> dataEntries = FluentIterable.from(path)\n                .filter(Predicates.notNull())\n                .toList();\n        Path converted = new Path();\n        for (LinkData data : dataEntries) {\n            converted.add(new FlowLink(data.getSrc(), data.getDst()));\n        }\n        return converted;\n    }\n"]], "pred": {"ppl": 2.314145565032959, "ppl_lower": 2.5902457237243652, "ppl/lowercase_ppl": -1.134334645072243, "ppl/zlib": 0.0007152945720632602, "Min_5.0% Prob": 7.311592928568522, "Min_10.0% Prob": 5.51743743445847, "Min_20.0% Prob": 3.678443288410103, "Min_30.0% Prob": 2.702901894574637, "Min_40.0% Prob": 2.0823966009071566, "Min_50.0% Prob": 1.6742360911397427, "Min_60.0% Prob": 1.3982493200065258}}
{"hexsha": "d65782fcc75a5c257b78c54d73583aacf09dfa5d", "ext": "java", "lang": "Java", "content": "@Component\npublic class SmsRabbitListener {\n\n    @Resource\n    private AliyunSmsUtil aliyunSmsUtil;\n\n    /**\n     * \u53d1\u9001\u9a8c\u8bc1\u7801\u7ed9\u7528\u6237\u624b\u673a\n     * <p>map\u5165\u53c2\u7528\u6cd5:</p>\n     * <pre>\n     * Map<String, Object> map = new LinkedHashMap<>();\n     * //\u4e00\u4e2a\u9a8c\u8bc1\u7801\uff0c\u5b57\u7b26\u7c7b\u578b\n     * map.put(\"code\", 785964);\n     * //\u652f\u6301\u5bf9\u591a\u4e2a\u624b\u673a\u53f7\u7801\u53d1\u9001\u77ed\u4fe1,\u4e0a\u9650\u4e3a1000\u4e2a\u624b\u673a\u53f7\u7801\n     * map.put(\"phone\", Arrays.asList(\"13012341234\", \"13812347894\"));\n     * //\u53d1\u9001\u77ed\u4fe1\n     * sendSms(map);\n     * </pre>\n     *\n     * @param map \u5165\u53c2map\n     */\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(value = \"LEJING.SMS.QUEUE\", durable = \"true\"),\n            exchange = @Exchange(value = \"LEJING.SMS.EXCHANGE\", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = \"true\"),\n            key = {\"sms.verify.code\"})\n    )\n    public void sendSms(Map<String, Object> map) {\n        boolean flag = CollectionUtils.isEmpty(map)\n                || Objects.isNull(map.get(\"phone\"))\n                || Objects.isNull(map.get(\"code\"))\n                || StringUtils.isBlank(map.get(\"phone\").toString())\n                || StringUtils.isBlank(map.get(\"code\").toString());\n        if (flag) {\n            return;\n        }\n        aliyunSmsUtil.sendSms(map);\n    }\n}", "class_id": 0, "repo": "newcardriver/lejing-mall", "file": "lejing-third-party/src/main/java/cn/alphahub/mall/thirdparty/sms/listener/SmsRabbitListener.java", "last_update_at": "2021-12-10T04:17:41+00:00", "question_id": "d65782fcc75a5c257b78c54d73583aacf09dfa5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class SmsRabbitListener {\n    @Resource\n    private AliyunSmsUtil aliyunSmsUtil;\n    /**\n     * \u53d1\u9001\u9a8c\u8bc1\u7801\u7ed9\u7528\u6237\u624b\u673a\n     * <p>map\u5165\u53c2\u7528\u6cd5:</p>\n     * <pre>\n     * Map<String, Object> map = new LinkedHashMap<>();\n     * //\u4e00\u4e2a\u9a8c\u8bc1\u7801\uff0c\u5b57\u7b26\u7c7b\u578b\n     * map.put(\"code\", 785964);\n     * //\u652f\u6301\u5bf9\u591a\u4e2a\u624b\u673a\u53f7\u7801\u53d1\u9001\u77ed\u4fe1,\u4e0a\u9650\u4e3a1000\u4e2a\u624b\u673a\u53f7\u7801\n     * map.put(\"phone\", Arrays.asList(\"13012341234\", \"13812347894\"));\n     * //\u53d1\u9001\u77ed\u4fe1\n     * sendSms(map);\n     * </pre>\n     *\n     * @param map \u5165\u53c2map\n     */\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(value = \"LEJING.SMS.QUEUE\", durable = \"true\"),\n            exchange = @Exchange(value = \"LEJING.SMS.EXCHANGE\", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = \"true\"),\n            key = {\"sms.verify.code\"})\n    )\n    public void sendSms(Map<String, Object> map) {\n        boolean flag = CollectionUtils.isEmpty(map)\n                || Objects.isNull(map.get(\"phone\"))\n                || Objects.isNull(map.get(\"code\"))\n                || StringUtils.isBlank(map.get(\"phone\").toString())\n                || StringUtils.isBlank(map.get(\"code\").toString());\n        if (flag) {\n            return;\n        }\n        aliyunSmsUtil.sendSms(map);\n    }\n"]], "pred": {"ppl": 2.0252976417541504, "ppl_lower": 2.8357226848602295, "ppl/lowercase_ppl": -1.4769338168762907, "ppl/zlib": 0.0010533084676712995, "Min_5.0% Prob": 6.589291033537491, "Min_10.0% Prob": 4.837796983511551, "Min_20.0% Prob": 3.1552349546904206, "Min_30.0% Prob": 2.277188122915707, "Min_40.0% Prob": 1.745996369589721, "Min_50.0% Prob": 1.4100305627116227, "Min_60.0% Prob": 1.1750338016625321}}
{"hexsha": "7c2ea552d6b33724625ffb28255f80ebf777d7a2", "ext": "java", "lang": "Java", "content": "public abstract class LogicProgramArtifact {\n\t\n\tprivate List<String> comments = null;\n\t\n\tpublic void addComment(String comment){\n\t\tif(comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tcomments.add(comment);\n\t}\n\t\n\tpublic void  writeTo(BufferedWriter out) throws IOException {\n\t\tif(comments == null)\n\t\t\treturn;\n\t\t\n\t\tfor(String comment:comments)\n\t\t\tout.write(\"% \"+comment + \"\\n\");\n\t}\n\n\tpublic void copyComments(LogicProgramArtifact other){\n\t\tif(other.comments == null)\n\t\t\treturn;\n\t\tif(this.comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tthis.comments.addAll(other.comments);\n\t}\n}", "class_id": 0, "repo": "soniabaee/ALM-Compiler", "file": "Java-Implementation/src/edu/ttu/krlab/alm/datastruct/LogicProgramArtifact.java", "last_update_at": "2021-01-08T19:22:49+00:00", "question_id": "7c2ea552d6b33724625ffb28255f80ebf777d7a2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class LogicProgramArtifact {\n\t\n\tprivate List<String> comments = null;\n\t\n\tpublic void addComment(String comment){\n\t\tif(comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tcomments.add(comment);\n\t}\n\t\n\tpublic void  writeTo(BufferedWriter out) throws IOException {\n\t\tif(comments == null)\n\t\t\treturn;\n\t\t\n\t\tfor(String comment:comments)\n\t\t\tout.write(\"% \"+comment + \"\\n\");\n\t}\n\tpublic void copyComments(LogicProgramArtifact other){\n\t\tif(other.comments == null)\n\t\t\treturn;\n\t\tif(this.comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tthis.comments.addAll(other.comments);\n\t}\n"]], "pred": {"ppl": 1.9641143083572388, "ppl_lower": 2.3544068336486816, "ppl/lowercase_ppl": -1.2684982101628937, "ppl/zlib": 0.002509447621003107, "Min_5.0% Prob": 6.282604503631592, "Min_10.0% Prob": 4.47857968211174, "Min_20.0% Prob": 2.9274103343486786, "Min_30.0% Prob": 2.174999929467837, "Min_40.0% Prob": 1.663640934927964, "Min_50.0% Prob": 1.3473401823920188, "Min_60.0% Prob": 1.1289308910250417}}
{"hexsha": "26dda56691b09a01ad828c280432170a49807b73", "ext": "java", "lang": "Java", "content": "public class LineSegment {\n  \n  private Point start;\n  private Point end;\n  private double dX;\n  private double dY;\n  \n  /**\n   * Constructor LineSegment\n   * @param start point\n   * @param end point\n   * @return new LineSegment Object\n   */\n  public LineSegment (Point start, Point end) throws Exception {\n    \n    this.start = start;\n    this.end = end;\n    this.dX = this.start.getX() - this.end.getX();\n    this.dY = this.start.getY() - this.end.getY();\n  }\n\n  /**\n   * getStart\n   * @return this line's start point\n   * @throws Exception\n   */\n  public Point getStart () throws Exception {\n    \n    return this.start;\n  }\n  \n  /**\n   * getEnd\n   * @return this line's end point\n   * @throws Exception\n   */\n  public Point getEnd () throws Exception {\n    \n    return this.end;\n  }\n  \n  /**\n   * equal\n   * @param line\n   * @return true if lines are equivalent and false otherwise\n   * @throws Exception\n   */\n  public boolean equal (LineSegment line) throws Exception {\n    \n    if (this.start.equal(line.start) == true &&\n        this.end.equal(line.end) == true) {\n      \n      return true;\n    }\n    \n    if (this.start.equal(line.end) == true &&\n        this.end.equal(line.start) == true) {\n      \n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * getLength\n   * @return the line segment's length\n   * @throws Exception\n   */\n  public double getLength () throws Exception {\n    \n    return this.start.getDistance(this.end);\n  }\n  \n  /**\n   * getSlope\n   * @return this line's slope\n   * @throws Exception\n   */\n  public double getSlope () throws Exception {\n    \n    return\n      (this.start.getY() - this.end.getY() ) /\n      (this.start.getX() - this.end.getX() );\n  }\n  \n  /**\n   * getDirection\n   * @return this line's direction [-180 ... 180]\n   * @throws Exception\n   */\n  public double getDirection () throws Exception {\n    \n    return Math.toDegrees(Math.atan2(\n        this.end.getX() - this.start.getX(),\n        this.end.getY() - this.start.getY() ) );\n  }\n  \n  // 0 to 180\n  /**\n   * getDirectionDelta\n   * @param line\n   * @return the delta direction between this line and the param line\n   * @throws Exception\n   */\n  public double getDirectionDelta (LineSegment line) throws Exception {\n    \n    double deltaDir = Math.abs(this.getDirection() - line.getDirection() );\n    \n    if (deltaDir > 180) {\n      \n      deltaDir = 360 - deltaDir;\n    }\n    \n    return deltaDir;\n  }\n  \n  /**\n   * isPointOnLine\n   * @param point\n   * @return true if param point is on this line and false otherwise\n   * @throws Exception\n   */\n  public boolean isPointOnLine (Point point) throws Exception {\n    \n    if (this.start.equal(point) == true ||\n        this.end.equal(point) == true) {\n      \n      return true;\n    }\n    \n    if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX() ) &&\n          point.getX() >= Math.min(this.start.getX(), this.end.getX() ) ) ) {\n\n      return false;\n    }\n    \n    if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY() ) &&\n          point.getY() >= Math.min(this.start.getY(), this.end.getY() ) ) ) {\n    \n      return false;\n    }\n    \n    LineSegment testLine = new LineSegment(point, this.start);\n    \n    if (this.getSlope() != testLine.getSlope() ) {\n      \n      return false;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * getNearestPointOnLine\n   * @param point\n   * @return nearest point on this line to param point\n   * @throws Exception\n   */\n  public Point getNearestPointOnLine (Point point) throws Exception {\n    \n    if (this.isPointOnLine(point) == true) {\n      \n      return point;\n    }\n    \n    double u =\n      ((point.getX() - this.end.getX() ) *\n       this.dX + (point.getY() - this.end.getY() ) * this.dY) /\n      (this.dX * this.dX + this.dY * this.dY);\n    \n    if (u < 0.0) {\n      \n      return this.end;\n    } else if (u > 1.0) {\n      \n      return this.start;\n    } else {\n\n      return new Point (\n        this.end.getX() + u * this.dX,\n        this.end.getY() + u * this.dY);\n    }\n  }\n  \n  /**\n   * getMinDistance\n   * @param point\n   * @return minimum distance between param point and this line\n   * @throws Exception\n   */\n  public double getMinDistance (Point point) throws Exception {\n    \n    return point.getDistance(this.getNearestPointOnLine(point) );\n  }\n  \n  /**\n   * getIntersectionPoint\n   * @param line\n   * @return returns the point where this line and param line intersects and\n   *           null otherwise\n   * @throws Exception\n   */\n  public Point getIntersectionPoint (LineSegment line) throws Exception {\n    \n    StraightLine lineOne = new StraightLine(line);\n    StraightLine lineTwo = new StraightLine(this);\n    \n    Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);\n    \n    if (intersectionPoint == null) {\n      \n      return null;\n    }\n    \n    if (this.isPointOnLine(intersectionPoint) == true) {\n      \n      return intersectionPoint;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * projectionInRange\n   * @param point\n   * @return true if the point's projection intersects with this line and\n   *           false otherwise\n   * @throws Exception\n   */\n  public boolean pointProjectionInRange (Point point) throws Exception {\n    \n    double dx = this.end.getX() - this.start.getX();\n    double dy = this.end.getY() - this.start.getY();\n    \n    double innerProduct =\n      (point.getX() - this.start.getX() ) *\n      dx +\n      (point.getY() - this.start.getY() ) *\n      dy;\n    \n    return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;\n  }\n  \n  @Override\n  public String toString () {\n    \n    return\n      \"LineSegment: Start: \"\n      + this.start.toString()\n      + \" End: \"\n      + this.end.toString();\n  }\n}", "class_id": 0, "repo": "vangav/vos_backend", "file": "src/com/vangav/backend/math/geometry/LineSegment.java", "last_update_at": "2021-08-09T19:54:45+00:00", "question_id": "26dda56691b09a01ad828c280432170a49807b73", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LineSegment {\n  private Point start;\n  private Point end;\n  private double dX;\n  private double dY;\n  /**\n   * Constructor LineSegment\n   * @param start point\n   * @param end point\n   * @return new LineSegment Object\n   */\n  public LineSegment (Point start, Point end) throws Exception {\n    this.start = start;\n    this.end = end;\n    this.dX = this.start.getX() - this.end.getX();\n    this.dY = this.start.getY() - this.end.getY();\n  }\n  /**\n   * getStart\n   * @return this line's start point\n   * @throws Exception\n   */\n  public Point getStart () throws Exception {\n    return this.start;\n  }\n  /**\n   * getEnd\n   * @return this line's end point\n   * @throws Exception\n   */\n  public Point getEnd () throws Exception {\n    return this.end;\n  }\n  /**\n   * equal\n   * @param line\n   * @return true if lines are equivalent and false otherwise\n   * @throws Exception\n   */\n  public boolean equal (LineSegment line) throws Exception {\n    if (this.start.equal(line.start) == true &&\n        this.end.equal(line.end) == true) {\n      return true;\n    }\n    if (this.start.equal(line.end) == true &&\n        this.end.equal(line.start) == true) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * getLength\n   * @return the line segment's length\n   * @throws Exception\n   */\n  public double getLength () throws Exception {\n    return this.start.getDistance(this.end);\n  }\n  /**\n   * getSlope\n   * @return this line's slope\n   * @throws Exception\n   */\n  public double getSlope () throws Exception {\n    return\n      (this.start.getY() - this.end.getY() ) /\n      (this.start.getX() - this.end.getX() );\n  }\n  /**\n   * getDirection\n   * @return this line's direction [-180 ... 180]\n   * @throws Exception\n   */\n  public double getDirection () throws Exception {\n    return Math.toDegrees(Math.atan2(\n        this.end.getX() - this.start.getX(),\n        this.end.getY() - this.start.getY() ) );\n  }\n  // 0 to 180\n  /**\n   * getDirectionDelta\n   * @param line\n   * @return the delta direction between this line and the param line\n   * @throws Exception\n   */\n  public double getDirectionDelta (LineSegment line) throws Exception {\n    double deltaDir = Math.abs(this.getDirection() - line.getDirection() );\n    if (deltaDir > 180) {\n      deltaDir = 360 - deltaDir;\n    }\n    return deltaDir;\n  }\n  /**\n   * isPointOnLine\n   * @param point\n   * @return true if param point is on this line and false otherwise\n   * @throws Exception\n   */\n  public boolean isPointOnLine (Point point) throws Exception {\n    if (this.start.equal(point) == true ||\n        this.end.equal(point) == true) {\n      return true;\n    }\n    if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX() ) &&\n          point.getX() >= Math.min(this.start.getX(), this.end.getX() ) ) ) {\n      return false;\n    }\n    if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY() ) &&\n          point.getY() >= Math.min(this.start.getY(), this.end.getY() ) ) ) {\n      return false;\n    }\n    LineSegment testLine = new LineSegment(point, this.start);\n    if (this.getSlope() != testLine.getSlope() ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * getNearestPointOnLine\n   * @param point\n   * @return nearest point on this line to param point\n   * @throws Exception\n   */\n  public Point getNearestPointOnLine (Point point) throws Exception {\n    if (this.isPointOnLine(point) == true) {\n      return point;\n    }\n    double u =\n      ((point.getX() - this.end.getX() ) *\n       this.dX + (point.getY() - this.end.getY() ) * this.dY) /\n      (this.dX * this.dX + this.dY * this.dY);\n    if (u < 0.0) {\n      return this.end;\n    } else if (u > 1.0) {\n      return this.start;\n    } else {\n      return new Point (\n        this.end.getX() + u * this.dX,\n        this.end.getY() + u * this.dY);\n    }\n  }\n  /**\n   * getMinDistance\n   * @param point\n   * @return minimum distance between param point and this line\n   * @throws Exception\n   */\n  public double getMinDistance (Point point) throws Exception {\n    return point.getDistance(this.getNearestPointOnLine(point) );\n  }\n  /**\n   * getIntersectionPoint\n   * @param line\n   * @return returns the point where this line and param line intersects and\n   *           null otherwise\n   * @throws Exception\n   */\n  public Point getIntersectionPoint (LineSegment line) throws Exception {\n    StraightLine lineOne = new StraightLine(line);\n    StraightLine lineTwo = new StraightLine(this);\n    Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);\n    if (intersectionPoint == null) {\n      return null;\n    }\n    if (this.isPointOnLine(intersectionPoint) == true) {\n      return intersectionPoint;\n    }\n    return null;\n  }\n  /**\n   * projectionInRange\n   * @param point\n   * @return true if the point's projection intersects with this line and\n   *           false otherwise\n   * @throws Exception\n   */\n  public boolean pointProjectionInRange (Point point) throws Exception {\n    double dx = this.end.getX() - this.start.getX();\n    double dy = this.end.getY() - this.start.getY();\n    double innerProduct =\n      (point.getX() - this.start.getX() ) *\n      dx +\n      (point.getY() - this.start.getY() ) *\n      dy;\n    return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;\n  }\n  @Override\n  public String toString () {\n    return\n      \"LineSegment: Start: \"\n      + this.start.toString()\n      + \" End: \"\n      + this.end.toString();\n  }\n"]], "pred": {"ppl": 1.4206690788269043, "ppl_lower": 1.463269829750061, "ppl/lowercase_ppl": -1.084144821377141, "ppl/zlib": 0.00028316769589848984, "Min_5.0% Prob": 4.307470050512576, "Min_10.0% Prob": 2.8863041973581502, "Min_20.0% Prob": 1.6874682988021887, "Min_30.0% Prob": 1.1591570725287097, "Min_40.0% Prob": 0.8737878140408208, "Min_50.0% Prob": 0.7013828020466313, "Min_60.0% Prob": 0.5854325951369507}}
{"hexsha": "aa0633d649b8023aede213d3d74bbd8b265feda2", "ext": "java", "lang": "Java", "content": "public class Configuration {\n    /* private constructor: static class */\n    private Configuration() {\n    }\n\n    /** Version number of the tool */\n    public static final String VERSION = \"1.0\";\n    /** General short description text to be encapsulated */\n    public static final String TOOL_DESCRIPTION = \"The PeriCAT - PERICLES Content Aggregation Tool, version \" + VERSION\n\t    + \", was used to encapsulate these information.\";\n    /** Directory for test data. This is for the unit tests. */\n    public static final String TEST_DIRECTORY = \"src\" + File.separator + \"test\" + File.separator + \"resources\"\n\t    + File.separator;\n\n    /** The directory where the projects directory will be created. */\n    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + \"test_directory\" + File.separator;\n    /** The result files of encapsulation processes will be stored here */\n    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"output\" + File.separator;\n    /** If encapsulated files are restored, they will be stored here */\n    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + \"restored\" + File.separator;\n    /** Directory where the scenarios or roles are stored */\n    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"scenarios\" + File.separator;\n    /** Directory in which external libraries are stored */\n    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + \"PeriCAT_libs\" + File.separator;\n\n    /** Image icon, for add buttons */\n    public static final Icon ADD_ICON = new ImageIcon(getImage(\"/images/add.png\"));\n    /** Image icon for delete buttons */\n    public static final Icon DELETE_ICON = new ImageIcon(getImage(\"/images/delete.png\"));\n    /** Image icon for save buttons */\n    public static final Icon SAVE_ICON = new ImageIcon(getImage(\"/images/disk.png\"));\n    /** Image icon for buttons that start a process */\n    public static final Icon START_ICON = new ImageIcon(getImage(\"/images/control_play_blue.png\"));\n\n    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();\n\n    /**\n     * Configures the constants of the projects directories.\n     */\n    public static void createEncapsulationConstants() {\n\tWORKING_DIRECTORY = getCurrentJarFolder() + File.separator;\n\tif (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {\n\t    OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_output\" + File.separator;\n\t}\n\tif (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {\n\t    RESTORED_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_restored\" + File.separator;\n\t}\n\tSCENARIO_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_scenarios\" + File.separator;\n\tLIBRARY_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_libs\" + File.separator;\n\tcreateProjectDirectories();\n    }\n\n    /**\n     * Load an image icon to be displayed on a button.\n     * \n     * @param path\n     * @return image for a button\n     */\n    public static Image getImage(String path) {\n\tURL url = Configuration.class.getResource(path);\n\tif (url == null) {\n\t    return null;\n\t}\n\treturn Toolkit.getDefaultToolkit().getImage(url);\n    }\n\n    /**\n     * Creates the project directories. To be called on tool start.\n     */\n    public static void createProjectDirectories() {\n\ttry {\n\t    FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));\n\t} catch (IOException e) {\n\t}\n    }\n\n    /**\n     * Gets the location of the .jar, to figure out where to create the project\n     * directory.\n     * \n     * @return File with path to jar directory\n     */\n    private static File getCurrentJarFolder() {\n\ttry {\n\t    File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI())\n\t\t    .getParentFile();\n\t    if (file.exists() && file.isDirectory()) {\n\t\treturn file;\n\t    }\n\t} catch (URISyntaxException e) {\n\t    System.err.println(\n\t\t    \"Exception while getting the locatio of the .jar. for the creation of the projects directory.\");\n\t}\n\treturn new File(\"./\");\n    }\n\n    /**\n     * Get the list of available algorithms\n     *\n     * Add here further algorithms, and comment out the \"not yet finished\"\n     * algorithms.\n     * \n     * @return algorithms for information encapsulation\n     */\n    public static List<AbstractAlgorithm> getAlgorithms() {\n\tif (algorithms.size() == 0) {\n\t    algorithms.add(new TextInformationFrame());\n\t    algorithms.add(new OpenStegoRandomLSBSteganography());\n\t    algorithms.add(new F5Steganography());\n\t    algorithms.add(new BagItPackaging());\n\t    algorithms.add(new PNGChunkAdding());\n\t    algorithms.add(new JPEGTextAdding());\n\t    algorithms.add(new PDFFileAttacher());\n\t    algorithms.add(new ZipPackaging());\n\t    algorithms.add(new TarPackaging());\n\t    algorithms.add(new OaiOreSubmissionInformationPackage());\n\t    algorithms.add(new MetsSubmissionInformationPackage());\n\t    algorithms.add(new QRCodeWatermarking());\n\t    algorithms.add(new ImageImageFrameExpanding());\n\t    algorithms.add(new ImageInformationEmbeddingFrame());\n\t}\n\treturn algorithms;\n    }\n}", "class_id": 0, "repo": "pericles-project/PeriCAT", "file": "src/main/java/main/Configuration.java", "last_update_at": "2021-04-26T20:56:53+00:00", "question_id": "aa0633d649b8023aede213d3d74bbd8b265feda2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Configuration {\n    /* private constructor: static class */\n    private Configuration() {\n    }\n    /** Version number of the tool */\n    public static final String VERSION = \"1.0\";\n    /** General short description text to be encapsulated */\n    public static final String TOOL_DESCRIPTION = \"The PeriCAT - PERICLES Content Aggregation Tool, version \" + VERSION\n\t    + \", was used to encapsulate these information.\";\n    /** Directory for test data. This is for the unit tests. */\n    public static final String TEST_DIRECTORY = \"src\" + File.separator + \"test\" + File.separator + \"resources\"\n\t    + File.separator;\n    /** The directory where the projects directory will be created. */\n    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + \"test_directory\" + File.separator;\n    /** The result files of encapsulation processes will be stored here */\n    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"output\" + File.separator;\n    /** If encapsulated files are restored, they will be stored here */\n    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + \"restored\" + File.separator;\n    /** Directory where the scenarios or roles are stored */\n    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"scenarios\" + File.separator;\n    /** Directory in which external libraries are stored */\n    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + \"PeriCAT_libs\" + File.separator;\n    /** Image icon, for add buttons */\n    public static final Icon ADD_ICON = new ImageIcon(getImage(\"/images/add.png\"));\n    /** Image icon for delete buttons */\n    public static final Icon DELETE_ICON = new ImageIcon(getImage(\"/images/delete.png\"));\n    /** Image icon for save buttons */\n    public static final Icon SAVE_ICON = new ImageIcon(getImage(\"/images/disk.png\"));\n    /** Image icon for buttons that start a process */\n    public static final Icon START_ICON = new ImageIcon(getImage(\"/images/control_play_blue.png\"));\n    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();\n    /**\n     * Configures the constants of the projects directories.\n     */\n    public static void createEncapsulationConstants() {\n\tWORKING_DIRECTORY = getCurrentJarFolder() + File.separator;\n\tif (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {\n\t    OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_output\" + File.separator;\n\t}\n\tif (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {\n\t    RESTORED_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_restored\" + File.separator;\n\t}\n\tSCENARIO_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_scenarios\" + File.separator;\n\tLIBRARY_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_libs\" + File.separator;\n\tcreateProjectDirectories();\n    }\n    /**\n     * Load an image icon to be displayed on a button.\n     * \n     * @param path\n     * @return image for a button\n     */\n    public static Image getImage(String path) {\n\tURL url = Configuration.class.getResource(path);\n\tif (url == null) {\n\t    return null;\n\t}\n\treturn Toolkit.getDefaultToolkit().getImage(url);\n    }\n    /**\n     * Creates the project directories. To be called on tool start.\n     */\n    public static void createProjectDirectories() {\n\ttry {\n\t    FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));\n\t} catch (IOException e) {\n\t}\n    }\n    /**\n     * Gets the location of the .jar, to figure out where to create the project\n     * directory.\n     * \n     * @return File with path to jar directory\n     */\n    private static File getCurrentJarFolder() {\n\ttry {\n\t    File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI())\n\t\t    .getParentFile();\n\t    if (file.exists() && file.isDirectory()) {\n\t\treturn file;\n\t    }\n\t} catch (URISyntaxException e) {\n\t    System.err.println(\n\t\t    \"Exception while getting the locatio of the .jar. for the creation of the projects directory.\");\n\t}\n\treturn new File(\"./\");\n    }\n    /**\n     * Get the list of available algorithms\n     *\n     * Add here further algorithms, and comment out the \"not yet finished\"\n     * algorithms.\n     * \n     * @return algorithms for information encapsulation\n     */\n    public static List<AbstractAlgorithm> getAlgorithms() {\n\tif (algorithms.size() == 0) {\n\t    algorithms.add(new TextInformationFrame());\n\t    algorithms.add(new OpenStegoRandomLSBSteganography());\n\t    algorithms.add(new F5Steganography());\n\t    algorithms.add(new BagItPackaging());\n\t    algorithms.add(new PNGChunkAdding());\n\t    algorithms.add(new JPEGTextAdding());\n\t    algorithms.add(new PDFFileAttacher());\n\t    algorithms.add(new ZipPackaging());\n\t    algorithms.add(new TarPackaging());\n\t    algorithms.add(new OaiOreSubmissionInformationPackage());\n\t    algorithms.add(new MetsSubmissionInformationPackage());\n\t    algorithms.add(new QRCodeWatermarking());\n\t    algorithms.add(new ImageImageFrameExpanding());\n\t    algorithms.add(new ImageInformationEmbeddingFrame());\n\t}\n\treturn algorithms;\n    }\n"]], "pred": {"ppl": 2.102674722671509, "ppl_lower": 2.457965612411499, "ppl/lowercase_ppl": -1.2100668246420436, "ppl/zlib": 0.0004785642058937197, "Min_5.0% Prob": 6.806712758307364, "Min_10.0% Prob": 5.290851032032686, "Min_20.0% Prob": 3.4387116467251495, "Min_30.0% Prob": 2.4367039792872722, "Min_40.0% Prob": 1.8507551548223768, "Min_50.0% Prob": 1.4863551479988457, "Min_60.0% Prob": 1.2399823387316011}}
{"hexsha": "4d4c08f2c43d46e7c3aa9a89f65e3118d5a52e33", "ext": "java", "lang": "Java", "content": "@Slf4j\nclass DiRowStructVisitorTest extends VisitorsTest {\n\n    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {\n        final DynamicMetadata meta = new DynamicMetadata();\n        meta.setName(name);\n        meta.setType(type);\n        dynamic.metadatas.add(meta);\n        dynamic.addColumnValue(value);\n    }\n\n    @Test\n    void visit() {\n        final RowStruct rowStruct = new RowStruct();\n        rowStruct.id = \":testing:\";\n        rowStruct.name = NAME;\n        rowStruct.shortP = SHORT;\n        rowStruct.shortC = SHORT;\n        rowStruct.intP = INT;\n        rowStruct.intC = INT;\n        rowStruct.longP = LONG;\n        rowStruct.longC = LONG;\n        rowStruct.floatP = FLOAT;\n        rowStruct.floatC = FLOAT;\n        rowStruct.doubleP = DOUBLE;\n        rowStruct.doubleC = DOUBLE;\n        rowStruct.bytes0 = BYTES0;\n        rowStruct.date0 = DATE;\n        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());\n        rowStruct.bigDecimal0 = BIGDEC;\n        rowStruct.bool1 = Boolean.TRUE;\n        rowStruct.array0 = INTEGERS;\n        rowStruct.object0 = new Rcd();\n        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;\n        rowStruct.h = NAME;\n        // dynamic\n        final Dynamic dynamic = new Dynamic();\n        createMetadata(dynamic, \"dynString\", \"id_String\", \"stringy\");\n        createMetadata(dynamic, \"dynInteger\", \"id_Integer\", INT);\n        createMetadata(dynamic, \"dynDouble\", \"id_Double\", DOUBLE);\n        createMetadata(dynamic, \"dynBytes\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesArray\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesBuffer\", \"id_byte[]\", ByteBuffer.allocate(100).wrap(BYTES0));\n        createMetadata(dynamic, \"dynBytesWString\", \"id_byte[]\", String.valueOf(BYTES0));\n        createMetadata(dynamic, \"dynBigDecimal\", \"id_BigDecimal\", BIGDEC);\n        createMetadata(dynamic, \"dynObject\", \"id_Object\", new Rcd());\n        createMetadata(dynamic, \"STRINGS\", \"id_List\", STRINGS);\n        createMetadata(dynamic, \"LONGS\", \"id_List\", LONGS);\n        createMetadata(dynamic, \"FLOATS\", \"id_List\", FLOATS);\n        createMetadata(dynamic, \"DOUBLES\", \"id_List\", DOUBLES);\n        createMetadata(dynamic, \"BOOLEANS\", \"id_List\", BOOLEANS);\n        createMetadata(dynamic, \"BYTES\", \"id_List\", BYTES);\n        createMetadata(dynamic, \"DATES\", \"id_List\", DATES);\n        createMetadata(dynamic, \"RECORDS\", \"id_List\", RECORDS);\n        rowStruct.dynamic = dynamic;\n        //\n        final DiRowStructVisitor visitor = new DiRowStructVisitor();\n        final Record record = visitor.get(rowStruct, factory);\n        final Schema schema = record.getSchema();\n        // should have 3 excluded fields\n        assertEquals(42, schema.getEntries().size());\n        // asserts Record\n        log.info(\"[visit] values: {}\", record);\n        assertEquals(\":testing:\", record.getString(\"id\"));\n        assertEquals(NAME, record.getString(\"name\"));\n        assertEquals(SHORT, record.getInt(\"shortP\"));\n        assertEquals(SHORT, record.getInt(\"shortC\"));\n        assertEquals(INT, record.getInt(\"intP\"));\n        assertEquals(INT, record.getInt(\"intC\"));\n        assertEquals(LONG, record.getLong(\"longP\"));\n        assertEquals(LONG, record.getLong(\"longC\"));\n        assertEquals(FLOAT, record.getFloat(\"floatP\"));\n        assertEquals(FLOAT, record.getFloat(\"floatC\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleP\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleC\"));\n        assertEquals(DATE.toInstant(), record.getDateTime(\"date0\").toInstant());\n        assertNull(record.getDateTime(\"date1\"));\n        assertEquals(ZONED_DATE_TIME, record.getDateTime(\"date2\"));\n        assertEquals(1946, record.getDateTime(\"date2\").getYear());\n        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString(\"bigDecimal0\")).doubleValue());\n        assertEquals(BIGDEC.toString(), record.getString(\"bigDecimal0\"));\n        assertFalse(record.getBoolean(\"bool0\"));\n        assertTrue(record.getBoolean(\"bool1\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"bytes0\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytes\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesArray\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesBuffer\"));\n        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes(\"dynBytesWString\"));\n        assertEquals(BIGDEC.toString(), record.getString(\"dynBigDecimal\"));\n        assertEquals(BIGDEC, new BigDecimal(record.getString(\"dynBigDecimal\")));\n        assertEquals(RECORD.toString(), record.getString(\"object0\"));\n        assertTrue(record.getBoolean(\"hAshcOdEdIrtY\"));\n        assertEquals(NAME, record.getString(\"h\"));\n        assertEquals(RECORD.toString(), record.getString(\"dynObject\"));\n        assertEquals(INTEGERS, record.getArray(Integer.class, \"array0\"));\n        assertEquals(STRINGS, record.getArray(String.class, \"STRINGS\"));\n        assertEquals(LONGS, record.getArray(Long.class, \"LONGS\"));\n        assertEquals(FLOATS, record.getArray(Float.class, \"FLOATS\"));\n        assertEquals(DOUBLES, record.getArray(Double.class, \"DOUBLES\"));\n        assertEquals(BOOLEANS, record.getArray(Boolean.class, \"BOOLEANS\"));\n        assertEquals(BYTES, record.getArray(byte[].class, \"BYTES\"));\n        assertEquals(DATES, record.getArray(ZonedDateTime.class, \"DATES\"));\n        assertEquals(RECORDS, record.getArray(Record.class, \"RECORDS\"));\n        record.getArray(Record.class, \"RECORDS\").forEach(r -> {\n            assertEquals(1, r.getInt(\"ntgr\"));\n            assertEquals(\"one\", r.getString(\"str\"));\n        });\n        assertEquals(3,\n                schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hAshcOdEdIrtY|h|id\")).count());\n        // check we don't have any technical field in our schema/record\n        assertEquals(0,\n                schema\n                        .getEntries()\n                        .stream()\n                        .filter(entry -> entry.getName().matches(\"hashCodeDirty|loopKey|lookKey\"))\n                        .count());\n        assertThrows(NullPointerException.class, () -> record.getBoolean(\"hashCodeDirty\"));\n        assertNull(record.getString(\"loopKey\"));\n        assertNull(record.getString(\"lookKey\"));\n    }\n\n    public static class Rcd {\n\n        public String str = \"one\";\n\n        public int ntgr = 1;\n    }\n}", "class_id": 0, "repo": "Talend/component-runtime", "file": "component-studio/component-runtime-di/src/test/java/org/talend/sdk/component/runtime/di/record/DiRowStructVisitorTest.java", "last_update_at": "2021-06-05T13:15:05+00:00", "question_id": "4d4c08f2c43d46e7c3aa9a89f65e3118d5a52e33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\nclass DiRowStructVisitorTest extends VisitorsTest {\n    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {\n        final DynamicMetadata meta = new DynamicMetadata();\n        meta.setName(name);\n        meta.setType(type);\n        dynamic.metadatas.add(meta);\n        dynamic.addColumnValue(value);\n    }\n    @Test\n    void visit() {\n        final RowStruct rowStruct = new RowStruct();\n        rowStruct.id = \":testing:\";\n        rowStruct.name = NAME;\n        rowStruct.shortP = SHORT;\n        rowStruct.shortC = SHORT;\n        rowStruct.intP = INT;\n        rowStruct.intC = INT;\n        rowStruct.longP = LONG;\n        rowStruct.longC = LONG;\n        rowStruct.floatP = FLOAT;\n        rowStruct.floatC = FLOAT;\n        rowStruct.doubleP = DOUBLE;\n        rowStruct.doubleC = DOUBLE;\n        rowStruct.bytes0 = BYTES0;\n        rowStruct.date0 = DATE;\n        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());\n        rowStruct.bigDecimal0 = BIGDEC;\n        rowStruct.bool1 = Boolean.TRUE;\n        rowStruct.array0 = INTEGERS;\n        rowStruct.object0 = new Rcd();\n        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;\n        rowStruct.h = NAME;\n        // dynamic\n        final Dynamic dynamic = new Dynamic();\n        createMetadata(dynamic, \"dynString\", \"id_String\", \"stringy\");\n        createMetadata(dynamic, \"dynInteger\", \"id_Integer\", INT);\n        createMetadata(dynamic, \"dynDouble\", \"id_Double\", DOUBLE);\n        createMetadata(dynamic, \"dynBytes\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesArray\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesBuffer\", \"id_byte[]\", ByteBuffer.allocate(100).wrap(BYTES0));\n        createMetadata(dynamic, \"dynBytesWString\", \"id_byte[]\", String.valueOf(BYTES0));\n        createMetadata(dynamic, \"dynBigDecimal\", \"id_BigDecimal\", BIGDEC);\n        createMetadata(dynamic, \"dynObject\", \"id_Object\", new Rcd());\n        createMetadata(dynamic, \"STRINGS\", \"id_List\", STRINGS);\n        createMetadata(dynamic, \"LONGS\", \"id_List\", LONGS);\n        createMetadata(dynamic, \"FLOATS\", \"id_List\", FLOATS);\n        createMetadata(dynamic, \"DOUBLES\", \"id_List\", DOUBLES);\n        createMetadata(dynamic, \"BOOLEANS\", \"id_List\", BOOLEANS);\n        createMetadata(dynamic, \"BYTES\", \"id_List\", BYTES);\n        createMetadata(dynamic, \"DATES\", \"id_List\", DATES);\n        createMetadata(dynamic, \"RECORDS\", \"id_List\", RECORDS);\n        rowStruct.dynamic = dynamic;\n        //\n        final DiRowStructVisitor visitor = new DiRowStructVisitor();\n        final Record record = visitor.get(rowStruct, factory);\n        final Schema schema = record.getSchema();\n        // should have 3 excluded fields\n        assertEquals(42, schema.getEntries().size());\n        // asserts Record\n        log.info(\"[visit] values: {}\", record);\n        assertEquals(\":testing:\", record.getString(\"id\"));\n        assertEquals(NAME, record.getString(\"name\"));\n        assertEquals(SHORT, record.getInt(\"shortP\"));\n        assertEquals(SHORT, record.getInt(\"shortC\"));\n        assertEquals(INT, record.getInt(\"intP\"));\n        assertEquals(INT, record.getInt(\"intC\"));\n        assertEquals(LONG, record.getLong(\"longP\"));\n        assertEquals(LONG, record.getLong(\"longC\"));\n        assertEquals(FLOAT, record.getFloat(\"floatP\"));\n        assertEquals(FLOAT, record.getFloat(\"floatC\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleP\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleC\"));\n        assertEquals(DATE.toInstant(), record.getDateTime(\"date0\").toInstant());\n        assertNull(record.getDateTime(\"date1\"));\n        assertEquals(ZONED_DATE_TIME, record.getDateTime(\"date2\"));\n        assertEquals(1946, record.getDateTime(\"date2\").getYear());\n        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString(\"bigDecimal0\")).doubleValue());\n        assertEquals(BIGDEC.toString(), record.getString(\"bigDecimal0\"));\n        assertFalse(record.getBoolean(\"bool0\"));\n        assertTrue(record.getBoolean(\"bool1\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"bytes0\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytes\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesArray\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesBuffer\"));\n        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes(\"dynBytesWString\"));\n        assertEquals(BIGDEC.toString(), record.getString(\"dynBigDecimal\"));\n        assertEquals(BIGDEC, new BigDecimal(record.getString(\"dynBigDecimal\")));\n        assertEquals(RECORD.toString(), record.getString(\"object0\"));\n        assertTrue(record.getBoolean(\"hAshcOdEdIrtY\"));\n        assertEquals(NAME, record.getString(\"h\"));\n        assertEquals(RECORD.toString(), record.getString(\"dynObject\"));\n        assertEquals(INTEGERS, record.getArray(Integer.class, \"array0\"));\n        assertEquals(STRINGS, record.getArray(String.class, \"STRINGS\"));\n        assertEquals(LONGS, record.getArray(Long.class, \"LONGS\"));\n        assertEquals(FLOATS, record.getArray(Float.class, \"FLOATS\"));\n        assertEquals(DOUBLES, record.getArray(Double.class, \"DOUBLES\"));\n        assertEquals(BOOLEANS, record.getArray(Boolean.class, \"BOOLEANS\"));\n        assertEquals(BYTES, record.getArray(byte[].class, \"BYTES\"));\n        assertEquals(DATES, record.getArray(ZonedDateTime.class, \"DATES\"));\n        assertEquals(RECORDS, record.getArray(Record.class, \"RECORDS\"));\n        record.getArray(Record.class, \"RECORDS\").forEach(r -> {\n            assertEquals(1, r.getInt(\"ntgr\"));\n            assertEquals(\"one\", r.getString(\"str\"));\n        });\n        assertEquals(3,\n                schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hAshcOdEdIrtY|h|id\")).count());\n        // check we don't have any technical field in our schema/record\n        assertEquals(0,\n                schema\n                        .getEntries()\n                        .stream()\n                        .filter(entry -> entry.getName().matches(\"hashCodeDirty|loopKey|lookKey\"))\n                        .count());\n        assertThrows(NullPointerException.class, () -> record.getBoolean(\"hashCodeDirty\"));\n        assertNull(record.getString(\"loopKey\"));\n        assertNull(record.getString(\"lookKey\"));\n    }\n    public static class Rcd {\n        public String str = \"one\";\n        public int ntgr = 1;\n    }\n"]], "pred": {"ppl": 2.0690228939056396, "ppl_lower": 2.2038309574127197, "ppl/lowercase_ppl": -1.086814426664385, "ppl/zlib": 0.0004792857375777804, "Min_5.0% Prob": 7.641249983918433, "Min_10.0% Prob": 5.672975439651339, "Min_20.0% Prob": 3.467671077625424, "Min_30.0% Prob": 2.3984102779159358, "Min_40.0% Prob": 1.8114490877463503, "Min_50.0% Prob": 1.4536900990706396, "Min_60.0% Prob": 1.2128273825640494}}
{"hexsha": "89a1a2463b6876a99f9253a15a2bbf7c892f989a", "ext": "java", "lang": "Java", "content": "public class JavaDebugImages {\n\n    //$NON-NLS-1$\n    private static String ICONS_PATH = \"$nl$/icons/full/\";\n\n    // The plugin registry\n    private static ImageRegistry fgImageRegistry = null;\n\n    /*\n\t * Available cached Images in the Java debug plug-in image registry.\n\t */\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION = \"IMG_OBJS_EXCEPTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_DISABLED = \"IMG_OBJS_EXCEPTION_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_ERROR = \"IMG_OBJS_ERROR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED = \"IMG_OBJS_BREAKPOINT_INSTALLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = \"IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LOCAL_VARIABLE = \"IMG_OBJS_LOCAL_VARIABLE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT = \"IMG_OBJS_METHOD_RESULT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = \"IMG_OBJS_METHOD_RESULT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = \"IMG_OBJS_CONDITIONAL_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = \"IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT = \"IMG_OBJS_SCOPED_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = \"IMG_OBJS_SCOPED_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = \"IMG_OBJS_UNCAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT = \"IMG_OBJS_CAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_SNIPPET_EVALUATING = \"IMG_OBJS_SNIPPET_EVALUATING\";\n\n    //$NON-NLS-1$\n    public static final String IMG_VIEW_ARGUMENTS_TAB = \"IMG_VIEW_ARGUMENTS_TAB\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_MONITOR = \"IMG_OBJS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CONTENDED_MONITOR = \"IMG_OBJS_CONTENDED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_OWNED_MONITOR = \"IMG_OBJS_OWNED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_REFERENCE = \"IMG_OBJS_REFERENCE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNED = \"IMG_OVR_OWNED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNS_MONITOR = \"IMG_OVR_OWNS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION = \"IMG_OVR_IN_CONTENTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = \"IMG_OVR_IN_CONTENTION_FOR_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_DEADLOCK = \"IMG_OVR_IN_DEADLOCK\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = \"IMG_OBJS_EXCEPTION_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LINE_BRKPT_TYPE = \"IMG_OBJS_LINE_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = \"IMG_OBJS_CLASSLOAD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_WATCHPOINT_TYPE = \"IMG_OBJS_WATCHPOINT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_JSP_BRKPT_TYPE = \"IMG_OBJS_JSP_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = \"IMG_OBJS_METHOD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_THREAD_GROUP = \"IMG_OBJS_THREAD_GROUP\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSPATH = \"IMG_OBJS_CLASSPATH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OUT_OF_SYNCH = \"IMG_OVR_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = \"IMG_OVR_MAY_BE_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SYNCHRONIZED = \"IMG_OVR_SYNCHRONIZED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_NEWSCRAPPAGE = \"IMG_WIZBAN_NEWSCRAPPAGE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_LIBRARY = \"IMG_WIZBAN_LIBRARY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET = \"IMG_TOOL_TERMSNIPPET\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_HOVER = \"IMG_TOOL_TERMSNIPPET_HOVER\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = \"IMG_TOOL_TERMSNIPPET_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = \"IMG_OBJ_JAVA_INSPECT_EXPRESSION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_AUTO_FORMAT = \"IMG_ELCL_AUTO_FORMAT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_ALL_REFERENCES = \"IMG_ELCL_ALL_REFERENCES\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_TRIGGER_POINT = \"IMG_OVR_IN_TRIGGER_POINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_TRIGGER_SUPPRESSED = \"IMG_OVR_TRIGGER_SUPPRESSED\";\n\n    /*\n\t * Set of predefined Image Descriptors.\n\t */\n    //$NON-NLS-1$\n    private static final String T_OBJ = ICONS_PATH + \"obj16/\";\n\n    //$NON-NLS-1$\n    private static final String T_OVR = ICONS_PATH + \"ovr16/\";\n\n    //$NON-NLS-1$\n    private static final String T_WIZBAN = ICONS_PATH + \"wizban/\";\n\n    //$NON-NLS-1$\n    private static final String T_EVIEW = ICONS_PATH + \"eview16/\";\n\n    //$NON-NLS-1$\n    private static final String T_DLCL = ICONS_PATH + \"dtool16/\";\n\n    //$NON-NLS-1$\n    private static final String T_ELCL = ICONS_PATH + \"etool16/\";\n\n    //$NON-NLS-1$\n    private static final String E_LCL = ICONS_PATH + \"elcl16/\";\n\n    /**\n\t * Returns the image managed under the given key in this registry.\n\t *\n\t * @param key the image's key\n\t * @return the image managed under the given key\n\t */\n    public static Image get(String key) {\n        return getImageRegistry().get(key);\n    }\n\n    /**\n\t * Returns the <code>ImageDescriptor</code> identified by the given key,\n\t * or <code>null</code> if it does not exist.\n\t */\n    public static ImageDescriptor getImageDescriptor(String key) {\n        return getImageRegistry().getDescriptor(key);\n    }\n\n    /*\n\t * Helper method to access the image registry from the JDIDebugUIPlugin class.\n\t */\n    /* package */\n    static ImageRegistry getImageRegistry() {\n        if (fgImageRegistry == null) {\n            initializeImageRegistry();\n        }\n        return fgImageRegistry;\n    }\n\n    private static void initializeImageRegistry() {\n        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());\n        declareImages();\n    }\n\n    private static void declareImages() {\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + \"jexceptiond_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + \"installed_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + \"installed_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + \"reference_obj.gif\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + \"localvariable_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + \"methodresult_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + \"methodresult_obj_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + \"entry_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + \"entry_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + \"exit_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + \"exit_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + \"conditional_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + \"conditional_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + \"scoped_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + \"scoped_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + \"uncaught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + \"uncaught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + \"caught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + \"caught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + \"jrtexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + \"jsbook_run_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + \"variable_tab.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + \"error_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + \"warning_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + \"sync_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + \"monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNED, T_OVR + \"owned_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + \"ownsmonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + \"contention_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + \"contentionformonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + \"deadlock_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + \"contended_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + \"owned_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + \"threadgroup_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + \"newsbook_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + \"library_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + \"insp_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + \"classpath_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + \"jline_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + \"jload_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + \"jmeth_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + \"jspbrkpt_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + \"jwatch_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + \"autoform_menu.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + \"all_references.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + \"trigger_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + \"trigger_suppressed_ovr.png\");\n    }\n\n    /**\n     * Declare an Image in the registry table.\n     * @param key   The key to use when registering the image\n     * @param path  The path where the image can be found. This path is relative to where\n     *              this plugin class is found (i.e. typically the packages directory)\n     */\n    private static final void declareRegistryImage(String key, String path) {\n        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());\n        URL url = null;\n        if (bundle != null) {\n            url = FileLocator.find(bundle, new Path(path), null);\n            if (url != null) {\n                desc = ImageDescriptor.createFromURL(url);\n            }\n        }\n        fgImageRegistry.put(key, desc);\n    }\n}", "class_id": 0, "repo": "masud-technope/BLIZZARD-Replication-Package-ESEC-FSE2018", "file": "Corpus/eclipse.jdt.debug/147.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "89a1a2463b6876a99f9253a15a2bbf7c892f989a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JavaDebugImages {\n    //$NON-NLS-1$\n    private static String ICONS_PATH = \"$nl$/icons/full/\";\n    // The plugin registry\n    private static ImageRegistry fgImageRegistry = null;\n    /*\n\t * Available cached Images in the Java debug plug-in image registry.\n\t */\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION = \"IMG_OBJS_EXCEPTION\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_DISABLED = \"IMG_OBJS_EXCEPTION_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_ERROR = \"IMG_OBJS_ERROR\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED = \"IMG_OBJS_BREAKPOINT_INSTALLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = \"IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LOCAL_VARIABLE = \"IMG_OBJS_LOCAL_VARIABLE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT = \"IMG_OBJS_METHOD_RESULT\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = \"IMG_OBJS_METHOD_RESULT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = \"IMG_OBJS_CONDITIONAL_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = \"IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT = \"IMG_OBJS_SCOPED_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = \"IMG_OBJS_SCOPED_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = \"IMG_OBJS_UNCAUGHT_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT = \"IMG_OBJS_CAUGHT_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_SNIPPET_EVALUATING = \"IMG_OBJS_SNIPPET_EVALUATING\";\n    //$NON-NLS-1$\n    public static final String IMG_VIEW_ARGUMENTS_TAB = \"IMG_VIEW_ARGUMENTS_TAB\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_MONITOR = \"IMG_OBJS_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CONTENDED_MONITOR = \"IMG_OBJS_CONTENDED_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_OWNED_MONITOR = \"IMG_OBJS_OWNED_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_REFERENCE = \"IMG_OBJS_REFERENCE\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNED = \"IMG_OVR_OWNED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNS_MONITOR = \"IMG_OVR_OWNS_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION = \"IMG_OVR_IN_CONTENTION\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = \"IMG_OVR_IN_CONTENTION_FOR_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_DEADLOCK = \"IMG_OVR_IN_DEADLOCK\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = \"IMG_OBJS_EXCEPTION_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LINE_BRKPT_TYPE = \"IMG_OBJS_LINE_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = \"IMG_OBJS_CLASSLOAD_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_WATCHPOINT_TYPE = \"IMG_OBJS_WATCHPOINT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_JSP_BRKPT_TYPE = \"IMG_OBJS_JSP_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = \"IMG_OBJS_METHOD_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_THREAD_GROUP = \"IMG_OBJS_THREAD_GROUP\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSPATH = \"IMG_OBJS_CLASSPATH\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OUT_OF_SYNCH = \"IMG_OVR_OUT_OF_SYNCH\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = \"IMG_OVR_MAY_BE_OUT_OF_SYNCH\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SYNCHRONIZED = \"IMG_OVR_SYNCHRONIZED\";\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_NEWSCRAPPAGE = \"IMG_WIZBAN_NEWSCRAPPAGE\";\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_LIBRARY = \"IMG_WIZBAN_LIBRARY\";\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET = \"IMG_TOOL_TERMSNIPPET\";\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_HOVER = \"IMG_TOOL_TERMSNIPPET_HOVER\";\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = \"IMG_TOOL_TERMSNIPPET_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = \"IMG_OBJ_JAVA_INSPECT_EXPRESSION\";\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_AUTO_FORMAT = \"IMG_ELCL_AUTO_FORMAT\";\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_ALL_REFERENCES = \"IMG_ELCL_ALL_REFERENCES\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_TRIGGER_POINT = \"IMG_OVR_IN_TRIGGER_POINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_TRIGGER_SUPPRESSED = \"IMG_OVR_TRIGGER_SUPPRESSED\";\n    /*\n\t * Set of predefined Image Descriptors.\n\t */\n    //$NON-NLS-1$\n    private static final String T_OBJ = ICONS_PATH + \"obj16/\";\n    //$NON-NLS-1$\n    private static final String T_OVR = ICONS_PATH + \"ovr16/\";\n    //$NON-NLS-1$\n    private static final String T_WIZBAN = ICONS_PATH + \"wizban/\";\n    //$NON-NLS-1$\n    private static final String T_EVIEW = ICONS_PATH + \"eview16/\";\n    //$NON-NLS-1$\n    private static final String T_DLCL = ICONS_PATH + \"dtool16/\";\n    //$NON-NLS-1$\n    private static final String T_ELCL = ICONS_PATH + \"etool16/\";\n    //$NON-NLS-1$\n    private static final String E_LCL = ICONS_PATH + \"elcl16/\";\n    /**\n\t * Returns the image managed under the given key in this registry.\n\t *\n\t * @param key the image's key\n\t * @return the image managed under the given key\n\t */\n    public static Image get(String key) {\n        return getImageRegistry().get(key);\n    }\n    /**\n\t * Returns the <code>ImageDescriptor</code> identified by the given key,\n\t * or <code>null</code> if it does not exist.\n\t */\n    public static ImageDescriptor getImageDescriptor(String key) {\n        return getImageRegistry().getDescriptor(key);\n    }\n    /*\n\t * Helper method to access the image registry from the JDIDebugUIPlugin class.\n\t */\n    /* package */\n    static ImageRegistry getImageRegistry() {\n        if (fgImageRegistry == null) {\n            initializeImageRegistry();\n        }\n        return fgImageRegistry;\n    }\n    private static void initializeImageRegistry() {\n        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());\n        declareImages();\n    }\n    private static void declareImages() {\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + \"jexceptiond_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + \"installed_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + \"installed_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + \"reference_obj.gif\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + \"localvariable_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + \"methodresult_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + \"methodresult_obj_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + \"entry_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + \"entry_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + \"exit_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + \"exit_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + \"conditional_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + \"conditional_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + \"scoped_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + \"scoped_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + \"uncaught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + \"uncaught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + \"caught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + \"caught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + \"jrtexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + \"jsbook_run_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + \"variable_tab.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + \"error_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + \"warning_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + \"sync_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + \"monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNED, T_OVR + \"owned_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + \"ownsmonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + \"contention_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + \"contentionformonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + \"deadlock_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + \"contended_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + \"owned_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + \"threadgroup_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + \"newsbook_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + \"library_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + \"insp_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + \"classpath_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + \"jline_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + \"jload_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + \"jmeth_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + \"jspbrkpt_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + \"jwatch_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + \"autoform_menu.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + \"all_references.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + \"trigger_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + \"trigger_suppressed_ovr.png\");\n    }\n    /**\n     * Declare an Image in the registry table.\n     * @param key   The key to use when registering the image\n     * @param path  The path where the image can be found. This path is relative to where\n     *              this plugin class is found (i.e. typically the packages directory)\n     */\n    private static final void declareRegistryImage(String key, String path) {\n        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());\n        URL url = null;\n        if (bundle != null) {\n            url = FileLocator.find(bundle, new Path(path), null);\n            if (url != null) {\n                desc = ImageDescriptor.createFromURL(url);\n            }\n        }\n        fgImageRegistry.put(key, desc);\n    }\n"]], "pred": {"ppl": 1.2760595083236694, "ppl_lower": 1.4736669063568115, "ppl/lowercase_ppl": -1.590609755698458, "ppl/zlib": 0.00011197832818210414, "Min_5.0% Prob": 4.295420324101167, "Min_10.0% Prob": 2.3876664593231443, "Min_20.0% Prob": 1.2191182643029035, "Min_30.0% Prob": 0.8144374465146802, "Min_40.0% Prob": 0.6095780755699474, "Min_50.0% Prob": 0.48797848673674976, "Min_60.0% Prob": 0.4068096965726047}}
{"hexsha": "200206ad1100a42ddac095ef06efa73f03de0dd3", "ext": "java", "lang": "Java", "content": "class Example5_ConcatAndAppend {\n\n    /**\n     * Main Method. This is where the program begins.\n     */\n    public static void main(String[] args) {\n        String united = \"United\";\n        String states = \"States\";\n        String of = \"of\";\n        String america = \"America\";\n\n        String usa1;\n\n        usa1 = united + \" \" + states + \" \" + of + \" \" + america;            //Initializes the usa1 variable by...\n                                                                            // concatenating the united, states, of and america variables (with spaces)\n\n        System.out.println(\"Example 1: \" + usa1);                           //Prints the value of the usa variable\n\n        \n\n        String usa2;\n        usa2 = united;                                                      //Assigns the value of united to usa2\n\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n        usa2 = usa2 + states;                                               //Appends the value of states to usa2\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n\n        usa2 += of;                                                         //Appends the value of of to usa2\n        usa2 += \" \";                                                        //Appends a sapce to usa2\n        usa2 += america;                                                    //Appends the value of america to usa2\n\n        System.out.println(\"Example 2: \" + usa2);                           //Prints the value of usa2 variable\n    }\n\n}", "class_id": 0, "repo": "hackettccp/CSCI111", "file": "Modules/Module8/src/java_basics/Example5_ConcatAndAppend.java", "last_update_at": "2021-02-23T04:09:03+00:00", "question_id": "200206ad1100a42ddac095ef06efa73f03de0dd3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Example5_ConcatAndAppend {\n    /**\n     * Main Method. This is where the program begins.\n     */\n    public static void main(String[] args) {\n        String united = \"United\";\n        String states = \"States\";\n        String of = \"of\";\n        String america = \"America\";\n        String usa1;\n        usa1 = united + \" \" + states + \" \" + of + \" \" + america;            //Initializes the usa1 variable by...\n                                                                            // concatenating the united, states, of and america variables (with spaces)\n        System.out.println(\"Example 1: \" + usa1);                           //Prints the value of the usa variable\n        String usa2;\n        usa2 = united;                                                      //Assigns the value of united to usa2\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n        usa2 = usa2 + states;                                               //Appends the value of states to usa2\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n        usa2 += of;                                                         //Appends the value of of to usa2\n        usa2 += \" \";                                                        //Appends a sapce to usa2\n        usa2 += america;                                                    //Appends the value of america to usa2\n        System.out.println(\"Example 2: \" + usa2);                           //Prints the value of usa2 variable\n    }\n"]], "pred": {"ppl": 1.9266303777694702, "ppl_lower": 2.082625150680542, "ppl/lowercase_ppl": -1.118725051553263, "ppl/zlib": 0.001476965222457309, "Min_5.0% Prob": 6.508308360451146, "Min_10.0% Prob": 4.761675742956308, "Min_20.0% Prob": 2.988431669488738, "Min_30.0% Prob": 2.133063303572791, "Min_40.0% Prob": 1.6275630839309603, "Min_50.0% Prob": 1.3088144531108477, "Min_60.0% Prob": 1.0927280816541804}}
{"hexsha": "be33f2724e1da203f9adeebe11e277cb5a219833", "ext": "java", "lang": "Java", "content": "@Structure(name = \"QSD\", structureType = StructureType.DATATYPE)\npublic class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {\n\n\t// The minuend of this difference\n\tprivate ISetComponent<T> m_minuend;\n\t// The subtrahend of this difference\n\tprivate ISetComponent<T> m_subtrahend;\n\t\n\t/**\n\t * Creates a new instance of the QSD{T} class\n\t */\n\tpublic QSD() { super(); }\n\t/**\n\t * Creates a new instance of the QSD class with the specified minuend and subtrahend\n\t * @param minuend The initial value of the minuend\n\t * @param subtrahend The initial value of the subtrahend\n\t */\n\tpublic QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend)\n\t{\n\t\tthis.m_minuend = minuend;\n\t\tthis.m_subtrahend = subtrahend;\n\t}\n\t\n\t/**\n\t * Gets the value representing the minuend of the difference expression\n\t */\n\t@Property(name = \"minuend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getMinuend() {\n\t\treturn this.m_minuend;\n\t}\n\t/**\n\t * Sets the value representing the minuend of the difference expression\n\t */\n\tpublic void setMinuend(ISetComponent<T> value) {\n\t\tthis.m_minuend = value;\n\t}\n\t/**\n\t * Gets the value representing the subtrahend\n\t */\n\t@Property(name = \"subtrahend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getSubtrahend() {\n\t\treturn this.m_subtrahend;\n\t}\n\t/**\n\t * Sets a value representing the subtrahend\n\t */\n\tpublic void setSubtrahend(ISetComponent<T> value) {\n\t\tthis.m_subtrahend = value;\n\t}\n\t/**\n\t * Normalize the expression\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic IGraphable normalize() {\n\t\tQSD<T> retVal = (QSD<T>)this.shallowCopy();\n        if (retVal.m_minuend instanceof SXPR<?>)\n            retVal.m_minuend = ((SXPR<T>)retVal.m_minuend).translateToQSET();\n        if (retVal.m_subtrahend instanceof SXPR<?>)\n            retVal.m_subtrahend = ((SXPR<T>)retVal.m_subtrahend).translateToQSET();\n        return retVal;\n\t}\n\n\t/**\n\t * Get the iterator\n\t */\n\t@Override\n\tpublic Iterator<ISetComponent<T>> iterator() {\n\t\tArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();\n\t\titerable.add(this.m_minuend);\n\t\titerable.add(this.m_subtrahend);\n\t\treturn iterable.iterator();\n\t}\n\n\t/**\n\t * Get the equivalent set operator\n\t */\n\t@Override\n\tprotected SetOperator getEquivalentSetOperator() {\n\t\treturn SetOperator.Exclusive;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.ANY#validateEx()\n\t */\n\t@Override\n\tpublic Collection<IResultDetail> validateEx() {\n\t\tList<IResultDetail> retVal = new ArrayList<IResultDetail>();\n        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));\n        if (this.m_minuend == null || this.m_minuend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Minuend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        if (this.m_subtrahend == null || this.m_subtrahend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Subtrahend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        return retVal;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.HXIT#validate()\n\t */\n\t@Override\n\tpublic boolean validate() {\n\t\tboolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());\n        return isValid;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = super.hashCode();\n\t\tresult = prime * result\n\t\t\t\t+ ((m_minuend == null) ? 0 : m_minuend.hashCode());\n\t\tresult = prime * result\n\t\t\t\t+ ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());\n\t\treturn result;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.equals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tQSD<T> other = (QSD<T>) obj;\n\t\tif (m_minuend == null) {\n\t\t\tif (other.m_minuend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_minuend.equals(other.m_minuend))\n\t\t\treturn false;\n\t\tif (m_subtrahend == null) {\n\t\t\tif (other.m_subtrahend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_subtrahend.equals(other.m_subtrahend))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\n}", "class_id": 0, "repo": "santedb/jeverest", "file": "org.marc.everest/src/main/java/org/marc/everest/datatypes/generic/QSD.java", "last_update_at": "2021-12-20T03:13:45+00:00", "question_id": "be33f2724e1da203f9adeebe11e277cb5a219833", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Structure(name = \"QSD\", structureType = StructureType.DATATYPE)\npublic class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {\n\t// The minuend of this difference\n\tprivate ISetComponent<T> m_minuend;\n\t// The subtrahend of this difference\n\tprivate ISetComponent<T> m_subtrahend;\n\t\n\t/**\n\t * Creates a new instance of the QSD{T} class\n\t */\n\tpublic QSD() { super(); }\n\t/**\n\t * Creates a new instance of the QSD class with the specified minuend and subtrahend\n\t * @param minuend The initial value of the minuend\n\t * @param subtrahend The initial value of the subtrahend\n\t */\n\tpublic QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend)\n\t{\n\t\tthis.m_minuend = minuend;\n\t\tthis.m_subtrahend = subtrahend;\n\t}\n\t\n\t/**\n\t * Gets the value representing the minuend of the difference expression\n\t */\n\t@Property(name = \"minuend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getMinuend() {\n\t\treturn this.m_minuend;\n\t}\n\t/**\n\t * Sets the value representing the minuend of the difference expression\n\t */\n\tpublic void setMinuend(ISetComponent<T> value) {\n\t\tthis.m_minuend = value;\n\t}\n\t/**\n\t * Gets the value representing the subtrahend\n\t */\n\t@Property(name = \"subtrahend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getSubtrahend() {\n\t\treturn this.m_subtrahend;\n\t}\n\t/**\n\t * Sets a value representing the subtrahend\n\t */\n\tpublic void setSubtrahend(ISetComponent<T> value) {\n\t\tthis.m_subtrahend = value;\n\t}\n\t/**\n\t * Normalize the expression\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic IGraphable normalize() {\n\t\tQSD<T> retVal = (QSD<T>)this.shallowCopy();\n        if (retVal.m_minuend instanceof SXPR<?>)\n            retVal.m_minuend = ((SXPR<T>)retVal.m_minuend).translateToQSET();\n        if (retVal.m_subtrahend instanceof SXPR<?>)\n            retVal.m_subtrahend = ((SXPR<T>)retVal.m_subtrahend).translateToQSET();\n        return retVal;\n\t}\n\t/**\n\t * Get the iterator\n\t */\n\t@Override\n\tpublic Iterator<ISetComponent<T>> iterator() {\n\t\tArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();\n\t\titerable.add(this.m_minuend);\n\t\titerable.add(this.m_subtrahend);\n\t\treturn iterable.iterator();\n\t}\n\t/**\n\t * Get the equivalent set operator\n\t */\n\t@Override\n\tprotected SetOperator getEquivalentSetOperator() {\n\t\treturn SetOperator.Exclusive;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.ANY#validateEx()\n\t */\n\t@Override\n\tpublic Collection<IResultDetail> validateEx() {\n\t\tList<IResultDetail> retVal = new ArrayList<IResultDetail>();\n        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));\n        if (this.m_minuend == null || this.m_minuend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Minuend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        if (this.m_subtrahend == null || this.m_subtrahend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Subtrahend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        return retVal;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.HXIT#validate()\n\t */\n\t@Override\n\tpublic boolean validate() {\n\t\tboolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());\n        return isValid;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = super.hashCode();\n\t\tresult = prime * result\n\t\t\t\t+ ((m_minuend == null) ? 0 : m_minuend.hashCode());\n\t\tresult = prime * result\n\t\t\t\t+ ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());\n\t\treturn result;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.equals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tQSD<T> other = (QSD<T>) obj;\n\t\tif (m_minuend == null) {\n\t\t\tif (other.m_minuend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_minuend.equals(other.m_minuend))\n\t\t\treturn false;\n\t\tif (m_subtrahend == null) {\n\t\t\tif (other.m_subtrahend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_subtrahend.equals(other.m_subtrahend))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n"]], "pred": {"ppl": 1.5894267559051514, "ppl_lower": 1.95928955078125, "ppl/lowercase_ppl": -1.4514901025969573, "ppl/zlib": 0.00035050939511951213, "Min_5.0% Prob": 5.6736286668216485, "Min_10.0% Prob": 3.84251231656355, "Min_20.0% Prob": 2.235020078134303, "Min_30.0% Prob": 1.5359609093809246, "Min_40.0% Prob": 1.1560243219797544, "Min_50.0% Prob": 0.9267666749136774, "Min_60.0% Prob": 0.7730247444958619}}
{"hexsha": "24ef2e880679f1e3b10ea8823a888c5bb2050a57", "ext": "java", "lang": "Java", "content": "public class LocalResourceSimpleAdapterTest extends AndroidTestCase {\n\n  public void testEagerAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertFalse(simpleAdapter.isLazy());\n  }\n\n  public void testLazyAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertTrue(simpleAdapter.isLazy());\n  }\n\n  private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {\n    Assert.assertNotNull(simpleAdapter);\n    Assert.assertEquals(10, requestedSize);\n    Assert.assertEquals(simpleAdapter.getSize(), requestedSize);\n    Uri firstUri = simpleAdapter.get(0);\n    assertNotNull(firstUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file1\"), firstUri);\n    Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);\n    assertNotNull(lastUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file10\"), lastUri);\n  }\n}", "class_id": 0, "repo": "app9gag/fresco", "file": "samples/scrollperf/src/androidTest/java/com/facebook/samples/scrollperf/data/impl/LocalResourceSimpleAdapterTest.java", "last_update_at": "2021-07-10T00:32:19+00:00", "question_id": "24ef2e880679f1e3b10ea8823a888c5bb2050a57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocalResourceSimpleAdapterTest extends AndroidTestCase {\n  public void testEagerAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertFalse(simpleAdapter.isLazy());\n  }\n  public void testLazyAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertTrue(simpleAdapter.isLazy());\n  }\n  private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {\n    Assert.assertNotNull(simpleAdapter);\n    Assert.assertEquals(10, requestedSize);\n    Assert.assertEquals(simpleAdapter.getSize(), requestedSize);\n    Uri firstUri = simpleAdapter.get(0);\n    assertNotNull(firstUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file1\"), firstUri);\n    Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);\n    assertNotNull(lastUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file10\"), lastUri);\n  }\n"]], "pred": {"ppl": 1.759093999862671, "ppl_lower": 2.008242607116699, "ppl/lowercase_ppl": -1.2345279182309965, "ppl/zlib": 0.00136096121374398, "Min_5.0% Prob": 6.172262657256353, "Min_10.0% Prob": 4.396794285885123, "Min_20.0% Prob": 2.6892398184743422, "Min_30.0% Prob": 1.8667585898105425, "Min_40.0% Prob": 1.410794520644205, "Min_50.0% Prob": 1.1304579345790082, "Min_60.0% Prob": 0.9423294894870002}}
{"hexsha": "0556eb05af9e2291d3785cc5ac51b749d932d51e", "ext": "java", "lang": "Java", "content": "public class HandleResponseImpl implements ResponseHandler<ResponseDto> {\n\n    @Override\n    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {\n        ResponseDto response = new ResponseDto();\n        if (null != httpResponse) {\n            response.setResponse(httpResponse);\n            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());\n            for (Header header : httpResponse.getAllHeaders()) {\n                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));\n            }\n            response.setContentType(response.getHeader(\"Content-Type\"));\n            response.setRequestId(response.getHeader(\"X-Ca-Request-Id\"));\n            response.setErrorMessage(response.getHeader(\"X-Ca-Error-Message\"));\n            if (httpResponse.getEntity() == null) {\n                response.setBody(null);\n            } else {\n                String s = readStreamAsStr(httpResponse.getEntity().getContent());\n                response.setBody(s);\n                response.setErrorMessage(s);\n            }\n        } else {\n            response.setStatusCode(500);\n            response.setErrorMessage(\"No Response\");\n        }\n        return response;\n    }\n\n    public static String readStreamAsStr(InputStream is) throws IOException {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            WritableByteChannel dest = Channels.newChannel(bos); ReadableByteChannel src = Channels.newChannel(is);) {\n            ByteBuffer bb = ByteBuffer.allocate(4096);\n            while (src.read(bb) != -1) {\n                bb.flip();\n                dest.write(bb);\n                bb.clear();\n            }\n            return new String(bos.toByteArray(), StandardCharsets.UTF_8);\n        }\n\n    }\n}", "class_id": 0, "repo": "MasterChenJiaWang/dahua-sdk", "file": "src/main/java/com/daren/chen/dahua/api/utils/HandleResponseImpl.java", "last_update_at": "2021-08-06T12:36:06+00:00", "question_id": "0556eb05af9e2291d3785cc5ac51b749d932d51e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HandleResponseImpl implements ResponseHandler<ResponseDto> {\n    @Override\n    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {\n        ResponseDto response = new ResponseDto();\n        if (null != httpResponse) {\n            response.setResponse(httpResponse);\n            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());\n            for (Header header : httpResponse.getAllHeaders()) {\n                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));\n            }\n            response.setContentType(response.getHeader(\"Content-Type\"));\n            response.setRequestId(response.getHeader(\"X-Ca-Request-Id\"));\n            response.setErrorMessage(response.getHeader(\"X-Ca-Error-Message\"));\n            if (httpResponse.getEntity() == null) {\n                response.setBody(null);\n            } else {\n                String s = readStreamAsStr(httpResponse.getEntity().getContent());\n                response.setBody(s);\n                response.setErrorMessage(s);\n            }\n        } else {\n            response.setStatusCode(500);\n            response.setErrorMessage(\"No Response\");\n        }\n        return response;\n    }\n    public static String readStreamAsStr(InputStream is) throws IOException {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            WritableByteChannel dest = Channels.newChannel(bos); ReadableByteChannel src = Channels.newChannel(is);) {\n            ByteBuffer bb = ByteBuffer.allocate(4096);\n            while (src.read(bb) != -1) {\n                bb.flip();\n                dest.write(bb);\n                bb.clear();\n            }\n            return new String(bos.toByteArray(), StandardCharsets.UTF_8);\n        }\n    }\n"]], "pred": {"ppl": 1.7282809019088745, "ppl_lower": 1.9755334854125977, "ppl/lowercase_ppl": -1.2443878881954522, "ppl/zlib": 0.0008810422160155049, "Min_5.0% Prob": 5.8770119602029975, "Min_10.0% Prob": 4.003240177366469, "Min_20.0% Prob": 2.5159631113211316, "Min_30.0% Prob": 1.7833288622033947, "Min_40.0% Prob": 1.3611190204832764, "Min_50.0% Prob": 1.090963786275081, "Min_60.0% Prob": 0.9121282647658304}}
{"hexsha": "9ef0a07c6c93211f564dd0ee9ac62d005881284a", "ext": "java", "lang": "Java", "content": "public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());\n    final static String HTTP_HEADER_NAME = \"Authorization\";\n    final static String HTTP_HEADER_VALUE_PREFIX = \"Bearer \";\n\n    final static String OIDC = \"oidc\";\n    public ServiceConfiguration conf;\n    public ConfigurationCacheService configCache;\n    private PulsarAuthorizationProvider defaultProvider;\n    private OidcTenantConfig oidcConfig;\n\n    public AuthorizationProviderOidc() { }\n\n    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache)\n            throws IOException {\n        initialize(conf, configCache);\n    }\n\n    @Override\n    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        this.conf = conf;\n        this.configCache = configCache;\n        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);\n        this.oidcConfig = new OidcConfig(conf);\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if(!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canProduceAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canLookupAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.isSuperUser(role, serviceConfiguration);\n        }\n\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    // TODO should this not be part of the OIDC client setup?\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {\n        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {\n        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);\n    }\n\n    @Override\n    public void close() throws IOException {\n        // NOP\n    }\n\n\n    @Override\n    public void initialize(ServiceConfiguration config) throws IOException {\n        this.oidcConfig = new OidcConfig(config);\n    }\n\n    @Override\n    public String getAuthMethodName() {\n        return OIDC;\n    }\n\n    @Override\n    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {\n        String biscuit = getJwt(authData);\n        return parseBiscuit(biscuit);\n    }\n\n    private static String validateJwt(final String jwt) throws AuthenticationException {\n        // Key check\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        } else {\n            throw new AuthenticationException(\"Blank biscuit found\");\n        }\n    }\n\n    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {\n        if (authData.hasDataFromCommand()) {\n            // Authenticate Pulsar binary connection\n            return authData.getCommandData();\n        } else if (authData.hasDataFromHttp()) {\n            // Authentication HTTP request. The format here should be compliant to RFC-6750\n            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx\n            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);\n            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {\n                throw new AuthenticationException(\"Invalid HTTP Authorization header\");\n            }\n\n            // Remove prefix\n            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());\n            return validateJwt(jwt);\n        } else {\n            throw new AuthenticationException(\"No JWT credentials passed\");\n        }\n    }\n\n    private String parseBiscuit(final String jwt) throws AuthenticationException {\n        LOGGER.info(\"Jwt to parse: {}\", jwt);\n\n//        Either<Error, Biscuit> deser = Biscuit.from_bytes(Base64.getUrlDecoder().decode(biscuit));\n//\n//        if (deser.isLeft()) {\n//            throw new AuthenticationException(\"Could not deserialize biscuit\");\n//        } else {\n//            Biscuit realBiscuit = deser.get();\n//            LOGGER.info(\"Deserialized biscuit\");\n//\n//            if (realBiscuit.check_root_key(rootKey).isLeft()) {\n//                throw new AuthenticationException(\"This biscuit was not generated with the expected root key\");\n//            }\n//            LOGGER.info(\"Root key is valid\");\n//\n//            byte[] sealed = realBiscuit.seal(BISCUIT_SEALING_KEY.getBytes()).get();\n//            LOGGER.info(\"Biscuit deserialized and sealed\");\n//            return \"biscuit:\" + Base64.getEncoder().encodeToString(sealed);\n//        }\n        // TODO\n        return \"\";\n    }\n}", "class_id": 0, "repo": "mvniekerk/poc-apache-pulsar-authz-oidc", "file": "src/main/java/za/co/koperfontein/poc/pulsar/oidc/AuthorizationProviderOidc.java", "last_update_at": "2021-11-18T16:58:34+00:00", "question_id": "9ef0a07c6c93211f564dd0ee9ac62d005881284a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());\n    final static String HTTP_HEADER_NAME = \"Authorization\";\n    final static String HTTP_HEADER_VALUE_PREFIX = \"Bearer \";\n    final static String OIDC = \"oidc\";\n    public ServiceConfiguration conf;\n    public ConfigurationCacheService configCache;\n    private PulsarAuthorizationProvider defaultProvider;\n    private OidcTenantConfig oidcConfig;\n    public AuthorizationProviderOidc() { }\n    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache)\n            throws IOException {\n        initialize(conf, configCache);\n    }\n    @Override\n    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        this.conf = conf;\n        this.configCache = configCache;\n        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);\n        this.oidcConfig = new OidcConfig(conf);\n    }\n    @Override\n    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if(!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canProduceAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canLookupAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.isSuperUser(role, serviceConfiguration);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    // TODO should this not be part of the OIDC client setup?\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);\n    }\n    @Override\n    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {\n        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);\n    }\n    @Override\n    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {\n        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);\n    }\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);\n    }\n    @Override\n    public void close() throws IOException {\n        // NOP\n    }\n    @Override\n    public void initialize(ServiceConfiguration config) throws IOException {\n        this.oidcConfig = new OidcConfig(config);\n    }\n    @Override\n    public String getAuthMethodName() {\n        return OIDC;\n    }\n    @Override\n    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {\n        String biscuit = getJwt(authData);\n        return parseBiscuit(biscuit);\n    }\n    private static String validateJwt(final String jwt) throws AuthenticationException {\n        // Key check\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        } else {\n            throw new AuthenticationException(\"Blank biscuit found\");\n        }\n    }\n    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {\n        if (authData.hasDataFromCommand()) {\n            // Authenticate Pulsar binary connection\n            return authData.getCommandData();\n        } else if (authData.hasDataFromHttp()) {\n            // Authentication HTTP request. The format here should be compliant to RFC-6750\n            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx\n            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);\n            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {\n                throw new AuthenticationException(\"Invalid HTTP Authorization header\");\n            }\n            // Remove prefix\n            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());\n            return validateJwt(jwt);\n        } else {\n            throw new AuthenticationException(\"No JWT credentials passed\");\n        }\n    }\n    private String parseBiscuit(final String jwt) throws AuthenticationException {\n        LOGGER.info(\"Jwt to parse: {}\", jwt);\n//        Either<Error, Biscuit> deser = Biscuit.from_bytes(Base64.getUrlDecoder().decode(biscuit));\n//\n//        if (deser.isLeft()) {\n//            throw new AuthenticationException(\"Could not deserialize biscuit\");\n//        } else {\n//            Biscuit realBiscuit = deser.get();\n//            LOGGER.info(\"Deserialized biscuit\");\n//\n//            if (realBiscuit.check_root_key(rootKey).isLeft()) {\n//                throw new AuthenticationException(\"This biscuit was not generated with the expected root key\");\n//            }\n//            LOGGER.info(\"Root key is valid\");\n//\n//            byte[] sealed = realBiscuit.seal(BISCUIT_SEALING_KEY.getBytes()).get();\n//            LOGGER.info(\"Biscuit deserialized and sealed\");\n//            return \"biscuit:\" + Base64.getEncoder().encodeToString(sealed);\n//        }\n        // TODO\n        return \"\";\n    }\n"]], "pred": {"ppl": 1.4752497673034668, "ppl_lower": 1.6971725225448608, "ppl/lowercase_ppl": -1.3604076457475922, "ppl/zlib": 0.0002406109586766718, "Min_5.0% Prob": 5.153047220379698, "Min_10.0% Prob": 3.3989401132452723, "Min_20.0% Prob": 1.9051635316481776, "Min_30.0% Prob": 1.2925344473603213, "Min_40.0% Prob": 0.9707354202998625, "Min_50.0% Prob": 0.77790548213404, "Min_60.0% Prob": 0.6487476098022444}}
{"hexsha": "ac8564a3b708ca4495959d57dc906f61cac2ece9", "ext": "java", "lang": "Java", "content": "public class LeftJoinTest {\n    @Test\n    public void testLeftJoin(){\n        HashMap one = new HashMap();\n        one.put(\"kis\",\"pande\");\n        one.put(\"kiss\",\"pan\");\n        one.put(\"kisss\",\"pnde\");\n        one.put(\"kissss\",\"pae\");\n\n        HashMap two = new HashMap();\n        two.put(\"kis\",\"Sarvin\");\n        two.put(\"kiss\",\"Srvin\");\n        two.put(\"kisss\",\"Savin\");\n        two.put(\"kissss\",\"Sarvn\");\n\n        HashMap<String,String[]> test = LeftJoin.leftJoin(one,two);\n        assertEquals(\"\",4 , test.size());\n        assertTrue(\"\",test.containsKey(\"kisss\"));\n        assertEquals(\"\",\"pande\",test.get(\"kis\")[0]);\n\n    }\n\n}", "class_id": 0, "repo": "kishorpan2/data-structures-and-algorithms", "file": "code401Challenges/src/test/java/code401Challenges/hashTable/LeftJoinTest.java", "last_update_at": "2021-05-08T15:13:22+00:00", "question_id": "ac8564a3b708ca4495959d57dc906f61cac2ece9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LeftJoinTest {\n    @Test\n    public void testLeftJoin(){\n        HashMap one = new HashMap();\n        one.put(\"kis\",\"pande\");\n        one.put(\"kiss\",\"pan\");\n        one.put(\"kisss\",\"pnde\");\n        one.put(\"kissss\",\"pae\");\n        HashMap two = new HashMap();\n        two.put(\"kis\",\"Sarvin\");\n        two.put(\"kiss\",\"Srvin\");\n        two.put(\"kisss\",\"Savin\");\n        two.put(\"kissss\",\"Sarvn\");\n        HashMap<String,String[]> test = LeftJoin.leftJoin(one,two);\n        assertEquals(\"\",4 , test.size());\n        assertTrue(\"\",test.containsKey(\"kisss\"));\n        assertEquals(\"\",\"pande\",test.get(\"kis\")[0]);\n    }\n"]], "pred": {"ppl": 2.814307689666748, "ppl_lower": 3.133453845977783, "ppl/lowercase_ppl": -1.1038154774239475, "ppl/zlib": 0.004138865180676681, "Min_5.0% Prob": 7.872189044952393, "Min_10.0% Prob": 6.376093660082136, "Min_20.0% Prob": 4.465849745841253, "Min_30.0% Prob": 3.2728399766816034, "Min_40.0% Prob": 2.534311320851831, "Min_50.0% Prob": 2.062889663748584, "Min_60.0% Prob": 1.730624773898932}}
{"hexsha": "763200963b9fac7b80736eb5620170b19b635e7e", "ext": "java", "lang": "Java", "content": "class TestingComponentD extends Component implements Cloneable {\n\n  @Prop(\n    resType = ResType.NONE,\n    optional = false\n  )\n  int prop1;\n\n  private TestingComponentD(ComponentContext context) {\n    super(\"TestingComponentD\");\n  }\n\n  public static Builder create(ComponentContext context) {\n    return create(context, 0, 0);\n  }\n\n  public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {\n    final Builder builder = new Builder();\n    TestingComponentD instance = new TestingComponentD(context);\n    builder.init(context, defStyleAttr, defStyleRes, instance);\n    return builder;\n  }\n\n  public static class Builder extends Component.Builder<Builder> {\n    @Nullable TestingComponentD mLithoComponent;\n    ComponentContext mContext;\n\n    private final String[] REQUIRED_PROPS_NAMES = new String[] {\"prop1\"};\n    private final int REQUIRED_PROPS_COUNT = 1;\n    private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n\n    private void init(\n        ComponentContext context,\n        int defStyleAttr,\n        int defStyleRes,\n        TestingComponentD lithoComponentRef) {\n      super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);\n      mLithoComponent = lithoComponentRef;\n      mContext = context;\n      mRequired.clear();\n    }\n\n    @Override\n    protected void setComponent(Component component) {\n      mLithoComponent = (TestingComponentD) component;\n    }\n\n    public Builder prop1(int prop1) {\n      this.mLithoComponent.prop1 = prop1;\n      mRequired.set(0);\n      return this;\n    }\n\n    @Override\n    public @Nullable TestingComponentD build() {\n      checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n      return mLithoComponent;\n    }\n\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n  }\n}", "class_id": 5, "repo": "penguin-wwy/redex", "file": "test/instr/RemoveBuilderPatternTest.java", "last_update_at": "2021-12-28T09:52:33+00:00", "question_id": "763200963b9fac7b80736eb5620170b19b635e7e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TestingComponentD extends Component implements Cloneable {\n  @Prop(\n    resType = ResType.NONE,\n    optional = false\n  )\n  int prop1;\n  private TestingComponentD(ComponentContext context) {\n    super(\"TestingComponentD\");\n  }\n  public static Builder create(ComponentContext context) {\n    return create(context, 0, 0);\n  }\n  public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {\n    final Builder builder = new Builder();\n    TestingComponentD instance = new TestingComponentD(context);\n    builder.init(context, defStyleAttr, defStyleRes, instance);\n    return builder;\n  }\n  public static class Builder extends Component.Builder<Builder> {\n    @Nullable TestingComponentD mLithoComponent;\n    ComponentContext mContext;\n    private final String[] REQUIRED_PROPS_NAMES = new String[] {\"prop1\"};\n    private final int REQUIRED_PROPS_COUNT = 1;\n    private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n    private void init(\n        ComponentContext context,\n        int defStyleAttr,\n        int defStyleRes,\n        TestingComponentD lithoComponentRef) {\n      super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);\n      mLithoComponent = lithoComponentRef;\n      mContext = context;\n      mRequired.clear();\n    }\n    @Override\n    protected void setComponent(Component component) {\n      mLithoComponent = (TestingComponentD) component;\n    }\n    public Builder prop1(int prop1) {\n      this.mLithoComponent.prop1 = prop1;\n      mRequired.set(0);\n      return this;\n    }\n    @Override\n    public @Nullable TestingComponentD build() {\n      checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n      return mLithoComponent;\n    }\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n  }\n"]], "pred": {"ppl": 1.6515928506851196, "ppl_lower": 2.260683536529541, "ppl/lowercase_ppl": -1.6256764748355674, "ppl/zlib": 0.0008695670473134611, "Min_5.0% Prob": 5.543126865669533, "Min_10.0% Prob": 3.8942229924378573, "Min_20.0% Prob": 2.3423261154029102, "Min_30.0% Prob": 1.6429694316085475, "Min_40.0% Prob": 1.2512281735220716, "Min_50.0% Prob": 1.001670109558287, "Min_60.0% Prob": 0.8363618909316853}}
{"hexsha": "23db7ae693e11efffaedcecc41a12084a78574f9", "ext": "java", "lang": "Java", "content": "public class Aufgabe1 {\n\n\n//    Aufgabe 1 \u2014 Summe aller Arrayelemente:\n//    Vervollst\u00e4ndigen Sie das folgende Programm, so dass\n//    es die Summe aller Elemente des Arrays berechnet.\n//    Schreiben Sie das Programm, so dass es sogar dann\n//        funktioniert, wenn die Dimensionen der Zeilen und\n//    Spalten ge\u00e4ndert werden. (Mit anderen Worten,\n//    verwenden Sie eher length als fest kodierte Zahlen).\n\n    public static void aufg() {\n\n\n\n\n        int[][] data = { {3, 2, 5, 7},\n                {1, 4, 4, 8},\n                {9, 1, 0, 2},\n                {0, 2, 6, 3} };\n        // Summe deklarieren\n        int summe = 0;\n        // Summe berechnen\n        for ( int zeile=0; zeile < data.length; zeile++)\n        {\n            for ( int spalte = 0; spalte < data[zeile].length; spalte++)\n            {\n                summe += data[spalte][zeile];\n            }\n        }\n\n        // Summe ausgeben\n        System.out.println(\"Summe: \" + summe);\n\n\n\n\n    }\n\n\n\n}", "class_id": 0, "repo": "deanomus/SZUT", "file": "src/de/deanomus/FirstLehrjahr/A20_1_Mehrdimensionale_Arrays/Aufgabe1.java", "last_update_at": "2021-10-13T20:56:24+00:00", "question_id": "23db7ae693e11efffaedcecc41a12084a78574f9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Aufgabe1 {\n//    Aufgabe 1 \u2014 Summe aller Arrayelemente:\n//    Vervollst\u00e4ndigen Sie das folgende Programm, so dass\n//    es die Summe aller Elemente des Arrays berechnet.\n//    Schreiben Sie das Programm, so dass es sogar dann\n//        funktioniert, wenn die Dimensionen der Zeilen und\n//    Spalten ge\u00e4ndert werden. (Mit anderen Worten,\n//    verwenden Sie eher length als fest kodierte Zahlen).\n    public static void aufg() {\n        int[][] data = { {3, 2, 5, 7},\n                {1, 4, 4, 8},\n                {9, 1, 0, 2},\n                {0, 2, 6, 3} };\n        // Summe deklarieren\n        int summe = 0;\n        // Summe berechnen\n        for ( int zeile=0; zeile < data.length; zeile++)\n        {\n            for ( int spalte = 0; spalte < data[zeile].length; spalte++)\n            {\n                summe += data[spalte][zeile];\n            }\n        }\n        // Summe ausgeben\n        System.out.println(\"Summe: \" + summe);\n    }\n"]], "pred": {"ppl": 3.163510322570801, "ppl_lower": 3.468837022781372, "ppl/lowercase_ppl": -1.080002198015221, "ppl/zlib": 0.0024043471244711914, "Min_5.0% Prob": 8.176337748765945, "Min_10.0% Prob": 6.359461177479137, "Min_20.0% Prob": 4.421517585640523, "Min_30.0% Prob": 3.421297184311517, "Min_40.0% Prob": 2.766325073010886, "Min_50.0% Prob": 2.2723718783152953, "Min_60.0% Prob": 1.908687804927035}}
{"hexsha": "a9493bf8c49764bbd03c7dd221f326510d0d8afa", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class CooldownsTest {\n\n    private static final String ENCHANT_NAME = \"enchantName\";\n    private static final UUID USER_ID = UUID.randomUUID();\n\n    @Mock\n    private Clock clock;\n    @Mock\n    private CustomEnchantment enchantment;\n    @Mock\n    private LivingEntity user;\n    @Mock\n    private Settings settings;\n\n    @Before\n    public void setUp() throws Exception {\n        TestUtils.set(Cooldowns.class, \"clock\", clock);\n\n        when(enchantment.getName()).thenReturn(ENCHANT_NAME);\n        when(user.getUniqueId()).thenReturn(USER_ID);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n\n    @Test\n    public void configure() throws Exception {\n        Cooldowns.configure(settings, 12, 23);\n\n        verify(settings).set(\"cooldown\", 12, 23);\n    }\n\n    @Test\n    public void secondsLeft() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 14);\n    }\n\n    @Test\n    public void secondsLeft_roundedUp() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1000L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(1.0);\n\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 1);\n    }\n\n    @Test\n    public void onCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n\n    @Test\n    public void onCooldown_exact() throws Exception {\n        when(clock.millis()).thenReturn(100L, 15100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void onCooldown_offCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduce() throws Exception {\n        when(clock.millis()).thenReturn(100L, 10100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, 6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduceNegative() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, -6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n}", "class_id": 0, "repo": "Eniripsa96/EnchantmentAPI", "file": "tst/com/sucy/enchant/api/CooldownsTest.java", "last_update_at": "2021-05-09T13:51:15+00:00", "question_id": "a9493bf8c49764bbd03c7dd221f326510d0d8afa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class CooldownsTest {\n    private static final String ENCHANT_NAME = \"enchantName\";\n    private static final UUID USER_ID = UUID.randomUUID();\n    @Mock\n    private Clock clock;\n    @Mock\n    private CustomEnchantment enchantment;\n    @Mock\n    private LivingEntity user;\n    @Mock\n    private Settings settings;\n    @Before\n    public void setUp() throws Exception {\n        TestUtils.set(Cooldowns.class, \"clock\", clock);\n        when(enchantment.getName()).thenReturn(ENCHANT_NAME);\n        when(user.getUniqueId()).thenReturn(USER_ID);\n    }\n    @After\n    public void tearDown() throws Exception {\n    }\n    @Test\n    public void configure() throws Exception {\n        Cooldowns.configure(settings, 12, 23);\n        verify(settings).set(\"cooldown\", 12, 23);\n    }\n    @Test\n    public void secondsLeft() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 14);\n    }\n    @Test\n    public void secondsLeft_roundedUp() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1000L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(1.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 1);\n    }\n    @Test\n    public void onCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n    @Test\n    public void onCooldown_exact() throws Exception {\n        when(clock.millis()).thenReturn(100L, 15100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n    @Test\n    public void onCooldown_offCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n    @Test\n    public void reduce() throws Exception {\n        when(clock.millis()).thenReturn(100L, 10100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, 6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n    @Test\n    public void reduceNegative() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, -6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n"]], "pred": {"ppl": 1.4491103887557983, "ppl_lower": 1.5987491607666016, "ppl/lowercase_ppl": -1.2649191195001004, "ppl/zlib": 0.0006172210368602437, "Min_5.0% Prob": 4.768847778731701, "Min_10.0% Prob": 3.1375070050650953, "Min_20.0% Prob": 1.8109484130114901, "Min_30.0% Prob": 1.2311042505833838, "Min_40.0% Prob": 0.9257671886390134, "Min_50.0% Prob": 0.7421662204433233, "Min_60.0% Prob": 0.6189530375454427}}
{"hexsha": "13885d2553f83227a07c14f88340bf149ac6a251", "ext": "java", "lang": "Java", "content": "public class IndexBall extends CommandBase {\n\t\n\tFeederSubsystem feeder;\n\tint targetPositon;\n\tint incrementTicks;\n\tboolean reversing;\n\tboolean isDone;\n\n\tboolean maxBalls;\n\tboolean outputSwitchPressed;\n\n\tprivate final boolean setTalonPosistionEveryCycle = true;\n\t\n\n\tpublic IndexBall() {\n\t\t\n\t\tfeeder = FeederSubsystem.getInstance();\n\n\t\taddRequirements(feeder);\n\t}\n\n\t// Called when the command is initially scheduled.\n\t@Override\n\tpublic void initialize() {\n\t\tincrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();\n\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\ttargetPositon = currentPosition + incrementTicks;\n\n\t\treversing = false;\n\t\tisDone = false;\n\n\t\tif (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {\n\t\t\tmaxBalls = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tmaxBalls = false;\n\t\toutputSwitchPressed = false;\n\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t\n\t}\n\n\t// Called every time the scheduler runs while the command is scheduled.\n\t@Override\n\tpublic void execute() {\n\t\tif (maxBalls == true) {\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t}\n\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\tboolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);\n\t\tint ticksChanged = currentPosition - (targetPositon - incrementTicks);\n\t\t\n\t\tif (currentPosition >= targetPositon || atPosistion) {\n\t\t\tisDone = true;\n\t\t} else if (reversing) {\n\t\t\tif (atPosistion) {\n\t\t\t\tisDone = true;\n\t\t\t} else if(setTalonPosistionEveryCycle) {\n\t\t\t\tfeeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t}\n\t\t// } else if (feeder.isBallAtInput() == false && ticksChanged < Config.FEEDERSUBSYSTEM_POS_PAST_SWITCH) {\n\t\t\t// Limit unpressed & in range that it should be pressed then reverse, likely ball bounced away\n\t\t\t// feeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t// reversing = true;\n\t\t} else if (setTalonPosistionEveryCycle) {\n\t\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t}\n\n\t}\n\n\t// Called once the command ends or is interrupted.\n\t@Override\n\tpublic void end(boolean interrupted) {\n\t\tif (reversing == false && maxBalls == false && outputSwitchPressed == false) {\n\t\t\tfeeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);\n\t\t}\n\n\t\tif (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {\n\t\t\tfeeder.setFeederPosistion((int) feeder.getCurrentPosition());\n\t\t\tfeeder.stopFeeder();\n\t\t}\n\t}\n\n\t// Returns true when the command should end.\n\t@Override\n\tpublic boolean isFinished() {\n\t\treturn isDone;\n\t}\n}", "class_id": 0, "repo": "davidliu-2706/2022-Test", "file": "src/main/java/frc/robot/commands/IndexBall.java", "last_update_at": "2021-11-10T21:09:19+00:00", "question_id": "13885d2553f83227a07c14f88340bf149ac6a251", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IndexBall extends CommandBase {\n\t\n\tFeederSubsystem feeder;\n\tint targetPositon;\n\tint incrementTicks;\n\tboolean reversing;\n\tboolean isDone;\n\tboolean maxBalls;\n\tboolean outputSwitchPressed;\n\tprivate final boolean setTalonPosistionEveryCycle = true;\n\t\n\tpublic IndexBall() {\n\t\t\n\t\tfeeder = FeederSubsystem.getInstance();\n\t\taddRequirements(feeder);\n\t}\n\t// Called when the command is initially scheduled.\n\t@Override\n\tpublic void initialize() {\n\t\tincrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\ttargetPositon = currentPosition + incrementTicks;\n\t\treversing = false;\n\t\tisDone = false;\n\t\tif (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {\n\t\t\tmaxBalls = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t}\n\t\tmaxBalls = false;\n\t\toutputSwitchPressed = false;\n\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t\n\t}\n\t// Called every time the scheduler runs while the command is scheduled.\n\t@Override\n\tpublic void execute() {\n\t\tif (maxBalls == true) {\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t}\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\tboolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);\n\t\tint ticksChanged = currentPosition - (targetPositon - incrementTicks);\n\t\t\n\t\tif (currentPosition >= targetPositon || atPosistion) {\n\t\t\tisDone = true;\n\t\t} else if (reversing) {\n\t\t\tif (atPosistion) {\n\t\t\t\tisDone = true;\n\t\t\t} else if(setTalonPosistionEveryCycle) {\n\t\t\t\tfeeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t}\n\t\t// } else if (feeder.isBallAtInput() == false && ticksChanged < Config.FEEDERSUBSYSTEM_POS_PAST_SWITCH) {\n\t\t\t// Limit unpressed & in range that it should be pressed then reverse, likely ball bounced away\n\t\t\t// feeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t// reversing = true;\n\t\t} else if (setTalonPosistionEveryCycle) {\n\t\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t}\n\t}\n\t// Called once the command ends or is interrupted.\n\t@Override\n\tpublic void end(boolean interrupted) {\n\t\tif (reversing == false && maxBalls == false && outputSwitchPressed == false) {\n\t\t\tfeeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);\n\t\t}\n\t\tif (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {\n\t\t\tfeeder.setFeederPosistion((int) feeder.getCurrentPosition());\n\t\t\tfeeder.stopFeeder();\n\t\t}\n\t}\n\t// Returns true when the command should end.\n\t@Override\n\tpublic boolean isFinished() {\n\t\treturn isDone;\n\t}\n"]], "pred": {"ppl": 2.0464231967926025, "ppl_lower": 2.317293405532837, "ppl/lowercase_ppl": -1.1735895998404446, "ppl/zlib": 0.0008064115846766628, "Min_5.0% Prob": 6.606658239364624, "Min_10.0% Prob": 4.954157512187958, "Min_20.0% Prob": 3.2543142541724057, "Min_30.0% Prob": 2.331817158086355, "Min_40.0% Prob": 1.7798870430693994, "Min_50.0% Prob": 1.4290842267482822, "Min_60.0% Prob": 1.193921870612238}}
{"hexsha": "f5cc2e0b1cbf8f1821a97d425e7f630fd91e4d34", "ext": "java", "lang": "Java", "content": "public abstract class ObjProperty extends AbstractParseTreeNode {\n  private static final long serialVersionUID = 3384973990326624609L;\n\n  public ObjProperty(StringLiteral name, Expression value) {\n    this(FilePosition.span(name.getFilePosition(), value.getFilePosition()),\n         name, value);\n  }\n\n  public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {\n    super(pos, Expression.class);\n    this.createMutation().appendChild(name).appendChild(value).execute();\n  }\n\n  /**\n   * Provided for reflection.\n   * @param value unused\n   */\n  protected ObjProperty(\n      FilePosition pos, Void value, List<? extends Expression> children) {\n    this(pos, (StringLiteral) children.get(0), children.get(1));\n    assert children.size() == 2;\n  }\n\n  @Override public final Object getValue() { return null; }\n\n  @Override\n  public List<? extends Expression> children() {\n    return childrenAs(Expression.class);\n  }\n\n  public final StringLiteral getPropertyNameNode() {\n    return (StringLiteral) children().get(0);\n  }\n\n  @Override\n  public void childrenChanged() {\n    super.childrenChanged();\n    if (2 != children().size()) { throw new IndexOutOfBoundsException(); }\n    getPropertyName();\n  }\n\n  public final String getPropertyName() {\n    return ((StringLiteral) children().get(0)).getUnquotedValue();\n  }\n\n  public boolean isPropertyNameQuoted() {\n    StringLiteral name = (StringLiteral) children().get(0);\n    String rawName = name.getValue();\n    if (rawName.length() == 0) { return false; }\n    char ch0 = rawName.charAt(0);\n    return ch0 == '\"' || ch0 == '\\'';\n  }\n\n  public final TokenConsumer makeRenderer(\n      Appendable out, Callback<IOException> handler) {\n    return new JsPrettyPrinter(new Concatenator(out, handler));\n  }\n\n  protected final void renderPropertyName(\n      RenderContext rc, boolean preferUnquoted) {\n    StringLiteral key = (StringLiteral) children().get(0);\n    TokenConsumer out = rc.getOut();\n    boolean unquoted = preferUnquoted;\n    switch (rc.propertyNameQuotingMode()) {\n      case NO_QUOTES: unquoted = true; break;\n      case PRESERVE_QUOTES:\n        String name = key.getValue();\n        if (name.length() == 0) {\n          unquoted = true;\n        } else {\n          char ch = name.charAt(0);\n          if (ch != '\"' && ch != '\\'') {\n            unquoted = true;\n          }\n        }\n        break;\n      default: break;\n    }\n    if (unquoted || preferUnquoted) {\n      String uqVal = key.getUnquotedValue();\n      if (ParserBase.isJavascriptIdentifier(uqVal)\n          && !(\"get\".equals(uqVal) || \"set\".equals(uqVal))) {\n        out.mark(key.getFilePosition());\n        out.consume(uqVal);\n        return;\n      }\n    }\n    key.render(rc);\n  }\n}", "class_id": 0, "repo": "michaelfig/caja", "file": "src/com/google/caja/parser/js/ObjProperty.java", "last_update_at": "2021-01-28T19:10:42+00:00", "question_id": "f5cc2e0b1cbf8f1821a97d425e7f630fd91e4d34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class ObjProperty extends AbstractParseTreeNode {\n  private static final long serialVersionUID = 3384973990326624609L;\n  public ObjProperty(StringLiteral name, Expression value) {\n    this(FilePosition.span(name.getFilePosition(), value.getFilePosition()),\n         name, value);\n  }\n  public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {\n    super(pos, Expression.class);\n    this.createMutation().appendChild(name).appendChild(value).execute();\n  }\n  /**\n   * Provided for reflection.\n   * @param value unused\n   */\n  protected ObjProperty(\n      FilePosition pos, Void value, List<? extends Expression> children) {\n    this(pos, (StringLiteral) children.get(0), children.get(1));\n    assert children.size() == 2;\n  }\n  @Override public final Object getValue() { return null; }\n  @Override\n  public List<? extends Expression> children() {\n    return childrenAs(Expression.class);\n  }\n  public final StringLiteral getPropertyNameNode() {\n    return (StringLiteral) children().get(0);\n  }\n  @Override\n  public void childrenChanged() {\n    super.childrenChanged();\n    if (2 != children().size()) { throw new IndexOutOfBoundsException(); }\n    getPropertyName();\n  }\n  public final String getPropertyName() {\n    return ((StringLiteral) children().get(0)).getUnquotedValue();\n  }\n  public boolean isPropertyNameQuoted() {\n    StringLiteral name = (StringLiteral) children().get(0);\n    String rawName = name.getValue();\n    if (rawName.length() == 0) { return false; }\n    char ch0 = rawName.charAt(0);\n    return ch0 == '\"' || ch0 == '\\'';\n  }\n  public final TokenConsumer makeRenderer(\n      Appendable out, Callback<IOException> handler) {\n    return new JsPrettyPrinter(new Concatenator(out, handler));\n  }\n  protected final void renderPropertyName(\n      RenderContext rc, boolean preferUnquoted) {\n    StringLiteral key = (StringLiteral) children().get(0);\n    TokenConsumer out = rc.getOut();\n    boolean unquoted = preferUnquoted;\n    switch (rc.propertyNameQuotingMode()) {\n      case NO_QUOTES: unquoted = true; break;\n      case PRESERVE_QUOTES:\n        String name = key.getValue();\n        if (name.length() == 0) {\n          unquoted = true;\n        } else {\n          char ch = name.charAt(0);\n          if (ch != '\"' && ch != '\\'') {\n            unquoted = true;\n          }\n        }\n        break;\n      default: break;\n    }\n    if (unquoted || preferUnquoted) {\n      String uqVal = key.getUnquotedValue();\n      if (ParserBase.isJavascriptIdentifier(uqVal)\n          && !(\"get\".equals(uqVal) || \"set\".equals(uqVal))) {\n        out.mark(key.getFilePosition());\n        out.consume(uqVal);\n        return;\n      }\n    }\n    key.render(rc);\n  }\n"]], "pred": {"ppl": 2.292099952697754, "ppl_lower": 2.644392967224121, "ppl/lowercase_ppl": -1.1723671793161252, "ppl/zlib": 0.0008220697792676963, "Min_5.0% Prob": 6.439888081899503, "Min_10.0% Prob": 5.052413182086255, "Min_20.0% Prob": 3.5916457069134284, "Min_30.0% Prob": 2.6458630121324167, "Min_40.0% Prob": 2.044535465560742, "Min_50.0% Prob": 1.652501891160424, "Min_60.0% Prob": 1.3831649253931475}}
{"hexsha": "0edf3c02e23be62144e02ee6a86e492b3b1ef462", "ext": "java", "lang": "Java", "content": "public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {\n    private Spin spin;\n\n    public void setSpin(Spin spin) {\n        this.spin = spin;\n    }\n\n    @Override\n    public void apply(String pluginId) {\n        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);\n        plugin.apply(spin);\n        spin.getPluginContainer()\n                .addPlugin(pluginId, plugin);\n    }\n\n    @Override\n    public Object invokeMethod(String name, Object[] args) {\n        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {\n            Object result = tryInvokeMethod(plugin, name, args);\n            if (result != null) {\n                return result;\n            }\n        }\n        throw new NoMethodFoundException(name);\n    }\n}", "class_id": 0, "repo": "tianxunaicaoke/LogSpin", "file": "core/src/main/java/org/logSpin/script/DefaultScriptDelegate.java", "last_update_at": "2021-02-03T02:12:13+00:00", "question_id": "0edf3c02e23be62144e02ee6a86e492b3b1ef462", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {\n    private Spin spin;\n    public void setSpin(Spin spin) {\n        this.spin = spin;\n    }\n    @Override\n    public void apply(String pluginId) {\n        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);\n        plugin.apply(spin);\n        spin.getPluginContainer()\n                .addPlugin(pluginId, plugin);\n    }\n    @Override\n    public Object invokeMethod(String name, Object[] args) {\n        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {\n            Object result = tryInvokeMethod(plugin, name, args);\n            if (result != null) {\n                return result;\n            }\n        }\n        throw new NoMethodFoundException(name);\n    }\n"]], "pred": {"ppl": 2.6178228855133057, "ppl_lower": 3.1215133666992188, "ppl/lowercase_ppl": -1.1828609162617612, "ppl/zlib": 0.0027108253876249244, "Min_5.0% Prob": 7.701147174835205, "Min_10.0% Prob": 6.222182130813598, "Min_20.0% Prob": 4.245279623240959, "Min_30.0% Prob": 3.089520126581192, "Min_40.0% Prob": 2.382252465888678, "Min_50.0% Prob": 1.921388023497107, "Min_60.0% Prob": 1.6050226120948792}}
{"hexsha": "4c2bc8c459162886daf755bef05a05afec9240d5", "ext": "java", "lang": "Java", "content": "public class LinkCommand extends RemoteControlCommandBase implements Cloneable{\n\n\t@Getter\n\tprivate String repeaterCallsign;\n\n\t@Getter\n\tprivate ReconnectType reconnectType;\n\n\t@Getter\n\tprivate String reflectorCallsign;\n\n\tpublic LinkCommand() {\n\t\tsuper(RemoteControlCommandType.LINK);\n\t}\n\n\t@Override\n\tpublic LinkCommand clone() {\n\t\tLinkCommand copy = null;\n\t\tcopy = (LinkCommand)super.clone();\n\n\t\tcopy.repeaterCallsign = repeaterCallsign;\n\n\t\tcopy.reconnectType = reconnectType;\n\n\t\tcopy.reflectorCallsign = reflectorCallsign;\n\n\t\treturn copy;\n\t}\n\n\t@Override\n\tprotected String getHeader() {\n\t\treturn \"LNK\";\n\t}\n\n\t@Override\n\tprotected boolean parseCommand(ByteBuffer srcBuffer) {\n\t\tint dataLength =\n\t\t\t\tDSTARDefines.CallsignFullLength +\n\t\t\t\t4 +\n\t\t\t\tDSTARDefines.CallsignFullLength;\n\n\t\tif(srcBuffer == null || srcBuffer.remaining() < dataLength)\n\t\t\treturn false;\n\n\t\tchar[] call = new char[DSTARDefines.CallsignFullLength];\n\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\n\t\trepeaterCallsign = String.valueOf(call);\n\n\t\tint reconnectTypeValue = 0;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\treconnectTypeValue <<= 8;\n\t\t\treconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();\n\t\t}\n\n\t\tthis.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);\n\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\n\t\treflectorCallsign = String.valueOf(call);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected Optional<byte[]> assembleCommandInt() {\n\t\treturn Optional.empty();\n\t}\n\n}", "class_id": 0, "repo": "jg1uaa/NoraSeries", "file": "src/NoraCommon/src/main/java/org/jp/illg/dstar/service/remotecontrol/model/command/LinkCommand.java", "last_update_at": "2021-05-03T04:39:05+00:00", "question_id": "4c2bc8c459162886daf755bef05a05afec9240d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LinkCommand extends RemoteControlCommandBase implements Cloneable{\n\t@Getter\n\tprivate String repeaterCallsign;\n\t@Getter\n\tprivate ReconnectType reconnectType;\n\t@Getter\n\tprivate String reflectorCallsign;\n\tpublic LinkCommand() {\n\t\tsuper(RemoteControlCommandType.LINK);\n\t}\n\t@Override\n\tpublic LinkCommand clone() {\n\t\tLinkCommand copy = null;\n\t\tcopy = (LinkCommand)super.clone();\n\t\tcopy.repeaterCallsign = repeaterCallsign;\n\t\tcopy.reconnectType = reconnectType;\n\t\tcopy.reflectorCallsign = reflectorCallsign;\n\t\treturn copy;\n\t}\n\t@Override\n\tprotected String getHeader() {\n\t\treturn \"LNK\";\n\t}\n\t@Override\n\tprotected boolean parseCommand(ByteBuffer srcBuffer) {\n\t\tint dataLength =\n\t\t\t\tDSTARDefines.CallsignFullLength +\n\t\t\t\t4 +\n\t\t\t\tDSTARDefines.CallsignFullLength;\n\t\tif(srcBuffer == null || srcBuffer.remaining() < dataLength)\n\t\t\treturn false;\n\t\tchar[] call = new char[DSTARDefines.CallsignFullLength];\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\t\trepeaterCallsign = String.valueOf(call);\n\t\tint reconnectTypeValue = 0;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\treconnectTypeValue <<= 8;\n\t\t\treconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();\n\t\t}\n\t\tthis.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\t\treflectorCallsign = String.valueOf(call);\n\t\treturn true;\n\t}\n\t@Override\n\tprotected Optional<byte[]> assembleCommandInt() {\n\t\treturn Optional.empty();\n\t}\n"]], "pred": {"ppl": 1.6494851112365723, "ppl_lower": 1.9813884496688843, "ppl/lowercase_ppl": -1.3663299441106806, "ppl/zlib": 0.000884210574942677, "Min_5.0% Prob": 5.707287229340652, "Min_10.0% Prob": 3.948586872068502, "Min_20.0% Prob": 2.3919281222052495, "Min_30.0% Prob": 1.6551954716780766, "Min_40.0% Prob": 1.2479347593626517, "Min_50.0% Prob": 1.0017436685849208, "Min_60.0% Prob": 0.835776291331801}}
{"hexsha": "028d0eb48fa34b8302e7d54fb8e8862b7ef0b42c", "ext": "java", "lang": "Java", "content": "public class CustomError {\n\tprivate final Logger logger;\n\tprivate boolean some_enabled = false;\n\n\t// Options\n\tprivate boolean escalate_exceptions = false;\n\tprivate boolean equal_is_strict_equal = false;\n\tprivate boolean enforce_existing_properties = false;\n\tprivate boolean boolean_op_only_boolean_operands = false;\n\tprivate boolean arith_op_no_undefined = false;\n\tprivate boolean arith_op_no_null = false;\n\tprivate boolean arith_op_no_nan = false;\n\tprivate boolean arith_op_no_infinity = false;\n\tprivate boolean division_op_no_zero = false;\n\n\tpublic CustomError(Logger lgr) {\n\t\tthis.logger = lgr;\n\t}\n\n\t/**\n\t * Set an option for this instance.\n\t *\n\t * @param name Name of the option\n\t * @param value Option value\n\t */\n\tpublic void setOption(String name, Object value) {\n\t\ttry {\n\t\t\tswitch (name) {\n\t\t\t\tcase \"escalate_exceptions\":\n\t\t\t\t\tescalate_exceptions = (boolean) value;\n\t\t\t\t\tlogSetOption(name, escalate_exceptions);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\t\tequal_is_strict_equal = (boolean) value;\n\t\t\t\t\tlogSetOption(name, equal_is_strict_equal);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\t\tenforce_existing_properties = (boolean) value;\n\t\t\t\t\tlogSetOption(name, enforce_existing_properties);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\t\tboolean_op_only_boolean_operands = (boolean) value;\n\t\t\t\t\tlogSetOption(name, boolean_op_only_boolean_operands);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\t\tarith_op_no_undefined = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_undefined);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_null\":\n\t\t\t\t\tarith_op_no_null = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\t\tarith_op_no_nan = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_nan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\t\tarith_op_no_infinity = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_infinity);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"division_op_no_zero\":\n\t\t\t\t\tdivision_op_no_zero = (boolean) value;\n\t\t\t\t\tlogSetOption(name, division_op_no_zero);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t}\n\t\t} catch (ClassCastException cce) {\n\t\t\tlogger.warning(\"CustomError: Cannot cast value for option '\" + name + \"'\");\n\t\t}\n\t\trecalculateSomeEnabled();\n\t}\n\n\tprivate void logSetOption(String name, boolean enabled) {\n\t\tif (enabled) {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' enabled\");\n\t\t} else {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' disabled\");\n\t\t}\n\t}\n\n\t/**\n\t * Get an option value from the instance.\n\t *\n\t * @param name Name of the option\n\t * @return Option value\n\t */\n\tpublic Object getOption(String name) {\n\t\tswitch (name) {\n\t\t\tcase \"escalate_exceptions\":\n\t\t\t\treturn this.escalate_exceptions;\n\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\treturn this.equal_is_strict_equal;\n\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\treturn this.enforce_existing_properties;\n\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\treturn this.boolean_op_only_boolean_operands;\n\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\treturn this.arith_op_no_undefined;\n\t\t\tcase \"arith_op_no_null\":\n\t\t\t\treturn this.arith_op_no_null;\n\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\treturn this.arith_op_no_nan;\n\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\treturn this.arith_op_no_infinity;\n\t\t\tcase \"division_op_no_zero\":\n\t\t\t\treturn this.division_op_no_zero;\n\t\t\tdefault:\n\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Check if at least one option is enabled.\n\t *\n\t * @return true, if at least one custom error class is enabled\n\t */\n\tpublic boolean someEnabled() {\n\t\treturn this.some_enabled;\n\t}\n\n\t/**\n\t * Recalculate if at least one option is enabled.\n\t */\n\tprivate void recalculateSomeEnabled() {\n\t\tthis.some_enabled = this.escalate_exceptions ||\n\t\t\t\t\t\t\tthis.equal_is_strict_equal ||\n\t\t\t\t\t\t\tthis.enforce_existing_properties ||\n\t\t\t\t\t\t\tthis.boolean_op_only_boolean_operands ||\n\t\t\t\t\t\t\tthis.arith_op_no_undefined ||\n\t\t\t\t\t\t\tthis.arith_op_no_null ||\n\t\t\t\t\t\t\tthis.arith_op_no_nan ||\n\t\t\t\t\t\t\tthis.arith_op_no_infinity ||\n\t\t\t\t\t\t\tthis.division_op_no_zero;\n\t}\n\n\t/**\n\t * Enable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void enable(String type) {\n\t\tsetOption(type, true);\n\t}\n\n\t/**\n\t * Disable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void disable(String type) {\n\t\tsetOption(type, false);\n\t}\n\n\t// exposed functions for use in wrapper nodes\n\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\t\tinspectDivisionZero(operation_name, value, input_index, line_num);\n\t\t\t\t// no break, division is also arithmetic operation\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t\tcase \"JSAndNode\":\n\t\t\tcase \"JSOrNode\":\n\t\t\tcase \"JSNotNodeGen\":\n\t\t\t\tif (boolean_op_only_boolean_operands) {\n\t\t\t\t\tif (!JSGuards.isBoolean(value)) {\n\t\t\t\t\t\tlogger.info(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands)\");\n\t\t\t\t\t\tthrow new EscalatedException(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {\n\t\tif (division_op_no_zero && input_index == 1) {\n\t\t\tObject num = JSRuntime.toNumeric(value);\n\t\t\tif (num instanceof BigInt) {\n\t\t\t\tBigInt bigint_num = (BigInt) num;\n\t\t\t\tif (bigint_num.equals(BigInt.ZERO)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Integer) {\n\t\t\t\tInteger int_num = (Integer) num;\n\t\t\t\tif (int_num.equals(0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name +\n\t\t\t\t\t\t\t\t\t\", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof SafeInteger) {\n\t\t\t\tSafeInteger safeint_num = (SafeInteger) num;\n\t\t\t\tif (safeint_num.intValue() == 0) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Double) {\n\t\t\t\tDouble double_num = (Double) num;\n\t\t\t\tif (double_num.equals(0.0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.warning(\"CustomError::inspect(): Unexpected value \" + num.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectReturnValue(String operation_name, Object value, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void inspectArithmeticValues(String operation_name, Object value, int line_num) {\n\t\tif (arith_op_no_undefined) {\n\t\t\tif (JSGuards.isUndefined(value)) {\n\t\t\t\tlogger.info(\"Detected undefined value for arithmetic operation (arith_op_no_undefined)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected undefined value for arithmetic operation (arith_op_no_undefined). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_null) {\n\t\t\t//if (JSGuards.isJSNull(value)) { //TODO does not work\n\t\t\tif (value.toString().startsWith(\"DynamicObject<null>\")) {\n\t\t\t\tlogger.info(\"Detected null value for arithmetic operation (arith_op_no_null)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected null value for arithmetic operation (arith_op_no_null). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_nan) {\n\t\t\tif (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {\n\t\t\t\tlogger.info(\"Detected NaN value for arithmetic operation (arith_op_no_nan)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected NaN value for arithmetic operation (arith_op_no_nan). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_infinity) {\n\t\t\tif (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {\n\t\t\t\tlogger.info(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected Infinity value for arithmetic operation (arith_op_no_infinity). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return Value of option \"escalate_exceptions\"\n\t */\n\tpublic boolean escalateExceptionsEnabled() {\n\t\treturn escalate_exceptions;\n\t}\n\n\t/**\n\t * @return Value of option \"equal_is_strict_equal\"\n\t */\n\tpublic boolean equalIsStrictEqualEnabled() {\n\t\treturn equal_is_strict_equal;\n\t}\n\n\t/**\n\t * @return Value of option \"enforce_existing_properties\"\n\t */\n\tpublic boolean enforceExistingPropertiesEnabled() {\n\t\treturn enforce_existing_properties;\n\t}\n\n\t/**\n\t * Create a new Exception that cannot be caught.\n\t *\n\t * @param message Message of the exception\n\t * @return Exception of type \"EscalatedException\"\n\t */\n\tpublic static EscalatedException createException(String message) {\n\t\treturn new EscalatedException(message);\n\t}\n\n\t/**\n\t * This class should be used whenever an error occurs in the programs execution.\n\t * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)\n\t * will be caught by a try-catch-statement in the guest language source code.\n\t * This exception extends RuntimeException directly and therefore will not be caught\n\t * by any safety measures in the guest language. It can only be caught by the Fuzzer\n\t * itself.\n\t */\n\tpublic static class EscalatedException extends RuntimeException {\n\t\tpublic EscalatedException() {\n\t\t\tsuper();\n\t\t}\n\n\t\tpublic EscalatedException(String message) {\n\t\t\tsuper(message);\n\t\t}\n\n\t\tpublic EscalatedException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\n\t\tpublic EscalatedException(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\n\t\tprotected EscalatedException(String message, Throwable cause,\n\t\t\t\t\t\t\t\t   boolean enableSuppression,\n\t\t\t\t\t\t\t\t   boolean writableStackTrace) {\n\t\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "rdelhougne/GraalFuzzing", "file": "fuzzingtool/core/src/main/java/org/fuzzingtool/core/components/CustomError.java", "last_update_at": "2021-04-13T15:48:38+00:00", "question_id": "028d0eb48fa34b8302e7d54fb8e8862b7ef0b42c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomError {\n\tprivate final Logger logger;\n\tprivate boolean some_enabled = false;\n\t// Options\n\tprivate boolean escalate_exceptions = false;\n\tprivate boolean equal_is_strict_equal = false;\n\tprivate boolean enforce_existing_properties = false;\n\tprivate boolean boolean_op_only_boolean_operands = false;\n\tprivate boolean arith_op_no_undefined = false;\n\tprivate boolean arith_op_no_null = false;\n\tprivate boolean arith_op_no_nan = false;\n\tprivate boolean arith_op_no_infinity = false;\n\tprivate boolean division_op_no_zero = false;\n\tpublic CustomError(Logger lgr) {\n\t\tthis.logger = lgr;\n\t}\n\t/**\n\t * Set an option for this instance.\n\t *\n\t * @param name Name of the option\n\t * @param value Option value\n\t */\n\tpublic void setOption(String name, Object value) {\n\t\ttry {\n\t\t\tswitch (name) {\n\t\t\t\tcase \"escalate_exceptions\":\n\t\t\t\t\tescalate_exceptions = (boolean) value;\n\t\t\t\t\tlogSetOption(name, escalate_exceptions);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\t\tequal_is_strict_equal = (boolean) value;\n\t\t\t\t\tlogSetOption(name, equal_is_strict_equal);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\t\tenforce_existing_properties = (boolean) value;\n\t\t\t\t\tlogSetOption(name, enforce_existing_properties);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\t\tboolean_op_only_boolean_operands = (boolean) value;\n\t\t\t\t\tlogSetOption(name, boolean_op_only_boolean_operands);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\t\tarith_op_no_undefined = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_undefined);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_null\":\n\t\t\t\t\tarith_op_no_null = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\t\tarith_op_no_nan = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_nan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\t\tarith_op_no_infinity = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_infinity);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"division_op_no_zero\":\n\t\t\t\t\tdivision_op_no_zero = (boolean) value;\n\t\t\t\t\tlogSetOption(name, division_op_no_zero);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t}\n\t\t} catch (ClassCastException cce) {\n\t\t\tlogger.warning(\"CustomError: Cannot cast value for option '\" + name + \"'\");\n\t\t}\n\t\trecalculateSomeEnabled();\n\t}\n\tprivate void logSetOption(String name, boolean enabled) {\n\t\tif (enabled) {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' enabled\");\n\t\t} else {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' disabled\");\n\t\t}\n\t}\n\t/**\n\t * Get an option value from the instance.\n\t *\n\t * @param name Name of the option\n\t * @return Option value\n\t */\n\tpublic Object getOption(String name) {\n\t\tswitch (name) {\n\t\t\tcase \"escalate_exceptions\":\n\t\t\t\treturn this.escalate_exceptions;\n\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\treturn this.equal_is_strict_equal;\n\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\treturn this.enforce_existing_properties;\n\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\treturn this.boolean_op_only_boolean_operands;\n\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\treturn this.arith_op_no_undefined;\n\t\t\tcase \"arith_op_no_null\":\n\t\t\t\treturn this.arith_op_no_null;\n\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\treturn this.arith_op_no_nan;\n\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\treturn this.arith_op_no_infinity;\n\t\t\tcase \"division_op_no_zero\":\n\t\t\t\treturn this.division_op_no_zero;\n\t\t\tdefault:\n\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t\treturn null;\n\t\t}\n\t}\n\t/**\n\t * Check if at least one option is enabled.\n\t *\n\t * @return true, if at least one custom error class is enabled\n\t */\n\tpublic boolean someEnabled() {\n\t\treturn this.some_enabled;\n\t}\n\t/**\n\t * Recalculate if at least one option is enabled.\n\t */\n\tprivate void recalculateSomeEnabled() {\n\t\tthis.some_enabled = this.escalate_exceptions ||\n\t\t\t\t\t\t\tthis.equal_is_strict_equal ||\n\t\t\t\t\t\t\tthis.enforce_existing_properties ||\n\t\t\t\t\t\t\tthis.boolean_op_only_boolean_operands ||\n\t\t\t\t\t\t\tthis.arith_op_no_undefined ||\n\t\t\t\t\t\t\tthis.arith_op_no_null ||\n\t\t\t\t\t\t\tthis.arith_op_no_nan ||\n\t\t\t\t\t\t\tthis.arith_op_no_infinity ||\n\t\t\t\t\t\t\tthis.division_op_no_zero;\n\t}\n\t/**\n\t * Enable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void enable(String type) {\n\t\tsetOption(type, true);\n\t}\n\t/**\n\t * Disable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void disable(String type) {\n\t\tsetOption(type, false);\n\t}\n\t// exposed functions for use in wrapper nodes\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\t\tinspectDivisionZero(operation_name, value, input_index, line_num);\n\t\t\t\t// no break, division is also arithmetic operation\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t\tcase \"JSAndNode\":\n\t\t\tcase \"JSOrNode\":\n\t\t\tcase \"JSNotNodeGen\":\n\t\t\t\tif (boolean_op_only_boolean_operands) {\n\t\t\t\t\tif (!JSGuards.isBoolean(value)) {\n\t\t\t\t\t\tlogger.info(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands)\");\n\t\t\t\t\t\tthrow new EscalatedException(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprivate void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {\n\t\tif (division_op_no_zero && input_index == 1) {\n\t\t\tObject num = JSRuntime.toNumeric(value);\n\t\t\tif (num instanceof BigInt) {\n\t\t\t\tBigInt bigint_num = (BigInt) num;\n\t\t\t\tif (bigint_num.equals(BigInt.ZERO)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Integer) {\n\t\t\t\tInteger int_num = (Integer) num;\n\t\t\t\tif (int_num.equals(0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name +\n\t\t\t\t\t\t\t\t\t\", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof SafeInteger) {\n\t\t\t\tSafeInteger safeint_num = (SafeInteger) num;\n\t\t\t\tif (safeint_num.intValue() == 0) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Double) {\n\t\t\t\tDouble double_num = (Double) num;\n\t\t\t\tif (double_num.equals(0.0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.warning(\"CustomError::inspect(): Unexpected value \" + num.toString());\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectReturnValue(String operation_name, Object value, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprivate void inspectArithmeticValues(String operation_name, Object value, int line_num) {\n\t\tif (arith_op_no_undefined) {\n\t\t\tif (JSGuards.isUndefined(value)) {\n\t\t\t\tlogger.info(\"Detected undefined value for arithmetic operation (arith_op_no_undefined)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected undefined value for arithmetic operation (arith_op_no_undefined). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_null) {\n\t\t\t//if (JSGuards.isJSNull(value)) { //TODO does not work\n\t\t\tif (value.toString().startsWith(\"DynamicObject<null>\")) {\n\t\t\t\tlogger.info(\"Detected null value for arithmetic operation (arith_op_no_null)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected null value for arithmetic operation (arith_op_no_null). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_nan) {\n\t\t\tif (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {\n\t\t\t\tlogger.info(\"Detected NaN value for arithmetic operation (arith_op_no_nan)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected NaN value for arithmetic operation (arith_op_no_nan). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_infinity) {\n\t\t\tif (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {\n\t\t\t\tlogger.info(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected Infinity value for arithmetic operation (arith_op_no_infinity). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * @return Value of option \"escalate_exceptions\"\n\t */\n\tpublic boolean escalateExceptionsEnabled() {\n\t\treturn escalate_exceptions;\n\t}\n\t/**\n\t * @return Value of option \"equal_is_strict_equal\"\n\t */\n\tpublic boolean equalIsStrictEqualEnabled() {\n\t\treturn equal_is_strict_equal;\n\t}\n\t/**\n\t * @return Value of option \"enforce_existing_properties\"\n\t */\n\tpublic boolean enforceExistingPropertiesEnabled() {\n\t\treturn enforce_existing_properties;\n\t}\n\t/**\n\t * Create a new Exception that cannot be caught.\n\t *\n\t * @param message Message of the exception\n\t * @return Exception of type \"EscalatedException\"\n\t */\n\tpublic static EscalatedException createException(String message) {\n\t\treturn new EscalatedException(message);\n\t}\n\t/**\n\t * This class should be used whenever an error occurs in the programs execution.\n\t * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)\n\t * will be caught by a try-catch-statement in the guest language source code.\n\t * This exception extends RuntimeException directly and therefore will not be caught\n\t * by any safety measures in the guest language. It can only be caught by the Fuzzer\n\t * itself.\n\t */\n\tpublic static class EscalatedException extends RuntimeException {\n\t\tpublic EscalatedException() {\n\t\t\tsuper();\n\t\t}\n\t\tpublic EscalatedException(String message) {\n\t\t\tsuper(message);\n\t\t}\n\t\tpublic EscalatedException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\t\tpublic EscalatedException(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\t\tprotected EscalatedException(String message, Throwable cause,\n\t\t\t\t\t\t\t\t   boolean enableSuppression,\n\t\t\t\t\t\t\t\t   boolean writableStackTrace) {\n\t\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.4537882804870605, "ppl_lower": 1.4890369176864624, "ppl/lowercase_ppl": -1.064026014279405, "ppl/zlib": 0.00015868225476647378, "Min_5.0% Prob": 5.4270910235012275, "Min_10.0% Prob": 3.4361929209793316, "Min_20.0% Prob": 1.8571600775946588, "Min_30.0% Prob": 1.2489713341959454, "Min_40.0% Prob": 0.9355576259643636, "Min_50.0% Prob": 0.7489998337954311, "Min_60.0% Prob": 0.6244129376464294}}
{"hexsha": "63f006d75c343e11e3056f238b16a9c53c97186d", "ext": "java", "lang": "Java", "content": "public class Bounds {\n\n    /**\n     * The position of something.\n     */\n    private final Position position;\n\n    /**\n     * The size of something.\n     */\n    private final Size size;\n\n    public Bounds(Position position, Size size) {\n        this.position = position;\n        this.size = size;\n    }\n\n    /**\n     * Get the position.\n     *\n     * @return position\n     */\n    public Position getPosition() {\n        return position;\n    }\n\n    /**\n     * Get the size.\n     *\n     * @return size\n     */\n    public Size getSize() {\n        return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Bounds bounds = (Bounds) o;\n\n        if (position != null ? !position.equals(bounds.position) : bounds.position != null) return false;\n        return size != null ? size.equals(bounds.size) : bounds.size == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = position != null ? position.hashCode() : 0;\n        result = 31 * result + (size != null ? size.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s at %s\",\n                getSize().toString(),\n                getPosition().toString()\n        );\n    }\n\n}", "class_id": 0, "repo": "badalsarkar/thaw", "file": "util/src/main/java/de/be/thaw/util/Bounds.java", "last_update_at": "2021-12-11T18:05:30+00:00", "question_id": "63f006d75c343e11e3056f238b16a9c53c97186d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Bounds {\n    /**\n     * The position of something.\n     */\n    private final Position position;\n    /**\n     * The size of something.\n     */\n    private final Size size;\n    public Bounds(Position position, Size size) {\n        this.position = position;\n        this.size = size;\n    }\n    /**\n     * Get the position.\n     *\n     * @return position\n     */\n    public Position getPosition() {\n        return position;\n    }\n    /**\n     * Get the size.\n     *\n     * @return size\n     */\n    public Size getSize() {\n        return size;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Bounds bounds = (Bounds) o;\n        if (position != null ? !position.equals(bounds.position) : bounds.position != null) return false;\n        return size != null ? size.equals(bounds.size) : bounds.size == null;\n    }\n    @Override\n    public int hashCode() {\n        int result = position != null ? position.hashCode() : 0;\n        result = 31 * result + (size != null ? size.hashCode() : 0);\n        return result;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%s at %s\",\n                getSize().toString(),\n                getPosition().toString()\n        );\n    }\n"]], "pred": {"ppl": 1.2865660190582275, "ppl_lower": 1.418622374534607, "ppl/lowercase_ppl": -1.387772306053317, "ppl/zlib": 0.0005901092932532434, "Min_5.0% Prob": 3.677908320175974, "Min_10.0% Prob": 2.315316834732106, "Min_20.0% Prob": 1.250327743491844, "Min_30.0% Prob": 0.8414567925297377, "Min_40.0% Prob": 0.6325552109766776, "Min_50.0% Prob": 0.5037409021410633, "Min_60.0% Prob": 0.42025400622565845}}
{"hexsha": "24e81dc3f9999e7393ee6e867168fcebaedb04ae", "ext": "java", "lang": "Java", "content": "public class RefeedActionsTest {\n\n    private String toString(RefeedActions.Entry entry) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(entry.getDocumentType() + \".\" + entry.getClusterName() + \":\");\n        builder.append(entry.getServices().stream().\n                map(ServiceInfo::getServiceName).\n                sorted().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        builder.append(entry.getMessages().stream().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        return builder.toString();\n    }\n\n    @Test\n    public void action_with_multiple_reasons() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz][change,other change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_services() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz,qux][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_document_types() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"book.foo:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_clusters() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"music.bar:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n\n}", "class_id": 0, "repo": "gsmcwhirter/vespa", "file": "configserver/src/test/java/com/yahoo/vespa/config/server/configchange/RefeedActionsTest.java", "last_update_at": "2021-01-11T18:37:46+00:00", "question_id": "24e81dc3f9999e7393ee6e867168fcebaedb04ae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RefeedActionsTest {\n    private String toString(RefeedActions.Entry entry) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(entry.getDocumentType() + \".\" + entry.getClusterName() + \":\");\n        builder.append(entry.getServices().stream().\n                map(ServiceInfo::getServiceName).\n                sorted().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        builder.append(entry.getMessages().stream().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        return builder.toString();\n    }\n    @Test\n    public void action_with_multiple_reasons() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz][change,other change]\"));\n    }\n    @Test\n    public void actions_with_multiple_services() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz,qux][change]\"));\n    }\n    @Test\n    public void actions_with_multiple_document_types() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"book.foo:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n    @Test\n    public void actions_with_multiple_clusters() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"music.bar:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n"]], "pred": {"ppl": 1.5028249025344849, "ppl_lower": 1.7539366483688354, "ppl/lowercase_ppl": -1.3793235725034352, "ppl/zlib": 0.0007392860350961145, "Min_5.0% Prob": 5.573288504670306, "Min_10.0% Prob": 3.5870635882917656, "Min_20.0% Prob": 2.0006128608372555, "Min_30.0% Prob": 1.3524554844451957, "Min_40.0% Prob": 1.0173187278609455, "Min_50.0% Prob": 0.8144468275588903, "Min_60.0% Prob": 0.678840556831836}}
{"hexsha": "3377317aa98200f51a48ce521cfc82e23fc73437", "ext": "java", "lang": "Java", "content": "public class DeleteObject extends CliCommand<DefaultResult> {\n\n    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);\n    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);\n\n    private String bucketName;\n    private String objectName;\n    private String versionId;\n    private boolean allVersions;\n\n    public DeleteObject() {\n    }\n\n    @Override\n    public CliCommand init(final Arguments args) throws Exception {\n        processCommandOptions(requiredArgs, optionalArgs, args);\n\n        this.bucketName = args.getBucket();\n        this.objectName = args.getObjectName();\n        this.versionId = args.getVersionId();\n        this.allVersions = args.isAllVersions();\n        return this;\n    }\n\n    @Override\n    public DefaultResult call() throws Exception {\n\n        if (allVersions) {\n            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request()\n                    .withName(objectName)\n                    .withBucketId(bucketName);\n            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);\n\n            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {\n                deleteObject(bucketName, objectName, objectVersion.getId());\n            }\n\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' and all of it's versions from bucket '\" + this.bucketName + \"'.\");\n        } else {\n            final UUID version;\n            if (versionId != null) {\n                version = UUID.fromString(versionId);\n            } else {\n                version = null;\n            }\n            deleteObject(bucketName, objectName, version);\n\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' from bucket '\" + this.bucketName + \"'.\");\n        }\n    }\n\n    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {\n        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);\n        if (version != null) {\n            deleteObjectRequest.withVersionId(version);\n        }\n        getClient().deleteObject(deleteObjectRequest);\n    }\n}", "class_id": 0, "repo": "RachelTucker/ds3_java_cli", "file": "ds3_java_cli/src/main/java/com/spectralogic/ds3cli/command/DeleteObject.java", "last_update_at": "2021-09-19T19:50:11+00:00", "question_id": "3377317aa98200f51a48ce521cfc82e23fc73437", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DeleteObject extends CliCommand<DefaultResult> {\n    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);\n    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);\n    private String bucketName;\n    private String objectName;\n    private String versionId;\n    private boolean allVersions;\n    public DeleteObject() {\n    }\n    @Override\n    public CliCommand init(final Arguments args) throws Exception {\n        processCommandOptions(requiredArgs, optionalArgs, args);\n        this.bucketName = args.getBucket();\n        this.objectName = args.getObjectName();\n        this.versionId = args.getVersionId();\n        this.allVersions = args.isAllVersions();\n        return this;\n    }\n    @Override\n    public DefaultResult call() throws Exception {\n        if (allVersions) {\n            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request()\n                    .withName(objectName)\n                    .withBucketId(bucketName);\n            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);\n            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {\n                deleteObject(bucketName, objectName, objectVersion.getId());\n            }\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' and all of it's versions from bucket '\" + this.bucketName + \"'.\");\n        } else {\n            final UUID version;\n            if (versionId != null) {\n                version = UUID.fromString(versionId);\n            } else {\n                version = null;\n            }\n            deleteObject(bucketName, objectName, version);\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' from bucket '\" + this.bucketName + \"'.\");\n        }\n    }\n    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {\n        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);\n        if (version != null) {\n            deleteObjectRequest.withVersionId(version);\n        }\n        getClient().deleteObject(deleteObjectRequest);\n    }\n"]], "pred": {"ppl": 1.6066385507583618, "ppl_lower": 2.1043946743011475, "ppl/lowercase_ppl": -1.569201847726428, "ppl/zlib": 0.0006649987934267745, "Min_5.0% Prob": 5.297205289204915, "Min_10.0% Prob": 3.6535789204425497, "Min_20.0% Prob": 2.1907092904656884, "Min_30.0% Prob": 1.5441097272155078, "Min_40.0% Prob": 1.1770475305525996, "Min_50.0% Prob": 0.9456009884945468, "Min_60.0% Prob": 0.790852241137325}}
{"hexsha": "4e80fb61037a20340836b0ea84f7505d3b249026", "ext": "java", "lang": "Java", "content": "public class Perspective {\n    public static final int LOCAL_COORD_BITS = 7;\n    public static final int LOCAL_HALF_TILE_SIZE = 64;\n    public static final int LOCAL_TILE_SIZE = 128;\n    public static final int SCENE_SIZE = 104;\n    public static final double UNIT = Math.PI / 1024d;\n\n    public static final int[] SINE = new int[2048]; // sine angles for each of the 2048 units, * 65536 and stored as an int\n    public static final int[] COSINE = new int[2048]; // cosine\n\n    static {\n        for (int i = 0; i < 2048; ++i)\n        {\n            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n        }\n    }\n\n    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {\n        if (string == null) {\n            return null;\n        }\n        Point p = Perspective.localToCanvas(client, localPoint, plane, n);\n        if (p == null) {\n            return null;\n        }\n        else\n        {\n            Log.e(\"Perspective\", p.toString());\n        }\n\n        return new Point(p.getX(), p.getY());\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {\n        int n3 = client.getPlane();\n        int n4 = localPoint.getX() - n * 128 / 2;\n        int n5 = localPoint.getY() - n * 128 / 2;\n        int n6 = localPoint.getX() + n * 128 / 2;\n        int n7 = localPoint.getY() + n * 128 / 2;\n        byte[][][] tileSettings = client.getTileSettings();\n        int n8 = localPoint.getSceneX();\n        int n9 = localPoint.getSceneY();\n        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {\n            int n10;\n            n = n10 = n3;\n            if (n3 < 3) {\n                n = n10;\n                if ((tileSettings[1][n8][n9] & 2) == 2) {\n                    n = n3 + 1;\n                }\n            }\n            n10 = Perspective.getHeight(client, n4, n5, n);\n            n8 = Perspective.getHeight(client, n6, n5, n);\n            n3 = Perspective.getHeight(client, n6, n7, n);\n            n = Perspective.getHeight(client, n4, n7, n);\n            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);\n            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);\n            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);\n            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);\n            if (p1 != null && p2 != null && p3 != null && p4 != null) {\n                Path path = new Path();\n                path.moveTo((float)((Point)p1).getX(), (float)((Point)p1).getY());\n                path.lineTo((float)((Point)p2).getX(), (float)((Point)p2).getY());\n                path.lineTo((float)p3.getX(), (float)p3.getY());\n                path.lineTo((float)((Point)p4).getX(), (float)((Point)p4).getY());\n                return path;\n            }\n            return null;\n        }\n        return null;\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);\n    }\n\n    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane)\n    {\n        int sceneX = localX >> LOCAL_COORD_BITS;\n        int sceneY = localY >> LOCAL_COORD_BITS;\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            int[][][] tileHeights = client.getTileHeights();\n\n            int x = localX & (LOCAL_TILE_SIZE - 1);\n            int y = localY & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n\n        return 0;\n    }\n\n    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {\n        int sceneX = point.getSceneX();\n        int sceneY = point.getSceneY();\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            byte[][][] tileSettings = client.getTileSettings();\n            int[][][] tileHeights = client.getTileHeights();\n            if (plane < 0)\n                plane = 0;\n            int z1 = plane;\n            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE)\n            {\n                z1 = plane + 1;\n            }\n\n            int x = point.getX() & (LOCAL_TILE_SIZE - 1);\n            int y = point.getY() & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n\n        return 0;\n    }\n\n    /*\n    public static Point localToCanvas(@Nonnull Client client, int n, int n2, int n3) {\n        if (n >= 128 && n2 >= 128 && n <= 13056 && n2 <= 13056) {\n            int n4;\n            int n5 = n3 - client.getCameraZ();\n            int n6 = client.getCameraPitch();\n            int n7 = client.getCameraYaw();\n            int[] nArray = SINE;\n            n3 = nArray[n6];\n            int[] nArray2 = COSINE;\n            int n8 = (n7 = nArray2[n7]) * (n2 -= client.getCameraY()) - (n4 = nArray[n7]) * (n -= client.getCameraX()) >> 16;\n            int n9 = n5 * n3 + n8 * (n6 = nArray2[n6]) >> 16;\n            if (n9 >= 50) {\n                double d = (double)client.getCameraZoom() * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double d2 = (double)client.getCameraZoom() * (double)client.getOverlayHeight() / (double)client.getViewportHeight();\n                int n10 = client.getOverlayWidth();\n                int n11 = client.getOverlayHeight();\n                return new Point(n10 / 2 + (int)d * (n7 * n + n2 * n4 >> 16) / n9, n11 / 2 + (int)d2 * (n6 * n5 - n8 * n3 >> 16) / n9);\n            }\n        }\n        return null;\n    }\n     */\n\n    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z)\n    {\n        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056)\n        {\n            x -= client.getCameraX();\n            y -= client.getCameraY();\n            z -= client.getCameraZ();\n\n            int cameraPitch = client.getCameraPitch();\n            int cameraYaw = client.getCameraYaw();\n\n            int pitchSin = SINE[cameraPitch];\n            int pitchCos = COSINE[cameraPitch];\n            int yawSin = SINE[cameraYaw];\n            int yawCos = COSINE[cameraYaw];\n\n            int var8 = yawCos * x + y * yawSin >> 16;\n            y = yawCos * y - yawSin * x >> 16;\n            x = var8;\n            var8 = pitchCos * z - y * pitchSin >> 16;\n            y = z * pitchSin + y * pitchCos >> 16;\n\n            if (y >= 50)\n            {\n                Log.e(\"Points\", \"x:\" + x + \" y:\" + y);\n                double pointX = (double)(client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double pointY = (double)(client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                return new Point(\n                        (int)pointX,\n                        (int)pointY);\n            }\n        }\n\n        return null;\n    }\n\n    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {\n        n = Perspective.getTileHeight(clientAPI, localPoint, n);\n        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);\n    }\n}", "class_id": 0, "repo": "Soxs/openosrs-mobile", "file": "runelite-api/src/main/java/net/runelite/api/Perspective.java", "last_update_at": "2021-11-19T15:28:42+00:00", "question_id": "4e80fb61037a20340836b0ea84f7505d3b249026", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Perspective {\n    public static final int LOCAL_COORD_BITS = 7;\n    public static final int LOCAL_HALF_TILE_SIZE = 64;\n    public static final int LOCAL_TILE_SIZE = 128;\n    public static final int SCENE_SIZE = 104;\n    public static final double UNIT = Math.PI / 1024d;\n    public static final int[] SINE = new int[2048]; // sine angles for each of the 2048 units, * 65536 and stored as an int\n    public static final int[] COSINE = new int[2048]; // cosine\n    static {\n        for (int i = 0; i < 2048; ++i)\n        {\n            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n        }\n    }\n    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {\n        if (string == null) {\n            return null;\n        }\n        Point p = Perspective.localToCanvas(client, localPoint, plane, n);\n        if (p == null) {\n            return null;\n        }\n        else\n        {\n            Log.e(\"Perspective\", p.toString());\n        }\n        return new Point(p.getX(), p.getY());\n    }\n    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);\n    }\n    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {\n        int n3 = client.getPlane();\n        int n4 = localPoint.getX() - n * 128 / 2;\n        int n5 = localPoint.getY() - n * 128 / 2;\n        int n6 = localPoint.getX() + n * 128 / 2;\n        int n7 = localPoint.getY() + n * 128 / 2;\n        byte[][][] tileSettings = client.getTileSettings();\n        int n8 = localPoint.getSceneX();\n        int n9 = localPoint.getSceneY();\n        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {\n            int n10;\n            n = n10 = n3;\n            if (n3 < 3) {\n                n = n10;\n                if ((tileSettings[1][n8][n9] & 2) == 2) {\n                    n = n3 + 1;\n                }\n            }\n            n10 = Perspective.getHeight(client, n4, n5, n);\n            n8 = Perspective.getHeight(client, n6, n5, n);\n            n3 = Perspective.getHeight(client, n6, n7, n);\n            n = Perspective.getHeight(client, n4, n7, n);\n            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);\n            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);\n            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);\n            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);\n            if (p1 != null && p2 != null && p3 != null && p4 != null) {\n                Path path = new Path();\n                path.moveTo((float)((Point)p1).getX(), (float)((Point)p1).getY());\n                path.lineTo((float)((Point)p2).getX(), (float)((Point)p2).getY());\n                path.lineTo((float)p3.getX(), (float)p3.getY());\n                path.lineTo((float)((Point)p4).getX(), (float)((Point)p4).getY());\n                return path;\n            }\n            return null;\n        }\n        return null;\n    }\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);\n    }\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);\n    }\n    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane)\n    {\n        int sceneX = localX >> LOCAL_COORD_BITS;\n        int sceneY = localY >> LOCAL_COORD_BITS;\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            int[][][] tileHeights = client.getTileHeights();\n            int x = localX & (LOCAL_TILE_SIZE - 1);\n            int y = localY & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {\n        int sceneX = point.getSceneX();\n        int sceneY = point.getSceneY();\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            byte[][][] tileSettings = client.getTileSettings();\n            int[][][] tileHeights = client.getTileHeights();\n            if (plane < 0)\n                plane = 0;\n            int z1 = plane;\n            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE)\n            {\n                z1 = plane + 1;\n            }\n            int x = point.getX() & (LOCAL_TILE_SIZE - 1);\n            int y = point.getY() & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n    /*\n    public static Point localToCanvas(@Nonnull Client client, int n, int n2, int n3) {\n        if (n >= 128 && n2 >= 128 && n <= 13056 && n2 <= 13056) {\n            int n4;\n            int n5 = n3 - client.getCameraZ();\n            int n6 = client.getCameraPitch();\n            int n7 = client.getCameraYaw();\n            int[] nArray = SINE;\n            n3 = nArray[n6];\n            int[] nArray2 = COSINE;\n            int n8 = (n7 = nArray2[n7]) * (n2 -= client.getCameraY()) - (n4 = nArray[n7]) * (n -= client.getCameraX()) >> 16;\n            int n9 = n5 * n3 + n8 * (n6 = nArray2[n6]) >> 16;\n            if (n9 >= 50) {\n                double d = (double)client.getCameraZoom() * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double d2 = (double)client.getCameraZoom() * (double)client.getOverlayHeight() / (double)client.getViewportHeight();\n                int n10 = client.getOverlayWidth();\n                int n11 = client.getOverlayHeight();\n                return new Point(n10 / 2 + (int)d * (n7 * n + n2 * n4 >> 16) / n9, n11 / 2 + (int)d2 * (n6 * n5 - n8 * n3 >> 16) / n9);\n            }\n        }\n        return null;\n    }\n     */\n    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z)\n    {\n        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056)\n        {\n            x -= client.getCameraX();\n            y -= client.getCameraY();\n            z -= client.getCameraZ();\n            int cameraPitch = client.getCameraPitch();\n            int cameraYaw = client.getCameraYaw();\n            int pitchSin = SINE[cameraPitch];\n            int pitchCos = COSINE[cameraPitch];\n            int yawSin = SINE[cameraYaw];\n            int yawCos = COSINE[cameraYaw];\n            int var8 = yawCos * x + y * yawSin >> 16;\n            y = yawCos * y - yawSin * x >> 16;\n            x = var8;\n            var8 = pitchCos * z - y * pitchSin >> 16;\n            y = z * pitchSin + y * pitchCos >> 16;\n            if (y >= 50)\n            {\n                Log.e(\"Points\", \"x:\" + x + \" y:\" + y);\n                double pointX = (double)(client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double pointY = (double)(client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                return new Point(\n                        (int)pointX,\n                        (int)pointY);\n            }\n        }\n        return null;\n    }\n    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {\n        n = Perspective.getTileHeight(clientAPI, localPoint, n);\n        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);\n    }\n"]], "pred": {"ppl": 1.8065553903579712, "ppl_lower": 2.0369277000427246, "ppl/lowercase_ppl": -1.2029358462481443, "ppl/zlib": 0.0003247786561415669, "Min_5.0% Prob": 6.072839222702325, "Min_10.0% Prob": 4.401860916147045, "Min_20.0% Prob": 2.7408311831600525, "Min_30.0% Prob": 1.9347665419473368, "Min_40.0% Prob": 1.4692675851850172, "Min_50.0% Prob": 1.181240954039046, "Min_60.0% Prob": 0.9861633344697743}}
{"hexsha": "3c9b0668c602f3425aef938ddbcd842b6fc11a32", "ext": "java", "lang": "Java", "content": "@Component\n@ConditionalOnProperty(value = \"datasource-observer.sentinelhub.enabled\", havingValue = \"true\")\npublic class SentinelJobFactory implements JobFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);\n\n    @Autowired\n    private ExecutionIntervalConfig intervalConfig;\n\n    @Override\n    public boolean supportsJobDefinition(WacodisJobDefinition job) {\n        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();\n        return count > 0;\n    }\n\n//    @Override\n//    public JobDetail initializeJob(WacodisJobDefinition job, JobDataMap data) {\n//        LOG.info(\"Preparing SentinelJob JobDetail\");\n//        \n//        Optional<AbstractSubsetDefinition> def = job.getInputs().stream()\n//                .filter((i -> i instanceof CopernicusSubsetDefinition)).findFirst();\n//        \n//        // this should always be the case\n//        if (def.isPresent()) {\n//            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) def.get();\n//            if (copDef.getMaximumCloudCoverage() > 0) {\n//                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n//            }\n//            \n//            switch (copDef.getSatellite()) {\n//                case _1:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n//                    break;\n//                case _2:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n//                    break;\n//                case _3:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n//                    break;\n//            }\n//            \n//            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n//                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n//                int baseDays = period.getDays();\n//                if (period.getHours() > 11) {\n//                    // round to full days\n//                    baseDays++;\n//                }\n//                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n//            }\n//            \n//            data.put(\"executionInterval\", intervalConfig.getSentinel());\n//        }\n//\n//        // create the quartz object\n//        return JobBuilder.newJob(SentinelJob.class)\n//                .withIdentity(job.getId().toString(), job.getName())\n//                .usingJobData(data)\n//                .build();\n//    }\n\n    @Override\n    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data,\n                                           AbstractSubsetDefinition subsetDefinition) {\n        // this should always be the case\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n\n            LOG.info(\"Preparing SentinelJob JobDetail\");\n\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            if (copDef.getMaximumCloudCoverage() > 0) {\n                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n            }\n\n            switch (copDef.getSatellite()) {\n                case _1:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n                    break;\n                case _2:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n                    break;\n                case _3:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n                    break;\n            }\n\n            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n                int baseDays = period.getDays();\n                if (period.getHours() > 11) {\n                    // round to full days\n                    baseDays++;\n                }\n                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n            }\n\n            data.put(\"executionInterval\", intervalConfig.getSentinel());\n\n        }\n\n        // create the quartz object\n        return JobBuilder.newJob(SentinelJob.class)\n                .usingJobData(data);\n\n    }\n\n    @Override\n    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {\n        return job.getInputs().stream()\n                .filter((i -> i instanceof CopernicusSubsetDefinition));\n    }\n\n    @Override\n    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {\n\n        StringBuilder builder = new StringBuilder(\"\");\n\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            builder.append(copDef.getSourceType());\n\n            if (copDef.getSatellite() != null) {\n                builder.append(\"_\" + copDef.getSatellite());\n            }\n        }\n\n        return builder.toString();\n    }\n    \n    @Override\n\tpublic Class getQuartzJobClass() {\n\t\t// TODO Auto-generated method stub\n\t\treturn SentinelJob.class;\n\t}\n    \n    @Override\n\tpublic JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {\n    \t// here we must do nothing as this Job dies not specify BBOX parameter\n    \treturn jobDetail;\n\t}\n\n}", "class_id": 0, "repo": "WaCoDiS/datasource-observer", "file": "sentinel-observer/src/main/java/de/wacodis/sentinel/SentinelJobFactory.java", "last_update_at": "2021-11-15T23:28:04+00:00", "question_id": "3c9b0668c602f3425aef938ddbcd842b6fc11a32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@ConditionalOnProperty(value = \"datasource-observer.sentinelhub.enabled\", havingValue = \"true\")\npublic class SentinelJobFactory implements JobFactory {\n    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);\n    @Autowired\n    private ExecutionIntervalConfig intervalConfig;\n    @Override\n    public boolean supportsJobDefinition(WacodisJobDefinition job) {\n        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();\n        return count > 0;\n    }\n//    @Override\n//    public JobDetail initializeJob(WacodisJobDefinition job, JobDataMap data) {\n//        LOG.info(\"Preparing SentinelJob JobDetail\");\n//        \n//        Optional<AbstractSubsetDefinition> def = job.getInputs().stream()\n//                .filter((i -> i instanceof CopernicusSubsetDefinition)).findFirst();\n//        \n//        // this should always be the case\n//        if (def.isPresent()) {\n//            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) def.get();\n//            if (copDef.getMaximumCloudCoverage() > 0) {\n//                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n//            }\n//            \n//            switch (copDef.getSatellite()) {\n//                case _1:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n//                    break;\n//                case _2:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n//                    break;\n//                case _3:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n//                    break;\n//            }\n//            \n//            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n//                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n//                int baseDays = period.getDays();\n//                if (period.getHours() > 11) {\n//                    // round to full days\n//                    baseDays++;\n//                }\n//                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n//            }\n//            \n//            data.put(\"executionInterval\", intervalConfig.getSentinel());\n//        }\n//\n//        // create the quartz object\n//        return JobBuilder.newJob(SentinelJob.class)\n//                .withIdentity(job.getId().toString(), job.getName())\n//                .usingJobData(data)\n//                .build();\n//    }\n    @Override\n    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data,\n                                           AbstractSubsetDefinition subsetDefinition) {\n        // this should always be the case\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            LOG.info(\"Preparing SentinelJob JobDetail\");\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            if (copDef.getMaximumCloudCoverage() > 0) {\n                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n            }\n            switch (copDef.getSatellite()) {\n                case _1:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n                    break;\n                case _2:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n                    break;\n                case _3:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n                    break;\n            }\n            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n                int baseDays = period.getDays();\n                if (period.getHours() > 11) {\n                    // round to full days\n                    baseDays++;\n                }\n                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n            }\n            data.put(\"executionInterval\", intervalConfig.getSentinel());\n        }\n        // create the quartz object\n        return JobBuilder.newJob(SentinelJob.class)\n                .usingJobData(data);\n    }\n    @Override\n    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {\n        return job.getInputs().stream()\n                .filter((i -> i instanceof CopernicusSubsetDefinition));\n    }\n    @Override\n    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {\n        StringBuilder builder = new StringBuilder(\"\");\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            builder.append(copDef.getSourceType());\n            if (copDef.getSatellite() != null) {\n                builder.append(\"_\" + copDef.getSatellite());\n            }\n        }\n        return builder.toString();\n    }\n    @Override\n\tpublic Class getQuartzJobClass() {\n\t\t// TODO Auto-generated method stub\n\t\treturn SentinelJob.class;\n\t}\n    @Override\n\tpublic JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {\n    \t// here we must do nothing as this Job dies not specify BBOX parameter\n    \treturn jobDetail;\n\t}\n"]], "pred": {"ppl": 1.7915140390396118, "ppl_lower": 2.117680549621582, "ppl/lowercase_ppl": -1.2868658479057515, "ppl/zlib": 0.00042590291760714373, "Min_5.0% Prob": 6.615615003249225, "Min_10.0% Prob": 4.676115280272914, "Min_20.0% Prob": 2.797375223800248, "Min_30.0% Prob": 1.927676589489957, "Min_40.0% Prob": 1.4540827862626913, "Min_50.0% Prob": 1.1662145989287258, "Min_60.0% Prob": 0.9727835789164088}}
{"hexsha": "1ee98f729518a3ab59cc092fb753ccaf548f8923", "ext": "java", "lang": "Java", "content": "public class SqlPagingStrategy\n{\n   public static SqlPaging buildPaging(String databaseProduct)\n   {\n      SqlPaging paging = new SqlPaging();\n      if (databaseProduct.equals(DatabaseProduct.MYSQL)) { //$NON-NLS-1$\n         MySqlPagingDialect dialect = new MySqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.PGSQL)) { //$NON-NLS-1$\n         PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.H2)) { //$NON-NLS-1$\n         H2PagingDialect dialect = new H2PagingDialect();\n         paging.setDialect(dialect);\n      }\n      return paging;\n   }\n}", "class_id": 0, "repo": "obidea/semantika-core", "file": "src/main/java/com/obidea/semantika/queryanswer/paging/SqlPagingStrategy.java", "last_update_at": "2021-03-01T04:33:21+00:00", "question_id": "1ee98f729518a3ab59cc092fb753ccaf548f8923", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SqlPagingStrategy\n{\n   public static SqlPaging buildPaging(String databaseProduct)\n   {\n      SqlPaging paging = new SqlPaging();\n      if (databaseProduct.equals(DatabaseProduct.MYSQL)) { //$NON-NLS-1$\n         MySqlPagingDialect dialect = new MySqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.PGSQL)) { //$NON-NLS-1$\n         PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.H2)) { //$NON-NLS-1$\n         H2PagingDialect dialect = new H2PagingDialect();\n         paging.setDialect(dialect);\n      }\n      return paging;\n   }\n"]], "pred": {"ppl": 1.707896113395691, "ppl_lower": 2.1437485218048096, "ppl/lowercase_ppl": -1.4246398170872163, "ppl/zlib": 0.0023579835681838287, "Min_5.0% Prob": 6.4529076019922895, "Min_10.0% Prob": 4.338903074463208, "Min_20.0% Prob": 2.5758448845396438, "Min_30.0% Prob": 1.774539751932025, "Min_40.0% Prob": 1.3357157160159356, "Min_50.0% Prob": 1.06977265678579, "Min_60.0% Prob": 0.8919411112470294}}
{"hexsha": "12958c18f6375a8f2d58b33654f17da5c8df2cff", "ext": "java", "lang": "Java", "content": "public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {\n\n    public static final String ENRICHMENT_ADDED = \"ENRICHMENT_ADDED\";\n\n    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {\n    };\n\n    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);\n\n    /**\n     * Have one of the supplied properties been modified?\n     */\n    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {\n\n        if (props != null) {\n            for (String propName : props) {\n                try {\n                    Property prop = doc.getProperty(propName);\n                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {\n                        return true;\n                    }\n                } catch (PropertyNotFoundException e) {\n                    // Just ignore\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {\n        // TODO: Handle versions here?\n        DocumentModel doc;\n        try {\n            doc = session.getDocument(new IdRef(metadata.context.documentRef));\n        } catch (DocumentNotFoundException e) {\n            log.info(\"Unable to save enrichment data for missing doc \" + metadata.context.documentRef);\n            return null;\n        }\n\n        Map<String, Object> anItem = metadata.toMap();\n        if (anItem != null) {\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(\n                    ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n            if (enrichmentList == null) {\n                enrichmentList = new ArrayList<>(1);\n            }\n            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);\n            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());\n        }\n        return doc;\n    }\n\n    /**\n     * Updates enrichment, ensures we have one enrichment entry per model/version and input\n     */\n    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original,\n            Map<String, Object> item) {\n        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();\n        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));\n        enrichmentByKey.put(uniqueKey(item), item);\n        return enrichmentByKey.values();\n    }\n\n    /**\n     * Generate a unique key for a model/version/input combination\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String uniqueKey(Map<String, Object> suggestion) {\n        String input = \"\";\n        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n        // This is a little big strange, but it adapts to the type and calls the correct join method.\n        if (inputs instanceof Set) {\n            input = String.join(\";\", (Set<String>) inputs);\n        } else if (inputs instanceof String[]) {\n            input = String.join(\";\", (String[]) inputs);\n        }\n        return suggestion.get(ENRICHMENT_MODEL) + input;\n    }\n\n    @Override\n    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model,\n            Serializable oldValue, String comment) {\n        if (!doc.hasFacet(ENRICHMENT_FACET)) {\n            doc.addFacet(ENRICHMENT_FACET);\n        }\n\n        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());\n        HashMap<String, String> prediction = new HashMap<>();\n        prediction.put(\"xpath\", xPath);\n        prediction.put(\"model\", model);\n        autoProps.add(prediction);\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);\n        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n\n        if (oldValue != null) {\n            List<AutoHistory> existingHistory = getAutoHistory(doc);\n            // First remove old history if it exists\n            List<AutoHistory> history = existingHistory.stream()\n                                                       .filter(h -> !xPath.equals(h.getProperty()))\n                                                       .collect(Collectors.toList());\n            history.add(new AutoHistory(xPath, oldValue));\n            setAutoHistory(doc, history);\n        }\n\n        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);\n\n        storeAudit(doc, autoField, model, 1L, comment);\n\n        return doc;\n    }\n\n    @Override\n    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {\n        List<AutoHistory> history = getAutoHistory(doc);\n        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();\n        boolean present = previous.isPresent();\n        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());\n        Set<Map<String, String>> toReset = set.stream()\n                                              .filter(val -> val.get(\"xpath\").equals(xPath))\n                                              .collect(Collectors.toSet());\n        @SuppressWarnings(\"unchecked\")\n        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);\n        Object previousValue = null;\n        if (set.size() > noOldXpath.size()) {\n            if (present) {\n                previousValue = previous.get().getPreviousValue();\n                history.remove(previous.get());\n                setAutoHistory(doc, history);\n            }\n            //Set the value\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);\n            String comment = \"Resetting \" + xPath + \" property\";\n            toReset.forEach(map -> {\n                storeAudit(doc, autoField, map.get(\"model\"), -1L, comment);\n            });\n\n            if (resetValue) {\n                doc.setPropertyValue(xPath, (Serializable) previousValue);\n            }\n        }\n\n        return doc;\n    }\n\n    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {\n        Set<Map<String, String>> autoProps = new HashSet<>(1);\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                autoPropertyName);\n        if (filled != null) {\n            autoProps.addAll(filled);\n        }\n\n        return autoProps;\n    }\n\n    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {\n        AuditLogger audit = Framework.getService(AuditLogger.class);\n        if (audit != null) {\n            LogEntry logEntry = audit.newLogEntry();\n            logEntry.setCategory(\"AI\");\n            logEntry.setEventId(autoField.eventName());\n            logEntry.setComment(comment);\n            logEntry.setDocUUID(doc.getId());\n            logEntry.setDocPath(doc.getPathAsString());\n            logEntry.setEventDate(new Date());\n\n            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);\n            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);\n\n            HashMap<String, ExtendedInfo> infos = new HashMap<>();\n            infos.put(\"model\", modelInfo);\n            infos.put(\"value\", one);\n            logEntry.setExtendedInfos(infos);\n\n            audit.addLogEntries(Collections.singletonList(logEntry));\n        } else {\n            log.warn(\"Audit Logger is not available\");\n        }\n    }\n\n    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {\n        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(),\n                doc);\n        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());\n        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());\n\n        String paths = null;\n        if (xPaths != null && !xPaths.isEmpty()) {\n            paths = String.join(\",\", xPaths);\n        }\n        ctx.setProperty(PATHS, paths);\n        if (StringUtils.isEmpty(comment)) {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);\n        } else {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);\n        }\n        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));\n    }\n\n    @Override\n    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null) {\n            return doc;\n        }\n        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());\n\n        itemsList.forEach(suggestObj -> {\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);\n            List<Map<String, Object>> newSuggestions = suggestions.stream()\n                                                                  .filter(s -> !xPath.equals(\n                                                                          s.get(SUGGESTION_PROPERTY)))\n                                                                  .collect(Collectors.toList());\n            if (!newSuggestions.isEmpty()) {\n                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);\n                newSuggestList.add(suggestObj);\n            }\n        });\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);\n        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);\n        return doc;\n    }\n\n    @Override\n    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null || itemsList.isEmpty()) {\n            return doc;\n        }\n        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());\n        Set<String> removedTargetProperties = new HashSet<>();\n\n        itemsList.forEach(entry -> {\n            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));\n            if (hadBeenModified(doc, inputProperties)) {\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);\n                Set<String> targetProps = suggestions.stream()\n                                                     .map(s -> (String) s.get(SUGGESTION_PROPERTY))\n                                                     .collect(Collectors.toSet());\n                removedTargetProperties.addAll(targetProps);\n            } else {\n                cleanItemsList.add(entry);\n            }\n        });\n        if (cleanItemsList.size() != itemsList.size()) {\n            //We made some changes lets update\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, \"Dirty inputs\");\n        }\n        return doc;\n    }\n\n    @Override\n    public List<AutoHistory> getAutoHistory(DocumentModel doc) {\n        try {\n            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());\n            if (autoBlob != null) {\n                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to read auto history blob\", e);\n        }\n\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {\n        try {\n            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n\n            String autoHistory = AUTO.HISTORY.lowerName();\n            autoBlob.setFilename(autoHistory + \"_\" + doc.getName() + \".json\");\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);\n        } catch (IOException e) {\n            log.warn(\"Failed to set auto history blob\", e);\n        }\n    }\n}", "class_id": 0, "repo": "nuxeo/nuxeo-ai", "file": "nuxeo-ai-core/src/main/java/org/nuxeo/ai/services/DocMetadataServiceImpl.java", "last_update_at": "2021-03-30T03:03:26+00:00", "question_id": "12958c18f6375a8f2d58b33654f17da5c8df2cff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {\n    public static final String ENRICHMENT_ADDED = \"ENRICHMENT_ADDED\";\n    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {\n    };\n    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);\n    /**\n     * Have one of the supplied properties been modified?\n     */\n    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {\n        if (props != null) {\n            for (String propName : props) {\n                try {\n                    Property prop = doc.getProperty(propName);\n                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {\n                        return true;\n                    }\n                } catch (PropertyNotFoundException e) {\n                    // Just ignore\n                }\n            }\n        }\n        return false;\n    }\n    @Override\n    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {\n        // TODO: Handle versions here?\n        DocumentModel doc;\n        try {\n            doc = session.getDocument(new IdRef(metadata.context.documentRef));\n        } catch (DocumentNotFoundException e) {\n            log.info(\"Unable to save enrichment data for missing doc \" + metadata.context.documentRef);\n            return null;\n        }\n        Map<String, Object> anItem = metadata.toMap();\n        if (anItem != null) {\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(\n                    ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n            if (enrichmentList == null) {\n                enrichmentList = new ArrayList<>(1);\n            }\n            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);\n            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());\n        }\n        return doc;\n    }\n    /**\n     * Updates enrichment, ensures we have one enrichment entry per model/version and input\n     */\n    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original,\n            Map<String, Object> item) {\n        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();\n        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));\n        enrichmentByKey.put(uniqueKey(item), item);\n        return enrichmentByKey.values();\n    }\n    /**\n     * Generate a unique key for a model/version/input combination\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String uniqueKey(Map<String, Object> suggestion) {\n        String input = \"\";\n        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n        // This is a little big strange, but it adapts to the type and calls the correct join method.\n        if (inputs instanceof Set) {\n            input = String.join(\";\", (Set<String>) inputs);\n        } else if (inputs instanceof String[]) {\n            input = String.join(\";\", (String[]) inputs);\n        }\n        return suggestion.get(ENRICHMENT_MODEL) + input;\n    }\n    @Override\n    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model,\n            Serializable oldValue, String comment) {\n        if (!doc.hasFacet(ENRICHMENT_FACET)) {\n            doc.addFacet(ENRICHMENT_FACET);\n        }\n        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());\n        HashMap<String, String> prediction = new HashMap<>();\n        prediction.put(\"xpath\", xPath);\n        prediction.put(\"model\", model);\n        autoProps.add(prediction);\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);\n        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n        if (oldValue != null) {\n            List<AutoHistory> existingHistory = getAutoHistory(doc);\n            // First remove old history if it exists\n            List<AutoHistory> history = existingHistory.stream()\n                                                       .filter(h -> !xPath.equals(h.getProperty()))\n                                                       .collect(Collectors.toList());\n            history.add(new AutoHistory(xPath, oldValue));\n            setAutoHistory(doc, history);\n        }\n        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);\n        storeAudit(doc, autoField, model, 1L, comment);\n        return doc;\n    }\n    @Override\n    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {\n        List<AutoHistory> history = getAutoHistory(doc);\n        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();\n        boolean present = previous.isPresent();\n        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());\n        Set<Map<String, String>> toReset = set.stream()\n                                              .filter(val -> val.get(\"xpath\").equals(xPath))\n                                              .collect(Collectors.toSet());\n        @SuppressWarnings(\"unchecked\")\n        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);\n        Object previousValue = null;\n        if (set.size() > noOldXpath.size()) {\n            if (present) {\n                previousValue = previous.get().getPreviousValue();\n                history.remove(previous.get());\n                setAutoHistory(doc, history);\n            }\n            //Set the value\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);\n            String comment = \"Resetting \" + xPath + \" property\";\n            toReset.forEach(map -> {\n                storeAudit(doc, autoField, map.get(\"model\"), -1L, comment);\n            });\n            if (resetValue) {\n                doc.setPropertyValue(xPath, (Serializable) previousValue);\n            }\n        }\n        return doc;\n    }\n    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {\n        Set<Map<String, String>> autoProps = new HashSet<>(1);\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                autoPropertyName);\n        if (filled != null) {\n            autoProps.addAll(filled);\n        }\n        return autoProps;\n    }\n    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {\n        AuditLogger audit = Framework.getService(AuditLogger.class);\n        if (audit != null) {\n            LogEntry logEntry = audit.newLogEntry();\n            logEntry.setCategory(\"AI\");\n            logEntry.setEventId(autoField.eventName());\n            logEntry.setComment(comment);\n            logEntry.setDocUUID(doc.getId());\n            logEntry.setDocPath(doc.getPathAsString());\n            logEntry.setEventDate(new Date());\n            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);\n            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);\n            HashMap<String, ExtendedInfo> infos = new HashMap<>();\n            infos.put(\"model\", modelInfo);\n            infos.put(\"value\", one);\n            logEntry.setExtendedInfos(infos);\n            audit.addLogEntries(Collections.singletonList(logEntry));\n        } else {\n            log.warn(\"Audit Logger is not available\");\n        }\n    }\n    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {\n        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(),\n                doc);\n        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());\n        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());\n        String paths = null;\n        if (xPaths != null && !xPaths.isEmpty()) {\n            paths = String.join(\",\", xPaths);\n        }\n        ctx.setProperty(PATHS, paths);\n        if (StringUtils.isEmpty(comment)) {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);\n        } else {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);\n        }\n        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));\n    }\n    @Override\n    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null) {\n            return doc;\n        }\n        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());\n        itemsList.forEach(suggestObj -> {\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);\n            List<Map<String, Object>> newSuggestions = suggestions.stream()\n                                                                  .filter(s -> !xPath.equals(\n                                                                          s.get(SUGGESTION_PROPERTY)))\n                                                                  .collect(Collectors.toList());\n            if (!newSuggestions.isEmpty()) {\n                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);\n                newSuggestList.add(suggestObj);\n            }\n        });\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);\n        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);\n        return doc;\n    }\n    @Override\n    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null || itemsList.isEmpty()) {\n            return doc;\n        }\n        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());\n        Set<String> removedTargetProperties = new HashSet<>();\n        itemsList.forEach(entry -> {\n            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));\n            if (hadBeenModified(doc, inputProperties)) {\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);\n                Set<String> targetProps = suggestions.stream()\n                                                     .map(s -> (String) s.get(SUGGESTION_PROPERTY))\n                                                     .collect(Collectors.toSet());\n                removedTargetProperties.addAll(targetProps);\n            } else {\n                cleanItemsList.add(entry);\n            }\n        });\n        if (cleanItemsList.size() != itemsList.size()) {\n            //We made some changes lets update\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, \"Dirty inputs\");\n        }\n        return doc;\n    }\n    @Override\n    public List<AutoHistory> getAutoHistory(DocumentModel doc) {\n        try {\n            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());\n            if (autoBlob != null) {\n                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to read auto history blob\", e);\n        }\n        return Collections.emptyList();\n    }\n    @Override\n    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {\n        try {\n            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            String autoHistory = AUTO.HISTORY.lowerName();\n            autoBlob.setFilename(autoHistory + \"_\" + doc.getName() + \".json\");\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);\n        } catch (IOException e) {\n            log.warn(\"Failed to set auto history blob\", e);\n        }\n    }\n"]], "pred": {"ppl": 2.2836923599243164, "ppl_lower": 2.7068099975585938, "ppl/lowercase_ppl": -1.2058350075944604, "ppl/zlib": 0.0002640005080461944, "Min_5.0% Prob": 7.438219369626513, "Min_10.0% Prob": 5.487921389878965, "Min_20.0% Prob": 3.6647573750393065, "Min_30.0% Prob": 2.6681703200527265, "Min_40.0% Prob": 2.0459470105127484, "Min_50.0% Prob": 1.6489076015636062, "Min_60.0% Prob": 1.3771820791251046}}
{"hexsha": "2dc0bd87eab86338ed959af6cf2291c34c7fcd29", "ext": "java", "lang": "Java", "content": "@Getter\npublic class OrientedBox {\n    protected Vector center;\n    protected Vector axisX;\n    protected Vector axisY;\n    protected Vector axisZ;\n    protected float extentX;\n    protected float extentY;\n    protected float extentZ;\n\n    public OrientedBox(final Vector center,\n                       final Vector axisX,\n                       final Vector axisY,\n                       final Vector axisZ,\n                       final float extentX,\n                       final float extentY,\n                       final float extentZ) {\n        this.center = center;\n        this.axisX = axisX;\n        this.axisY = axisY;\n        this.axisZ = axisZ;\n        this.extentX = extentX;\n        this.extentY = extentY;\n        this.extentZ = extentZ;\n    }\n\n    public OrientedBox(final AxialBox box, final Transform transform) {\n        this.center = transform.rotateTranslateLocalToParent(box.getCenter());\n        this.axisX = transform.rotateLocalToParent(box.getAxisX());\n        this.axisY = transform.rotateLocalToParent(box.getAxisY());\n        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final AxialBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final YawedBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public Vector[] getAxes() {\n        return new Vector[]{axisX, axisY, axisZ};\n    }\n\n    public float[] getExtents() {\n        return new float[]{extentX, extentY, extentZ};\n    }\n\n    public Vector getBase() {\n        return getCenter().subtract(getAxisY().multiply(getExtentY()));\n    }\n\n    public Plane3d getFacePlane(final int whichPlane) {\n        switch (whichPlane) {\n            case 0:\n                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);\n            case 1:\n                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);\n            case 2:\n                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);\n            case 3:\n                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());\n            case 4:\n                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());\n            case 5:\n                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());\n            default:\n                return new Plane3d(Vector.ZERO, Vector.ZERO);\n        }\n    }\n\n    public Vector getCorner(final int whichCorner) {\n        final Vector x = axisX.multiply(extentX);\n        final Vector y = axisY.multiply(extentY);\n        final Vector z = axisZ.multiply(extentZ);\n\n        switch (whichCorner) {\n            case 0:\n                return center.subtract(x).subtract(y).subtract(z);\n            case 1:\n                return center.add(x).subtract(y).subtract(z);\n            case 2:\n                return center.subtract(x).subtract(y).add(z);\n            case 3:\n                return center.add(x).subtract(y).add(z);\n            case 4:\n                return center.subtract(x).add(y).subtract(z);\n            case 5:\n                return center.add(x).add(y).subtract(z);\n            case 6:\n                return center.subtract(x).add(y).add(z);\n            case 7:\n                return center.add(x).add(y).add(z);\n            default:\n                return Vector.ZERO;\n        }\n    }\n\n    public AxialBox getLocalShape() {\n        return new AxialBox(\n                new Vector(-extentX, -extentY, -extentZ),\n                new Vector(extentX, extentY, extentZ));\n    }\n\n    public Transform getTransformLocalToParent() {\n        final Transform temp = new Transform();\n        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());\n        temp.moveInParentSpace(center);\n        return temp;\n    }\n\n    public Transform getTransformParentToLocal() {\n        final Transform temp = new Transform();\n        temp.invert(getTransformLocalToParent());\n        return temp;\n    }\n\n    public Vector transformToLocal(final Vector vector) {\n        return rotateToLocal(vector.subtract(center));\n    }\n\n    public Vector transformToWorld(final Vector vector) {\n        return rotateToWorld(vector).add(center);\n    }\n\n    public Vector rotateToLocal(final Vector vector) {\n        return new Vector(\n                vector.dot(getAxisX()),\n                vector.dot(getAxisY()),\n                vector.dot(getAxisZ()));\n    }\n\n    public Vector rotateToWorld(final Vector vector) {\n        return Vector.ZERO\n                .add(getAxisX().multiply(vector.x))\n                .add(getAxisY().multiply(vector.y))\n                .add(getAxisZ().multiply(vector.z));\n    }\n}", "class_id": 0, "repo": "bacta/pre-cu-archive", "file": "src/main/java/com/ocdsoft/bacta/swg/shared/math/OrientedBox.java", "last_update_at": "2021-09-20T23:01:54+00:00", "question_id": "2dc0bd87eab86338ed959af6cf2291c34c7fcd29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\npublic class OrientedBox {\n    protected Vector center;\n    protected Vector axisX;\n    protected Vector axisY;\n    protected Vector axisZ;\n    protected float extentX;\n    protected float extentY;\n    protected float extentZ;\n    public OrientedBox(final Vector center,\n                       final Vector axisX,\n                       final Vector axisY,\n                       final Vector axisZ,\n                       final float extentX,\n                       final float extentY,\n                       final float extentZ) {\n        this.center = center;\n        this.axisX = axisX;\n        this.axisY = axisY;\n        this.axisZ = axisZ;\n        this.extentX = extentX;\n        this.extentY = extentY;\n        this.extentZ = extentZ;\n    }\n    public OrientedBox(final AxialBox box, final Transform transform) {\n        this.center = transform.rotateTranslateLocalToParent(box.getCenter());\n        this.axisX = transform.rotateLocalToParent(box.getAxisX());\n        this.axisY = transform.rotateLocalToParent(box.getAxisY());\n        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n    public OrientedBox(final AxialBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n    public OrientedBox(final YawedBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n    public Vector[] getAxes() {\n        return new Vector[]{axisX, axisY, axisZ};\n    }\n    public float[] getExtents() {\n        return new float[]{extentX, extentY, extentZ};\n    }\n    public Vector getBase() {\n        return getCenter().subtract(getAxisY().multiply(getExtentY()));\n    }\n    public Plane3d getFacePlane(final int whichPlane) {\n        switch (whichPlane) {\n            case 0:\n                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);\n            case 1:\n                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);\n            case 2:\n                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);\n            case 3:\n                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());\n            case 4:\n                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());\n            case 5:\n                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());\n            default:\n                return new Plane3d(Vector.ZERO, Vector.ZERO);\n        }\n    }\n    public Vector getCorner(final int whichCorner) {\n        final Vector x = axisX.multiply(extentX);\n        final Vector y = axisY.multiply(extentY);\n        final Vector z = axisZ.multiply(extentZ);\n        switch (whichCorner) {\n            case 0:\n                return center.subtract(x).subtract(y).subtract(z);\n            case 1:\n                return center.add(x).subtract(y).subtract(z);\n            case 2:\n                return center.subtract(x).subtract(y).add(z);\n            case 3:\n                return center.add(x).subtract(y).add(z);\n            case 4:\n                return center.subtract(x).add(y).subtract(z);\n            case 5:\n                return center.add(x).add(y).subtract(z);\n            case 6:\n                return center.subtract(x).add(y).add(z);\n            case 7:\n                return center.add(x).add(y).add(z);\n            default:\n                return Vector.ZERO;\n        }\n    }\n    public AxialBox getLocalShape() {\n        return new AxialBox(\n                new Vector(-extentX, -extentY, -extentZ),\n                new Vector(extentX, extentY, extentZ));\n    }\n    public Transform getTransformLocalToParent() {\n        final Transform temp = new Transform();\n        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());\n        temp.moveInParentSpace(center);\n        return temp;\n    }\n    public Transform getTransformParentToLocal() {\n        final Transform temp = new Transform();\n        temp.invert(getTransformLocalToParent());\n        return temp;\n    }\n    public Vector transformToLocal(final Vector vector) {\n        return rotateToLocal(vector.subtract(center));\n    }\n    public Vector transformToWorld(final Vector vector) {\n        return rotateToWorld(vector).add(center);\n    }\n    public Vector rotateToLocal(final Vector vector) {\n        return new Vector(\n                vector.dot(getAxisX()),\n                vector.dot(getAxisY()),\n                vector.dot(getAxisZ()));\n    }\n    public Vector rotateToWorld(final Vector vector) {\n        return Vector.ZERO\n                .add(getAxisX().multiply(vector.x))\n                .add(getAxisY().multiply(vector.y))\n                .add(getAxisZ().multiply(vector.z));\n    }\n"]], "pred": {"ppl": 1.271363615989685, "ppl_lower": 1.3371485471725464, "ppl/lowercase_ppl": -1.2101268316455618, "ppl/zlib": 0.00025650645067337377, "Min_5.0% Prob": 3.841700091081507, "Min_10.0% Prob": 2.2557093743600096, "Min_20.0% Prob": 1.1877307184588384, "Min_30.0% Prob": 0.7997109801965017, "Min_40.0% Prob": 0.599848141141172, "Min_50.0% Prob": 0.4804441498466284, "Min_60.0% Prob": 0.40060830972840905}}
{"hexsha": "cebbdc7523d968d8f24072abc5e1ab3f921ba715", "ext": "java", "lang": "Java", "content": "public class BinaryInput extends AbstractInput {\r\n    private static final long serialVersionUID = -1467422051075776185L;\r\n    \r\n    private final HexEdit hexEdit = new HexEdit(new byte[0]);\r\n    private byte[] buffer;      // model - byte array\r\n    \r\n    /**\r\n     * Constructor\r\n     * \r\n     */\r\n    public BinaryInput() {\r\n        super();\r\n        setLayout(new GridLayout(1,1));\r\n        hexEdit.addAncestorListener(new RequestFocusListener());    // set focus\r\n        add(hexEdit);\r\n    }\r\n    \r\n    /**\r\n     * Sets value to be edited\r\n     * \r\n     * @param buffer \r\n     */\r\n    public void setValue(byte[] buffer) {\r\n        hexEdit.requestFocusInWindow();\r\n        this.buffer = buffer;\r\n        hexEdit.reset(buffer);\r\n    }\r\n    \r\n    /**\r\n     * Get edited data\r\n     * \r\n     * @return \r\n     */\r\n    public byte[] getValue() {\r\n        return(buffer);\r\n    }\r\n    \r\n}", "class_id": 0, "repo": "metalname/regular", "file": "Common/src/InputHelpers/BinaryInput.java", "last_update_at": "2021-09-12T13:33:15+00:00", "question_id": "cebbdc7523d968d8f24072abc5e1ab3f921ba715", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinaryInput extends AbstractInput {\r\n    private static final long serialVersionUID = -1467422051075776185L;\r\n    \r\n    private final HexEdit hexEdit = new HexEdit(new byte[0]);\r\n    private byte[] buffer;      // model - byte array\r\n    \r\n    /**\r\n     * Constructor\r\n     * \r\n     */\r\n    public BinaryInput() {\r\n        super();\r\n        setLayout(new GridLayout(1,1));\r\n        hexEdit.addAncestorListener(new RequestFocusListener());    // set focus\r\n        add(hexEdit);\r\n    }\r\n    \r\n    /**\r\n     * Sets value to be edited\r\n     * \r\n     * @param buffer \r\n     */\r\n    public void setValue(byte[] buffer) {\r\n        hexEdit.requestFocusInWindow();\r\n        this.buffer = buffer;\r\n        hexEdit.reset(buffer);\r\n    }\r\n    \r\n    /**\r\n     * Get edited data\r\n     * \r\n     * @return \r\n     */\r\n    public byte[] getValue() {\r\n        return(buffer);\r\n    }\r\n    \r\n"]], "pred": {"ppl": 2.6695396900177, "ppl_lower": 3.065863609313965, "ppl/lowercase_ppl": -1.1409740135516888, "ppl/zlib": 0.0025177078379666857, "Min_5.0% Prob": 6.737574540651762, "Min_10.0% Prob": 5.316671821806166, "Min_20.0% Prob": 3.8163534207777543, "Min_30.0% Prob": 3.022625268223774, "Min_40.0% Prob": 2.40429086728139, "Min_50.0% Prob": 1.9546605266577048, "Min_60.0% Prob": 1.6426707922469779}}
{"hexsha": "fd52101a33b5d14359ea4a2449bf8b531284b2c9", "ext": "java", "lang": "Java", "content": "public class NonStartTest {\n\n    private NonStart fixture;\n\n    @BeforeEach\n    public void setUp() {\n        fixture = new NonStart();\n    }\n\n    @Test\n    public void testcase1() {\n\n        final String strA = \"Hello\";\n        final String strB = \"There\";\n\n        final String expected = \"ellohere\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase2() {\n\n        final String strA = \"java\";\n        final String strB = \"code\";\n\n        final String expected = \"avaode\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase3() {\n\n        final String strA = \"shotl\";\n        final String strB = \"java\";\n\n        final String expected = \"hotlava\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreNull() {\n\n        final String strA = null;\n        final String strB = null;\n\n        final String expected = \"\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreEmpty() {\n\n        final String strA = \"\";\n        final String strB = \"\";\n\n        final String expected = \"\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {\n\n        final String strA1 = null;\n        final String strA2 = \"\";\n        final String strB1 = \"\";\n        final String strB2 = null;\n\n        final String expected = \"\";\n\n        final String actual1 = fixture.nonStart(strA1, strB1);\n        final String actual2 = fixture.nonStart(strA2, strB2);\n\n        assertThat(actual1).isEqualTo(expected);\n        assertThat(actual2).isEqualTo(expected);\n    }\n\n}", "class_id": 0, "repo": "the-code-journal/code-challenges-java", "file": "src/test/java/io/codejournal/codingbat/string1/NonStartTest.java", "last_update_at": "2021-06-13T14:03:00+00:00", "question_id": "fd52101a33b5d14359ea4a2449bf8b531284b2c9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NonStartTest {\n    private NonStart fixture;\n    @BeforeEach\n    public void setUp() {\n        fixture = new NonStart();\n    }\n    @Test\n    public void testcase1() {\n        final String strA = \"Hello\";\n        final String strB = \"There\";\n        final String expected = \"ellohere\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void testcase2() {\n        final String strA = \"java\";\n        final String strB = \"code\";\n        final String expected = \"avaode\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void testcase3() {\n        final String strA = \"shotl\";\n        final String strB = \"java\";\n        final String expected = \"hotlava\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnEmptyWhenBothAreNull() {\n        final String strA = null;\n        final String strB = null;\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnEmptyWhenBothAreEmpty() {\n        final String strA = \"\";\n        final String strB = \"\";\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {\n        final String strA1 = null;\n        final String strA2 = \"\";\n        final String strB1 = \"\";\n        final String strB2 = null;\n        final String expected = \"\";\n        final String actual1 = fixture.nonStart(strA1, strB1);\n        final String actual2 = fixture.nonStart(strA2, strB2);\n        assertThat(actual1).isEqualTo(expected);\n        assertThat(actual2).isEqualTo(expected);\n    }\n"]], "pred": {"ppl": 1.3775708675384521, "ppl_lower": 1.5540211200714111, "ppl/lowercase_ppl": -1.376259656180406, "ppl/zlib": 0.000872811191309269, "Min_5.0% Prob": 4.985478302528119, "Min_10.0% Prob": 2.9947603567171903, "Min_20.0% Prob": 1.5859928576886153, "Min_30.0% Prob": 1.0647358909904874, "Min_40.0% Prob": 0.8026180946045094, "Min_50.0% Prob": 0.6414665120838198, "Min_60.0% Prob": 0.5340780168469325}}
{"hexsha": "495a13909672c96a7ef84b5eadc8a58384dc2c30", "ext": "java", "lang": "Java", "content": "public class DiffAlgorithm\r\n{\r\n    // XXX: Caution, enabling logging significantly impacts performance\r\n    public static final int VERBOSE_LOGGING = 1;\r\n    \r\n    private DocumentModel baseModel, witnessModel;\r\n\r\n    private SymbolTable symbolTable;\r\n    private Correlator correlator;\r\n    private DifferenceCollector collector;\r\n    private DifferenceSet differenceSet;\r\n    \r\n    \r\n    public DifferenceSet diffDocuments( DocumentModel baseModel, DocumentModel witnessModel )\r\n    {\r\n        if( baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false ) \r\n        {\r\n            SimpleLogger.logError(\"Documents must be tokenized the same way to be comparable.\");\r\n            return null;\r\n        }\r\n\r\n        this.baseModel = baseModel;\r\n        this.witnessModel = witnessModel;\r\n\r\n        return performDiff();\r\n    }\r\n\r\n    //  perform the actual diff algorithm \r\n    private DifferenceSet performDiff()\r\n    {\r\n        // create a common symbol table based on the two documents\r\n        symbolTable = new SymbolTable(baseModel,witnessModel);\r\n\r\n        // Correlate the contents of the two documents\r\n        correlator = new Correlator(symbolTable);\r\n\r\n        // Collect difference information from the correlation data\r\n        collector = new DifferenceCollector(correlator);\r\n        differenceSet = collector.getDifferenceSet();\r\n        \r\n        return differenceSet;\r\n    }\r\n    \r\n    public void updateDifferenceSet(DifferenceSet differenceSet)\r\n    {\r\n    \tthis.differenceSet = differenceSet;\r\n    }\r\n    \r\n\t// Given the offset in one document, this finds the offset of that character in the other document.\r\n\t// If there is a perfect match, then it is easy to know what to return.\r\n\t// If it doesn't appear in the other document, then return it's insert point.\r\n\t// If it is part of a change, return -1.\r\n\r\n\tpublic int getCorrespondingWitnessOffset( int baseOffset, boolean getEnd )\r\n\t{\r\n\t\tint baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);\r\n\t\t\r\n\t\tFileInfo witnessFileInfo = correlator.getNewInfo();\r\n\t\t\r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\tbaseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE)+difference.getLength(Difference.BASE)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int witnessIndex=1; witnessIndex < witnessFileInfo.getSymbolCount()+1; witnessIndex++ ) {\r\n\t\t\tif( witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex ) {\r\n\t\t\t\tif(getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS ) + witnessFileInfo.getSymbol(witnessIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tpublic int getCorrespondingBaseOffset( int witnessOffset, boolean getEnd )\r\n\t{\r\n\t\tint witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);\r\n\t\t\r\n\t\tFileInfo baseFileInfo = correlator.getOldInfo();\r\n\t\t \r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\twitnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS)+difference.getLength(Difference.WITNESS)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int baseIndex=1; baseIndex < baseFileInfo.getSymbolCount()+1; baseIndex++ ) {\r\n\t\t\tif( baseFileInfo.getCrossIndex(baseIndex) == witnessIndex ) {\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE ) + baseFileInfo.getSymbol(baseIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\t\r\n\tprivate int convertIndexToOffset(int index, int type) {\r\n\t\t// For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.\r\n\t\tif( type == Difference.BASE ) {\r\n\t\t\treturn symbolTable.getOldInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn symbolTable.getNewInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t}\r\n\r\n\t// Given an offset into the document, we want to scan the token table, seeing which token that falls in.\r\n\t// There is some space that doesn't belong to any token (white space and punctuation when that is ignored),\r\n\t// so in that case we need to know if we're interested in the token before that or the token after that.\r\n\tprivate int convertOffsetToIndex(int offset, int type, boolean useNext) {\r\n\t\tDocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;\r\n\r\n\t\tList<Token> tokenList = targetDocument.getTokenList();\r\n\t\t\r\n\t\tint i=0;\r\n\t\tfor( Token token : tokenList ) {\r\n\t\t\tint tokenEnd = token.getOffset() + token.getToken().length();\r\n\t\t\t// If we are looking earlier, then we don't want to match the offset itself, because that will look to the user as the next token.\r\n\t\t\t// Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=\r\n\t\t\tint fudge = (useNext?0:1);\r\n\t\t\tif((token.getOffset() <= offset-fudge) &&  (offset <= tokenEnd))\r\n\t\t\t\t\treturn i;\t// Exact match\r\n\t\t\tif (token.getOffset() >= offset) // We've passed the spot, so we must be in the crack between tokens\r\n\t\t\t{\r\n\t\t\t\tif (useNext)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i == tokenList.size()-1) return i;\r\n\t\t\t\t\telse return i;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn (i-1 > 0) ? i-1 : 0;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t\r\n\t\treturn (tokenList.size() > 0 ) ? tokenList.size()-1 : 0;\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "performant-software/juxta-desktop", "file": "src/main/java/edu/virginia/speclab/diff/DiffAlgorithm.java", "last_update_at": "2021-07-17T19:42:48+00:00", "question_id": "495a13909672c96a7ef84b5eadc8a58384dc2c30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DiffAlgorithm\r\n{\r\n    // XXX: Caution, enabling logging significantly impacts performance\r\n    public static final int VERBOSE_LOGGING = 1;\r\n    \r\n    private DocumentModel baseModel, witnessModel;\r\n\r\n    private SymbolTable symbolTable;\r\n    private Correlator correlator;\r\n    private DifferenceCollector collector;\r\n    private DifferenceSet differenceSet;\r\n    \r\n    \r\n    public DifferenceSet diffDocuments( DocumentModel baseModel, DocumentModel witnessModel )\r\n    {\r\n        if( baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false ) \r\n        {\r\n            SimpleLogger.logError(\"Documents must be tokenized the same way to be comparable.\");\r\n            return null;\r\n        }\r\n\r\n        this.baseModel = baseModel;\r\n        this.witnessModel = witnessModel;\r\n\r\n        return performDiff();\r\n    }\r\n\r\n    //  perform the actual diff algorithm \r\n    private DifferenceSet performDiff()\r\n    {\r\n        // create a common symbol table based on the two documents\r\n        symbolTable = new SymbolTable(baseModel,witnessModel);\r\n\r\n        // Correlate the contents of the two documents\r\n        correlator = new Correlator(symbolTable);\r\n\r\n        // Collect difference information from the correlation data\r\n        collector = new DifferenceCollector(correlator);\r\n        differenceSet = collector.getDifferenceSet();\r\n        \r\n        return differenceSet;\r\n    }\r\n    \r\n    public void updateDifferenceSet(DifferenceSet differenceSet)\r\n    {\r\n    \tthis.differenceSet = differenceSet;\r\n    }\r\n    \r\n\t// Given the offset in one document, this finds the offset of that character in the other document.\r\n\t// If there is a perfect match, then it is easy to know what to return.\r\n\t// If it doesn't appear in the other document, then return it's insert point.\r\n\t// If it is part of a change, return -1.\r\n\r\n\tpublic int getCorrespondingWitnessOffset( int baseOffset, boolean getEnd )\r\n\t{\r\n\t\tint baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);\r\n\t\t\r\n\t\tFileInfo witnessFileInfo = correlator.getNewInfo();\r\n\t\t\r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\tbaseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE)+difference.getLength(Difference.BASE)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int witnessIndex=1; witnessIndex < witnessFileInfo.getSymbolCount()+1; witnessIndex++ ) {\r\n\t\t\tif( witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex ) {\r\n\t\t\t\tif(getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS ) + witnessFileInfo.getSymbol(witnessIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tpublic int getCorrespondingBaseOffset( int witnessOffset, boolean getEnd )\r\n\t{\r\n\t\tint witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);\r\n\t\t\r\n\t\tFileInfo baseFileInfo = correlator.getOldInfo();\r\n\t\t \r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\twitnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS)+difference.getLength(Difference.WITNESS)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int baseIndex=1; baseIndex < baseFileInfo.getSymbolCount()+1; baseIndex++ ) {\r\n\t\t\tif( baseFileInfo.getCrossIndex(baseIndex) == witnessIndex ) {\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE ) + baseFileInfo.getSymbol(baseIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\t\r\n\tprivate int convertIndexToOffset(int index, int type) {\r\n\t\t// For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.\r\n\t\tif( type == Difference.BASE ) {\r\n\t\t\treturn symbolTable.getOldInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn symbolTable.getNewInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t}\r\n\r\n\t// Given an offset into the document, we want to scan the token table, seeing which token that falls in.\r\n\t// There is some space that doesn't belong to any token (white space and punctuation when that is ignored),\r\n\t// so in that case we need to know if we're interested in the token before that or the token after that.\r\n\tprivate int convertOffsetToIndex(int offset, int type, boolean useNext) {\r\n\t\tDocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;\r\n\r\n\t\tList<Token> tokenList = targetDocument.getTokenList();\r\n\t\t\r\n\t\tint i=0;\r\n\t\tfor( Token token : tokenList ) {\r\n\t\t\tint tokenEnd = token.getOffset() + token.getToken().length();\r\n\t\t\t// If we are looking earlier, then we don't want to match the offset itself, because that will look to the user as the next token.\r\n\t\t\t// Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=\r\n\t\t\tint fudge = (useNext?0:1);\r\n\t\t\tif((token.getOffset() <= offset-fudge) &&  (offset <= tokenEnd))\r\n\t\t\t\t\treturn i;\t// Exact match\r\n\t\t\tif (token.getOffset() >= offset) // We've passed the spot, so we must be in the crack between tokens\r\n\t\t\t{\r\n\t\t\t\tif (useNext)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i == tokenList.size()-1) return i;\r\n\t\t\t\t\telse return i;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn (i-1 > 0) ? i-1 : 0;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t\r\n\t\treturn (tokenList.size() > 0 ) ? tokenList.size()-1 : 0;\r\n\t}\r\n\r\n"]], "pred": {"ppl": 2.5633370876312256, "ppl_lower": 2.7512874603271484, "ppl/lowercase_ppl": -1.0751707865604363, "ppl/zlib": 0.00047733770763891127, "Min_5.0% Prob": 6.632519834181842, "Min_10.0% Prob": 5.275438666343689, "Min_20.0% Prob": 3.823164808399537, "Min_30.0% Prob": 2.9136912557813854, "Min_40.0% Prob": 2.2959818817438298, "Min_50.0% Prob": 1.871964760037201, "Min_60.0% Prob": 1.5683434269319594}}
{"hexsha": "05ef2f68dbf7ba92065c8486bd0b45aff254557c", "ext": "java", "lang": "Java", "content": "public class OrganisationTransformer\n{\n\tpublic static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException\n    {\n        ArrayList<Organization> organizations = new ArrayList<>();\n\n        for (OpenHR001Organisation source: sources)\n            organizations.add(transform(source));\n\n        return organizations;\n    }\n\n\tpublic static Organization transform(OpenHR001Organisation source) throws TransformException\n    {\n\t\tOpenHRHelper.ensureDboNotDelete(source);\n\n\t\tOrganization target = new Organization();\n\n        target.setId(source.getId());\n        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));\n\n        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))\n            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));\n\n        target.setActive(source.getCloseDate() == null);\n\n        if ((source.getOpenDate() != null) || (source.getCloseDate() != null))\n        {\n            Period period = new Period();\n\n            if (source.getOpenDate() != null)\n                period.setStart(DateConverter.toDate(source.getOpenDate()));\n\n            if (source.getCloseDate() != null)\n                period.setEnd(DateConverter.toDate(source.getCloseDate()));\n\n            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));\n        }\n\n        target.setName(source.getName());\n        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));\n\n        if (!StringUtils.isBlank(source.getParentOrganisation()))\n            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));\n\n        if (!StringUtils.isBlank(source.getMainLocation()))\n            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));\n\n\t\treturn target;\n\t}\n}", "class_id": 0, "repo": "endeavourhealth/Transforms", "file": "src/main/java/org/endeavourhealth/transform/emis/openhr/transforms/admin/OrganisationTransformer.java", "last_update_at": "2021-08-17T12:29:48+00:00", "question_id": "05ef2f68dbf7ba92065c8486bd0b45aff254557c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrganisationTransformer\n{\n\tpublic static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException\n    {\n        ArrayList<Organization> organizations = new ArrayList<>();\n        for (OpenHR001Organisation source: sources)\n            organizations.add(transform(source));\n        return organizations;\n    }\n\tpublic static Organization transform(OpenHR001Organisation source) throws TransformException\n    {\n\t\tOpenHRHelper.ensureDboNotDelete(source);\n\t\tOrganization target = new Organization();\n        target.setId(source.getId());\n        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));\n        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))\n            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));\n        target.setActive(source.getCloseDate() == null);\n        if ((source.getOpenDate() != null) || (source.getCloseDate() != null))\n        {\n            Period period = new Period();\n            if (source.getOpenDate() != null)\n                period.setStart(DateConverter.toDate(source.getOpenDate()));\n            if (source.getCloseDate() != null)\n                period.setEnd(DateConverter.toDate(source.getCloseDate()));\n            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));\n        }\n        target.setName(source.getName());\n        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));\n        if (!StringUtils.isBlank(source.getParentOrganisation()))\n            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));\n        if (!StringUtils.isBlank(source.getMainLocation()))\n            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));\n\t\treturn target;\n\t}\n"]], "pred": {"ppl": 1.7133764028549194, "ppl_lower": 2.390592336654663, "ppl/lowercase_ppl": -1.618563272023321, "ppl/zlib": 0.0007681396980543214, "Min_5.0% Prob": 5.846038017954145, "Min_10.0% Prob": 4.106841296480413, "Min_20.0% Prob": 2.4985829795661725, "Min_30.0% Prob": 1.7565937281003472, "Min_40.0% Prob": 1.338975714732027, "Min_50.0% Prob": 1.0739824046817172, "Min_60.0% Prob": 0.8973011447811831}}
{"hexsha": "39d74258dd6a75d4e31c7f001884daaab0356310", "ext": "java", "lang": "Java", "content": "public class Do implements Directive {\n    Directive _prefix;\n\n    @Override\n    public String script() {\n        return String.format(\"%s do\", _prefix.script());\n    }\n\n    @Override\n    public List<Parameter> parameters() {\n        return _prefix.parameters();\n    }\n\n    public Nothing nothing(){\n        Nothing re = new Nothing();\n        re._prefix = this;\n        return re;\n    }\n\n    public Update update(){\n        Update re = new Update();\n        re._prefix = this;\n        return re;\n    }\n\n    public class Update implements Directive {\n        Directive _prefix;\n\n        @Override\n        public String script() {\n            return String.format(\"%s update\", _prefix.script());\n        }\n\n        @Override\n        public List<Parameter> parameters() {\n            return _prefix.parameters();\n        }\n\n        public jaskell.sql.Update.Set set(String field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n\n        public jaskell.sql.Update.Set set(Directive field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n    }\n}", "class_id": 0, "repo": "moonbirdxp/jaskell", "file": "src/main/java/jaskell/sql/Do.java", "last_update_at": "2021-04-29T01:31:42+00:00", "question_id": "39d74258dd6a75d4e31c7f001884daaab0356310", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Do implements Directive {\n    Directive _prefix;\n    @Override\n    public String script() {\n        return String.format(\"%s do\", _prefix.script());\n    }\n    @Override\n    public List<Parameter> parameters() {\n        return _prefix.parameters();\n    }\n    public Nothing nothing(){\n        Nothing re = new Nothing();\n        re._prefix = this;\n        return re;\n    }\n    public Update update(){\n        Update re = new Update();\n        re._prefix = this;\n        return re;\n    }\n    public class Update implements Directive {\n        Directive _prefix;\n        @Override\n        public String script() {\n            return String.format(\"%s update\", _prefix.script());\n        }\n        @Override\n        public List<Parameter> parameters() {\n            return _prefix.parameters();\n        }\n        public jaskell.sql.Update.Set set(String field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n        public jaskell.sql.Update.Set set(Directive field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n    }\n"]], "pred": {"ppl": 1.7590314149856567, "ppl_lower": 1.9319696426391602, "ppl/lowercase_ppl": -1.1660460114904763, "ppl/zlib": 0.0018101388627150417, "Min_5.0% Prob": 7.765680581331253, "Min_10.0% Prob": 5.006297375216628, "Min_20.0% Prob": 2.7675729142640955, "Min_30.0% Prob": 1.870299427668647, "Min_40.0% Prob": 1.4172292433317695, "Min_50.0% Prob": 1.1319972613904004, "Min_60.0% Prob": 0.94188880028104}}
{"hexsha": "8430996939d31d00feb517b1c2345762d39cc91e", "ext": "java", "lang": "Java", "content": "public class PullRequestRescopedActivity extends PullRequestActivity{\n\n    private String fromHash;\n    private String previousFromHash;\n    private String previousToHash;\n    private String toHash;\n\n    private List<Commit> added;\n    private List<Commit> removed;\n\n    protected PullRequestRescopedActivity() {\n    }\n\n    public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {\n        this.id = id;\n        this.createdDate = createdDate;\n        this.user = user;\n        this.pullRequestId = pullRequestId;\n        this.fromHash = fromHash;\n        this.previousFromHash = previousFromHash;\n        this.previousToHash = previousToHash;\n        this.toHash = toHash;\n        this.added = ImmutableList.copyOf(added);\n        this.removed = ImmutableList.copyOf(removed);\n        this.actionType = PullRequestActivityActionType.RESCOPED;\n    }\n\n    public String getFromHash() {\n        return fromHash;\n    }\n\n    public String getPreviousFromHash() {\n        return previousFromHash;\n    }\n\n    public String getPreviousToHash() {\n        return previousToHash;\n    }\n\n    public String getToHash() {\n        return toHash;\n    }\n\n    public List<Commit> getAdded() {\n        return added;\n    }\n\n    public List<Commit> getRemoved() {\n        return removed;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PullRequestRescopedActivity that = (PullRequestRescopedActivity) o;\n\n        if (pullRequestId != that.pullRequestId) return false;\n        if (fromHash != null ? !fromHash.equals(that.fromHash) : that.fromHash != null) return false;\n        if (previousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)\n            return false;\n        if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)\n            return false;\n        if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null) return false;\n        if (added != null ? !added.equals(that.added) : that.added != null) return false;\n        if (removed != null ? !removed.equals(that.removed) : that.removed != null) return false;\n        if (id != null ? !id.equals(that.id) : that.id != null) return false;\n        if (createdDate != null ? !createdDate.equals(that.createdDate) : that.createdDate != null) return false;\n        if (user != null ? !user.equals(that.user) : that.user != null) return false;\n        return actionType == that.actionType;\n\n    }\n\n    @Override\n    public int hashCode() {\n        int result = fromHash != null ? fromHash.hashCode() : 0;\n        result = 31 * result + (previousFromHash != null ? previousFromHash.hashCode() : 0);\n        result = 31 * result + (previousToHash != null ? previousToHash.hashCode() : 0);\n        result = 31 * result + (toHash != null ? toHash.hashCode() : 0);\n        result = 31 * result + (added != null ? added.hashCode() : 0);\n        result = 31 * result + (removed != null ? removed.hashCode() : 0);\n        result = 31 * result + (id != null ? id.hashCode() : 0);\n        result = 31 * result + (createdDate != null ? createdDate.hashCode() : 0);\n        result = 31 * result + (user != null ? user.hashCode() : 0);\n        result = 31 * result + (int) (pullRequestId ^ (pullRequestId >>> 32));\n        result = 31 * result + (actionType != null ? actionType.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"PullRequestRescopedActivity{\" +\n                \"fromHash='\" + fromHash + '\\'' +\n                \", previousFromHash='\" + previousFromHash + '\\'' +\n                \", previousToHash='\" + previousToHash + '\\'' +\n                \", toHash='\" + toHash + '\\'' +\n                \", added=\" + added +\n                \", removed=\" + removed +\n                \", id=\" + id +\n                \", createdDate=\" + createdDate +\n                \", user=\" + user +\n                \", pullRequestId=\" + pullRequestId +\n                \", actionType=\" + actionType +\n                '}';\n    }\n}", "class_id": 0, "repo": "cornelcreanga/bitbucket-rest-client", "file": "src/main/java/com/ccreanga/bitbucket/rest/client/model/pull/activity/PullRequestRescopedActivity.java", "last_update_at": "2021-06-30T06:37:32+00:00", "question_id": "8430996939d31d00feb517b1c2345762d39cc91e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [