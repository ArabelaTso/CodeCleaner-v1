{"hexsha": "b08a80f53c729d0b170df6c3806811715adb16ff", "ext": "java", "lang": "Java", "content": "public class BitstreamReader extends AbstractReader implements Recyclable\n{\n    private static Logger log = Logger.getLogger(BitstreamReader.class);\n        \n    /**\n     * Messages to be sent when the user is not authorized to view\n     * a particular bitstream. They will be redirected to the login\n     * where this message will be displayed.\n     */\n    private static final String AUTH_REQUIRED_HEADER = \"xmlui.BitstreamReader.auth_header\";\n    private static final String AUTH_REQUIRED_MESSAGE = \"xmlui.BitstreamReader.auth_message\";\n        \n    /**\n     * How big a buffer should we use when reading from the bitstream before\n     * writing to the HTTP response?\n     */\n    protected static final int BUFFER_SIZE = 8192;\n\n    /**\n     * When should a bitstream expire in milliseconds. This should be set to\n     * some low value just to prevent someone hiting DSpace repeatedy from\n     * killing the server. Note: there are 1000 milliseconds in a second.\n     *\n     * Format: minutes * seconds * milliseconds\n     *  60 * 60 * 1000 == 1 hour\n     */\n    protected static final int expires = 60 * 60 * 1000;\n\n    /** The Cocoon response */\n    protected Response response;\n\n    /** The Cocoon request */\n    protected Request request;\n\n    /** The bitstream file */\n    protected InputStream bitstreamInputStream;\n    \n    /** The bitstream's reported size */\n    protected long bitstreamSize;\n    \n    /** The bitstream's mime-type */\n    protected String bitstreamMimeType;\n    \n    /** The bitstream's name */\n    protected String bitstreamName;\n    \n    /** True if bitstream is readable by anonymous users */\n    protected boolean isAnonymouslyReadable;\n\n    /** The last modified date of the item containing the bitstream */\n    private Date itemLastModified = null;\n\n    /** True if user agent making this request was identified as spider. */\n    private boolean isSpider = false;\n\n    /** TEMP file for citation PDF. We will save here, so we can delete the temp file when done.  */\n    private File tempFile;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();\n\n\n    /**\n     * Set up the bitstream reader.\n     *\n     * See the class description for information on configuration options.\n     * @param resolver source resolver.\n     * @param objectModel Cocoon object model.\n     * @param src source to read.\n     * @param par Reader parameters.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    public void setup(SourceResolver resolver, Map objectModel, String src,\n            Parameters par)\n            throws ProcessingException, SAXException, IOException\n    {\n        super.setup(resolver, objectModel, src, par);\n\n        try\n        {\n            this.request = ObjectModelHelper.getRequest(objectModel);\n            this.response = ObjectModelHelper.getResponse(objectModel);\n\n            Item item = null;\n\n            // Check to see if a context already exists or not. We may\n            // have been aggregated into an http request by the XSL document\n            // pulling in an XML-based bitstream. In this case the context has\n            // already been created and we should leave it open because the\n            // normal processes will close it.\n            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);\n            Context context = ContextUtil.obtainContext(objectModel);\n            \n            // Get our parameters that identify the bitstream\n            String itemID = par.getParameter(\"itemID\", null);\n            String bitstreamID = par.getParameter(\"bitstreamID\", null);\n            String handle = par.getParameter(\"handle\", null);\n            \n            int sequence = par.getParameterAsInteger(\"sequence\", -1);\n            String name = par.getParameter(\"name\", null);\n        \n            this.isSpider = par.getParameter(\"userAgent\", \"\").equals(\"spider\");\n\n            // Resolve the bitstream\n            Bitstream bitstream = null;\n            DSpaceObject dso = null;\n            \n            if (bitstreamID != null)\n            {\n                // Direct reference to the individual bitstream ID.\n                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);\n            }\n            else if (itemID != null)\n            {\n                // Referenced by internal itemID\n                item = itemService.findByIdOrLegacyId(context, itemID);\n                \n                if (sequence > -1)\n                {\n                        bitstream = findBitstreamBySequence(item, sequence);\n                }\n                else if (name != null)\n                {\n                        bitstream = findBitstreamByName(item, name);\n                }\n            }\n            else if (handle != null)\n            {\n                // Reference by an item's handle.\n                dso = handleService.resolveToObject(context, handle);\n\n                if (dso instanceof Item)\n                {\n                    item = (Item)dso;\n\n                    if (sequence > -1)\n                    {\n                        bitstream = findBitstreamBySequence(item,sequence);\n                    }\n                    else if (name != null)\n                    {\n                        bitstream = findBitstreamByName(item,name);\n                    }\n                }\n            }\n\n            if (item != null) {\n                itemLastModified = item.getLastModified();\n            }\n\n            // if initial search was by sequence number and found nothing,\n            // then try to find bitstream by name (assuming we have a file name)\n            if((sequence > -1 && bitstream==null) && name!=null)\n            {\n                bitstream = findBitstreamByName(item,name);\n\n                // if we found bitstream by name, send a redirect to its new sequence number location\n                if(bitstream!=null)\n                {\n                    String redirectURL = \"\";\n\n                    // build redirect URL based on whether item has a handle assigned yet\n                    if(item.getHandle()!=null && item.getHandle().length()>0)\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/handle/\" + item.getHandle();\n                    }\n                    else\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/item/\" + item.getID();\n                    }\n\n                        redirectURL += \"/\" + name + \"?sequence=\" + bitstream.getSequenceID();\n\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redirectURL);\n                        return;\n                }\n            }\n\n            // Was a bitstream found?\n            if (bitstream == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate bitstream\");\n            }\n\n            // Is there a User logged in and does the user have access to read it?\n            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);\n            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context))\n            {\n                isAuthorized = false;\n                log.info(LogManager.getHeader(context, \"view_bitstream\", \"handle=\" + item.getHandle() + \",withdrawn=true\"));\n            }\n            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request  \n            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\");\n            if (!isAuthorized)\n            {\n                if(context.getCurrentUser() != null || StringUtils.equalsIgnoreCase(\"all\", requestItemType)){\n                        // A user is logged in, but they are not authorized to read this bitstream,\n                        // instead of asking them to login again we'll point them to a friendly error\n                        // message that tells them the bitstream is restricted.\n                        String redictURL = request.getContextPath() + \"/handle/\";\n                        if (item!=null){\n                                redictURL += item.getHandle();\n                        }\n                        else if(dso!=null){\n                                redictURL += dso.getHandle();\n                        }\n                        redictURL += \"/restricted-resource?bitstreamId=\" + bitstream.getID();\n\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                }\n                else{\n                \tif(StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\")) ||\n                \t\t\t                \t\t\tDSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\").equalsIgnoreCase(\"logged\")){\n                        // The user does not have read access to this bitstream. Interrupt this current request\n                        // and then forward them to the login page so that they can be authenticated. Once that is\n                        // successful, their request will be resumed.\n                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);\n\n                        // Redirect\n                        String redictURL = request.getContextPath() + \"/login\";\n\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                \t}\n                }\n            }\n\n            // Success, bitstream found and the user has access to read it.\n            // Store these for later retrieval:\n\n            // Intercepting views to the original bitstream to instead show a citation altered version of the object\n            // We need to check if this resource falls under the \"show watermarked alternative\" umbrella.\n            // At which time we will not return the \"bitstream\", but will instead on-the-fly generate the citation rendition.\n\n            // What will trigger a redirect/intercept?\n            // 1) Intercepting Enabled\n            // 2) This User is not an admin\n            // 3) This object is citation-able\n            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {\n                // on-the-fly citation generator\n                log.info(item.getHandle() + \" - \" + bitstream.getName() + \" is citable.\");\n\n                FileInputStream fileInputStream = null;\n\n                try {\n                    //Create the cited document\n                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);\n                    if(tempFile == null) {\n                        log.error(\"CitedDocument was null\");\n                    } else {\n                        log.info(\"CitedDocument was ok,\" + tempFile.getAbsolutePath());\n                    }\n\n\n                    fileInputStream = new FileInputStream(tempFile);\n                    if(fileInputStream == null) {\n                        log.error(\"Error opening fileInputStream: \");\n                    }\n\n                    this.bitstreamInputStream = fileInputStream;\n                    this.bitstreamSize = tempFile.length();\n\n                } catch (Exception e) {\n                    log.error(\"Caught an error with intercepting the citation document:\" + e.getMessage());\n                }\n\n                //End of CitationDocument\n            } else {\n                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);\n                this.bitstreamSize = bitstream.getSize();\n            }\n\n            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();\n            this.bitstreamName = bitstream.getName();\n            if (context.getCurrentUser() == null)\n            {\n                this.isAnonymouslyReadable = true;\n            }\n            else\n            {\n                this.isAnonymouslyReadable = false;\n                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ))\n                {\n                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS))\n                    {\n                        this.isAnonymouslyReadable = true;\n                    }\n                }\n            }\n\n            // Trim any path information from the bitstream\n            if (bitstreamName != null && bitstreamName.length() >0 )\n            {\n                        int finalSlashIndex = bitstreamName.lastIndexOf('/');\n                        if (finalSlashIndex > 0)\n                        {\n                                bitstreamName = bitstreamName.substring(finalSlashIndex+1);\n                        }\n            }\n            else\n            {\n                // In-case there is no bitstream name...\n                if(name != null && name.length() > 0) {\n                    bitstreamName = name;\n                    if(name.endsWith(\".jpg\")) {\n                        bitstreamMimeType = \"image/jpeg\";\n                    } else if(name.endsWith(\".png\")) {\n                        bitstreamMimeType = \"image/png\";\n                    }\n                } else {\n                    bitstreamName = \"bitstream\";\n                }\n            }\n            \n            // Log that the bitstream has been viewed, this is non-cached and the complexity\n            // of adding it to the sitemap for every possible bitstream uri is not very tractable\n            DSpaceServicesFactory.getInstance().getEventService().fireEvent(\n                                new UsageEvent(\n                                                UsageEvent.Action.VIEW,\n                                                ObjectModelHelper.getRequest(objectModel),\n                                                ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),\n                                                bitstream));\n            \n            // If we created the database connection close it, otherwise leave it open.\n            if (BitstreamReaderOpenedContext)\n            \tcontext.complete();\n        }\n        catch (SQLException sqle)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",sqle);\n        }\n        catch (AuthorizeException ae)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",ae);\n        }\n    }\n\n    \n    \n    \n    \n    /**\n     * Find the bitstream identified by a sequence number on this item.\n     *\n     * @param item A DSpace item\n     * @param sequence The sequence of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException\n    {\n        if (item == null)\n        {\n            return null;\n        }\n        \n        List<Bundle> bundles = item.getBundles();\n        for (Bundle bundle : bundles)\n        {\n            List<Bitstream> bitstreams = bundle.getBitstreams();\n\n            for (Bitstream bitstream : bitstreams)\n            {\n                if (bitstream.getSequenceID() == sequence)\n                {\n                    return bitstream;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Return the bitstream from the given item that is identified by the\n     * given name. If the name has prepended directories they will be removed\n     * one at a time until a bitstream is found. Note that if two bitstreams\n     * have the same name then the first bitstream will be returned.\n     *\n     * @param item A DSpace item\n     * @param name The name of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamByName(Item item, String name) throws SQLException\n    {\n        if (name == null || item == null)\n        {\n            return null;\n        }\n    \n        // Determine our the maximum number of directories that will be removed for a path.\n        int maxDepthPathSearch = 3;\n        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"xmlui.html.max-depth-guess\") != null)\n        {\n            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.html.max-depth-guess\");\n        }\n        \n        // Search for the named bitstream on this item. Each time through the loop\n        // a directory is removed from the name until either our maximum depth is\n        // reached or the bitstream is found. Note: an extra pass is added on to the\n        // loop for a last ditch effort where all directory paths will be removed.\n        for (int i = 0; i < maxDepthPathSearch+1; i++)\n        {\n                // Search through all the bitstreams and see\n                // if the name can be found\n                List<Bundle> bundles = item.getBundles();\n                for (Bundle bundle : bundles)\n                {\n                    List<Bitstream> bitstreams = bundle.getBitstreams();\n        \n                    for (Bitstream bitstream : bitstreams)\n                    {\n                        if (name.equals(bitstream.getName()))\n                        {\n                            return bitstream;\n                        }\n                    }\n                }\n                \n                // The bitstream was not found, so try removing a directory\n                // off of the name and see if we lost some path information.\n                int indexOfSlash = name.indexOf('/');\n                \n                if (indexOfSlash < 0)\n                {\n                    // No more directories to remove from the path, so return null for no\n                    // bitstream found.\n                    return null;\n                }\n               \n                name = name.substring(indexOfSlash+1);\n                \n                // If this is our next to last time through the loop then\n                // trim everything and only use the trailing filename.\n                if (i == maxDepthPathSearch-1)\n                {\n                        int indexOfLastSlash = name.lastIndexOf('/');\n                        if (indexOfLastSlash > -1)\n                        {\n                            name = name.substring(indexOfLastSlash + 1);\n                        }\n                }\n                \n        }\n        \n        // The named bitstream was not found and we exhausted the maximum path depth that\n        // we search.\n        return null;\n    }\n    \n    \n    /**\n         * Write the actual data out to the response.\n         *\n         * Some implementation notes:\n         *\n         * 1) We set a short expiration time just in the hopes of preventing someone\n         * from overloading the server by clicking reload a bunch of times. I\n         * Realize that this is nowhere near 100% effective but it may help in some\n         * cases and shouldn't hurt anything.\n         *\n         * 2) We accept partial downloads, thus if you lose a connection halfway\n         * through most web browser will enable you to resume downloading the\n         * bitstream.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n         */\n    @Override\n    public void generate() throws IOException, SAXException,\n            ProcessingException\n    {\n        if (this.bitstreamInputStream == null)\n        {\n            return;\n        }\n        \n        // Only allow If-Modified-Since protocol if request is from a spider\n        // since response headers would encourage a browser to cache results\n        // that might change with different authentication.\n        if (isSpider)\n        {\n            // Check for if-modified-since header -- ONLY if not authenticated\n            long modSince = request.getDateHeader(\"If-Modified-Since\");\n            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince)\n            {\n                // Item has not been modified since requested date,\n                // hence bitstream has not been, either; return 304\n                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n        }\n\n        // Only set Last-Modified: header for spiders or anonymous\n        // access, since it might encourage browse to cache the result\n        // which might leave a result only available to authenticated\n        // users in the cache for a response later to anonymous user.\n        try\n        {\n            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null))\n            {\n                // TODO:  Currently just borrow the date of the item, since\n                // we don't have last-mod dates for Bitstreams\n                response.setDateHeader(\"Last-Modified\", itemLastModified.getTime());\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new ProcessingException(e);\n        }\n\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int length = -1;\n\n        // Only encourage caching if this is not a restricted resource, i.e.\n        // if it is accessed anonymously or is readable by Anonymous:\n        if (isAnonymouslyReadable)\n        {\n            response.setDateHeader(\"Expires\", System.currentTimeMillis() + expires);\n        }\n        \n        // If this is a large bitstream then tell the browser it should treat it as a download.\n        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.content_disposition_threshold\");\n        if (bitstreamSize > threshold && threshold != 0)\n        {\n                String name  = bitstreamName;\n                \n                // Try and make the download file name formatted for each browser.\n                try {\n                        String agent = request.getHeader(\"USER-AGENT\");\n                        if (agent != null && agent.contains(\"MSIE\"))\n                        {\n                            name = URLEncoder.encode(name, \"UTF8\");\n                        }\n                        else if (agent != null && agent.contains(\"Mozilla\"))\n                        {\n                            name = MimeUtility.encodeText(name, \"UTF8\", \"B\");\n                        }\n                }\n                catch (UnsupportedEncodingException see)\n                {\n                        // do nothing\n                }\n                response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + '\"' + name + '\"');\n        }\n\n        ByteRange byteRange = null;\n\n        // Turn off partial downloads, they cause problems\n        // and are only rarely used. Specifically some windows pdf\n        // viewers are incapable of handling this request. You can\n        // uncomment the following lines to turn this feature back on.\n/*\n    response.setHeader(\"Accept-Ranges\", \"bytes\");\n        String ranges = request.getHeader(\"Range\");\n        if (ranges != null)\n        {\n            try\n            {\n                ranges = ranges.substring(ranges.indexOf('=') + 1);\n                byteRange = new ByteRange(ranges);\n            }\n            catch (NumberFormatException e)\n            {\n                byteRange = null;\n                if (response instanceof HttpResponse)\n                {\n                    // Respond with status 416 (Request range not\n                    // satisfiable)\n                    response.setStatus(416);\n                }\n            }\n        }*/\n\n        try\n        {\n            if (byteRange != null)\n            {\n                String entityLength;\n                String entityRange;\n\t\tByteRange requestedRange=null; //VT\n                if (this.bitstreamSize != -1)\n                {\n                    entityLength = \"\" + this.bitstreamSize;\n                   //VT entityRange = byteRange.intersection(\n                   //VT        new ByteRange(0, this.bitstreamSize)).toString();\n\t\t\trequestedRange = byteRange.intersection(\n                        new ByteRange(0, this.bitstreamSize - 1));\n                    \tentityRange = requestedRange.toString();\n                }\n                else\n                {\n                    entityLength = \"*\";\n                    entityRange = byteRange.toString();\n                }\n\n                response.setHeader(\"Content-Range\", entityRange + \"/\" + entityLength);\n                if (response instanceof HttpResponse)\n                {\n                    // Response with status 206 (Partial content)\n                    response.setStatus(206);\n                }\n\n                int pos = 0;\n                int posEnd;\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    posEnd = pos + length - 1;\n                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));\n                    if (intersection != null)\n                    {\n                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());\n                    }\n                    pos += length;\n                }\n            }\n            else\n            {\n                response.setHeader(\"Content-Length\", String.valueOf(this.bitstreamSize));\n\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    out.write(buffer, 0, length);\n                }\n                out.flush();\n            }\n        }\n        finally\n        {\n            try\n            {\n                // Close the bitstream input stream so that we don't leak a file descriptor\n                this.bitstreamInputStream.close();\n                \n                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html\n                out.close();\n            } \n            catch (IOException ioe)\n            {\n                // Closing the stream threw an IOException but do we want this to propagate up to Cocoon?\n                // No point since the user has already got the bitstream contents.\n                log.warn(\"Caught IO exception when closing a stream: \" + ioe.getMessage());\n            }\n        }\n\n    }\n\n    /**\n     * Returns the mime-type of the bitstream.\n     * @return the type.\n     */\n    @Override\n    public String getMimeType()\n    {\n        return this.bitstreamMimeType;\n    }\n    \n    /**\n         * Recycle\n         */\n    @Override\n    public void recycle() {\n        this.response = null;\n        this.request = null;\n        this.bitstreamInputStream = null;\n        this.bitstreamSize = 0;\n        this.bitstreamMimeType = null;\n        this.bitstreamName = null;\n        this.itemLastModified = null;\n        this.tempFile = null;\n        super.recycle();\n    }\n\n\n}", "class_id": 0, "repo": "sunakshitejwani/testOER", "file": "dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/BitstreamReader.java", "last_update_at": "2021-02-13T18:35:31+00:00", "question_id": "b08a80f53c729d0b170df6c3806811715adb16ff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BitstreamReader extends AbstractReader implements Recyclable\n{\n    private static Logger log = Logger.getLogger(BitstreamReader.class);\n    /**\n     * Messages to be sent when the user is not authorized to view\n     * a particular bitstream. They will be redirected to the login\n     * where this message will be displayed.\n     */\n    private static final String AUTH_REQUIRED_HEADER = \"xmlui.BitstreamReader.auth_header\";\n    private static final String AUTH_REQUIRED_MESSAGE = \"xmlui.BitstreamReader.auth_message\";\n    /**\n     * How big a buffer should we use when reading from the bitstream before\n     * writing to the HTTP response?\n     */\n    protected static final int BUFFER_SIZE = 8192;\n    /**\n     * When should a bitstream expire in milliseconds. This should be set to\n     * some low value just to prevent someone hiting DSpace repeatedy from\n     * killing the server. Note: there are 1000 milliseconds in a second.\n     *\n     * Format: minutes * seconds * milliseconds\n     *  60 * 60 * 1000 == 1 hour\n     */\n    protected static final int expires = 60 * 60 * 1000;\n    /** The Cocoon response */\n    protected Response response;\n    /** The Cocoon request */\n    protected Request request;\n    /** The bitstream file */\n    protected InputStream bitstreamInputStream;\n    /** The bitstream's reported size */\n    protected long bitstreamSize;\n    /** The bitstream's mime-type */\n    protected String bitstreamMimeType;\n    /** The bitstream's name */\n    protected String bitstreamName;\n    /** True if bitstream is readable by anonymous users */\n    protected boolean isAnonymouslyReadable;\n    /** The last modified date of the item containing the bitstream */\n    private Date itemLastModified = null;\n    /** True if user agent making this request was identified as spider. */\n    private boolean isSpider = false;\n    /** TEMP file for citation PDF. We will save here, so we can delete the temp file when done.  */\n    private File tempFile;\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();\n    /**\n     * Set up the bitstream reader.\n     *\n     * See the class description for information on configuration options.\n     * @param resolver source resolver.\n     * @param objectModel Cocoon object model.\n     * @param src source to read.\n     * @param par Reader parameters.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    public void setup(SourceResolver resolver, Map objectModel, String src,\n            Parameters par)\n            throws ProcessingException, SAXException, IOException\n    {\n        super.setup(resolver, objectModel, src, par);\n        try\n        {\n            this.request = ObjectModelHelper.getRequest(objectModel);\n            this.response = ObjectModelHelper.getResponse(objectModel);\n            Item item = null;\n            // Check to see if a context already exists or not. We may\n            // have been aggregated into an http request by the XSL document\n            // pulling in an XML-based bitstream. In this case the context has\n            // already been created and we should leave it open because the\n            // normal processes will close it.\n            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);\n            Context context = ContextUtil.obtainContext(objectModel);\n            // Get our parameters that identify the bitstream\n            String itemID = par.getParameter(\"itemID\", null);\n            String bitstreamID = par.getParameter(\"bitstreamID\", null);\n            String handle = par.getParameter(\"handle\", null);\n            int sequence = par.getParameterAsInteger(\"sequence\", -1);\n            String name = par.getParameter(\"name\", null);\n            this.isSpider = par.getParameter(\"userAgent\", \"\").equals(\"spider\");\n            // Resolve the bitstream\n            Bitstream bitstream = null;\n            DSpaceObject dso = null;\n            if (bitstreamID != null)\n            {\n                // Direct reference to the individual bitstream ID.\n                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);\n            }\n            else if (itemID != null)\n            {\n                // Referenced by internal itemID\n                item = itemService.findByIdOrLegacyId(context, itemID);\n                if (sequence > -1)\n                {\n                        bitstream = findBitstreamBySequence(item, sequence);\n                }\n                else if (name != null)\n                {\n                        bitstream = findBitstreamByName(item, name);\n                }\n            }\n            else if (handle != null)\n            {\n                // Reference by an item's handle.\n                dso = handleService.resolveToObject(context, handle);\n                if (dso instanceof Item)\n                {\n                    item = (Item)dso;\n                    if (sequence > -1)\n                    {\n                        bitstream = findBitstreamBySequence(item,sequence);\n                    }\n                    else if (name != null)\n                    {\n                        bitstream = findBitstreamByName(item,name);\n                    }\n                }\n            }\n            if (item != null) {\n                itemLastModified = item.getLastModified();\n            }\n            // if initial search was by sequence number and found nothing,\n            // then try to find bitstream by name (assuming we have a file name)\n            if((sequence > -1 && bitstream==null) && name!=null)\n            {\n                bitstream = findBitstreamByName(item,name);\n                // if we found bitstream by name, send a redirect to its new sequence number location\n                if(bitstream!=null)\n                {\n                    String redirectURL = \"\";\n                    // build redirect URL based on whether item has a handle assigned yet\n                    if(item.getHandle()!=null && item.getHandle().length()>0)\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/handle/\" + item.getHandle();\n                    }\n                    else\n                    {\n                        redirectURL = request.getContextPath() + \"/bitstream/item/\" + item.getID();\n                    }\n                        redirectURL += \"/\" + name + \"?sequence=\" + bitstream.getSequenceID();\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redirectURL);\n                        return;\n                }\n            }\n            // Was a bitstream found?\n            if (bitstream == null)\n            {\n                throw new ResourceNotFoundException(\"Unable to locate bitstream\");\n            }\n            // Is there a User logged in and does the user have access to read it?\n            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);\n            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context))\n            {\n                isAuthorized = false;\n                log.info(LogManager.getHeader(context, \"view_bitstream\", \"handle=\" + item.getHandle() + \",withdrawn=true\"));\n            }\n            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request  \n            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\");\n            if (!isAuthorized)\n            {\n                if(context.getCurrentUser() != null || StringUtils.equalsIgnoreCase(\"all\", requestItemType)){\n                        // A user is logged in, but they are not authorized to read this bitstream,\n                        // instead of asking them to login again we'll point them to a friendly error\n                        // message that tells them the bitstream is restricted.\n                        String redictURL = request.getContextPath() + \"/handle/\";\n                        if (item!=null){\n                                redictURL += item.getHandle();\n                        }\n                        else if(dso!=null){\n                                redictURL += dso.getHandle();\n                        }\n                        redictURL += \"/restricted-resource?bitstreamId=\" + bitstream.getID();\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                }\n                else{\n                \tif(StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\")) ||\n                \t\t\t                \t\t\tDSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\").equalsIgnoreCase(\"logged\")){\n                        // The user does not have read access to this bitstream. Interrupt this current request\n                        // and then forward them to the login page so that they can be authenticated. Once that is\n                        // successful, their request will be resumed.\n                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);\n                        // Redirect\n                        String redictURL = request.getContextPath() + \"/login\";\n                        HttpServletResponse httpResponse = (HttpServletResponse)\n                        objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                \t}\n                }\n            }\n            // Success, bitstream found and the user has access to read it.\n            // Store these for later retrieval:\n            // Intercepting views to the original bitstream to instead show a citation altered version of the object\n            // We need to check if this resource falls under the \"show watermarked alternative\" umbrella.\n            // At which time we will not return the \"bitstream\", but will instead on-the-fly generate the citation rendition.\n            // What will trigger a redirect/intercept?\n            // 1) Intercepting Enabled\n            // 2) This User is not an admin\n            // 3) This object is citation-able\n            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {\n                // on-the-fly citation generator\n                log.info(item.getHandle() + \" - \" + bitstream.getName() + \" is citable.\");\n                FileInputStream fileInputStream = null;\n                try {\n                    //Create the cited document\n                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);\n                    if(tempFile == null) {\n                        log.error(\"CitedDocument was null\");\n                    } else {\n                        log.info(\"CitedDocument was ok,\" + tempFile.getAbsolutePath());\n                    }\n                    fileInputStream = new FileInputStream(tempFile);\n                    if(fileInputStream == null) {\n                        log.error(\"Error opening fileInputStream: \");\n                    }\n                    this.bitstreamInputStream = fileInputStream;\n                    this.bitstreamSize = tempFile.length();\n                } catch (Exception e) {\n                    log.error(\"Caught an error with intercepting the citation document:\" + e.getMessage());\n                }\n                //End of CitationDocument\n            } else {\n                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);\n                this.bitstreamSize = bitstream.getSize();\n            }\n            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();\n            this.bitstreamName = bitstream.getName();\n            if (context.getCurrentUser() == null)\n            {\n                this.isAnonymouslyReadable = true;\n            }\n            else\n            {\n                this.isAnonymouslyReadable = false;\n                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ))\n                {\n                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS))\n                    {\n                        this.isAnonymouslyReadable = true;\n                    }\n                }\n            }\n            // Trim any path information from the bitstream\n            if (bitstreamName != null && bitstreamName.length() >0 )\n            {\n                        int finalSlashIndex = bitstreamName.lastIndexOf('/');\n                        if (finalSlashIndex > 0)\n                        {\n                                bitstreamName = bitstreamName.substring(finalSlashIndex+1);\n                        }\n            }\n            else\n            {\n                // In-case there is no bitstream name...\n                if(name != null && name.length() > 0) {\n                    bitstreamName = name;\n                    if(name.endsWith(\".jpg\")) {\n                        bitstreamMimeType = \"image/jpeg\";\n                    } else if(name.endsWith(\".png\")) {\n                        bitstreamMimeType = \"image/png\";\n                    }\n                } else {\n                    bitstreamName = \"bitstream\";\n                }\n            }\n            // Log that the bitstream has been viewed, this is non-cached and the complexity\n            // of adding it to the sitemap for every possible bitstream uri is not very tractable\n            DSpaceServicesFactory.getInstance().getEventService().fireEvent(\n                                new UsageEvent(\n                                                UsageEvent.Action.VIEW,\n                                                ObjectModelHelper.getRequest(objectModel),\n                                                ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),\n                                                bitstream));\n            // If we created the database connection close it, otherwise leave it open.\n            if (BitstreamReaderOpenedContext)\n            \tcontext.complete();\n        }\n        catch (SQLException sqle)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",sqle);\n        }\n        catch (AuthorizeException ae)\n        {\n            throw new ProcessingException(\"Unable to read bitstream.\",ae);\n        }\n    }\n    /**\n     * Find the bitstream identified by a sequence number on this item.\n     *\n     * @param item A DSpace item\n     * @param sequence The sequence of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException\n    {\n        if (item == null)\n        {\n            return null;\n        }\n        List<Bundle> bundles = item.getBundles();\n        for (Bundle bundle : bundles)\n        {\n            List<Bitstream> bitstreams = bundle.getBitstreams();\n            for (Bitstream bitstream : bitstreams)\n            {\n                if (bitstream.getSequenceID() == sequence)\n                {\n                    return bitstream;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Return the bitstream from the given item that is identified by the\n     * given name. If the name has prepended directories they will be removed\n     * one at a time until a bitstream is found. Note that if two bitstreams\n     * have the same name then the first bitstream will be returned.\n     *\n     * @param item A DSpace item\n     * @param name The name of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamByName(Item item, String name) throws SQLException\n    {\n        if (name == null || item == null)\n        {\n            return null;\n        }\n        // Determine our the maximum number of directories that will be removed for a path.\n        int maxDepthPathSearch = 3;\n        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"xmlui.html.max-depth-guess\") != null)\n        {\n            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.html.max-depth-guess\");\n        }\n        // Search for the named bitstream on this item. Each time through the loop\n        // a directory is removed from the name until either our maximum depth is\n        // reached or the bitstream is found. Note: an extra pass is added on to the\n        // loop for a last ditch effort where all directory paths will be removed.\n        for (int i = 0; i < maxDepthPathSearch+1; i++)\n        {\n                // Search through all the bitstreams and see\n                // if the name can be found\n                List<Bundle> bundles = item.getBundles();\n                for (Bundle bundle : bundles)\n                {\n                    List<Bitstream> bitstreams = bundle.getBitstreams();\n                    for (Bitstream bitstream : bitstreams)\n                    {\n                        if (name.equals(bitstream.getName()))\n                        {\n                            return bitstream;\n                        }\n                    }\n                }\n                // The bitstream was not found, so try removing a directory\n                // off of the name and see if we lost some path information.\n                int indexOfSlash = name.indexOf('/');\n                if (indexOfSlash < 0)\n                {\n                    // No more directories to remove from the path, so return null for no\n                    // bitstream found.\n                    return null;\n                }\n                name = name.substring(indexOfSlash+1);\n                // If this is our next to last time through the loop then\n                // trim everything and only use the trailing filename.\n                if (i == maxDepthPathSearch-1)\n                {\n                        int indexOfLastSlash = name.lastIndexOf('/');\n                        if (indexOfLastSlash > -1)\n                        {\n                            name = name.substring(indexOfLastSlash + 1);\n                        }\n                }\n        }\n        // The named bitstream was not found and we exhausted the maximum path depth that\n        // we search.\n        return null;\n    }\n    /**\n         * Write the actual data out to the response.\n         *\n         * Some implementation notes:\n         *\n         * 1) We set a short expiration time just in the hopes of preventing someone\n         * from overloading the server by clicking reload a bunch of times. I\n         * Realize that this is nowhere near 100% effective but it may help in some\n         * cases and shouldn't hurt anything.\n         *\n         * 2) We accept partial downloads, thus if you lose a connection halfway\n         * through most web browser will enable you to resume downloading the\n         * bitstream.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n         */\n    @Override\n    public void generate() throws IOException, SAXException,\n            ProcessingException\n    {\n        if (this.bitstreamInputStream == null)\n        {\n            return;\n        }\n        // Only allow If-Modified-Since protocol if request is from a spider\n        // since response headers would encourage a browser to cache results\n        // that might change with different authentication.\n        if (isSpider)\n        {\n            // Check for if-modified-since header -- ONLY if not authenticated\n            long modSince = request.getDateHeader(\"If-Modified-Since\");\n            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince)\n            {\n                // Item has not been modified since requested date,\n                // hence bitstream has not been, either; return 304\n                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n        }\n        // Only set Last-Modified: header for spiders or anonymous\n        // access, since it might encourage browse to cache the result\n        // which might leave a result only available to authenticated\n        // users in the cache for a response later to anonymous user.\n        try\n        {\n            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null))\n            {\n                // TODO:  Currently just borrow the date of the item, since\n                // we don't have last-mod dates for Bitstreams\n                response.setDateHeader(\"Last-Modified\", itemLastModified.getTime());\n            }\n        }\n        catch (SQLException e)\n        {\n            throw new ProcessingException(e);\n        }\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int length = -1;\n        // Only encourage caching if this is not a restricted resource, i.e.\n        // if it is accessed anonymously or is readable by Anonymous:\n        if (isAnonymouslyReadable)\n        {\n            response.setDateHeader(\"Expires\", System.currentTimeMillis() + expires);\n        }\n        // If this is a large bitstream then tell the browser it should treat it as a download.\n        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.content_disposition_threshold\");\n        if (bitstreamSize > threshold && threshold != 0)\n        {\n                String name  = bitstreamName;\n                // Try and make the download file name formatted for each browser.\n                try {\n                        String agent = request.getHeader(\"USER-AGENT\");\n                        if (agent != null && agent.contains(\"MSIE\"))\n                        {\n                            name = URLEncoder.encode(name, \"UTF8\");\n                        }\n                        else if (agent != null && agent.contains(\"Mozilla\"))\n                        {\n                            name = MimeUtility.encodeText(name, \"UTF8\", \"B\");\n                        }\n                }\n                catch (UnsupportedEncodingException see)\n                {\n                        // do nothing\n                }\n                response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + '\"' + name + '\"');\n        }\n        ByteRange byteRange = null;\n        // Turn off partial downloads, they cause problems\n        // and are only rarely used. Specifically some windows pdf\n        // viewers are incapable of handling this request. You can\n        // uncomment the following lines to turn this feature back on.\n/*\n    response.setHeader(\"Accept-Ranges\", \"bytes\");\n        String ranges = request.getHeader(\"Range\");\n        if (ranges != null)\n        {\n            try\n            {\n                ranges = ranges.substring(ranges.indexOf('=') + 1);\n                byteRange = new ByteRange(ranges);\n            }\n            catch (NumberFormatException e)\n            {\n                byteRange = null;\n                if (response instanceof HttpResponse)\n                {\n                    // Respond with status 416 (Request range not\n                    // satisfiable)\n                    response.setStatus(416);\n                }\n            }\n        }*/\n        try\n        {\n            if (byteRange != null)\n            {\n                String entityLength;\n                String entityRange;\n\t\tByteRange requestedRange=null; //VT\n                if (this.bitstreamSize != -1)\n                {\n                    entityLength = \"\" + this.bitstreamSize;\n                   //VT entityRange = byteRange.intersection(\n                   //VT        new ByteRange(0, this.bitstreamSize)).toString();\n\t\t\trequestedRange = byteRange.intersection(\n                        new ByteRange(0, this.bitstreamSize - 1));\n                    \tentityRange = requestedRange.toString();\n                }\n                else\n                {\n                    entityLength = \"*\";\n                    entityRange = byteRange.toString();\n                }\n                response.setHeader(\"Content-Range\", entityRange + \"/\" + entityLength);\n                if (response instanceof HttpResponse)\n                {\n                    // Response with status 206 (Partial content)\n                    response.setStatus(206);\n                }\n                int pos = 0;\n                int posEnd;\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    posEnd = pos + length - 1;\n                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));\n                    if (intersection != null)\n                    {\n                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());\n                    }\n                    pos += length;\n                }\n            }\n            else\n            {\n                response.setHeader(\"Content-Length\", String.valueOf(this.bitstreamSize));\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1)\n                {\n                    out.write(buffer, 0, length);\n                }\n                out.flush();\n            }\n        }\n        finally\n        {\n            try\n            {\n                // Close the bitstream input stream so that we don't leak a file descriptor\n                this.bitstreamInputStream.close();\n                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html\n                out.close();\n            } \n            catch (IOException ioe)\n            {\n                // Closing the stream threw an IOException but do we want this to propagate up to Cocoon?\n                // No point since the user has already got the bitstream contents.\n                log.warn(\"Caught IO exception when closing a stream: \" + ioe.getMessage());\n            }\n        }\n    }\n    /**\n     * Returns the mime-type of the bitstream.\n     * @return the type.\n     */\n    @Override\n    public String getMimeType()\n    {\n        return this.bitstreamMimeType;\n    }\n    /**\n         * Recycle\n         */\n    @Override\n    public void recycle() {\n        this.response = null;\n        this.request = null;\n        this.bitstreamInputStream = null;\n        this.bitstreamSize = 0;\n        this.bitstreamMimeType = null;\n        this.bitstreamName = null;\n        this.itemLastModified = null;\n        this.tempFile = null;\n        super.recycle();\n    }\n"]]}
{"hexsha": "9070530deb7f6fef01876b2859a32446ef3c2a06", "ext": "java", "lang": "Java", "content": "@NativeTag\n@Execution(ExecutionMode.SAME_THREAD)\npublic class InfNanTests extends BaseNd4jTestWithBackends {\n\n\n    @BeforeEach\n    public void setUp() {\n       Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n               .checkForINF(true)\n               .checkForNAN(true)\n               .build());\n    }\n\n    @AfterEach\n    public void cleanUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf3(Nd4jBackend backend) {\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NaN);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForINF(true)\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n\n            x.putScalar(2, Float.NaN);\n\n            OpExecutionerUtil.checkForAny(x);\n        });\n\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN3(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .checkForINF(true)\n                .checkForNAN(true)\n                .build());\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .build());\n        INDArray x = Nd4j.create(100);\n\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n}", "class_id": 0, "repo": "showkawa/deeplearning4j", "file": "nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/profiling/InfNanTests.java", "last_update_at": "2021-09-01T06:59:10+00:00", "question_id": "9070530deb7f6fef01876b2859a32446ef3c2a06", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@NativeTag\n@Execution(ExecutionMode.SAME_THREAD)\npublic class InfNanTests extends BaseNd4jTestWithBackends {\n    @BeforeEach\n    public void setUp() {\n       Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n               .checkForINF(true)\n               .checkForNAN(true)\n               .build());\n    }\n    @AfterEach\n    public void cleanUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .checkForINF(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf3(Nd4jBackend backend) {\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class,() -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                    .checkForINF(true)\n                    .checkForNAN(true)\n                    .build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN3(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .checkForINF(true)\n                .checkForNAN(true)\n                .build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()\n                .build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n"]]}
{"hexsha": "0bdccbde2f8923091380e6547b9a7dcaa1198eba", "ext": "java", "lang": "Java", "content": "public class GooOverlayRenderer\n{\n    private static final String[] NUM_SUFFIXES = new String[]{\"\", \"k\", \"m\", \"b\", \"t\"};\n    private static final int MAX_LENGTH = 4;\n    private static final Minecraft CLIENT = Minecraft.getInstance();\n\n    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {\n        if (!stack.isEmpty() && stack.getAmount() != 1) {\n            String s = shortHandNumber(stack.getAmount());\n\n            if (stack.getAmount() < 1)\n                s = TextFormatting.RED + String.valueOf(stack.getAmount());\n\n            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);\n\n        }\n    }\n\n    private static String shortHandNumber(Number number) {\n        String shorthand = new DecimalFormat(\"##0E0\").format(number);\n        shorthand = shorthand.replaceAll(\"E[0-9]\", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);\n        while (shorthand.length() > MAX_LENGTH || shorthand.matches(\"[0-9]+\\\\.[a-z]\"))\n            shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);\n\n        return shorthand;\n    }\n\n    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {\n        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);\n\n        if (iconSprite == null)\n            return;\n\n        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());\n    }\n\n    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {\n        float f = 0.00390625F;\n        float f1 = 0.00390625F;\n        float zLevel = 0.0F;\n        Tessellator tessellator = Tessellator.getInstance();\n        BufferBuilder buffer = tessellator.getBuffer();\n        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);\n        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();\n        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();\n        tessellator.draw();\n    }\n}", "class_id": 0, "repo": "skyboy/Goo", "file": "src/main/java/com/xeno/goo/client/render/GooOverlayRenderer.java", "last_update_at": "2021-08-19T01:52:37+00:00", "question_id": "0bdccbde2f8923091380e6547b9a7dcaa1198eba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GooOverlayRenderer\n{\n    private static final String[] NUM_SUFFIXES = new String[]{\"\", \"k\", \"m\", \"b\", \"t\"};\n    private static final int MAX_LENGTH = 4;\n    private static final Minecraft CLIENT = Minecraft.getInstance();\n    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {\n        if (!stack.isEmpty() && stack.getAmount() != 1) {\n            String s = shortHandNumber(stack.getAmount());\n            if (stack.getAmount() < 1)\n                s = TextFormatting.RED + String.valueOf(stack.getAmount());\n            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);\n        }\n    }\n    private static String shortHandNumber(Number number) {\n        String shorthand = new DecimalFormat(\"##0E0\").format(number);\n        shorthand = shorthand.replaceAll(\"E[0-9]\", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);\n        while (shorthand.length() > MAX_LENGTH || shorthand.matches(\"[0-9]+\\\\.[a-z]\"))\n            shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);\n        return shorthand;\n    }\n    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {\n        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);\n        if (iconSprite == null)\n            return;\n        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());\n    }\n    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {\n        float f = 0.00390625F;\n        float f1 = 0.00390625F;\n        float zLevel = 0.0F;\n        Tessellator tessellator = Tessellator.getInstance();\n        BufferBuilder buffer = tessellator.getBuffer();\n        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);\n        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();\n        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();\n        tessellator.draw();\n    }\n"]]}
{"hexsha": "763fc82862a43e0b16eb8f74bb7a4c58704f0059", "ext": "java", "lang": "Java", "content": "public class MessageBindingsReader {\n\n    public MessageBindingsReader() {\n    }\n\n    public static MessageBindings readMessageBindings(final AnnotationScannerContext context,\n            final AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return null;\n        }\n\n        IoLogging.logger.annotationsArray(\"@MessageBindings\");\n        AnnotationInstance nested = annotationValue.asNested();\n\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));\n\n        return bindings;\n    }\n\n    public static MessageBindings readMessageBindings(final JsonNode node) {\n        if (node == null) {\n            return null;\n        }\n\n        IoLogging.logger.singleJsonNode(\"ChannelBindings\");\n\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));\n\n        return bindings;\n    }\n}", "class_id": 0, "repo": "openknowledge/smallrye-async-api", "file": "core/src/main/java/io/smallrye/asyncapi/core/runtime/io/bindings/MessageBindingsReader.java", "last_update_at": "2021-02-12T10:51:20+00:00", "question_id": "763fc82862a43e0b16eb8f74bb7a4c58704f0059", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageBindingsReader {\n    public MessageBindingsReader() {\n    }\n    public static MessageBindings readMessageBindings(final AnnotationScannerContext context,\n            final AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return null;\n        }\n        IoLogging.logger.annotationsArray(\"@MessageBindings\");\n        AnnotationInstance nested = annotationValue.asNested();\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n    public static MessageBindings readMessageBindings(final JsonNode node) {\n        if (node == null) {\n            return null;\n        }\n        IoLogging.logger.singleJsonNode(\"ChannelBindings\");\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(\n                AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(\n                HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(\n                KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(\n                MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n"]]}
{"hexsha": "4d76de705259e8969c3567afa2dc3811eff12574", "ext": "java", "lang": "Java", "content": "@Service\npublic class IssueServiceImpl implements IssueService {\n\n\n    private final IssueRepository issueRepository;\n    private final LabelRepository labelRepository;\n    private final UserRepository userRepository;\n    private final ModelMapper modelMapper;\n    private final FromIssueToIssueDTO fromIssueToIssueDTO;\n    private final FromIssueDTOToIssue fromIssueDTOToIssue;\n    private final FromLabelToLabelDTO fromLabelToLabelDTO;\n    private final FromLabelDTOToLabel fromLabelDTOToLabel;\n    private final FromUserToUserDTO fromUserToUserDTO;\n    private final FromUserDTOToUser fromUserDTOToUser;\n    private final CommentService commentService;\n    private final FromCommentDTOToComment fromCommentDTOtoComment;\n\n    private final StateRepository stateRepository;\n\n    private final static String ASCENDING=\"asc\" ;\n    private final static String DESCENDING=\"desc\" ;\n    private final static String ORDER_TYPE_ERROR_MESSAGE=\" Recieved OrderType is : %s .\\nOrder Type must be asc or desc.\";\n\n\n    @Autowired\n    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper,\n                            FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue,\n                            FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService,\n                            FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {\n\n        this.issueRepository = issueRepository;\n        this.labelRepository = labelRepository;\n        this.userRepository = userRepository;\n        this.modelMapper = modelMapper;\n        this.fromIssueToIssueDTO = fromIssueToIssueDTO;\n        this.fromIssueDTOToIssue = fromIssueDTOToIssue;\n        this.fromLabelToLabelDTO = fromLabelToLabelDTO;\n        this.fromLabelDTOToLabel = fromLabelDTOToLabel;\n        this.fromUserToUserDTO = fromUserToUserDTO;\n        this.fromUserDTOToUser = fromUserDTOToUser;\n        this.commentService = commentService;\n        this.fromCommentDTOtoComment = fromCommentDTOtoComment;\n        this.stateRepository = stateRepository;\n    }\n\n    @Override\n    public IssueDTO createIssue(IssueDTO idt) {\n        Issue issue = fromIssueDTOToIssue.convert(idt);\n        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));\n        return issueDto;\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssues() {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());\n        return issueDTOList;\n    }\n\n    @Override\n    public IssueDTO findById(Long issueId) {\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(\n                issueRepository.findById(issueId)\n                        .orElseThrow(NoSuchElementException::new));\n\n        return issueDTO;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByTitleKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByDescKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlIssuesByLabel(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));\n        return issueDTOList;\n    }\n\n    @Transactional\n    @Override\n    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));\n        issue.getComments().add(addedComment);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public void deleteComment(Long issueId,Long commentId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(()->new IssueTrackerNotFoundException(\"Issue\",issueId.toString()));\n        Optional<Comment> comment=issue.getComments().stream()\n                .filter(x->x.getId()==commentId)\n                .findFirst();\n        if(comment.isPresent()){\n            issue.getComments().remove(comment.get());\n        }else{\n            throw new IssueTrackerNotFoundException(\"Comment\",commentId.toString());\n        }\n        issueRepository.save(issue);\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());\n        }\n\n    }\n\n    @Override\n    public IssueDTO updateState(Long issueId, Long stateId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        State state = stateRepository.findById(stateId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"State\", stateId.toString()));\n        issue.setState(state);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());\n        }\n\n    }\n\n    public List<IssueDTO> getAllIssuesSort( String orderType, String byWhichSort) {\n       if (byWhichSort == null) {\n            return getAllIssues();\n        }\n\n        if (byWhichSort.equalsIgnoreCase(\"createDate\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByCreateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByCreateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else if (byWhichSort.equalsIgnoreCase(\"update\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByUpdateTime(true);\n\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByUpdateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n\n        } else {\n            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n        }\n    }\n    @Override\n    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {\n\n        labelRepository.removeLabelFromIssue(labelId, issueId);\n\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n\n\n\n    @Override\n    public IssueDTO addLabel(Long labelId,Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n\n       Label label = labelRepository.findById(labelId)\n                .orElseThrow(NoSuchElementException::new);\n\n        issue.getLabels().add(label);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO editIssue(Long issueId, IssueDTO issue) {\n        Issue updatedIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n\n        modelMapper.getConfiguration().setSkipNullEnabled(true);\n        modelMapper.map(issue, updatedIssue);\n\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));\n\n        return issueDTO;\n\n    }\n\n    @Override\n    public void deleteIssue(Long issueId) {\n        issueRepository.deleteById(issueId);\n    }\n\n\n    @Override\n    public void deleteSelectedIssues(List<Long> selectedIssueIds) {\n        for (Long id : selectedIssueIds) {\n            deleteIssue(id);\n        }\n    }\n\n    @Override\n    public IssueDTO addAssignee(Long userId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n\n        User user = userRepository.findById(userId)\n                .orElseThrow(NoSuchElementException::new);\n\n        issue.getAssignees().add(user);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {\n\n        userRepository.removeAssigneeFromIssue(userId, issueId);\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n}", "class_id": 0, "repo": "SuzanGencer/issue-tracker-2020-2", "file": "backend/issue-tracker/src/main/java/com/kodstar/issuetracker/service/impl/IssueServiceImpl.java", "last_update_at": "2021-04-06T13:05:56+00:00", "question_id": "4d76de705259e8969c3567afa2dc3811eff12574", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class IssueServiceImpl implements IssueService {\n    private final IssueRepository issueRepository;\n    private final LabelRepository labelRepository;\n    private final UserRepository userRepository;\n    private final ModelMapper modelMapper;\n    private final FromIssueToIssueDTO fromIssueToIssueDTO;\n    private final FromIssueDTOToIssue fromIssueDTOToIssue;\n    private final FromLabelToLabelDTO fromLabelToLabelDTO;\n    private final FromLabelDTOToLabel fromLabelDTOToLabel;\n    private final FromUserToUserDTO fromUserToUserDTO;\n    private final FromUserDTOToUser fromUserDTOToUser;\n    private final CommentService commentService;\n    private final FromCommentDTOToComment fromCommentDTOtoComment;\n    private final StateRepository stateRepository;\n    private final static String ASCENDING=\"asc\" ;\n    private final static String DESCENDING=\"desc\" ;\n    private final static String ORDER_TYPE_ERROR_MESSAGE=\" Recieved OrderType is : %s .\\nOrder Type must be asc or desc.\";\n    @Autowired\n    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper,\n                            FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue,\n                            FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService,\n                            FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {\n        this.issueRepository = issueRepository;\n        this.labelRepository = labelRepository;\n        this.userRepository = userRepository;\n        this.modelMapper = modelMapper;\n        this.fromIssueToIssueDTO = fromIssueToIssueDTO;\n        this.fromIssueDTOToIssue = fromIssueDTOToIssue;\n        this.fromLabelToLabelDTO = fromLabelToLabelDTO;\n        this.fromLabelDTOToLabel = fromLabelDTOToLabel;\n        this.fromUserToUserDTO = fromUserToUserDTO;\n        this.fromUserDTOToUser = fromUserDTOToUser;\n        this.commentService = commentService;\n        this.fromCommentDTOtoComment = fromCommentDTOtoComment;\n        this.stateRepository = stateRepository;\n    }\n    @Override\n    public IssueDTO createIssue(IssueDTO idt) {\n        Issue issue = fromIssueDTOToIssue.convert(idt);\n        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));\n        return issueDto;\n    }\n    @Override\n    public List<IssueDTO> getAllIssues() {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());\n        return issueDTOList;\n    }\n    @Override\n    public IssueDTO findById(Long issueId) {\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(\n                issueRepository.findById(issueId)\n                        .orElseThrow(NoSuchElementException::new));\n        return issueDTO;\n    }\n    @Override\n    public List<IssueDTO> findALlByTitleKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));\n        return issueDTOList;\n    }\n    @Override\n    public List<IssueDTO> findALlByDescKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));\n        return issueDTOList;\n    }\n    @Override\n    public List<IssueDTO> findALlIssuesByLabel(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));\n        return issueDTOList;\n    }\n    @Transactional\n    @Override\n    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));\n        issue.getComments().add(addedComment);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    @Override\n    public void deleteComment(Long issueId,Long commentId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(()->new IssueTrackerNotFoundException(\"Issue\",issueId.toString()));\n        Optional<Comment> comment=issue.getComments().stream()\n                .filter(x->x.getId()==commentId)\n                .findFirst();\n        if(comment.isPresent()){\n            issue.getComments().remove(comment.get());\n        }else{\n            throw new IssueTrackerNotFoundException(\"Comment\",commentId.toString());\n        }\n        issueRepository.save(issue);\n    }\n    @Override\n    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());\n        }\n    }\n    @Override\n    public IssueDTO updateState(Long issueId, Long stateId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        State state = stateRepository.findById(stateId)\n                .orElseThrow(() -> new IssueTrackerNotFoundException(\"State\", stateId.toString()));\n        issue.setState(state);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());\n        }\n    }\n    public List<IssueDTO> getAllIssuesSort( String orderType, String byWhichSort) {\n       if (byWhichSort == null) {\n            return getAllIssues();\n        }\n        if (byWhichSort.equalsIgnoreCase(\"createDate\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByCreateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByCreateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else if (byWhichSort.equalsIgnoreCase(\"update\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByUpdateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByUpdateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else {\n            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n        }\n    }\n    @Override\n    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {\n        labelRepository.removeLabelFromIssue(labelId, issueId);\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n    @Override\n    public IssueDTO addLabel(Long labelId,Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n       Label label = labelRepository.findById(labelId)\n                .orElseThrow(NoSuchElementException::new);\n        issue.getLabels().add(label);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    @Override\n    public IssueDTO editIssue(Long issueId, IssueDTO issue) {\n        Issue updatedIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        modelMapper.getConfiguration().setSkipNullEnabled(true);\n        modelMapper.map(issue, updatedIssue);\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));\n        return issueDTO;\n    }\n    @Override\n    public void deleteIssue(Long issueId) {\n        issueRepository.deleteById(issueId);\n    }\n    @Override\n    public void deleteSelectedIssues(List<Long> selectedIssueIds) {\n        for (Long id : selectedIssueIds) {\n            deleteIssue(id);\n        }\n    }\n    @Override\n    public IssueDTO addAssignee(Long userId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        User user = userRepository.findById(userId)\n                .orElseThrow(NoSuchElementException::new);\n        issue.getAssignees().add(user);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n    @Override\n    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {\n        userRepository.removeAssigneeFromIssue(userId, issueId);\n        Issue newIssue = issueRepository.findById(issueId)\n                .orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n"]]}
{"hexsha": "8443c954494c6c6baca7fbd14f3c738d5cd75922", "ext": "java", "lang": "Java", "content": "public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {\n\n    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)\n    private EventManager eventManager;\n\n    /**\n     * SubAppRuntimeManager Interface member variables.\n     */\n    List<FermatEventListener> listenersAdded = new ArrayList<>();\n\n    /**\n     * MAp of desktop identifier + runtimeDesktopObject\n     */\n\n    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();\n\n    /**\n     * Last desktop-object\n     */\n    String lastDesktopObject;\n\n    public DesktopRuntimeEnginePluginRoot() {\n        super(new PluginVersionReference(new Version()));\n    }\n\n\n    @Override\n    public void start() throws CantStartPluginException {\n        try {\n            /**\n             * I will initialize the handling of com.bitdubai.platform events.\n             */\n\n            /**\n             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add\n             * functionality based on wallets downloaded by users this wont be an option.\n             * * *\n             */\n            factoryReset();\n\n            this.serviceStatus = ServiceStatus.STARTED;\n        } catch (CantFactoryResetException ex) {\n            String message = CantStartPluginException.DEFAULT_MESSAGE;\n            FermatException cause = ex;\n            String context = \"App Runtime Start\";\n            String possibleReason = \"Some null definition\";\n            throw new CantStartPluginException(message, cause, context, possibleReason);\n        } catch (Exception exception) {\n            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, \"Unchecked Exception occurred, check the cause\");\n        }\n    }\n\n    @Override\n    public void stop() {\n        /**\n         * I will remove all the listeners registered with the event manager. \n         */\n        for (FermatEventListener eventListener : listenersAdded) {\n            eventManager.removeListener(eventListener);\n        }\n\n        listenersAdded.clear();\n\n        this.serviceStatus = ServiceStatus.STOPPED;\n\n    }\n\n    /**\n     * AppRuntime Interface implementation.\n     */\n    @Override\n    public DesktopObject getLastDesktopObject() {\n        if (lastDesktopObject != null) {\n            return lstDesktops.get(0);\n        }\n        return  null;\n        //return mapDesktops.get(startDesktopObject);\n    }\n\n    @Override\n    public DesktopObject getDesktopObject(String desktopObjectType) {\n        //DesktopObject desktopObject = mapDesktops.get(desktopObjectType);\n//        if (desktopObject != null) {\n//            lastDesktopObject = desktopObjectType;\n//            return desktopObject;\n//        }\n        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta\n        return null;\n    }\n\n    @Override\n    public List<DesktopObject> listDesktops() {\n        return lstDesktops;\n    }\n\n    /**\n     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the\n     * factory structure.\n     */\n    private void factoryReset() throws CantFactoryResetException {\n\n        //loadHomeScreen();\n\n        try {\n\n            RuntimeDesktopObject runtimeDesktopObject;// = new RuntimeDesktopObject();\n\n            Activity runtimeActivity; //= new Activity();\n            //runtimeActivity.setType(Activities.CWP_SHELL_LOGIN);\n            //runtimeSubApp.addActivity(runtimeActivity);\n\n            Fragment runtimeFragment; //= new Fragment();\n            //runtimeFragment.setType(Fragments.CWP_SHELL_LOGIN.getKey());\n            //runtimeActivity.addFragment(Fragments.CWP_SHELL_LOGIN.getKey(), runtimeFragment);\n\n            TitleBar runtimeTitleBar;\n            SideMenu runtimeSideMenu;\n            MainMenu runtimeMainMenu;\n            MenuItem runtimeMenuItem;\n            TabStrip runtimeTabStrip;\n            StatusBar statusBar;\n            Tab runtimeTab;\n\n            /**\n             * Desktop CCP\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCCP\");\n            lastDesktopObject = runtimeDesktopObject.getType();\n\n            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);\n\n            Activity activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CCPDHA\");\n            Fragment fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add WalletManager fragment\n             */\n\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CCPWMF\");\n            activity.addFragment(\"CCPWMF\",fragment);\n            runtimeDesktopObject.setStartActivity(activity.getType());\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n\n\n            lstDesktops.add(runtimeDesktopObject);\n            /**\n             * End Desktop CCP\n             */\n\n\n            /**\n             * Desktop WPD\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"WPD\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);\n\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"WPD\");\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n\n\n            /**\n             * End Desktop WPD\n             */\n\n\n            /**\n             * Desktop DAP\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DDAP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);\n\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"DAPDHA\");\n            fragment = new Fragment();\n\n            /**\n             * Add WalletManager fragment\n             */\n\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"DAPWMF\");\n            activity.addFragment(\"DAPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"DAPSAMF\");\n            activity.addFragment(\"DAPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * End Desktop DAP\n             */\n\n            /**\n             * Desktop CBP\n             */\n\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCBP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);\n\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CBPDHA\");\n            fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add WalletManager fragment\n             */\n\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CBPWMF\");\n            activity.addFragment(\"CBPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * Add home subApps fragment\n             */\n\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CBPSAMF\");\n            activity.addFragment(\"CBPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n\n            /**\n             * End Desktop CBP\n             */\n\n\n        } catch (Exception e) {\n            String message = CantFactoryResetException.DEFAULT_MESSAGE;\n            FermatException cause = FermatException.wrapException(e);\n            String context = \"Error on method Factory Reset, setting the structure of the apps\";\n            String possibleReason = \"some null definition\";\n            throw new CantFactoryResetException(message, cause, context, possibleReason);\n\n        }\n\n    }\n\n\n\n}", "class_id": 0, "repo": "nattyco/fermatold", "file": "PIP/plugin/engine/fermat-pip-plugin-engine-desktop-runtime-bitdubai/src/main/java/com/bitdubai/fermat_pip_plugin/layer/engine/desktop_runtime/developer/bitdubai/version_1/DesktopRuntimeEnginePluginRoot.java", "last_update_at": "2021-08-15T20:32:35+00:00", "question_id": "8443c954494c6c6baca7fbd14f3c738d5cd75922", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {\n    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)\n    private EventManager eventManager;\n    /**\n     * SubAppRuntimeManager Interface member variables.\n     */\n    List<FermatEventListener> listenersAdded = new ArrayList<>();\n    /**\n     * MAp of desktop identifier + runtimeDesktopObject\n     */\n    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();\n    /**\n     * Last desktop-object\n     */\n    String lastDesktopObject;\n    public DesktopRuntimeEnginePluginRoot() {\n        super(new PluginVersionReference(new Version()));\n    }\n    @Override\n    public void start() throws CantStartPluginException {\n        try {\n            /**\n             * I will initialize the handling of com.bitdubai.platform events.\n             */\n            /**\n             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add\n             * functionality based on wallets downloaded by users this wont be an option.\n             * * *\n             */\n            factoryReset();\n            this.serviceStatus = ServiceStatus.STARTED;\n        } catch (CantFactoryResetException ex) {\n            String message = CantStartPluginException.DEFAULT_MESSAGE;\n            FermatException cause = ex;\n            String context = \"App Runtime Start\";\n            String possibleReason = \"Some null definition\";\n            throw new CantStartPluginException(message, cause, context, possibleReason);\n        } catch (Exception exception) {\n            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, \"Unchecked Exception occurred, check the cause\");\n        }\n    }\n    @Override\n    public void stop() {\n        /**\n         * I will remove all the listeners registered with the event manager. \n         */\n        for (FermatEventListener eventListener : listenersAdded) {\n            eventManager.removeListener(eventListener);\n        }\n        listenersAdded.clear();\n        this.serviceStatus = ServiceStatus.STOPPED;\n    }\n    /**\n     * AppRuntime Interface implementation.\n     */\n    @Override\n    public DesktopObject getLastDesktopObject() {\n        if (lastDesktopObject != null) {\n            return lstDesktops.get(0);\n        }\n        return  null;\n        //return mapDesktops.get(startDesktopObject);\n    }\n    @Override\n    public DesktopObject getDesktopObject(String desktopObjectType) {\n        //DesktopObject desktopObject = mapDesktops.get(desktopObjectType);\n//        if (desktopObject != null) {\n//            lastDesktopObject = desktopObjectType;\n//            return desktopObject;\n//        }\n        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta\n        return null;\n    }\n    @Override\n    public List<DesktopObject> listDesktops() {\n        return lstDesktops;\n    }\n    /**\n     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the\n     * factory structure.\n     */\n    private void factoryReset() throws CantFactoryResetException {\n        //loadHomeScreen();\n        try {\n            RuntimeDesktopObject runtimeDesktopObject;// = new RuntimeDesktopObject();\n            Activity runtimeActivity; //= new Activity();\n            //runtimeActivity.setType(Activities.CWP_SHELL_LOGIN);\n            //runtimeSubApp.addActivity(runtimeActivity);\n            Fragment runtimeFragment; //= new Fragment();\n            //runtimeFragment.setType(Fragments.CWP_SHELL_LOGIN.getKey());\n            //runtimeActivity.addFragment(Fragments.CWP_SHELL_LOGIN.getKey(), runtimeFragment);\n            TitleBar runtimeTitleBar;\n            SideMenu runtimeSideMenu;\n            MainMenu runtimeMainMenu;\n            MenuItem runtimeMenuItem;\n            TabStrip runtimeTabStrip;\n            StatusBar statusBar;\n            Tab runtimeTab;\n            /**\n             * Desktop CCP\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCCP\");\n            lastDesktopObject = runtimeDesktopObject.getType();\n            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);\n            Activity activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CCPDHA\");\n            Fragment fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add WalletManager fragment\n             */\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CCPWMF\");\n            activity.addFragment(\"CCPWMF\",fragment);\n            runtimeDesktopObject.setStartActivity(activity.getType());\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            lstDesktops.add(runtimeDesktopObject);\n            /**\n             * End Desktop CCP\n             */\n            /**\n             * Desktop WPD\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"WPD\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"WPD\");\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * End Desktop WPD\n             */\n            /**\n             * Desktop DAP\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DDAP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"DAPDHA\");\n            fragment = new Fragment();\n            /**\n             * Add WalletManager fragment\n             */\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"DAPWMF\");\n            activity.addFragment(\"DAPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"DAPSAMF\");\n            activity.addFragment(\"DAPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * End Desktop DAP\n             */\n            /**\n             * Desktop CBP\n             */\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCBP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);\n            activity = new Activity();\n            /**\n             * set type home\n             */\n            //activity.setType(Activities.CWP_WALLET_MANAGER_MAIN);\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CBPDHA\");\n            fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add WalletManager fragment\n             */\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CBPWMF\");\n            activity.addFragment(\"CBPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * Add home subApps fragment\n             */\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CBPSAMF\");\n            activity.addFragment(\"CBPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            /**\n             * End Desktop CBP\n             */\n        } catch (Exception e) {\n            String message = CantFactoryResetException.DEFAULT_MESSAGE;\n            FermatException cause = FermatException.wrapException(e);\n            String context = \"Error on method Factory Reset, setting the structure of the apps\";\n            String possibleReason = \"some null definition\";\n            throw new CantFactoryResetException(message, cause, context, possibleReason);\n        }\n    }\n"]]}
{"hexsha": "a7adb9c2cd2745f6f8a868174542360456f4045b", "ext": "java", "lang": "Java", "content": "public class CPGManualTest extends CPGTestBase {\n\n    @Test\n    public void testGet() {\n\n        String location = given()\n                .post(baseUrlOfSut + \"/api/cpg/x\")\n                .then()\n                .statusCode(201)\n                .extract().header(\"location\");\n\n        int a = 42;\n        int b = 77;\n\n        location = resolveLocation(location, baseUrlOfSut + \"/api/cpg/x/{id}/y\");\n\n        given().contentType(ContentType.JSON)\n                .body(\"{\\\"a\\\":\" + a + \", \\\"b\\\":\" + b + \"}\")\n                .post(location)\n                .then()\n                .statusCode(201);\n\n        given().accept(ContentType.JSON)\n                .get(location)\n                .then()\n                .statusCode(200)\n                .body(\"a\", is(a))\n                .body(\"b\", is(b));\n    }\n}", "class_id": 0, "repo": "mitchellolsthoorn/ASE-Technical-2021-api-linkage-replication", "file": "EvoMaster/e2e-tests/spring-examples/src/test/java/org/evomaster/e2etests/spring/examples/chainedpostget/CPGManualTest.java", "last_update_at": "2021-07-15T12:44:15+00:00", "question_id": "a7adb9c2cd2745f6f8a868174542360456f4045b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CPGManualTest extends CPGTestBase {\n    @Test\n    public void testGet() {\n        String location = given()\n                .post(baseUrlOfSut + \"/api/cpg/x\")\n                .then()\n                .statusCode(201)\n                .extract().header(\"location\");\n        int a = 42;\n        int b = 77;\n        location = resolveLocation(location, baseUrlOfSut + \"/api/cpg/x/{id}/y\");\n        given().contentType(ContentType.JSON)\n                .body(\"{\\\"a\\\":\" + a + \", \\\"b\\\":\" + b + \"}\")\n                .post(location)\n                .then()\n                .statusCode(201);\n        given().accept(ContentType.JSON)\n                .get(location)\n                .then()\n                .statusCode(200)\n                .body(\"a\", is(a))\n                .body(\"b\", is(b));\n    }\n"]]}
{"hexsha": "16d5f6bd57d22f954e4f4bcebb596da796cc9164", "ext": "java", "lang": "Java", "content": "@UnitTest\npublic class MavenCodeLocationPackagerTest {\n    @Test\n    public void testParseProject() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        Dependency dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:0.0.1\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar\");\n        assertNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1:monkey\");\n        assertNull(dependency);\n    }\n\n    @Test\n    public void testParseDependency() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:0.0.1:compile\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1:test\");\n        assertNotNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar\");\n        assertNull(dependency);\n\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n    }\n\n    @Test\n    public void testIsLineRelevant() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465] stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]  stuff\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]     \"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" \"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloaded\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and thingsDownloaded stuff and things\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloading\"));\n\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and things Downloadingstuff and things\"));\n    }\n\n    @Test\n    public void testTrimLogLevel() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        String actualLine = \"\";\n        final String expectedValue = \"thing\";\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"weird garbage 3525356 [thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\" [INFO] \" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n    }\n\n    @Test\n    public void testIsProjectSection() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\" \"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"       \"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:\"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:other      stuff\"));\n\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"maven-dependency-plugin:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin garbage:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin:tree      stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree\"));\n\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"      ---       maven-dependency-plugin      :       tree\"));\n    }\n\n    @Test\n    public void testIsDependencyTreeUpdates() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"artifact com.google.guava:guava:jar:15.0:compile checking for updates from\"));\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"         artifact       com.google.guava:guava:         checking for updates\"));\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"      checking for updates   artifact       com.google.guava:guava:      \"));\n\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"checking for updates\"));\n\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"com.google.guava:guava:jar:15.0:compile\"));\n\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"+- com.google.guava:guava:jar:15.0:compile\"));\n\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"|  \\\\- com.google.guava:guava:jar:15.0:compile\"));\n    }\n\n    @Test\n    public void testIsGav() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertFalse(mavenCodeLocationPackager.isGav(\" \"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"       \"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"::::\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\" : : : : \"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact:version\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group-artifact:type-classifier-version:scope-garbage\"));\n\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact::classifier:version: :garbage\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:version\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope\"));\n\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope:garbage\"));\n    }\n\n    @Test\n    public void testIndexOfEndOfSegments() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"\"));\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\"));\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\"));\n\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n\n        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\"));\n\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\"));\n\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"and\"));\n\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testDoesLineContainSegmentsInOrder() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"\"));\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\"));\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\"));\n\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"and\"));\n\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testLineWithExtraTextAfterScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", dependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithUnknownScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", scopedDependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithBadColonPlacement() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from\", dependency.getExternalId().createExternalId());\n    }\n}", "class_id": 0, "repo": "antontroshin/synopsys-detect", "file": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/maven/unit/MavenCodeLocationPackagerTest.java", "last_update_at": "2021-01-08T16:56:35+00:00", "question_id": "16d5f6bd57d22f954e4f4bcebb596da796cc9164", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@UnitTest\npublic class MavenCodeLocationPackagerTest {\n    @Test\n    public void testParseProject() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        Dependency dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1:monkey\");\n        assertNull(dependency);\n    }\n    @Test\n    public void testParseDependency() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:0.0.1:compile\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1:test\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n    }\n    @Test\n    public void testIsLineRelevant() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465] stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]  stuff\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]     \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloaded\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and thingsDownloaded stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloading\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and things Downloadingstuff and things\"));\n    }\n    @Test\n    public void testTrimLogLevel() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        String actualLine = \"\";\n        final String expectedValue = \"thing\";\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"weird garbage 3525356 [thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\" [INFO] \" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n    }\n    @Test\n    public void testIsProjectSection() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\" \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:other      stuff\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin garbage:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"      ---       maven-dependency-plugin      :       tree\"));\n    }\n    @Test\n    public void testIsDependencyTreeUpdates() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"artifact com.google.guava:guava:jar:15.0:compile checking for updates from\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"         artifact       com.google.guava:guava:         checking for updates\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"      checking for updates   artifact       com.google.guava:guava:      \"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"checking for updates\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"+- com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"|  \\\\- com.google.guava:guava:jar:15.0:compile\"));\n    }\n    @Test\n    public void testIsGav() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isGav(\" \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"::::\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\" : : : : \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact:version\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group-artifact:type-classifier-version:scope-garbage\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact::classifier:version: :garbage\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope:garbage\"));\n    }\n    @Test\n    public void testIndexOfEndOfSegments() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\"));\n    }\n    @Test\n    public void testDoesLineContainSegmentsInOrder() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\"));\n    }\n    @Test\n    public void testLineWithExtraTextAfterScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", dependency.getExternalId().createExternalId());\n    }\n    @Test\n    public void testLineWithUnknownScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", scopedDependency.getExternalId().createExternalId());\n    }\n    @Test\n    public void testLineWithBadColonPlacement() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from\", dependency.getExternalId().createExternalId());\n    }\n"]]}
{"hexsha": "236dd9c3e3386bd6a06a244e8ea1516692f3c35d", "ext": "java", "lang": "Java", "content": "public class PluginXMLTextHover extends PDETextHover {\n\n    private PDESourcePage fSourcePage;\n\n    public  PluginXMLTextHover(PDESourcePage sourcePage) {\n        fSourcePage = sourcePage;\n    }\n\n    @Override\n    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {\n        int offset = hoverRegion.getOffset();\n        IDocumentRange range = fSourcePage.getRangeElement(offset, true);\n        if (range instanceof IDocumentTextNode)\n            return checkTranslatedValue((IDocumentTextNode) range);\n        if (!(range instanceof IPluginObject))\n            return null;\n        ISchema schema = getExtensionSchema((IPluginObject) range);\n        if (schema != null) {\n            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);\n            if (sObj == null) {\n                return null;\n            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {\n                IDocumentAttributeNode da = (IDocumentAttributeNode) range;\n                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)\n                    // inside name\n                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);\n                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)\n                    // inside value\n                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);\n            } else if (range instanceof IPluginElement) {\n                IDocumentElementNode dn = (IDocumentElementNode) range;\n                int dnOff = dn.getOffset();\n                int dnLen = dn.getLength();\n                String dnName = dn.getXMLTagName();\n                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())\n                    // inside opening tag\n                    return getElementText((ISchemaElement) sObj);\n                try {\n                    String nt = textViewer.getDocument().get(dnOff, dnLen);\n                    if (nt.endsWith(//$NON-NLS-1$\n                    \"</\" + dnName + //$NON-NLS-1$\n                    '>')) {\n                        offset = offset - dnOff;\n                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)\n                            // inside closing tag\n                            return getElementText((ISchemaElement) sObj);\n                    }\n                } catch (BadLocationException e) {\n                }\n            }\n        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)\n            return getExtensionPointHoverInfo((IPluginObject) range, offset);\n        return null;\n    }\n\n    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {\n        IDocumentAttributeNode da = (IDocumentAttributeNode) object;\n        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {\n            String value = da.getAttributeValue();\n            if (//$NON-NLS-1$\n            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith(\"%\"))\n                return object.getResourceString(value);\n        }\n        return null;\n    }\n\n    private ISchema getExtensionSchema(IPluginObject object) {\n        IPluginObject extension = object;\n        if (object instanceof IDocumentAttributeNode)\n            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();\n        while (extension != null && !(extension instanceof IPluginExtension)) extension = extension.getParent();\n        if (extension == null)\n            // started off outside of an extension element\n            return null;\n        String point = ((IPluginExtension) extension).getPoint();\n        return PDECore.getDefault().getSchemaRegistry().getSchema(point);\n    }\n\n    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {\n        if (object instanceof IPluginElement)\n            return schema.findElement(((IPluginElement) object).getName());\n        if (object instanceof IPluginExtension)\n            //$NON-NLS-1$\n            return schema.findElement(\"extension\");\n        if (object instanceof IDocumentAttributeNode)\n            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());\n        return null;\n    }\n\n    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        return sAtt.getDescription();\n    }\n\n    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {\n        if (//$NON-NLS-1$\n        sEle.getName().equals(\"extension\") && attrib.getName().equals(IPluginExtension.P_POINT))\n            return getSchemaDescription(attrib, sEle);\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        String value = attrib.getValue();\n        if (//$NON-NLS-1$\n        sAtt.isTranslatable() && value.startsWith(\"%\"))\n            return attrib.getResourceString(value);\n        return null;\n    }\n\n    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {\n        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        if (description == null) {\n            URL url = sEle.getSchema().getURL();\n            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();\n            SchemaUtil.parseURL(url, handler);\n            description = handler.getDescription();\n            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        }\n        return description;\n    }\n\n    private String getElementText(ISchemaElement sEle) {\n        if (sEle == null) {\n            return null;\n        }\n        return sEle.getDescription();\n    }\n\n    private String checkTranslatedValue(IDocumentTextNode node) {\n        String value = node.getText();\n        if (//$NON-NLS-1$\n        value.startsWith(\"%\"))\n            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);\n        return null;\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.pde.ui/1463.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "236dd9c3e3386bd6a06a244e8ea1516692f3c35d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PluginXMLTextHover extends PDETextHover {\n    private PDESourcePage fSourcePage;\n    public  PluginXMLTextHover(PDESourcePage sourcePage) {\n        fSourcePage = sourcePage;\n    }\n    @Override\n    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {\n        int offset = hoverRegion.getOffset();\n        IDocumentRange range = fSourcePage.getRangeElement(offset, true);\n        if (range instanceof IDocumentTextNode)\n            return checkTranslatedValue((IDocumentTextNode) range);\n        if (!(range instanceof IPluginObject))\n            return null;\n        ISchema schema = getExtensionSchema((IPluginObject) range);\n        if (schema != null) {\n            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);\n            if (sObj == null) {\n                return null;\n            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {\n                IDocumentAttributeNode da = (IDocumentAttributeNode) range;\n                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)\n                    // inside name\n                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);\n                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)\n                    // inside value\n                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);\n            } else if (range instanceof IPluginElement) {\n                IDocumentElementNode dn = (IDocumentElementNode) range;\n                int dnOff = dn.getOffset();\n                int dnLen = dn.getLength();\n                String dnName = dn.getXMLTagName();\n                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())\n                    // inside opening tag\n                    return getElementText((ISchemaElement) sObj);\n                try {\n                    String nt = textViewer.getDocument().get(dnOff, dnLen);\n                    if (nt.endsWith(//$NON-NLS-1$\n                    \"</\" + dnName + //$NON-NLS-1$\n                    '>')) {\n                        offset = offset - dnOff;\n                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)\n                            // inside closing tag\n                            return getElementText((ISchemaElement) sObj);\n                    }\n                } catch (BadLocationException e) {\n                }\n            }\n        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)\n            return getExtensionPointHoverInfo((IPluginObject) range, offset);\n        return null;\n    }\n    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {\n        IDocumentAttributeNode da = (IDocumentAttributeNode) object;\n        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {\n            String value = da.getAttributeValue();\n            if (//$NON-NLS-1$\n            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith(\"%\"))\n                return object.getResourceString(value);\n        }\n        return null;\n    }\n    private ISchema getExtensionSchema(IPluginObject object) {\n        IPluginObject extension = object;\n        if (object instanceof IDocumentAttributeNode)\n            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();\n        while (extension != null && !(extension instanceof IPluginExtension)) extension = extension.getParent();\n        if (extension == null)\n            // started off outside of an extension element\n            return null;\n        String point = ((IPluginExtension) extension).getPoint();\n        return PDECore.getDefault().getSchemaRegistry().getSchema(point);\n    }\n    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {\n        if (object instanceof IPluginElement)\n            return schema.findElement(((IPluginElement) object).getName());\n        if (object instanceof IPluginExtension)\n            //$NON-NLS-1$\n            return schema.findElement(\"extension\");\n        if (object instanceof IDocumentAttributeNode)\n            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());\n        return null;\n    }\n    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        return sAtt.getDescription();\n    }\n    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {\n        if (//$NON-NLS-1$\n        sEle.getName().equals(\"extension\") && attrib.getName().equals(IPluginExtension.P_POINT))\n            return getSchemaDescription(attrib, sEle);\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        String value = attrib.getValue();\n        if (//$NON-NLS-1$\n        sAtt.isTranslatable() && value.startsWith(\"%\"))\n            return attrib.getResourceString(value);\n        return null;\n    }\n    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {\n        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        if (description == null) {\n            URL url = sEle.getSchema().getURL();\n            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();\n            SchemaUtil.parseURL(url, handler);\n            description = handler.getDescription();\n            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        }\n        return description;\n    }\n    private String getElementText(ISchemaElement sEle) {\n        if (sEle == null) {\n            return null;\n        }\n        return sEle.getDescription();\n    }\n    private String checkTranslatedValue(IDocumentTextNode node) {\n        String value = node.getText();\n        if (//$NON-NLS-1$\n        value.startsWith(\"%\"))\n            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);\n        return null;\n    }\n"]]}
{"hexsha": "b5f71a5a6d3aac676e17055cfabf54d3d8029f71", "ext": "java", "lang": "Java", "content": "public class CylonGpioExample {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        System.out.println(\"<--Pi4J--> GPIO Cylon Example ... started.\");\n\n        // create gpio controller\n        final GpioController gpio = GpioFactory.getInstance();\n\n        // provision gpio pin #01 as an output pin and turn on\n        final GpioPinDigitalOutput[] pins = {\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW)};\n        System.out.println(\"--> GPIO state should be: ON\");\n\n        // set shutdown options on all pins\n        gpio.setShutdownOptions(true, PinState.LOW, pins);\n\n        // infinite loop\n        while(true) {\n\n            for(int index = 0; index <= 6; index++) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n\n            for(int index = 6; index >= 0; index--) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n        }\n\n        // stop all GPIO activity/threads by shutting down the GPIO controller\n        // (this method will forcefully shutdown all GPIO monitoring threads and scheduled tasks)\n        // gpio.shutdown();   <--- implement this method call if you wish to terminate the Pi4J GPIO controller\n    }\n}", "class_id": 0, "repo": "funk-overload/funky_leds", "file": "pi4j-1.1/examples/CylonGpioExample.java", "last_update_at": "2021-01-13T03:25:14+00:00", "question_id": "b5f71a5a6d3aac676e17055cfabf54d3d8029f71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CylonGpioExample {\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"<--Pi4J--> GPIO Cylon Example ... started.\");\n        // create gpio controller\n        final GpioController gpio = GpioFactory.getInstance();\n        // provision gpio pin #01 as an output pin and turn on\n        final GpioPinDigitalOutput[] pins = {\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW),\n                gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW)};\n        System.out.println(\"--> GPIO state should be: ON\");\n        // set shutdown options on all pins\n        gpio.setShutdownOptions(true, PinState.LOW, pins);\n        // infinite loop\n        while(true) {\n            for(int index = 0; index <= 6; index++) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n            for(int index = 6; index >= 0; index--) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n        }\n        // stop all GPIO activity/threads by shutting down the GPIO controller\n        // (this method will forcefully shutdown all GPIO monitoring threads and scheduled tasks)\n        // gpio.shutdown();   <--- implement this method call if you wish to terminate the Pi4J GPIO controller\n    }\n"]]}
{"hexsha": "f03acb955ac4cb27321bca392b2d1acefa0e597e", "ext": "java", "lang": "Java", "content": "public class PrivateUrlTest {\n\n    @Test\n    public void testProcessLine() throws Exception {\n        PropertiesFile propertiesFile = new PropertiesFile(\"resources/.application.properties\");\n        String accessKeyId = propertiesFile.getValue(\"ten-id\");\n        String accessKeySecret = propertiesFile.getValue(\"ten-secret\");\n        String bucket = propertiesFile.getValue(\"bucket\");\n        String region = \"ap-shanghai\";\n        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, \"~/Downloads\");\n        String result = privateUrl.singleResult(new HashMap<String, String>(){{\n            put(\"key\", \"24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg\");\n        }});\n        System.out.println(result);\n\n        List<Map<String, String>> mapList = new ArrayList<>();\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"1\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"2\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"3\"); }});\n        privateUrl.processLine(mapList);\n        privateUrl.closeResource();\n    }\n}", "class_id": 0, "repo": "NigelWu95/qiniu-suits", "file": "src/test/java/com/qiniu/process/tencent/PrivateUrlTest.java", "last_update_at": "2021-05-19T13:33:45+00:00", "question_id": "f03acb955ac4cb27321bca392b2d1acefa0e597e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PrivateUrlTest {\n    @Test\n    public void testProcessLine() throws Exception {\n        PropertiesFile propertiesFile = new PropertiesFile(\"resources/.application.properties\");\n        String accessKeyId = propertiesFile.getValue(\"ten-id\");\n        String accessKeySecret = propertiesFile.getValue(\"ten-secret\");\n        String bucket = propertiesFile.getValue(\"bucket\");\n        String region = \"ap-shanghai\";\n        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, \"~/Downloads\");\n        String result = privateUrl.singleResult(new HashMap<String, String>(){{\n            put(\"key\", \"24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg\");\n        }});\n        System.out.println(result);\n        List<Map<String, String>> mapList = new ArrayList<>();\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"1\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"2\"); }});\n        mapList.add(new HashMap<String, String>(){{ put(\"key\", \"3\"); }});\n        privateUrl.processLine(mapList);\n        privateUrl.closeResource();\n    }\n"]]}
{"hexsha": "d1df0edd75da094a11db311dfe81daf5603081fa", "ext": "java", "lang": "Java", "content": "public class ViewCommand extends Command {\n\n    public static final String COMMAND_WORD = \"view\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD\n            + \": Displays the applicant details identified by the index number used in the displayed applicant list.\\n\"\n            + \"Parameters: INDEX (must be a positive integer) [T] (case sensitive)\\n\"\n            + \"Example: \" + COMMAND_WORD + \" 1 T\";\n\n\n    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = \"Displayed Applicant details: %1$s\";\n\n    private final Index targetIndex;\n    private final Boolean toggle;\n\n    /**\n     * User can view applicant details in Intern Watcher.\n     */\n    public ViewCommand(Index index, Boolean toggle) {\n        this.targetIndex = index;\n        this.toggle = toggle;\n    }\n\n    @Override\n    public CommandResult execute(Model model) throws CommandException {\n        requireNonNull(model);\n        List<Applicant> lastShownList = model.getFilteredApplicantList();\n\n        if (targetIndex != null) {\n            if (targetIndex.getZeroBased() >= lastShownList.size()) {\n                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);\n            }\n        }\n        if (toggle) {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, true);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        } else {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, false);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        }\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof ViewCommand // instanceof handles nulls\n                && targetIndex.equals(((ViewCommand) other).targetIndex)); // state check\n    }\n}", "class_id": 0, "repo": "jackgugz/tp", "file": "src/main/java/seedu/intern/logic/commands/ViewCommand.java", "last_update_at": "2021-11-11T13:50:27+00:00", "question_id": "d1df0edd75da094a11db311dfe81daf5603081fa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ViewCommand extends Command {\n    public static final String COMMAND_WORD = \"view\";\n    public static final String MESSAGE_USAGE = COMMAND_WORD\n            + \": Displays the applicant details identified by the index number used in the displayed applicant list.\\n\"\n            + \"Parameters: INDEX (must be a positive integer) [T] (case sensitive)\\n\"\n            + \"Example: \" + COMMAND_WORD + \" 1 T\";\n    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = \"Displayed Applicant details: %1$s\";\n    private final Index targetIndex;\n    private final Boolean toggle;\n    /**\n     * User can view applicant details in Intern Watcher.\n     */\n    public ViewCommand(Index index, Boolean toggle) {\n        this.targetIndex = index;\n        this.toggle = toggle;\n    }\n    @Override\n    public CommandResult execute(Model model) throws CommandException {\n        requireNonNull(model);\n        List<Applicant> lastShownList = model.getFilteredApplicantList();\n        if (targetIndex != null) {\n            if (targetIndex.getZeroBased() >= lastShownList.size()) {\n                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);\n            }\n        }\n        if (toggle) {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, true);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        } else {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, false);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS,\n                    applicantToView), false, false, true);\n        }\n    }\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof ViewCommand // instanceof handles nulls\n                && targetIndex.equals(((ViewCommand) other).targetIndex)); // state check\n    }\n"]]}
{"hexsha": "73f66a22b3c991c1a48893c0996622a8d2412519", "ext": "java", "lang": "Java", "content": "public class MiniMaxSum {\n\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n        Object[] numbers = Arrays.stream(stdin.nextLine().split(\" \"))\n                .map(Long::parseLong).toArray();\n        Arrays.sort(numbers);\n        long minSum = 0;\n        long maxSum = 0;\n        for(int i = 0; i < numbers.length - 1; i++) {\n            minSum += (long) numbers[i];\n            maxSum += (long) numbers[i + 1];\n        }\n\n        System.out.println(minSum + \" \" + maxSum);\n        stdin.close();\n    }\n}", "class_id": 0, "repo": "Alok255/hackerrank", "file": "practice/algorithms/implementation/mini-max_sum/MiniMaxSum.java", "last_update_at": "2021-09-04T00:14:38+00:00", "question_id": "73f66a22b3c991c1a48893c0996622a8d2412519", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MiniMaxSum {\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n        Object[] numbers = Arrays.stream(stdin.nextLine().split(\" \"))\n                .map(Long::parseLong).toArray();\n        Arrays.sort(numbers);\n        long minSum = 0;\n        long maxSum = 0;\n        for(int i = 0; i < numbers.length - 1; i++) {\n            minSum += (long) numbers[i];\n            maxSum += (long) numbers[i + 1];\n        }\n        System.out.println(minSum + \" \" + maxSum);\n        stdin.close();\n    }\n"]]}
{"hexsha": "f0df889c9a924965d5986a36b2a0cbf9e81b51b7", "ext": "java", "lang": "Java", "content": "public class Saml2IdentityProviderResponse {\n  @JsonProperty(\"issuer\")\n  private String issuer = null;\n\n  @JsonProperty(\"settings\")\n  private java.util.List<SettingResponse> settings = null;\n\n  @JsonProperty(\"certificates\")\n  private java.util.List<CertificateResponse> certificates = null;\n\n  @JsonProperty(\"attribute_mappings\")\n  private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;\n\n  /**\n   * issuer.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse issuer(String issuer) {\n    this.issuer = issuer;\n    return this;\n  }\n\n  /**\n   * Get issuer.\n   *\n   * @return issuer\n   */\n  @ApiModelProperty(value = \"\")\n  public String getIssuer() {\n    return issuer;\n  }\n\n  /** setIssuer. */\n  public void setIssuer(String issuer) {\n    this.issuer = issuer;\n  }\n\n  /**\n   * settings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n    return this;\n  }\n\n  /**\n   * addSettingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {\n    if (this.settings == null) {\n      this.settings = new java.util.ArrayList<>();\n    }\n    this.settings.add(settingsItem);\n    return this;\n  }\n\n  /**\n   * Get settings.\n   *\n   * @return settings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<SettingResponse> getSettings() {\n    return settings;\n  }\n\n  /** setSettings. */\n  public void setSettings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n  }\n\n  /**\n   * certificates.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse certificates(\n      java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n    return this;\n  }\n\n  /**\n   * addCertificatesItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {\n    if (this.certificates == null) {\n      this.certificates = new java.util.ArrayList<>();\n    }\n    this.certificates.add(certificatesItem);\n    return this;\n  }\n\n  /**\n   * Get certificates.\n   *\n   * @return certificates\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<CertificateResponse> getCertificates() {\n    return certificates;\n  }\n\n  /** setCertificates. */\n  public void setCertificates(java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n  }\n\n  /**\n   * attributeMappings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse attributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n    return this;\n  }\n\n  /**\n   * addAttributeMappingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addAttributeMappingsItem(\n      RequiredAttributeMappingResponse attributeMappingsItem) {\n    if (this.attributeMappings == null) {\n      this.attributeMappings = new java.util.ArrayList<>();\n    }\n    this.attributeMappings.add(attributeMappingsItem);\n    return this;\n  }\n\n  /**\n   * Get attributeMappings.\n   *\n   * @return attributeMappings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {\n    return attributeMappings;\n  }\n\n  /** setAttributeMappings. */\n  public void setAttributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n  }\n\n  /**\n   * Compares objects.\n   *\n   * @return true or false depending on comparison result.\n   */\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;\n    return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer)\n        && Objects.equals(this.settings, saml2IdentityProviderResponse.settings)\n        && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates)\n        && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);\n  }\n\n  /** Returns the HashCode. */\n  @Override\n  public int hashCode() {\n    return Objects.hash(issuer, settings, certificates, attributeMappings);\n  }\n\n  /** Converts the given object to string. */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Saml2IdentityProviderResponse {\\n\");\n\n    sb.append(\"    issuer: \").append(toIndentedString(issuer)).append(\"\\n\");\n    sb.append(\"    settings: \").append(toIndentedString(settings)).append(\"\\n\");\n    sb.append(\"    certificates: \").append(toIndentedString(certificates)).append(\"\\n\");\n    sb.append(\"    attributeMappings: \").append(toIndentedString(attributeMappings)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n}", "class_id": 0, "repo": "docusign/docusign-admin-java-client", "file": "src/main/java/com/docusign/admin/model/Saml2IdentityProviderResponse.java", "last_update_at": "2021-11-14T17:02:16+00:00", "question_id": "f0df889c9a924965d5986a36b2a0cbf9e81b51b7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Saml2IdentityProviderResponse {\n  @JsonProperty(\"issuer\")\n  private String issuer = null;\n  @JsonProperty(\"settings\")\n  private java.util.List<SettingResponse> settings = null;\n  @JsonProperty(\"certificates\")\n  private java.util.List<CertificateResponse> certificates = null;\n  @JsonProperty(\"attribute_mappings\")\n  private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;\n  /**\n   * issuer.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse issuer(String issuer) {\n    this.issuer = issuer;\n    return this;\n  }\n  /**\n   * Get issuer.\n   *\n   * @return issuer\n   */\n  @ApiModelProperty(value = \"\")\n  public String getIssuer() {\n    return issuer;\n  }\n  /** setIssuer. */\n  public void setIssuer(String issuer) {\n    this.issuer = issuer;\n  }\n  /**\n   * settings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n    return this;\n  }\n  /**\n   * addSettingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {\n    if (this.settings == null) {\n      this.settings = new java.util.ArrayList<>();\n    }\n    this.settings.add(settingsItem);\n    return this;\n  }\n  /**\n   * Get settings.\n   *\n   * @return settings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<SettingResponse> getSettings() {\n    return settings;\n  }\n  /** setSettings. */\n  public void setSettings(java.util.List<SettingResponse> settings) {\n    this.settings = settings;\n  }\n  /**\n   * certificates.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse certificates(\n      java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n    return this;\n  }\n  /**\n   * addCertificatesItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {\n    if (this.certificates == null) {\n      this.certificates = new java.util.ArrayList<>();\n    }\n    this.certificates.add(certificatesItem);\n    return this;\n  }\n  /**\n   * Get certificates.\n   *\n   * @return certificates\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<CertificateResponse> getCertificates() {\n    return certificates;\n  }\n  /** setCertificates. */\n  public void setCertificates(java.util.List<CertificateResponse> certificates) {\n    this.certificates = certificates;\n  }\n  /**\n   * attributeMappings.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse attributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n    return this;\n  }\n  /**\n   * addAttributeMappingsItem.\n   *\n   * @return Saml2IdentityProviderResponse\n   */\n  public Saml2IdentityProviderResponse addAttributeMappingsItem(\n      RequiredAttributeMappingResponse attributeMappingsItem) {\n    if (this.attributeMappings == null) {\n      this.attributeMappings = new java.util.ArrayList<>();\n    }\n    this.attributeMappings.add(attributeMappingsItem);\n    return this;\n  }\n  /**\n   * Get attributeMappings.\n   *\n   * @return attributeMappings\n   */\n  @ApiModelProperty(value = \"\")\n  public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {\n    return attributeMappings;\n  }\n  /** setAttributeMappings. */\n  public void setAttributeMappings(\n      java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n    this.attributeMappings = attributeMappings;\n  }\n  /**\n   * Compares objects.\n   *\n   * @return true or false depending on comparison result.\n   */\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;\n    return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer)\n        && Objects.equals(this.settings, saml2IdentityProviderResponse.settings)\n        && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates)\n        && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);\n  }\n  /** Returns the HashCode. */\n  @Override\n  public int hashCode() {\n    return Objects.hash(issuer, settings, certificates, attributeMappings);\n  }\n  /** Converts the given object to string. */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Saml2IdentityProviderResponse {\\n\");\n    sb.append(\"    issuer: \").append(toIndentedString(issuer)).append(\"\\n\");\n    sb.append(\"    settings: \").append(toIndentedString(settings)).append(\"\\n\");\n    sb.append(\"    certificates: \").append(toIndentedString(certificates)).append(\"\\n\");\n    sb.append(\"    attributeMappings: \").append(toIndentedString(attributeMappings)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "07f14f69f8dacb6b9a0eeb603908e41613cd4a6a", "ext": "java", "lang": "Java", "content": "public class RegistrationFactory implements FactoryBean<Registration> {\n    @Override\n    public Registration getObject() throws Exception {\n\n        User user = new UserFactory().getObject();\n        Activity activity = new ActivityFactory().getObject();\n\n        assert user != null;\n        assert activity != null;\n\n        return Registration.builder()\n                .registrationId(new RegistrationId(user.getId(), activity.getId()))\n                .user(user)\n                .activity(activity)\n                .build();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}", "class_id": 0, "repo": "olros/GIDD", "file": "backend/src/test/java/com/ntnu/gidd/factories/RegistrationFactory.java", "last_update_at": "2021-04-30T21:46:19+00:00", "question_id": "07f14f69f8dacb6b9a0eeb603908e41613cd4a6a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RegistrationFactory implements FactoryBean<Registration> {\n    @Override\n    public Registration getObject() throws Exception {\n        User user = new UserFactory().getObject();\n        Activity activity = new ActivityFactory().getObject();\n        assert user != null;\n        assert activity != null;\n        return Registration.builder()\n                .registrationId(new RegistrationId(user.getId(), activity.getId()))\n                .user(user)\n                .activity(activity)\n                .build();\n    }\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n"]]}
{"hexsha": "be19510bbe554bc909260040d46c21ac6908f660", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\"})\npublic class LRExprParenParser extends Parser {\n\tstatic { RuntimeMetaData.checkVersion(\"4.9.2\", RuntimeMetaData.VERSION); }\n\n\tprotected static final DFA[] _decisionToDFA;\n\tprotected static final PredictionContextCache _sharedContextCache =\n\t\tnew PredictionContextCache();\n\tpublic static final int\n\t\tT__0=1, T__1=2, T__2=3, T__3=4, T__4=5, ID=6, INT=7, WS=8;\n\tpublic static final int\n\t\tRULE_stat = 0, RULE_expr = 1;\n\tprivate static String[] makeRuleNames() {\n\t\treturn new String[] {\n\t\t\t\"stat\", \"expr\"\n\t\t};\n\t}\n\tpublic static final String[] ruleNames = makeRuleNames();\n\n\tprivate static String[] makeLiteralNames() {\n\t\treturn new String[] {\n\t\t\tnull, \"';'\", \"'*'\", \"'+'\", \"'('\", \"')'\"\n\t\t};\n\t}\n\tprivate static final String[] _LITERAL_NAMES = makeLiteralNames();\n\tprivate static String[] makeSymbolicNames() {\n\t\treturn new String[] {\n\t\t\tnull, null, null, null, null, null, \"ID\", \"INT\", \"WS\"\n\t\t};\n\t}\n\tprivate static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();\n\tpublic static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);\n\n\t/**\n\t * @deprecated Use {@link #VOCABULARY} instead.\n\t */\n\t@Deprecated\n\tpublic static final String[] tokenNames;\n\tstatic {\n\t\ttokenNames = new String[_SYMBOLIC_NAMES.length];\n\t\tfor (int i = 0; i < tokenNames.length; i++) {\n\t\t\ttokenNames[i] = VOCABULARY.getLiteralName(i);\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = VOCABULARY.getSymbolicName(i);\n\t\t\t}\n\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = \"<INVALID>\";\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic String[] getTokenNames() {\n\t\treturn tokenNames;\n\t}\n\n\t@Override\n\n\tpublic Vocabulary getVocabulary() {\n\t\treturn VOCABULARY;\n\t}\n\n\t@Override\n\tpublic String getGrammarFileName() { return \"LRExprParen.g4\"; }\n\n\t@Override\n\tpublic String[] getRuleNames() { return ruleNames; }\n\n\t@Override\n\tpublic String getSerializedATN() { return _serializedATN; }\n\n\t@Override\n\tpublic ATN getATN() { return _ATN; }\n\n\tpublic LRExprParenParser(TokenStream input) {\n\t\tsuper(input);\n\t\t_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);\n\t}\n\n\tpublic static class StatContext extends ParserRuleContext {\n\t\tpublic ExprContext expr() {\n\t\t\treturn getRuleContext(ExprContext.class,0);\n\t\t}\n\t\tpublic TerminalNode EOF() { return getToken(LRExprParenParser.EOF, 0); }\n\t\tpublic StatContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_stat; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitStat(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\n\tpublic final StatContext stat() throws RecognitionException {\n\t\tStatContext _localctx = new StatContext(_ctx, getState());\n\t\tenterRule(_localctx, 0, RULE_stat);\n\t\ttry {\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(4);\n\t\t\texpr(0);\n\t\t\tsetState(5);\n\t\t\tmatch(T__0);\n\t\t\tsetState(6);\n\t\t\tmatch(EOF);\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\texitRule();\n\t\t}\n\t\treturn _localctx;\n\t}\n\n\tpublic static class ExprContext extends ParserRuleContext {\n\t\tpublic List<ExprContext> expr() {\n\t\t\treturn getRuleContexts(ExprContext.class);\n\t\t}\n\t\tpublic ExprContext expr(int i) {\n\t\t\treturn getRuleContext(ExprContext.class,i);\n\t\t}\n\t\tpublic TerminalNode INT() { return getToken(LRExprParenParser.INT, 0); }\n\t\tpublic TerminalNode ID() { return getToken(LRExprParenParser.ID, 0); }\n\t\tpublic ExprContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_expr; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitExpr(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\n\tpublic final ExprContext expr() throws RecognitionException {\n\t\treturn expr(0);\n\t}\n\n\tprivate ExprContext expr(int _p) throws RecognitionException {\n\t\tParserRuleContext _parentctx = _ctx;\n\t\tint _parentState = getState();\n\t\tExprContext _localctx = new ExprContext(_ctx, _parentState);\n\t\tExprContext _prevctx = _localctx;\n\t\tint _startState = 2;\n\t\tenterRecursionRule(_localctx, 2, RULE_expr, _p);\n\t\ttry {\n\t\t\tint _alt;\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(15);\n\t\t\t_errHandler.sync(this);\n\t\t\tswitch (_input.LA(1)) {\n\t\t\tcase T__3:\n\t\t\t\t{\n\t\t\t\tsetState(9);\n\t\t\t\tmatch(T__3);\n\t\t\t\tsetState(10);\n\t\t\t\texpr(0);\n\t\t\t\tsetState(11);\n\t\t\t\tmatch(T__4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\t{\n\t\t\t\tsetState(13);\n\t\t\t\tmatch(INT);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ID:\n\t\t\t\t{\n\t\t\t\tsetState(14);\n\t\t\t\tmatch(ID);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new NoViableAltException(this);\n\t\t\t}\n\t\t\t_ctx.stop = _input.LT(-1);\n\t\t\tsetState(25);\n\t\t\t_errHandler.sync(this);\n\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\twhile ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tif ( _alt==1 ) {\n\t\t\t\t\tif ( _parseListeners!=null ) triggerExitRuleEvent();\n\t\t\t\t\t_prevctx = _localctx;\n\t\t\t\t\t{\n\t\t\t\t\tsetState(23);\n\t\t\t\t\t_errHandler.sync(this);\n\t\t\t\t\tswitch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(17);\n\t\t\t\t\t\tif (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\t\t\t\t\t\tsetState(18);\n\t\t\t\t\t\tmatch(T__1);\n\t\t\t\t\t\tsetState(19);\n\t\t\t\t\t\texpr(6);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(20);\n\t\t\t\t\t\tif (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\t\t\t\t\t\tsetState(21);\n\t\t\t\t\t\tmatch(T__2);\n\t\t\t\t\t\tsetState(22);\n\t\t\t\t\t\texpr(5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tsetState(27);\n\t\t\t\t_errHandler.sync(this);\n\t\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\tunrollRecursionContexts(_parentctx);\n\t\t}\n\t\treturn _localctx;\n\t}\n\n\tpublic boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n\t\tswitch (ruleIndex) {\n\t\tcase 1:\n\t\t\treturn expr_sempred((ExprContext)_localctx, predIndex);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate boolean expr_sempred(ExprContext _localctx, int predIndex) {\n\t\tswitch (predIndex) {\n\t\tcase 0:\n\t\t\treturn precpred(_ctx, 5);\n\t\tcase 1:\n\t\t\treturn precpred(_ctx, 4);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static final String _serializedATN =\n\t\t\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3\\n\\37\\4\\2\\t\\2\\4\\3\"+\n\t\t\"\\t\\3\\3\\2\\3\\2\\3\\2\\3\\2\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3\\22\\n\\3\\3\\3\\3\\3\\3\"+\n\t\t\"\\3\\3\\3\\3\\3\\3\\3\\7\\3\\32\\n\\3\\f\\3\\16\\3\\35\\13\\3\\3\\3\\2\\3\\4\\4\\2\\4\\2\\2\\2 \\2\\6\"+\n\t\t\"\\3\\2\\2\\2\\4\\21\\3\\2\\2\\2\\6\\7\\5\\4\\3\\2\\7\\b\\7\\3\\2\\2\\b\\t\\7\\2\\2\\3\\t\\3\\3\\2\\2\\2\"+\n\t\t\"\\n\\13\\b\\3\\1\\2\\13\\f\\7\\6\\2\\2\\f\\r\\5\\4\\3\\2\\r\\16\\7\\7\\2\\2\\16\\22\\3\\2\\2\\2\\17\\22\"+\n\t\t\"\\7\\t\\2\\2\\20\\22\\7\\b\\2\\2\\21\\n\\3\\2\\2\\2\\21\\17\\3\\2\\2\\2\\21\\20\\3\\2\\2\\2\\22\\33\"+\n\t\t\"\\3\\2\\2\\2\\23\\24\\f\\7\\2\\2\\24\\25\\7\\4\\2\\2\\25\\32\\5\\4\\3\\b\\26\\27\\f\\6\\2\\2\\27\\30\"+\n\t\t\"\\7\\5\\2\\2\\30\\32\\5\\4\\3\\7\\31\\23\\3\\2\\2\\2\\31\\26\\3\\2\\2\\2\\32\\35\\3\\2\\2\\2\\33\\31\"+\n\t\t\"\\3\\2\\2\\2\\33\\34\\3\\2\\2\\2\\34\\5\\3\\2\\2\\2\\35\\33\\3\\2\\2\\2\\5\\21\\31\\33\";\n\tpublic static final ATN _ATN =\n\t\tnew ATNDeserializer().deserialize(_serializedATN.toCharArray());\n\tstatic {\n\t\t_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];\n\t\tfor (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {\n\t\t\t_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "courses-at-nju-by-hfwei/compilers-antlr", "file": "build/generated-src/antlr/main/parserllantlr/LRExprParenParser.java", "last_update_at": "2021-12-16T03:24:37+00:00", "question_id": "be19510bbe554bc909260040d46c21ac6908f660", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\"})\npublic class LRExprParenParser extends Parser {\n\tstatic { RuntimeMetaData.checkVersion(\"4.9.2\", RuntimeMetaData.VERSION); }\n\tprotected static final DFA[] _decisionToDFA;\n\tprotected static final PredictionContextCache _sharedContextCache =\n\t\tnew PredictionContextCache();\n\tpublic static final int\n\t\tT__0=1, T__1=2, T__2=3, T__3=4, T__4=5, ID=6, INT=7, WS=8;\n\tpublic static final int\n\t\tRULE_stat = 0, RULE_expr = 1;\n\tprivate static String[] makeRuleNames() {\n\t\treturn new String[] {\n\t\t\t\"stat\", \"expr\"\n\t\t};\n\t}\n\tpublic static final String[] ruleNames = makeRuleNames();\n\tprivate static String[] makeLiteralNames() {\n\t\treturn new String[] {\n\t\t\tnull, \"';'\", \"'*'\", \"'+'\", \"'('\", \"')'\"\n\t\t};\n\t}\n\tprivate static final String[] _LITERAL_NAMES = makeLiteralNames();\n\tprivate static String[] makeSymbolicNames() {\n\t\treturn new String[] {\n\t\t\tnull, null, null, null, null, null, \"ID\", \"INT\", \"WS\"\n\t\t};\n\t}\n\tprivate static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();\n\tpublic static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);\n\t/**\n\t * @deprecated Use {@link #VOCABULARY} instead.\n\t */\n\t@Deprecated\n\tpublic static final String[] tokenNames;\n\tstatic {\n\t\ttokenNames = new String[_SYMBOLIC_NAMES.length];\n\t\tfor (int i = 0; i < tokenNames.length; i++) {\n\t\t\ttokenNames[i] = VOCABULARY.getLiteralName(i);\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = VOCABULARY.getSymbolicName(i);\n\t\t\t}\n\t\t\tif (tokenNames[i] == null) {\n\t\t\t\ttokenNames[i] = \"<INVALID>\";\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\t@Deprecated\n\tpublic String[] getTokenNames() {\n\t\treturn tokenNames;\n\t}\n\t@Override\n\tpublic Vocabulary getVocabulary() {\n\t\treturn VOCABULARY;\n\t}\n\t@Override\n\tpublic String getGrammarFileName() { return \"LRExprParen.g4\"; }\n\t@Override\n\tpublic String[] getRuleNames() { return ruleNames; }\n\t@Override\n\tpublic String getSerializedATN() { return _serializedATN; }\n\t@Override\n\tpublic ATN getATN() { return _ATN; }\n\tpublic LRExprParenParser(TokenStream input) {\n\t\tsuper(input);\n\t\t_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);\n\t}\n\tpublic static class StatContext extends ParserRuleContext {\n\t\tpublic ExprContext expr() {\n\t\t\treturn getRuleContext(ExprContext.class,0);\n\t\t}\n\t\tpublic TerminalNode EOF() { return getToken(LRExprParenParser.EOF, 0); }\n\t\tpublic StatContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_stat; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitStat(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitStat(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\tpublic final StatContext stat() throws RecognitionException {\n\t\tStatContext _localctx = new StatContext(_ctx, getState());\n\t\tenterRule(_localctx, 0, RULE_stat);\n\t\ttry {\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(4);\n\t\t\texpr(0);\n\t\t\tsetState(5);\n\t\t\tmatch(T__0);\n\t\t\tsetState(6);\n\t\t\tmatch(EOF);\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\texitRule();\n\t\t}\n\t\treturn _localctx;\n\t}\n\tpublic static class ExprContext extends ParserRuleContext {\n\t\tpublic List<ExprContext> expr() {\n\t\t\treturn getRuleContexts(ExprContext.class);\n\t\t}\n\t\tpublic ExprContext expr(int i) {\n\t\t\treturn getRuleContext(ExprContext.class,i);\n\t\t}\n\t\tpublic TerminalNode INT() { return getToken(LRExprParenParser.INT, 0); }\n\t\tpublic TerminalNode ID() { return getToken(LRExprParenParser.ID, 0); }\n\t\tpublic ExprContext(ParserRuleContext parent, int invokingState) {\n\t\t\tsuper(parent, invokingState);\n\t\t}\n\t\t@Override public int getRuleIndex() { return RULE_expr; }\n\t\t@Override\n\t\tpublic void enterRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).enterExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic void exitRule(ParseTreeListener listener) {\n\t\t\tif ( listener instanceof LRExprParenListener ) ((LRExprParenListener)listener).exitExpr(this);\n\t\t}\n\t\t@Override\n\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n\t\t\tif ( visitor instanceof LRExprParenVisitor ) return ((LRExprParenVisitor<? extends T>)visitor).visitExpr(this);\n\t\t\telse return visitor.visitChildren(this);\n\t\t}\n\t}\n\tpublic final ExprContext expr() throws RecognitionException {\n\t\treturn expr(0);\n\t}\n\tprivate ExprContext expr(int _p) throws RecognitionException {\n\t\tParserRuleContext _parentctx = _ctx;\n\t\tint _parentState = getState();\n\t\tExprContext _localctx = new ExprContext(_ctx, _parentState);\n\t\tExprContext _prevctx = _localctx;\n\t\tint _startState = 2;\n\t\tenterRecursionRule(_localctx, 2, RULE_expr, _p);\n\t\ttry {\n\t\t\tint _alt;\n\t\t\tenterOuterAlt(_localctx, 1);\n\t\t\t{\n\t\t\tsetState(15);\n\t\t\t_errHandler.sync(this);\n\t\t\tswitch (_input.LA(1)) {\n\t\t\tcase T__3:\n\t\t\t\t{\n\t\t\t\tsetState(9);\n\t\t\t\tmatch(T__3);\n\t\t\t\tsetState(10);\n\t\t\t\texpr(0);\n\t\t\t\tsetState(11);\n\t\t\t\tmatch(T__4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\t{\n\t\t\t\tsetState(13);\n\t\t\t\tmatch(INT);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ID:\n\t\t\t\t{\n\t\t\t\tsetState(14);\n\t\t\t\tmatch(ID);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new NoViableAltException(this);\n\t\t\t}\n\t\t\t_ctx.stop = _input.LT(-1);\n\t\t\tsetState(25);\n\t\t\t_errHandler.sync(this);\n\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\twhile ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tif ( _alt==1 ) {\n\t\t\t\t\tif ( _parseListeners!=null ) triggerExitRuleEvent();\n\t\t\t\t\t_prevctx = _localctx;\n\t\t\t\t\t{\n\t\t\t\t\tsetState(23);\n\t\t\t\t\t_errHandler.sync(this);\n\t\t\t\t\tswitch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(17);\n\t\t\t\t\t\tif (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n\t\t\t\t\t\tsetState(18);\n\t\t\t\t\t\tmatch(T__1);\n\t\t\t\t\t\tsetState(19);\n\t\t\t\t\t\texpr(6);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t_localctx = new ExprContext(_parentctx, _parentState);\n\t\t\t\t\t\tpushNewRecursionContext(_localctx, _startState, RULE_expr);\n\t\t\t\t\t\tsetState(20);\n\t\t\t\t\t\tif (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n\t\t\t\t\t\tsetState(21);\n\t\t\t\t\t\tmatch(T__2);\n\t\t\t\t\t\tsetState(22);\n\t\t\t\t\t\texpr(5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tsetState(27);\n\t\t\t\t_errHandler.sync(this);\n\t\t\t\t_alt = getInterpreter().adaptivePredict(_input,2,_ctx);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t_localctx.exception = re;\n\t\t\t_errHandler.reportError(this, re);\n\t\t\t_errHandler.recover(this, re);\n\t\t}\n\t\tfinally {\n\t\t\tunrollRecursionContexts(_parentctx);\n\t\t}\n\t\treturn _localctx;\n\t}\n\tpublic boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n\t\tswitch (ruleIndex) {\n\t\tcase 1:\n\t\t\treturn expr_sempred((ExprContext)_localctx, predIndex);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate boolean expr_sempred(ExprContext _localctx, int predIndex) {\n\t\tswitch (predIndex) {\n\t\tcase 0:\n\t\t\treturn precpred(_ctx, 5);\n\t\tcase 1:\n\t\t\treturn precpred(_ctx, 4);\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static final String _serializedATN =\n\t\t\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3\\n\\37\\4\\2\\t\\2\\4\\3\"+\n\t\t\"\\t\\3\\3\\2\\3\\2\\3\\2\\3\\2\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3\\22\\n\\3\\3\\3\\3\\3\\3\"+\n\t\t\"\\3\\3\\3\\3\\3\\3\\3\\7\\3\\32\\n\\3\\f\\3\\16\\3\\35\\13\\3\\3\\3\\2\\3\\4\\4\\2\\4\\2\\2\\2 \\2\\6\"+\n\t\t\"\\3\\2\\2\\2\\4\\21\\3\\2\\2\\2\\6\\7\\5\\4\\3\\2\\7\\b\\7\\3\\2\\2\\b\\t\\7\\2\\2\\3\\t\\3\\3\\2\\2\\2\"+\n\t\t\"\\n\\13\\b\\3\\1\\2\\13\\f\\7\\6\\2\\2\\f\\r\\5\\4\\3\\2\\r\\16\\7\\7\\2\\2\\16\\22\\3\\2\\2\\2\\17\\22\"+\n\t\t\"\\7\\t\\2\\2\\20\\22\\7\\b\\2\\2\\21\\n\\3\\2\\2\\2\\21\\17\\3\\2\\2\\2\\21\\20\\3\\2\\2\\2\\22\\33\"+\n\t\t\"\\3\\2\\2\\2\\23\\24\\f\\7\\2\\2\\24\\25\\7\\4\\2\\2\\25\\32\\5\\4\\3\\b\\26\\27\\f\\6\\2\\2\\27\\30\"+\n\t\t\"\\7\\5\\2\\2\\30\\32\\5\\4\\3\\7\\31\\23\\3\\2\\2\\2\\31\\26\\3\\2\\2\\2\\32\\35\\3\\2\\2\\2\\33\\31\"+\n\t\t\"\\3\\2\\2\\2\\33\\34\\3\\2\\2\\2\\34\\5\\3\\2\\2\\2\\35\\33\\3\\2\\2\\2\\5\\21\\31\\33\";\n\tpublic static final ATN _ATN =\n\t\tnew ATNDeserializer().deserialize(_serializedATN.toCharArray());\n\tstatic {\n\t\t_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];\n\t\tfor (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {\n\t\t\t_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);\n\t\t}\n\t}\n"]]}
{"hexsha": "80b509f6a9d12338612de5cf8c483f27953d4d54", "ext": "java", "lang": "Java", "content": "public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {\n\n  private int x;\n  private int y;\n  private int z;\n  private List<IoMode> modes;\n  private Channel selectedChannel;\n\n  public PacketClientState() {\n  }\n\n  public PacketClientState(TileHyperCube te) {\n    x = te.xCoord;\n    y = te.yCoord;\n    z = te.zCoord;\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      modes.add(te.getModeForChannel(sc));\n    }\n    selectedChannel = te.getChannel();\n  }\n\n  @Override\n  public void toBytes(ByteBuf buf) {\n    buf.writeInt(x);\n    buf.writeInt(y);\n    buf.writeInt(z);\n\n    if(selectedChannel == null) {\n      ByteBufUtils.writeUTF8String(buf, \"\");\n      ByteBufUtils.writeUTF8String(buf, \"\");\n    } else {\n      ByteBufUtils.writeUTF8String(buf, selectedChannel.name);\n      if(selectedChannel.isPublic()) {\n        ByteBufUtils.writeUTF8String(buf, \"\");\n      } else {\n        ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());\n      }\n    }\n\n    for (IoMode mode : modes) {\n      buf.writeShort(mode.ordinal());\n    }\n  }\n\n  @Override\n  public void fromBytes(ByteBuf buf) {\n    x = buf.readInt();\n    y = buf.readInt();\n    z = buf.readInt();\n\n    String name = ByteBufUtils.readUTF8String(buf);\n    String user = ByteBufUtils.readUTF8String(buf);\n    selectedChannel = null;\n    if(name != null && name.trim().length() > 0) {\n      if(user != null && user.trim().length() > 0) {\n        selectedChannel = new Channel(name, user);\n      } else {\n        selectedChannel = new Channel(name, null);\n      }\n\n    }\n\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      short ordinal = buf.readShort();\n      modes.add(IoMode.values()[ordinal]);\n    }\n\n  }\n\n  @Override\n  public IMessage onMessage(PacketClientState message, MessageContext ctx) {\n    EntityPlayer player = ctx.getServerHandler().playerEntity;\n    TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);\n    if(te instanceof TileHyperCube) {\n      TileHyperCube hc = (TileHyperCube) te;\n\n      SubChannel[] vals = SubChannel.values();\n      for (int i = 0; i < vals.length; i++) {\n        SubChannel sc = vals[i];\n        IoMode mode = message.modes.get(i);\n        hc.setModeForChannel(sc, mode);\n      }\n\n      hc.setChannel(message.selectedChannel);\n\n      player.worldObj.markBlockForUpdate(message.x, message.y, message.z);\n    }\n    return null;\n\n  }\n\n}", "class_id": 0, "repo": "LorenzoDCC/EnderIO", "file": "src/main/java/crazypants/enderio/machine/hypercube/PacketClientState.java", "last_update_at": "2021-08-22T03:46:51+00:00", "question_id": "80b509f6a9d12338612de5cf8c483f27953d4d54", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {\n  private int x;\n  private int y;\n  private int z;\n  private List<IoMode> modes;\n  private Channel selectedChannel;\n  public PacketClientState() {\n  }\n  public PacketClientState(TileHyperCube te) {\n    x = te.xCoord;\n    y = te.yCoord;\n    z = te.zCoord;\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      modes.add(te.getModeForChannel(sc));\n    }\n    selectedChannel = te.getChannel();\n  }\n  @Override\n  public void toBytes(ByteBuf buf) {\n    buf.writeInt(x);\n    buf.writeInt(y);\n    buf.writeInt(z);\n    if(selectedChannel == null) {\n      ByteBufUtils.writeUTF8String(buf, \"\");\n      ByteBufUtils.writeUTF8String(buf, \"\");\n    } else {\n      ByteBufUtils.writeUTF8String(buf, selectedChannel.name);\n      if(selectedChannel.isPublic()) {\n        ByteBufUtils.writeUTF8String(buf, \"\");\n      } else {\n        ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());\n      }\n    }\n    for (IoMode mode : modes) {\n      buf.writeShort(mode.ordinal());\n    }\n  }\n  @Override\n  public void fromBytes(ByteBuf buf) {\n    x = buf.readInt();\n    y = buf.readInt();\n    z = buf.readInt();\n    String name = ByteBufUtils.readUTF8String(buf);\n    String user = ByteBufUtils.readUTF8String(buf);\n    selectedChannel = null;\n    if(name != null && name.trim().length() > 0) {\n      if(user != null && user.trim().length() > 0) {\n        selectedChannel = new Channel(name, user);\n      } else {\n        selectedChannel = new Channel(name, null);\n      }\n    }\n    modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n    for (SubChannel sc : SubChannel.values()) {\n      short ordinal = buf.readShort();\n      modes.add(IoMode.values()[ordinal]);\n    }\n  }\n  @Override\n  public IMessage onMessage(PacketClientState message, MessageContext ctx) {\n    EntityPlayer player = ctx.getServerHandler().playerEntity;\n    TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);\n    if(te instanceof TileHyperCube) {\n      TileHyperCube hc = (TileHyperCube) te;\n      SubChannel[] vals = SubChannel.values();\n      for (int i = 0; i < vals.length; i++) {\n        SubChannel sc = vals[i];\n        IoMode mode = message.modes.get(i);\n        hc.setModeForChannel(sc, mode);\n      }\n      hc.setChannel(message.selectedChannel);\n      player.worldObj.markBlockForUpdate(message.x, message.y, message.z);\n    }\n    return null;\n  }\n"]]}
{"hexsha": "2d088d08cd730611273367ea147d60a48850ecf1", "ext": "java", "lang": "Java", "content": "public final class ResourceLoader {\n    static ObjectMapper om;\n\n   static {\n        om = new ObjectMapper();\n        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n                .enable(SerializationFeature.INDENT_OUTPUT);\n        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n        om.registerModule(new JavaTimeModule());\n        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n    }\n\n    public static String load(String resourceName) {\n        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {\n            return IOUtils.toString(is, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public static String loadGitlabFile(String resourceName) {\n\n        String loaded = load(resourceName);\n        GitlabFile file = GitlabFile.builder().content(loaded).filePath(\"engagement.json\").build();\n        file.encodeFileAttributes();\n\n        try {\n            return om.writeValueAsString(file);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n}", "class_id": 0, "repo": "rht-labs/lodestar-hosting", "file": "src/test/java/com/redhat/labs/lodestar/hosting/mock/ResourceLoader.java", "last_update_at": "2021-08-09T16:55:15+00:00", "question_id": "2d088d08cd730611273367ea147d60a48850ecf1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ResourceLoader {\n    static ObjectMapper om;\n   static {\n        om = new ObjectMapper();\n        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n                .enable(SerializationFeature.INDENT_OUTPUT);\n        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n        om.registerModule(new JavaTimeModule());\n        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n    public static String load(String resourceName) {\n        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {\n            return IOUtils.toString(is, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static String loadGitlabFile(String resourceName) {\n        String loaded = load(resourceName);\n        GitlabFile file = GitlabFile.builder().content(loaded).filePath(\"engagement.json\").build();\n        file.encodeFileAttributes();\n        try {\n            return om.writeValueAsString(file);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n"]]}
{"hexsha": "900efec8f77509ae8a2b4b9488dc2c67b487169f", "ext": "java", "lang": "Java", "content": "public class OpFactory {\n    public static ASTLeaf createOperator(Token t) {\n        String op = t.getText();\n        String[] AssignOperators = {\"+=\", \"-=\", \"*=\", \"/=\"};\n        if(Arrays.asList(AssignOperators).contains(op))\n            return new CompoundAssignOperator(t);\n        else if(op.equals(\"=\"))\n            return new AssignOperator(t);\n        else if(op.equals(\"+\"))\n            return new PlusOperator(t);\n        else if(op.equals(\"-\"))\n            return new MinusOperator(t);\n        else if(op.equals(\"*\"))\n            return new ProductOperator(t);\n        else if (op.equals(\"/\"))\n            return new QuotientOperator(t);\n        else if (op.equals(\"%\"))\n            return new SurplusOperator(t);\n        else if (op.equals(\"==\"))\n            return new EqualityOperator(t);\n        else if (op.equals(\"!=\"))\n            return new NonEqualityOperator(t);\n        else if (op.equals(\">\"))\n            return new MoreOperator(t);\n        else if (op.equals(\">=\"))\n            return new MoreOrEqualOperator(t);\n        else if (op.equals(\"<\"))\n            return new LessOperator(t);\n        else if (op.equals(\"<=\"))\n            return new LessOrEqualOperator(t);\n        else if (op.equals(\"&&\"))\n            return new AndOperator(t);\n        else if (op.equals(\"||\"))\n            return new OrOperator(t);\n        throw new SheepException(\"Unsupported operator\", t.getLineNumber());\n    }\n}", "class_id": 0, "repo": "teru01/Sheep", "file": "src/main/java/sheep/operator/OpFactory.java", "last_update_at": "2021-07-13T15:30:20+00:00", "question_id": "900efec8f77509ae8a2b4b9488dc2c67b487169f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OpFactory {\n    public static ASTLeaf createOperator(Token t) {\n        String op = t.getText();\n        String[] AssignOperators = {\"+=\", \"-=\", \"*=\", \"/=\"};\n        if(Arrays.asList(AssignOperators).contains(op))\n            return new CompoundAssignOperator(t);\n        else if(op.equals(\"=\"))\n            return new AssignOperator(t);\n        else if(op.equals(\"+\"))\n            return new PlusOperator(t);\n        else if(op.equals(\"-\"))\n            return new MinusOperator(t);\n        else if(op.equals(\"*\"))\n            return new ProductOperator(t);\n        else if (op.equals(\"/\"))\n            return new QuotientOperator(t);\n        else if (op.equals(\"%\"))\n            return new SurplusOperator(t);\n        else if (op.equals(\"==\"))\n            return new EqualityOperator(t);\n        else if (op.equals(\"!=\"))\n            return new NonEqualityOperator(t);\n        else if (op.equals(\">\"))\n            return new MoreOperator(t);\n        else if (op.equals(\">=\"))\n            return new MoreOrEqualOperator(t);\n        else if (op.equals(\"<\"))\n            return new LessOperator(t);\n        else if (op.equals(\"<=\"))\n            return new LessOrEqualOperator(t);\n        else if (op.equals(\"&&\"))\n            return new AndOperator(t);\n        else if (op.equals(\"||\"))\n            return new OrOperator(t);\n        throw new SheepException(\"Unsupported operator\", t.getLineNumber());\n    }\n"]]}
{"hexsha": "73c0128eea6de9f738bb18aeb804b5c4154dd8dc", "ext": "java", "lang": "Java", "content": "@ExtendWith(MockitoExtension.class)\nclass AuthCodeGenerationServiceTest {\n\n    @Mock\n    private AuthorizationCodeRepository repository;\n    @InjectMocks\n    private AuthCodeGenerationService testee;\n\n    @Test\n    void test_create() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));\n        when(repository.existsByCode(anyString())).thenReturn(false);\n\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_code_already_exists() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);\n\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_in_future() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_too_far_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017,7,7));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_4_weeks_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_now() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n}", "class_id": 0, "repo": "Ruben23/CovidCode-Service", "file": "src/test/java/ch/admin/bag/covidcode/authcodegeneration/service/AuthCodeGenerationServiceTest.java", "last_update_at": "2021-09-11T08:45:20+00:00", "question_id": "73c0128eea6de9f738bb18aeb804b5c4154dd8dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(MockitoExtension.class)\nclass AuthCodeGenerationServiceTest {\n    @Mock\n    private AuthorizationCodeRepository repository;\n    @InjectMocks\n    private AuthCodeGenerationService testee;\n    @Test\n    void test_create() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));\n        when(repository.existsByCode(anyString())).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n    @Test\n    void test_create_code_already_exists() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n    @Test\n    void test_create_invalid_onset_date_in_future() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n    @Test\n    void test_create_invalid_onset_date_too_far_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017,7,7));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n    @Test\n    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));\n        //when\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n    @Test\n    void test_create_valid_onset_date_exactly_4_weeks_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n    @Test\n    void test_create_valid_onset_date_exactly_now() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n"]]}
{"hexsha": "bbc956ee5ff3ca405fd0af54c93d59a6b745685b", "ext": "java", "lang": "Java", "content": "@Service\npublic class ItemService {\n\n    @Autowired\n    private GmallPmsClient pmsClient;\n\n    @Autowired\n    private GmallSmsClient smsClient;\n    @Autowired\n    private GmallWmsClient wmsClient;\n\n    @Autowired\n    private ThreadPoolExecutor threadPoolExecutor;\n\n\n    public ItemVO queryItemVO(Long skuId) {\n\n        ItemVO itemVO = new ItemVO();\n        //\u6839\u636esku\u7684id\u67e5\u8be2sku\n\n\n        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {\n            itemVO.setSkuId(skuId);\n            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);\n            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();\n            if (skuInfoEntity == null) {\n                return null;\n            }\n            itemVO.setWeight(skuInfoEntity.getWeight());\n            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());\n            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());\n            itemVO.setPrice(skuInfoEntity.getPrice());\n\n            return skuInfoEntity;\n        },threadPoolExecutor);\n\n        //\u6839\u636esku\u4e2d\u7684\u54c1\u724c\u7684id\u67e5\u8be2\u5206\u7c7b\n        //thenAcceptAsync:\u6709\u53c2\u6570\uff0c\u65e0\u8fd4\u56de\n        //thanApplyAsync: \u6709\u53c2\u6570\uff0c\u6709\u8fd4\u56de\n        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());\n            CategoryEntity categoryEntity = categoryEntityResp.getData();\n            if (categoryEntity != null) {\n\n                itemVO.setCategoryId(categoryEntity.getCatId());\n                itemVO.setCategoryName(categoryEntity.getName());\n            }\n\n        },threadPoolExecutor);\n\n        //\u6839\u636esku\u4e2d\u7684brandID\u67e5\u8be2\u54c1\u724c\n        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n\n            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());\n            BrandEntity brandEntity = brandEntityResp.getData();\n            if(brandEntity!=null){\n                itemVO.setBrandId(brandEntity.getBrandId());\n                itemVO.setBrandName(brandEntity.getName());\n\n            }\n        },threadPoolExecutor);\n\n        //\u6839\u636esku\u4e2d\u7684spu\u67e5\u8be2spu\n        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());\n            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();\n            if (skuInfoEntity != null) {\n                itemVO.setSpuId(spuInfoEntity.getId());\n                itemVO.setSpuName(spuInfoEntity.getSpuName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684\u4fe1\u606f\u67e5\u8be2\u56fe\u7247\n        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);\n            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();\n            if (!CollectionUtils.isEmpty(imagesEntities)) {\n                itemVO.setImeges(imagesEntities);\n            }\n        },threadPoolExecutor);\n\n\n        //\u6839\u636eskuid\u67e5\u8be2\u5e93\u5b58\n        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);\n            List<WareSkuEntity> wareSkuEntities = listResp.getData();\n            if (!CollectionUtils.isEmpty(wareSkuEntities)) {\n                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));\n            }\n        },threadPoolExecutor);\n\n\n        //\u6839\u636eskuid\u67e5\u8be2\u8425\u9500\u4fe1\u606f3\u4e2a\n        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);\n            List<ItemSaleVO> itemSaleVOList = listResp1.getData();\n            itemVO.setSales(itemSaleVOList);\n        },threadPoolExecutor);\n\n\n        //\u6839\u636esku\u4e2d\u7684spuID\u67e5\u8be2\u63cf\u8ff0\u4fe1\u606f\n        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());\n            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();\n            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {\n\n                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), \",\")));\n            }\n        },threadPoolExecutor);\n\n        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());\n            List<ItemGroupVO> itemGroupVOS = listResp2.getData();\n            itemVO.setGroupVOS(itemGroupVOS);\n\n        },threadPoolExecutor);\n\n\n        //\u6839\u636esku\u4e2d\u7684spuId\u67e5\u8be2skus\n        //\u6839\u636eskuIds\u67e5\u8be2\u9500\u552e\u5c5e\u6027\n        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());\n            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();\n            itemVO.setSaleAttrs(skuSaleAttrValueEntities);\n\n        },threadPoolExecutor);\n\n        CompletableFuture.allOf(completableFuture,cateCompletablbe,brandCompletablbe,spuCompletable,imagesCompletableFuture\n                               ,skuCompletableFuture,saleCompletableFuture,descCompletableFuture,\n                groupCompletableFuture,attrValueCompletableFuture).join();\n        return itemVO;\n    }\n}", "class_id": 0, "repo": "lxftheking/gmall", "file": "gmall-item/src/main/java/com/atguigu/gmall/item/service/ItemService.java", "last_update_at": "2021-09-09T07:21:17+00:00", "question_id": "bbc956ee5ff3ca405fd0af54c93d59a6b745685b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class ItemService {\n    @Autowired\n    private GmallPmsClient pmsClient;\n    @Autowired\n    private GmallSmsClient smsClient;\n    @Autowired\n    private GmallWmsClient wmsClient;\n    @Autowired\n    private ThreadPoolExecutor threadPoolExecutor;\n    public ItemVO queryItemVO(Long skuId) {\n        ItemVO itemVO = new ItemVO();\n        //\u6839\u636esku\u7684id\u67e5\u8be2sku\n        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {\n            itemVO.setSkuId(skuId);\n            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);\n            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();\n            if (skuInfoEntity == null) {\n                return null;\n            }\n            itemVO.setWeight(skuInfoEntity.getWeight());\n            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());\n            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());\n            itemVO.setPrice(skuInfoEntity.getPrice());\n            return skuInfoEntity;\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684\u54c1\u724c\u7684id\u67e5\u8be2\u5206\u7c7b\n        //thenAcceptAsync:\u6709\u53c2\u6570\uff0c\u65e0\u8fd4\u56de\n        //thanApplyAsync: \u6709\u53c2\u6570\uff0c\u6709\u8fd4\u56de\n        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());\n            CategoryEntity categoryEntity = categoryEntityResp.getData();\n            if (categoryEntity != null) {\n                itemVO.setCategoryId(categoryEntity.getCatId());\n                itemVO.setCategoryName(categoryEntity.getName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684brandID\u67e5\u8be2\u54c1\u724c\n        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());\n            BrandEntity brandEntity = brandEntityResp.getData();\n            if(brandEntity!=null){\n                itemVO.setBrandId(brandEntity.getBrandId());\n                itemVO.setBrandName(brandEntity.getName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684spu\u67e5\u8be2spu\n        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());\n            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();\n            if (skuInfoEntity != null) {\n                itemVO.setSpuId(spuInfoEntity.getId());\n                itemVO.setSpuName(spuInfoEntity.getSpuName());\n            }\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684\u4fe1\u606f\u67e5\u8be2\u56fe\u7247\n        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);\n            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();\n            if (!CollectionUtils.isEmpty(imagesEntities)) {\n                itemVO.setImeges(imagesEntities);\n            }\n        },threadPoolExecutor);\n        //\u6839\u636eskuid\u67e5\u8be2\u5e93\u5b58\n        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);\n            List<WareSkuEntity> wareSkuEntities = listResp.getData();\n            if (!CollectionUtils.isEmpty(wareSkuEntities)) {\n                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));\n            }\n        },threadPoolExecutor);\n        //\u6839\u636eskuid\u67e5\u8be2\u8425\u9500\u4fe1\u606f3\u4e2a\n        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);\n            List<ItemSaleVO> itemSaleVOList = listResp1.getData();\n            itemVO.setSales(itemSaleVOList);\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684spuID\u67e5\u8be2\u63cf\u8ff0\u4fe1\u606f\n        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());\n            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();\n            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {\n                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), \",\")));\n            }\n        },threadPoolExecutor);\n        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());\n            List<ItemGroupVO> itemGroupVOS = listResp2.getData();\n            itemVO.setGroupVOS(itemGroupVOS);\n        },threadPoolExecutor);\n        //\u6839\u636esku\u4e2d\u7684spuId\u67e5\u8be2skus\n        //\u6839\u636eskuIds\u67e5\u8be2\u9500\u552e\u5c5e\u6027\n        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());\n            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();\n            itemVO.setSaleAttrs(skuSaleAttrValueEntities);\n        },threadPoolExecutor);\n        CompletableFuture.allOf(completableFuture,cateCompletablbe,brandCompletablbe,spuCompletable,imagesCompletableFuture\n                               ,skuCompletableFuture,saleCompletableFuture,descCompletableFuture,\n                groupCompletableFuture,attrValueCompletableFuture).join();\n        return itemVO;\n    }\n"]]}
{"hexsha": "b695b9c87c6ae72391dd9e982a7a2b9c105d886d", "ext": "java", "lang": "Java", "content": "public class VertexStroke {\n\n    /**\n     * Method to compute Vertex Stroke\n     *\n     * @param v JUNG's V (Vertex) type\n     * @param dash The array representing the dashing pattern\n     * @param view VisualizationViewer<Object, Edge>\n     * @param layout Layout<Object, Edge>\n     * @return Stroke\n     */\n    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {\n        PickedState<Object> picked_state = view.getPickedVertexState();\n        if (picked_state.isPicked(v)) {\n            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        } else {\n            for (Object w : layout.getGraph().getNeighbors(v)) {\n                if (picked_state.isPicked(w)) {\n                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n                }\n            }\n//            float value = ((Vertex)v).getAttributeValueFloat(\"Cluster\");\n//            if(value != value)\n                return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n//            else\n//                return new BasicStroke(5.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        }\n    }\n\n    /**\n     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,\n     * hired)\n     *\n     * @param v\n     * @param view\n     * @param layout\n     * @param variables\n     * @return\n     */\n    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {\n        float[] dash = null;\n//        if (v instanceof Graph) {\n//            return new BasicStroke(0);\n//        }\n\n        if (v instanceof Vertex) {\n            if (!variables.config.vertexStrokevariables.isEmpty()) {\n                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {\n                    String[] list = vertexStrokevariable.split(\" \");\n                    String att = ((Vertex) v).getAttributeValue(list[0]);\n                    if (!\"\".equals(att)) {\n                        for (int j = 1; j < list.length; j++) {\n                            if (att.equalsIgnoreCase(list[j])) {\n                                dash = new float[1];\n                                dash[0] = 4.0f;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return VertexStroke(v, dash, view, layout);\n    }\n}", "class_id": 0, "repo": "stain/prov-viewer", "file": "src/main/java/br/uff/ic/provviewer/Stroke/VertexStroke.java", "last_update_at": "2021-12-09T05:27:32+00:00", "question_id": "b695b9c87c6ae72391dd9e982a7a2b9c105d886d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VertexStroke {\n    /**\n     * Method to compute Vertex Stroke\n     *\n     * @param v JUNG's V (Vertex) type\n     * @param dash The array representing the dashing pattern\n     * @param view VisualizationViewer<Object, Edge>\n     * @param layout Layout<Object, Edge>\n     * @return Stroke\n     */\n    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {\n        PickedState<Object> picked_state = view.getPickedVertexState();\n        if (picked_state.isPicked(v)) {\n            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        } else {\n            for (Object w : layout.getGraph().getNeighbors(v)) {\n                if (picked_state.isPicked(w)) {\n                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n                }\n            }\n//            float value = ((Vertex)v).getAttributeValueFloat(\"Cluster\");\n//            if(value != value)\n                return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n//            else\n//                return new BasicStroke(5.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        }\n    }\n    /**\n     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,\n     * hired)\n     *\n     * @param v\n     * @param view\n     * @param layout\n     * @param variables\n     * @return\n     */\n    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {\n        float[] dash = null;\n//        if (v instanceof Graph) {\n//            return new BasicStroke(0);\n//        }\n        if (v instanceof Vertex) {\n            if (!variables.config.vertexStrokevariables.isEmpty()) {\n                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {\n                    String[] list = vertexStrokevariable.split(\" \");\n                    String att = ((Vertex) v).getAttributeValue(list[0]);\n                    if (!\"\".equals(att)) {\n                        for (int j = 1; j < list.length; j++) {\n                            if (att.equalsIgnoreCase(list[j])) {\n                                dash = new float[1];\n                                dash[0] = 4.0f;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return VertexStroke(v, dash, view, layout);\n    }\n"]]}
{"hexsha": "1bfe81dec8dca4cb4bef7c48cad2b36862d7d8fe", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet\")\n@JsonPropertyOrder({\n  PresentationResult.JSON_PROPERTY_SLIDE_NUMBER,\n  PresentationResult.JSON_PROPERTY_U_R_L,\n  PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS\n})\n@JsonTypeName(\"PresentationResult\")\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-11-14T13:47:19.979-08:00[America/Los_Angeles]\")\npublic class PresentationResult {\n  public static final String JSON_PROPERTY_SLIDE_NUMBER = \"SlideNumber\";\n  private Integer slideNumber;\n\n  public static final String JSON_PROPERTY_U_R_L = \"URL\";\n  private String URL;\n\n  public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = \"PresentationContents\";\n  private byte[] presentationContents;\n\n\n  public PresentationResult slideNumber(Integer slideNumber) {\n    \n    this.slideNumber = slideNumber;\n    return this;\n  }\n\n   /**\n   * Worksheet number of the converted page, starting with 1 for the left-most worksheet\n   * @return slideNumber\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Worksheet number of the converted page, starting with 1 for the left-most worksheet\")\n  @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public Integer getSlideNumber() {\n    return slideNumber;\n  }\n\n\n  public void setSlideNumber(Integer slideNumber) {\n    this.slideNumber = slideNumber;\n  }\n\n\n  public PresentationResult URL(String URL) {\n    \n    this.URL = URL;\n    return this;\n  }\n\n   /**\n   * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\n   * @return URL\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\")\n  @JsonProperty(JSON_PROPERTY_U_R_L)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public String getURL() {\n    return URL;\n  }\n\n\n  public void setURL(String URL) {\n    this.URL = URL;\n  }\n\n\n  public PresentationResult presentationContents(byte[] presentationContents) {\n    \n    this.presentationContents = presentationContents;\n    return this;\n  }\n\n   /**\n   * Contents of the presentation in bytes\n   * @return presentationContents\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Contents of the presentation in bytes\")\n  @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n\n  public byte[] getPresentationContents() {\n    return presentationContents;\n  }\n\n\n  public void setPresentationContents(byte[] presentationContents) {\n    this.presentationContents = presentationContents;\n  }\n\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PresentationResult presentationResult = (PresentationResult) o;\n    return Objects.equals(this.slideNumber, presentationResult.slideNumber) &&\n        Objects.equals(this.URL, presentationResult.URL) &&\n        Arrays.equals(this.presentationContents, presentationResult.presentationContents);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PresentationResult {\\n\");\n    sb.append(\"    slideNumber: \").append(toIndentedString(slideNumber)).append(\"\\n\");\n    sb.append(\"    URL: \").append(toIndentedString(URL)).append(\"\\n\");\n    sb.append(\"    presentationContents: \").append(toIndentedString(presentationContents)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "Cloudmersive/Cloudmersive.APIClient.Java.RestTemplate", "file": "src/main/java/com/cloudmersive/client/rt/model/PresentationResult.java", "last_update_at": "2021-02-14T19:52:25+00:00", "question_id": "1bfe81dec8dca4cb4bef7c48cad2b36862d7d8fe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(description = \"A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet\")\n@JsonPropertyOrder({\n  PresentationResult.JSON_PROPERTY_SLIDE_NUMBER,\n  PresentationResult.JSON_PROPERTY_U_R_L,\n  PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS\n})\n@JsonTypeName(\"PresentationResult\")\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-11-14T13:47:19.979-08:00[America/Los_Angeles]\")\npublic class PresentationResult {\n  public static final String JSON_PROPERTY_SLIDE_NUMBER = \"SlideNumber\";\n  private Integer slideNumber;\n  public static final String JSON_PROPERTY_U_R_L = \"URL\";\n  private String URL;\n  public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = \"PresentationContents\";\n  private byte[] presentationContents;\n  public PresentationResult slideNumber(Integer slideNumber) {\n    this.slideNumber = slideNumber;\n    return this;\n  }\n   /**\n   * Worksheet number of the converted page, starting with 1 for the left-most worksheet\n   * @return slideNumber\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Worksheet number of the converted page, starting with 1 for the left-most worksheet\")\n  @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public Integer getSlideNumber() {\n    return slideNumber;\n  }\n  public void setSlideNumber(Integer slideNumber) {\n    this.slideNumber = slideNumber;\n  }\n  public PresentationResult URL(String URL) {\n    this.URL = URL;\n    return this;\n  }\n   /**\n   * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\n   * @return URL\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\")\n  @JsonProperty(JSON_PROPERTY_U_R_L)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public String getURL() {\n    return URL;\n  }\n  public void setURL(String URL) {\n    this.URL = URL;\n  }\n  public PresentationResult presentationContents(byte[] presentationContents) {\n    this.presentationContents = presentationContents;\n    return this;\n  }\n   /**\n   * Contents of the presentation in bytes\n   * @return presentationContents\n  **/\n  @javax.annotation.Nullable\n  @ApiModelProperty(value = \"Contents of the presentation in bytes\")\n  @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)\n  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n  public byte[] getPresentationContents() {\n    return presentationContents;\n  }\n  public void setPresentationContents(byte[] presentationContents) {\n    this.presentationContents = presentationContents;\n  }\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    PresentationResult presentationResult = (PresentationResult) o;\n    return Objects.equals(this.slideNumber, presentationResult.slideNumber) &&\n        Objects.equals(this.URL, presentationResult.URL) &&\n        Arrays.equals(this.presentationContents, presentationResult.presentationContents);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class PresentationResult {\\n\");\n    sb.append(\"    slideNumber: \").append(toIndentedString(slideNumber)).append(\"\\n\");\n    sb.append(\"    URL: \").append(toIndentedString(URL)).append(\"\\n\");\n    sb.append(\"    presentationContents: \").append(toIndentedString(presentationContents)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "b5ba2355ae572f4a5409e77434046a0882844699", "ext": "java", "lang": "Java", "content": "@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class HttpProviderTest {\n\n    /**\n     * Initial configuration.\n     */\n    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/x28wW7J8\\\"\\n\"\n    );\n\n    /**\n     * Initial configuration. Requested remote configuration file does not exists.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn87\\\"\\n\"\n    );\n\n    /**\n     * Initial configuration. Remote server can't be resolved.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\\\"\\n\"\n    );\n\n    /**\n     * Initial configuration. Requested remote configuration file is not valid.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn\\\"\\n\"\n    );\n\n    @Test\n    public void httpTest_001() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        final Config remoteConfig = ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION);\n\n        // Test version\n        final Properties properties = new Properties();\n        final InputStream is = HttpProvider.class.getClassLoader()\n            .getResourceAsStream(\"playrconf-http.properties\");\n        try {\n            properties.load(is);\n            Assert.assertEquals(\n                provider.getVersion(),\n                properties.getProperty(\"playrconf.http.version\", \"unknown\")\n            );\n            properties.clear();\n            is.close();\n        } catch (final IOException ignore) {\n        }\n\n        // Standard values\n        Assert.assertEquals(5, remoteConfig.getInt(\"application.five\"));\n        Assert.assertEquals(\"world\", remoteConfig.getString(\"application.hello\"));\n        Assert.assertTrue(remoteConfig.getBoolean(\"application.is-enabled\"));\n        Assert.assertEquals(4, remoteConfig.getIntList(\"application.list\").size());\n\n        // File\n        final File file = new File(\"./test\");\n        try {\n            final InputStream initialStream = new FileInputStream(file);\n            final byte[] buffer = new byte[128];\n            final int nbRead = initialStream.read(buffer);\n            buffer[nbRead] = '\\0';\n            Assert.assertTrue(nbRead > 0);\n            Assert.assertEquals(\n                \"Hello World!\",\n                new String(buffer, 0, nbRead)\n            );\n        } catch (final IOException ex) {\n            ex.printStackTrace();\n            Assert.fail();\n        }\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_002() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);\n    }\n\n    @Test(expected = ConfigException.BadValue.class)\n    public void httpTest_003() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_004() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);\n    }\n}", "class_id": 0, "repo": "play-rconf/play-rconf-http", "file": "src/test/java/io/playrconf/provider/HttpProviderTest.java", "last_update_at": "2021-09-03T01:39:21+00:00", "question_id": "b5ba2355ae572f4a5409e77434046a0882844699", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class HttpProviderTest {\n    /**\n     * Initial configuration.\n     */\n    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/x28wW7J8\\\"\\n\"\n    );\n    /**\n     * Initial configuration. Requested remote configuration file does not exists.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn87\\\"\\n\"\n    );\n    /**\n     * Initial configuration. Remote server can't be resolved.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\\\"\\n\"\n    );\n    /**\n     * Initial configuration. Requested remote configuration file is not valid.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString(\n        \"application.hello = \\\"Bad value\\\"\\n\"\n            + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn\\\"\\n\"\n    );\n    @Test\n    public void httpTest_001() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        final Config remoteConfig = ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION);\n        // Test version\n        final Properties properties = new Properties();\n        final InputStream is = HttpProvider.class.getClassLoader()\n            .getResourceAsStream(\"playrconf-http.properties\");\n        try {\n            properties.load(is);\n            Assert.assertEquals(\n                provider.getVersion(),\n                properties.getProperty(\"playrconf.http.version\", \"unknown\")\n            );\n            properties.clear();\n            is.close();\n        } catch (final IOException ignore) {\n        }\n        // Standard values\n        Assert.assertEquals(5, remoteConfig.getInt(\"application.five\"));\n        Assert.assertEquals(\"world\", remoteConfig.getString(\"application.hello\"));\n        Assert.assertTrue(remoteConfig.getBoolean(\"application.is-enabled\"));\n        Assert.assertEquals(4, remoteConfig.getIntList(\"application.list\").size());\n        // File\n        final File file = new File(\"./test\");\n        try {\n            final InputStream initialStream = new FileInputStream(file);\n            final byte[] buffer = new byte[128];\n            final int nbRead = initialStream.read(buffer);\n            buffer[nbRead] = '\\0';\n            Assert.assertTrue(nbRead > 0);\n            Assert.assertEquals(\n                \"Hello World!\",\n                new String(buffer, 0, nbRead)\n            );\n        } catch (final IOException ex) {\n            ex.printStackTrace();\n            Assert.fail();\n        }\n    }\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_002() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);\n    }\n    @Test(expected = ConfigException.BadValue.class)\n    public void httpTest_003() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);\n    }\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_004() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(\n            INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()),\n            keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder),\n            FileCfgObject::apply\n        );\n        ConfigFactory\n            .parseString(stringBuilder.toString())\n            .withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);\n    }\n"]]}
{"hexsha": "03d7a5ce83aba3ab84bada38250092fab43c06b1", "ext": "java", "lang": "Java", "content": "public class RandomTest {\n    public static void main(String[] args) {\n\n\n        long start = System.currentTimeMillis();\n        for (int i = 0; i <1000000 ; i++) {\n\n\n\n        int intv = new Double(Math.random() * 10000).intValue();\n        long longv = new Double(Math.random() * 1000000).longValue();\n        double doublev = Math.random() * 100;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end-start);\n\n        long start1 = System.currentTimeMillis();\n        for (int i = 0; i <10000 ; i++) {\n\n\n\n            int intv = ThreadLocalRandom.current().nextInt(10000);\n            long longv = ThreadLocalRandom.current().nextLong(1000000);\n            double doublev = ThreadLocalRandom.current().nextDouble(500);\n//            System.out.println(intv);\n//            System.out.println(longv);\n//            System.out.println(doublev);\n//            System.out.println(\"===============\");\n        }\n        long end1 = System.currentTimeMillis();\n        System.out.println(end1-start1);\n\n\n\n    }\n}", "class_id": 0, "repo": "fbjoker/cn.gitv.clickhouse", "file": "src/main/java/com/virtusai/clickhouseclient/utils/RandomTest.java", "last_update_at": "2021-11-11T00:20:35+00:00", "question_id": "03d7a5ce83aba3ab84bada38250092fab43c06b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RandomTest {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i <1000000 ; i++) {\n        int intv = new Double(Math.random() * 10000).intValue();\n        long longv = new Double(Math.random() * 1000000).longValue();\n        double doublev = Math.random() * 100;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end-start);\n        long start1 = System.currentTimeMillis();\n        for (int i = 0; i <10000 ; i++) {\n            int intv = ThreadLocalRandom.current().nextInt(10000);\n            long longv = ThreadLocalRandom.current().nextLong(1000000);\n            double doublev = ThreadLocalRandom.current().nextDouble(500);\n//            System.out.println(intv);\n//            System.out.println(longv);\n//            System.out.println(doublev);\n//            System.out.println(\"===============\");\n        }\n        long end1 = System.currentTimeMillis();\n        System.out.println(end1-start1);\n    }\n"]]}
{"hexsha": "c7ffc9b5dcc827825419f89bb5fd3694937e4516", "ext": "java", "lang": "Java", "content": "public class PlainSpringJSONDocScannerTest {\n\n\tprivate JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();\n\n\t@Controller\n\t@RequestMapping(value = \"/api\", produces = { MediaType.APPLICATION_JSON_VALUE })\n\tprivate class SpringController {\n\n\t\t@RequestMapping(value = \"/string/{name}\", headers = \"header=test\", params = \"delete\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n\t\t@ResponseStatus(value = HttpStatus.CREATED)\n\t\tpublic @ResponseBody String string(@PathVariable(value = \"test\") String name, @RequestParam(\"id\") Integer id, @RequestParam Long query, @RequestParam(name = \"user\", required = false, defaultValue = \"admin\") String user,\t\t\t\t@RequestHeader(value = \"header-two\", defaultValue = \"header-test\") String header, @RequestBody String requestBody) {\n\t\t\treturn \"ok\";\n\t\t}\n\n\t}\n\n\t@Test\n\tpublic void testMergeApiDoc() {\n\t\tSet<Class<?>> controllers = new LinkedHashSet<Class<?>>();\n\t\tcontrollers.add(SpringController.class);\n\t\tSet<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);\n\n\t\tApiDoc apiDoc = apiDocs.iterator().next();\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getDescription());\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getName());\n\t\tAssert.assertNotNull(apiDoc.getGroup());\n\n\t\tfor (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {\n\t\t\tAssert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());\n\t\t\tAssert.assertNull(apiMethodDoc.getAuth());\n\t\t\tAssert.assertNull(apiMethodDoc.getSupportedversions());\n\t\t\tAssert.assertTrue(apiMethodDoc.getApierrors().isEmpty());\n\t\t\tAssert.assertNull(apiMethodDoc.getId());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getSummary());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getDescription());\n\t\t\t\n\t\t\tif (apiMethodDoc.getPath().contains(\"/api/string/{name}\")) {\n\t\t\t\tAssert.assertEquals(2, apiMethodDoc.getHeaders().size());\n\t\t\t\tSet<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();\n\t\t\t\tIterator<ApiHeaderDoc> headersIterator = headers.iterator();\n\t\t\t\tApiHeaderDoc headerTest = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header\", headerTest.getName());\n\t\t\t\tAssert.assertEquals(\"test\", headerTest.getAllowedvalues()[0]);\n\t\t\t\tApiHeaderDoc headerTwo = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header-two\", headerTwo.getName());\n\t\t\t\tAssert.assertEquals(\"header-test\", headerTwo.getAllowedvalues()[0]);\n\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getResponse().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"POST\", apiMethodDoc.getVerb().iterator().next().name());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getProduces().iterator().next());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getConsumes().iterator().next());\n\t\t\t\tAssert.assertEquals(\"201 - Created\", apiMethodDoc.getResponsestatuscode());\n\n\t\t\t\tSet<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();\n\t\t\t\tAssert.assertEquals(4, queryparameters.size());\n\t\t\t\tIterator<ApiParamDoc> qpIterator = queryparameters.iterator();\n\t\t\t\tApiParamDoc apiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"delete\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(null, apiParamDoc.getDefaultvalue());\n\t\t\t\tAssert.assertEquals(0, apiParamDoc.getAllowedvalues().length);\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"id\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getDefaultvalue());\n\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"user\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"false\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"admin\", apiParamDoc.getDefaultvalue());\n\n\t\t\t\tSet<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();\n\t\t\t\tIterator<ApiParamDoc> ppIterator = pathparameters.iterator();\n\t\t\t\tapiParamDoc = ppIterator.next();\n\t\t\t\tapiParamDoc = apiMethodDoc.getPathparameters().iterator().next();\n\t\t\t\tAssert.assertEquals(\"test\", apiParamDoc.getName());\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "class_id": 0, "repo": "eoekun/jsondoc", "file": "jsondoc-springmvc/src/test/java/org/jsondoc/springmvc/scanner/PlainSpringJSONDocScannerTest.java", "last_update_at": "2021-12-11T23:36:19+00:00", "question_id": "c7ffc9b5dcc827825419f89bb5fd3694937e4516", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlainSpringJSONDocScannerTest {\n\tprivate JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();\n\t@Controller\n\t@RequestMapping(value = \"/api\", produces = { MediaType.APPLICATION_JSON_VALUE })\n\tprivate class SpringController {\n\t\t@RequestMapping(value = \"/string/{name}\", headers = \"header=test\", params = \"delete\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n\t\t@ResponseStatus(value = HttpStatus.CREATED)\n\t\tpublic @ResponseBody String string(@PathVariable(value = \"test\") String name, @RequestParam(\"id\") Integer id, @RequestParam Long query, @RequestParam(name = \"user\", required = false, defaultValue = \"admin\") String user,\t\t\t\t@RequestHeader(value = \"header-two\", defaultValue = \"header-test\") String header, @RequestBody String requestBody) {\n\t\t\treturn \"ok\";\n\t\t}\n\t}\n\t@Test\n\tpublic void testMergeApiDoc() {\n\t\tSet<Class<?>> controllers = new LinkedHashSet<Class<?>>();\n\t\tcontrollers.add(SpringController.class);\n\t\tSet<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);\n\t\tApiDoc apiDoc = apiDocs.iterator().next();\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getDescription());\n\t\tAssert.assertEquals(\"SpringController\", apiDoc.getName());\n\t\tAssert.assertNotNull(apiDoc.getGroup());\n\t\tfor (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {\n\t\t\tAssert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());\n\t\t\tAssert.assertNull(apiMethodDoc.getAuth());\n\t\t\tAssert.assertNull(apiMethodDoc.getSupportedversions());\n\t\t\tAssert.assertTrue(apiMethodDoc.getApierrors().isEmpty());\n\t\t\tAssert.assertNull(apiMethodDoc.getId());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getSummary());\n\t\t\tAssert.assertEquals(\"\", apiMethodDoc.getDescription());\n\t\t\t\n\t\t\tif (apiMethodDoc.getPath().contains(\"/api/string/{name}\")) {\n\t\t\t\tAssert.assertEquals(2, apiMethodDoc.getHeaders().size());\n\t\t\t\tSet<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();\n\t\t\t\tIterator<ApiHeaderDoc> headersIterator = headers.iterator();\n\t\t\t\tApiHeaderDoc headerTest = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header\", headerTest.getName());\n\t\t\t\tAssert.assertEquals(\"test\", headerTest.getAllowedvalues()[0]);\n\t\t\t\tApiHeaderDoc headerTwo = headersIterator.next();\n\t\t\t\tAssert.assertEquals(\"header-two\", headerTwo.getName());\n\t\t\t\tAssert.assertEquals(\"header-test\", headerTwo.getAllowedvalues()[0]);\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"string\", apiMethodDoc.getResponse().getJsondocType().getOneLineText());\n\t\t\t\tAssert.assertEquals(\"POST\", apiMethodDoc.getVerb().iterator().next().name());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getProduces().iterator().next());\n\t\t\t\tAssert.assertEquals(\"application/json\", apiMethodDoc.getConsumes().iterator().next());\n\t\t\t\tAssert.assertEquals(\"201 - Created\", apiMethodDoc.getResponsestatuscode());\n\t\t\t\tSet<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();\n\t\t\t\tAssert.assertEquals(4, queryparameters.size());\n\t\t\t\tIterator<ApiParamDoc> qpIterator = queryparameters.iterator();\n\t\t\t\tApiParamDoc apiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"delete\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(null, apiParamDoc.getDefaultvalue());\n\t\t\t\tAssert.assertEquals(0, apiParamDoc.getAllowedvalues().length);\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"id\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"true\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"\", apiParamDoc.getDefaultvalue());\n\t\t\t\tapiParamDoc = qpIterator.next();\n\t\t\t\tAssert.assertEquals(\"user\", apiParamDoc.getName());\n\t\t\t\tAssert.assertEquals(\"false\", apiParamDoc.getRequired());\n\t\t\t\tAssert.assertEquals(\"admin\", apiParamDoc.getDefaultvalue());\n\t\t\t\tSet<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();\n\t\t\t\tIterator<ApiParamDoc> ppIterator = pathparameters.iterator();\n\t\t\t\tapiParamDoc = ppIterator.next();\n\t\t\t\tapiParamDoc = apiMethodDoc.getPathparameters().iterator().next();\n\t\t\t\tAssert.assertEquals(\"test\", apiParamDoc.getName());\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "7740a522f9d31a442361aea9f7bbad55c45087be", "ext": "java", "lang": "Java", "content": "@Ignore\npublic class PhishingDetectionApiTest {\n\n    private final PhishingDetectionApi api = new PhishingDetectionApi();\n\n    \n    /**\n     * Detects phishing attempts\n     *\n     * \n     *\n     * @throws ApiException\n     *          if the Api call fails\n     */\n    @Test\n    public void detectAndReportTest() throws ApiException {\n        List<String> attachments = null;\n        String body = null;\n        String from = null;\n        String subject = null;\n        Integer response = api.detectAndReport(attachments, body, from, subject);\n\n        // TODO: test validations\n    }\n    \n}", "class_id": 0, "repo": "LogSentinel/logsentinel-java-api", "file": "src/test/java/com/logsentinel/api/PhishingDetectionApiTest.java", "last_update_at": "2021-05-14T10:05:46+00:00", "question_id": "7740a522f9d31a442361aea9f7bbad55c45087be", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Ignore\npublic class PhishingDetectionApiTest {\n    private final PhishingDetectionApi api = new PhishingDetectionApi();\n    /**\n     * Detects phishing attempts\n     *\n     * \n     *\n     * @throws ApiException\n     *          if the Api call fails\n     */\n    @Test\n    public void detectAndReportTest() throws ApiException {\n        List<String> attachments = null;\n        String body = null;\n        String from = null;\n        String subject = null;\n        Integer response = api.detectAndReport(attachments, body, from, subject);\n        // TODO: test validations\n    }\n"]]}
{"hexsha": "c6ec38e3aa543ebec430a9ccbdb14ad544958a43", "ext": "java", "lang": "Java", "content": "public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {\n\n    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n    /**\n     * Creation mode.\n     */\n    private ShardMapManagerCreateMode createMode;\n\n    /**\n     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.\n     */\n    private Version targetVersion;\n\n    /**\n     * Constructs request for deploying SMM storage objects to target GSM database.\n     *\n     * @param credentials\n     *            Credentials for connection.\n     * @param retryPolicy\n     *            Retry policy.\n     * @param operationName\n     *            Operation name, useful for diagnostics.\n     * @param createMode\n     *            Creation mode.\n     * @param targetVersion\n     *            target version of store to deploy\n     */\n    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials,\n            RetryPolicy retryPolicy,\n            String operationName,\n            ShardMapManagerCreateMode createMode,\n            Version targetVersion) {\n        super(credentials, retryPolicy, operationName);\n        this.createMode = createMode;\n        this.targetVersion = targetVersion;\n    }\n\n    /**\n     * Whether this is a read-only operation.\n     */\n    @Override\n    public boolean getReadOnly() {\n        return false;\n    }\n\n    /**\n     * Execute the operation against GSM in the current transaction scope.\n     *\n     * @param ts\n     *            Transaction scope.\n     * @return Results of the operation.\n     */\n    @Override\n    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {\n        log.info(\"ShardMapManagerFactory {}, Started creating Global Shard Map structures.\", this.getOperationName());\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n\n        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));\n\n        // If we did find some store deployed.\n        if (checkResult.getStoreVersion() != null) {\n            // DevNote: We need to have a way to error out if versions do not match.\n            if (createMode == ShardMapManagerCreateMode.KeepExisting) {\n                stopwatch.stop();\n                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory,\n                        ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);\n            }\n\n            log.info(\"ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.\", this.getOperationName());\n\n            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());\n        }\n\n        // Deploy initial version and run upgrade script to bring it to the specified version.\n        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());\n\n        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));\n\n        stopwatch.stop();\n\n        log.info(\"ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}\", this.getOperationName(),\n                stopwatch.elapsed(TimeUnit.MILLISECONDS));\n\n        return new StoreResults();\n    }\n\n    /**\n     * Handles errors from the GSM operation after the LSM operations.\n     *\n     * @param result\n     *            Operation result.\n     */\n    @Override\n    public void handleDoGlobalExecuteError(StoreResults result) {\n        log.debug(\"Always expect Success or Exception from DoGlobalExecute.\");\n    }\n\n    /**\n     * Error category for store exception.\n     */\n    @Override\n    protected ShardManagementErrorCategory getErrorCategory() {\n        return ShardManagementErrorCategory.ShardMapManagerFactory;\n    }\n}", "class_id": 0, "repo": "Blackbaud-MattWalsh/elastic-db-tools-for-java", "file": "elastic-db-tools/src/main/java/com/microsoft/azure/elasticdb/shard/storeops/mapmanagerfactory/CreateShardMapManagerGlobalOperation.java", "last_update_at": "2021-12-07T18:21:33+00:00", "question_id": "c6ec38e3aa543ebec430a9ccbdb14ad544958a43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {\n    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    /**\n     * Creation mode.\n     */\n    private ShardMapManagerCreateMode createMode;\n    /**\n     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.\n     */\n    private Version targetVersion;\n    /**\n     * Constructs request for deploying SMM storage objects to target GSM database.\n     *\n     * @param credentials\n     *            Credentials for connection.\n     * @param retryPolicy\n     *            Retry policy.\n     * @param operationName\n     *            Operation name, useful for diagnostics.\n     * @param createMode\n     *            Creation mode.\n     * @param targetVersion\n     *            target version of store to deploy\n     */\n    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials,\n            RetryPolicy retryPolicy,\n            String operationName,\n            ShardMapManagerCreateMode createMode,\n            Version targetVersion) {\n        super(credentials, retryPolicy, operationName);\n        this.createMode = createMode;\n        this.targetVersion = targetVersion;\n    }\n    /**\n     * Whether this is a read-only operation.\n     */\n    @Override\n    public boolean getReadOnly() {\n        return false;\n    }\n    /**\n     * Execute the operation against GSM in the current transaction scope.\n     *\n     * @param ts\n     *            Transaction scope.\n     * @return Results of the operation.\n     */\n    @Override\n    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {\n        log.info(\"ShardMapManagerFactory {}, Started creating Global Shard Map structures.\", this.getOperationName());\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));\n        // If we did find some store deployed.\n        if (checkResult.getStoreVersion() != null) {\n            // DevNote: We need to have a way to error out if versions do not match.\n            if (createMode == ShardMapManagerCreateMode.KeepExisting) {\n                stopwatch.stop();\n                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory,\n                        ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);\n            }\n            log.info(\"ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.\", this.getOperationName());\n            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());\n        }\n        // Deploy initial version and run upgrade script to bring it to the specified version.\n        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());\n        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));\n        stopwatch.stop();\n        log.info(\"ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}\", this.getOperationName(),\n                stopwatch.elapsed(TimeUnit.MILLISECONDS));\n        return new StoreResults();\n    }\n    /**\n     * Handles errors from the GSM operation after the LSM operations.\n     *\n     * @param result\n     *            Operation result.\n     */\n    @Override\n    public void handleDoGlobalExecuteError(StoreResults result) {\n        log.debug(\"Always expect Success or Exception from DoGlobalExecute.\");\n    }\n    /**\n     * Error category for store exception.\n     */\n    @Override\n    protected ShardManagementErrorCategory getErrorCategory() {\n        return ShardManagementErrorCategory.ShardMapManagerFactory;\n    }\n"]]}
{"hexsha": "11992b1676761a8e7bb5d9a4c39bd1a80802e4e0", "ext": "java", "lang": "Java", "content": "public class DateTest implements Predicate<Object> {\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public boolean test(Object o) {\r\n        if (!(o instanceof Map))\r\n            return false;\r\n\r\n        Map<String, Object> m = (Map<String, Object>) o;\r\n        return m.containsKey(\"$date\");\r\n    }\r\n}", "class_id": 0, "repo": "ozwolf-software/mongo-trek", "file": "src/main/java/net/ozwolf/mongo/migrations/internal/util/strict/test/DateTest.java", "last_update_at": "2021-11-05T13:13:10+00:00", "question_id": "11992b1676761a8e7bb5d9a4c39bd1a80802e4e0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DateTest implements Predicate<Object> {\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public boolean test(Object o) {\r\n        if (!(o instanceof Map))\r\n            return false;\r\n\r\n        Map<String, Object> m = (Map<String, Object>) o;\r\n        return m.containsKey(\"$date\");\r\n    }\r\n"]]}
{"hexsha": "471abfbcd5ea2120b3ab3a2bcc2caedb5f103606", "ext": "java", "lang": "Java", "content": "public class CustomInlineFunctions {\n\t\n\t// declare log services\n\tprivate LogServices log = LogServices.getInstance(\"wbtServices\");\n\n\t\t\n\tpublic String doSample(String value) {\n\t\t\n\t\tlog.debug(\"wbtServices\", \"WebertiseInlineFunctions - doSample: got value '\" + value + \"'\");\n\t\t\n\t\t// do something\n\t\t\n\t\t\n\t\treturn value;\n\t}\n\n}", "class_id": 0, "repo": "bernfried/wbf-framework", "file": "dsextensions/src/de/webertise/ds/inlinefunctions/CustomInlineFunctions.java", "last_update_at": "2021-01-15T02:53:06+00:00", "question_id": "471abfbcd5ea2120b3ab3a2bcc2caedb5f103606", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomInlineFunctions {\n\t\n\t// declare log services\n\tprivate LogServices log = LogServices.getInstance(\"wbtServices\");\n\t\t\n\tpublic String doSample(String value) {\n\t\t\n\t\tlog.debug(\"wbtServices\", \"WebertiseInlineFunctions - doSample: got value '\" + value + \"'\");\n\t\t\n\t\t// do something\n\t\t\n\t\t\n\t\treturn value;\n\t}\n"]]}
{"hexsha": "f7178660a3d266187dc4287ef23abc8f0a527d87", "ext": "java", "lang": "Java", "content": "public class AbstractDRResourceProviderTest {\n  @Test\n  public void testGetResourceProvider() throws Exception {\n    Set<String> propertyIds = new HashSet<String>();\n    propertyIds.add(\"foo\");\n    propertyIds.add(\"cat1/foo\");\n    propertyIds.add(\"cat2/bar\");\n    propertyIds.add(\"cat2/baz\");\n    propertyIds.add(\"cat3/sub1/bam\");\n    propertyIds.add(\"cat4/sub2/sub3/bat\");\n    propertyIds.add(\"cat5/subcat5/map\");\n\n    Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();\n\n    IvoryService ivoryService = createMock(IvoryService.class);\n\n    AbstractResourceProvider provider =\n        (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(\n            Resource.Type.DRFeed,\n            propertyIds,\n            keyPropertyIds,\n            ivoryService);\n\n    Assert.assertTrue(provider instanceof FeedResourceProvider);\n  }\n}", "class_id": 0, "repo": "dawnwish/ambari", "file": "ambari-server/src/test/java/org/apache/ambari/server/controller/internal/AbstractDRResourceProviderTest.java", "last_update_at": "2021-08-05T03:13:26+00:00", "question_id": "f7178660a3d266187dc4287ef23abc8f0a527d87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbstractDRResourceProviderTest {\n  @Test\n  public void testGetResourceProvider() throws Exception {\n    Set<String> propertyIds = new HashSet<String>();\n    propertyIds.add(\"foo\");\n    propertyIds.add(\"cat1/foo\");\n    propertyIds.add(\"cat2/bar\");\n    propertyIds.add(\"cat2/baz\");\n    propertyIds.add(\"cat3/sub1/bam\");\n    propertyIds.add(\"cat4/sub2/sub3/bat\");\n    propertyIds.add(\"cat5/subcat5/map\");\n    Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();\n    IvoryService ivoryService = createMock(IvoryService.class);\n    AbstractResourceProvider provider =\n        (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(\n            Resource.Type.DRFeed,\n            propertyIds,\n            keyPropertyIds,\n            ivoryService);\n    Assert.assertTrue(provider instanceof FeedResourceProvider);\n  }\n"]]}
{"hexsha": "7cbaabecd2cc61947ab6279a547d2c9290a3bb1e", "ext": "java", "lang": "Java", "content": "@Path(\"/shop\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ShoppingController {\n    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);\n    private final StylingApi stylingApi;\n\n    ShoppingController() {\n        String stylingUrl = \"http://localhost:50051\";\n        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;\n        // wavefrontJaxrsFilter = wfJaxrsClientFilter;\n        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);\n    }\n\n    @GET\n    @Path(\"/menu\")\n    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {\n        return Response.ok(stylingApi.getAllStyles()).build();\n    }\n\n    @POST\n    @Path(\"/order\")\n    @Consumes(APPLICATION_JSON)\n    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {\n        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();\n        }\n        Response deliveryResponse = stylingApi.makeShirts(\n                orderDTO.getStyleName(), orderDTO.getQuantity());\n        if (deliveryResponse.getStatus() < 400) {\n            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);\n            return Response.ok().entity(deliveryStatus).build();\n        } else {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(deliveryResponse.getStatus()).entity(msg).build();\n        }\n    }\n}", "class_id": 0, "repo": "scrogatl/otel-demo-app-java", "file": "shopping/src/main/java/com/wfsample/shopping/ShoppingController.java", "last_update_at": "2021-06-21T13:56:10+00:00", "question_id": "7cbaabecd2cc61947ab6279a547d2c9290a3bb1e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Path(\"/shop\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ShoppingController {\n    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);\n    private final StylingApi stylingApi;\n    ShoppingController() {\n        String stylingUrl = \"http://localhost:50051\";\n        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;\n        // wavefrontJaxrsFilter = wfJaxrsClientFilter;\n        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);\n    }\n    @GET\n    @Path(\"/menu\")\n    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {\n        return Response.ok(stylingApi.getAllStyles()).build();\n    }\n    @POST\n    @Path(\"/order\")\n    @Consumes(APPLICATION_JSON)\n    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {\n        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();\n        }\n        Response deliveryResponse = stylingApi.makeShirts(\n                orderDTO.getStyleName(), orderDTO.getQuantity());\n        if (deliveryResponse.getStatus() < 400) {\n            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);\n            return Response.ok().entity(deliveryStatus).build();\n        } else {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(deliveryResponse.getStatus()).entity(msg).build();\n        }\n    }\n"]]}
{"hexsha": "d8c97610050943cdf2ccaade422a76ac48e11c71", "ext": "java", "lang": "Java", "content": "public class B_SuperClass {\n    public static void main(String[] args) {\n        Class<?> clazz = Example_B_SuperClass.class;\n        Class<?> superclass = clazz.getSuperclass();\n        System.out.println(superclass);\n    }\n}", "class_id": 0, "repo": "lsieun/learn-java", "file": "Reflection/code/learn-reflection/src/main/java/lsieun/reflection/a_clazz/B_SuperClass.java", "last_update_at": "2021-03-24T23:13:33+00:00", "question_id": "d8c97610050943cdf2ccaade422a76ac48e11c71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class B_SuperClass {\n    public static void main(String[] args) {\n        Class<?> clazz = Example_B_SuperClass.class;\n        Class<?> superclass = clazz.getSuperclass();\n        System.out.println(superclass);\n    }\n"]]}
{"hexsha": "21ca9661f3376f46943fd2a0ddc93a92bb03a6a3", "ext": "java", "lang": "Java", "content": "public class MvnModelFactory {\r\n    \r\n    public Model createModel(Project project) throws MvnModelInputException{\r\n        return createModel(project.getProjectDirectory());\r\n    }\r\n    \r\n    public Model createModel(FileObject projectDir) throws MvnModelInputException {\r\n        FileObject pomFile = projectDir.getFileObject(\"pom.xml\");\r\n        MavenXpp3Reader mavenreader = new MavenXpp3Reader();\r\n        try(Reader reader=new InputStreamReader(pomFile.getInputStream())){\r\n            Model model = mavenreader.read(reader);\r\n            model.setPomFile(new File(pomFile.getPath()));\r\n            return model;\r\n        }catch(XmlPullParserException | IOException ex) {\r\n            throw new MvnModelInputException(ex);\r\n        }\r\n    }\r\n    \r\n}", "class_id": 0, "repo": "hmvictor/radar-netbeans", "file": "src/main/java/qubexplorer/MvnModelFactory.java", "last_update_at": "2021-11-14T19:52:07+00:00", "question_id": "21ca9661f3376f46943fd2a0ddc93a92bb03a6a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MvnModelFactory {\r\n    \r\n    public Model createModel(Project project) throws MvnModelInputException{\r\n        return createModel(project.getProjectDirectory());\r\n    }\r\n    \r\n    public Model createModel(FileObject projectDir) throws MvnModelInputException {\r\n        FileObject pomFile = projectDir.getFileObject(\"pom.xml\");\r\n        MavenXpp3Reader mavenreader = new MavenXpp3Reader();\r\n        try(Reader reader=new InputStreamReader(pomFile.getInputStream())){\r\n            Model model = mavenreader.read(reader);\r\n            model.setPomFile(new File(pomFile.getPath()));\r\n            return model;\r\n        }catch(XmlPullParserException | IOException ex) {\r\n            throw new MvnModelInputException(ex);\r\n        }\r\n    }\r\n    \r\n"]]}
{"hexsha": "3037ceb3997c55c745d234f6205a58fc66497019", "ext": "java", "lang": "Java", "content": "public class PushNotificationCallback{\n    private String email;\n    private String url;\n\n    public PushNotificationCallback(Context appContext){\n        Breadcaster caster = new Breadcaster(appContext)\n                .action(\"1\", new Execution() {\n                    @Override\n                    public void exec(Context context, Intent intent) {\n                        String email = intent.getStringExtra(\"email\");\n                        if(email != null){\n                            PushNotificationCallback.this.email = email;\n                            String url = intent.getStringExtra(\"url\");\n                            PushNotificationCallback.this.url = url;\n                        }\n\n                        System.out.println(\"****PUSH_NOTIFICATION_CALLBACK_INVOKED*****\");\n                        System.out.println(email+\":\"+MyFirebaseMessagingService.pushToken+\":\"+url);\n\n                        if(PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null){\n                            return;\n                        }\n                        Thread t = new Thread(()->{\n                            URL urlValue = null;\n                            HttpsURLConnection urlConnection = null;\n                            String json = null;\n                            OutputStreamWriter writer = null;\n                            BufferedReader reader = null;\n                            try {\n                                urlValue = new URL(PushNotificationCallback.this.url);\n                                urlConnection = (HttpsURLConnection) urlValue.openConnection();\n                                urlConnection.setDoOutput(true);\n\n                                JSONObject jsonObject = new JSONObject();\n                                jsonObject.put(\"email\",PushNotificationCallback.this.email);\n                                jsonObject.put(\"pushToken\",MyFirebaseMessagingService.pushToken);\n                                json = jsonObject.toString();\n\n                                writer = new OutputStreamWriter(urlConnection.getOutputStream());\n                                writer.write(json);\n                                writer.flush();\n\n                                reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                                StringBuilder sb = new StringBuilder();\n                                String line = null;\n                                // Read Server Response\n                                while((line = reader.readLine()) != null)\n                                {\n                                    // Append server response in string\n                                    sb.append(line + \"\\n\");\n                                }\n                                System.out.println(\"TOKEN_REGISTRATION_SUCCESS: \"+sb);\n                            }catch(Exception e){\n                                //e.printStackTrace();\n                            }finally {\n                                if(urlConnection != null) {\n                                    urlConnection.disconnect();\n                                }\n                                try {\n                                    if(writer != null) {\n                                        writer.close();\n                                    }\n                                    if(reader != null) {\n                                        reader.close();\n                                    }\n                                }catch(Exception e){}\n                            }\n                        });\n                        t.start();\n                    }\n                }).register();\n    }\n}", "class_id": 0, "repo": "slydogshah/appGalCloud", "file": "jennetapp/android/app/src/main/java/io/appgallabs/jennetwork/PushNotificationCallback.java", "last_update_at": "2021-06-17T13:29:02+00:00", "question_id": "3037ceb3997c55c745d234f6205a58fc66497019", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PushNotificationCallback{\n    private String email;\n    private String url;\n    public PushNotificationCallback(Context appContext){\n        Breadcaster caster = new Breadcaster(appContext)\n                .action(\"1\", new Execution() {\n                    @Override\n                    public void exec(Context context, Intent intent) {\n                        String email = intent.getStringExtra(\"email\");\n                        if(email != null){\n                            PushNotificationCallback.this.email = email;\n                            String url = intent.getStringExtra(\"url\");\n                            PushNotificationCallback.this.url = url;\n                        }\n                        System.out.println(\"****PUSH_NOTIFICATION_CALLBACK_INVOKED*****\");\n                        System.out.println(email+\":\"+MyFirebaseMessagingService.pushToken+\":\"+url);\n                        if(PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null){\n                            return;\n                        }\n                        Thread t = new Thread(()->{\n                            URL urlValue = null;\n                            HttpsURLConnection urlConnection = null;\n                            String json = null;\n                            OutputStreamWriter writer = null;\n                            BufferedReader reader = null;\n                            try {\n                                urlValue = new URL(PushNotificationCallback.this.url);\n                                urlConnection = (HttpsURLConnection) urlValue.openConnection();\n                                urlConnection.setDoOutput(true);\n                                JSONObject jsonObject = new JSONObject();\n                                jsonObject.put(\"email\",PushNotificationCallback.this.email);\n                                jsonObject.put(\"pushToken\",MyFirebaseMessagingService.pushToken);\n                                json = jsonObject.toString();\n                                writer = new OutputStreamWriter(urlConnection.getOutputStream());\n                                writer.write(json);\n                                writer.flush();\n                                reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                                StringBuilder sb = new StringBuilder();\n                                String line = null;\n                                // Read Server Response\n                                while((line = reader.readLine()) != null)\n                                {\n                                    // Append server response in string\n                                    sb.append(line + \"\\n\");\n                                }\n                                System.out.println(\"TOKEN_REGISTRATION_SUCCESS: \"+sb);\n                            }catch(Exception e){\n                                //e.printStackTrace();\n                            }finally {\n                                if(urlConnection != null) {\n                                    urlConnection.disconnect();\n                                }\n                                try {\n                                    if(writer != null) {\n                                        writer.close();\n                                    }\n                                    if(reader != null) {\n                                        reader.close();\n                                    }\n                                }catch(Exception e){}\n                            }\n                        });\n                        t.start();\n                    }\n                }).register();\n    }\n"]]}
{"hexsha": "27a89c084d6ab746c2199fdd9f7518ada1b9eea9", "ext": "java", "lang": "Java", "content": "public class ArrayTypeReference extends SingleTypeReference {\n\n    public int dimensions;\n\n    // jsr308 style type annotations on dimensions.\n    private Annotation[][] annotationsOnDimensions;\n\n    public int originalSourceEnd;\n\n    public int extendedDimensions;\n\n    /**\n\t * ArrayTypeReference constructor comment.\n\t * @param source char[]\n\t * @param dimensions int\n\t * @param pos int\n\t */\n    public  ArrayTypeReference(char[] source, int dimensions, long pos) {\n        super(source, pos);\n        this.originalSourceEnd = this.sourceEnd;\n        this.dimensions = dimensions;\n        this.annotationsOnDimensions = null;\n    }\n\n    public  ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {\n        this(source, dimensions, pos);\n        if (annotationsOnDimensions != null) {\n            this.bits |= ASTNode.HasTypeAnnotations;\n        }\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    public int dimensions() {\n        return this.dimensions;\n    }\n\n    public int extraDimensions() {\n        return this.extendedDimensions;\n    }\n\n    /**\n\t @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)\n\t*/\n    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {\n        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)\n            return this.annotationsOnDimensions;\n        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];\n        final int baseDimensions = this.dimensions - this.extendedDimensions;\n        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);\n        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);\n        return externalAnnotations;\n    }\n\n    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    /**\n\t * @return char[][]\n\t */\n    public char[][] getParameterizedTypeName() {\n        int dim = this.dimensions;\n        char[] dimChars = new char[dim * 2];\n        for (int i = 0; i < dim; i++) {\n            int index = i * 2;\n            dimChars[index] = '[';\n            dimChars[index + 1] = ']';\n        }\n        return new char[][] { CharOperation.concat(this.token, dimChars) };\n    }\n\n    protected TypeBinding getTypeBinding(Scope scope) {\n        if (this.resolvedType != null) {\n            return this.resolvedType;\n        }\n        if (this.dimensions > 255) {\n            scope.problemReporter().tooManyDimensions(this);\n        }\n        TypeBinding leafComponentType = scope.getType(this.token);\n        return scope.createArrayType(leafComponentType, this.dimensions);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        super.printExpression(indent, output);\n        if ((this.bits & IsVarArgs) != 0) {\n            for (int i = 0; i < this.dimensions - 1; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    output.append(' ');\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    output.append(' ');\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {\n                output.append(' ');\n                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);\n                output.append(' ');\n            }\n            //$NON-NLS-1$\n            output.append(\"...\");\n        } else {\n            for (int i = 0; i < this.dimensions; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n        }\n        return output;\n    }\n\n    public void traverse(ASTVisitor visitor, BlockScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    public void traverse(ASTVisitor visitor, ClassScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    protected TypeBinding internalResolveType(Scope scope, int location) {\n        TypeBinding internalResolveType = super.internalResolveType(scope, location);\n        return internalResolveType;\n    }\n\n    @Override\n    public boolean hasNullTypeAnnotation(AnnotationPosition position) {\n        switch(position) {\n            case LEAF_TYPE:\n                // ignore annotationsOnDimensions:\n                return super.hasNullTypeAnnotation(position);\n            case MAIN_TYPE:\n                // outermost dimension only:\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {\n                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];\n                    return containsNullAnnotation(innerAnnotations);\n                }\n                break;\n            case ANY:\n                if (super.hasNullTypeAnnotation(position))\n                    return true;\n                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())\n                    // shortcut\n                    return false;\n                if (this.annotationsOnDimensions != null) {\n                    for (int i = 0; i < this.annotationsOnDimensions.length; i++) {\n                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];\n                        if (containsNullAnnotation(innerAnnotations))\n                            return true;\n                    }\n                }\n        }\n        return false;\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.core/4509.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "27a89c084d6ab746c2199fdd9f7518ada1b9eea9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ArrayTypeReference extends SingleTypeReference {\n    public int dimensions;\n    // jsr308 style type annotations on dimensions.\n    private Annotation[][] annotationsOnDimensions;\n    public int originalSourceEnd;\n    public int extendedDimensions;\n    /**\n\t * ArrayTypeReference constructor comment.\n\t * @param source char[]\n\t * @param dimensions int\n\t * @param pos int\n\t */\n    public  ArrayTypeReference(char[] source, int dimensions, long pos) {\n        super(source, pos);\n        this.originalSourceEnd = this.sourceEnd;\n        this.dimensions = dimensions;\n        this.annotationsOnDimensions = null;\n    }\n    public  ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {\n        this(source, dimensions, pos);\n        if (annotationsOnDimensions != null) {\n            this.bits |= ASTNode.HasTypeAnnotations;\n        }\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n    public int dimensions() {\n        return this.dimensions;\n    }\n    public int extraDimensions() {\n        return this.extendedDimensions;\n    }\n    /**\n\t @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)\n\t*/\n    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {\n        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)\n            return this.annotationsOnDimensions;\n        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];\n        final int baseDimensions = this.dimensions - this.extendedDimensions;\n        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);\n        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);\n        return externalAnnotations;\n    }\n    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n    /**\n\t * @return char[][]\n\t */\n    public char[][] getParameterizedTypeName() {\n        int dim = this.dimensions;\n        char[] dimChars = new char[dim * 2];\n        for (int i = 0; i < dim; i++) {\n            int index = i * 2;\n            dimChars[index] = '[';\n            dimChars[index + 1] = ']';\n        }\n        return new char[][] { CharOperation.concat(this.token, dimChars) };\n    }\n    protected TypeBinding getTypeBinding(Scope scope) {\n        if (this.resolvedType != null) {\n            return this.resolvedType;\n        }\n        if (this.dimensions > 255) {\n            scope.problemReporter().tooManyDimensions(this);\n        }\n        TypeBinding leafComponentType = scope.getType(this.token);\n        return scope.createArrayType(leafComponentType, this.dimensions);\n    }\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        super.printExpression(indent, output);\n        if ((this.bits & IsVarArgs) != 0) {\n            for (int i = 0; i < this.dimensions - 1; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    output.append(' ');\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    output.append(' ');\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {\n                output.append(' ');\n                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);\n                output.append(' ');\n            }\n            //$NON-NLS-1$\n            output.append(\"...\");\n        } else {\n            for (int i = 0; i < this.dimensions; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    //$NON-NLS-1$\n                    output.append(//$NON-NLS-1$\n                    \" \");\n                }\n                //$NON-NLS-1$\n                output.append(//$NON-NLS-1$\n                \"[]\");\n            }\n        }\n        return output;\n    }\n    public void traverse(ASTVisitor visitor, BlockScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n    public void traverse(ASTVisitor visitor, ClassScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n    protected TypeBinding internalResolveType(Scope scope, int location) {\n        TypeBinding internalResolveType = super.internalResolveType(scope, location);\n        return internalResolveType;\n    }\n    @Override\n    public boolean hasNullTypeAnnotation(AnnotationPosition position) {\n        switch(position) {\n            case LEAF_TYPE:\n                // ignore annotationsOnDimensions:\n                return super.hasNullTypeAnnotation(position);\n            case MAIN_TYPE:\n                // outermost dimension only:\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {\n                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];\n                    return containsNullAnnotation(innerAnnotations);\n                }\n                break;\n            case ANY:\n                if (super.hasNullTypeAnnotation(position))\n                    return true;\n                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())\n                    // shortcut\n                    return false;\n                if (this.annotationsOnDimensions != null) {\n                    for (int i = 0; i < this.annotationsOnDimensions.length; i++) {\n                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];\n                        if (containsNullAnnotation(innerAnnotations))\n                            return true;\n                    }\n                }\n        }\n        return false;\n    }\n"]]}
{"hexsha": "6ba2c65ef09c9dce214c0d5ad690323d7dcafe61", "ext": "java", "lang": "Java", "content": "public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {\n\n    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext,\n                                                                         ClassLoader classLoader,\n                                                                         List<URL> resources) {\n        if (classLoader == null) {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        }\n\n        SCAGenericApplicationContext appCtx =\n            new SCAGenericApplicationContext((ApplicationContext)scaParentContext, classLoader);\n        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);\n\n        // REVIEW: [rfeng] How do we control the schema validation \n        xmlReader.setValidating(false);\n\n        for (URL resource : resources) {\n            xmlReader.loadBeanDefinitions(new UrlResource(resource));\n        }\n\n        return appCtx;\n\n    }\n\n    @Override\n    public Object load(List<URL> resources,\n                       List<SpringSCAServiceElement> serviceElements,\n                       List<SpringSCAReferenceElement> referenceElements,\n                       List<SpringSCAPropertyElement> propertyElements,\n                       List<SpringBeanElement> beanElements,\n                       ProcessorContext context) {\n        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime\n        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);\n        serviceElements.addAll(applicationContext.getServiceElements());\n        referenceElements.addAll(applicationContext.getReferenceElements());\n        propertyElements.addAll(applicationContext.getPropertyElements());\n        beanElements.addAll(applicationContext.getBeanElements());\n        return applicationContext;\n    }\n\n}", "class_id": 0, "repo": "apache/tuscany-sca-2.x", "file": "modules/implementation-spring-runtime/src/main/java/org/apache/tuscany/sca/implementation/spring/processor/SpringXMLBeanDefinitionLoaderImpl.java", "last_update_at": "2021-11-10T16:04:56+00:00", "question_id": "6ba2c65ef09c9dce214c0d5ad690323d7dcafe61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {\n    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext,\n                                                                         ClassLoader classLoader,\n                                                                         List<URL> resources) {\n        if (classLoader == null) {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        }\n        SCAGenericApplicationContext appCtx =\n            new SCAGenericApplicationContext((ApplicationContext)scaParentContext, classLoader);\n        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);\n        // REVIEW: [rfeng] How do we control the schema validation \n        xmlReader.setValidating(false);\n        for (URL resource : resources) {\n            xmlReader.loadBeanDefinitions(new UrlResource(resource));\n        }\n        return appCtx;\n    }\n    @Override\n    public Object load(List<URL> resources,\n                       List<SpringSCAServiceElement> serviceElements,\n                       List<SpringSCAReferenceElement> referenceElements,\n                       List<SpringSCAPropertyElement> propertyElements,\n                       List<SpringBeanElement> beanElements,\n                       ProcessorContext context) {\n        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime\n        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);\n        serviceElements.addAll(applicationContext.getServiceElements());\n        referenceElements.addAll(applicationContext.getReferenceElements());\n        propertyElements.addAll(applicationContext.getPropertyElements());\n        beanElements.addAll(applicationContext.getBeanElements());\n        return applicationContext;\n    }\n"]]}
{"hexsha": "278ec218a2e650deb4500198e2ed05508b55549c", "ext": "java", "lang": "Java", "content": "public class Builders {\n    private Builders() {\n    }\n\n    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();\n\n    static {\n        map.put(User.class, new UserBuilder());\n        map.put(Content.class, new ContentBuilder());\n        map.put(Company.class, new CompanyBuilder());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {\n        K builder = (K) map.get(clazz);\n        if (builder == null) throw new IllegalArgumentException(\"No builder for entity: \" + clazz.getName());\n        return (K) builder.newInstance();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {\n        if (entity == null) throw new IllegalArgumentException(\"Entity should not be a null.\");\n\n        K builder = (K) map.get(entity.getClass());\n\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + entity.getClass().getName());\n\n        return (K) builder.newInstance(entity);\n    }\n\n\n}", "class_id": 0, "repo": "Pivopil/spring-boot-oauth2-rest-service-password-encoding", "file": "share/src/main/java/io/github/pivopil/share/builders/Builders.java", "last_update_at": "2021-04-25T08:44:09+00:00", "question_id": "278ec218a2e650deb4500198e2ed05508b55549c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Builders {\n    private Builders() {\n    }\n    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();\n    static {\n        map.put(User.class, new UserBuilder());\n        map.put(Content.class, new ContentBuilder());\n        map.put(Company.class, new CompanyBuilder());\n    }\n    @SuppressWarnings(\"unchecked\")\n    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {\n        K builder = (K) map.get(clazz);\n        if (builder == null) throw new IllegalArgumentException(\"No builder for entity: \" + clazz.getName());\n        return (K) builder.newInstance();\n    }\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {\n        if (entity == null) throw new IllegalArgumentException(\"Entity should not be a null.\");\n        K builder = (K) map.get(entity.getClass());\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + entity.getClass().getName());\n        return (K) builder.newInstance(entity);\n    }\n"]]}
{"hexsha": "cda831809d818cc9f3aa657b63679325f432741b", "ext": "java", "lang": "Java", "content": "public class ObsidianShard extends Item {\n    public ObsidianShard() {\n        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));\n    }\n\n    @Override\n    @ParametersAreNonnullByDefault\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {\n        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);\n        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS))\n                .orElse(0D);\n        if (overworldAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.overworld_attunement_message\", String.format(\"%.2f\", overworldAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.BLUE));\n        }\n        if (netherAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.nether_attunement_message\", String.format(\"%.2f\", netherAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.RED));\n        }\n        if (endAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.end_attunement_message\", String.format(\"%.2f\", endAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.AQUA));\n        }\n    }\n}", "class_id": 0, "repo": "Pursuit-of-Glowstone/Obsidimancy", "file": "src/main/java/com/pursuitofglowstone/obsidimancy/items/ObsidianShard.java", "last_update_at": "2021-09-18T17:27:15+00:00", "question_id": "cda831809d818cc9f3aa657b63679325f432741b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ObsidianShard extends Item {\n    public ObsidianShard() {\n        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));\n    }\n    @Override\n    @ParametersAreNonnullByDefault\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {\n        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);\n        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS))\n                .orElse(0D);\n        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag())\n                .map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS))\n                .orElse(0D);\n        if (overworldAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.overworld_attunement_message\", String.format(\"%.2f\", overworldAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.BLUE));\n        }\n        if (netherAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.nether_attunement_message\", String.format(\"%.2f\", netherAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.RED));\n        }\n        if (endAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.end_attunement_message\", String.format(\"%.2f\", endAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.AQUA));\n        }\n    }\n"]]}
{"hexsha": "00bef6747de51bf67fa009897a672aaff33c027a", "ext": "java", "lang": "Java", "content": "@Component\r\npublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {\r\n\r\n    @Override\r\n    public TResponse send(TRequest request, Handler handler) {\r\n        return (TResponse) handler.handle(request);\r\n\r\n//        try {\r\n//\r\n//            ApplicationContext applicationContext = SpringbootBeanHelper.getApplicationContext();\r\n//\r\n//            // todo: find class that extend request\r\n//            Class<?> clazz = request.getClass();\r\n//\r\n//            Class<?> entityType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommand\");\r\n//\r\n//            Class<?> handlerType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommandHandler\");\r\n//\r\n//            //Reflection setting method parameters.\r\n//            Method method = handlerType.getDeclaredMethod(\"handle\",entityType);\r\n//\r\n//            //Remove the instantiated bean according to the class in the ApplicationContext\r\n//            method.invoke(applicationContext.getBean(handlerType), new Object[] {new AddInventoryCommand()});\r\n//\r\n//            return null;\r\n//        } catch (Exception ex) {\r\n//            return null;\r\n//        }\r\n    }\r\n}", "class_id": 0, "repo": "unsri-hackers/ecommerce", "file": "src/main/java/com/unsri/ecommerce/infrastructure/mediator/MediatorImpl.java", "last_update_at": "2021-07-12T08:08:01+00:00", "question_id": "00bef6747de51bf67fa009897a672aaff33c027a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\r\npublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {\r\n\r\n    @Override\r\n    public TResponse send(TRequest request, Handler handler) {\r\n        return (TResponse) handler.handle(request);\r\n\r\n//        try {\r\n//\r\n//            ApplicationContext applicationContext = SpringbootBeanHelper.getApplicationContext();\r\n//\r\n//            // todo: find class that extend request\r\n//            Class<?> clazz = request.getClass();\r\n//\r\n//            Class<?> entityType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommand\");\r\n//\r\n//            Class<?> handlerType = Class.forName(\"com.unsri.ecommerce.application.behaviours.inventory.commands.AddInventoryCommandHandler\");\r\n//\r\n//            //Reflection setting method parameters.\r\n//            Method method = handlerType.getDeclaredMethod(\"handle\",entityType);\r\n//\r\n//            //Remove the instantiated bean according to the class in the ApplicationContext\r\n//            method.invoke(applicationContext.getBean(handlerType), new Object[] {new AddInventoryCommand()});\r\n//\r\n//            return null;\r\n//        } catch (Exception ex) {\r\n//            return null;\r\n//        }\r\n    }\r\n"]]}
{"hexsha": "0d702eb90f1c4fb17696cc6f6afccd963790a157", "ext": "java", "lang": "Java", "content": "@ExtendWith(SiriusExtension.class)\nclass XMLReaderTest {\n\n    @Test\n    @DisplayName(\"XMLReader extracts XPATH expression\")\n    void readXpath() throws Exception {\n        ValueHolder<String> readString = ValueHolder.of(null);\n        Counter nodeCount = new Counter();\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            nodeCount.inc();\n            readString.set(node.queryString(\"value\"));\n        });\n\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n\n        assertEquals(\"5\", readString.get());\n        assertEquals(3, nodeCount.getCount(), \"parsed invalid count of nodes\");\n    }\n\n    @Test\n    @DisplayName(\"XMLReader supports compound XPATH paths\")\n    void readXpathCompound() throws Exception {\n        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);\n        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"doc/test/value\", node -> shouldToggle.set(true));\n        reader.addHandler(\"value\", node -> shouldNotToggle.set(true));\n\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n\n        assertTrue(shouldToggle.get());\n        assertFalse(shouldNotToggle.get());\n    }\n\n    @Test\n    @DisplayName(\"XMLReader reads attributes\")\n    void readXpathAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n\n        reader.parse(new ByteArrayInputStream(\"<doc><test namedAttribute=\\\"abc\\\" namedAttribute2=\\\"xyz\\\">1</test></doc>\".getBytes()));\n\n        assertEquals(2, attributes.size());\n        assertEquals(\"abc\", attribute.get());\n    }\n\n    @Test\n    @DisplayName(\"reading non existing attributes does not throw errors\")\n    void readXpathMissingAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"wrongValue\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n\n        reader.parse(new ByteArrayInputStream(\"<doc><test>1</test></doc>\".getBytes()));\n\n        assertEquals(0, attributes.size());\n        assertEquals(\"\", attribute.get());\n    }\n}", "class_id": 0, "repo": "scireum/sirius-kernel", "file": "src/test/java/sirius/kernel/xml/XMLReaderTest.java", "last_update_at": "2021-11-24T01:29:39+00:00", "question_id": "0d702eb90f1c4fb17696cc6f6afccd963790a157", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ExtendWith(SiriusExtension.class)\nclass XMLReaderTest {\n    @Test\n    @DisplayName(\"XMLReader extracts XPATH expression\")\n    void readXpath() throws Exception {\n        ValueHolder<String> readString = ValueHolder.of(null);\n        Counter nodeCount = new Counter();\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            nodeCount.inc();\n            readString.set(node.queryString(\"value\"));\n        });\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertEquals(\"5\", readString.get());\n        assertEquals(3, nodeCount.getCount(), \"parsed invalid count of nodes\");\n    }\n    @Test\n    @DisplayName(\"XMLReader supports compound XPATH paths\")\n    void readXpathCompound() throws Exception {\n        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);\n        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"doc/test/value\", node -> shouldToggle.set(true));\n        reader.addHandler(\"value\", node -> shouldNotToggle.set(true));\n        reader.parse(new ByteArrayInputStream(\n                \"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertTrue(shouldToggle.get());\n        assertFalse(shouldNotToggle.get());\n    }\n    @Test\n    @DisplayName(\"XMLReader reads attributes\")\n    void readXpathAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test namedAttribute=\\\"abc\\\" namedAttribute2=\\\"xyz\\\">1</test></doc>\".getBytes()));\n        assertEquals(2, attributes.size());\n        assertEquals(\"abc\", attribute.get());\n    }\n    @Test\n    @DisplayName(\"reading non existing attributes does not throw errors\")\n    void readXpathMissingAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"wrongValue\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test>1</test></doc>\".getBytes()));\n        assertEquals(0, attributes.size());\n        assertEquals(\"\", attribute.get());\n    }\n"]]}
{"hexsha": "16a60673c47ed31ef3e70caf496702cafa6f7bfd", "ext": "java", "lang": "Java", "content": "public class KeyItem extends Item {\n    public static final String ID = \"lock_key\";\n    public static final String TEX_BASE = \"lock_key_\";\n    private static final int ICONS_COUNT = 3;\n\n    private IIcon[] icons = new IIcon[ICONS_COUNT];\n\n    public KeyItem() {\n        setUnlocalizedName(ID);\n    }\n\n    @Override\n    public boolean showDurabilityBar(ItemStack stack) {\n        return false;\n    }\n\n    @Override\n    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {\n        if (!itemStack.hasTagCompound())\n            return false;\n\n        final LockObject lock = LockObject.find(world, x, y, z);\n        if (lock == null || lock.getLockType() == LockType.DIGITAL)\n            return false;\n\n        final String secret = itemStack.getTagCompound().getString(\"secret\");\n        if (lock.canUnlockWith(secret)) {\n            lock.toggleLocked();\n\n            if (!world.isRemote) {\n                final String msg = lock.isLocked() ? \"more.lock.locked\" : \"more.lock.unlocked\";\n                player.addChatMessage(new ChatComponentTranslation(msg));\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public IIcon getIconIndex(ItemStack stack) {\n        if (!stack.hasTagCompound() || stack.getTagCompound().getString(\"secret\").isEmpty())\n            return icons[0];\n\n        final String secret = stack.getTagCompound().getString(\"secret\");\n        final int iconId = secret.charAt(1) % ICONS_COUNT; // use second char, because first one can be minus\n        return icons[iconId];\n    }\n\n    @Override\n    public void registerIcons(IIconRegister p_94581_1_) {\n        for (int i = 0; i < ICONS_COUNT; ++i)\n            icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + \":\" + TEX_BASE + (i + 1));\n    }\n\n    public static ItemStack makeKeyItem(String secret) {\n        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);\n\n        final NBTTagCompound compound = new NBTTagCompound();\n        compound.setString(\"secret\", secret);\n        stack.setTagCompound(compound);\n\n        return stack;\n    }\n}", "class_id": 0, "repo": "msifd/more", "file": "src/main/java/msifeed/mc/extensions/locks/items/KeyItem.java", "last_update_at": "2021-01-25T21:18:39+00:00", "question_id": "16a60673c47ed31ef3e70caf496702cafa6f7bfd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KeyItem extends Item {\n    public static final String ID = \"lock_key\";\n    public static final String TEX_BASE = \"lock_key_\";\n    private static final int ICONS_COUNT = 3;\n    private IIcon[] icons = new IIcon[ICONS_COUNT];\n    public KeyItem() {\n        setUnlocalizedName(ID);\n    }\n    @Override\n    public boolean showDurabilityBar(ItemStack stack) {\n        return false;\n    }\n    @Override\n    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {\n        if (!itemStack.hasTagCompound())\n            return false;\n        final LockObject lock = LockObject.find(world, x, y, z);\n        if (lock == null || lock.getLockType() == LockType.DIGITAL)\n            return false;\n        final String secret = itemStack.getTagCompound().getString(\"secret\");\n        if (lock.canUnlockWith(secret)) {\n            lock.toggleLocked();\n            if (!world.isRemote) {\n                final String msg = lock.isLocked() ? \"more.lock.locked\" : \"more.lock.unlocked\";\n                player.addChatMessage(new ChatComponentTranslation(msg));\n            }\n        }\n        return true;\n    }\n    @Override\n    public IIcon getIconIndex(ItemStack stack) {\n        if (!stack.hasTagCompound() || stack.getTagCompound().getString(\"secret\").isEmpty())\n            return icons[0];\n        final String secret = stack.getTagCompound().getString(\"secret\");\n        final int iconId = secret.charAt(1) % ICONS_COUNT; // use second char, because first one can be minus\n        return icons[iconId];\n    }\n    @Override\n    public void registerIcons(IIconRegister p_94581_1_) {\n        for (int i = 0; i < ICONS_COUNT; ++i)\n            icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + \":\" + TEX_BASE + (i + 1));\n    }\n    public static ItemStack makeKeyItem(String secret) {\n        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);\n        final NBTTagCompound compound = new NBTTagCompound();\n        compound.setString(\"secret\", secret);\n        stack.setTagCompound(compound);\n        return stack;\n    }\n"]]}
{"hexsha": "ce0aae2d035d5e83776bce459265e8dafe8ff912", "ext": "java", "lang": "Java", "content": "public final class MethodHandlerScanner implements EventHandlerScanner {\n    private final AnnotatedListenerPredicate annotatedListenerPredicate =\n            new AnnotatedListenerPredicate();\n    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();\n\n    @Override\n    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {\n        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();\n        Stream.of(listenerContainer.getClass().getDeclaredMethods())\n                .filter(annotatedListenerPredicate).forEach(method -> eventHandlers\n                .computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>())\n                .add(new MethodEventHandler(listenerContainer, method,\n                        filterScanner.scan(method))));\n        return eventHandlers;\n    }\n}", "class_id": 0, "repo": "GentlemanMC/Zenith-Public", "file": "src/main/java/team/stiff/pomelo/impl/annotated/handler/scan/MethodHandlerScanner.java", "last_update_at": "2021-12-19T18:11:35+00:00", "question_id": "ce0aae2d035d5e83776bce459265e8dafe8ff912", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class MethodHandlerScanner implements EventHandlerScanner {\n    private final AnnotatedListenerPredicate annotatedListenerPredicate =\n            new AnnotatedListenerPredicate();\n    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();\n    @Override\n    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {\n        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();\n        Stream.of(listenerContainer.getClass().getDeclaredMethods())\n                .filter(annotatedListenerPredicate).forEach(method -> eventHandlers\n                .computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>())\n                .add(new MethodEventHandler(listenerContainer, method,\n                        filterScanner.scan(method))));\n        return eventHandlers;\n    }\n"]]}
{"hexsha": "daf88f1a21c8768696553c46d83f94aec56a5ffe", "ext": "java", "lang": "Java", "content": "public class HttpClientHelper {\n\n    public static final String DEFAULT_URL = \"http://localhost:7493/go/\";\n    private String baseUrl = DEFAULT_URL;\n\n    public HttpClientHelper() {\n    }\n\n    public HttpClientHelper(String baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {\n        return httpRequest(path, methodRequired, null);\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, params);\n        return method.getResponseBodyAsString();\n    }\n\n\n    public int httpRequestForHeaders(final String path, RequestMethod methodRequired)\n            throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, \"\");\n        return method.getStatusCode();\n\n    }\n\n    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {\n        HttpMethod method = null;\n        String url = baseUrl + path;\n        switch (methodRequired) {\n            case PUT:\n                method = new PutMethod(url);\n                break;\n            case POST:\n                method = new PostMethod(url);\n                break;\n            case GET:\n                method = new GetMethod(url);\n                break;\n        }\n        method.setQueryString(params);\n        HttpClient client = new HttpClient();\n        client.executeMethod(method);\n        return method;\n    }\n\n    public static boolean isRedirect(int statusCode) {\n        return statusCode >= 300 && statusCode < 400;\n    }\n}", "class_id": 0, "repo": "refdiff-data/gocd", "file": "server/test/common/com/thoughtworks/go/helpers/HttpClientHelper.java", "last_update_at": "2021-08-14T13:50:46+00:00", "question_id": "daf88f1a21c8768696553c46d83f94aec56a5ffe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HttpClientHelper {\n    public static final String DEFAULT_URL = \"http://localhost:7493/go/\";\n    private String baseUrl = DEFAULT_URL;\n    public HttpClientHelper() {\n    }\n    public HttpClientHelper(String baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {\n        return httpRequest(path, methodRequired, null);\n    }\n    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, params);\n        return method.getResponseBodyAsString();\n    }\n    public int httpRequestForHeaders(final String path, RequestMethod methodRequired)\n            throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, \"\");\n        return method.getStatusCode();\n    }\n    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {\n        HttpMethod method = null;\n        String url = baseUrl + path;\n        switch (methodRequired) {\n            case PUT:\n                method = new PutMethod(url);\n                break;\n            case POST:\n                method = new PostMethod(url);\n                break;\n            case GET:\n                method = new GetMethod(url);\n                break;\n        }\n        method.setQueryString(params);\n        HttpClient client = new HttpClient();\n        client.executeMethod(method);\n        return method;\n    }\n    public static boolean isRedirect(int statusCode) {\n        return statusCode >= 300 && statusCode < 400;\n    }\n"]]}
{"hexsha": "969a8d791f5bc2edfa349e8c2e0c99f9951846c6", "ext": "java", "lang": "Java", "content": "@Component\npublic class StartCommandHandler implements ICommandHandler {\n\n    private final UserService userService;\n\n    public StartCommandHandler(UserService userService) {\n        this.userService = userService;\n    }\n\n    @Override\n    public boolean accept(String command) {\n        return Objects.equals(command, \"/start\");\n    }\n\n    @Override\n    public SendMessage handle(User user, String[] args) {\n        String chatId = user.getId().toString();\n\n        if (args == null || args.length == 0) {\n            userService.resetUser(user);\n            return new SendMessage(chatId, getHelpMessage());\n        }\n\n        String botAnswer;\n\n        if (args[0].equals(\"leaveFeedback\")) {\n            Long eventId = Long.parseLong(args[1]);\n            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;\n            user.setConversationStatus(ConversationStatus.LeaveFeedback);\n            user.setSelectedEventId(eventId);\n            user.setSelectedFeedbackId(feedbackId);\n            userService.insertOrUpdate(user);\n            botAnswer = \"Write your message\";\n        }\n        else {\n            botAnswer = \"Something went wrong!\";\n        }\n\n        return new SendMessage(chatId, botAnswer);\n    }\n}", "class_id": 0, "repo": "animolos/mutual_feedback_bot", "file": "src/main/java/ru/home/mutual_feedback_bot/api/command_handlers/StartCommandHandler.java", "last_update_at": "2021-11-06T12:16:30+00:00", "question_id": "969a8d791f5bc2edfa349e8c2e0c99f9951846c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class StartCommandHandler implements ICommandHandler {\n    private final UserService userService;\n    public StartCommandHandler(UserService userService) {\n        this.userService = userService;\n    }\n    @Override\n    public boolean accept(String command) {\n        return Objects.equals(command, \"/start\");\n    }\n    @Override\n    public SendMessage handle(User user, String[] args) {\n        String chatId = user.getId().toString();\n        if (args == null || args.length == 0) {\n            userService.resetUser(user);\n            return new SendMessage(chatId, getHelpMessage());\n        }\n        String botAnswer;\n        if (args[0].equals(\"leaveFeedback\")) {\n            Long eventId = Long.parseLong(args[1]);\n            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;\n            user.setConversationStatus(ConversationStatus.LeaveFeedback);\n            user.setSelectedEventId(eventId);\n            user.setSelectedFeedbackId(feedbackId);\n            userService.insertOrUpdate(user);\n            botAnswer = \"Write your message\";\n        }\n        else {\n            botAnswer = \"Something went wrong!\";\n        }\n        return new SendMessage(chatId, botAnswer);\n    }\n"]]}
{"hexsha": "6dc842b708c83d823cc7570e2b26a376f97948f7", "ext": "java", "lang": "Java", "content": "public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate ModelVersion sinceVersion;\n\tprivate ModelVersion deprecatedVersion;\n\n\tprotected VersionableSurveyObject(Survey survey, int id) {\n\t\tsuper(survey, id);\n\t}\n\n\tprotected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {\n\t\tsuper(survey, source, id);\n\t\tif (survey == source.getSurvey()) {\n\t\t\tthis.sinceVersion = source.sinceVersion;\n\t\t\tthis.deprecatedVersion = source.deprecatedVersion;\n\t\t}\n\t}\n\t\n\tpublic void removeVersioning(ModelVersion version) {\n\t\tint versionId = version.getId();\n\t\tif ( sinceVersion != null && sinceVersion.getId() == versionId ) {\n\t\t\tsinceVersion = null;\n\t\t}\n\t\tif ( deprecatedVersion != null && deprecatedVersion.getId() == versionId ) {\n\t\t\tdeprecatedVersion = null;\n\t\t}\n\t}\n\n\tpublic String getSinceVersionName() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getName();\n\t}\n\t\n\tpublic Integer getSinceVersionId() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getId();\n\t}\n\t\n\tpublic void setSinceVersionByName(String name) {\n\t\tthis.sinceVersion = name == null ? null : findVersion(name);\n\t}\n\n\tpublic String getDeprecatedVersionName() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getName();\n\t}\n\t\n\tpublic Integer getDeprecatedVersionId() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getId();\n\t}\n\t\n\tpublic void setDeprecatedVersionByName(String name) {\n\t\tthis.deprecatedVersion = name == null ? null : findVersion(name);\n\t}\n\n\tpublic ModelVersion getSinceVersion() {\n\t\treturn this.sinceVersion;\n\t}\n\n\tpublic void setSinceVersion(ModelVersion since) {\n\t\tthis.sinceVersion = since;\n\t}\n\n\tpublic ModelVersion getDeprecatedVersion() {\n\t\treturn this.deprecatedVersion;\n\t}\n\n\tpublic void setDeprecatedVersion(ModelVersion deprecated) {\n\t\tthis.deprecatedVersion = deprecated;\n\t}\n\n\tprivate ModelVersion findVersion(String name) {\n\t\tif ( name == null ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tSurvey survey = getSurvey();\n\t\t\tif ( survey == null ) {\n\t\t\t\tthrow new IllegalStateException(\"Survey not set!\");\n\t\t\t} \n\t\t\tModelVersion v = survey.getVersion(name);\n\t\t\tif ( v == null ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Undefined version '\"+name+\"' in \"+toString());\n\t\t\t} \n\t\t\treturn v;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean deepEquals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.deepEquals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tVersionableSurveyObject other = (VersionableSurveyObject) obj;\n\t\tif (deprecatedVersion == null) {\n\t\t\tif (other.deprecatedVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))\n\t\t\treturn false;\n\t\tif (sinceVersion == null) {\n\t\t\tif (other.sinceVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!sinceVersion.deepEquals(other.sinceVersion))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}", "class_id": 0, "repo": "jadedevin13/collect", "file": "collect-core/src/main/java/org/openforis/idm/metamodel/VersionableSurveyObject.java", "last_update_at": "2021-10-05T13:25:16+00:00", "question_id": "6dc842b708c83d823cc7570e2b26a376f97948f7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate ModelVersion sinceVersion;\n\tprivate ModelVersion deprecatedVersion;\n\tprotected VersionableSurveyObject(Survey survey, int id) {\n\t\tsuper(survey, id);\n\t}\n\tprotected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {\n\t\tsuper(survey, source, id);\n\t\tif (survey == source.getSurvey()) {\n\t\t\tthis.sinceVersion = source.sinceVersion;\n\t\t\tthis.deprecatedVersion = source.deprecatedVersion;\n\t\t}\n\t}\n\t\n\tpublic void removeVersioning(ModelVersion version) {\n\t\tint versionId = version.getId();\n\t\tif ( sinceVersion != null && sinceVersion.getId() == versionId ) {\n\t\t\tsinceVersion = null;\n\t\t}\n\t\tif ( deprecatedVersion != null && deprecatedVersion.getId() == versionId ) {\n\t\t\tdeprecatedVersion = null;\n\t\t}\n\t}\n\tpublic String getSinceVersionName() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getName();\n\t}\n\t\n\tpublic Integer getSinceVersionId() {\n\t\treturn sinceVersion == null ? null : sinceVersion.getId();\n\t}\n\t\n\tpublic void setSinceVersionByName(String name) {\n\t\tthis.sinceVersion = name == null ? null : findVersion(name);\n\t}\n\tpublic String getDeprecatedVersionName() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getName();\n\t}\n\t\n\tpublic Integer getDeprecatedVersionId() {\n\t\treturn deprecatedVersion == null ? null : deprecatedVersion.getId();\n\t}\n\t\n\tpublic void setDeprecatedVersionByName(String name) {\n\t\tthis.deprecatedVersion = name == null ? null : findVersion(name);\n\t}\n\tpublic ModelVersion getSinceVersion() {\n\t\treturn this.sinceVersion;\n\t}\n\tpublic void setSinceVersion(ModelVersion since) {\n\t\tthis.sinceVersion = since;\n\t}\n\tpublic ModelVersion getDeprecatedVersion() {\n\t\treturn this.deprecatedVersion;\n\t}\n\tpublic void setDeprecatedVersion(ModelVersion deprecated) {\n\t\tthis.deprecatedVersion = deprecated;\n\t}\n\tprivate ModelVersion findVersion(String name) {\n\t\tif ( name == null ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tSurvey survey = getSurvey();\n\t\t\tif ( survey == null ) {\n\t\t\t\tthrow new IllegalStateException(\"Survey not set!\");\n\t\t\t} \n\t\t\tModelVersion v = survey.getVersion(name);\n\t\t\tif ( v == null ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Undefined version '\"+name+\"' in \"+toString());\n\t\t\t} \n\t\t\treturn v;\n\t\t}\n\t}\n\t@Override\n\tpublic boolean deepEquals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.deepEquals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tVersionableSurveyObject other = (VersionableSurveyObject) obj;\n\t\tif (deprecatedVersion == null) {\n\t\t\tif (other.deprecatedVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))\n\t\t\treturn false;\n\t\tif (sinceVersion == null) {\n\t\t\tif (other.sinceVersion != null)\n\t\t\t\treturn false;\n\t\t} else if (!sinceVersion.deepEquals(other.sinceVersion))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n"]]}
{"hexsha": "f9adf1391613a41a2b211c8031b0e6fa8832d4dc", "ext": "java", "lang": "Java", "content": "public class ApiOvhSslGateway extends ApiOvhBase {\n\tpublic ApiOvhSslGateway(ApiOvhCore core) {\n\t\tsuper(core);\n\t}\n\n\t/**\n\t * Launch a contact change procedure\n\t *\n\t * REST: POST /sslGateway/{serviceName}/changeContact\n\t * @param contactAdmin [required] The contact to set as admin contact\n\t * @param contactTech [required] The contact to set as tech contact\n\t * @param contactBilling [required] The contact to set as billing contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/changeContact\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"contactAdmin\", contactAdmin);\n\t\taddBody(o, \"contactBilling\", contactBilling);\n\t\taddBody(o, \"contactTech\", contactTech);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t1);\n\t}\n\tprivate static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {};\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/serviceInfos\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhService.class);\n\t}\n\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/serviceInfos\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\n\t/**\n\t * Renew your SSL certificates\n\t *\n\t * REST: POST /sslGateway/{serviceName}/renewCertificate\n\t * @param domain [required] Domain on which you want to renew certificate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/renewCertificate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t2);\n\t}\n\tprivate static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {};\n\n\t/**\n\t * Terminate your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/terminate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_terminate_POST(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/terminate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), null);\n\t\treturn convertTo(resp, String.class);\n\t}\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\n\t/**\n\t * Detach a domain from your SSL Gateway\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\n\t/**\n\t * Domains attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\n\t/**\n\t * Attach a new domain to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/domain\n\t * @param domain [required] Domain to attach\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\n\t/**\n\t * Servers attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\n\t/**\n\t * Add a new server to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/server\n\t * @param port [required] Port of your server\n\t * @param address [required] IPv4 address of your server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"address\", address);\n\t\taddBody(o, \"port\", port);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/server/{id}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\n\t/**\n\t * Remove a server\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\n\t/**\n\t * Task for this SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of the task\n\t *\n\t * API beta\n\t */\n\tpublic OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhTask.class);\n\t}\n\n\t/**\n\t * Ip subnet used by OVH to nat requests to your SSL Gateway backends.\n\t *\n\t * REST: GET /sslGateway/{serviceName}/natIp\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/natIp\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t3);\n\t}\n\tprivate static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {};\n\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhSslGateway serviceName_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhSslGateway.class);\n\t}\n\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\n\t/**\n\t * Confirm termination of your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/confirmTermination\n\t * @param futureUse [required] What next after your termination request\n\t * @param reason [required] Reason of your termination request\n\t * @param commentary [required] Commentary about your termination request\n\t * @param token [required] The termination token sent by mail to the admin contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/confirmTermination\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"commentary\", commentary);\n\t\taddBody(o, \"futureUse\", futureUse);\n\t\taddBody(o, \"reason\", reason);\n\t\taddBody(o, \"token\", token);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, String.class);\n\t}\n\n\t/**\n\t * Check domain eligibility. Return list of eligible IP(s) for this domain.\n\t *\n\t * REST: GET /sslGateway/eligibility\n\t * @param domain [required] domain to check eligibility for SSL Gateway offer\n\t *\n\t * API beta\n\t */\n\tpublic OvhEligibilityStatus eligibility_GET(String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/eligibility\";\n\t\tStringBuilder sb = path(qPath);\n\t\tquery(sb, \"domain\", domain);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhEligibilityStatus.class);\n\t}\n\n\t/**\n\t * List available services\n\t *\n\t * REST: GET /sslGateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> GET() throws IOException {\n\t\tString qPath = \"/sslGateway\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n\n\t/**\n\t * List of zone available for an SSL Gateway\n\t *\n\t * REST: GET /sslGateway/availableZones\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> availableZones_GET() throws IOException {\n\t\tString qPath = \"/sslGateway/availableZones\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n}", "class_id": 0, "repo": "marstona/ovh-java-sdk", "file": "ovh-java-sdk-sslGateway/src/main/java/net/minidev/ovh/api/ApiOvhSslGateway.java", "last_update_at": "2021-04-20T07:54:21+00:00", "question_id": "f9adf1391613a41a2b211c8031b0e6fa8832d4dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ApiOvhSslGateway extends ApiOvhBase {\n\tpublic ApiOvhSslGateway(ApiOvhCore core) {\n\t\tsuper(core);\n\t}\n\t/**\n\t * Launch a contact change procedure\n\t *\n\t * REST: POST /sslGateway/{serviceName}/changeContact\n\t * @param contactAdmin [required] The contact to set as admin contact\n\t * @param contactTech [required] The contact to set as tech contact\n\t * @param contactBilling [required] The contact to set as billing contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/changeContact\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"contactAdmin\", contactAdmin);\n\t\taddBody(o, \"contactBilling\", contactBilling);\n\t\taddBody(o, \"contactTech\", contactTech);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t1);\n\t}\n\tprivate static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {};\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/serviceInfos\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhService.class);\n\t}\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/serviceInfos\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\t/**\n\t * Renew your SSL certificates\n\t *\n\t * REST: POST /sslGateway/{serviceName}/renewCertificate\n\t * @param domain [required] Domain on which you want to renew certificate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/renewCertificate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, t2);\n\t}\n\tprivate static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {};\n\t/**\n\t * Terminate your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/terminate\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_terminate_POST(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/terminate\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), null);\n\t\treturn convertTo(resp, String.class);\n\t}\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\t/**\n\t * Detach a domain from your SSL Gateway\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/domain/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your domain\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\t/**\n\t * Domains attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/domain\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\t/**\n\t * Attach a new domain to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/domain\n\t * @param domain [required] Domain to attach\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/domain\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"domain\", domain);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhDomain.class);\n\t}\n\t/**\n\t * Servers attached to your SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\t/**\n\t * Add a new server to your SSL Gateway\n\t *\n\t * REST: POST /sslGateway/{serviceName}/server\n\t * @param port [required] Port of your server\n\t * @param address [required] IPv4 address of your server\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"address\", address);\n\t\taddBody(o, \"port\", port);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhServer.class);\n\t}\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}/server/{id}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\t/**\n\t * Remove a server\n\t *\n\t * REST: DELETE /sslGateway/{serviceName}/server/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of your server\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/server/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\texec(qPath, \"DELETE\", sb.toString(), null);\n\t}\n\t/**\n\t * Task for this SSL Gateway\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t1);\n\t}\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}/task/{id}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t * @param id [required] Id of the task\n\t *\n\t * API beta\n\t */\n\tpublic OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/task/{id}\";\n\t\tStringBuilder sb = path(qPath, serviceName, id);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhTask.class);\n\t}\n\t/**\n\t * Ip subnet used by OVH to nat requests to your SSL Gateway backends.\n\t *\n\t * REST: GET /sslGateway/{serviceName}/natIp\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/natIp\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t3);\n\t}\n\tprivate static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {};\n\t/**\n\t * Get this object properties\n\t *\n\t * REST: GET /sslGateway/{serviceName}\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic OvhSslGateway serviceName_GET(String serviceName) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhSslGateway.class);\n\t}\n\t/**\n\t * Alter this object properties\n\t *\n\t * REST: PUT /sslGateway/{serviceName}\n\t * @param body [required] New object properties\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\texec(qPath, \"PUT\", sb.toString(), body);\n\t}\n\t/**\n\t * Confirm termination of your service\n\t *\n\t * REST: POST /sslGateway/{serviceName}/confirmTermination\n\t * @param futureUse [required] What next after your termination request\n\t * @param reason [required] Reason of your termination request\n\t * @param commentary [required] Commentary about your termination request\n\t * @param token [required] The termination token sent by mail to the admin contact\n\t * @param serviceName [required] The internal name of your SSL Gateway\n\t *\n\t * API beta\n\t */\n\tpublic String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {\n\t\tString qPath = \"/sslGateway/{serviceName}/confirmTermination\";\n\t\tStringBuilder sb = path(qPath, serviceName);\n\t\tHashMap<String, Object>o = new HashMap<String, Object>();\n\t\taddBody(o, \"commentary\", commentary);\n\t\taddBody(o, \"futureUse\", futureUse);\n\t\taddBody(o, \"reason\", reason);\n\t\taddBody(o, \"token\", token);\n\t\tString resp = exec(qPath, \"POST\", sb.toString(), o);\n\t\treturn convertTo(resp, String.class);\n\t}\n\t/**\n\t * Check domain eligibility. Return list of eligible IP(s) for this domain.\n\t *\n\t * REST: GET /sslGateway/eligibility\n\t * @param domain [required] domain to check eligibility for SSL Gateway offer\n\t *\n\t * API beta\n\t */\n\tpublic OvhEligibilityStatus eligibility_GET(String domain) throws IOException {\n\t\tString qPath = \"/sslGateway/eligibility\";\n\t\tStringBuilder sb = path(qPath);\n\t\tquery(sb, \"domain\", domain);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, OvhEligibilityStatus.class);\n\t}\n\t/**\n\t * List available services\n\t *\n\t * REST: GET /sslGateway\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> GET() throws IOException {\n\t\tString qPath = \"/sslGateway\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = exec(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n\t/**\n\t * List of zone available for an SSL Gateway\n\t *\n\t * REST: GET /sslGateway/availableZones\n\t *\n\t * API beta\n\t */\n\tpublic ArrayList<String> availableZones_GET() throws IOException {\n\t\tString qPath = \"/sslGateway/availableZones\";\n\t\tStringBuilder sb = path(qPath);\n\t\tString resp = execN(qPath, \"GET\", sb.toString(), null);\n\t\treturn convertTo(resp, t2);\n\t}\n"]]}
{"hexsha": "2e2144587792d1fd6ca9470159dc937992a00ce0", "ext": "java", "lang": "Java", "content": "public class LectorLadronesJSON implements LectorLadrones{\n    private String ruta = \"src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json\";\n\n    public ArrayList<Ladron> cargarLadrones() {\n        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                String hobby = (String) ladron.get(\"Hobby\");\n                String cabello = (String) ladron.get(\"Cabello\");\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n                ladrones.add(objLadron);\n\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return ladrones;\n    }\n\n    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {\n        HashMap<String, ArrayList<String>> diccionario = new HashMap();\n        diccionario.put(\"Sexo\", new ArrayList<String>());\n        diccionario.put(\"Cabello\", new ArrayList<String>());\n        diccionario.put(\"Hobby\", new ArrayList<String>());\n        diccionario.put(\"Vehiculo\", new ArrayList<String>());\n        diccionario.put(\"Senia\", new ArrayList<String>());\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                ArrayList<String> sexos = diccionario.get(\"Sexo\");\n                if (!sexos.contains(sexo)) {\n                    sexos.add(sexo);\n                }\n                String hobby = (String) ladron.get(\"Hobby\");\n                ArrayList<String> hobbys = diccionario.get(\"Hobby\");\n                if (!hobbys.contains(hobby)) {\n                    hobbys.add(hobby);\n                }\n                String cabello = (String) ladron.get(\"Cabello\");\n                ArrayList<String> cabellos = diccionario.get(\"Cabello\");\n                if (!cabellos.contains(cabello)) {\n                    cabellos.add(cabello);\n                }\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                ArrayList<String> senias = diccionario.get(\"Senia\");\n                if (!senias.contains(caracteristica)) {\n                    senias.add(caracteristica);\n                }\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> vehiculos = diccionario.get(\"Vehiculo\");\n                if (!vehiculos.contains(vehiculo)) {\n                    vehiculos.add(vehiculo);\n                }\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return diccionario;\n    }\n\n\n}", "class_id": 0, "repo": "jmdieguez/algothief", "file": "src/main/java/edu/fiuba/algo3/modelo/lectoresDeArchivos/LectorLadronesJSON.java", "last_update_at": "2021-12-23T21:09:22+00:00", "question_id": "2e2144587792d1fd6ca9470159dc937992a00ce0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LectorLadronesJSON implements LectorLadrones{\n    private String ruta = \"src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json\";\n    public ArrayList<Ladron> cargarLadrones() {\n        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                String hobby = (String) ladron.get(\"Hobby\");\n                String cabello = (String) ladron.get(\"Cabello\");\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n                ladrones.add(objLadron);\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return ladrones;\n    }\n    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {\n        HashMap<String, ArrayList<String>> diccionario = new HashMap();\n        diccionario.put(\"Sexo\", new ArrayList<String>());\n        diccionario.put(\"Cabello\", new ArrayList<String>());\n        diccionario.put(\"Hobby\", new ArrayList<String>());\n        diccionario.put(\"Vehiculo\", new ArrayList<String>());\n        diccionario.put(\"Senia\", new ArrayList<String>());\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                ArrayList<String> sexos = diccionario.get(\"Sexo\");\n                if (!sexos.contains(sexo)) {\n                    sexos.add(sexo);\n                }\n                String hobby = (String) ladron.get(\"Hobby\");\n                ArrayList<String> hobbys = diccionario.get(\"Hobby\");\n                if (!hobbys.contains(hobby)) {\n                    hobbys.add(hobby);\n                }\n                String cabello = (String) ladron.get(\"Cabello\");\n                ArrayList<String> cabellos = diccionario.get(\"Cabello\");\n                if (!cabellos.contains(cabello)) {\n                    cabellos.add(cabello);\n                }\n                String caracteristica = (String) ladron.get(\"Caracter\u00edstica\");\n                ArrayList<String> senias = diccionario.get(\"Senia\");\n                if (!senias.contains(caracteristica)) {\n                    senias.add(caracteristica);\n                }\n                String vehiculo = (String) ladron.get(\"Veh\u00edculo\");\n                ArrayList<String> vehiculos = diccionario.get(\"Vehiculo\");\n                if (!vehiculos.contains(vehiculo)) {\n                    vehiculos.add(vehiculo);\n                }\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n            }\n        }\n        catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        }\n        catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        }\n        catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return diccionario;\n    }\n"]]}
{"hexsha": "37ecfb9df884be7d35bf5475a3abf4d1b0e8fe8d", "ext": "java", "lang": "Java", "content": "@RunWith(JMock.class)\npublic class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {\n\n    private PasswordValueSemanticsProvider adapter;\n    private Object password;\n    private FacetHolder holder;\n\n    @Before\n    public void setUpObjects() throws Exception {\n        holder = new FacetHolderImpl();\n        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));\n        password = new Password(\"secret\");\n    }\n\n    @Test\n    public void testEncoding() {\n        assertEquals(\"secret\", new String(adapter.toEncodedString(password)));\n    }\n}", "class_id": 0, "repo": "Corpus-2021/nakedobjects-4.0.0", "file": "core/metamodel/src/test/java/org/nakedobjects/metamodel/value/PasswordValueSemanticsProviderTest.java", "last_update_at": "2021-02-22T15:40:05+00:00", "question_id": "37ecfb9df884be7d35bf5475a3abf4d1b0e8fe8d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(JMock.class)\npublic class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {\n    private PasswordValueSemanticsProvider adapter;\n    private Object password;\n    private FacetHolder holder;\n    @Before\n    public void setUpObjects() throws Exception {\n        holder = new FacetHolderImpl();\n        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));\n        password = new Password(\"secret\");\n    }\n    @Test\n    public void testEncoding() {\n        assertEquals(\"secret\", new String(adapter.toEncodedString(password)));\n    }\n"]]}
{"hexsha": "2f37e0e31a286e088d15fb05e86f8bfa506763a6", "ext": "java", "lang": "Java", "content": "public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {\n\n    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());\n    \n    private ServerBootstrap serverBootstrap;\n    private Channel serverChannel;\n    private EndpointService endpointService;\n    \n    private AtomicBoolean started = new AtomicBoolean(false);\n    private PeerGroup group;\n    private PeerGroupID homeGroupID;\n    private PeerID localPeerID;\n    \n    private MessengerEventListener listener;\n    private List<EndpointAddress> publicAddresses;\n\n    private AddressTranslator addrTranslator;\n    \n    private ChannelGroup channels;\n\n    private HashedWheelTimer timeoutTimer;\n\n    private ChannelGroupFuture closeChannelsFuture;\n\n    private List<EndpointAddress> boundAddresses;\n    \n    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {\n        this.channels = new DefaultChannelGroup();\n        this.group = group;\n        this.homeGroupID = group.getPeerGroupID();\n        this.localPeerID = group.getPeerID();\n        this.addrTranslator = addrTranslator;\n        serverBootstrap = new ServerBootstrap(factory);\n        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());\n        timeoutTimer = new HashedWheelTimer();\n    }\n \n    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {\n        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));\n        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);\n        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));\n        \n        if(serverChannel == null) {\n\n            Logging.logCheckedWarning(LOG, \"Failed to bind to any of the addresses in the configured range\");\n            throw new PeerGroupException(\"Failed to bind to any address in the configured range\");\n\n        }\n        \n        if(usePublicOnly) {\n\n            if(publicAddress == null) {\n\n                Logging.logCheckedWarning(LOG, \"Instructed to use public address only, but no public address specified! Using all bound addresses instead\");\n                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);\n\n            } else {\n\n                publicAddresses = new ArrayList<EndpointAddress>(1);\n                publicAddresses.add(publicAddress);\n\n            }\n\n        } else {\n            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);\n            publicAddresses = new ArrayList<EndpointAddress>(size);\n            if(publicAddress != null) {\n                publicAddresses.add(publicAddress);\n            }\n            publicAddresses.addAll(boundAddresses);\n        }\n    }\n\n    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {\n        \n        for(SocketAddress nextBP : potentialBindpoints) {\n\n            try {\n                serverChannel = serverBootstrap.bind(nextBP);\n                channels.add(serverChannel);\n                return nextBP;\n            } catch(ChannelException e) {\n                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();\n                Logging.logCheckedInfo(LOG, \"Attempt to bind to \", nextBP, \" failed (\", failReason, \"), trying another address\");\n            }\n            \n        }\n        \n        return null;\n    }\n    \n    public boolean start(EndpointService endpointService) throws IllegalStateException {\n        if(started.get()) {\n            throw new IllegalStateException(\"already started\");\n        }\n        \n        this.endpointService = endpointService;\n        listener = endpointService.addMessageTransport(this);\n        \n        if(listener == null) {\n\n            Logging.logCheckedSevere(LOG, \"Transport registration failed for netty transport server, protocol=\", addrTranslator.getProtocolName());\n            return false;\n\n        }\n        \n        started.set(true);\n        return true;\n    }\n    \n    public void beginStop() {\n\n        if(!started.compareAndSet(true, false)) {\n\n            Logging.logCheckedWarning(LOG, \"Netty transport server for protocol \", addrTranslator.getProtocolName(), \" already stopped or never started!\");\n            return;\n\n        }\n        \n        closeChannelsFuture = channels.close();\n    }\n    \n    public void stop() throws IllegalStateException {\n        if(closeChannelsFuture != null) {\n            closeChannelsFuture.awaitUninterruptibly();\n        }\n        \n        serverChannel = null;\n        serverBootstrap.releaseExternalResources();\n        timeoutTimer.stop();\n    }\n\n    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {\n        // EndpointAddress localAddr = addrTranslator.toEndpointAddress(channel.getLocalAddress(), serverChannel.getLocalAddress());\n        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));\n\t}\n\t\n    public Iterator<EndpointAddress> getPublicAddresses() {\n        return publicAddresses.iterator();\n    }\n\n    public EndpointService getEndpointService() {\n        return endpointService;\n    }\n\n    public String getProtocolName() {\n        return addrTranslator.getProtocolName();\n    }\n\n    @Sharable\n    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {\n\n        @Override\n        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {\n            \n            Logging.logCheckedFine(LOG, String.format(\"Incoming connection for transport %s from %s to %s (handled by %s)\",\n                  getProtocolName(),\n                  e.getChildChannel().getRemoteAddress(),\n                  e.getChildChannel().getLocalAddress(),\n                  ctx.getChannel().getLocalAddress()\n                  ));\n                \n            channels.add(e.getChildChannel());\n            super.childChannelOpen(ctx, e);\n        }\n        \n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n            // BindExceptions are transformed into ChannelBindExceptions by the netty\n            // ServerBootstrap, and handled in in bindServerChannel()\n            if(!(e.getCause() instanceof BindException)) {\n                LOG.log(Level.WARNING, \"Unexpected exception on server channel for {0} protocol:\\n{1}\", \n                        new Object[] { getProtocolName(), e.getCause() });\n            }\n        }\n    }\n\n    public boolean isStarted() {\n        return started.get();\n    }\n\n    /**\n     * @return the physically bound addresses for this transport, as opposed to those which are\n     * broadcasted to external peers.\n     */\n    public List<EndpointAddress> getBoundAddresses() {\n        return boundAddresses;\n    }\n}", "class_id": 0, "repo": "chaupal/jp2p-jxta", "file": "Workspace/net.jp2p.endpoint.netty/src/net/jxta/impl/endpoint/netty/NettyTransportServer.java", "last_update_at": "2021-01-20T14:53:01+00:00", "question_id": "2f37e0e31a286e088d15fb05e86f8bfa506763a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {\n    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());\n    private ServerBootstrap serverBootstrap;\n    private Channel serverChannel;\n    private EndpointService endpointService;\n    private AtomicBoolean started = new AtomicBoolean(false);\n    private PeerGroup group;\n    private PeerGroupID homeGroupID;\n    private PeerID localPeerID;\n    private MessengerEventListener listener;\n    private List<EndpointAddress> publicAddresses;\n    private AddressTranslator addrTranslator;\n    private ChannelGroup channels;\n    private HashedWheelTimer timeoutTimer;\n    private ChannelGroupFuture closeChannelsFuture;\n    private List<EndpointAddress> boundAddresses;\n    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {\n        this.channels = new DefaultChannelGroup();\n        this.group = group;\n        this.homeGroupID = group.getPeerGroupID();\n        this.localPeerID = group.getPeerID();\n        this.addrTranslator = addrTranslator;\n        serverBootstrap = new ServerBootstrap(factory);\n        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());\n        timeoutTimer = new HashedWheelTimer();\n    }\n    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {\n        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));\n        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);\n        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));\n        if(serverChannel == null) {\n            Logging.logCheckedWarning(LOG, \"Failed to bind to any of the addresses in the configured range\");\n            throw new PeerGroupException(\"Failed to bind to any address in the configured range\");\n        }\n        if(usePublicOnly) {\n            if(publicAddress == null) {\n                Logging.logCheckedWarning(LOG, \"Instructed to use public address only, but no public address specified! Using all bound addresses instead\");\n                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);\n            } else {\n                publicAddresses = new ArrayList<EndpointAddress>(1);\n                publicAddresses.add(publicAddress);\n            }\n        } else {\n            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);\n            publicAddresses = new ArrayList<EndpointAddress>(size);\n            if(publicAddress != null) {\n                publicAddresses.add(publicAddress);\n            }\n            publicAddresses.addAll(boundAddresses);\n        }\n    }\n    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {\n        for(SocketAddress nextBP : potentialBindpoints) {\n            try {\n                serverChannel = serverBootstrap.bind(nextBP);\n                channels.add(serverChannel);\n                return nextBP;\n            } catch(ChannelException e) {\n                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();\n                Logging.logCheckedInfo(LOG, \"Attempt to bind to \", nextBP, \" failed (\", failReason, \"), trying another address\");\n            }\n        }\n        return null;\n    }\n    public boolean start(EndpointService endpointService) throws IllegalStateException {\n        if(started.get()) {\n            throw new IllegalStateException(\"already started\");\n        }\n        this.endpointService = endpointService;\n        listener = endpointService.addMessageTransport(this);\n        if(listener == null) {\n            Logging.logCheckedSevere(LOG, \"Transport registration failed for netty transport server, protocol=\", addrTranslator.getProtocolName());\n            return false;\n        }\n        started.set(true);\n        return true;\n    }\n    public void beginStop() {\n        if(!started.compareAndSet(true, false)) {\n            Logging.logCheckedWarning(LOG, \"Netty transport server for protocol \", addrTranslator.getProtocolName(), \" already stopped or never started!\");\n            return;\n        }\n        closeChannelsFuture = channels.close();\n    }\n    public void stop() throws IllegalStateException {\n        if(closeChannelsFuture != null) {\n            closeChannelsFuture.awaitUninterruptibly();\n        }\n        serverChannel = null;\n        serverBootstrap.releaseExternalResources();\n        timeoutTimer.stop();\n    }\n    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {\n        // EndpointAddress localAddr = addrTranslator.toEndpointAddress(channel.getLocalAddress(), serverChannel.getLocalAddress());\n        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n\t    listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));\n\t}\n\t\n    public Iterator<EndpointAddress> getPublicAddresses() {\n        return publicAddresses.iterator();\n    }\n    public EndpointService getEndpointService() {\n        return endpointService;\n    }\n    public String getProtocolName() {\n        return addrTranslator.getProtocolName();\n    }\n    @Sharable\n    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {\n        @Override\n        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {\n            Logging.logCheckedFine(LOG, String.format(\"Incoming connection for transport %s from %s to %s (handled by %s)\",\n                  getProtocolName(),\n                  e.getChildChannel().getRemoteAddress(),\n                  e.getChildChannel().getLocalAddress(),\n                  ctx.getChannel().getLocalAddress()\n                  ));\n            channels.add(e.getChildChannel());\n            super.childChannelOpen(ctx, e);\n        }\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n            // BindExceptions are transformed into ChannelBindExceptions by the netty\n            // ServerBootstrap, and handled in in bindServerChannel()\n            if(!(e.getCause() instanceof BindException)) {\n                LOG.log(Level.WARNING, \"Unexpected exception on server channel for {0} protocol:\\n{1}\", \n                        new Object[] { getProtocolName(), e.getCause() });\n            }\n        }\n    }\n    public boolean isStarted() {\n        return started.get();\n    }\n    /**\n     * @return the physically bound addresses for this transport, as opposed to those which are\n     * broadcasted to external peers.\n     */\n    public List<EndpointAddress> getBoundAddresses() {\n        return boundAddresses;\n    }\n"]]}
{"hexsha": "5243c099bbc4d6b225d8d4ed73dce3be7503010c", "ext": "java", "lang": "Java", "content": "public class ScannerImplTest {\n\n  private ClientContext context;\n\n  @Before\n  public void setup() {\n    context = EasyMock.createMock(ClientContext.class);\n  }\n\n  @Test\n  public void testValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(0);\n    s.setReadaheadThreshold(10);\n    s.setReadaheadThreshold(Long.MAX_VALUE);\n\n    assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());\n    s.close();\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(-1);\n    s.close();\n  }\n\n  @Test\n  public void testGetAuthorizations() {\n    Authorizations expected = new Authorizations(\"a,b\");\n    Scanner s = new ScannerImpl(context, \"foo\", expected);\n    assertEquals(expected, s.getAuthorizations());\n    s.close();\n  }\n\n  @SuppressWarnings(\"resource\")\n  @Test(expected = IllegalArgumentException.class)\n  public void testNullAuthorizationsFails() {\n    new ScannerImpl(context, \"foo\", null);\n  }\n\n}", "class_id": 0, "repo": "dorateq/accumulo", "file": "core/src/test/java/org/apache/accumulo/core/client/impl/ScannerImplTest.java", "last_update_at": "2021-04-07T18:45:40+00:00", "question_id": "5243c099bbc4d6b225d8d4ed73dce3be7503010c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScannerImplTest {\n  private ClientContext context;\n  @Before\n  public void setup() {\n    context = EasyMock.createMock(ClientContext.class);\n  }\n  @Test\n  public void testValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(0);\n    s.setReadaheadThreshold(10);\n    s.setReadaheadThreshold(Long.MAX_VALUE);\n    assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());\n    s.close();\n  }\n  @Test(expected = IllegalArgumentException.class)\n  public void testInValidReadaheadValues() {\n    Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n    s.setReadaheadThreshold(-1);\n    s.close();\n  }\n  @Test\n  public void testGetAuthorizations() {\n    Authorizations expected = new Authorizations(\"a,b\");\n    Scanner s = new ScannerImpl(context, \"foo\", expected);\n    assertEquals(expected, s.getAuthorizations());\n    s.close();\n  }\n  @SuppressWarnings(\"resource\")\n  @Test(expected = IllegalArgumentException.class)\n  public void testNullAuthorizationsFails() {\n    new ScannerImpl(context, \"foo\", null);\n  }\n"]]}
{"hexsha": "4d7f0a0119dc23fe4bd356b1832ed7063663cf23", "ext": "java", "lang": "Java", "content": "public class D11_ValidAnagram {\n    public static void main(String[] args) {\n        ValidAnagramSolution vas = new ValidAnagramSolution();\n        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();\n\n        System.out.println(vas.isAnagram(\"azamat\", \"tamaza\"));\n        System.out.println(vas_1.isAnagram(\"azamat\", \"tamaza\"));\n    }\n}", "class_id": 0, "repo": "SudoAzek/LeetCodeJava", "file": "Solutions/src/february_daily_challenge/D11_ValidAnagram.java", "last_update_at": "2021-12-18T22:51:42+00:00", "question_id": "4d7f0a0119dc23fe4bd356b1832ed7063663cf23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class D11_ValidAnagram {\n    public static void main(String[] args) {\n        ValidAnagramSolution vas = new ValidAnagramSolution();\n        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();\n        System.out.println(vas.isAnagram(\"azamat\", \"tamaza\"));\n        System.out.println(vas_1.isAnagram(\"azamat\", \"tamaza\"));\n    }\n"]]}
{"hexsha": "cf298733351b7e35725e78d8f67a8e27f7e35c3e", "ext": "java", "lang": "Java", "content": "public class demo06ArrayListStudent {\n    public static void main(String[] args) {\n        ArrayList<Student> list =  new ArrayList<>();\n\n        list.add(new Student(22,\"\u6d2a\u4e03\u516c\"));\n        list.add(new Student(23,\"\u6b27\u9633\u950b\"));\n        list.add(new Student(53,\"\u9ec4\u836f\u5e08\"));\n        list.add(new Student(33,\"\u6bb5\u667a\u5e86\"));\n\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(\"\u59d3\u540d\uff1a\"+stu.getName()+\" \u5e74\u9f84\uff1a\"+stu.getAge());\n\n        }\n    }\n}", "class_id": 0, "repo": "BinmingWen/base-code", "file": "day06-code/src/demo04/demo06ArrayListStudent.java", "last_update_at": "2021-03-02T00:49:32+00:00", "question_id": "cf298733351b7e35725e78d8f67a8e27f7e35c3e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class demo06ArrayListStudent {\n    public static void main(String[] args) {\n        ArrayList<Student> list =  new ArrayList<>();\n        list.add(new Student(22,\"\u6d2a\u4e03\u516c\"));\n        list.add(new Student(23,\"\u6b27\u9633\u950b\"));\n        list.add(new Student(53,\"\u9ec4\u836f\u5e08\"));\n        list.add(new Student(33,\"\u6bb5\u667a\u5e86\"));\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(\"\u59d3\u540d\uff1a\"+stu.getName()+\" \u5e74\u9f84\uff1a\"+stu.getAge());\n        }\n    }\n"]]}
{"hexsha": "f897b790e84ce679266078228c42440591f1ba9b", "ext": "java", "lang": "Java", "content": "public class IsDAG_DontHave_Cycles {\n    Map<Integer, Set<Integer>> map = new HashMap<>();\n    Set<Integer> vis = new HashSet<>();\n    \n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if(prerequisites == null){\n            return false;\n        }\n        \n        if(prerequisites.length <= 0){\n            return true;\n        }\n        \n        Set<Integer> prevS = new HashSet<>();\n        Set<Integer> nextS = new HashSet<>();\n        \n        int n = prerequisites.length;\n        for(int i=0; i<n; i++){\n            int prevCour = prerequisites[i][1];\n            int nextCour = prerequisites[i][0];\n            \n            prevS.add(prevCour);\n            nextS.add(nextCour);\n            \n            Set<Integer> courses = map.get(prevCour);\n            if(courses == null){\n                courses = new HashSet<>();\n                map.put(prevCour, courses);\n            }\n            \n            courses.add(nextCour);\n        }\n        \n        prevS.removeAll(nextS);\n        \n        for(Integer item : prevS){\n            if(!dfs(item)){\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private boolean dfs(Integer node){\n        if(node == null){\n            return true;\n        }\n        \n        if(vis.contains(node)){\n            return false;\n        }\n        \n        vis.add(node);\n        \n        Set<Integer> courses = map.get(node);\n        if(courses != null){\n            for(Integer n : courses){\n                if(!dfs(n)){\n                    return false;\n                }\n            }\n        }\n        \n        vis.remove(node);\n        \n        return true;\n    }\n}", "class_id": 0, "repo": "sergeyltd/pilgrim-base", "file": "src/main/java/org/pilgrim/leetcode/y2021/IsDAG_DontHave_Cycles.java", "last_update_at": "2021-04-06T17:19:31+00:00", "question_id": "f897b790e84ce679266078228c42440591f1ba9b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IsDAG_DontHave_Cycles {\n    Map<Integer, Set<Integer>> map = new HashMap<>();\n    Set<Integer> vis = new HashSet<>();\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if(prerequisites == null){\n            return false;\n        }\n        if(prerequisites.length <= 0){\n            return true;\n        }\n        Set<Integer> prevS = new HashSet<>();\n        Set<Integer> nextS = new HashSet<>();\n        int n = prerequisites.length;\n        for(int i=0; i<n; i++){\n            int prevCour = prerequisites[i][1];\n            int nextCour = prerequisites[i][0];\n            prevS.add(prevCour);\n            nextS.add(nextCour);\n            Set<Integer> courses = map.get(prevCour);\n            if(courses == null){\n                courses = new HashSet<>();\n                map.put(prevCour, courses);\n            }\n            courses.add(nextCour);\n        }\n        prevS.removeAll(nextS);\n        for(Integer item : prevS){\n            if(!dfs(item)){\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean dfs(Integer node){\n        if(node == null){\n            return true;\n        }\n        if(vis.contains(node)){\n            return false;\n        }\n        vis.add(node);\n        Set<Integer> courses = map.get(node);\n        if(courses != null){\n            for(Integer n : courses){\n                if(!dfs(n)){\n                    return false;\n                }\n            }\n        }\n        vis.remove(node);\n        return true;\n    }\n"]]}
{"hexsha": "3b3405f0a50720b0ea3fa6ab7ba19be695a6240c", "ext": "java", "lang": "Java", "content": "public class NullabilityTest {\n\n    @Test\n    public void test() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;\n        settings.sortDeclarations = true;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n        final String expected = \"\" +\n                \"interface A<T> {\\n\" +\n                \"    data?: T;\\n\" +\n                \"    isNonNullableFlag: boolean;\\n\" +\n                \"    isNullableFlag?: boolean;\\n\" +\n                \"    nonNullableBoolean: boolean;\\n\" +\n                \"    nonNullableString: string;\\n\" +\n                \"    nullableArray?: (string | undefined)[];\\n\" +\n                \"    nullableBoolean?: boolean;\\n\" +\n                \"    nullableGenericArray?: (T | undefined)[];\\n\" +\n                \"    nullableGenericType?: T;\\n\" +\n                \"    nullableList?: (string | undefined)[];\\n\" +\n                \"    nullableString?: string;\\n\" +\n                \"    test: string;\\n\" +\n                \"    testNullable?: string;\\n\" +\n                \"}\";\n        Assert.assertEquals(expected.trim(), output.trim());\n    }\n\n    private static class A<T> {\n\n        public @Nullable String nullableString;\n        public String nonNullableString;\n        public @Nullable List<@Nullable String> nullableList;\n        public @Nullable String @Nullable [] nullableArray;\n        public @Nullable T @Nullable [] nullableGenericArray;\n        public @Nullable T nullableGenericType;\n        public @Nullable Boolean nullableBoolean;\n        public Boolean nonNullableBoolean;\n        public @Nullable Boolean isNullableFlag;\n        public Boolean isNonNullableFlag;\n\n        public <B extends T> @Nullable B getData() {\n            return null;\n        }\n\n        public String getTest() {\n            return \"\";\n        }\n\n        public @Nullable String getTestNullable() {\n            return null;\n        }\n\n    }\n\n    @Test\n    public void testVariants() {\n        testVariant(NullabilityDefinition.nullAndUndefinedUnion,       \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null | undefined\");\n        testVariant(NullabilityDefinition.undefinedUnion,              \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | undefined\");\n        testVariant(NullabilityDefinition.nullUnion,                   \"list: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null\");\n        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, \"list?: (string | null | undefined)[] | null\");\n        testVariant(NullabilityDefinition.undefinedInlineUnion,        \"list?: (string | undefined)[]\");\n        testVariant(NullabilityDefinition.nullInlineUnion,             \"list: (string | null)[] | null\");\n    }\n\n    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        for (String s : expected) {\n            Assert.assertTrue(output.contains(s));\n        }\n    }\n\n    private static class B {\n        public @Nullable List<@Nullable String> list;\n    }\n\n    @Test\n    public void testCombinationsOfOptionalAndNullable() {\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.questionMark,\n                NullabilityDefinition.nullInlineUnion,\n                \"list?: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullInlineUnion,\n                \"list: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableAndUndefinableType,\n                NullabilityDefinition.nullAndUndefinedInlineUnion,\n                \"list: (string | null | undefined)[] | null | undefined;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullAndUndefinedUnion,\n                \"list: Nullable<Nullable<string>[]> | null;\");\n    }\n\n    private static void testCombinationOfOptionalAndNullable(\n            OptionalPropertiesDeclaration optionalPropertiesDeclaration,\n            NullabilityDefinition nullabilityDefinition,\n            String expected\n    ) {\n        final Settings settings = TestUtils.settings();\n        settings.optionalAnnotations.add(Nullable.class);\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        Assert.assertTrue(\"Unexpected actual output: \" + output, output.contains(expected));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testNullableAnnotationTarget() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(javax.annotation.Nullable.class);\n        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n    }\n\n}", "class_id": 0, "repo": "joaocmendes/typescript-generator", "file": "typescript-generator-core/src/test/java/cz/habarta/typescript/generator/NullabilityTest.java", "last_update_at": "2021-05-21T07:38:40+00:00", "question_id": "3b3405f0a50720b0ea3fa6ab7ba19be695a6240c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NullabilityTest {\n    @Test\n    public void test() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;\n        settings.sortDeclarations = true;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n        final String expected = \"\" +\n                \"interface A<T> {\\n\" +\n                \"    data?: T;\\n\" +\n                \"    isNonNullableFlag: boolean;\\n\" +\n                \"    isNullableFlag?: boolean;\\n\" +\n                \"    nonNullableBoolean: boolean;\\n\" +\n                \"    nonNullableString: string;\\n\" +\n                \"    nullableArray?: (string | undefined)[];\\n\" +\n                \"    nullableBoolean?: boolean;\\n\" +\n                \"    nullableGenericArray?: (T | undefined)[];\\n\" +\n                \"    nullableGenericType?: T;\\n\" +\n                \"    nullableList?: (string | undefined)[];\\n\" +\n                \"    nullableString?: string;\\n\" +\n                \"    test: string;\\n\" +\n                \"    testNullable?: string;\\n\" +\n                \"}\";\n        Assert.assertEquals(expected.trim(), output.trim());\n    }\n    private static class A<T> {\n        public @Nullable String nullableString;\n        public String nonNullableString;\n        public @Nullable List<@Nullable String> nullableList;\n        public @Nullable String @Nullable [] nullableArray;\n        public @Nullable T @Nullable [] nullableGenericArray;\n        public @Nullable T nullableGenericType;\n        public @Nullable Boolean nullableBoolean;\n        public Boolean nonNullableBoolean;\n        public @Nullable Boolean isNullableFlag;\n        public Boolean isNonNullableFlag;\n        public <B extends T> @Nullable B getData() {\n            return null;\n        }\n        public String getTest() {\n            return \"\";\n        }\n        public @Nullable String getTestNullable() {\n            return null;\n        }\n    }\n    @Test\n    public void testVariants() {\n        testVariant(NullabilityDefinition.nullAndUndefinedUnion,       \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null | undefined\");\n        testVariant(NullabilityDefinition.undefinedUnion,              \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | undefined\");\n        testVariant(NullabilityDefinition.nullUnion,                   \"list: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null\");\n        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, \"list?: (string | null | undefined)[] | null\");\n        testVariant(NullabilityDefinition.undefinedInlineUnion,        \"list?: (string | undefined)[]\");\n        testVariant(NullabilityDefinition.nullInlineUnion,             \"list: (string | null)[] | null\");\n    }\n    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        for (String s : expected) {\n            Assert.assertTrue(output.contains(s));\n        }\n    }\n    private static class B {\n        public @Nullable List<@Nullable String> list;\n    }\n    @Test\n    public void testCombinationsOfOptionalAndNullable() {\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.questionMark,\n                NullabilityDefinition.nullInlineUnion,\n                \"list?: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullInlineUnion,\n                \"list: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableAndUndefinableType,\n                NullabilityDefinition.nullAndUndefinedInlineUnion,\n                \"list: (string | null | undefined)[] | null | undefined;\");\n        testCombinationOfOptionalAndNullable(\n                OptionalPropertiesDeclaration.nullableType,\n                NullabilityDefinition.nullAndUndefinedUnion,\n                \"list: Nullable<Nullable<string>[]> | null;\");\n    }\n    private static void testCombinationOfOptionalAndNullable(\n            OptionalPropertiesDeclaration optionalPropertiesDeclaration,\n            NullabilityDefinition nullabilityDefinition,\n            String expected\n    ) {\n        final Settings settings = TestUtils.settings();\n        settings.optionalAnnotations.add(Nullable.class);\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        Assert.assertTrue(\"Unexpected actual output: \" + output, output.contains(expected));\n    }\n    @Test(expected = RuntimeException.class)\n    public void testNullableAnnotationTarget() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(javax.annotation.Nullable.class);\n        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n    }\n"]]}
{"hexsha": "147107bc0784d1e698608f00c42fa859e9ca63b2", "ext": "java", "lang": "Java", "content": "public class DatabaseWriter {\n\n  ProcessingEnvironment processingEnv;\n\n  Elements elementUtils;\n\n  Element database;\n\n  String className;\n\n  ClassName clazzName;\n\n  String fileName;\n\n  List<VariableElement> tables = new ArrayList<>();\n\n  List<VariableElement> execOnCreate = new ArrayList<>();\n\n  ExecutableElement onCreate;\n\n  ExecutableElement onUpgrade;\n\n  ExecutableElement onConfigure;\n\n  int version;\n\n  String outPackage;\n\n  public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {\n    this.processingEnv = env;\n    this.elementUtils = env.getElementUtils();\n\n    this.database = database;\n\n    String databaseSchematicName = database.getSimpleName().toString();\n\n    Database db = database.getAnnotation(Database.class);\n    this.version = db.version();\n\n    this.className = db.className();\n    if (className.trim().isEmpty()) {\n      this.className = databaseSchematicName;\n    }\n\n    this.outPackage = db.packageName();\n    if (outPackage.trim().isEmpty()) {\n      this.outPackage = elements.getPackageOf(database).getQualifiedName() + \".generated\";\n    }\n\n    this.fileName = db.fileName();\n    if (fileName.trim().isEmpty()) {\n      this.fileName =\n          CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + \".db\";\n    }\n\n    clazzName = ClassName.get(outPackage, className);\n\n    findAnnotations(database);\n  }\n\n  private void findAnnotations(Element element) {\n    List<? extends Element> enclosedElements = element.getEnclosedElements();\n\n    for (Element enclosedElement : enclosedElements) {\n      findAnnotations(enclosedElement);\n\n      Table table = enclosedElement.getAnnotation(Table.class);\n      if (table != null) {\n        tables.add((VariableElement) enclosedElement);\n      }\n\n      OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);\n      if (onCreate != null) {\n        if (this.onCreate != null) {\n          error(\"Multiple OnCreate annotations found in \" + database.getSimpleName().toString());\n        }\n\n        this.onCreate = (ExecutableElement) enclosedElement;\n      }\n\n      OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);\n      if (onUpgrade != null) {\n        if (this.onUpgrade != null) {\n          error(\"Multiple OnUpgrade annotations found in \" + database.getSimpleName().toString());\n        }\n\n        this.onUpgrade = (ExecutableElement) enclosedElement;\n      }\n\n      OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);\n      if (onConfigure != null) {\n        if (this.onConfigure != null) {\n          error(\"Multiple OnConfigure annotations found in \" + database.getSimpleName().toString());\n        }\n\n        this.onConfigure = (ExecutableElement) enclosedElement;\n      }\n\n      ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);\n      if (execOnCreate != null) {\n        this.execOnCreate.add((VariableElement) enclosedElement);\n      }\n    }\n  }\n\n  public void writeJava(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getFileName());\n    Writer out = jfo.openWriter();\n\n    TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className)\n        .superclass(Clazz.SQLITE_OPEN_HELPER)\n        .addModifiers(Modifier.PUBLIC);\n\n    FieldSpec versionSpec =\n        FieldSpec.builder(int.class, \"DATABASE_VERSION\", Modifier.PRIVATE, Modifier.STATIC,\n            Modifier.FINAL).initializer(\"$L\", version).build();\n    databaseBuilder.addField(versionSpec);\n\n    for (VariableElement table : tables) {\n      TypeElement tableClass = null;\n      Table columns = table.getAnnotation(Table.class);\n      try {\n        columns.value();\n      } catch (MirroredTypeException e) {\n        TypeMirror mirror = e.getTypeMirror();\n        tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);\n      }\n\n      ClassName tableClassName = ClassName.get(tableClass);\n\n      TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);\n      tableWriter.createTable(databaseBuilder);\n      tableWriter.createValuesBuilder(filer, outPackage);\n    }\n\n    WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);\n\n    databaseBuilder.addField(Clazz.CONTEXT, \"context\", Modifier.PRIVATE);\n\n    MethodSpec constructor = MethodSpec.constructorBuilder()\n        .addModifiers(Modifier.PRIVATE)\n        .addParameter(Clazz.CONTEXT, \"context\")\n        .addStatement(\"super(context.getApplicationContext(), $S, null, DATABASE_VERSION)\", fileName)\n        .addStatement(\"this.context = context.getApplicationContext()\")\n        .build();\n    databaseBuilder.addMethod(constructor);\n\n    databaseBuilder.addMethod(getOnCreateSpec());\n    databaseBuilder.addMethod(getOnUpgradeSpec());\n\n    if (onConfigure != null) {\n      databaseBuilder.addMethod(getOnConfigureSpec());\n    }\n\n    JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n\n  private MethodSpec getOnCreateSpec() {\n    MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder(\"onCreate\")\n        .returns(void.class)\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n\n    for (VariableElement table : tables) {\n      onCreateBuilder.addStatement(\"db.execSQL($L)\", table.getSimpleName().toString());\n    }\n\n    for (VariableElement exec : execOnCreate) {\n      String variableName = exec.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"db.execSQL($T.$L)\", exec.getEnclosingElement(), variableName);\n    }\n\n    if (onCreate != null) {\n      List<? extends VariableElement> parameters = onCreate.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n        TypeMirror paramType = param.asType();\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n      }\n\n      String methodName = onCreate.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"$T.$L($L)\", onCreate.getEnclosingElement(), methodName,\n          params.toString());\n    }\n\n    return onCreateBuilder.build();\n  }\n\n  private MethodSpec getOnUpgradeSpec() {\n    MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder(\"onUpgrade\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\")\n        .addParameter(int.class, \"oldVersion\")\n        .addParameter(int.class, \"newVersion\");\n\n    if (onUpgrade != null) {\n      List<? extends VariableElement> parameters = onUpgrade.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n\n        TypeMirror paramType = param.asType();\n\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n        if (TypeName.get(int.class).equals(TypeName.get(paramType))) {\n          String name = param.getSimpleName().toString();\n          if (\"oldVersion\".equals(name)) {\n            params.append(\"oldVersion\");\n          } else if (\"newVersion\".equals(name)) {\n            params.append(\"newVersion\");\n          } else {\n            error(\"Unknown int parameter: \" + name);\n          }\n        }\n      }\n\n      String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();\n      String methodName = onUpgrade.getSimpleName().toString();\n      onUpgradeBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n    }\n\n    return onUpgradeBuilder.build();\n  }\n\n  private MethodSpec getOnConfigureSpec() {\n    MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder(\"onConfigure\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n\n    List<? extends VariableElement> parameters = onConfigure.getParameters();\n    StringBuilder params = new StringBuilder();\n    boolean first = true;\n    for (VariableElement param : parameters) {\n      if (first) {\n        first = false;\n      } else {\n        params.append(\", \");\n      }\n      TypeMirror paramType = param.asType();\n      if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n        params.append(\"db\");\n      } else {\n        throw new IllegalArgumentException(\n            \"OnConfigure does not support parameter \" + paramType.toString());\n      }\n    }\n\n    String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();\n    String methodName = onConfigure.getSimpleName().toString();\n    onConfigureBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n\n    return onConfigureBuilder.build();\n  }\n\n  public void writeValues(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getValuesFileName());\n    Writer out = jfo.openWriter();\n\n    final String valuesPackage = outPackage + \".values\";\n\n    TypeSpec.Builder spec =\n        TypeSpec.classBuilder(className + \"Values\").addModifiers(Modifier.PUBLIC);\n\n    for (VariableElement table : tables) {\n      Table tableAnnotation = table.getAnnotation(Table.class);\n      String tableName = table.getConstantValue().toString();\n      tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);\n\n      String methodName = \"for\" + tableName;\n      String valuesName = tableName + \"ValuesBuilder\";\n      ClassName builderClass = ClassName.get(valuesPackage, valuesName);\n\n      MethodSpec builderSpec = MethodSpec.methodBuilder(methodName)\n          .addModifiers(Modifier.PUBLIC)\n          .returns(builderClass)\n          .addStatement(\"return new $T()\", builderClass)\n          .build();\n\n      spec.addMethod(builderSpec);\n    }\n\n    JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n\n  private String getFileName() {\n    return outPackage + \".\" + className;\n  }\n\n  private String getValuesFileName() {\n    return outPackage + \".values.\" + className + \"Values\";\n  }\n\n  private void error(String error) {\n    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);\n  }\n}", "class_id": 0, "repo": "icse18-refactorings/schematic", "file": "schematic-compiler/src/main/java/net/simonvt/schematic/compiler/DatabaseWriter.java", "last_update_at": "2021-12-31T14:46:37+00:00", "question_id": "147107bc0784d1e698608f00c42fa859e9ca63b2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DatabaseWriter {\n  ProcessingEnvironment processingEnv;\n  Elements elementUtils;\n  Element database;\n  String className;\n  ClassName clazzName;\n  String fileName;\n  List<VariableElement> tables = new ArrayList<>();\n  List<VariableElement> execOnCreate = new ArrayList<>();\n  ExecutableElement onCreate;\n  ExecutableElement onUpgrade;\n  ExecutableElement onConfigure;\n  int version;\n  String outPackage;\n  public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {\n    this.processingEnv = env;\n    this.elementUtils = env.getElementUtils();\n    this.database = database;\n    String databaseSchematicName = database.getSimpleName().toString();\n    Database db = database.getAnnotation(Database.class);\n    this.version = db.version();\n    this.className = db.className();\n    if (className.trim().isEmpty()) {\n      this.className = databaseSchematicName;\n    }\n    this.outPackage = db.packageName();\n    if (outPackage.trim().isEmpty()) {\n      this.outPackage = elements.getPackageOf(database).getQualifiedName() + \".generated\";\n    }\n    this.fileName = db.fileName();\n    if (fileName.trim().isEmpty()) {\n      this.fileName =\n          CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + \".db\";\n    }\n    clazzName = ClassName.get(outPackage, className);\n    findAnnotations(database);\n  }\n  private void findAnnotations(Element element) {\n    List<? extends Element> enclosedElements = element.getEnclosedElements();\n    for (Element enclosedElement : enclosedElements) {\n      findAnnotations(enclosedElement);\n      Table table = enclosedElement.getAnnotation(Table.class);\n      if (table != null) {\n        tables.add((VariableElement) enclosedElement);\n      }\n      OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);\n      if (onCreate != null) {\n        if (this.onCreate != null) {\n          error(\"Multiple OnCreate annotations found in \" + database.getSimpleName().toString());\n        }\n        this.onCreate = (ExecutableElement) enclosedElement;\n      }\n      OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);\n      if (onUpgrade != null) {\n        if (this.onUpgrade != null) {\n          error(\"Multiple OnUpgrade annotations found in \" + database.getSimpleName().toString());\n        }\n        this.onUpgrade = (ExecutableElement) enclosedElement;\n      }\n      OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);\n      if (onConfigure != null) {\n        if (this.onConfigure != null) {\n          error(\"Multiple OnConfigure annotations found in \" + database.getSimpleName().toString());\n        }\n        this.onConfigure = (ExecutableElement) enclosedElement;\n      }\n      ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);\n      if (execOnCreate != null) {\n        this.execOnCreate.add((VariableElement) enclosedElement);\n      }\n    }\n  }\n  public void writeJava(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getFileName());\n    Writer out = jfo.openWriter();\n    TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className)\n        .superclass(Clazz.SQLITE_OPEN_HELPER)\n        .addModifiers(Modifier.PUBLIC);\n    FieldSpec versionSpec =\n        FieldSpec.builder(int.class, \"DATABASE_VERSION\", Modifier.PRIVATE, Modifier.STATIC,\n            Modifier.FINAL).initializer(\"$L\", version).build();\n    databaseBuilder.addField(versionSpec);\n    for (VariableElement table : tables) {\n      TypeElement tableClass = null;\n      Table columns = table.getAnnotation(Table.class);\n      try {\n        columns.value();\n      } catch (MirroredTypeException e) {\n        TypeMirror mirror = e.getTypeMirror();\n        tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);\n      }\n      ClassName tableClassName = ClassName.get(tableClass);\n      TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);\n      tableWriter.createTable(databaseBuilder);\n      tableWriter.createValuesBuilder(filer, outPackage);\n    }\n    WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);\n    databaseBuilder.addField(Clazz.CONTEXT, \"context\", Modifier.PRIVATE);\n    MethodSpec constructor = MethodSpec.constructorBuilder()\n        .addModifiers(Modifier.PRIVATE)\n        .addParameter(Clazz.CONTEXT, \"context\")\n        .addStatement(\"super(context.getApplicationContext(), $S, null, DATABASE_VERSION)\", fileName)\n        .addStatement(\"this.context = context.getApplicationContext()\")\n        .build();\n    databaseBuilder.addMethod(constructor);\n    databaseBuilder.addMethod(getOnCreateSpec());\n    databaseBuilder.addMethod(getOnUpgradeSpec());\n    if (onConfigure != null) {\n      databaseBuilder.addMethod(getOnConfigureSpec());\n    }\n    JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n  private MethodSpec getOnCreateSpec() {\n    MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder(\"onCreate\")\n        .returns(void.class)\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n    for (VariableElement table : tables) {\n      onCreateBuilder.addStatement(\"db.execSQL($L)\", table.getSimpleName().toString());\n    }\n    for (VariableElement exec : execOnCreate) {\n      String variableName = exec.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"db.execSQL($T.$L)\", exec.getEnclosingElement(), variableName);\n    }\n    if (onCreate != null) {\n      List<? extends VariableElement> parameters = onCreate.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n        TypeMirror paramType = param.asType();\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n      }\n      String methodName = onCreate.getSimpleName().toString();\n      onCreateBuilder.addStatement(\"$T.$L($L)\", onCreate.getEnclosingElement(), methodName,\n          params.toString());\n    }\n    return onCreateBuilder.build();\n  }\n  private MethodSpec getOnUpgradeSpec() {\n    MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder(\"onUpgrade\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\")\n        .addParameter(int.class, \"oldVersion\")\n        .addParameter(int.class, \"newVersion\");\n    if (onUpgrade != null) {\n      List<? extends VariableElement> parameters = onUpgrade.getParameters();\n      StringBuilder params = new StringBuilder();\n      boolean first = true;\n      for (VariableElement param : parameters) {\n        if (first) {\n          first = false;\n        } else {\n          params.append(\", \");\n        }\n        TypeMirror paramType = param.asType();\n        if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n          params.append(\"context\");\n        }\n        if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n          params.append(\"db\");\n        }\n        if (TypeName.get(int.class).equals(TypeName.get(paramType))) {\n          String name = param.getSimpleName().toString();\n          if (\"oldVersion\".equals(name)) {\n            params.append(\"oldVersion\");\n          } else if (\"newVersion\".equals(name)) {\n            params.append(\"newVersion\");\n          } else {\n            error(\"Unknown int parameter: \" + name);\n          }\n        }\n      }\n      String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();\n      String methodName = onUpgrade.getSimpleName().toString();\n      onUpgradeBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n    }\n    return onUpgradeBuilder.build();\n  }\n  private MethodSpec getOnConfigureSpec() {\n    MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder(\"onConfigure\")\n        .addModifiers(Modifier.PUBLIC)\n        .addAnnotation(Override.class)\n        .addParameter(Clazz.SQLITE_DATABASE, \"db\");\n    List<? extends VariableElement> parameters = onConfigure.getParameters();\n    StringBuilder params = new StringBuilder();\n    boolean first = true;\n    for (VariableElement param : parameters) {\n      if (first) {\n        first = false;\n      } else {\n        params.append(\", \");\n      }\n      TypeMirror paramType = param.asType();\n      if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n        params.append(\"db\");\n      } else {\n        throw new IllegalArgumentException(\n            \"OnConfigure does not support parameter \" + paramType.toString());\n      }\n    }\n    String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();\n    String methodName = onConfigure.getSimpleName().toString();\n    onConfigureBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n    return onConfigureBuilder.build();\n  }\n  public void writeValues(Filer filer) throws IOException {\n    JavaFileObject jfo = filer.createSourceFile(getValuesFileName());\n    Writer out = jfo.openWriter();\n    final String valuesPackage = outPackage + \".values\";\n    TypeSpec.Builder spec =\n        TypeSpec.classBuilder(className + \"Values\").addModifiers(Modifier.PUBLIC);\n    for (VariableElement table : tables) {\n      Table tableAnnotation = table.getAnnotation(Table.class);\n      String tableName = table.getConstantValue().toString();\n      tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);\n      String methodName = \"for\" + tableName;\n      String valuesName = tableName + \"ValuesBuilder\";\n      ClassName builderClass = ClassName.get(valuesPackage, valuesName);\n      MethodSpec builderSpec = MethodSpec.methodBuilder(methodName)\n          .addModifiers(Modifier.PUBLIC)\n          .returns(builderClass)\n          .addStatement(\"return new $T()\", builderClass)\n          .build();\n      spec.addMethod(builderSpec);\n    }\n    JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();\n    javaFile.writeTo(out);\n    out.flush();\n    out.close();\n  }\n  private String getFileName() {\n    return outPackage + \".\" + className;\n  }\n  private String getValuesFileName() {\n    return outPackage + \".values.\" + className + \"Values\";\n  }\n  private void error(String error) {\n    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);\n  }\n"]]}
{"hexsha": "411be56df51eee3c16dfe6b0f35455330e5f8f63", "ext": "java", "lang": "Java", "content": "public final class DnsUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);\n\n    /**\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\n     */\n    public static boolean anyInterfaceSupportsIpV6() {\n        try {\n            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                final NetworkInterface iface = interfaces.nextElement();\n                final Enumeration<InetAddress> addresses = iface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    final InetAddress inetAddress = addresses.nextElement();\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() &&\n                        !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\n                        return true;\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\n        }\n        return false;\n    }\n\n    @Nullable\n    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {\n        final DnsRecordType type = record.type();\n        final ByteBuf content = ((ByteBufHolder) record).content();\n        final int contentLen = content.readableBytes();\n\n        // Skip invalid records.\n        if (type == DnsRecordType.A) {\n            if (contentLen != 4) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else if (type == DnsRecordType.AAAA) {\n            if (contentLen != 16) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else {\n            return null;\n        }\n\n        final byte[] addrBytes = new byte[contentLen];\n        content.getBytes(content.readerIndex(), addrBytes);\n        return addrBytes;\n    }\n\n    /**\n     * Logs a warning message about an invalid record.\n     */\n    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {\n        if (logger.isWarnEnabled()) {\n            final String dump = ByteBufUtil.hexDump(content);\n            logger.warn(\"{} Skipping invalid {} record: {}\",\n                        logPrefix, type.name(), dump.isEmpty() ? \"<empty>\" : dump);\n        }\n    }\n\n    private DnsUtil() {}\n}", "class_id": 0, "repo": "georgecao/armeria", "file": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "last_update_at": "2021-12-22T01:14:48+00:00", "question_id": "411be56df51eee3c16dfe6b0f35455330e5f8f63", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class DnsUtil {\n    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);\n    /**\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\n     */\n    public static boolean anyInterfaceSupportsIpV6() {\n        try {\n            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                final NetworkInterface iface = interfaces.nextElement();\n                final Enumeration<InetAddress> addresses = iface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    final InetAddress inetAddress = addresses.nextElement();\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() &&\n                        !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\n                        return true;\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\n        }\n        return false;\n    }\n    @Nullable\n    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {\n        final DnsRecordType type = record.type();\n        final ByteBuf content = ((ByteBufHolder) record).content();\n        final int contentLen = content.readableBytes();\n        // Skip invalid records.\n        if (type == DnsRecordType.A) {\n            if (contentLen != 4) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else if (type == DnsRecordType.AAAA) {\n            if (contentLen != 16) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else {\n            return null;\n        }\n        final byte[] addrBytes = new byte[contentLen];\n        content.getBytes(content.readerIndex(), addrBytes);\n        return addrBytes;\n    }\n    /**\n     * Logs a warning message about an invalid record.\n     */\n    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {\n        if (logger.isWarnEnabled()) {\n            final String dump = ByteBufUtil.hexDump(content);\n            logger.warn(\"{} Skipping invalid {} record: {}\",\n                        logPrefix, type.name(), dump.isEmpty() ? \"<empty>\" : dump);\n        }\n    }\n    private DnsUtil() {}\n"]]}
{"hexsha": "c56eafd18ce46221d394fe0d46db958c396d688c", "ext": "java", "lang": "Java", "content": "class LogicalFormatValidator\n    extends AbstractDataValidator\n{\n    private static final Pattern booleanPattern = Pattern.compile(\"[YNTF ]\");\n\n    LogicalFormatValidator(final Field field)\n    {\n        super(field);\n        assert field.getType() == Type.LOGICAL : \"Can only be validator for LOGICAL fields\";\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A\n     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not\n     * contain leading or trailing spaces.\n     */\n    public void validate(final Object typedObject)\n                  throws DbfLibException\n    {\n        if (typedObject instanceof Boolean)\n        {\n            return;\n        }\n\n        if (typedObject instanceof String)\n        {\n            final String booleanString = (String) typedObject;\n\n            if (! booleanPattern.matcher(booleanString).matches())\n            {\n                throw new DataMismatchException(\"Boolean must be one of Y, N, T, F or a space\");\n            }\n\n            return;\n        }\n\n        throw new DataMismatchException(\"Cannot write objects of type '\" + typedObject.getClass().getName()\n                                        + \"' to a LOGICAL field\");\n    }\n}", "class_id": 0, "repo": "Switajski/dans-dbf-lib", "file": "src/main/java/nl/knaw/dans/common/dbflib/LogicalFormatValidator.java", "last_update_at": "2021-05-25T13:50:19+00:00", "question_id": "c56eafd18ce46221d394fe0d46db958c396d688c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class LogicalFormatValidator\n    extends AbstractDataValidator\n{\n    private static final Pattern booleanPattern = Pattern.compile(\"[YNTF ]\");\n    LogicalFormatValidator(final Field field)\n    {\n        super(field);\n        assert field.getType() == Type.LOGICAL : \"Can only be validator for LOGICAL fields\";\n    }\n    /**\n     * {@inheritDoc}\n     * <p>\n     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A\n     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not\n     * contain leading or trailing spaces.\n     */\n    public void validate(final Object typedObject)\n                  throws DbfLibException\n    {\n        if (typedObject instanceof Boolean)\n        {\n            return;\n        }\n        if (typedObject instanceof String)\n        {\n            final String booleanString = (String) typedObject;\n            if (! booleanPattern.matcher(booleanString).matches())\n            {\n                throw new DataMismatchException(\"Boolean must be one of Y, N, T, F or a space\");\n            }\n            return;\n        }\n        throw new DataMismatchException(\"Cannot write objects of type '\" + typedObject.getClass().getName()\n                                        + \"' to a LOGICAL field\");\n    }\n"]]}
{"hexsha": "8c883a23ce2238926cc5819852b763dc95f1d839", "ext": "java", "lang": "Java", "content": "public class NumFilter implements Filter {\n    @Override\n    public boolean doFilter(Msg msg) {\n        String msg1 = msg.getMsg();\n        String num = msg1.replace(\"123\", \"num\");\n        msg.setMsg(num);\n        return true;\n    }\n}", "class_id": 0, "repo": "zhaochaoyue1/Beyond", "file": "student/src/test/java/com/example/designPattern23/chainOfResponsibility/easyImpl/NumFilter.java", "last_update_at": "2021-09-20T20:51:51+00:00", "question_id": "8c883a23ce2238926cc5819852b763dc95f1d839", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NumFilter implements Filter {\n    @Override\n    public boolean doFilter(Msg msg) {\n        String msg1 = msg.getMsg();\n        String num = msg1.replace(\"123\", \"num\");\n        msg.setMsg(num);\n        return true;\n    }\n"]]}
{"hexsha": "004f0b95f9d31afac73fdba3b9f2530353bc2072", "ext": "java", "lang": "Java", "content": "public class MessagesManager {\n  private Configuration freemarkerCfg = null;\n  @Inject\n  private ServletContext context;\n  @Inject\n  private AssetsManager assetsManager;\n  @Inject\n  private SherlockConfig config;\n\n  @PostConstruct\n  public void init() {\n    WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, \"WEB-INF/messages/\");\n    freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);\n    freemarkerCfg.setTemplateLoader(templateLoader);\n    freemarkerCfg.setDefaultEncoding(\"UTF-8\");\n    freemarkerCfg.setLocale(Locale.US);\n    freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n  }\n\n  public String message(String id) throws IOException, MessageException {\n    return message(id, ImmutableMap.of());\n  }\n\n  public String message(String id, Map<String, Object> context)\n      throws IOException, MessageException {\n    if (!context.containsKey(\"random\")) {\n      ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\n      builder.putAll(context);\n      builder.put(\"tool\", new MessagesTool(assetsManager, config));\n      context = builder.build();\n    }\n    Template template = freemarkerCfg.getTemplate(id + \".ftl\");\n    StringWriter output = new StringWriter();\n    try {\n      template.process(context, output);\n    } catch (TemplateException e) {\n      throw new MessageException(\"Freemarker error\", e);\n    }\n    return output.toString();\n  }\n}", "class_id": 0, "repo": "actions-on-google-labs/sherlock-mysteries-java", "file": "sherlock-web/src/main/java/com/google/mystery/actions/messages/MessagesManager.java", "last_update_at": "2021-03-31T21:52:36+00:00", "question_id": "004f0b95f9d31afac73fdba3b9f2530353bc2072", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessagesManager {\n  private Configuration freemarkerCfg = null;\n  @Inject\n  private ServletContext context;\n  @Inject\n  private AssetsManager assetsManager;\n  @Inject\n  private SherlockConfig config;\n  @PostConstruct\n  public void init() {\n    WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, \"WEB-INF/messages/\");\n    freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);\n    freemarkerCfg.setTemplateLoader(templateLoader);\n    freemarkerCfg.setDefaultEncoding(\"UTF-8\");\n    freemarkerCfg.setLocale(Locale.US);\n    freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n  }\n  public String message(String id) throws IOException, MessageException {\n    return message(id, ImmutableMap.of());\n  }\n  public String message(String id, Map<String, Object> context)\n      throws IOException, MessageException {\n    if (!context.containsKey(\"random\")) {\n      ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\n      builder.putAll(context);\n      builder.put(\"tool\", new MessagesTool(assetsManager, config));\n      context = builder.build();\n    }\n    Template template = freemarkerCfg.getTemplate(id + \".ftl\");\n    StringWriter output = new StringWriter();\n    try {\n      template.process(context, output);\n    } catch (TemplateException e) {\n      throw new MessageException(\"Freemarker error\", e);\n    }\n    return output.toString();\n  }\n"]]}
{"hexsha": "5e2fa117bef24890f7d8225ed48450f9a62751c1", "ext": "java", "lang": "Java", "content": "public class CompletionJavadoc extends Javadoc {\n\n\tExpression completionNode;\n\n\tpublic CompletionJavadoc(int sourceStart, int sourceEnd) {\n\t\tsuper(sourceStart, sourceEnd);\n\t}\n\n\t/**\n\t * @return Returns the completionNode.\n\t */\n\tpublic Expression getCompletionNode() {\n\t\treturn this.completionNode;\n\t}\n\n\t/**\n\t * Resolve selected node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tprivate void internalResolve(Scope scope) {\n\t\tif (this.completionNode != null) {\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocTag) {\n\t\t\t\t((CompletionOnJavadocTag)this.completionNode).filterPossibleTags(scope);\n\t\t\t} else {\n\t\t\t\tboolean resolve = true;\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocParamNameReference)this.completionNode).token != null;\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocTypeParamReference)this.completionNode).token != null;\n\t\t\t\t}\n\t\t\t\tif (resolve) {\n\t\t\t\t\tswitch (scope.kind) {\n\t\t\t\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((ClassScope)scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((MethodScope) scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tCompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;\n\t\t\t\t\tif (scope.kind == Scope.METHOD_SCOPE) {\n\t\t\t\t\t\tparamNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope)scope);\n\t\t\t\t\t}\n\t\t\t\t\tif (paramNameReference.token == null || paramNameReference.token.length == 0) {\n\t\t\t\t\t\tparamNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);\n\t\t\t\t\t}\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tCompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;\n\t\t\t\t\ttypeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBinding qualifiedBinding = null;\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {\n\t\t\t\tCompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;\n\t\t\t\tif (typeRef.packageBinding == null) {\n\t\t\t\t\tqualifiedBinding = typeRef.resolvedType;\n\t\t\t\t} else {\n\t\t\t\t\tqualifiedBinding = typeRef.packageBinding;\n\t\t\t\t}\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {\n\t\t\t\tCompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;\n\t\t\t\tif (!msg.receiver.isThis()) qualifiedBinding = msg.receiver.resolvedType;\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {\n\t\t\t\tCompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;\n\t\t\t\tqualifiedBinding = alloc.type.resolvedType;\n\t\t\t}\n\t\t\tthrow new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);\n\t\t}\n\t}\n\n\t/*\n\t * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)\n\t */\n\tpublic StringBuffer print(int indent, StringBuffer output) {\n\t\tprintIndent(indent, output).append(\"/**\\n\"); //$NON-NLS-1$\n\t\tboolean nodePrinted = false;\n\t\tif (this.paramReferences != null) {\n\t\t\tfor (int i = 0, length = this.paramReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param \"); //$NON-NLS-1$\n\t\t\t\tthis.paramReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.paramTypeParameters != null) {\n\t\t\tfor (int i = 0, length = this.paramTypeParameters.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param <\"); //$NON-NLS-1$\n\t\t\t\tthis.paramTypeParameters[i].print(indent, output).append(\">\\n\"); //$NON-NLS-1$\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramTypeParameters[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.returnStatement != null) {\n\t\t\tprintIndent(indent, output).append(\" * @\"); //$NON-NLS-1$\n\t\t\tthis.returnStatement.print(indent, output).append('\\n');\n\t\t}\n\t\tif (this.exceptionReferences != null) {\n\t\t\tfor (int i = 0, length = this.exceptionReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @throws \"); //$NON-NLS-1$\n\t\t\t\tthis.exceptionReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.exceptionReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.seeReferences != null) {\n\t\t\tfor (int i = 0, length = this.seeReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @see \"); //$NON-NLS-1$\n\t\t\t\tthis.seeReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.seeReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\tprintIndent(indent, output).append(\" * \"); //$NON-NLS-1$\n\t\t\tthis.completionNode.print(indent, output).append('\\n');\n\t\t}\n\t\tprintIndent(indent, output).append(\" */\\n\"); //$NON-NLS-1$\n\t\treturn output;\n\t}\n\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(ClassScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(CompilationUnitScope scope) {\n\t\tinternalResolve(scope);\n\t}\n\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(MethodScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\n\t/*\n\t * Look for missing method @param tags\n\t */\n\tprivate char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {\n\n\t\t// Verify if there's some possible param tag\n\t\tAbstractMethodDeclaration md = methScope.referenceMethod();\n\t\tint paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;\n\t\tif (md == null) return null;\n\t\tint argumentsSize = md.arguments == null ? 0 : md.arguments.length;\n\t\tif (argumentsSize == 0) return null;\n\n\t\t// Store all method arguments if there's no @param in javadoc\n\t\tif (paramTagsSize == 0) {\n\t\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\t\tmissingParams[i] = md.arguments[i].name;\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\n\t\t// Look for missing arguments\n\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\tint size = 0;\n\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\tArgument arg = md.arguments[i];\n\t\t\tboolean found = false;\n\t\t\tint paramNameRefCount = 0;\n\t\t\tfor (int j = 0; j < paramTagsSize && !found; j++) {\n\t\t\t\tJavadocSingleNameReference param = this.paramReferences[j];\n\t\t\t\tif (arg.binding == param.binding) {\n\t\t\t\t\tif (param.binding == paramNameRefBinding) { // do not count first occurence of param name reference\n\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tmissingParams[size++] = arg.name;\n\t\t\t}\n\t\t}\n\t\tif (size > 0) {\n\t\t\tif (size != argumentsSize) {\n\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Look for missing type parameters @param tags\n\t */\n\tprivate char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {\n\t\tint paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;\n\n\t\t// Verify if there's any type parameter to tag\n\t\tTypeParameter[] parameters =  null;\n\t\tTypeVariableBinding[] typeVariables = null;\n\t\tswitch (scope.kind) {\n\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\tAbstractMethodDeclaration methodDeclaration = ((MethodScope)scope).referenceMethod();\n\t\t\t\tif (methodDeclaration == null) return null;\n\t\t\t\tparameters = methodDeclaration.typeParameters();\n\t\t\t\ttypeVariables = methodDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\tTypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;\n\t\t\t\tparameters = typeDeclaration.typeParameters;\n\t\t\t\ttypeVariables = typeDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (typeVariables == null || typeVariables.length == 0) return null;\n\n\t\t// Store all type parameters if there's no @param in javadoc\n\t\tif (parameters != null) {\n\t\t\tint typeParametersLength = parameters.length;\n\t\t\tif (paramTypeParamLength == 0) {\n\t\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\t\tmissingParams[i] = parameters[i].name;\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\n\t\t\t// Look for missing type parameter\n\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\tint size = 0;\n\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\tTypeParameter parameter = parameters[i];\n\t\t\t\tboolean found = false;\n\t\t\t\tint paramNameRefCount = 0;\n\t\t\t\tfor (int j = 0; j < paramTypeParamLength && !found; j++) {\n\t\t\t\t\tif (parameter.binding == this.paramTypeParameters[j].resolvedType) {\n\t\t\t\t\t\tif (parameter.binding == paramNameRefBinding) { // do not count first occurence of param nmae reference\n\t\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tmissingParams[size++] = parameter.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0) {\n\t\t\t\tif (size != typeParametersLength) {\n\t\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}", "class_id": 0, "repo": "TheRakeshPurohit/CodingSpectator", "file": "plug-ins/indigo/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionJavadoc.java", "last_update_at": "2021-05-11T06:56:51+00:00", "question_id": "5e2fa117bef24890f7d8225ed48450f9a62751c1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompletionJavadoc extends Javadoc {\n\tExpression completionNode;\n\tpublic CompletionJavadoc(int sourceStart, int sourceEnd) {\n\t\tsuper(sourceStart, sourceEnd);\n\t}\n\t/**\n\t * @return Returns the completionNode.\n\t */\n\tpublic Expression getCompletionNode() {\n\t\treturn this.completionNode;\n\t}\n\t/**\n\t * Resolve selected node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tprivate void internalResolve(Scope scope) {\n\t\tif (this.completionNode != null) {\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocTag) {\n\t\t\t\t((CompletionOnJavadocTag)this.completionNode).filterPossibleTags(scope);\n\t\t\t} else {\n\t\t\t\tboolean resolve = true;\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocParamNameReference)this.completionNode).token != null;\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tresolve = ((CompletionOnJavadocTypeParamReference)this.completionNode).token != null;\n\t\t\t\t}\n\t\t\t\tif (resolve) {\n\t\t\t\t\tswitch (scope.kind) {\n\t\t\t\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((ClassScope)scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\t\t\t\tthis.completionNode.resolveType((MethodScope) scope);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n\t\t\t\t\tCompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;\n\t\t\t\t\tif (scope.kind == Scope.METHOD_SCOPE) {\n\t\t\t\t\t\tparamNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope)scope);\n\t\t\t\t\t}\n\t\t\t\t\tif (paramNameReference.token == null || paramNameReference.token.length == 0) {\n\t\t\t\t\t\tparamNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);\n\t\t\t\t\t}\n\t\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n\t\t\t\t\tCompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;\n\t\t\t\t\ttypeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBinding qualifiedBinding = null;\n\t\t\tif (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {\n\t\t\t\tCompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;\n\t\t\t\tif (typeRef.packageBinding == null) {\n\t\t\t\t\tqualifiedBinding = typeRef.resolvedType;\n\t\t\t\t} else {\n\t\t\t\t\tqualifiedBinding = typeRef.packageBinding;\n\t\t\t\t}\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {\n\t\t\t\tCompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;\n\t\t\t\tif (!msg.receiver.isThis()) qualifiedBinding = msg.receiver.resolvedType;\n\t\t\t} else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {\n\t\t\t\tCompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;\n\t\t\t\tqualifiedBinding = alloc.type.resolvedType;\n\t\t\t}\n\t\t\tthrow new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);\n\t\t}\n\t}\n\t/*\n\t * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)\n\t */\n\tpublic StringBuffer print(int indent, StringBuffer output) {\n\t\tprintIndent(indent, output).append(\"/**\\n\"); //$NON-NLS-1$\n\t\tboolean nodePrinted = false;\n\t\tif (this.paramReferences != null) {\n\t\t\tfor (int i = 0, length = this.paramReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param \"); //$NON-NLS-1$\n\t\t\t\tthis.paramReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.paramTypeParameters != null) {\n\t\t\tfor (int i = 0, length = this.paramTypeParameters.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @param <\"); //$NON-NLS-1$\n\t\t\t\tthis.paramTypeParameters[i].print(indent, output).append(\">\\n\"); //$NON-NLS-1$\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.paramTypeParameters[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.returnStatement != null) {\n\t\t\tprintIndent(indent, output).append(\" * @\"); //$NON-NLS-1$\n\t\t\tthis.returnStatement.print(indent, output).append('\\n');\n\t\t}\n\t\tif (this.exceptionReferences != null) {\n\t\t\tfor (int i = 0, length = this.exceptionReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @throws \"); //$NON-NLS-1$\n\t\t\t\tthis.exceptionReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.exceptionReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.seeReferences != null) {\n\t\t\tfor (int i = 0, length = this.seeReferences.length; i < length; i++) {\n\t\t\t\tprintIndent(indent, output).append(\" * @see \"); //$NON-NLS-1$\n\t\t\t\tthis.seeReferences[i].print(indent, output).append('\\n');\n\t\t\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\t\t\tnodePrinted =  this.completionNode == this.seeReferences[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!nodePrinted && this.completionNode != null) {\n\t\t\tprintIndent(indent, output).append(\" * \"); //$NON-NLS-1$\n\t\t\tthis.completionNode.print(indent, output).append('\\n');\n\t\t}\n\t\tprintIndent(indent, output).append(\" */\\n\"); //$NON-NLS-1$\n\t\treturn output;\n\t}\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(ClassScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(CompilationUnitScope scope) {\n\t\tinternalResolve(scope);\n\t}\n\t/**\n\t * Resolve completion node if not null and throw exception to let clients know\n\t * that it has been found.\n\t *\n\t * @throws CompletionNodeFound\n\t */\n\tpublic void resolve(MethodScope scope) {\n\t\tsuper.resolve(scope);\n\t\tinternalResolve(scope);\n\t}\n\t/*\n\t * Look for missing method @param tags\n\t */\n\tprivate char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {\n\t\t// Verify if there's some possible param tag\n\t\tAbstractMethodDeclaration md = methScope.referenceMethod();\n\t\tint paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;\n\t\tif (md == null) return null;\n\t\tint argumentsSize = md.arguments == null ? 0 : md.arguments.length;\n\t\tif (argumentsSize == 0) return null;\n\t\t// Store all method arguments if there's no @param in javadoc\n\t\tif (paramTagsSize == 0) {\n\t\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\t\tmissingParams[i] = md.arguments[i].name;\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\t\t// Look for missing arguments\n\t\tchar[][] missingParams = new char[argumentsSize][];\n\t\tint size = 0;\n\t\tfor (int i = 0; i < argumentsSize; i++) {\n\t\t\tArgument arg = md.arguments[i];\n\t\t\tboolean found = false;\n\t\t\tint paramNameRefCount = 0;\n\t\t\tfor (int j = 0; j < paramTagsSize && !found; j++) {\n\t\t\t\tJavadocSingleNameReference param = this.paramReferences[j];\n\t\t\t\tif (arg.binding == param.binding) {\n\t\t\t\t\tif (param.binding == paramNameRefBinding) { // do not count first occurence of param name reference\n\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tmissingParams[size++] = arg.name;\n\t\t\t}\n\t\t}\n\t\tif (size > 0) {\n\t\t\tif (size != argumentsSize) {\n\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t}\n\t\t\treturn missingParams;\n\t\t}\n\t\treturn null;\n\t}\n\t/*\n\t * Look for missing type parameters @param tags\n\t */\n\tprivate char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {\n\t\tint paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;\n\t\t// Verify if there's any type parameter to tag\n\t\tTypeParameter[] parameters =  null;\n\t\tTypeVariableBinding[] typeVariables = null;\n\t\tswitch (scope.kind) {\n\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\tAbstractMethodDeclaration methodDeclaration = ((MethodScope)scope).referenceMethod();\n\t\t\t\tif (methodDeclaration == null) return null;\n\t\t\t\tparameters = methodDeclaration.typeParameters();\n\t\t\t\ttypeVariables = methodDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\tTypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;\n\t\t\t\tparameters = typeDeclaration.typeParameters;\n\t\t\t\ttypeVariables = typeDeclaration.binding.typeVariables;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (typeVariables == null || typeVariables.length == 0) return null;\n\t\t// Store all type parameters if there's no @param in javadoc\n\t\tif (parameters != null) {\n\t\t\tint typeParametersLength = parameters.length;\n\t\t\tif (paramTypeParamLength == 0) {\n\t\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\t\tmissingParams[i] = parameters[i].name;\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\t\t\t// Look for missing type parameter\n\t\t\tchar[][] missingParams = new char[typeParametersLength][];\n\t\t\tint size = 0;\n\t\t\tfor (int i = 0; i < typeParametersLength; i++) {\n\t\t\t\tTypeParameter parameter = parameters[i];\n\t\t\t\tboolean found = false;\n\t\t\t\tint paramNameRefCount = 0;\n\t\t\t\tfor (int j = 0; j < paramTypeParamLength && !found; j++) {\n\t\t\t\t\tif (parameter.binding == this.paramTypeParameters[j].resolvedType) {\n\t\t\t\t\t\tif (parameter.binding == paramNameRefBinding) { // do not count first occurence of param nmae reference\n\t\t\t\t\t\t\tparamNameRefCount++;\n\t\t\t\t\t\t\tfound = paramNameRefCount > 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tmissingParams[size++] = parameter.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0) {\n\t\t\t\tif (size != typeParametersLength) {\n\t\t\t\t\tSystem.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n\t\t\t\t}\n\t\t\t\treturn missingParams;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n"]]}
{"hexsha": "b340f2fb457ab4721fc8027ede739eb8fda262c5", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class CertificateTypeServiceImpl implements CertificateTypeService {\n\n    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);\n\n    private final CertificateTypeRepository certificateTypeRepository;\n\n    private final CertificateTypeMapper certificateTypeMapper;\n\n    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {\n        this.certificateTypeRepository = certificateTypeRepository;\n        this.certificateTypeMapper = certificateTypeMapper;\n    }\n\n    /**\n     * Save a certificateType.\n     *\n     * @param certificateTypeDTO the entity to save.\n     * @return the persisted entity.\n     */\n    @Override\n    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {\n        log.debug(\"Request to save CertificateType : {}\", certificateTypeDTO);\n        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);\n        certificateType = certificateTypeRepository.save(certificateType);\n        return certificateTypeMapper.toDto(certificateType);\n    }\n\n    /**\n     * Get all the certificateTypes.\n     *\n     * @return the list of entities.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public List<CertificateTypeDTO> findAll() {\n        log.debug(\"Request to get all CertificateTypes\");\n        return certificateTypeRepository.findAll().stream()\n            .map(certificateTypeMapper::toDto)\n            .collect(Collectors.toCollection(LinkedList::new));\n    }\n\n    /**\n     * Get one certificateType by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public Optional<CertificateTypeDTO> findOne(Long id) {\n        log.debug(\"Request to get CertificateType : {}\", id);\n        return certificateTypeRepository.findById(id)\n            .map(certificateTypeMapper::toDto);\n    }\n\n    /**\n     * Delete the certificateType by id.\n     *\n     * @param id the id of the entity.\n     */\n    @Override\n    public void delete(Long id) {\n        log.debug(\"Request to delete CertificateType : {}\", id);\n        certificateTypeRepository.deleteById(id);\n    }\n}", "class_id": 0, "repo": "boutainaLemrabet/jhipster-composite-key-server-blueprint", "file": "test/samples/composite-key-blueprint/src/main/java/com/mycompany/myapp/service/impl/CertificateTypeServiceImpl.java", "last_update_at": "2021-09-15T07:41:05+00:00", "question_id": "b340f2fb457ab4721fc8027ede739eb8fda262c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class CertificateTypeServiceImpl implements CertificateTypeService {\n    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);\n    private final CertificateTypeRepository certificateTypeRepository;\n    private final CertificateTypeMapper certificateTypeMapper;\n    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {\n        this.certificateTypeRepository = certificateTypeRepository;\n        this.certificateTypeMapper = certificateTypeMapper;\n    }\n    /**\n     * Save a certificateType.\n     *\n     * @param certificateTypeDTO the entity to save.\n     * @return the persisted entity.\n     */\n    @Override\n    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {\n        log.debug(\"Request to save CertificateType : {}\", certificateTypeDTO);\n        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);\n        certificateType = certificateTypeRepository.save(certificateType);\n        return certificateTypeMapper.toDto(certificateType);\n    }\n    /**\n     * Get all the certificateTypes.\n     *\n     * @return the list of entities.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public List<CertificateTypeDTO> findAll() {\n        log.debug(\"Request to get all CertificateTypes\");\n        return certificateTypeRepository.findAll().stream()\n            .map(certificateTypeMapper::toDto)\n            .collect(Collectors.toCollection(LinkedList::new));\n    }\n    /**\n     * Get one certificateType by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public Optional<CertificateTypeDTO> findOne(Long id) {\n        log.debug(\"Request to get CertificateType : {}\", id);\n        return certificateTypeRepository.findById(id)\n            .map(certificateTypeMapper::toDto);\n    }\n    /**\n     * Delete the certificateType by id.\n     *\n     * @param id the id of the entity.\n     */\n    @Override\n    public void delete(Long id) {\n        log.debug(\"Request to delete CertificateType : {}\", id);\n        certificateTypeRepository.deleteById(id);\n    }\n"]]}
{"hexsha": "66221d0b3719371c37d84e20dc260cfa0cb7971a", "ext": "java", "lang": "Java", "content": "public class ClientServiceImplTest extends AbstractSpringTests {\n\n    @Autowired\n    private ClientService clientService;\n\n    public ClientServiceImplTest() {\n        super(true);\n    }\n\n    @Test\n    public void testCreate_notAdmin_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        expectNotAdmin(() -> {\n            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);\n        });\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testCreate_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testCreate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testCreate_shortName_exists_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testDelete_notAdmin_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        expectNotAdmin(() -> {\n            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        });\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testDelete_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testDelete_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testListAll_notAdmin_FAIL() {\n        expectNotAdmin(() -> {\n            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);\n        });\n    }\n\n    @Test\n    public void testListAll_OK() {\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-testListAll_OK.json\", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));\n    }\n\n    @Test\n    public void testUpdate_noChange_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_notAdmin_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        expectNotAdmin(() -> {\n            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        });\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_shortName_exists_FAIL() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n    @Test\n    public void testUpdate_shortName_OK() {\n\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(\"bbb\") //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_shortName_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n\n    }\n\n}", "class_id": 0, "repo": "foilen/foilen-crm", "file": "src/test/java/com/foilen/crm/services/ClientServiceImplTest.java", "last_update_at": "2021-02-23T13:22:53+00:00", "question_id": "66221d0b3719371c37d84e20dc260cfa0cb7971a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClientServiceImplTest extends AbstractSpringTests {\n    @Autowired\n    private ClientService clientService;\n    public ClientServiceImplTest() {\n        super(true);\n    }\n    @Test\n    public void testCreate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testCreate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(\"abc\") //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testCreate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testCreate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"ABC\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Abc Def\").setEmail(\"abc@example.com\") //\n                .setAddress(\"555 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://abc.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testDelete_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        expectNotAdmin(() -> {\n            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testDelete_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testDelete_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testListAll_notAdmin_FAIL() {\n        expectNotAdmin(() -> {\n            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);\n        });\n    }\n    @Test\n    public void testListAll_OK() {\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-testListAll_OK.json\", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));\n    }\n    @Test\n    public void testUpdate_noChange_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar Yay\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR) //\n                .setContactName(\"Benoit Banana\").setEmail(\"benoit@example2.com\") //\n                .setAddress(\"1020 Betancour\").setTel(\"555-202-0101\") //\n                .setMainSite(\"http://bazar.here.com\") //\n                .setLang(\"EN\") //\n                .setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA) //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n    @Test\n    public void testUpdate_shortName_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = new CreateOrUpdateClientForm() //\n                .setName(\"Bazar\")//\n                .setShortName(\"bbb\") //\n                .setContactName(\"Benoit Bezos\").setEmail(\"benoit@example.com\") //\n                .setAddress(\"1010 Betancour\").setTel(\"555-101-0101\") //\n                .setMainSite(\"http://bazar.example.com\") //\n                .setLang(\"FR\") //\n                .setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_shortName_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n"]]}
{"hexsha": "201d81bb57bfceee81740093f870c685ab999062", "ext": "java", "lang": "Java", "content": "class Solution1 {\n\n  private int[][] dx_dy = new int[][]{\n      {0, 1}, {0, -1}, {1, 0}, {-1, 0}\n  };\n\n  private void dfs(int[][] image, int i, int j) {\n    if (i < 0 || j < 0 || i >= image.length || j >= image[0].length\n        || image[i][j] != oldColor)\n      return;\n    image[i][j] = newColor;\n    for (int[] offset : dx_dy) {\n      dfs(image, i + offset[0], j + offset[1]);\n    }\n  }\n\n  private int oldColor = 0, newColor = 0;\n\n  public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    this.oldColor = image[sr][sc];\n    this.newColor = newColor;\n    if (this.oldColor == this.newColor) return image;\n    dfs(image, sr, sc);\n    return image;\n  }\n\n  private static void test(int[][] image, int sr, int sc, int newColor) {\n    Solution1 solution = new Solution1();\n    int[][] ans = solution.floodFill(image, sr, sc, newColor);\n    for (int[] ints : ans) {\n      for (int i : ints) {\n        System.out.print(i + \" \");\n      }\n      System.out.println();\n    }\n    System.out.println();\n  }\n\n  public static void main(String[] args) {\n    test(new int[][]{\n        {0, 0, 0},\n        {0, 1, 1}}, 1, 1, 1);\n    test(new int[][]{\n        {1, 1, 1},\n        {1, 1, 0},\n        {1, 0, 1}}, 1, 1, 2);\n\n  }\n}", "class_id": 0, "repo": "ooooo-youwillsee/leetcode", "file": "lcci_08_10/java_08_10/src/com/ooooo/Solution1.java", "last_update_at": "2021-12-19T02:24:33+00:00", "question_id": "201d81bb57bfceee81740093f870c685ab999062", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution1 {\n  private int[][] dx_dy = new int[][]{\n      {0, 1}, {0, -1}, {1, 0}, {-1, 0}\n  };\n  private void dfs(int[][] image, int i, int j) {\n    if (i < 0 || j < 0 || i >= image.length || j >= image[0].length\n        || image[i][j] != oldColor)\n      return;\n    image[i][j] = newColor;\n    for (int[] offset : dx_dy) {\n      dfs(image, i + offset[0], j + offset[1]);\n    }\n  }\n  private int oldColor = 0, newColor = 0;\n  public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    this.oldColor = image[sr][sc];\n    this.newColor = newColor;\n    if (this.oldColor == this.newColor) return image;\n    dfs(image, sr, sc);\n    return image;\n  }\n  private static void test(int[][] image, int sr, int sc, int newColor) {\n    Solution1 solution = new Solution1();\n    int[][] ans = solution.floodFill(image, sr, sc, newColor);\n    for (int[] ints : ans) {\n      for (int i : ints) {\n        System.out.print(i + \" \");\n      }\n      System.out.println();\n    }\n    System.out.println();\n  }\n  public static void main(String[] args) {\n    test(new int[][]{\n        {0, 0, 0},\n        {0, 1, 1}}, 1, 1, 1);\n    test(new int[][]{\n        {1, 1, 1},\n        {1, 1, 0},\n        {1, 0, 1}}, 1, 1, 2);\n  }\n"]]}
{"hexsha": "5e28482a90909ff8a582c684e353d5dcc0a58b48", "ext": "java", "lang": "Java", "content": "@EqualsAndHashCode(of = { \"annotatedObject\", \"descriptor\", \"clientId\" })\n/* package */class AnnotatedModelInterceptor implements IModelInterceptor\n{\n\tprivate static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);\n\n\tprivate final AnnotatedModelInterceptorDescriptor descriptor;\n\tprivate final transient Object annotatedObject;\n\tprivate ClientId clientId;\n\n\t/**\n\t * @param annotatedObject\n\t */\n\tAnnotatedModelInterceptor(@NonNull final Object annotatedObject)\n\t{\n\t\tthis.annotatedObject = annotatedObject;\n\t\tthis.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass())\n\t\t\t\t.build();\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"annotated[\" + annotatedObject.getClass().getName() + \"]\";\n\t}\n\n\t/**\n\t *\n\t * @return true if it has no initializers, no pointcuts, no nothing\n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\treturn descriptor.isEmpty();\n\t}\n\n\t@Override\n\tpublic void initialize(final IModelValidationEngine engine, final I_AD_Client client)\n\t{\n\t\tif (client != null)\n\t\t{\n\t\t\tthis.clientId = ClientId.ofRepoId(client.getAD_Client_ID());\n\t\t}\n\n\t\tbindPointcuts(engine);\n\n\t\t//\n\t\t// Execute initializers\n\t\tfor (final InterceptorInit init : descriptor.getInitializers())\n\t\t{\n\t\t\tObject[] params = new Object[] {};\n\t\t\tif (init.isMethodRequiresEngine())\n\t\t\t{\n\t\t\t\tparams = new Object[] { engine };\n\t\t\t}\n\n\t\t\tfinal Method method = init.getMethod();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Make sure the method is accessible\n\t\t\t\tif (!method.isAccessible())\n\t\t\t\t{\n\t\t\t\t\tmethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\t// Execute\n\t\t\t\tmethod.invoke(annotatedObject, params);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new AdempiereException(\"Cannot initialize \" + annotatedObject + \". Initializer \" + init + \" failed.\"\n\t\t\t\t\t\t+ \"\\n Method: \" + method\n\t\t\t\t\t\t+ \"\\n Params:\" + Arrays.toString(params)\n\t\t\t\t\t\t+ \"\\n Method Descriptor: \" + init, Throwables.getRootCause(e));\n\t\t\t}\n\n\t\t\tlogger.debug(\"Initializer {} executed successfully.\", init);\n\t\t}\n\t}\n\n\tprivate void bindPointcuts(@NonNull final IModelValidationEngine engine)\n\t{\n\t\tlogger.debug(\"Binding pointcuts for {}\", annotatedObject);\n\t\tfor (final PointcutKey key : descriptor.getPointcutKeys())\n\t\t{\n\t\t\tfinal Set<Pointcut> list = descriptor.getPointcuts(key);\n\t\t\tif (list.isEmpty())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlogger.debug(\"Binding pointcuts for {} on {}\", annotatedObject, key);\n\n\t\t\tswitch (key.getType())\n\t\t\t{\n\t\t\t\tcase ModelChange:\n\t\t\t\t\tengine.addModelChange(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DocValidate:\n\t\t\t\t\tengine.addDocValidate(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new AdempiereException(\"Unknown PointcutType \" + key.getType());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"Binding pointcuts for {} done.\", annotatedObject);\n\t}\n\n\t@Override\n\tpublic int getAD_Client_ID()\n\t{\n\t\treturn ClientId.toRepoId(clientId);\n\t}\n\n\t@Override\n\tpublic void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID)\n\t{\n\t\t// nothing\n\t}\n\n\t@Override\n\tpublic final void onModelChange(final Object model, final ModelChangeType changeType)\n\t{\n\t\texecute(PointcutType.ModelChange, model, changeType.toInt());\n\t}\n\n\t@Override\n\tpublic final void onDocValidate(final Object model, final DocTimingType timing)\n\t{\n\t\texecute(PointcutType.DocValidate, model, timing.toInt());\n\t}\n\n\tprivate void execute(final PointcutType type, final Object po, final int timing)\n\t{\n\t\tfinal String tableName = InterfaceWrapperHelper.getModelTableName(po);\n\t\tfinal PointcutKey key = PointcutKey.of(tableName, type);\n\t\tfinal ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);\n\t\tif (pointcuts.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (final Pointcut pointcut : pointcuts)\n\t\t{\n\t\t\texecute(pointcut, po, timing);\n\t\t}\n\t}\n\n\tprivate void execute(final Pointcut pointcut, final Object po, final int timing)\n\t{\n\t\t//\n\t\t// Check timings\n\t\tfinal Set<Integer> timings = pointcut.getTimings();\n\t\tif (!timings.contains(timing))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// Check if UserAction required (i.e. user manually changed this record from a window)\n\t\tif (pointcut.isOnlyIfUIAction())\n\t\t{\n\t\t\tfinal boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);\n\t\t\tif (!isUIAction)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Check if we shall skip when copying\n\t\tif (pointcut.isSkipIfCopying())\n\t\t{\n\t\t\tfinal boolean isCopying = InterfaceWrapperHelper.isCopy(po);\n\t\t\tif (isCopying)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Check changed columns (only if timing is before/after change).\n\t\t// #105 FRESH-442: only check for changed columns on \"change\". For \"new\" and \"delete\", execute the pointcut.\n\t\t// Else, does not make sense.\n\t\tif (isTimingChange(timing))\n\t\t{\n\t\t\tfinal Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();\n\t\t\tif (!columnsToCheckForChanges.isEmpty())\n\t\t\t{\n\t\t\t\t// none of our columns had changed; skip\n\t\t\t\tif (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Execute the method now\n\t\tif (!pointcut.isAfterCommit())\n\t\t{\n\t\t\texecuteNow(po, pointcut, timing);\n\t\t}\n\t\t//\n\t\t// ... or schedule it to be executed after commit\n\t\telse\n\t\t{\n\t\t\tlogger.trace(\"Scheduling to be executed after commit: {}\", pointcut);\n\t\t\tfinal String trxName = InterfaceWrapperHelper.getTrxName(po);\n\n\t\t\tServices.get(ITrxManager.class)\n\t\t\t\t\t.getTrxListenerManagerOrAutoCommit(trxName)\n\t\t\t\t\t.newEventListener(TrxEventTiming.AFTER_COMMIT)\n\t\t\t\t\t.additionalToStringInfo(() -> MoreObjects.toStringHelper(this)\n\t\t\t\t\t\t\t.add(\"pointcut\", pointcut)\n\t\t\t\t\t\t\t.add(\"po\", po)\n\t\t\t\t\t\t\t.add(\"timing\", timing)\n\t\t\t\t\t\t\t.toString())\n\t\t\t\t\t.invokeMethodJustOnce(true)\n\t\t\t\t\t.registerHandlingMethod(transaction -> {\n\n\t\t\t\t\t\texecuteNow(po, pointcut, timing);\n\t\t\t\t\t\tInterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);\n\t\t\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate final void executeNow(\n\t\t\t@NonNull final Object po,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing)\n\t{\n\t\tif (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut))\n\t\t{\n\t\t\tlogger.info(\"Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}\",\n\t\t\t\t\tAnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());\n\t\ttry\n\t\t{\n\t\t\texecuteNow0(model, pointcut, timing);\n\t\t}\n\t\tcatch (final Exception e)\n\t\t{\n\t\t\tfinal AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);\n\t\t\tthrow adempiereException;\n\t\t}\n\t}\n\n\tprivate static AdempiereException appendAndLogHowtoDisableMessage(\n\t\t\t@NonNull final Exception e,\n\t\t\t@NonNull final Pointcut pointcut)\n\t{\n\t\tfinal String parameterName = \"HowtoDisableModelInterceptor\";\n\t\tfinal AdempiereException ae = AdempiereException.wrapIfNeeded(e);\n\n\t\tif (!ae.hasParameter(parameterName))\n\t\t{\n\t\t\tfinal String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);\n\n\t\t\tlogger.error(howtoDisableMsg);\n\t\t\tae.setParameter(parameterName, howtoDisableMsg);\n\t\t}\n\t\treturn ae;\n\t}\n\n\tprivate void executeNow0(\n\t\t\t@NonNull final Object model,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing) throws IllegalAccessException, InvocationTargetException\n\t{\n\t\tfinal Method method = pointcut.getMethod();\n\n\t\t// Make sure the method is accessible\n\t\tif (!method.isAccessible())\n\t\t{\n\t\t\tmethod.setAccessible(true);\n\t\t}\n\n\t\tfinal Stopwatch stopwatch = Stopwatch.createStarted();\n\t\tif (pointcut.isMethodRequiresTiming())\n\t\t{\n\t\t\tfinal Object timingParam = pointcut.convertToMethodTimingParameterType(timing);\n\t\t\tmethod.invoke(annotatedObject, model, timingParam);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmethod.invoke(annotatedObject, model);\n\t\t}\n\n\t\tlogger.trace(\"Executed in {}: {} (timing={}) on {}\", stopwatch, pointcut, timing, model);\n\t}\n\n\t/**\n\t *\n\t * @param timing\n\t * @return true if timing is change (before, after)\n\t */\n\tprivate static final boolean isTimingChange(final int timing)\n\t{\n\t\treturn ModelValidator.TYPE_BEFORE_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;\n\t}\n}", "class_id": 0, "repo": "focadiz/metasfresh", "file": "backend/de.metas.adempiere.adempiere/base/src/main/java/org/adempiere/ad/modelvalidator/AnnotatedModelInterceptor.java", "last_update_at": "2021-02-17T12:00:41+00:00", "question_id": "5e28482a90909ff8a582c684e353d5dcc0a58b48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@EqualsAndHashCode(of = { \"annotatedObject\", \"descriptor\", \"clientId\" })\n/* package */class AnnotatedModelInterceptor implements IModelInterceptor\n{\n\tprivate static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);\n\tprivate final AnnotatedModelInterceptorDescriptor descriptor;\n\tprivate final transient Object annotatedObject;\n\tprivate ClientId clientId;\n\t/**\n\t * @param annotatedObject\n\t */\n\tAnnotatedModelInterceptor(@NonNull final Object annotatedObject)\n\t{\n\t\tthis.annotatedObject = annotatedObject;\n\t\tthis.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass())\n\t\t\t\t.build();\n\t}\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"annotated[\" + annotatedObject.getClass().getName() + \"]\";\n\t}\n\t/**\n\t *\n\t * @return true if it has no initializers, no pointcuts, no nothing\n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\treturn descriptor.isEmpty();\n\t}\n\t@Override\n\tpublic void initialize(final IModelValidationEngine engine, final I_AD_Client client)\n\t{\n\t\tif (client != null)\n\t\t{\n\t\t\tthis.clientId = ClientId.ofRepoId(client.getAD_Client_ID());\n\t\t}\n\t\tbindPointcuts(engine);\n\t\t//\n\t\t// Execute initializers\n\t\tfor (final InterceptorInit init : descriptor.getInitializers())\n\t\t{\n\t\t\tObject[] params = new Object[] {};\n\t\t\tif (init.isMethodRequiresEngine())\n\t\t\t{\n\t\t\t\tparams = new Object[] { engine };\n\t\t\t}\n\t\t\tfinal Method method = init.getMethod();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Make sure the method is accessible\n\t\t\t\tif (!method.isAccessible())\n\t\t\t\t{\n\t\t\t\t\tmethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\t// Execute\n\t\t\t\tmethod.invoke(annotatedObject, params);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new AdempiereException(\"Cannot initialize \" + annotatedObject + \". Initializer \" + init + \" failed.\"\n\t\t\t\t\t\t+ \"\\n Method: \" + method\n\t\t\t\t\t\t+ \"\\n Params:\" + Arrays.toString(params)\n\t\t\t\t\t\t+ \"\\n Method Descriptor: \" + init, Throwables.getRootCause(e));\n\t\t\t}\n\t\t\tlogger.debug(\"Initializer {} executed successfully.\", init);\n\t\t}\n\t}\n\tprivate void bindPointcuts(@NonNull final IModelValidationEngine engine)\n\t{\n\t\tlogger.debug(\"Binding pointcuts for {}\", annotatedObject);\n\t\tfor (final PointcutKey key : descriptor.getPointcutKeys())\n\t\t{\n\t\t\tfinal Set<Pointcut> list = descriptor.getPointcuts(key);\n\t\t\tif (list.isEmpty())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlogger.debug(\"Binding pointcuts for {} on {}\", annotatedObject, key);\n\t\t\tswitch (key.getType())\n\t\t\t{\n\t\t\t\tcase ModelChange:\n\t\t\t\t\tengine.addModelChange(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DocValidate:\n\t\t\t\t\tengine.addDocValidate(key.getTableName(), this);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new AdempiereException(\"Unknown PointcutType \" + key.getType());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"Binding pointcuts for {} done.\", annotatedObject);\n\t}\n\t@Override\n\tpublic int getAD_Client_ID()\n\t{\n\t\treturn ClientId.toRepoId(clientId);\n\t}\n\t@Override\n\tpublic void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID)\n\t{\n\t\t// nothing\n\t}\n\t@Override\n\tpublic final void onModelChange(final Object model, final ModelChangeType changeType)\n\t{\n\t\texecute(PointcutType.ModelChange, model, changeType.toInt());\n\t}\n\t@Override\n\tpublic final void onDocValidate(final Object model, final DocTimingType timing)\n\t{\n\t\texecute(PointcutType.DocValidate, model, timing.toInt());\n\t}\n\tprivate void execute(final PointcutType type, final Object po, final int timing)\n\t{\n\t\tfinal String tableName = InterfaceWrapperHelper.getModelTableName(po);\n\t\tfinal PointcutKey key = PointcutKey.of(tableName, type);\n\t\tfinal ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);\n\t\tif (pointcuts.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (final Pointcut pointcut : pointcuts)\n\t\t{\n\t\t\texecute(pointcut, po, timing);\n\t\t}\n\t}\n\tprivate void execute(final Pointcut pointcut, final Object po, final int timing)\n\t{\n\t\t//\n\t\t// Check timings\n\t\tfinal Set<Integer> timings = pointcut.getTimings();\n\t\tif (!timings.contains(timing))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t//\n\t\t// Check if UserAction required (i.e. user manually changed this record from a window)\n\t\tif (pointcut.isOnlyIfUIAction())\n\t\t{\n\t\t\tfinal boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);\n\t\t\tif (!isUIAction)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// Check if we shall skip when copying\n\t\tif (pointcut.isSkipIfCopying())\n\t\t{\n\t\t\tfinal boolean isCopying = InterfaceWrapperHelper.isCopy(po);\n\t\t\tif (isCopying)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// Check changed columns (only if timing is before/after change).\n\t\t// #105 FRESH-442: only check for changed columns on \"change\". For \"new\" and \"delete\", execute the pointcut.\n\t\t// Else, does not make sense.\n\t\tif (isTimingChange(timing))\n\t\t{\n\t\t\tfinal Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();\n\t\t\tif (!columnsToCheckForChanges.isEmpty())\n\t\t\t{\n\t\t\t\t// none of our columns had changed; skip\n\t\t\t\tif (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// Execute the method now\n\t\tif (!pointcut.isAfterCommit())\n\t\t{\n\t\t\texecuteNow(po, pointcut, timing);\n\t\t}\n\t\t//\n\t\t// ... or schedule it to be executed after commit\n\t\telse\n\t\t{\n\t\t\tlogger.trace(\"Scheduling to be executed after commit: {}\", pointcut);\n\t\t\tfinal String trxName = InterfaceWrapperHelper.getTrxName(po);\n\t\t\tServices.get(ITrxManager.class)\n\t\t\t\t\t.getTrxListenerManagerOrAutoCommit(trxName)\n\t\t\t\t\t.newEventListener(TrxEventTiming.AFTER_COMMIT)\n\t\t\t\t\t.additionalToStringInfo(() -> MoreObjects.toStringHelper(this)\n\t\t\t\t\t\t\t.add(\"pointcut\", pointcut)\n\t\t\t\t\t\t\t.add(\"po\", po)\n\t\t\t\t\t\t\t.add(\"timing\", timing)\n\t\t\t\t\t\t\t.toString())\n\t\t\t\t\t.invokeMethodJustOnce(true)\n\t\t\t\t\t.registerHandlingMethod(transaction -> {\n\t\t\t\t\t\texecuteNow(po, pointcut, timing);\n\t\t\t\t\t\tInterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);\n\t\t\t\t\t});\n\t\t}\n\t}\n\t@VisibleForTesting\n\tprivate final void executeNow(\n\t\t\t@NonNull final Object po,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing)\n\t{\n\t\tif (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut))\n\t\t{\n\t\t\tlogger.info(\"Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}\",\n\t\t\t\t\tAnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);\n\t\t\treturn;\n\t\t}\n\t\tfinal Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());\n\t\ttry\n\t\t{\n\t\t\texecuteNow0(model, pointcut, timing);\n\t\t}\n\t\tcatch (final Exception e)\n\t\t{\n\t\t\tfinal AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);\n\t\t\tthrow adempiereException;\n\t\t}\n\t}\n\tprivate static AdempiereException appendAndLogHowtoDisableMessage(\n\t\t\t@NonNull final Exception e,\n\t\t\t@NonNull final Pointcut pointcut)\n\t{\n\t\tfinal String parameterName = \"HowtoDisableModelInterceptor\";\n\t\tfinal AdempiereException ae = AdempiereException.wrapIfNeeded(e);\n\t\tif (!ae.hasParameter(parameterName))\n\t\t{\n\t\t\tfinal String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);\n\t\t\tlogger.error(howtoDisableMsg);\n\t\t\tae.setParameter(parameterName, howtoDisableMsg);\n\t\t}\n\t\treturn ae;\n\t}\n\tprivate void executeNow0(\n\t\t\t@NonNull final Object model,\n\t\t\t@NonNull final Pointcut pointcut,\n\t\t\tfinal int timing) throws IllegalAccessException, InvocationTargetException\n\t{\n\t\tfinal Method method = pointcut.getMethod();\n\t\t// Make sure the method is accessible\n\t\tif (!method.isAccessible())\n\t\t{\n\t\t\tmethod.setAccessible(true);\n\t\t}\n\t\tfinal Stopwatch stopwatch = Stopwatch.createStarted();\n\t\tif (pointcut.isMethodRequiresTiming())\n\t\t{\n\t\t\tfinal Object timingParam = pointcut.convertToMethodTimingParameterType(timing);\n\t\t\tmethod.invoke(annotatedObject, model, timingParam);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmethod.invoke(annotatedObject, model);\n\t\t}\n\t\tlogger.trace(\"Executed in {}: {} (timing={}) on {}\", stopwatch, pointcut, timing, model);\n\t}\n\t/**\n\t *\n\t * @param timing\n\t * @return true if timing is change (before, after)\n\t */\n\tprivate static final boolean isTimingChange(final int timing)\n\t{\n\t\treturn ModelValidator.TYPE_BEFORE_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE == timing\n\t\t\t\t|| ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;\n\t}\n"]]}
{"hexsha": "7d552efcea6c5f5cdd42841cc34ad20e76f615e1", "ext": "java", "lang": "Java", "content": "public final class MatrixAppendCPInstruction extends AppendCPInstruction {\n\n\tprotected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type,\n\t\tString opcode, String istr) {\n\t\tsuper(op, in1, in2, out, type, opcode, istr);\n\t}\n\n\t@Override\n\tpublic void processInstruction(ExecutionContext ec) {\n\t\t// get inputs\n\t\tMatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());\n\t\tMatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());\n\n\t\tvalidateInput(matBlock1, matBlock2);\n\n\t\tMatrixBlock ret;\n\t\tif(matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)\n\t\t\tret = CLALibAppend.append(matBlock1, matBlock2);\n\t\telse\n\t\t\tret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);\n\n\t\tec.setMatrixOutput(output.getName(), ret);\n\t\tec.releaseMatrixInput(input1.getName(), input2.getName());\n\t}\n\n\tprivate void validateInput(MatrixBlock m1, MatrixBlock m2) {\n\t\tif(_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-cbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of rows: \" + m1.getNumRows() + \" vs \" + m2.getNumRows());\n\t\t}\n\t\telse if(_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-rbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of columns: \" + m1.getNumColumns() + \" vs \" + m2.getNumColumns());\n\t\t}\n\t}\n\n\t@Override\n\tpublic Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {\n\t\t// TODO: break append to cbind and rbind for full compilation chain\n\t\tString opcode = _type.toString().toLowerCase();\n\t\treturn Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));\n\t}\n}", "class_id": 0, "repo": "Shafaq-Siddiqi/systemml", "file": "src/main/java/org/apache/sysds/runtime/instructions/cp/MatrixAppendCPInstruction.java", "last_update_at": "2021-06-08T18:02:41+00:00", "question_id": "7d552efcea6c5f5cdd42841cc34ad20e76f615e1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class MatrixAppendCPInstruction extends AppendCPInstruction {\n\tprotected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type,\n\t\tString opcode, String istr) {\n\t\tsuper(op, in1, in2, out, type, opcode, istr);\n\t}\n\t@Override\n\tpublic void processInstruction(ExecutionContext ec) {\n\t\t// get inputs\n\t\tMatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());\n\t\tMatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());\n\t\tvalidateInput(matBlock1, matBlock2);\n\t\tMatrixBlock ret;\n\t\tif(matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)\n\t\t\tret = CLALibAppend.append(matBlock1, matBlock2);\n\t\telse\n\t\t\tret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);\n\t\tec.setMatrixOutput(output.getName(), ret);\n\t\tec.releaseMatrixInput(input1.getName(), input2.getName());\n\t}\n\tprivate void validateInput(MatrixBlock m1, MatrixBlock m2) {\n\t\tif(_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-cbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of rows: \" + m1.getNumRows() + \" vs \" + m2.getNumRows());\n\t\t}\n\t\telse if(_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {\n\t\t\tthrow new DMLRuntimeException(\n\t\t\t\t\"Append-rbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName()\n\t\t\t\t\t+ \" with different number of columns: \" + m1.getNumColumns() + \" vs \" + m2.getNumColumns());\n\t\t}\n\t}\n\t@Override\n\tpublic Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {\n\t\t// TODO: break append to cbind and rbind for full compilation chain\n\t\tString opcode = _type.toString().toLowerCase();\n\t\treturn Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));\n\t}\n"]]}
{"hexsha": "95b4f2f41928e6bf7ea2abf2c075fca294df06a9", "ext": "java", "lang": "Java", "content": "@Component\n@Description(\"Authorization policy assigned by given identity by assigned or default role.\")\npublic class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {\n\n\t@Autowired @Lazy private RoleConfiguration roleConfiguration;\n\t@Autowired @Lazy private IdmRoleCompositionService roleCompositionService;\n\t\n\t@Autowired\n\tpublic AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {\n\t\tsuper(repository);\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;\n\t}\n\t\n\t@Override\n\tpublic Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {\n\t\tUUID identityId = filter.getIdentityId();\n\t\tif (identityId == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//\n\t\t// assigned role subquery\n\t\tSubquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);\n\t\tRoot<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);\n\t\tsubquery.select(subRoot);\n\t\tsubquery.where(\n                builder.and(\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId),\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role)) // correlation\n                \t\t)\n        );\n\t\tPredicate predicate = builder.exists(subquery);\n\t\t//\n\t\t// or default role\n\t\tUUID defaultRoleId = roleConfiguration.getDefaultRoleId();\n\t\tif (defaultRoleId == null) {\n\t\t\t// default role is not defined\n\t\t\treturn predicate;\n\t\t}\n\t\t//\n\t\t// find all default role sub roles \n\t\tSet<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);\n\t\tdefaultRoles.addAll(\n\t\t\t\troleCompositionService\n\t\t\t\t\t.findAllSubRoles(defaultRoleId)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(IdmRoleCompositionDto::getSub)\n\t\t\t\t\t.collect(Collectors.toSet())\n\t\t);\n\t\treturn builder.or(\n\t\t\t\tpredicate,\n\t\t\t\troot.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles)\n\t\t);\n\t}\n}", "class_id": 0, "repo": "piougy/CzechIdMng", "file": "Realization/backend/core/core-impl/src/main/java/eu/bcvsolutions/idm/core/model/repository/filter/AuthorizationPolicyByIdentityFilterBuilder.java", "last_update_at": "2021-08-06T19:55:05+00:00", "question_id": "95b4f2f41928e6bf7ea2abf2c075fca294df06a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Description(\"Authorization policy assigned by given identity by assigned or default role.\")\npublic class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {\n\t@Autowired @Lazy private RoleConfiguration roleConfiguration;\n\t@Autowired @Lazy private IdmRoleCompositionService roleCompositionService;\n\t\n\t@Autowired\n\tpublic AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {\n\t\tsuper(repository);\n\t}\n\t@Override\n\tpublic String getName() {\n\t\treturn IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;\n\t}\n\t\n\t@Override\n\tpublic Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {\n\t\tUUID identityId = filter.getIdentityId();\n\t\tif (identityId == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//\n\t\t// assigned role subquery\n\t\tSubquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);\n\t\tRoot<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);\n\t\tsubquery.select(subRoot);\n\t\tsubquery.where(\n                builder.and(\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId),\n                \t\tbuilder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role)) // correlation\n                \t\t)\n        );\n\t\tPredicate predicate = builder.exists(subquery);\n\t\t//\n\t\t// or default role\n\t\tUUID defaultRoleId = roleConfiguration.getDefaultRoleId();\n\t\tif (defaultRoleId == null) {\n\t\t\t// default role is not defined\n\t\t\treturn predicate;\n\t\t}\n\t\t//\n\t\t// find all default role sub roles \n\t\tSet<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);\n\t\tdefaultRoles.addAll(\n\t\t\t\troleCompositionService\n\t\t\t\t\t.findAllSubRoles(defaultRoleId)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(IdmRoleCompositionDto::getSub)\n\t\t\t\t\t.collect(Collectors.toSet())\n\t\t);\n\t\treturn builder.or(\n\t\t\t\tpredicate,\n\t\t\t\troot.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles)\n\t\t);\n\t}\n"]]}
{"hexsha": "d0aa6b0a1e5c6f19bbc40686624f1ab36563df62", "ext": "java", "lang": "Java", "content": "public class Dispatcher {\n  \n  /**\n   * DispatcherRunnable is the runnable class in which a group of dispatch\n   *   messages (sharing the same url) get dispatched to corresponding worker\n   *   service\n   */\n  private class DispatcherRunnable implements Runnable {\n    \n    private static final String kWorkerEntryPoint = \"/Worker\";\n\n    private String dispatchMessages;\n    private ArrayList<String> workersTopology;\n    \n    /**\n     * Constructor DispatcherRunnable\n     * @param url: worker service's url\n     * @param dispatchMessages: messages to be dispatched\n     * @return new DispatcherRunnable Object\n     */\n    public DispatcherRunnable (\n      String dispatchMessages) {\n\n      this.dispatchMessages = dispatchMessages;\n      \n      this.workersTopology = new ArrayList<String>();\n      \n      try {\n      \n        String propertiesWorkersTopology =\n          DispatcherProperties.i().getStringPropterty(\n            DispatcherProperties.kWorkersTopology);\n        \n        String[] topologyArr = propertiesWorkersTopology.split(\",\");\n        \n        for (String topologyEntry : topologyArr) {\n          \n          this.workersTopology.add(topologyEntry + kWorkerEntryPoint);\n        }\n      } catch (Exception e) {\n\n        throw new CodeException(\n          32,\n          1,\n          \"propterty [\"\n            + DispatcherProperties.kWorkersTopology\n            + \"] isn't defined in properties file [\"\n            + DispatcherProperties.i().getName()\n            + \"]\",\n          ExceptionClass.PROPERTIES);\n      }\n    }\n    \n    /**\n     * send the messages to be despatched in a POST http request to the\n     *   worker service\n     * NOTE: silent in case of failure, change as needed?\n     * */\n    @Override\n    public void run () {\n      \n      for (String workerTopologyPoint : this.workersTopology) {\n      \n        try {\n          \n          URLConnection urlConnection = RestSyncInl.restCall(\n            workerTopologyPoint,\n            RestCallType.POST,\n            this.dispatchMessages);\n          \n          if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {\n          \n            break;\n          }\n        } catch (Exception e) {\n          \n        }\n      }\n    }\n    \n    @Override\n    public String toString () {\n      \n      return\n        \"DispatcherRunnable:  dispatchMessages(\"\n        + this.dispatchMessages\n        + \")\";\n    }\n  }\n  \n  // url -> list of dispatch messages\n  private ArrayList<DispatchMessage> dispatchMessages;\n\n  /**\n   * Constructor Dispatcher\n   * @return new Dispatcher Object\n   */\n  public Dispatcher () {\n    \n    this.dispatchMessages = new ArrayList<DispatchMessage>();\n  }\n  \n  /**\n   * addDispatchMessage\n   * adds a new dispatch message to the dispatcher's buffer\n   * @param url: url of the worker service that handles this type of\n   *               dispatch message\n   * @param dispatchMessage: the message to be dispatched\n   * @throws Exception\n   */\n  public void addDispatchMessage (\n    DispatchMessage dispatchMessage) throws Exception {\n    \n    this.dispatchMessages.add(dispatchMessage);\n  }\n  \n  /**\n   * dispatchMessages\n   * dispatches all the dispatch messages in the dispatcher buffer to their\n   *   corresponding worker services then clears the dispatcher buffer\n   * @throws Exception\n   */\n  public void dispatchMessages () throws Exception {\n    \n    if (this.dispatchMessages.isEmpty() == true) {\n      \n      return;\n    }\n      \n    ThreadPool.i().executeInDispatcherPool(\n      new DispatcherRunnable(\n        new DispatchMessages(this.dispatchMessages).toJsonString() ) );\n    \n    this.dispatchMessages.clear();\n  }\n  \n  @Override\n  public String toString () {\n    \n    return this.dispatchMessages.toString();\n  }\n}", "class_id": 0, "repo": "vangav/vos_backend", "file": "src/com/vangav/backend/dispatcher/Dispatcher.java", "last_update_at": "2021-08-09T19:54:45+00:00", "question_id": "d0aa6b0a1e5c6f19bbc40686624f1ab36563df62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Dispatcher {\n  /**\n   * DispatcherRunnable is the runnable class in which a group of dispatch\n   *   messages (sharing the same url) get dispatched to corresponding worker\n   *   service\n   */\n  private class DispatcherRunnable implements Runnable {\n    private static final String kWorkerEntryPoint = \"/Worker\";\n    private String dispatchMessages;\n    private ArrayList<String> workersTopology;\n    /**\n     * Constructor DispatcherRunnable\n     * @param url: worker service's url\n     * @param dispatchMessages: messages to be dispatched\n     * @return new DispatcherRunnable Object\n     */\n    public DispatcherRunnable (\n      String dispatchMessages) {\n      this.dispatchMessages = dispatchMessages;\n      this.workersTopology = new ArrayList<String>();\n      try {\n        String propertiesWorkersTopology =\n          DispatcherProperties.i().getStringPropterty(\n            DispatcherProperties.kWorkersTopology);\n        String[] topologyArr = propertiesWorkersTopology.split(\",\");\n        for (String topologyEntry : topologyArr) {\n          this.workersTopology.add(topologyEntry + kWorkerEntryPoint);\n        }\n      } catch (Exception e) {\n        throw new CodeException(\n          32,\n          1,\n          \"propterty [\"\n            + DispatcherProperties.kWorkersTopology\n            + \"] isn't defined in properties file [\"\n            + DispatcherProperties.i().getName()\n            + \"]\",\n          ExceptionClass.PROPERTIES);\n      }\n    }\n    /**\n     * send the messages to be despatched in a POST http request to the\n     *   worker service\n     * NOTE: silent in case of failure, change as needed?\n     * */\n    @Override\n    public void run () {\n      for (String workerTopologyPoint : this.workersTopology) {\n        try {\n          URLConnection urlConnection = RestSyncInl.restCall(\n            workerTopologyPoint,\n            RestCallType.POST,\n            this.dispatchMessages);\n          if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {\n            break;\n          }\n        } catch (Exception e) {\n        }\n      }\n    }\n    @Override\n    public String toString () {\n      return\n        \"DispatcherRunnable:  dispatchMessages(\"\n        + this.dispatchMessages\n        + \")\";\n    }\n  }\n  // url -> list of dispatch messages\n  private ArrayList<DispatchMessage> dispatchMessages;\n  /**\n   * Constructor Dispatcher\n   * @return new Dispatcher Object\n   */\n  public Dispatcher () {\n    this.dispatchMessages = new ArrayList<DispatchMessage>();\n  }\n  /**\n   * addDispatchMessage\n   * adds a new dispatch message to the dispatcher's buffer\n   * @param url: url of the worker service that handles this type of\n   *               dispatch message\n   * @param dispatchMessage: the message to be dispatched\n   * @throws Exception\n   */\n  public void addDispatchMessage (\n    DispatchMessage dispatchMessage) throws Exception {\n    this.dispatchMessages.add(dispatchMessage);\n  }\n  /**\n   * dispatchMessages\n   * dispatches all the dispatch messages in the dispatcher buffer to their\n   *   corresponding worker services then clears the dispatcher buffer\n   * @throws Exception\n   */\n  public void dispatchMessages () throws Exception {\n    if (this.dispatchMessages.isEmpty() == true) {\n      return;\n    }\n    ThreadPool.i().executeInDispatcherPool(\n      new DispatcherRunnable(\n        new DispatchMessages(this.dispatchMessages).toJsonString() ) );\n    this.dispatchMessages.clear();\n  }\n  @Override\n  public String toString () {\n    return this.dispatchMessages.toString();\n  }\n"]]}
{"hexsha": "1168d4b7c2a618ee1fa85e5a4e7400a4dc63922f", "ext": "java", "lang": "Java", "content": "public class DialogShopCarAdapter extends BaseAdapter {\n    private static final int FIRST = 0;\n    private static final int SECOND = 1;\n    private static final int COUNT = 2;\n    private FunctionListActivity activity;\n    private List<Quotation> data;\n    private LayoutInflater mInflater;\n\n    private DelOnClickListener delOnClickListener;\n    private AddDelOnClickListener addDelOnClickListener;\n    private ShopCarDialog dialog;\n\n    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {\n        this.activity = activity;\n        mInflater = LayoutInflater.from(activity);\n        this.dialog = dialog;\n        this.delOnClickListener = new DelOnClickListener();\n        this.addDelOnClickListener = new AddDelOnClickListener();\n    }\n\n    public void setData(List<Quotation> data) {\n        this.data = data;\n    }\n\n    public List<Quotation> getData() {\n        return data;\n    }\n\n    @Override\n    public int getCount() {\n        return data == null ? 0 : data.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (data.get(position).type == 1) {\n            return FIRST;\n        } else {\n            return SECOND;\n        }\n    }\n\n    @Override\n    public int getViewTypeCount() {\n        return COUNT;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        int type = getItemViewType(position);\n        if (convertView == null) {\n            holder = new ViewHolder();\n            switch (type) {\n                case FIRST:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);\n                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);\n                    holder.clearAll = convertView.findViewById(R.id.tv_clear);\n                    holder.reset = convertView.findViewById(R.id.tv_reset);\n                    holder.clearAll.setOnClickListener(clickClear);\n                    holder.reset.setOnClickListener(clickReset);\n                    break;\n\n                case SECOND:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);\n                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);\n                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);\n                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);\n                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);\n                    break;\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        Quotation quotation = data.get(position);\n        switch (type) {\n            case FIRST:\n                String sectionTitle = String.format(\"%s . %d\", quotation.title, quotation.getExtra().size());\n                holder.tv_head.setText(sectionTitle);\n                holder.clearAll.setTag(quotation);\n                holder.reset.setTag(quotation);\n                break;\n\n            case SECOND:\n                holder.tv_name.setText(quotation.title);\n                if (quotation.title.equals(\"\u9875\u9762\u6570\u91cf\")) {\n                    holder.ivDelCar.setVisibility(View.VISIBLE);\n                    holder.tvNum.setVisibility(View.VISIBLE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);\n                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);\n                    holder.tvNum.setText(activity.getNum() + \"\");\n                    //\u52a0\u6570\u91cf\n                    holder.ivAddCar.setTag(R.id.action_type, 0);\n                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);\n                    //\u51cf\u6570\u91cf\n                    holder.ivDelCar.setTag(R.id.action_type, 1);\n                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);\n                } else {\n                    holder.ivDelCar.setVisibility(View.GONE);\n                    holder.tvNum.setVisibility(View.GONE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);\n                    holder.ivAddCar.setTag(quotation);\n                    holder.ivAddCar.setOnClickListener(delOnClickListener);\n                }\n\n                break;\n        }\n\n        return convertView;\n    }\n\n    private class ViewHolder {\n        TextView tv_head;\n\n        View reset;\n        View clearAll;\n\n        TextView tv_name;\n        ImageView ivAddCar;\n        ImageView ivDelCar;\n        TextView tvNum;\n    }\n\n    private View.OnClickListener clickClear = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.clearPickedFunction(tag);\n\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private View.OnClickListener clickReset = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.resetPickedFunction(tag);\n\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private class DelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            Quotation quotation = (Quotation) v.getTag();\n            if (quotation.isRadioItem()) {\n                return;\n            }\n\n            int pos = data.indexOf(quotation);\n            if (pos != -1) {\n                data.remove(quotation);\n                Quotation platform = null;\n                for (int i = pos - 1; i >= 0; --i) {\n                    Quotation quotation1 = data.get(i);\n                    if (quotation1.isPlatform()) {\n                        platform = quotation1;\n                        break;\n                    }\n                }\n\n                if (platform != null) {\n                    platform.getExtra().remove(quotation);\n                }\n\n                dialog.updateNum();\n                notifyDataSetChanged();\n            }\n        }\n    }\n\n    private class AddDelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            int type = (int) v.getTag(R.id.action_type);\n            switch (type) {\n                case 0: {\n                    int num = activity.getNum();\n                    num++;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n\n                case 1: {\n                    int num = activity.getNum();\n                    if (num < 1) {\n                        return;\n                    }\n                    num--;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n            }\n        }\n    }\n\n\n}", "class_id": 0, "repo": "JingMeng/Mart-Android", "file": "app/src/main/java/net/coding/mart/developers/adapter/DialogShopCarAdapter.java", "last_update_at": "2021-05-19T05:38:56+00:00", "question_id": "1168d4b7c2a618ee1fa85e5a4e7400a4dc63922f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DialogShopCarAdapter extends BaseAdapter {\n    private static final int FIRST = 0;\n    private static final int SECOND = 1;\n    private static final int COUNT = 2;\n    private FunctionListActivity activity;\n    private List<Quotation> data;\n    private LayoutInflater mInflater;\n    private DelOnClickListener delOnClickListener;\n    private AddDelOnClickListener addDelOnClickListener;\n    private ShopCarDialog dialog;\n    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {\n        this.activity = activity;\n        mInflater = LayoutInflater.from(activity);\n        this.dialog = dialog;\n        this.delOnClickListener = new DelOnClickListener();\n        this.addDelOnClickListener = new AddDelOnClickListener();\n    }\n    public void setData(List<Quotation> data) {\n        this.data = data;\n    }\n    public List<Quotation> getData() {\n        return data;\n    }\n    @Override\n    public int getCount() {\n        return data == null ? 0 : data.size();\n    }\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n    @Override\n    public int getItemViewType(int position) {\n        if (data.get(position).type == 1) {\n            return FIRST;\n        } else {\n            return SECOND;\n        }\n    }\n    @Override\n    public int getViewTypeCount() {\n        return COUNT;\n    }\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        int type = getItemViewType(position);\n        if (convertView == null) {\n            holder = new ViewHolder();\n            switch (type) {\n                case FIRST:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);\n                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);\n                    holder.clearAll = convertView.findViewById(R.id.tv_clear);\n                    holder.reset = convertView.findViewById(R.id.tv_reset);\n                    holder.clearAll.setOnClickListener(clickClear);\n                    holder.reset.setOnClickListener(clickReset);\n                    break;\n                case SECOND:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);\n                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);\n                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);\n                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);\n                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);\n                    break;\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        Quotation quotation = data.get(position);\n        switch (type) {\n            case FIRST:\n                String sectionTitle = String.format(\"%s . %d\", quotation.title, quotation.getExtra().size());\n                holder.tv_head.setText(sectionTitle);\n                holder.clearAll.setTag(quotation);\n                holder.reset.setTag(quotation);\n                break;\n            case SECOND:\n                holder.tv_name.setText(quotation.title);\n                if (quotation.title.equals(\"\u9875\u9762\u6570\u91cf\")) {\n                    holder.ivDelCar.setVisibility(View.VISIBLE);\n                    holder.tvNum.setVisibility(View.VISIBLE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);\n                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);\n                    holder.tvNum.setText(activity.getNum() + \"\");\n                    //\u52a0\u6570\u91cf\n                    holder.ivAddCar.setTag(R.id.action_type, 0);\n                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);\n                    //\u51cf\u6570\u91cf\n                    holder.ivDelCar.setTag(R.id.action_type, 1);\n                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);\n                } else {\n                    holder.ivDelCar.setVisibility(View.GONE);\n                    holder.tvNum.setVisibility(View.GONE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);\n                    holder.ivAddCar.setTag(quotation);\n                    holder.ivAddCar.setOnClickListener(delOnClickListener);\n                }\n                break;\n        }\n        return convertView;\n    }\n    private class ViewHolder {\n        TextView tv_head;\n        View reset;\n        View clearAll;\n        TextView tv_name;\n        ImageView ivAddCar;\n        ImageView ivDelCar;\n        TextView tvNum;\n    }\n    private View.OnClickListener clickClear = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.clearPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n    private View.OnClickListener clickReset = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.resetPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n    private class DelOnClickListener implements View.OnClickListener {\n        @Override\n        public void onClick(View v) {\n            Quotation quotation = (Quotation) v.getTag();\n            if (quotation.isRadioItem()) {\n                return;\n            }\n            int pos = data.indexOf(quotation);\n            if (pos != -1) {\n                data.remove(quotation);\n                Quotation platform = null;\n                for (int i = pos - 1; i >= 0; --i) {\n                    Quotation quotation1 = data.get(i);\n                    if (quotation1.isPlatform()) {\n                        platform = quotation1;\n                        break;\n                    }\n                }\n                if (platform != null) {\n                    platform.getExtra().remove(quotation);\n                }\n                dialog.updateNum();\n                notifyDataSetChanged();\n            }\n        }\n    }\n    private class AddDelOnClickListener implements View.OnClickListener {\n        @Override\n        public void onClick(View v) {\n            int type = (int) v.getTag(R.id.action_type);\n            switch (type) {\n                case 0: {\n                    int num = activity.getNum();\n                    num++;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n                case 1: {\n                    int num = activity.getNum();\n                    if (num < 1) {\n                        return;\n                    }\n                    num--;\n                    activity.setNum(num);\n                    dialog.updateNum();\n                    notifyDataSetChanged();\n                }\n                break;\n            }\n        }\n    }\n"]]}
{"hexsha": "20ce929ce28429536893d7323990cd9eaf4116b3", "ext": "java", "lang": "Java", "content": "public class MainActivity extends AppCompatActivity\n        implements NavigationView.OnNavigationItemSelectedListener {\n\n    private static final String TAG = MainActivity.class.getSimpleName();\n\n    private static final String KEY_NAV_POS = \"key_nav_pos\";\n\n    private Fragment m_actualFragment;\n    private NavigationView m_navigationView;\n\n    private int m_navPos;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n\n        Log.d(TAG, \"TAG: \" + TAG);\n\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(\n                this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawer.setDrawerListener(toggle);\n        toggle.syncState();\n\n        m_navigationView = (NavigationView) findViewById(R.id.nav_view);\n        m_navigationView.setNavigationItemSelectedListener(this);\n        // Select first menu item of drawer\n        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);\n        m_navPos = R.id.nav_example_1;\n\n        /*\n        FlipIconChecker flipIconChecker = (FlipIconChecker) findViewById(R.id.flipChecker);\n        View view = getLayoutInflater().inflate(R.layout.custom_front_color, flipIconChecker, false);\n        flipIconChecker.setFrontView(view);\n        */\n\n    }\n\n    @Override\n    public void onBackPressed() {\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main_activity, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n\n        return super.onOptionsItemSelected(item);\n    }\n\n    @SuppressWarnings(\"StatementWithEmptyBody\")\n    @Override\n    public boolean onNavigationItemSelected(MenuItem item) {\n        // Handle navigation view item clicks here.\n        int id = item.getItemId();\n\n        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();\n        if (id == R.id.nav_example_1) {\n            if (!(m_actualFragment instanceof FragmentColors)) {\n                m_navPos = R.id.nav_example_1;\n                FragmentColors fragmentColors = FragmentColors.newInstance();\n                m_actualFragment = fragmentColors;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentColors, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n        else if (id == R.id.nav_example_2) {\n            if (!(m_actualFragment instanceof FragmentCities)) {\n                m_navPos = R.id.nav_example_2;\n                FragmentCities fragmentCities = FragmentCities.newInstance();\n                m_actualFragment = fragmentCities;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentCities, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n\n    @Override\n        protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_NAV_POS, m_navPos);\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        if (savedInstanceState != null) {\n            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);\n            // Select first menu item of drawer\n            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);\n        }\n    }\n}", "class_id": 0, "repo": "TmCrafz/FlipIconChecker", "file": "example/src/main/java/org/tmcrafz/flipiconcheckerexample/MainActivity.java", "last_update_at": "2021-03-16T13:55:31+00:00", "question_id": "20ce929ce28429536893d7323990cd9eaf4116b3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainActivity extends AppCompatActivity\n        implements NavigationView.OnNavigationItemSelectedListener {\n    private static final String TAG = MainActivity.class.getSimpleName();\n    private static final String KEY_NAV_POS = \"key_nav_pos\";\n    private Fragment m_actualFragment;\n    private NavigationView m_navigationView;\n    private int m_navPos;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        Log.d(TAG, \"TAG: \" + TAG);\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(\n                this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawer.setDrawerListener(toggle);\n        toggle.syncState();\n        m_navigationView = (NavigationView) findViewById(R.id.nav_view);\n        m_navigationView.setNavigationItemSelectedListener(this);\n        // Select first menu item of drawer\n        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);\n        m_navPos = R.id.nav_example_1;\n        /*\n        FlipIconChecker flipIconChecker = (FlipIconChecker) findViewById(R.id.flipChecker);\n        View view = getLayoutInflater().inflate(R.layout.custom_front_color, flipIconChecker, false);\n        flipIconChecker.setFrontView(view);\n        */\n    }\n    @Override\n    public void onBackPressed() {\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main_activity, menu);\n        return true;\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    @SuppressWarnings(\"StatementWithEmptyBody\")\n    @Override\n    public boolean onNavigationItemSelected(MenuItem item) {\n        // Handle navigation view item clicks here.\n        int id = item.getItemId();\n        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();\n        if (id == R.id.nav_example_1) {\n            if (!(m_actualFragment instanceof FragmentColors)) {\n                m_navPos = R.id.nav_example_1;\n                FragmentColors fragmentColors = FragmentColors.newInstance();\n                m_actualFragment = fragmentColors;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentColors, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n        else if (id == R.id.nav_example_2) {\n            if (!(m_actualFragment instanceof FragmentCities)) {\n                m_navPos = R.id.nav_example_2;\n                FragmentCities fragmentCities = FragmentCities.newInstance();\n                m_actualFragment = fragmentCities;\n                fragmentManager.beginTransaction()\n                        .replace(R.id.container, fragmentCities, FragmentCities.TAG)\n                        .commit();\n            }\n        }\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n    @Override\n        protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_NAV_POS, m_navPos);\n    }\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        if (savedInstanceState != null) {\n            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);\n            // Select first menu item of drawer\n            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);\n        }\n    }\n"]]}
{"hexsha": "9911321d53109bf16da1df0c35f7787910b99c99", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\n@ComponentScan({\"com.song7749.incident.drs\"})\r\npublic class LogRepositoryTest{\r\n\r\n\tLogger logger = LoggerFactory.getLogger(getClass());\r\n\r\n\t@Autowired\r\n\tLogRepository logRepository;\r\n\r\n\t@Test\r\n\tpublic void testSaveLogLogin() {\r\n\t\t// give\r\n\t\tLogLogin ll = new LogLogin();\r\n\t\tll.setIp(\"111.111.111.111\");\r\n\t\tll.setLoginId(\"song7749\");\r\n\t\tll.setCipher(\"12314142341231\");\r\n\r\n\t\t// when\r\n\t\tlogRepository.saveAndFlush(ll);\r\n\t\t// then\r\n\t\tassertThat(ll.getId(), notNullValue());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testSaveLogQuery() {\r\n\t\t//give\r\n\t\tLogQuery lq = new LogQuery();\r\n\t\tlq.setIp(\"111.111.111.111\");\r\n\t\tlq.setDatabaseId(1L);\r\n\t\tlq.setAccount(\"song7749\");\r\n\t\tlq.setHost(\"11.11.11.11\");\r\n\t\tlq.setHostAlias(\"\ud14c\uc2a4\ud2b8 \uc11c\ubc84\");\r\n\t\tlq.setLoginId(\"song7749\");\r\n\t\tlq.setQuery(\"select * from dual\");\r\n\t\tlq.setSchemaName(\"song7749\");\r\n\t\t//when\r\n\t\tlogRepository.saveAndFlush(lq);\r\n\t\t//then\r\n\t\tassertThat(lq.getId(), notNullValue());\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "MS-Song/Spring4BootWithGradel", "file": "incidentAlert/src/test/java/com/song7749/incident/drs/repository/LogRepositoryTest.java", "last_update_at": "2021-09-16T04:20:54+00:00", "question_id": "9911321d53109bf16da1df0c35f7787910b99c99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\n@ComponentScan({\"com.song7749.incident.drs\"})\r\npublic class LogRepositoryTest{\r\n\r\n\tLogger logger = LoggerFactory.getLogger(getClass());\r\n\r\n\t@Autowired\r\n\tLogRepository logRepository;\r\n\r\n\t@Test\r\n\tpublic void testSaveLogLogin() {\r\n\t\t// give\r\n\t\tLogLogin ll = new LogLogin();\r\n\t\tll.setIp(\"111.111.111.111\");\r\n\t\tll.setLoginId(\"song7749\");\r\n\t\tll.setCipher(\"12314142341231\");\r\n\r\n\t\t// when\r\n\t\tlogRepository.saveAndFlush(ll);\r\n\t\t// then\r\n\t\tassertThat(ll.getId(), notNullValue());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testSaveLogQuery() {\r\n\t\t//give\r\n\t\tLogQuery lq = new LogQuery();\r\n\t\tlq.setIp(\"111.111.111.111\");\r\n\t\tlq.setDatabaseId(1L);\r\n\t\tlq.setAccount(\"song7749\");\r\n\t\tlq.setHost(\"11.11.11.11\");\r\n\t\tlq.setHostAlias(\"\ud14c\uc2a4\ud2b8 \uc11c\ubc84\");\r\n\t\tlq.setLoginId(\"song7749\");\r\n\t\tlq.setQuery(\"select * from dual\");\r\n\t\tlq.setSchemaName(\"song7749\");\r\n\t\t//when\r\n\t\tlogRepository.saveAndFlush(lq);\r\n\t\t//then\r\n\t\tassertThat(lq.getId(), notNullValue());\r\n\t}\r\n\r\n"]]}
{"hexsha": "6c338a1f6834fb9094f88ce1c7d13fe385e54000", "ext": "java", "lang": "Java", "content": "@RunWith(value = YBTestRunnerNonTsanOnly.class)\npublic class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {\n  private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);\n\n  @Test\n  public void simplest() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n    }\n  }\n\n  @Test\n  public void duplicates() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 2)\");\n\n      // Note:\n      // PG error in this case mentions \"nopk_pkey\", not just \"nopk\"\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"duplicate key value violates unique constraint \\\"nopk\\\"\");\n\n      stmt.executeUpdate(\"DELETE FROM nopk WHERE v = 2\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n\n  @Test\n  public void nulls() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (NULL)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1)\");\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"column \\\"id\\\" contains null values\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row((Object) null)));\n    }\n  }\n\n  @Test\n  public void columnTypes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int[10][20], v2 text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, new Integer[] { 1, 2, 3 }, \"qwe\"),\n          new Row(2, new Integer[] { 3, 4 }, \"zxcv\")));\n    }\n  }\n\n  @Test\n  public void columnTypesUnsupported() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE typeid AS (i int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (id typeid, v int)\");\n\n      String msg = \"PRIMARY KEY containing column of type 'user_defined_type' not yet supported\";\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)\", msg);\n    }\n  }\n\n  @Test\n  public void missing() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n\n      String msg = \"column \\\"missme\\\" named in key does not exist\";\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)\", msg);\n    }\n  }\n\n  @Test\n  public void complexPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '111', '1', true)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '2', false)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)\");\n\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '3', true)\");\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, '222', '2', false)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY v1, v2, v3, v4\", Arrays.asList(\n          new Row(1, \"111\", \"1\", true),\n          new Row(2, \"222\", \"2\", false),\n          new Row(2, \"222\", \"3\", true)));\n    }\n  }\n\n  @Test\n  public void pkInclude() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int, v2 int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 11, 111)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 22, 222)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id) INCLUDE (v1, v2)\");\n\n      // Scan is supposed to be index-only scan, but it's index scan for us.\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 2\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(22));\n      }\n\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3, 11, 111)\");\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (3, 99, 999)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 11, 111),\n          new Row(2, 22, 222),\n          new Row(3, 11, 111)));\n\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 3\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(11));\n      }\n    }\n  }\n\n  @Test\n  public void pkUsingIndex() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)\");\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY\"\n          + \" USING INDEX nopk_idx\",\n          \"ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported\");\n    }\n  }\n\n  @Test\n  public void sequences() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \"id serial,\"\n          + \"v1 int GENERATED ALWAYS AS IDENTITY,\"\n          + \"v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10),\"\n          + \"stuff text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r1')\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\")));\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r2')\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\"),\n          new Row(2, 2, 11, \"r2\")));\n    }\n  }\n\n  @Test\n  public void typedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE nopk_type AS (id int, v int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk OF nopk_type\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 10)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 20)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 10),\n          new Row(2, 20)));\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk DROP COLUMN v\",\n          \"cannot drop column from typed table\");\n    }\n  }\n\n  @Ignore // TODO(alex): Enable after INHERITS is supported in #1129\n  public void inheritedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_parent (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (3, 30)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (4, 40)\");\n\n      alterAddPrimaryKey(stmt, \"nopk_parent\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_child\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk_parent ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_child ORDER BY id\", Arrays.asList(\n          new Row(3, 30),\n          new Row(4, 40)));\n    }\n  }\n\n  /** Adding PK to a partitioned table is not yet implemented. */\n  @Test\n  public void partitionedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part1 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (1, 2, 3)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (10, 20)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (30, 40)\");\n\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_whole ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n    }\n  }\n\n  @Test\n  public void tablesInColocatedDb() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE DATABASE clc WITH colocated = true\");\n    }\n\n    try (Connection conn2 = getConnectionBuilder().withDatabase(\"clc\").connect();\n        Statement stmt = conn2.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk_c (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (4)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk_nc (id int) WITH (colocated = false)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (6)\");\n\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n\n      // This doesn't really accomplish much though, since colocated property is invisible to SQL\n      // - we can't check whether a re-created table keeps/gains/loses it.\n      // See #6159\n      alterAddPrimaryKey(stmt, \"nopk_c\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_nc\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_c ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk_nc ORDER BY id\", Arrays.asList(\n          new Row(5),\n          new Row(6)));\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n    }\n  }\n\n  @Test\n  public void tablesInTablegroup() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLEGROUP tgroup1\");\n\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (4)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk2 (id int, id2 int unique)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (5, 5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (6, 6)\");\n\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk2\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk2 ORDER BY id\", Arrays.asList(\n          new Row(5, 5),\n          new Row(6, 6)));\n\n      assertRowList(stmt,\n        \"SELECT s.relname, pg_tablegroup.grpname \" +\n        \"FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) \" +\n        \"s, pg_tablegroup WHERE opts LIKE \" +\n        \"CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') \" +\n        \"ORDER BY s\", Arrays.asList(\n          new Row(\"nopk\", \"tgroup1\"),\n          new Row(\"nopk2\", \"tgroup1\"),\n          new Row(\"nopk2_id2_key\", \"tgroup1\"),\n          new Row(\"nopk2_pkey\", \"tgroup1\"),\n          new Row(\"nopk_pkey\", \"tgroup1\"),\n          new Row(\"normal_table\", \"tgroup1\"),\n          new Row(\"normal_table_pkey\", \"tgroup1\")));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n    }\n  }\n\n  @Test\n  public void defaults() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int DEFAULT 10, \"\n          + \" drop_me int DEFAULT 10, \"\n          + \" v int DEFAULT 10\"\n          + \")\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n\n      stmt.executeUpdate(\"INSERT INTO nopk (id) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10)));\n\n      stmt.executeUpdate(\"INSERT INTO nopk (v) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10),\n          new Row(10, 2)));\n    }\n  }\n\n  @Test\n  public void notNullAndCheck() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int CHECK (id > 0),\"\n          + \" drop_me int,\"\n          + \" v1 int CHECK (v1 > 0),\"\n          + \" v2 int NOT NULL\"\n          + \")\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (0, 2, 2)\",\n          \"violates check constraint \\\"nopk_id_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 0, 2)\",\n          \"violates check constraint \\\"nopk_v1_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, NULL)\",\n          \"violates not-null constraint\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n    }\n  }\n\n  /** Altered table references a FK table. */\n  @Test\n  public void foreignKeys() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (2, 2)\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" fk1 int REFERENCES fk_ref_table (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES fk_ref_table (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1)\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 2)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n\n      runInvalidQuery(stmt, \"DELETE FROM fk_ref_table WHERE id = 1\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\" on table \\\"nopk\\\"\");\n    }\n  }\n\n  /** Altered table itself is referenced through FK constraints from other table. */\n  @Test\n  public void foreignKeys2() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      stmt.executeUpdate(\"CREATE TABLE referencing_table (\"\n          + \" id int PRIMARY KEY,\"\n          + \" fk1 int REFERENCES nopk (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES nopk (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table DROP COLUMN drop_me\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 2)));\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (2, 2, 2, 2)\");\n\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n\n      runInvalidQuery(stmt, \"DELETE FROM nopk WHERE id = 1\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\"\n              + \" on table \\\"referencing_table\\\"\");\n    }\n  }\n\n  @Test\n  public void otherConstraintsAndIndexes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.\n      runInvalidQuery(stmt, \"CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))\",\n          \"EXCLUDE constraint not supported yet\");\n\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" v1 int UNIQUE,\"\n          + \" drop_me int,\"\n          + \" v2 int,\"\n          + \" v3 int,\"\n          + \" v4 int\"\n          + \")\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v2)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk (v3)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v4 * 2))\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      String v3query = \"SELECT v3 FROM nopk WHERE v3 = 1\";\n      String v4query = \"SELECT v4 FROM nopk WHERE v4 * 2 = 2\";\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1)));\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 1, 2, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v1_key\\\"\");\n\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 1, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v2_idx\\\"\");\n\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 1, 2)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1),\n          new Row(2, 2, 2, 1, 2)));\n\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertRowList(stmt, v3query, Arrays.asList(\n          new Row(1),\n          new Row(1)));\n\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n      assertRowList(stmt, v4query, Arrays.asList(\n          new Row(1)));\n    }\n  }\n\n  @Test\n  public void triggers() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, drop_me int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\n          \"CREATE FUNCTION notice_on_trigger() RETURNS trigger\"\n              + \" LANGUAGE plpgsql\"\n              + \" AS $$\"\n              + \"   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;\"\n              + \"   RETURN NEW;\"\n              + \"   END;\"\n              + \" $$;\");\n      for (String timing : Arrays.asList(\"before\", \"after\")) {\n        for (String scope : Arrays.asList(\"statement\", \"row\")) {\n          for (String action : Arrays.asList(\"insert\", \"update\", \"delete\")) {\n            stmt.executeUpdate(MessageFormat.format(\n                \"CREATE TRIGGER nopk__{0}_{2}_{1}\"\n                    + \" {0} {2} ON nopk\"\n                    + \" FOR EACH {1}\"\n                    + \" EXECUTE PROCEDURE notice_on_trigger()\",\n                timing, scope, action));\n          }\n          String whenExpr = scope.equals(\"row\")\n              ? \"OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0\"\n              : \"RANDOM() >= 0\";\n          stmt.executeUpdate(MessageFormat.format(\n              \"CREATE TRIGGER nopk__{0}_update_c_{1}\"\n                  + \" {0} UPDATE OF id, v ON nopk\"\n                  + \" FOR EACH {1}\"\n                  + \" WHEN (\" + whenExpr + \")\"\n                  + \" EXECUTE PROCEDURE notice_on_trigger()\",\n              timing, scope));\n        }\n      }\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n\n  @Test\n  public void secondPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int PRIMARY KEY)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"multiple primary keys for table \\\"nopk\\\" are not allowed\");\n    }\n  }\n\n  @Test\n  public void splitInto() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n    }\n  }\n\n  @Test\n  public void roles() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE ROLE new_user\");\n      stmt.executeUpdate(\"ALTER TABLE nopk OWNER TO new_user\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n    }\n  }\n\n  /**\n   * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).\n   * <p>\n   * Source was a real output from pg_dump in its default configuration.\n   */\n  @Test\n  public void restorePgDump() throws Exception {\n    URL sqlFileRes = getClass().getClassLoader()\n        .getResource(\"TestPgAlterTableAddPrimaryKey/restorePgDump.sql\");\n    assertTrue(\"Dump SQL resource not found!\", sqlFileRes != null);\n    File sqlFile = new File(sqlFileRes.getFile());\n\n    String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), \"ysqlsh\").getAbsolutePath();\n    ProcessBuilder procBuilder = new ProcessBuilder(\n        ysqlshPath,\n        \"-h\", getPgHost(0),\n        \"-p\", Integer.toString(getPgPort(0)),\n        DEFAULT_PG_DATABASE);\n\n    procBuilder.redirectInput(sqlFile);\n\n    List<String> output = runProcess(procBuilder);\n\n    // Sanity checks.\n    assertTrue(output.size() > 0);\n    assertFalse(\"There was an error executing SQL: \" + output,\n        StringUtils.join(output, '\\n').toLowerCase().contains(\"error\"));\n\n    try (Statement stmt = connection.createStatement()) {\n      assertRowList(stmt, \"SELECT * FROM public.with_constraints_and_such ORDER BY id\",\n          Arrays.asList(\n              new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111),\n              new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222),\n              new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));\n    }\n  }\n\n  //\n  // Helpers\n  //\n\n  /**\n   * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.\n   */\n  private void alterAddPrimaryKey(\n      Statement stmt,\n      String tableName,\n      String alterSpec) throws Exception {\n    String countPgClass = \"SELECT COUNT(*) FROM pg_class\";\n    String getTableNames = \"SELECT table_name FROM information_schema.tables\"\n        + \" WHERE table_schema = 'public' ORDER BY table_name\";\n    String getOid = \"SELECT oid FROM pg_class WHERE relname = '\" + tableName + \"'\";\n    // This query is based on pg_dump.c query, with some columns removed.\n    // We're also selecting owning_tab_name instead of owning_tab OID.\n    String getSequences = \"SELECT c.oid, c.relname, \"\n        + \"     c.relkind, c.relnamespace, \"\n        + \"     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, \"\n        + \"     c.relchecks, c.relhastriggers, \"\n        + \"     c.relhasindex, c.relhasrules, c.relhasoids, \"\n        + \"     c.relrowsecurity, c.relforcerowsecurity, \"\n        + \"     c.relfrozenxid, c.relminmxid, tc.oid AS toid, \"\n        + \"     tc.relfrozenxid AS tfrozenxid, \"\n        + \"     tc.relminmxid AS tminmxid, \"\n        + \"     c.relpersistence, c.relispopulated, \"\n        + \"     c.relreplident, c.relpages, \"\n        + \"     CASE WHEN c.reloftype <> 0\"\n        + \"       THEN c.reloftype::pg_catalog.regtype ELSE NULL END\"\n        + \"     AS reloftype, \"\n        + \"     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, \"\n        + \"     d.refobjsubid AS owning_col, \"\n        + \"     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)\"\n        + \"       AS reltablespace, \"\n        + \"     array_remove(array_remove(c.reloptions,'check_option=local'),\"\n        + \"                  'check_option=cascaded')\"\n        + \"     AS reloptions, \"\n        + \"     CASE\"\n        + \"       WHEN 'check_option=local' = ANY (c.reloptions)\"\n        + \"         THEN 'LOCAL'::text \"\n        + \"       WHEN 'check_option=cascaded' = ANY (c.reloptions)\"\n        + \"         THEN 'CASCADED'::text ELSE NULL END\"\n        + \"     AS checkoption, \"\n        + \"     tc.reloptions AS toast_reloptions, \"\n        + \"     c.relkind = 'S' AND EXISTS (\"\n        + \"       SELECT 1 FROM pg_depend\"\n        + \"       WHERE classid = 'pg_class'::regclass\"\n        + \"         AND objid = c.oid\"\n        + \"         AND objsubid = 0\"\n        + \"         AND refclassid = 'pg_class'::regclass\"\n        + \"         AND deptype = 'i'\"\n        + \"     ) AS is_identity_sequence\"\n        + \" FROM pg_class c \"\n        + \" LEFT JOIN pg_depend d\"\n        + \"   ON (c.relkind = 'S' AND d.classid = c.tableoid AND\"\n        + \"     d.objid = c.oid AND d.objsubid = 0 AND \"\n        + \"     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) \"\n        + \" LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) \"\n        + \" LEFT JOIN pg_init_privs pip\"\n        + \"   ON (c.oid = pip.objoid AND\"\n        + \"     pip.classoid = 'pg_class'::regclass AND\"\n        + \"     pip.objsubid = 0) \"\n        + \" WHERE c.relkind in ('S') \"\n        + \" ORDER BY c.oid\";\n\n    // Saving stuff to verify after rename.\n\n    long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);\n\n    List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));\n    List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));\n\n    PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);\n\n    stmt.executeUpdate(\"ALTER TABLE \" + tableName + \" \" + alterSpec);\n\n    // OID has changed, but the pg_class row content did not.\n    long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    assertNotEquals(oldOid, newOid);\n\n    // Stuff targeting old OID should match the stuff targeting the new one.\n\n    // There's one more index in the pool now.\n    assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));\n\n    // Everything else should remain as it was.\n    assertRowList(stmt, getTableNames, oldTableNames);\n    assertRowList(stmt, getSequences, oldSequences);\n\n    PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);\n\n    assertPgStateEquals(oldState, newState);\n  }\n\n  private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {\n    ps.setLong(1, oid);\n    return getRowList(ps.executeQuery());\n  }\n\n  private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {\n    assertRow(oldState.pgClassRow, newState.pgClassRow);\n    assertRows(oldState.attrs, newState.attrs);\n    assertRows(oldState.defaults, newState.defaults);\n    assertRows(oldState.checkConstrs, newState.checkConstrs);\n    assertRows(oldState.indexes, newState.indexes);\n    assertRows(oldState.foreignKeys, newState.foreignKeys);\n    assertRows(oldState.triggers, newState.triggers);\n  }\n\n  private int getNumTablets(String databaseName, String tableName) throws Exception {\n    List<String> lines = runProcess(\n        TestUtils.findBinary(\"yb-admin\"),\n        \"--master_addresses\",\n        masterAddresses,\n        \"list_tablets\",\n        \"ysql.\" + databaseName,\n        tableName);\n    // We don't care about the output, just number of lines (minus header line).\n    return lines.size() - 1;\n  }\n\n  private class PgSystemTableInfo {\n    Row pgClassRow;\n    List<Row> attrs;\n    List<Row> defaults;\n    List<Row> checkConstrs;\n    List<Row> indexes;\n    List<Row> foreignKeys;\n    List<Row> triggers;\n\n    public PgSystemTableInfo(Connection conn, long oid) throws Exception {\n      // Columns not selected: reltype, relhasindex, relfilenode, relpartbound,\n      // relnatts (because it includes dropped attributes).\n      PreparedStatement getPgClassRow = conn.prepareStatement(\n          \"SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages,\"\n              + \"   reltuples, relallvisible, reltoastrelid, relisshared,\"\n              + \"   relpersistence, relkind, relchecks, relhasoids, relhasrules,\"\n              + \"   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity,\"\n              + \"   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid,\"\n              + \"   relminmxid, relacl\"\n              + \" FROM pg_class WHERE oid = ?\");\n\n      // These queries are taken from pg_dump.c, with the following changes:\n      //  * Formatting was changed slightly.\n      //  * Attributes query doesn't include attnotnull (they are changed for PK cols)\n      //      and dropped columns.\n      //  * Index query doesn't include PK index.\n      //  * Index query selects column names instead of attnums.\n      //  * Attribute-related queries don't include attnum (replaced by ORDER BY).\n      //  * Queries don't include tableoids because we don't care.\n      //  * Queries don't include OIDs that are expected to change.\n      //  * Added ORDER BY to all queries.\n      PreparedStatement getAttrs = conn.prepareStatement(\n          \"SELECT a.attname, a.atttypmod, \"\n              + \"   a.attstattarget, a.attstorage, t.typstorage, \"\n              + \"   a.atthasdef, a.attlen, a.attalign, a.attislocal, \"\n              + \"   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, \"\n              + \"   array_to_string(a.attoptions, ', ') AS attoptions, \"\n              + \"   CASE WHEN a.attcollation <> t.typcollation \"\n              + \"     THEN a.attcollation ELSE 0 END AS attcollation, \"\n              + \"   a.attidentity, \"\n              + \"   pg_catalog.array_to_string(ARRAY(\"\n              + \"     SELECT pg_catalog.quote_ident(option_name) || \"\n              + \"     ' ' || pg_catalog.quote_literal(option_value) \"\n              + \"     FROM pg_catalog.pg_options_to_table(attfdwoptions) \"\n              + \"     ORDER BY option_name\"\n              + \"   ), E',\\n    ') AS attfdwoptions ,\"\n              + \"   CASE WHEN a.atthasmissing AND NOT a.attisdropped \"\n              + \"     THEN a.attmissingval ELSE null END AS attmissingval \"\n              + \" FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t \"\n              + \"   ON a.atttypid = t.oid \"\n              + \" WHERE a.attrelid = ?::pg_catalog.oid \"\n              + \"   AND a.attnum > 0::pg_catalog.int2 \"\n              + \"   AND NOT a.attisdropped \"\n              + \" ORDER BY a.attnum\");\n      PreparedStatement getDefaults = conn.prepareStatement(\n          \"SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc \"\n              + \" FROM pg_catalog.pg_attrdef \"\n              + \" WHERE adrelid = ?::pg_catalog.oid \"\n              + \" ORDER BY adnum\");\n      PreparedStatement getCheckConstrs = conn.prepareStatement(\n          \"SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc,\"\n              + \"   conislocal, convalidated\"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getIndexes = conn.prepareStatement(\n          \"SELECT t.relname AS indexname, \"\n              + \"   inh.inhparent AS parentidx, \"\n              + \"   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, \"\n              + \"   i.indnkeyatts AS indnkeyatts, \"\n              + \"   i.indnatts AS indnatts, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) \"\n              + \"     AS indkey_colnames, \"\n              + \"   i.indisclustered, \"\n              + \"   i.indisreplident, i.indoption, t.relpages, \"\n              + \"   c.contype, c.conname, \"\n              + \"   c.condeferrable, c.condeferred, \"\n              + \"   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, \"\n              + \"   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)\"\n              + \"     AS tablespace, \"\n              + \"   t.reloptions AS indreloptions, \"\n              + \"   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatcols,\"\n              + \"   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatvals \"\n              + \" FROM pg_catalog.pg_index i \"\n              + \" JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) \"\n              + \" JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) \"\n              + \" LEFT JOIN pg_catalog.pg_constraint c \"\n              + \"   ON (i.indrelid = c.conrelid AND \"\n              + \"     i.indexrelid = c.conindid AND \"\n              + \"     c.contype IN ('u','x')) \"\n              + \" LEFT JOIN pg_catalog.pg_inherits inh \"\n              + \"   ON (inh.inhrelid = indexrelid) \"\n              + \" WHERE i.indrelid = ?::pg_catalog.oid \"\n              + \"   AND (i.indisvalid OR t2.relkind = 'p') \"\n              + \"   AND i.indisready \"\n              + \"   AND i.indisprimary = false \"\n              + \" ORDER BY indexname\");\n      PreparedStatement getForeignKeys = conn.prepareStatement(\n          \"SELECT conname, confrelid, \"\n              + \"   pg_catalog.pg_get_constraintdef(oid) AS condef \"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid \"\n              + \"  AND conparentid = 0 \"\n              + \"  AND contype = 'f'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getTriggers = conn.prepareStatement(\n          \"SELECT tgname, \"\n              + \"   tgfoid::pg_catalog.regproc AS tgfname, \"\n              + \"   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) \"\n              + \"     AS tgattr_colnames, \"\n              + \"   tgenabled \"\n              + \" FROM pg_catalog.pg_trigger t \"\n              + \" WHERE tgrelid = ?::pg_catalog.oid \"\n              + \"   AND NOT tgisinternal\"\n              + \" ORDER BY tgfname\");\n      List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);\n      assertTrue(\"Table with OID \" + oid + \" not found!\", pgClassRows.size() > 0);\n      this.pgClassRow = pgClassRows.get(0);\n      this.attrs = execCheckQuery(getAttrs, oid);\n      this.defaults = execCheckQuery(getDefaults, oid);\n      this.checkConstrs = execCheckQuery(getCheckConstrs, oid);\n      this.indexes = execCheckQuery(getIndexes, oid);\n      this.foreignKeys = execCheckQuery(getForeignKeys, oid);\n      this.triggers = execCheckQuery(getTriggers, oid);\n    }\n  }\n}", "class_id": 0, "repo": "nextgres/yugabyte-db", "file": "java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgAlterTableAddPrimaryKey.java", "last_update_at": "2021-06-14T23:51:05+00:00", "question_id": "6c338a1f6834fb9094f88ce1c7d13fe385e54000", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(value = YBTestRunnerNonTsanOnly.class)\npublic class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {\n  private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);\n  @Test\n  public void simplest() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n    }\n  }\n  @Test\n  public void duplicates() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 2)\");\n      // Note:\n      // PG error in this case mentions \"nopk_pkey\", not just \"nopk\"\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"duplicate key value violates unique constraint \\\"nopk\\\"\");\n      stmt.executeUpdate(\"DELETE FROM nopk WHERE v = 2\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n  @Test\n  public void nulls() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (NULL)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"column \\\"id\\\" contains null values\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row((Object) null)));\n    }\n  }\n  @Test\n  public void columnTypes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int[10][20], v2 text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, new Integer[] { 1, 2, 3 }, \"qwe\"),\n          new Row(2, new Integer[] { 3, 4 }, \"zxcv\")));\n    }\n  }\n  @Test\n  public void columnTypesUnsupported() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE typeid AS (i int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (id typeid, v int)\");\n      String msg = \"PRIMARY KEY containing column of type 'user_defined_type' not yet supported\";\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)\", msg);\n    }\n  }\n  @Test\n  public void missing() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      String msg = \"column \\\"missme\\\" named in key does not exist\";\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)\", msg);\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)\", msg);\n    }\n  }\n  @Test\n  public void complexPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '111', '1', true)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '2', false)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '3', true)\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, '222', '2', false)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY v1, v2, v3, v4\", Arrays.asList(\n          new Row(1, \"111\", \"1\", true),\n          new Row(2, \"222\", \"2\", false),\n          new Row(2, \"222\", \"3\", true)));\n    }\n  }\n  @Test\n  public void pkInclude() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int, v2 int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 11, 111)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 22, 222)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id) INCLUDE (v1, v2)\");\n      // Scan is supposed to be index-only scan, but it's index scan for us.\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 2\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(22));\n      }\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3, 11, 111)\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (3, 99, 999)\",\n          \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 11, 111),\n          new Row(2, 22, 222),\n          new Row(3, 11, 111)));\n      {\n        String includeQuery = \"SELECT v1 FROM nopk WHERE id = 3\";\n        assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n        assertQuery(stmt, includeQuery, new Row(11));\n      }\n    }\n  }\n  @Test\n  public void pkUsingIndex() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY\"\n          + \" USING INDEX nopk_idx\",\n          \"ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported\");\n    }\n  }\n  @Test\n  public void sequences() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \"id serial,\"\n          + \"v1 int GENERATED ALWAYS AS IDENTITY,\"\n          + \"v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10),\"\n          + \"stuff text)\");\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r1')\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\")));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r2')\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 10, \"r1\"),\n          new Row(2, 2, 11, \"r2\")));\n    }\n  }\n  @Test\n  public void typedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TYPE nopk_type AS (id int, v int)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk OF nopk_type\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 10)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 20)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 10),\n          new Row(2, 20)));\n      runInvalidQuery(stmt, \"ALTER TABLE nopk DROP COLUMN v\",\n          \"cannot drop column from typed table\");\n    }\n  }\n  @Ignore // TODO(alex): Enable after INHERITS is supported in #1129\n  public void inheritedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_parent (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (3, 30)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (4, 40)\");\n      alterAddPrimaryKey(stmt, \"nopk_parent\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_child\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk_parent ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_child ORDER BY id\", Arrays.asList(\n          new Row(3, 30),\n          new Row(4, 40)));\n    }\n  }\n  /** Adding PK to a partitioned table is not yet implemented. */\n  @Test\n  public void partitionedTable() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part1 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (1, 2, 3)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2 PARTITION OF nopk_whole\"\n          + \" FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (10, 20)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2\"\n          + \" FOR VALUES IN (30, 40)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_whole ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)\",\n          \"adding primary key to a partitioned table is not yet implemented\");\n    }\n  }\n  @Test\n  public void tablesInColocatedDb() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE DATABASE clc WITH colocated = true\");\n    }\n    try (Connection conn2 = getConnectionBuilder().withDatabase(\"clc\").connect();\n        Statement stmt = conn2.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_c (id int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (4)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk_nc (id int) WITH (colocated = false)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (6)\");\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n      // This doesn't really accomplish much though, since colocated property is invisible to SQL\n      // - we can't check whether a re-created table keeps/gains/loses it.\n      // See #6159\n      alterAddPrimaryKey(stmt, \"nopk_c\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk_nc\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk_c ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk_nc ORDER BY id\", Arrays.asList(\n          new Row(5),\n          new Row(6)));\n      assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n      assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n      assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n    }\n  }\n  @Test\n  public void tablesInTablegroup() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n      stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (3)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (4)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk2 (id int, id2 int unique)\"\n          + \" TABLEGROUP tgroup1\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (5, 5)\");\n      stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (6, 6)\");\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      alterAddPrimaryKey(stmt, \"nopk2\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(\n          new Row(1),\n          new Row(2)));\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(3),\n          new Row(4)));\n      assertRowList(stmt, \"SELECT * FROM nopk2 ORDER BY id\", Arrays.asList(\n          new Row(5, 5),\n          new Row(6, 6)));\n      assertRowList(stmt,\n        \"SELECT s.relname, pg_tablegroup.grpname \" +\n        \"FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) \" +\n        \"s, pg_tablegroup WHERE opts LIKE \" +\n        \"CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') \" +\n        \"ORDER BY s\", Arrays.asList(\n          new Row(\"nopk\", \"tgroup1\"),\n          new Row(\"nopk2\", \"tgroup1\"),\n          new Row(\"nopk2_id2_key\", \"tgroup1\"),\n          new Row(\"nopk2_pkey\", \"tgroup1\"),\n          new Row(\"nopk_pkey\", \"tgroup1\"),\n          new Row(\"normal_table\", \"tgroup1\"),\n          new Row(\"normal_table_pkey\", \"tgroup1\")));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n    }\n  }\n  @Test\n  public void defaults() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int DEFAULT 10, \"\n          + \" drop_me int DEFAULT 10, \"\n          + \" v int DEFAULT 10\"\n          + \")\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n      stmt.executeUpdate(\"INSERT INTO nopk (id) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10)));\n      stmt.executeUpdate(\"INSERT INTO nopk (v) VALUES (2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 10),\n          new Row(10, 2)));\n    }\n  }\n  @Test\n  public void notNullAndCheck() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int CHECK (id > 0),\"\n          + \" drop_me int,\"\n          + \" v1 int CHECK (v1 > 0),\"\n          + \" v2 int NOT NULL\"\n          + \")\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (0, 2, 2)\",\n          \"violates check constraint \\\"nopk_id_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 0, 2)\",\n          \"violates check constraint \\\"nopk_v1_check\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, NULL)\",\n          \"violates not-null constraint\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1)));\n    }\n  }\n  /** Altered table references a FK table. */\n  @Test\n  public void foreignKeys() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (2, 2)\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" fk1 int REFERENCES fk_ref_table (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES fk_ref_table (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES fk_ref_table (v, id)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1)\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"nopk_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n      runInvalidQuery(stmt, \"DELETE FROM fk_ref_table WHERE id = 1\",\n          \"violates foreign key constraint \\\"nopk_fk1_fkey\\\" on table \\\"nopk\\\"\");\n    }\n  }\n  /** Altered table itself is referenced through FK constraints from other table. */\n  @Test\n  public void foreignKeys2() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v)\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      stmt.executeUpdate(\"CREATE TABLE referencing_table (\"\n          + \" id int PRIMARY KEY,\"\n          + \" fk1 int REFERENCES nopk (id),\"\n          + \" drop_me int,\"\n          + \" fk2 int REFERENCES nopk (v),\"\n          + \" fk3 int)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)\"\n          + \" REFERENCES nopk (v, id)\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE referencing_table DROP COLUMN drop_me\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1),\n          new Row(2, 2)));\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 20, 2, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 20, 2)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 2, 20)\",\n          \"violates foreign key constraint \\\"referencing_table_fk2_fkey1\\\"\");\n      stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (2, 2, 2, 2)\");\n      assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1),\n          new Row(2, 2, 2, 2)));\n      runInvalidQuery(stmt, \"DELETE FROM nopk WHERE id = 1\",\n          \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\"\n              + \" on table \\\"referencing_table\\\"\");\n    }\n  }\n  @Test\n  public void otherConstraintsAndIndexes() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.\n      runInvalidQuery(stmt, \"CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))\",\n          \"EXCLUDE constraint not supported yet\");\n      stmt.executeUpdate(\"CREATE TABLE nopk (\"\n          + \" id int,\"\n          + \" v1 int UNIQUE,\"\n          + \" drop_me int,\"\n          + \" v2 int,\"\n          + \" v3 int,\"\n          + \" v4 int\"\n          + \")\");\n      stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v2)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk (v3)\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v4 * 2))\");\n      stmt.executeUpdate(\"CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)\");\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      String v3query = \"SELECT v3 FROM nopk WHERE v3 = 1\";\n      String v4query = \"SELECT v4 FROM nopk WHERE v4 * 2 = 2\";\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1)));\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 1, 2, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v1_key\\\"\");\n      runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 1, 2, 2)\",\n          \"violates unique constraint \\\"nopk_v2_idx\\\"\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 1, 2)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1, 1, 1, 1),\n          new Row(2, 2, 2, 1, 2)));\n      assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n      assertRowList(stmt, v3query, Arrays.asList(\n          new Row(1),\n          new Row(1)));\n      assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n      assertRowList(stmt, v4query, Arrays.asList(\n          new Row(1)));\n    }\n  }\n  @Test\n  public void triggers() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int, drop_me int, v int)\");\n      stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n      stmt.executeUpdate(\n          \"CREATE FUNCTION notice_on_trigger() RETURNS trigger\"\n              + \" LANGUAGE plpgsql\"\n              + \" AS $$\"\n              + \"   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;\"\n              + \"   RETURN NEW;\"\n              + \"   END;\"\n              + \" $$;\");\n      for (String timing : Arrays.asList(\"before\", \"after\")) {\n        for (String scope : Arrays.asList(\"statement\", \"row\")) {\n          for (String action : Arrays.asList(\"insert\", \"update\", \"delete\")) {\n            stmt.executeUpdate(MessageFormat.format(\n                \"CREATE TRIGGER nopk__{0}_{2}_{1}\"\n                    + \" {0} {2} ON nopk\"\n                    + \" FOR EACH {1}\"\n                    + \" EXECUTE PROCEDURE notice_on_trigger()\",\n                timing, scope, action));\n          }\n          String whenExpr = scope.equals(\"row\")\n              ? \"OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0\"\n              : \"RANDOM() >= 0\";\n          stmt.executeUpdate(MessageFormat.format(\n              \"CREATE TRIGGER nopk__{0}_update_c_{1}\"\n                  + \" {0} UPDATE OF id, v ON nopk\"\n                  + \" FOR EACH {1}\"\n                  + \" WHEN (\" + whenExpr + \")\"\n                  + \" EXECUTE PROCEDURE notice_on_trigger()\",\n              timing, scope));\n        }\n      }\n      stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(\n          new Row(1, 1)));\n    }\n  }\n  @Test\n  public void secondPk() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int PRIMARY KEY)\");\n      runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\",\n          \"multiple primary keys for table \\\"nopk\\\" are not allowed\");\n    }\n  }\n  @Test\n  public void splitInto() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n    }\n  }\n  @Test\n  public void roles() throws Exception {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n      stmt.executeUpdate(\"CREATE ROLE new_user\");\n      stmt.executeUpdate(\"ALTER TABLE nopk OWNER TO new_user\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n      alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n      assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\",\n          new Row(\"new_user\"));\n    }\n  }\n  /**\n   * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).\n   * <p>\n   * Source was a real output from pg_dump in its default configuration.\n   */\n  @Test\n  public void restorePgDump() throws Exception {\n    URL sqlFileRes = getClass().getClassLoader()\n        .getResource(\"TestPgAlterTableAddPrimaryKey/restorePgDump.sql\");\n    assertTrue(\"Dump SQL resource not found!\", sqlFileRes != null);\n    File sqlFile = new File(sqlFileRes.getFile());\n    String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), \"ysqlsh\").getAbsolutePath();\n    ProcessBuilder procBuilder = new ProcessBuilder(\n        ysqlshPath,\n        \"-h\", getPgHost(0),\n        \"-p\", Integer.toString(getPgPort(0)),\n        DEFAULT_PG_DATABASE);\n    procBuilder.redirectInput(sqlFile);\n    List<String> output = runProcess(procBuilder);\n    // Sanity checks.\n    assertTrue(output.size() > 0);\n    assertFalse(\"There was an error executing SQL: \" + output,\n        StringUtils.join(output, '\\n').toLowerCase().contains(\"error\"));\n    try (Statement stmt = connection.createStatement()) {\n      assertRowList(stmt, \"SELECT * FROM public.with_constraints_and_such ORDER BY id\",\n          Arrays.asList(\n              new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111),\n              new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222),\n              new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));\n    }\n  }\n  //\n  // Helpers\n  //\n  /**\n   * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.\n   */\n  private void alterAddPrimaryKey(\n      Statement stmt,\n      String tableName,\n      String alterSpec) throws Exception {\n    String countPgClass = \"SELECT COUNT(*) FROM pg_class\";\n    String getTableNames = \"SELECT table_name FROM information_schema.tables\"\n        + \" WHERE table_schema = 'public' ORDER BY table_name\";\n    String getOid = \"SELECT oid FROM pg_class WHERE relname = '\" + tableName + \"'\";\n    // This query is based on pg_dump.c query, with some columns removed.\n    // We're also selecting owning_tab_name instead of owning_tab OID.\n    String getSequences = \"SELECT c.oid, c.relname, \"\n        + \"     c.relkind, c.relnamespace, \"\n        + \"     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, \"\n        + \"     c.relchecks, c.relhastriggers, \"\n        + \"     c.relhasindex, c.relhasrules, c.relhasoids, \"\n        + \"     c.relrowsecurity, c.relforcerowsecurity, \"\n        + \"     c.relfrozenxid, c.relminmxid, tc.oid AS toid, \"\n        + \"     tc.relfrozenxid AS tfrozenxid, \"\n        + \"     tc.relminmxid AS tminmxid, \"\n        + \"     c.relpersistence, c.relispopulated, \"\n        + \"     c.relreplident, c.relpages, \"\n        + \"     CASE WHEN c.reloftype <> 0\"\n        + \"       THEN c.reloftype::pg_catalog.regtype ELSE NULL END\"\n        + \"     AS reloftype, \"\n        + \"     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, \"\n        + \"     d.refobjsubid AS owning_col, \"\n        + \"     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)\"\n        + \"       AS reltablespace, \"\n        + \"     array_remove(array_remove(c.reloptions,'check_option=local'),\"\n        + \"                  'check_option=cascaded')\"\n        + \"     AS reloptions, \"\n        + \"     CASE\"\n        + \"       WHEN 'check_option=local' = ANY (c.reloptions)\"\n        + \"         THEN 'LOCAL'::text \"\n        + \"       WHEN 'check_option=cascaded' = ANY (c.reloptions)\"\n        + \"         THEN 'CASCADED'::text ELSE NULL END\"\n        + \"     AS checkoption, \"\n        + \"     tc.reloptions AS toast_reloptions, \"\n        + \"     c.relkind = 'S' AND EXISTS (\"\n        + \"       SELECT 1 FROM pg_depend\"\n        + \"       WHERE classid = 'pg_class'::regclass\"\n        + \"         AND objid = c.oid\"\n        + \"         AND objsubid = 0\"\n        + \"         AND refclassid = 'pg_class'::regclass\"\n        + \"         AND deptype = 'i'\"\n        + \"     ) AS is_identity_sequence\"\n        + \" FROM pg_class c \"\n        + \" LEFT JOIN pg_depend d\"\n        + \"   ON (c.relkind = 'S' AND d.classid = c.tableoid AND\"\n        + \"     d.objid = c.oid AND d.objsubid = 0 AND \"\n        + \"     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) \"\n        + \" LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) \"\n        + \" LEFT JOIN pg_init_privs pip\"\n        + \"   ON (c.oid = pip.objoid AND\"\n        + \"     pip.classoid = 'pg_class'::regclass AND\"\n        + \"     pip.objsubid = 0) \"\n        + \" WHERE c.relkind in ('S') \"\n        + \" ORDER BY c.oid\";\n    // Saving stuff to verify after rename.\n    long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);\n    List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));\n    List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));\n    PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);\n    stmt.executeUpdate(\"ALTER TABLE \" + tableName + \" \" + alterSpec);\n    // OID has changed, but the pg_class row content did not.\n    long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n    assertNotEquals(oldOid, newOid);\n    // Stuff targeting old OID should match the stuff targeting the new one.\n    // There's one more index in the pool now.\n    assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));\n    // Everything else should remain as it was.\n    assertRowList(stmt, getTableNames, oldTableNames);\n    assertRowList(stmt, getSequences, oldSequences);\n    PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);\n    assertPgStateEquals(oldState, newState);\n  }\n  private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {\n    ps.setLong(1, oid);\n    return getRowList(ps.executeQuery());\n  }\n  private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {\n    assertRow(oldState.pgClassRow, newState.pgClassRow);\n    assertRows(oldState.attrs, newState.attrs);\n    assertRows(oldState.defaults, newState.defaults);\n    assertRows(oldState.checkConstrs, newState.checkConstrs);\n    assertRows(oldState.indexes, newState.indexes);\n    assertRows(oldState.foreignKeys, newState.foreignKeys);\n    assertRows(oldState.triggers, newState.triggers);\n  }\n  private int getNumTablets(String databaseName, String tableName) throws Exception {\n    List<String> lines = runProcess(\n        TestUtils.findBinary(\"yb-admin\"),\n        \"--master_addresses\",\n        masterAddresses,\n        \"list_tablets\",\n        \"ysql.\" + databaseName,\n        tableName);\n    // We don't care about the output, just number of lines (minus header line).\n    return lines.size() - 1;\n  }\n  private class PgSystemTableInfo {\n    Row pgClassRow;\n    List<Row> attrs;\n    List<Row> defaults;\n    List<Row> checkConstrs;\n    List<Row> indexes;\n    List<Row> foreignKeys;\n    List<Row> triggers;\n    public PgSystemTableInfo(Connection conn, long oid) throws Exception {\n      // Columns not selected: reltype, relhasindex, relfilenode, relpartbound,\n      // relnatts (because it includes dropped attributes).\n      PreparedStatement getPgClassRow = conn.prepareStatement(\n          \"SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages,\"\n              + \"   reltuples, relallvisible, reltoastrelid, relisshared,\"\n              + \"   relpersistence, relkind, relchecks, relhasoids, relhasrules,\"\n              + \"   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity,\"\n              + \"   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid,\"\n              + \"   relminmxid, relacl\"\n              + \" FROM pg_class WHERE oid = ?\");\n      // These queries are taken from pg_dump.c, with the following changes:\n      //  * Formatting was changed slightly.\n      //  * Attributes query doesn't include attnotnull (they are changed for PK cols)\n      //      and dropped columns.\n      //  * Index query doesn't include PK index.\n      //  * Index query selects column names instead of attnums.\n      //  * Attribute-related queries don't include attnum (replaced by ORDER BY).\n      //  * Queries don't include tableoids because we don't care.\n      //  * Queries don't include OIDs that are expected to change.\n      //  * Added ORDER BY to all queries.\n      PreparedStatement getAttrs = conn.prepareStatement(\n          \"SELECT a.attname, a.atttypmod, \"\n              + \"   a.attstattarget, a.attstorage, t.typstorage, \"\n              + \"   a.atthasdef, a.attlen, a.attalign, a.attislocal, \"\n              + \"   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, \"\n              + \"   array_to_string(a.attoptions, ', ') AS attoptions, \"\n              + \"   CASE WHEN a.attcollation <> t.typcollation \"\n              + \"     THEN a.attcollation ELSE 0 END AS attcollation, \"\n              + \"   a.attidentity, \"\n              + \"   pg_catalog.array_to_string(ARRAY(\"\n              + \"     SELECT pg_catalog.quote_ident(option_name) || \"\n              + \"     ' ' || pg_catalog.quote_literal(option_value) \"\n              + \"     FROM pg_catalog.pg_options_to_table(attfdwoptions) \"\n              + \"     ORDER BY option_name\"\n              + \"   ), E',\\n    ') AS attfdwoptions ,\"\n              + \"   CASE WHEN a.atthasmissing AND NOT a.attisdropped \"\n              + \"     THEN a.attmissingval ELSE null END AS attmissingval \"\n              + \" FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t \"\n              + \"   ON a.atttypid = t.oid \"\n              + \" WHERE a.attrelid = ?::pg_catalog.oid \"\n              + \"   AND a.attnum > 0::pg_catalog.int2 \"\n              + \"   AND NOT a.attisdropped \"\n              + \" ORDER BY a.attnum\");\n      PreparedStatement getDefaults = conn.prepareStatement(\n          \"SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc \"\n              + \" FROM pg_catalog.pg_attrdef \"\n              + \" WHERE adrelid = ?::pg_catalog.oid \"\n              + \" ORDER BY adnum\");\n      PreparedStatement getCheckConstrs = conn.prepareStatement(\n          \"SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc,\"\n              + \"   conislocal, convalidated\"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getIndexes = conn.prepareStatement(\n          \"SELECT t.relname AS indexname, \"\n              + \"   inh.inhparent AS parentidx, \"\n              + \"   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, \"\n              + \"   i.indnkeyatts AS indnkeyatts, \"\n              + \"   i.indnatts AS indnatts, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) \"\n              + \"     AS indkey_colnames, \"\n              + \"   i.indisclustered, \"\n              + \"   i.indisreplident, i.indoption, t.relpages, \"\n              + \"   c.contype, c.conname, \"\n              + \"   c.condeferrable, c.condeferred, \"\n              + \"   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, \"\n              + \"   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)\"\n              + \"     AS tablespace, \"\n              + \"   t.reloptions AS indreloptions, \"\n              + \"   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatcols,\"\n              + \"   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) \"\n              + \"     FROM pg_catalog.pg_attribute \"\n              + \"     WHERE attrelid = i.indexrelid AND \"\n              + \"       attstattarget >= 0) AS indstatvals \"\n              + \" FROM pg_catalog.pg_index i \"\n              + \" JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) \"\n              + \" JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) \"\n              + \" LEFT JOIN pg_catalog.pg_constraint c \"\n              + \"   ON (i.indrelid = c.conrelid AND \"\n              + \"     i.indexrelid = c.conindid AND \"\n              + \"     c.contype IN ('u','x')) \"\n              + \" LEFT JOIN pg_catalog.pg_inherits inh \"\n              + \"   ON (inh.inhrelid = indexrelid) \"\n              + \" WHERE i.indrelid = ?::pg_catalog.oid \"\n              + \"   AND (i.indisvalid OR t2.relkind = 'p') \"\n              + \"   AND i.indisready \"\n              + \"   AND i.indisprimary = false \"\n              + \" ORDER BY indexname\");\n      PreparedStatement getForeignKeys = conn.prepareStatement(\n          \"SELECT conname, confrelid, \"\n              + \"   pg_catalog.pg_get_constraintdef(oid) AS condef \"\n              + \" FROM pg_catalog.pg_constraint \"\n              + \" WHERE conrelid = ?::pg_catalog.oid \"\n              + \"  AND conparentid = 0 \"\n              + \"  AND contype = 'f'\"\n              + \" ORDER BY conname\");\n      PreparedStatement getTriggers = conn.prepareStatement(\n          \"SELECT tgname, \"\n              + \"   tgfoid::pg_catalog.regproc AS tgfname, \"\n              + \"   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, \"\n              + \"   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k \"\n              + \"     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) \"\n              + \"     AS tgattr_colnames, \"\n              + \"   tgenabled \"\n              + \" FROM pg_catalog.pg_trigger t \"\n              + \" WHERE tgrelid = ?::pg_catalog.oid \"\n              + \"   AND NOT tgisinternal\"\n              + \" ORDER BY tgfname\");\n      List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);\n      assertTrue(\"Table with OID \" + oid + \" not found!\", pgClassRows.size() > 0);\n      this.pgClassRow = pgClassRows.get(0);\n      this.attrs = execCheckQuery(getAttrs, oid);\n      this.defaults = execCheckQuery(getDefaults, oid);\n      this.checkConstrs = execCheckQuery(getCheckConstrs, oid);\n      this.indexes = execCheckQuery(getIndexes, oid);\n      this.foreignKeys = execCheckQuery(getForeignKeys, oid);\n      this.triggers = execCheckQuery(getTriggers, oid);\n    }\n  }\n"]]}
{"hexsha": "469ab8b8135d229de2f22682bfe1f823e382cb62", "ext": "java", "lang": "Java", "content": "public class BaseKnowledgeManagerTest {\n\n\tprivate BaseKnowledgeManager tested;\n\n\t@Mock\n\tprivate TriggerListener triggerListener;\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\ttested.update(createKnowledge());\n\t\tinitMocks(this);\n\t}\n\n\tpublic static ChangeSet createKnowledge() {\n\t\tChangeSet result = new ChangeSet();\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"id\"), \"Test\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"number\"), 10);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapKeyInner\"), \"x\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"date\"), null);\n\t\tList<Integer> list = new LinkedList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"list\"), list);\n\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"a\", 1);\n\t\tmap.put(\"b\", 2);\n\t\tmap.put(\"c\", 3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"map\"), map);\n\t\tresult.setValue(\n\t\t\t\tRuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"),\n\t\t\t\tnew InnerKnowledge(\"innerA\", \"innerB\"));\n\t\tMap<String, String> mapNested = new HashMap<>();\n\t\tmapNested.put(\"x\", \"a\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapNested\"), mapNested);\n\t\t\n\t\treturn result;\n\t}\n\n\t@Test\n\tpublic void testUpdateIntegerField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for the 'number' field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the number field the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(17, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t}\n\n\t@Test\n\tpublic void testInnerKnowledgeUpdate() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for some nested inner field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, \"innerAModified\");\n\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the inner knowledge the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(\"innerAModified\", result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\")));\n\t}\n\n\t@Test\n\tpublic void testUpdateListField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 4);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(4, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"list\")));\n\t}\n\n\t@Test\n\tpublic void testUpdateMapField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(16, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"map\")));\n\t}\n\n\t@Test\n\tpublic void testRemovalFromList() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tObject nextItemValue = tested.get(knowledgePaths).getValue(kp);\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n\t\tknowledgePaths.clear();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\n\t\t// THEN when accessed the deleted item index, the KnowledgeManager\n\t\t// should return\n\t\t// the value of the next item\n\t\tassertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));\n\t}\n\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testDeleteFromMap() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'map' elements is\n\t\t// passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\n\t\t// THEN when accessed the removed element value the KnowledgeManager\n\t\t// should throw the KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\n\t@Test\n\tpublic void testGetIntegerField() throws Exception {\n\t\t// WHEN a field is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(10, result.getValue(kp));\n\t}\n\n\t@Test\n\tpublic void testInnerKnowledgeGet() throws Exception {\n\t\t// WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(\"innerA\", result.getValue(kp));\n\t}\n\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNullBaseKnowledgeAccess() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\t// WHEN a field is accessed from the knowledge manager initialized with\n\t\t// null base knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\t// THEN exception is thrown.\n\t\ttested.get(knowledgePaths);\n\t}\n\n\t@Test\n\tpublic void testGetListField() throws Exception {\n\t\t// WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(3, result.getValue(kp));\n\t}\n\n\t@Test\n\tpublic void testGetMapField() throws Exception {\n\t\t// WHEN an element of a map is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(1, result.getValue(kp));\n\t}\n\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNotExsistentAccess() throws Exception {\n\t\t// WHEN a not existent entry is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"dummy\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\t// THEN the ReadOnlyKnowledgeManager should throw the\n\t\t// KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\n\t@Test\n\tpublic void testRegisterListener() throws Exception {\n\t\t// WHEN a listener is registered at the KnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// and WHEN listener's releavant knowledge is updated\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\t\ttested.update(toUpdate);\n\t\t// THEN the listener is notify once.\n\t\tverify(triggerListener).triggered(trigger);\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\n\t@Test\n\tpublic void testUnregisterListener() throws Exception {\n\t\t// WHEN a previously registered listener\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// is unregistered from the KnowledgeManager\n\t\ttested.register(trigger, triggerListener);\n\t\t// THEN it is not notified about knowledge changes any more\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\n\t@Test\n\tpublic void testGetRootKnowledge() throws Exception {\n\t\t// WHEN empty knowledge path is created\n\t\tKnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(emptyKP);\n\t\t// and WHEN it is used to access knowledge manager data\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN as a result the knowledge manager should return its root\n\t\t// knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"id\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"date\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t}\n\n\tpublic void testForbiddenUpdate() throws Exception {\n\t\t// WHEN the knowledge manager update is required, with one list element\n\t\t// removal and number field update and incorrect inner knowledge change\n\t\tKnowledgePath numberPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"number\");\n\t\tKnowledgePath listElementPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"list\", \"1\");\n\t\tKnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tChangeSet toChange = new ChangeSet();\n\t\ttoChange.setValue(numberPath, 100);\n\t\ttoChange.setValue(innerPath, 66);\n\t\ttoChange.setDeleted(listElementPath);\n\n\t\tboolean exceptionThrown = false;\n\n\t\ttry {\n\t\t\ttested.update(toChange, \"update_author\");\n\t\t} catch (KnowledgeUpdateException e) {\n\t\t\texceptionThrown = true;\n\t\t}\n\t\t// THEN the KnowledgeUpdateException is thrown\n\t\tassertTrue(exceptionThrown);\n\n\t\tKnowledgePath listPath = RuntimeModelHelper.createKnowledgePath(\"list\");\n\t\tList<KnowledgePath> listOfPaths = new LinkedList<>();\n\t\t// and THEN list remains unchanged\n\t\tlistOfPaths.add(listPath);\n\t\tassertEquals(3,\n\t\t\t\t((List<?>) tested.get(listOfPaths).getValue(listPath)).size());\n\t\tlistOfPaths.clear();\n\t\t// and THEN inner knowledge has its original value\n\t\tlistOfPaths.add(innerPath);\n\t\tassertEquals(\"innerA\", tested.get(listOfPaths).getValue(innerPath));\n\t\tlistOfPaths.clear();\n\t\t// and THEN number field has its original value\n\t\tlistOfPaths.add(numberPath);\n\t\tassertEquals(10, tested.get(listOfPaths).getValue(numberPath));\n\t\t\n\t\t// then authors of knowledge remain the same\n\t\tassertEquals(\"TEST\", tested.getAuthor(numberPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(listElementPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(innerPath));\n\t}\n\n\t@Test\n\tpublic void securityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(expectedTags, actualTags);\n\t}\n\t\n\t@Test\n\tpublic void addSecurityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\ttested.addSecurityTag(kp, tag);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(2, actualTags.size());\n\t\tassertEquals(tag, actualTags.get(0));\n\t\tassertEquals(tag, actualTags.get(1));\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_MultiNodePathTest() {\n\t\t// given multi-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\", \"inner\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_IdPathTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath();\n\t\tkp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest1() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n\t\tKnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\");\n\t\t\n\t\t// when nested path is used and getAuthor() called\n\t\tString innerAuthor = tested.getAuthor(nestedPath);\n\t\tString outerAuthor = tested.getAuthor(basicPath);\n\t\t\n\t\t// then author is returned\n\t\tassertEquals(\"TEST\", innerAuthor);\n\t\tassertEquals(\"TEST\", outerAuthor);\n\t\t\n\t\t// then knowledge paths remain intact\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\"), nestedPath);\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), basicPath);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest2() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath(\"non\", \"existent\", \"path\");\n\t\t\n\t\t// when getAuthor() is called\n\t\tString author = tested.getAuthor(nonExistentPath);\n\t\t\n\t\t// then null is returned\n\t\tassertNull(author);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// WHEN the 'map' itself is then updated by a different author\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setValue(kp2, new HashMap<>());\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is set to Y\n\t\tassertEquals(\"Y\", tested.getAuthor(kp2));\n\t\tassertEquals(\"Y\", tested.getAuthor(kp));\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\n\t\t// WHEN the 'map' itself is then deleted\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setDeleted(kp2);\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is null\n\t\tassertNull(tested.getAuthor(kp2));\n\t\tassertNull(tested.getAuthor(kp));\n\t}\n\t\n\tpublic static class InnerKnowledge {\n\t\tpublic String a;\n\t\tpublic String b;\n\n\t\tpublic InnerKnowledge(String a, String b) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "d3scomp/JDEECo", "file": "jdeeco-core/test/cz/cuni/mff/d3s/deeco/knowledge/BaseKnowledgeManagerTest.java", "last_update_at": "2021-09-22T12:46:58+00:00", "question_id": "469ab8b8135d229de2f22682bfe1f823e382cb62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseKnowledgeManagerTest {\n\tprivate BaseKnowledgeManager tested;\n\t@Mock\n\tprivate TriggerListener triggerListener;\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\ttested.update(createKnowledge());\n\t\tinitMocks(this);\n\t}\n\tpublic static ChangeSet createKnowledge() {\n\t\tChangeSet result = new ChangeSet();\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"id\"), \"Test\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"number\"), 10);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapKeyInner\"), \"x\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"date\"), null);\n\t\tList<Integer> list = new LinkedList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"list\"), list);\n\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"a\", 1);\n\t\tmap.put(\"b\", 2);\n\t\tmap.put(\"c\", 3);\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"map\"), map);\n\t\tresult.setValue(\n\t\t\t\tRuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"),\n\t\t\t\tnew InnerKnowledge(\"innerA\", \"innerB\"));\n\t\tMap<String, String> mapNested = new HashMap<>();\n\t\tmapNested.put(\"x\", \"a\");\n\t\tresult.setValue(RuntimeModelHelper.createKnowledgePath(\"mapNested\"), mapNested);\n\t\t\n\t\treturn result;\n\t}\n\t@Test\n\tpublic void testUpdateIntegerField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for the 'number' field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the number field the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(17, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t}\n\t@Test\n\tpublic void testInnerKnowledgeUpdate() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for some nested inner field is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, \"innerAModified\");\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the inner knowledge the KnowledgeManager should\n\t\t// return updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(\"innerAModified\", result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\")));\n\t}\n\t@Test\n\tpublic void testUpdateListField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 4);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(4, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"list\")));\n\t}\n\t@Test\n\tpublic void testUpdateMapField() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// THEN when accessed the item value the KnowledgeManager should return\n\t\t// updated value\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\tassertEquals(16, result.getValue(kp));\n\t\tassertEquals(\"X\", tested.getAuthor(kp));\n\t\tassertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"map\")));\n\t}\n\t@Test\n\tpublic void testRemovalFromList() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'list' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tObject nextItemValue = tested.get(knowledgePaths).getValue(kp);\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n\t\tknowledgePaths.clear();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\t\t// THEN when accessed the deleted item index, the KnowledgeManager\n\t\t// should return\n\t\t// the value of the next item\n\t\tassertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));\n\t}\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testDeleteFromMap() throws Exception {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the removal of one of the 'map' elements is\n\t\t// passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toDelete = new ChangeSet();\n\t\ttoDelete.setDeleted(kp);\n\t\ttested.update(toDelete);\n\t\t// THEN when accessed the removed element value the KnowledgeManager\n\t\t// should throw the KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\t@Test\n\tpublic void testGetIntegerField() throws Exception {\n\t\t// WHEN a field is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(10, result.getValue(kp));\n\t}\n\t@Test\n\tpublic void testInnerKnowledgeGet() throws Exception {\n\t\t// WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(\"innerA\", result.getValue(kp));\n\t}\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNullBaseKnowledgeAccess() throws Exception {\n\t\ttested = new BaseKnowledgeManager(\"TEST\", null, null);\n\t\t// WHEN a field is accessed from the knowledge manager initialized with\n\t\t// null base knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\t// THEN exception is thrown.\n\t\ttested.get(knowledgePaths);\n\t}\n\t@Test\n\tpublic void testGetListField() throws Exception {\n\t\t// WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(3, result.getValue(kp));\n\t}\n\t@Test\n\tpublic void testGetMapField() throws Exception {\n\t\t// WHEN an element of a map is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN the correct value is returned\n\t\tassertEquals(1, result.getValue(kp));\n\t}\n\t@Test(expected = KnowledgeNotFoundException.class)\n\tpublic void testNotExsistentAccess() throws Exception {\n\t\t// WHEN a not existent entry is accessed from the\n\t\t// ReadOnlyKnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"dummy\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\t// THEN the ReadOnlyKnowledgeManager should throw the\n\t\t// KnowledgeNotExistentException\n\t\ttested.get(knowledgePaths);\n\t}\n\t@Test\n\tpublic void testRegisterListener() throws Exception {\n\t\t// WHEN a listener is registered at the KnowledgeManager\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// and WHEN listener's releavant knowledge is updated\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 17);\n\t\ttested.update(toUpdate);\n\t\t// THEN the listener is notify once.\n\t\tverify(triggerListener).triggered(trigger);\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\t@Test\n\tpublic void testUnregisterListener() throws Exception {\n\t\t// WHEN a previously registered listener\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n\t\tKnowledgeChangeTrigger trigger = RuntimeModelHelper\n\t\t\t\t.createKnowledgeChangeTrigger();\n\t\ttrigger.setKnowledgePath(kp);\n\t\ttested.register(trigger, triggerListener);\n\t\t// is unregistered from the KnowledgeManager\n\t\ttested.register(trigger, triggerListener);\n\t\t// THEN it is not notified about knowledge changes any more\n\t\tverifyNoMoreInteractions(triggerListener);\n\t}\n\t@Test\n\tpublic void testGetRootKnowledge() throws Exception {\n\t\t// WHEN empty knowledge path is created\n\t\tKnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(emptyKP);\n\t\t// and WHEN it is used to access knowledge manager data\n\t\tValueSet result = tested.get(knowledgePaths);\n\t\t// THEN as a result the knowledge manager should return its root\n\t\t// knowledge\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"id\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t\tkp = RuntimeModelHelper.createKnowledgePath(\"date\");\n\t\tassertTrue(result.getKnowledgePaths().contains(kp));\n\t}\n\tpublic void testForbiddenUpdate() throws Exception {\n\t\t// WHEN the knowledge manager update is required, with one list element\n\t\t// removal and number field update and incorrect inner knowledge change\n\t\tKnowledgePath numberPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"number\");\n\t\tKnowledgePath listElementPath = RuntimeModelHelper\n\t\t\t\t.createKnowledgePath(\"list\", \"1\");\n\t\tKnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath(\n\t\t\t\t\"innerKnowledge\", \"a\");\n\t\tChangeSet toChange = new ChangeSet();\n\t\ttoChange.setValue(numberPath, 100);\n\t\ttoChange.setValue(innerPath, 66);\n\t\ttoChange.setDeleted(listElementPath);\n\t\tboolean exceptionThrown = false;\n\t\ttry {\n\t\t\ttested.update(toChange, \"update_author\");\n\t\t} catch (KnowledgeUpdateException e) {\n\t\t\texceptionThrown = true;\n\t\t}\n\t\t// THEN the KnowledgeUpdateException is thrown\n\t\tassertTrue(exceptionThrown);\n\t\tKnowledgePath listPath = RuntimeModelHelper.createKnowledgePath(\"list\");\n\t\tList<KnowledgePath> listOfPaths = new LinkedList<>();\n\t\t// and THEN list remains unchanged\n\t\tlistOfPaths.add(listPath);\n\t\tassertEquals(3,\n\t\t\t\t((List<?>) tested.get(listOfPaths).getValue(listPath)).size());\n\t\tlistOfPaths.clear();\n\t\t// and THEN inner knowledge has its original value\n\t\tlistOfPaths.add(innerPath);\n\t\tassertEquals(\"innerA\", tested.get(listOfPaths).getValue(innerPath));\n\t\tlistOfPaths.clear();\n\t\t// and THEN number field has its original value\n\t\tlistOfPaths.add(numberPath);\n\t\tassertEquals(10, tested.get(listOfPaths).getValue(numberPath));\n\t\t\n\t\t// then authors of knowledge remain the same\n\t\tassertEquals(\"TEST\", tested.getAuthor(numberPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(listElementPath));\n\t\tassertEquals(\"TEST\", tested.getAuthor(innerPath));\n\t}\n\t@Test\n\tpublic void securityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(expectedTags, actualTags);\n\t}\n\t\n\t@Test\n\tpublic void addSecurityTagsTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tKnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n\t\ttag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n\t\ttag.getRequiredRole().setRoleName(\"role\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList(tag);\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\ttested.addSecurityTag(kp, tag);\n\t\t\n\t\t// when security tags are then retrieved\n\t\tKnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n\t\tList<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n\t\t\n\t\t// then collections are equal\n\t\tassertEquals(2, actualTags.size());\n\t\tassertEquals(tag, actualTags.get(0));\n\t\tassertEquals(tag, actualTags.get(1));\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_MultiNodePathTest() {\n\t\t// given multi-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\", \"inner\");\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void markAsSecured_IdPathTest() {\n\t\t// given single-noded knowledge path and security tags are prepared\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath();\n\t\tkp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());\n\t\tCollection<SecurityTag> expectedTags = Arrays.asList();\n\t\t\n\t\t// when setSecurityTags() is called\n\t\ttested.setSecurityTags(kp, expectedTags);\n\t\t\n\t\t// then exception is thrown\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest1() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n\t\tKnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\");\n\t\t\n\t\t// when nested path is used and getAuthor() called\n\t\tString innerAuthor = tested.getAuthor(nestedPath);\n\t\tString outerAuthor = tested.getAuthor(basicPath);\n\t\t\n\t\t// then author is returned\n\t\tassertEquals(\"TEST\", innerAuthor);\n\t\tassertEquals(\"TEST\", outerAuthor);\n\t\t\n\t\t// then knowledge paths remain intact\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\"), nestedPath);\n\t\tassertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), basicPath);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest2() {\n\t\t// given basic knowledge is created\n\t\tKnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath(\"non\", \"existent\", \"path\");\n\t\t\n\t\t// when getAuthor() is called\n\t\tString author = tested.getAuthor(nonExistentPath);\n\t\t\n\t\t// then null is returned\n\t\tassertNull(author);\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// WHEN the 'map' itself is then updated by a different author\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setValue(kp2, new HashMap<>());\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is set to Y\n\t\tassertEquals(\"Y\", tested.getAuthor(kp2));\n\t\tassertEquals(\"Y\", tested.getAuthor(kp));\n\t}\n\t\n\t@Test\n\tpublic void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n\t\t// WHEN the update method is called on the KnowledgeManager\n\t\t// and as a ChangeSet, the update for one of the 'map' items is passed\n\t\tKnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n\t\tList<KnowledgePath> knowledgePaths = new LinkedList<>();\n\t\tknowledgePaths.add(kp);\n\t\tChangeSet toUpdate = new ChangeSet();\n\t\ttoUpdate.setValue(kp, 16);\n\t\ttested.update(toUpdate, \"X\");\n\t\t// WHEN the 'map' itself is then deleted\n\t\tKnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n\t\tList<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n\t\tknowledgePaths2.add(kp2);\n\t\tChangeSet toUpdate2 = new ChangeSet();\n\t\ttoUpdate2.setDeleted(kp2);\n\t\ttested.update(toUpdate2, \"Y\");\n\t\t\n\t\t// THEN author of the 'map' and the 'map.a' is null\n\t\tassertNull(tested.getAuthor(kp2));\n\t\tassertNull(tested.getAuthor(kp));\n\t}\n\t\n\tpublic static class InnerKnowledge {\n\t\tpublic String a;\n\t\tpublic String b;\n\t\tpublic InnerKnowledge(String a, String b) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n"]]}
{"hexsha": "2f09050d499d8eb4df2f94048b0b44a79bf11ad5", "ext": "java", "lang": "Java", "content": "public class MockApnsServer extends BaseHttp2Server {\n\n    private final PushNotificationHandlerFactory handlerFactory;\n    private final MockApnsServerListener listener;\n\n    private final int maxConcurrentStreams;\n\n    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup,\n                   final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener,\n                   final int maxConcurrentStreams) {\n\n        super(sslContext, eventLoopGroup);\n\n        this.handlerFactory = handlerFactory;\n        this.listener = listener;\n\n        this.maxConcurrentStreams = maxConcurrentStreams;\n    }\n\n    @Override\n    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {\n        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);\n\n        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder()\n                .pushNotificationHandler(pushNotificationHandler)\n                .initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams))\n                .listener(this.listener)\n                .build();\n\n        pipeline.addLast(serverHandler);\n    }\n}", "class_id": 0, "repo": "Chatatata/pushy", "file": "pushy/src/main/java/sa/com/stcpay/blink/pushy/server/MockApnsServer.java", "last_update_at": "2021-01-04T11:06:26+00:00", "question_id": "2f09050d499d8eb4df2f94048b0b44a79bf11ad5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockApnsServer extends BaseHttp2Server {\n    private final PushNotificationHandlerFactory handlerFactory;\n    private final MockApnsServerListener listener;\n    private final int maxConcurrentStreams;\n    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup,\n                   final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener,\n                   final int maxConcurrentStreams) {\n        super(sslContext, eventLoopGroup);\n        this.handlerFactory = handlerFactory;\n        this.listener = listener;\n        this.maxConcurrentStreams = maxConcurrentStreams;\n    }\n    @Override\n    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {\n        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);\n        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder()\n                .pushNotificationHandler(pushNotificationHandler)\n                .initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams))\n                .listener(this.listener)\n                .build();\n        pipeline.addLast(serverHandler);\n    }\n"]]}
{"hexsha": "6121857566879d003fc4f936c4f45ac6ff2ab499", "ext": "java", "lang": "Java", "content": "public class GrobidCitationFetcher implements SearchBasedFetcher {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);\n\n    private static final String GROBID_URL = \"http://grobid.jabref.org:8070\";\n    private ImportFormatPreferences importFormatPreferences;\n    private GrobidService grobidService;\n\n    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {\n        this(importFormatPreferences, new GrobidService(GROBID_URL));\n    }\n\n    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {\n        this.importFormatPreferences = importFormatPreferences;\n        this.grobidService = grobidService;\n    }\n\n    /**\n     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the\n     * server has to look up the entry.\n     *\n     * @return A BibTeX string if extraction is successful\n     */\n    private Optional<String> parseUsingGrobid(String plainText) {\n        try {\n            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));\n        } catch (SocketTimeoutException e) {\n            String msg = \"Connection timed out.\";\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        } catch (IOException e) {\n            String msg = \"Could not process citation. \" + e.getMessage();\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        }\n    }\n\n    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {\n        try {\n            return BibtexParser.singleFromString(bibtexString,\n                    importFormatPreferences, new DummyFileUpdateMonitor());\n        } catch (ParseException e) {\n            return Optional.empty();\n        }\n    }\n\n    @Override\n    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {\n        List<BibEntry> bibEntries = null;\n        // This just treats the complex query like a normal string query until it it implemented correctly\n        String query = complexSearchQuery.toString();\n        try {\n            bibEntries = Arrays\n                    .stream(query.split(\"\\\\r\\\\r+|\\\\n\\\\n+|\\\\r\\\\n(\\\\r\\\\n)+\"))\n                    .map(String::trim)\n                    .filter(str -> !str.isBlank())\n                    .map(this::parseUsingGrobid)\n                    .flatMap(Optional::stream)\n                    .map(this::parseBibToBibEntry)\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toList());\n        } catch (RuntimeException e) {\n            // un-wrap the wrapped exceptions\n            throw new FetcherException(e.getMessage(), e.getCause());\n        }\n        return bibEntries;\n    }\n\n    @Override\n    public String getName() {\n        return \"GROBID\";\n    }\n\n}", "class_id": 0, "repo": "scfinniss/jabref", "file": "src/main/java/org/jabref/logic/importer/fetcher/GrobidCitationFetcher.java", "last_update_at": "2021-04-02T16:02:25+00:00", "question_id": "6121857566879d003fc4f936c4f45ac6ff2ab499", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GrobidCitationFetcher implements SearchBasedFetcher {\n    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);\n    private static final String GROBID_URL = \"http://grobid.jabref.org:8070\";\n    private ImportFormatPreferences importFormatPreferences;\n    private GrobidService grobidService;\n    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {\n        this(importFormatPreferences, new GrobidService(GROBID_URL));\n    }\n    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {\n        this.importFormatPreferences = importFormatPreferences;\n        this.grobidService = grobidService;\n    }\n    /**\n     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the\n     * server has to look up the entry.\n     *\n     * @return A BibTeX string if extraction is successful\n     */\n    private Optional<String> parseUsingGrobid(String plainText) {\n        try {\n            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));\n        } catch (SocketTimeoutException e) {\n            String msg = \"Connection timed out.\";\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        } catch (IOException e) {\n            String msg = \"Could not process citation. \" + e.getMessage();\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        }\n    }\n    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {\n        try {\n            return BibtexParser.singleFromString(bibtexString,\n                    importFormatPreferences, new DummyFileUpdateMonitor());\n        } catch (ParseException e) {\n            return Optional.empty();\n        }\n    }\n    @Override\n    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {\n        List<BibEntry> bibEntries = null;\n        // This just treats the complex query like a normal string query until it it implemented correctly\n        String query = complexSearchQuery.toString();\n        try {\n            bibEntries = Arrays\n                    .stream(query.split(\"\\\\r\\\\r+|\\\\n\\\\n+|\\\\r\\\\n(\\\\r\\\\n)+\"))\n                    .map(String::trim)\n                    .filter(str -> !str.isBlank())\n                    .map(this::parseUsingGrobid)\n                    .flatMap(Optional::stream)\n                    .map(this::parseBibToBibEntry)\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toList());\n        } catch (RuntimeException e) {\n            // un-wrap the wrapped exceptions\n            throw new FetcherException(e.getMessage(), e.getCause());\n        }\n        return bibEntries;\n    }\n    @Override\n    public String getName() {\n        return \"GROBID\";\n    }\n"]]}
{"hexsha": "9687d6ab54c8b9d8f51dadc5b7c29d4734a45987", "ext": "java", "lang": "Java", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"AddClientsToClassesRequest\", propOrder = {\n    \"clientIDs\",\n    \"classIDs\",\n    \"test\",\n    \"requirePayment\",\n    \"waitlist\",\n    \"sendEmail\"\n})\npublic class AddClientsToClassesRequest\n    extends MBRequest\n    implements Serializable, Equals, HashCode, ToString\n{\n\n    private final static long serialVersionUID = 1L;\n    @XmlElement(name = \"ClientIDs\")\n    protected ArrayOfString clientIDs;\n    @XmlElement(name = \"ClassIDs\")\n    protected ArrayOfInt classIDs;\n    @XmlElement(name = \"Test\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean test;\n    @XmlElement(name = \"RequirePayment\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean requirePayment;\n    @XmlElement(name = \"Waitlist\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean waitlist;\n    @XmlElement(name = \"SendEmail\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean sendEmail;\n\n    /**\n     * Gets the value of the clientIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public ArrayOfString getClientIDs() {\n        return clientIDs;\n    }\n\n    /**\n     * Sets the value of the clientIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public void setClientIDs(ArrayOfString value) {\n        this.clientIDs = value;\n    }\n\n    /**\n     * Gets the value of the classIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public ArrayOfInt getClassIDs() {\n        return classIDs;\n    }\n\n    /**\n     * Sets the value of the classIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public void setClassIDs(ArrayOfInt value) {\n        this.classIDs = value;\n    }\n\n    /**\n     * Gets the value of the test property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getTest() {\n        return test;\n    }\n\n    /**\n     * Sets the value of the test property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setTest(Boolean value) {\n        this.test = value;\n    }\n\n    /**\n     * Gets the value of the requirePayment property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getRequirePayment() {\n        return requirePayment;\n    }\n\n    /**\n     * Sets the value of the requirePayment property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setRequirePayment(Boolean value) {\n        this.requirePayment = value;\n    }\n\n    /**\n     * Gets the value of the waitlist property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getWaitlist() {\n        return waitlist;\n    }\n\n    /**\n     * Sets the value of the waitlist property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setWaitlist(Boolean value) {\n        this.waitlist = value;\n    }\n\n    /**\n     * Gets the value of the sendEmail property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getSendEmail() {\n        return sendEmail;\n    }\n\n    /**\n     * Sets the value of the sendEmail property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setSendEmail(Boolean value) {\n        this.sendEmail = value;\n    }\n\n    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {\n        int currentHashCode = super.hashCode(locator, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"clientIDs\", theClientIDs), currentHashCode, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"classIDs\", theClassIDs), currentHashCode, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"test\", theTest), currentHashCode, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"requirePayment\", theRequirePayment), currentHashCode, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"waitlist\", theWaitlist), currentHashCode, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"sendEmail\", theSendEmail), currentHashCode, theSendEmail);\n        }\n        return currentHashCode;\n    }\n\n    public int hashCode() {\n        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;\n        return this.hashCode(null, strategy);\n    }\n\n    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {\n        if (!(object instanceof AddClientsToClassesRequest)) {\n            return false;\n        }\n        if (this == object) {\n            return true;\n        }\n        if (!super.equals(thisLocator, thatLocator, object, strategy)) {\n            return false;\n        }\n        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);\n        {\n            ArrayOfString lhsClientIDs;\n            lhsClientIDs = this.getClientIDs();\n            ArrayOfString rhsClientIDs;\n            rhsClientIDs = that.getClientIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"clientIDs\", lhsClientIDs), LocatorUtils.property(thatLocator, \"clientIDs\", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {\n                return false;\n            }\n        }\n        {\n            ArrayOfInt lhsClassIDs;\n            lhsClassIDs = this.getClassIDs();\n            ArrayOfInt rhsClassIDs;\n            rhsClassIDs = that.getClassIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"classIDs\", lhsClassIDs), LocatorUtils.property(thatLocator, \"classIDs\", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsTest;\n            lhsTest = this.getTest();\n            Boolean rhsTest;\n            rhsTest = that.getTest();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"test\", lhsTest), LocatorUtils.property(thatLocator, \"test\", rhsTest), lhsTest, rhsTest)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsRequirePayment;\n            lhsRequirePayment = this.getRequirePayment();\n            Boolean rhsRequirePayment;\n            rhsRequirePayment = that.getRequirePayment();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"requirePayment\", lhsRequirePayment), LocatorUtils.property(thatLocator, \"requirePayment\", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsWaitlist;\n            lhsWaitlist = this.getWaitlist();\n            Boolean rhsWaitlist;\n            rhsWaitlist = that.getWaitlist();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"waitlist\", lhsWaitlist), LocatorUtils.property(thatLocator, \"waitlist\", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsSendEmail;\n            lhsSendEmail = this.getSendEmail();\n            Boolean rhsSendEmail;\n            rhsSendEmail = that.getSendEmail();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"sendEmail\", lhsSendEmail), LocatorUtils.property(thatLocator, \"sendEmail\", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean equals(Object object) {\n        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;\n        return equals(null, null, object, strategy);\n    }\n\n    public String toString() {\n        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;\n        final StringBuilder buffer = new StringBuilder();\n        append(null, buffer, strategy);\n        return buffer.toString();\n    }\n\n    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        strategy.appendStart(locator, this, buffer);\n        appendFields(locator, buffer, strategy);\n        strategy.appendEnd(locator, this, buffer);\n        return buffer;\n    }\n\n    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        super.appendFields(locator, buffer, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            strategy.appendField(locator, this, \"clientIDs\", buffer, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            strategy.appendField(locator, this, \"classIDs\", buffer, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            strategy.appendField(locator, this, \"test\", buffer, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            strategy.appendField(locator, this, \"requirePayment\", buffer, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            strategy.appendField(locator, this, \"waitlist\", buffer, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            strategy.appendField(locator, this, \"sendEmail\", buffer, theSendEmail);\n        }\n        return buffer;\n    }\n\n}", "class_id": 0, "repo": "xaderfos/hyperjaxb3-support", "file": "m/MindBody/src/main/java/integration/mindbody/AddClientsToClassesRequest.java", "last_update_at": "2021-02-03T09:26:07+00:00", "question_id": "9687d6ab54c8b9d8f51dadc5b7c29d4734a45987", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"AddClientsToClassesRequest\", propOrder = {\n    \"clientIDs\",\n    \"classIDs\",\n    \"test\",\n    \"requirePayment\",\n    \"waitlist\",\n    \"sendEmail\"\n})\npublic class AddClientsToClassesRequest\n    extends MBRequest\n    implements Serializable, Equals, HashCode, ToString\n{\n    private final static long serialVersionUID = 1L;\n    @XmlElement(name = \"ClientIDs\")\n    protected ArrayOfString clientIDs;\n    @XmlElement(name = \"ClassIDs\")\n    protected ArrayOfInt classIDs;\n    @XmlElement(name = \"Test\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean test;\n    @XmlElement(name = \"RequirePayment\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean requirePayment;\n    @XmlElement(name = \"Waitlist\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean waitlist;\n    @XmlElement(name = \"SendEmail\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean sendEmail;\n    /**\n     * Gets the value of the clientIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public ArrayOfString getClientIDs() {\n        return clientIDs;\n    }\n    /**\n     * Sets the value of the clientIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfString }\n     *     \n     */\n    public void setClientIDs(ArrayOfString value) {\n        this.clientIDs = value;\n    }\n    /**\n     * Gets the value of the classIDs property.\n     * \n     * @return\n     *     possible object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public ArrayOfInt getClassIDs() {\n        return classIDs;\n    }\n    /**\n     * Sets the value of the classIDs property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfInt }\n     *     \n     */\n    public void setClassIDs(ArrayOfInt value) {\n        this.classIDs = value;\n    }\n    /**\n     * Gets the value of the test property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getTest() {\n        return test;\n    }\n    /**\n     * Sets the value of the test property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setTest(Boolean value) {\n        this.test = value;\n    }\n    /**\n     * Gets the value of the requirePayment property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getRequirePayment() {\n        return requirePayment;\n    }\n    /**\n     * Sets the value of the requirePayment property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setRequirePayment(Boolean value) {\n        this.requirePayment = value;\n    }\n    /**\n     * Gets the value of the waitlist property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getWaitlist() {\n        return waitlist;\n    }\n    /**\n     * Sets the value of the waitlist property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setWaitlist(Boolean value) {\n        this.waitlist = value;\n    }\n    /**\n     * Gets the value of the sendEmail property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean getSendEmail() {\n        return sendEmail;\n    }\n    /**\n     * Sets the value of the sendEmail property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setSendEmail(Boolean value) {\n        this.sendEmail = value;\n    }\n    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {\n        int currentHashCode = super.hashCode(locator, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"clientIDs\", theClientIDs), currentHashCode, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"classIDs\", theClassIDs), currentHashCode, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"test\", theTest), currentHashCode, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"requirePayment\", theRequirePayment), currentHashCode, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"waitlist\", theWaitlist), currentHashCode, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"sendEmail\", theSendEmail), currentHashCode, theSendEmail);\n        }\n        return currentHashCode;\n    }\n    public int hashCode() {\n        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;\n        return this.hashCode(null, strategy);\n    }\n    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {\n        if (!(object instanceof AddClientsToClassesRequest)) {\n            return false;\n        }\n        if (this == object) {\n            return true;\n        }\n        if (!super.equals(thisLocator, thatLocator, object, strategy)) {\n            return false;\n        }\n        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);\n        {\n            ArrayOfString lhsClientIDs;\n            lhsClientIDs = this.getClientIDs();\n            ArrayOfString rhsClientIDs;\n            rhsClientIDs = that.getClientIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"clientIDs\", lhsClientIDs), LocatorUtils.property(thatLocator, \"clientIDs\", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {\n                return false;\n            }\n        }\n        {\n            ArrayOfInt lhsClassIDs;\n            lhsClassIDs = this.getClassIDs();\n            ArrayOfInt rhsClassIDs;\n            rhsClassIDs = that.getClassIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"classIDs\", lhsClassIDs), LocatorUtils.property(thatLocator, \"classIDs\", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsTest;\n            lhsTest = this.getTest();\n            Boolean rhsTest;\n            rhsTest = that.getTest();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"test\", lhsTest), LocatorUtils.property(thatLocator, \"test\", rhsTest), lhsTest, rhsTest)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsRequirePayment;\n            lhsRequirePayment = this.getRequirePayment();\n            Boolean rhsRequirePayment;\n            rhsRequirePayment = that.getRequirePayment();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"requirePayment\", lhsRequirePayment), LocatorUtils.property(thatLocator, \"requirePayment\", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsWaitlist;\n            lhsWaitlist = this.getWaitlist();\n            Boolean rhsWaitlist;\n            rhsWaitlist = that.getWaitlist();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"waitlist\", lhsWaitlist), LocatorUtils.property(thatLocator, \"waitlist\", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsSendEmail;\n            lhsSendEmail = this.getSendEmail();\n            Boolean rhsSendEmail;\n            rhsSendEmail = that.getSendEmail();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"sendEmail\", lhsSendEmail), LocatorUtils.property(thatLocator, \"sendEmail\", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public boolean equals(Object object) {\n        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;\n        return equals(null, null, object, strategy);\n    }\n    public String toString() {\n        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;\n        final StringBuilder buffer = new StringBuilder();\n        append(null, buffer, strategy);\n        return buffer.toString();\n    }\n    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        strategy.appendStart(locator, this, buffer);\n        appendFields(locator, buffer, strategy);\n        strategy.appendEnd(locator, this, buffer);\n        return buffer;\n    }\n    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        super.appendFields(locator, buffer, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            strategy.appendField(locator, this, \"clientIDs\", buffer, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            strategy.appendField(locator, this, \"classIDs\", buffer, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            strategy.appendField(locator, this, \"test\", buffer, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            strategy.appendField(locator, this, \"requirePayment\", buffer, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            strategy.appendField(locator, this, \"waitlist\", buffer, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            strategy.appendField(locator, this, \"sendEmail\", buffer, theSendEmail);\n        }\n        return buffer;\n    }\n"]]}
{"hexsha": "8a9bfb3171c29a5cac43a722a02e924726776612", "ext": "java", "lang": "Java", "content": "@Getter\n@Setter\npublic class NpcShop {\n    private int shopId;\n    private int selectNpcItemId;\n    private int npcTemplateId;\n    private int starCoin;\n    private int shopVerNo;\n    private List<NpcShopItem> items = new ArrayList<>();\n\n    public List<NpcShopItem> getItems() {\n        return items;\n    }\n\n    public void setItems(List<NpcShopItem> items) {\n        this.items = items;\n    }\n\n    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {\n        out.writeZeroBytes(20);\n        out.writeInt(DateUtil.getTime());\n        out.writeBool(false);\n        out.writeShort(items.size() + repurchaseItems.size());\n        items.forEach(npcShopItem -> npcShopItem.encode(out));\n        ListIterator<NpcShopItem> itemListIterator;\n        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {\n            itemListIterator.next();\n        }\n        while (itemListIterator.hasPrevious()) {\n            NpcShopItem shopItem = itemListIterator.previous();\n            shopItem.encode(out);\n        }\n    }\n\n    public NpcShopItem getItemByIndex(int idx) {\n        NpcShopItem item = null;\n        if (idx >= 0 && idx < getItems().size()) {\n            item = getItems().get(idx);\n        }\n        return item;\n    }\n\n}", "class_id": 0, "repo": "Heasn/ms", "file": "src/main/java/im/cave/ms/client/field/obj/npc/shop/NpcShop.java", "last_update_at": "2021-12-23T02:26:11+00:00", "question_id": "8a9bfb3171c29a5cac43a722a02e924726776612", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\n@Setter\npublic class NpcShop {\n    private int shopId;\n    private int selectNpcItemId;\n    private int npcTemplateId;\n    private int starCoin;\n    private int shopVerNo;\n    private List<NpcShopItem> items = new ArrayList<>();\n    public List<NpcShopItem> getItems() {\n        return items;\n    }\n    public void setItems(List<NpcShopItem> items) {\n        this.items = items;\n    }\n    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {\n        out.writeZeroBytes(20);\n        out.writeInt(DateUtil.getTime());\n        out.writeBool(false);\n        out.writeShort(items.size() + repurchaseItems.size());\n        items.forEach(npcShopItem -> npcShopItem.encode(out));\n        ListIterator<NpcShopItem> itemListIterator;\n        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {\n            itemListIterator.next();\n        }\n        while (itemListIterator.hasPrevious()) {\n            NpcShopItem shopItem = itemListIterator.previous();\n            shopItem.encode(out);\n        }\n    }\n    public NpcShopItem getItemByIndex(int idx) {\n        NpcShopItem item = null;\n        if (idx >= 0 && idx < getItems().size()) {\n            item = getItems().get(idx);\n        }\n        return item;\n    }\n"]]}
{"hexsha": "13ff8592e8c99706938dc8f4175004a0e584dad8", "ext": "java", "lang": "Java", "content": "@Controller\npublic class IndexEditController\n\t{\n\t/**\n\t * Helper class used as form backing object\n\t */\n\tpublic static final class FormBackingObject\n\t\t{\n\t\tprivate String catalog;\n\t\tprivate String schema;\n\t\tprivate String object;\n\t\tprivate String name;\n\t\tprivate boolean unique;\n\t\tprivate final Map<Integer, String> columns;\n\t\t\n\t\t/**\n\t\t * Constructor\n\t\t */\n\t\tpublic FormBackingObject()\n\t\t\t{\n\t\t\tthis.columns = new TreeMap<Integer, String>();\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * Get the column names\n\t\t * @return column names\n\t\t */\n\t\tpublic List<String> getColumnNames()\n\t\t\t{\n\t\t\tfinal List<String> ret = new ArrayList<String>(columns.size());\n\t\t\t\n\t\t\tfor (int i = 0; ; i++)\n\t\t\t\t{\n\t\t\t\tfinal String s = columns.get(i);\n\t\t\t\tif (StringUtils.empty(s))\n\t\t\t\t\tbreak;\n\t\t\t\tret.add(s);\n\t\t\t\t}\n\t\t\t\n\t\t\treturn (ret);\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the catalog\n\t\t */\n\t\tpublic String getCatalog()\n\t\t\t{\n\t\t\treturn catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param catalog the catalog to set\n\t\t */\n\t\tpublic void setCatalog(String catalog)\n\t\t\t{\n\t\t\tthis.catalog = catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the schema\n\t\t */\n\t\tpublic String getSchema()\n\t\t\t{\n\t\t\treturn schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param schema the schema to set\n\t\t */\n\t\tpublic void setSchema(String schema)\n\t\t\t{\n\t\t\tthis.schema = schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the object\n\t\t */\n\t\tpublic String getObject()\n\t\t\t{\n\t\t\treturn object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param object the object to set\n\t\t */\n\t\tpublic void setObject(String object)\n\t\t\t{\n\t\t\tthis.object = object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the name\n\t\t */\n\t\tpublic String getName()\n\t\t\t{\n\t\t\treturn name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param name the name to set\n\t\t */\n\t\tpublic void setName(String name)\n\t\t\t{\n\t\t\tthis.name = name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the unique\n\t\t */\n\t\tpublic boolean isUnique()\n\t\t\t{\n\t\t\treturn unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param unique the unique to set\n\t\t */\n\t\tpublic void setUnique(boolean unique)\n\t\t\t{\n\t\t\tthis.unique = unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the columns\n\t\t */\n\t\tpublic Map<Integer, String> getColumns()\n\t\t\t{\n\t\t\treturn columns;\n\t\t\t}\n\t\t}\n\t\n\tprivate final MetadataService metadataService;\n\tprivate final QuerySettingsManager querySettingsManager;\n\tprivate final QueryPerformerService runner;\n\tprivate final QueryGeneratorService queryGeneratorService;\n\tprivate final ConnectionSettings connectionSettings;\n\tprivate final FrontendHelperService frontendHelperService;\n\t\n\t/**\n\t * Constructor\n\t * @param metadataService MetadataService\n\t * @param querySettingsManager QuerySettingsManager\n\t * @param runner QueryPerformerService\n\t * @param queryGeneratorService QueryGeneratorService\n\t * @param connectionSettings ConnectionSettings\n\t * @param frontendHelperService FrontendHelperService\n\t */\n\t@Autowired\n\tpublic IndexEditController(MetadataService metadataService,\n\t\t\tQuerySettingsManager querySettingsManager, QueryPerformerService runner,\n\t\t\tQueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings,\n\t\t\tFrontendHelperService frontendHelperService)\n\t\t{\n\t\tthis.metadataService = metadataService;\n\t\tthis.querySettingsManager = querySettingsManager;\n\t\tthis.runner = runner;\n\t\tthis.queryGeneratorService = queryGeneratorService;\n\t\tthis.connectionSettings = connectionSettings;\n\t\tthis.frontendHelperService = frontendHelperService;\n\t\t}\n\t\n\t/**\n\t * Get the FormBackingObject\n\t * @param obj DB object name\n\t * @return FormBackingObject\n\t */\n\t@ModelAttribute(\"model\")\n\tpublic FormBackingObject getFormBackingObject(@RequestParam(value = \"q\", required = false) String obj)\n\t\t{\n\t\tfinal FormBackingObject fbo = new FormBackingObject();\n\t\t// Hack to recognize object name in \"q\" as well as \"object\" parameter\n\t\tfbo.setObject(obj);\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tfbo.getColumns().put(i, \"\");\n\t\treturn (fbo);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfbo.setUnique(id.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : id.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfbo.setUnique(pk.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : pk.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\tprivate SQLDialect getSQLDialect()\n\t\t{\n\t\treturn (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));\n\t\t}\n\t}", "class_id": 0, "repo": "tweerlei/dbgrazer", "file": "web/plugins/jdbc-web/src/main/java/de/tweerlei/dbgrazer/web/controller/jdbc/IndexEditController.java", "last_update_at": "2021-09-26T03:05:18+00:00", "question_id": "13ff8592e8c99706938dc8f4175004a0e584dad8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\npublic class IndexEditController\n\t{\n\t/**\n\t * Helper class used as form backing object\n\t */\n\tpublic static final class FormBackingObject\n\t\t{\n\t\tprivate String catalog;\n\t\tprivate String schema;\n\t\tprivate String object;\n\t\tprivate String name;\n\t\tprivate boolean unique;\n\t\tprivate final Map<Integer, String> columns;\n\t\t\n\t\t/**\n\t\t * Constructor\n\t\t */\n\t\tpublic FormBackingObject()\n\t\t\t{\n\t\t\tthis.columns = new TreeMap<Integer, String>();\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * Get the column names\n\t\t * @return column names\n\t\t */\n\t\tpublic List<String> getColumnNames()\n\t\t\t{\n\t\t\tfinal List<String> ret = new ArrayList<String>(columns.size());\n\t\t\t\n\t\t\tfor (int i = 0; ; i++)\n\t\t\t\t{\n\t\t\t\tfinal String s = columns.get(i);\n\t\t\t\tif (StringUtils.empty(s))\n\t\t\t\t\tbreak;\n\t\t\t\tret.add(s);\n\t\t\t\t}\n\t\t\t\n\t\t\treturn (ret);\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the catalog\n\t\t */\n\t\tpublic String getCatalog()\n\t\t\t{\n\t\t\treturn catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param catalog the catalog to set\n\t\t */\n\t\tpublic void setCatalog(String catalog)\n\t\t\t{\n\t\t\tthis.catalog = catalog;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the schema\n\t\t */\n\t\tpublic String getSchema()\n\t\t\t{\n\t\t\treturn schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param schema the schema to set\n\t\t */\n\t\tpublic void setSchema(String schema)\n\t\t\t{\n\t\t\tthis.schema = schema;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the object\n\t\t */\n\t\tpublic String getObject()\n\t\t\t{\n\t\t\treturn object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param object the object to set\n\t\t */\n\t\tpublic void setObject(String object)\n\t\t\t{\n\t\t\tthis.object = object;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the name\n\t\t */\n\t\tpublic String getName()\n\t\t\t{\n\t\t\treturn name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param name the name to set\n\t\t */\n\t\tpublic void setName(String name)\n\t\t\t{\n\t\t\tthis.name = name;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the unique\n\t\t */\n\t\tpublic boolean isUnique()\n\t\t\t{\n\t\t\treturn unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @param unique the unique to set\n\t\t */\n\t\tpublic void setUnique(boolean unique)\n\t\t\t{\n\t\t\tthis.unique = unique;\n\t\t\t}\n\t\t\n\t\t/**\n\t\t * @return the columns\n\t\t */\n\t\tpublic Map<Integer, String> getColumns()\n\t\t\t{\n\t\t\treturn columns;\n\t\t\t}\n\t\t}\n\t\n\tprivate final MetadataService metadataService;\n\tprivate final QuerySettingsManager querySettingsManager;\n\tprivate final QueryPerformerService runner;\n\tprivate final QueryGeneratorService queryGeneratorService;\n\tprivate final ConnectionSettings connectionSettings;\n\tprivate final FrontendHelperService frontendHelperService;\n\t\n\t/**\n\t * Constructor\n\t * @param metadataService MetadataService\n\t * @param querySettingsManager QuerySettingsManager\n\t * @param runner QueryPerformerService\n\t * @param queryGeneratorService QueryGeneratorService\n\t * @param connectionSettings ConnectionSettings\n\t * @param frontendHelperService FrontendHelperService\n\t */\n\t@Autowired\n\tpublic IndexEditController(MetadataService metadataService,\n\t\t\tQuerySettingsManager querySettingsManager, QueryPerformerService runner,\n\t\t\tQueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings,\n\t\t\tFrontendHelperService frontendHelperService)\n\t\t{\n\t\tthis.metadataService = metadataService;\n\t\tthis.querySettingsManager = querySettingsManager;\n\t\tthis.runner = runner;\n\t\tthis.queryGeneratorService = queryGeneratorService;\n\t\tthis.connectionSettings = connectionSettings;\n\t\tthis.frontendHelperService = frontendHelperService;\n\t\t}\n\t\n\t/**\n\t * Get the FormBackingObject\n\t * @param obj DB object name\n\t * @return FormBackingObject\n\t */\n\t@ModelAttribute(\"model\")\n\tpublic FormBackingObject getFormBackingObject(@RequestParam(value = \"q\", required = false) String obj)\n\t\t{\n\t\tfinal FormBackingObject fbo = new FormBackingObject();\n\t\t// Hack to recognize object name in \"q\" as well as \"object\" parameter\n\t\tfbo.setObject(obj);\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tfbo.getColumns().put(i, \"\");\n\t\treturn (fbo);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-index.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfbo.setUnique(id.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : id.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-index.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal IndexDescription id = info.getIndex(fbo.getName());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-add-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tmodel.put(\"columns\", info.getColumns());\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-add-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\t\n\t\tfinal PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());\n\t\t\n\t\tfinal Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ajax/ddl-drop-primarykey.html\", method = RequestMethod.GET)\n\tpublic Map<String, Object> showPKDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfbo.setUnique(pk.isUnique());\n\t\tint i = 0;\n\t\tfor (String c : pk.getColumns())\n\t\t\tfbo.getColumns().put(i++, c);\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\t/**\n\t * Show a parameter input form\n\t * @param fbo FormBackingObject\n\t * @return Model\n\t */\n\t@RequestMapping(value = \"/db/*/ddl-drop-primarykey.html\", method = RequestMethod.POST)\n\tpublic Map<String, Object> performPKDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo)\n\t\t{\n\t\tif (!connectionSettings.isBrowserEnabled())\n\t\t\tthrow new AccessDeniedException();\n\t\tif (!connectionSettings.isWritable())\n\t\t\tthrow new AccessDeniedException();\n\t\t\n\t\tfinal Map<String, Object> model = new HashMap<String, Object>();\n\t\t\n\t\tfinal QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n\t\tfinal TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n\t\tfinal PrimaryKeyDescription pk = info.getPrimaryKey();\n\t\t\n\t\tfinal Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);\n\t\tfinal QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n\t\t\n\t\ttry\t{\n\t\t\tfinal Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n\t\t\tmetadataService.flushCache(connectionSettings.getLinkName());\n\t\t\tmodel.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n\t\t\tmodel.put(\"exceptionText\", null);\n\t\t\t}\n\t\tcatch (PerformQueryException e)\n\t\t\t{\n\t\t\tmodel.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n\t\t\t}\n\t\t\n\t\treturn (model);\n\t\t}\n\t\n\tprivate SQLDialect getSQLDialect()\n\t\t{\n\t\treturn (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));\n\t\t}\n"]]}
{"hexsha": "3e73974b19bd63eef0024f08c1d9d9f3549ef0b5", "ext": "java", "lang": "Java", "content": "public class RestClientLoadBalancerTest {\n\n  public static ResourceBundle messageBundle = ResourceBundle.getBundle(\"Messages\");\n  public static MessageUtils messageUtils = new MessageUtils(messageBundle);\n  public static HttpClient httpClient = HttpClient.newHttpClient();\n  public static MockWebServer mockServer;\n\n  @BeforeEach\n  void setUp() throws IOException {\n    mockServer = new MockWebServer();\n    mockServer.start();\n  }\n\n  @Test\n  public void happyMakeRequest() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    Integer statusCode = 200;\n    String body = \"someBody\";\n    mockServer.enqueue(new MockResponse()\n        .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n        .setBody(body)\n        .setResponseCode(statusCode));\n\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(body));\n  }\n\n  @Test\n  public void happyMakeRequestAfterRetries() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    Integer statusCode = 400;\n    String body = \"badBody\";\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n\n    statusCode = 200;\n    body = \"goodBody\";\n\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(\"goodBody0\"));\n\n    System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());\n  }\n\n  @Test\n  public void failedMakeRequestNoValidServer() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    String urlServer1 = \"https://incorrectServer1:100\";\n    String urlServer2 = \"https://incorrectServer2:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n\n  @Test\n  public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n\n    Integer statusCode = 400;\n    String body = \"someBody\";\n\n    // put at least as many requests into the queue as the retry limit\n    for (int i = 0; i < 10; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n\n  @AfterEach\n  void tearDown() throws Exception {\n    mockServer.shutdown();\n  }\n}", "class_id": 0, "repo": "IBM/uni-resolver-driver-did-hpass", "file": "src/test/java/uniresolver/driver/did/hpass/utils/RestClientLoadBalancerTest.java", "last_update_at": "2021-12-13T15:56:55+00:00", "question_id": "3e73974b19bd63eef0024f08c1d9d9f3549ef0b5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RestClientLoadBalancerTest {\n  public static ResourceBundle messageBundle = ResourceBundle.getBundle(\"Messages\");\n  public static MessageUtils messageUtils = new MessageUtils(messageBundle);\n  public static HttpClient httpClient = HttpClient.newHttpClient();\n  public static MockWebServer mockServer;\n  @BeforeEach\n  void setUp() throws IOException {\n    mockServer = new MockWebServer();\n    mockServer.start();\n  }\n  @Test\n  public void happyMakeRequest() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    Integer statusCode = 200;\n    String body = \"someBody\";\n    mockServer.enqueue(new MockResponse()\n        .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n        .setBody(body)\n        .setResponseCode(statusCode));\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(body));\n  }\n  @Test\n  public void happyMakeRequestAfterRetries() throws Exception {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    Integer statusCode = 400;\n    String body = \"badBody\";\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n    statusCode = 200;\n    body = \"goodBody\";\n    for (int i = 0; i < 5; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    Integer actual = httpResponse.statusCode();\n    Integer expected = statusCode;\n    assertTrue(actual.equals(expected));\n    assertTrue(httpResponse.body().equals(\"goodBody0\"));\n    System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());\n  }\n  @Test\n  public void failedMakeRequestNoValidServer() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    String urlServer1 = \"https://incorrectServer1:100\";\n    String urlServer2 = \"https://incorrectServer2:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n  @Test\n  public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {\n    Boolean staticServerList = true;\n    ArrayList<Server> networkServerList = new ArrayList<>();\n    Integer statusCode = 400;\n    String body = \"someBody\";\n    // put at least as many requests into the queue as the retry limit\n    for (int i = 0; i < 10; i++) {\n      mockServer.enqueue(new MockResponse()\n          .addHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n          .setBody(body + i)\n          .setResponseCode(statusCode));\n    }\n    String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n    String urlServer2 = \"https://incorrectServer:200\";\n    networkServerList.add(new Server(urlServer1, 1));\n    networkServerList.add(new Server(urlServer2, 2));\n    ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n    RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n    HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n    String networkID = \"identifier1\";\n    String parameters = \"?network_id=\" + networkID;\n    ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n      HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n    });\n    assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n  }\n  @AfterEach\n  void tearDown() throws Exception {\n    mockServer.shutdown();\n  }\n"]]}
{"hexsha": "720da52387d7399deb3c25aef1d5a296b400d45c", "ext": "java", "lang": "Java", "content": "public class BulkOperation extends ExtensibleObject {\n\n    /**\n     *  Status ACTIVE: when bulk operation is created.\n     */\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n\n    /**\n     *  Status IN_PROGRESS: when bulk operation is performing on all devices.\n     */\n    public static final String STATUS_IN_PROGRESS = \"IN_PROGRESS\";\n\n    /**\n     * Status COMPLETED: when the operation was performed on all devices.\n     */\n    public static final String STATUS_COMPLETED = \"COMPLETED\";\n\n    /**\n     * Status DELETED: when already created operation was cancelled by deleting the bulk operation\n     */\n    public static final String STATUS_DELETED = \"DELETED\";\n\n    /**\n     * Constructor to create a bulk operation.\n     */\n    public BulkOperation() {\n        super();\n    }\n\n    /**\n     * Internal constructor to create a bulk operation object.\n     *\n     * @param extensibleObject existing base class object.\n     */\n    BulkOperation(ExtensibleObject extensibleObject) {\n        super(extensibleObject);\n    }\n\n\n    /**\n     * Set the unique identifier of the bulk operation.\n     * Just used internally.\n     *\n     * @param id the new identifier created by storing the entity.\n     */\n    void setId(String id) {\n        anyObject.put(\"id\", id);\n    }\n\n    /**\n     * Get the unique identifier for the bulk operation.\n     *\n     * @return String with the unique identifier of the bulk operation or null if not\n     * available.\n     */\n    public String getId() {\n        Object id = anyObject.get(\"id\");\n        if (id == null) {\n            return null;\n        }\n        return id.toString();\n    }\n\n    /**\n     * Set the groupId of the target group on which the bulk operation should be performed.\n     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'\n     *\n     * @param groupId the unique identifier of the target group.\n     */\n    public void setGroupId(String groupId) {\n        anyObject.put(\"groupId\", groupId);\n    }\n\n    /**\n     * Get the groupId of the target group of the bulk operation.\n     *\n     * @return String with the unique identifier of the target group or null if not\n     * available.\n     */\n    public String getGroupId() {\n        return (String) anyObject.get(\"groupId\");\n    }\n\n    /**\n     * Set the bulk operation id to reschedule this operation on devices where it failed.\n     *\n     * @param failedBulkOperationId the unique identifier of the bulk operation.\n     */\n    public void setFailedBulkOperationId(String failedBulkOperationId) {\n        anyObject.put(\"failedBulkOperationId\", failedBulkOperationId);\n    }\n\n    /**\n     * Get the bulk operation id from which failed operation should be rescheduled.\n     *\n     * @return String with the unique identifier of the failed bulk operation id\n     * or null if not available.\n     */\n    public String getFailedBulkOperationId() {\n        return (String) anyObject.get(\"failedBulkOperationId\");\n    }\n\n    /**\n     * Get the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @return a String with the status\n     */\n    public String getStatus() {\n        return (String) anyObject.get(\"status\");\n    }\n\n    /**\n     * Set the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @param status String which represents the status of the bulk operation.\n     */\n    public void setStatus(String status) {\n        anyObject.put(\"status\", status);\n    }\n\n    /**\n     * Set the ramp up time, specifying the delay between every operation.\n     *\n     * @param creationRamp number in seconds.\n     */\n    public void setCreationRamp(Number creationRamp) {\n        anyObject.put(\"creationRamp\", creationRamp);\n    }\n\n    /**\n     * Get the ramp up time, specifying the delay between every operation.\n     *\n     * @return the number in seconds.\n     */\n    public Number getCreationRamp() {\n        return (Number) anyObject.get(\"creationRamp\");\n    }\n\n    /**\n     * Get the time when operation should be started.\n     *\n     * @return Date object representing the timestamp when bulk operation should be performed.\n     */\n    public Date getStartDate() {\n        return (Date) anyObject.get(\"startDate\");\n    }\n\n    /**\n     * Set the schedule time.\n     *\n     * @param startDate Date object with the time when bulk operation should be performed.\n     */\n    public void setStartDate(Date startDate) {\n        anyObject.put(\"startDate\", startDate);\n    }\n\n    /**\n     * Get the operation which will be executed for every device in the target group.\n     *\n     * @return Operation object representing the operation which will be executed for every device in the target group.\n     */\n    public Operation getOperation() {\n        Object operationPrototype = anyObject.get(\"operationPrototype\");\n        // since source value can be set as Operation Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Operation Object\n        if(operationPrototype instanceof Operation) {\n            return (Operation)operationPrototype;\n        }\n        return new Operation((ExtensibleObject) operationPrototype);\n    }\n\n    /**\n     * Set the operation which should be executed for every device in the target group.\n     *\n     * @param operation Operation object representing the operation which need to be executed for every device in the target group.\n     */\n    public void setOperation(Operation operation) {\n        anyObject.put(\"operationPrototype\", operation);\n    }\n\n    /**\n     * Get the progress of the bulk operation.\n     *\n     * @return Progress object containing the number of processed bulk operations.\n     */\n    public Progress getProgress() {\n        Object progress = anyObject.get(\"progress\");\n        // since source value can be set as Progress Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Progress Object\n        if(progress instanceof Progress) {\n            return (Progress)progress;\n        }\n        return new Progress((ExtensibleObject) progress);\n    }\n\n    /**\n     * Set the progress of the bulk operation.\n     *\n     * @param progress Progress object containing the number of processed bulk operations.\n     */\n    public void setProgress(Progress progress) {\n        anyObject.put(\"progress\", progress);\n    }\n\n}", "class_id": 0, "repo": "Matthimatiker/cot-java-rest-sdk", "file": "src/main/java/com/telekom/m2m/cot/restsdk/devicecontrol/BulkOperation.java", "last_update_at": "2021-04-30T23:56:52+00:00", "question_id": "720da52387d7399deb3c25aef1d5a296b400d45c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BulkOperation extends ExtensibleObject {\n    /**\n     *  Status ACTIVE: when bulk operation is created.\n     */\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n    /**\n     *  Status IN_PROGRESS: when bulk operation is performing on all devices.\n     */\n    public static final String STATUS_IN_PROGRESS = \"IN_PROGRESS\";\n    /**\n     * Status COMPLETED: when the operation was performed on all devices.\n     */\n    public static final String STATUS_COMPLETED = \"COMPLETED\";\n    /**\n     * Status DELETED: when already created operation was cancelled by deleting the bulk operation\n     */\n    public static final String STATUS_DELETED = \"DELETED\";\n    /**\n     * Constructor to create a bulk operation.\n     */\n    public BulkOperation() {\n        super();\n    }\n    /**\n     * Internal constructor to create a bulk operation object.\n     *\n     * @param extensibleObject existing base class object.\n     */\n    BulkOperation(ExtensibleObject extensibleObject) {\n        super(extensibleObject);\n    }\n    /**\n     * Set the unique identifier of the bulk operation.\n     * Just used internally.\n     *\n     * @param id the new identifier created by storing the entity.\n     */\n    void setId(String id) {\n        anyObject.put(\"id\", id);\n    }\n    /**\n     * Get the unique identifier for the bulk operation.\n     *\n     * @return String with the unique identifier of the bulk operation or null if not\n     * available.\n     */\n    public String getId() {\n        Object id = anyObject.get(\"id\");\n        if (id == null) {\n            return null;\n        }\n        return id.toString();\n    }\n    /**\n     * Set the groupId of the target group on which the bulk operation should be performed.\n     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'\n     *\n     * @param groupId the unique identifier of the target group.\n     */\n    public void setGroupId(String groupId) {\n        anyObject.put(\"groupId\", groupId);\n    }\n    /**\n     * Get the groupId of the target group of the bulk operation.\n     *\n     * @return String with the unique identifier of the target group or null if not\n     * available.\n     */\n    public String getGroupId() {\n        return (String) anyObject.get(\"groupId\");\n    }\n    /**\n     * Set the bulk operation id to reschedule this operation on devices where it failed.\n     *\n     * @param failedBulkOperationId the unique identifier of the bulk operation.\n     */\n    public void setFailedBulkOperationId(String failedBulkOperationId) {\n        anyObject.put(\"failedBulkOperationId\", failedBulkOperationId);\n    }\n    /**\n     * Get the bulk operation id from which failed operation should be rescheduled.\n     *\n     * @return String with the unique identifier of the failed bulk operation id\n     * or null if not available.\n     */\n    public String getFailedBulkOperationId() {\n        return (String) anyObject.get(\"failedBulkOperationId\");\n    }\n    /**\n     * Get the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @return a String with the status\n     */\n    public String getStatus() {\n        return (String) anyObject.get(\"status\");\n    }\n    /**\n     * Set the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @param status String which represents the status of the bulk operation.\n     */\n    public void setStatus(String status) {\n        anyObject.put(\"status\", status);\n    }\n    /**\n     * Set the ramp up time, specifying the delay between every operation.\n     *\n     * @param creationRamp number in seconds.\n     */\n    public void setCreationRamp(Number creationRamp) {\n        anyObject.put(\"creationRamp\", creationRamp);\n    }\n    /**\n     * Get the ramp up time, specifying the delay between every operation.\n     *\n     * @return the number in seconds.\n     */\n    public Number getCreationRamp() {\n        return (Number) anyObject.get(\"creationRamp\");\n    }\n    /**\n     * Get the time when operation should be started.\n     *\n     * @return Date object representing the timestamp when bulk operation should be performed.\n     */\n    public Date getStartDate() {\n        return (Date) anyObject.get(\"startDate\");\n    }\n    /**\n     * Set the schedule time.\n     *\n     * @param startDate Date object with the time when bulk operation should be performed.\n     */\n    public void setStartDate(Date startDate) {\n        anyObject.put(\"startDate\", startDate);\n    }\n    /**\n     * Get the operation which will be executed for every device in the target group.\n     *\n     * @return Operation object representing the operation which will be executed for every device in the target group.\n     */\n    public Operation getOperation() {\n        Object operationPrototype = anyObject.get(\"operationPrototype\");\n        // since source value can be set as Operation Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Operation Object\n        if(operationPrototype instanceof Operation) {\n            return (Operation)operationPrototype;\n        }\n        return new Operation((ExtensibleObject) operationPrototype);\n    }\n    /**\n     * Set the operation which should be executed for every device in the target group.\n     *\n     * @param operation Operation object representing the operation which need to be executed for every device in the target group.\n     */\n    public void setOperation(Operation operation) {\n        anyObject.put(\"operationPrototype\", operation);\n    }\n    /**\n     * Get the progress of the bulk operation.\n     *\n     * @return Progress object containing the number of processed bulk operations.\n     */\n    public Progress getProgress() {\n        Object progress = anyObject.get(\"progress\");\n        // since source value can be set as Progress Object via setter in regular way\n        // and as ExtensibleObject via gson ExtensibleObjectSerializer.\n        // At first we need to check the type to avoid an unnecessary wrap into Progress Object\n        if(progress instanceof Progress) {\n            return (Progress)progress;\n        }\n        return new Progress((ExtensibleObject) progress);\n    }\n    /**\n     * Set the progress of the bulk operation.\n     *\n     * @param progress Progress object containing the number of processed bulk operations.\n     */\n    public void setProgress(Progress progress) {\n        anyObject.put(\"progress\", progress);\n    }\n"]]}
{"hexsha": "04baabdf7c25ae7771d5baa86ba14663503d9f40", "ext": "java", "lang": "Java", "content": "@ConstantFieldsFirstExcept({}) @ConstantFieldsSecondExcept({})\npublic class StratosphereSqlCrossOperator extends CrossFunction {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate Filter filter;\n\tpublic StratosphereSqlCrossOperator(Filter f) {\n\t\tthis.filter = f;\n\t}\n\n\t@Override\n\tpublic void open(Configuration parameters) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.open(parameters);\n\t\tfilter.prepareEvaluation();\n\t}\n\t@Override\n\tpublic void cross(Record record1, Record record2, Collector<Record> out)\n\t\t\tthrows Exception {\n\t\tif(filter.evaluateTwo(record1, record2)) {\n\t\t\tSystem.err.println(\"Cross got rec1=\"+record1+\" rec2=\"+record2);\n\t\t\trecord1.concatenate(record2);\n\t\t\tSystem.err.println(\"Cross is outputting \"+record1);\n\t\t\tout.collect(record1);\n\t\t\t\n\t\t}\n\t}\n\t\n}", "class_id": 0, "repo": "rmetzger/stratosphere-sql", "file": "src/main/java/eu/stratosphere/sql/relOpt/join/StratosphereSqlCrossOperator.java", "last_update_at": "2021-09-08T11:01:56+00:00", "question_id": "04baabdf7c25ae7771d5baa86ba14663503d9f40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ConstantFieldsFirstExcept({}) @ConstantFieldsSecondExcept({})\npublic class StratosphereSqlCrossOperator extends CrossFunction {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate Filter filter;\n\tpublic StratosphereSqlCrossOperator(Filter f) {\n\t\tthis.filter = f;\n\t}\n\t@Override\n\tpublic void open(Configuration parameters) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.open(parameters);\n\t\tfilter.prepareEvaluation();\n\t}\n\t@Override\n\tpublic void cross(Record record1, Record record2, Collector<Record> out)\n\t\t\tthrows Exception {\n\t\tif(filter.evaluateTwo(record1, record2)) {\n\t\t\tSystem.err.println(\"Cross got rec1=\"+record1+\" rec2=\"+record2);\n\t\t\trecord1.concatenate(record2);\n\t\t\tSystem.err.println(\"Cross is outputting \"+record1);\n\t\t\tout.collect(record1);\n\t\t\t\n\t\t}\n\t}\n\t\n"]]}
{"hexsha": "f72f58de555633dae38ae5ca07680378374dc88b", "ext": "java", "lang": "Java", "content": "public class StickyKey {\n\tpublic static final StickyKey DEFAULT = new StickyKey(0, 0);\n\n\tpublic final long clusterId;\n\tpublic final long stickyId;\n\n\tprivate StickyKey(final long clusterId, final long stickyId) {\n\t\tthis.clusterId = (clusterId <= 0 ? 0 : clusterId);\n\t\tthis.stickyId = (stickyId <= 0 ? 0 : stickyId);\n\t}\n\n\tpublic static StickyKey valueOf(final String clusterName, final String stickyName) {\n\t\tfinal long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));\n\t\tfinal long stickyId = IOHelper.longIdFromString(stickyName);\n\t\tif (clusterName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped clusterName=\" + clusterName + \" clusterId=\" + clusterId);\n\t\t}\n\t\tif (stickyName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped stickyName=\" + stickyName + \" stickyId=\" + stickyId);\n\t\t}\n\t\treturn valueOf(clusterId, stickyId);\n\t}\n\n\tpublic static StickyKey valueOf(final long clusterId, final long stickyId) {\n\t\treturn new StickyKey(clusterId, stickyId);\n\t}\n\n\t@Override\n\tpublic boolean equals(final Object obj) {\n\t\tif (obj instanceof StickyKey) {\n\t\t\tfinal StickyKey o = (StickyKey) obj;\n\t\t\treturn ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString() + \"[clusterId=\" + clusterId + \" stickyId=\" + stickyId + \"]\";\n\t}\n}", "class_id": 0, "repo": "ggrandes/jrinetd", "file": "src/main/java/org/javastack/jrinetd/StickyKey.java", "last_update_at": "2021-11-10T10:37:44+00:00", "question_id": "f72f58de555633dae38ae5ca07680378374dc88b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StickyKey {\n\tpublic static final StickyKey DEFAULT = new StickyKey(0, 0);\n\tpublic final long clusterId;\n\tpublic final long stickyId;\n\tprivate StickyKey(final long clusterId, final long stickyId) {\n\t\tthis.clusterId = (clusterId <= 0 ? 0 : clusterId);\n\t\tthis.stickyId = (stickyId <= 0 ? 0 : stickyId);\n\t}\n\tpublic static StickyKey valueOf(final String clusterName, final String stickyName) {\n\t\tfinal long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));\n\t\tfinal long stickyId = IOHelper.longIdFromString(stickyName);\n\t\tif (clusterName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped clusterName=\" + clusterName + \" clusterId=\" + clusterId);\n\t\t}\n\t\tif (stickyName != null) {\n\t\t\tLog.info(StickyKey.class.getSimpleName(), \"Mapped stickyName=\" + stickyName + \" stickyId=\" + stickyId);\n\t\t}\n\t\treturn valueOf(clusterId, stickyId);\n\t}\n\tpublic static StickyKey valueOf(final long clusterId, final long stickyId) {\n\t\treturn new StickyKey(clusterId, stickyId);\n\t}\n\t@Override\n\tpublic boolean equals(final Object obj) {\n\t\tif (obj instanceof StickyKey) {\n\t\t\tfinal StickyKey o = (StickyKey) obj;\n\t\t\treturn ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString() + \"[clusterId=\" + clusterId + \" stickyId=\" + stickyId + \"]\";\n\t}\n"]]}
{"hexsha": "2e39263ceb6cb884efccdb282a6247b85892ec0e", "ext": "java", "lang": "Java", "content": "public class ConfigTest {\n    Connection conn;\n    Session session;\n\n    public static final String uri = \"table:test_config06\";\n    public static final String key = \"keyABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    public static final String value = \"valueABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    public void session_config(String config) {\n        Exception e = null;\n\n        try {\n            session.create(uri, config);\n        }\n        catch (WiredTigerException wte) {\n            e = wte;\n        }\n\n        Assert.assertTrue(e != null &&\n                          e.toString().indexOf(\"Invalid argument\") >= 0);\n    }\n\n    // Edge cases for key/value formats.\n    @Test\n    public void test_session_config()\n    throws WiredTigerException {\n        setup();\n        System.err.println(\"\\n-- expect error output --\");\n        session_config(\"key_format=A,value_format=S\");\n        session_config(\"key_format=S,value_format=A\");\n        session_config(\"key_format=0s,value_format=s\");\n        session_config(\"key_format=s,value_format=0s\");\n        session_config(\"key_format=0t,value_format=4t\");\n        session_config(\"key_format=4t,value_format=0t\");\n        System.err.println(\"-- end expected error output --\");\n        teardown();\n    }\n\n    // Smoke-test the string formats with length specifiers; both formats should\n    // ignore trailing bytes, verify that.\n    public void format_string(String fmt, int len)\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=\" + len + fmt +\n                            \",value_format=\" + len + fmt);\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,len));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,len), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_S_1()\n    throws WiredTigerException {\n        format_string(\"S\", 1);\n    }\n    @Test\n    public void test_format_string_S_4()\n    throws WiredTigerException {\n        format_string(\"S\", 4);\n    }\n    @Test\n    public void test_format_string_S_10()\n    throws WiredTigerException {\n        format_string(\"S\", 10);\n    }\n    @Test\n    public void test_format_string_s_1()\n    throws WiredTigerException {\n        format_string(\"s\", 1);\n    }\n    @Test\n    public void test_format_string_s_4()\n    throws WiredTigerException {\n        format_string(\"s\", 4);\n    }\n    @Test\n    public void test_format_string_s_10()\n    throws WiredTigerException {\n        format_string(\"s\", 10);\n    }\n\n    @Test\n    public void test_format_string_S_default()\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=S,value_format=S\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key);\n        assertEquals(0, cursor.search());\n        assertEquals(value, cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_s_default()\n        throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=s,value_format=s\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,1));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,1), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    public static void main(String[] args) {\n        ConfigTest tester = new ConfigTest();\n        try {\n            tester.test_session_config();\n            tester.test_format_string_S_1();\n            tester.test_format_string_S_4();\n            tester.test_format_string_S_10();\n            tester.test_format_string_s_1();\n            tester.test_format_string_s_4();\n            tester.test_format_string_s_10();\n            tester.test_format_string_S_default();\n            tester.test_format_string_s_default();\n        } catch (WiredTigerException wte) {\n            System.err.println(\"WiredTigerException: \" + wte);\n        }\n    }\n\n    private void setup() {\n        conn = wiredtiger.open(\"WT_HOME\", \"create\");\n        session = conn.open_session(null);\n    }\n\n    private void teardown() {\n        session.close(\"\");\n        conn.close(\"\");\n    }\n\n}", "class_id": 0, "repo": "danx0r/mongo", "file": "src/third_party/wiredtiger/test/java/com/wiredtiger/test/ConfigTest.java", "last_update_at": "2021-03-22T03:15:56+00:00", "question_id": "2e39263ceb6cb884efccdb282a6247b85892ec0e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConfigTest {\n    Connection conn;\n    Session session;\n    public static final String uri = \"table:test_config06\";\n    public static final String key = \"keyABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    public static final String value = \"valueABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    public void session_config(String config) {\n        Exception e = null;\n        try {\n            session.create(uri, config);\n        }\n        catch (WiredTigerException wte) {\n            e = wte;\n        }\n        Assert.assertTrue(e != null &&\n                          e.toString().indexOf(\"Invalid argument\") >= 0);\n    }\n    // Edge cases for key/value formats.\n    @Test\n    public void test_session_config()\n    throws WiredTigerException {\n        setup();\n        System.err.println(\"\\n-- expect error output --\");\n        session_config(\"key_format=A,value_format=S\");\n        session_config(\"key_format=S,value_format=A\");\n        session_config(\"key_format=0s,value_format=s\");\n        session_config(\"key_format=s,value_format=0s\");\n        session_config(\"key_format=0t,value_format=4t\");\n        session_config(\"key_format=4t,value_format=0t\");\n        System.err.println(\"-- end expected error output --\");\n        teardown();\n    }\n    // Smoke-test the string formats with length specifiers; both formats should\n    // ignore trailing bytes, verify that.\n    public void format_string(String fmt, int len)\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=\" + len + fmt +\n                            \",value_format=\" + len + fmt);\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,len));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,len), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n    @Test\n    public void test_format_string_S_1()\n    throws WiredTigerException {\n        format_string(\"S\", 1);\n    }\n    @Test\n    public void test_format_string_S_4()\n    throws WiredTigerException {\n        format_string(\"S\", 4);\n    }\n    @Test\n    public void test_format_string_S_10()\n    throws WiredTigerException {\n        format_string(\"S\", 10);\n    }\n    @Test\n    public void test_format_string_s_1()\n    throws WiredTigerException {\n        format_string(\"s\", 1);\n    }\n    @Test\n    public void test_format_string_s_4()\n    throws WiredTigerException {\n        format_string(\"s\", 4);\n    }\n    @Test\n    public void test_format_string_s_10()\n    throws WiredTigerException {\n        format_string(\"s\", 10);\n    }\n    @Test\n    public void test_format_string_S_default()\n    throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=S,value_format=S\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key);\n        assertEquals(0, cursor.search());\n        assertEquals(value, cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n    @Test\n    public void test_format_string_s_default()\n        throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=s,value_format=s\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0,1));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0,1), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n    public static void main(String[] args) {\n        ConfigTest tester = new ConfigTest();\n        try {\n            tester.test_session_config();\n            tester.test_format_string_S_1();\n            tester.test_format_string_S_4();\n            tester.test_format_string_S_10();\n            tester.test_format_string_s_1();\n            tester.test_format_string_s_4();\n            tester.test_format_string_s_10();\n            tester.test_format_string_S_default();\n            tester.test_format_string_s_default();\n        } catch (WiredTigerException wte) {\n            System.err.println(\"WiredTigerException: \" + wte);\n        }\n    }\n    private void setup() {\n        conn = wiredtiger.open(\"WT_HOME\", \"create\");\n        session = conn.open_session(null);\n    }\n    private void teardown() {\n        session.close(\"\");\n        conn.close(\"\");\n    }\n"]]}
{"hexsha": "0e0da15f7cbb858c23517f700b77e09fcb2e8e1f", "ext": "java", "lang": "Java", "content": "@WebServlet(name = \"smarthomeUpdate\", urlPatterns = \"/smarthome/update\")\npublic class SmartHomeUpdateServlet extends HttpServlet {\n  private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);\n  private static MyDataStore database = MyDataStore.getInstance();\n  private final SmartHomeApp actionsApp = new MySmartHomeApp();\n  //private String msg;\n  private static final List<String> UPDATE_DEVICE_PARAMS_KEYS =\n      Arrays.asList(new String[] {\"name\", \"nickname\", \"localDeviceId\", \"errorCode\", \"tfa\"});\n\n  {\n    try {\n      GoogleCredentials credentials =\n          GoogleCredentials.fromStream(getClass().getResourceAsStream(\"/smart-home-key.json\"));\n      actionsApp.setCredentials(credentials);\n    } catch (Exception e) {\n      LOGGER.error(\"couldn't load credentials\");\n    }\n  }\n\n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n    String body = req.getReader().lines().collect(Collectors.joining());\n    LOGGER.info(\"doPost, body = {}\", body);\n    JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();\n    String userId = bodyJson.get(\"userId\").getAsString();\n    String deviceId = bodyJson.get(\"deviceId\").getAsString();\n    JsonObject states = bodyJson.getAsJsonObject(\"states\");\n    Map<String, Object> deviceStates =\n        states != null ? new Gson().fromJson(states, HashMap.class) : null;\n    Map<String, String> deviceParams = new HashMap<>();\n    Set<String> deviceParamsKeys = bodyJson.keySet();\n    deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);\n    for (String k : deviceParamsKeys) {\n      deviceParams.put(k, bodyJson.get(k).getAsString());\n    }\n    try {\n      database.updateDevice(userId, deviceId, deviceStates, deviceParams);\n      if (deviceParams.containsKey(\"localDeviceId\")) {\n        actionsApp.requestSync(userId);\n      }\n      if (states != null) {\n        ReportState.makeRequest(actionsApp, userId, deviceId, states);\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"failed to update device: {}\", e);\n      res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n      res.setContentType(\"text/plain\");\n      res.getWriter().println(\"ERROR\");\n      return;\n    }\n\n    res.setStatus(HttpServletResponse.SC_OK);\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setContentType(\"text/plain\");\n    res.getWriter().println(\"OK\");\n    // --------- Mqtt implementation --------------\n    //String msg = states.get(\"on\").getAsString().equals(\"true\") ? \"on\" : \"off\";\n    /*msg = states.toString();\n    if (states.has(\"thermostatTemperatureSetpoint\")){\n      msg = \"{'thermostatTemperatureSetpoint':\"+states.get(\"thermostatTemperatureSetpoint\")+\"}\";\n    }\n    String topic = \"hello\";\n    CompletableFuture.runAsync(() -> {\n      publishMqtt(topic, msg); // method call or code to be asynch.\n    });\n    */\n\n    // ---------------------------------------------\n  }\n\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException {\n    response.setContentType(\"text/plain\");\n    response.getWriter().println(\"/smarthome/update is a POST call\");\n  }\n\n  @Override\n  protected void doOptions(HttpServletRequest req, HttpServletResponse res) {\n    // pre-flight request processing\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,Accept,Origin\");\n  }\n/*\n  public void publishMqtt(String topic, String msg){\n    try {\n      //SampleAsyncCallBack mqtt = new SampleAsyncCallBack();\n      Sample mqtt = MySmartHomeApp.getInstanceMqtt();\n      mqtt.publish(topic, 0, msg.getBytes());\n      LOGGER.debug(\"Message = \"+ msg +\" sent by MQTT from UpdateServelet\");\n    } catch (Throwable throwable) {\n      LOGGER.error(\"failed to publish device: {}\", throwable);\n    }\n  } */\n}", "class_id": 0, "repo": "aniketkumar2012/GH_Home_Smart_Devices", "file": "src/main/java/com/example/SmartHomeUpdateServlet.java", "last_update_at": "2021-09-25T07:01:30+00:00", "question_id": "0e0da15f7cbb858c23517f700b77e09fcb2e8e1f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(name = \"smarthomeUpdate\", urlPatterns = \"/smarthome/update\")\npublic class SmartHomeUpdateServlet extends HttpServlet {\n  private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);\n  private static MyDataStore database = MyDataStore.getInstance();\n  private final SmartHomeApp actionsApp = new MySmartHomeApp();\n  //private String msg;\n  private static final List<String> UPDATE_DEVICE_PARAMS_KEYS =\n      Arrays.asList(new String[] {\"name\", \"nickname\", \"localDeviceId\", \"errorCode\", \"tfa\"});\n  {\n    try {\n      GoogleCredentials credentials =\n          GoogleCredentials.fromStream(getClass().getResourceAsStream(\"/smart-home-key.json\"));\n      actionsApp.setCredentials(credentials);\n    } catch (Exception e) {\n      LOGGER.error(\"couldn't load credentials\");\n    }\n  }\n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n    String body = req.getReader().lines().collect(Collectors.joining());\n    LOGGER.info(\"doPost, body = {}\", body);\n    JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();\n    String userId = bodyJson.get(\"userId\").getAsString();\n    String deviceId = bodyJson.get(\"deviceId\").getAsString();\n    JsonObject states = bodyJson.getAsJsonObject(\"states\");\n    Map<String, Object> deviceStates =\n        states != null ? new Gson().fromJson(states, HashMap.class) : null;\n    Map<String, String> deviceParams = new HashMap<>();\n    Set<String> deviceParamsKeys = bodyJson.keySet();\n    deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);\n    for (String k : deviceParamsKeys) {\n      deviceParams.put(k, bodyJson.get(k).getAsString());\n    }\n    try {\n      database.updateDevice(userId, deviceId, deviceStates, deviceParams);\n      if (deviceParams.containsKey(\"localDeviceId\")) {\n        actionsApp.requestSync(userId);\n      }\n      if (states != null) {\n        ReportState.makeRequest(actionsApp, userId, deviceId, states);\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"failed to update device: {}\", e);\n      res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n      res.setContentType(\"text/plain\");\n      res.getWriter().println(\"ERROR\");\n      return;\n    }\n    res.setStatus(HttpServletResponse.SC_OK);\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setContentType(\"text/plain\");\n    res.getWriter().println(\"OK\");\n    // --------- Mqtt implementation --------------\n    //String msg = states.get(\"on\").getAsString().equals(\"true\") ? \"on\" : \"off\";\n    /*msg = states.toString();\n    if (states.has(\"thermostatTemperatureSetpoint\")){\n      msg = \"{'thermostatTemperatureSetpoint':\"+states.get(\"thermostatTemperatureSetpoint\")+\"}\";\n    }\n    String topic = \"hello\";\n    CompletableFuture.runAsync(() -> {\n      publishMqtt(topic, msg); // method call or code to be asynch.\n    });\n    */\n    // ---------------------------------------------\n  }\n  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException {\n    response.setContentType(\"text/plain\");\n    response.getWriter().println(\"/smarthome/update is a POST call\");\n  }\n  @Override\n  protected void doOptions(HttpServletRequest req, HttpServletResponse res) {\n    // pre-flight request processing\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,Accept,Origin\");\n  }\n/*\n  public void publishMqtt(String topic, String msg){\n    try {\n      //SampleAsyncCallBack mqtt = new SampleAsyncCallBack();\n      Sample mqtt = MySmartHomeApp.getInstanceMqtt();\n      mqtt.publish(topic, 0, msg.getBytes());\n      LOGGER.debug(\"Message = \"+ msg +\" sent by MQTT from UpdateServelet\");\n    } catch (Throwable throwable) {\n      LOGGER.error(\"failed to publish device: {}\", throwable);\n    }\n  } */\n"]]}
{"hexsha": "b08f107779d239c4b7d57ae1d699871248d132d2", "ext": "java", "lang": "Java", "content": "public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {\n\n    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {\n\n        private JpaGpsDevice device;\n\n        public OpenJPAEventListener(JpaGpsDevice device) {\n            this.device = device;\n        }\n\n        @Override\n        protected JpaGpsDevice getDevice() {\n            return this.device;\n        }\n\n        public void beforeDelete(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterDelete(LifecycleEvent lifecycleEvent) {\n            postRemove(lifecycleEvent.getSource());\n        }\n\n        public void beforePersist(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterPersist(LifecycleEvent lifecycleEvent) {\n            postPersist(lifecycleEvent.getSource());\n        }\n\n        public void beforeStore(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterStore(LifecycleEvent lifecycleEvent) {\n            postUpdate(lifecycleEvent.getSource());\n        }\n    }\n\n    private boolean useSpecificClassEvents = true;\n\n    private ClassLoader classLoader;\n\n    private Object eventListener;\n\n    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {\n        this.useSpecificClassEvents = useSpecificClassEvents;\n    }\n\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Allows to directly inject the event listener that will be used with Open JPA. Will\n     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.\n     */\n    public void setEventListener(Object eventListener) {\n        this.eventListener = eventListener;\n    }\n\n    public boolean requireRefresh() {\n        return true;\n    }\n\n    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n\n        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();\n\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n\n        if (eventListener == null) {\n            eventListener = new OpenJPAEventListener(device);\n        }\n\n        if (useSpecificClassEvents) {\n            ArrayList<Class> matchedClasses = new ArrayList<Class>();\n            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);\n            for (Class clazz : classes) {\n                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);\n                Class mappedClass = classMetaData.getDescribedType();\n                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {\n                    matchedClasses.add(mappedClass);\n                }\n            }\n            if (matchedClasses.size() > 0) {\n                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));\n            }\n        } else {\n            emf.addLifecycleListener(eventListener);\n        }\n    }\n\n    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        eventListener = new OpenJPAEventListener(device);\n        emf.removeLifecycleListener(eventListener);\n    }\n}", "class_id": 0, "repo": "guaxinim/compass", "file": "src/main/src/org/compass/gps/device/jpa/lifecycle/OpenJPAJpaEntityLifecycleInjector.java", "last_update_at": "2021-11-10T06:48:02+00:00", "question_id": "b08f107779d239c4b7d57ae1d699871248d132d2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {\n    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {\n        private JpaGpsDevice device;\n        public OpenJPAEventListener(JpaGpsDevice device) {\n            this.device = device;\n        }\n        @Override\n        protected JpaGpsDevice getDevice() {\n            return this.device;\n        }\n        public void beforeDelete(LifecycleEvent lifecycleEvent) {\n        }\n        public void afterDelete(LifecycleEvent lifecycleEvent) {\n            postRemove(lifecycleEvent.getSource());\n        }\n        public void beforePersist(LifecycleEvent lifecycleEvent) {\n        }\n        public void afterPersist(LifecycleEvent lifecycleEvent) {\n            postPersist(lifecycleEvent.getSource());\n        }\n        public void beforeStore(LifecycleEvent lifecycleEvent) {\n        }\n        public void afterStore(LifecycleEvent lifecycleEvent) {\n            postUpdate(lifecycleEvent.getSource());\n        }\n    }\n    private boolean useSpecificClassEvents = true;\n    private ClassLoader classLoader;\n    private Object eventListener;\n    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {\n        this.useSpecificClassEvents = useSpecificClassEvents;\n    }\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n    /**\n     * Allows to directly inject the event listener that will be used with Open JPA. Will\n     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.\n     */\n    public void setEventListener(Object eventListener) {\n        this.eventListener = eventListener;\n    }\n    public boolean requireRefresh() {\n        return true;\n    }\n    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        if (eventListener == null) {\n            eventListener = new OpenJPAEventListener(device);\n        }\n        if (useSpecificClassEvents) {\n            ArrayList<Class> matchedClasses = new ArrayList<Class>();\n            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);\n            for (Class clazz : classes) {\n                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);\n                Class mappedClass = classMetaData.getDescribedType();\n                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {\n                    matchedClasses.add(mappedClass);\n                }\n            }\n            if (matchedClasses.size() > 0) {\n                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));\n            }\n        } else {\n            emf.addLifecycleListener(eventListener);\n        }\n    }\n    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        eventListener = new OpenJPAEventListener(device);\n        emf.removeLifecycleListener(eventListener);\n    }\n"]]}
{"hexsha": "44cf8deda1243d30e680509d78d40d7907b51d93", "ext": "java", "lang": "Java", "content": "@Configuration\r\npublic class ShiroConfig {\r\n\r\n    @Bean(\"sessionManager\")\r\n    public SessionManager sessionManager(){\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n        sessionManager.setSessionValidationSchedulerEnabled(true);\r\n        sessionManager.setSessionIdCookieEnabled(true);\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean(\"securityManager\")\r\n    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(oAuth2Realm);\r\n        securityManager.setSessionManager(sessionManager);\r\n\r\n        return securityManager;\r\n    }\r\n\r\n    @Bean(\"shiroFilter\")\r\n    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n\r\n        //oauth\u8fc7\u6ee4\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"oauth2\", new OAuth2Filter());\r\n        shiroFilter.setFilters(filters);\r\n\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/webjars/**\", \"anon\");\r\n        filterMap.put(\"/druid/**\", \"anon\");\r\n        filterMap.put(\"/app/**\", \"anon\");\r\n        filterMap.put(\"/sys/login\", \"anon\");\r\n        filterMap.put(\"/swagger/**\", \"anon\");\r\n        filterMap.put(\"/v2/api-docs\", \"anon\");\r\n        filterMap.put(\"/swagger-ui.html\", \"anon\");\r\n        filterMap.put(\"/swagger-resources/**\", \"anon\");\r\n        filterMap.put(\"/captcha.jpg\", \"anon\");\r\n        filterMap.put(\"/webname\", \"anon\");\r\n        filterMap.put(\"/licence/**\", \"anon\");\r\n        filterMap.put(\"/report/**\", \"anon\");\r\n        filterMap.put(\"/**/*.html\", \"anon\");\r\n        filterMap.put(\"/fonts/**\", \"anon\");\r\n        filterMap.put(\"/**/*.js\", \"anon\");\r\n        filterMap.put(\"/**/*.css\", \"anon\");\r\n        filterMap.put(\"/plugins/**\", \"anon\");\r\n        filterMap.put(\"/**/*.jpg\", \"anon\");\r\n        filterMap.put(\"/**/*.mp4\", \"anon\");\r\n        filterMap.put(\"/**/*.zip\", \"anon\");\r\n        filterMap.put(\"/**/*.png\", \"anon\");\r\n        filterMap.put(\"/\", \"anon\");\r\n        filterMap.put(\"/**\", \"oauth2\");\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n\r\n        return shiroFilter;\r\n    }\r\n\r\n    @Bean(\"lifecycleBeanPostProcessor\")\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        proxyCreator.setProxyTargetClass(true);\r\n        return proxyCreator;\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n\r\n}", "class_id": 0, "repo": "stuMental/StudentMental", "file": "src/main/java/io/student/config/ShiroConfig.java", "last_update_at": "2021-09-20T20:44:43+00:00", "question_id": "44cf8deda1243d30e680509d78d40d7907b51d93", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\r\npublic class ShiroConfig {\r\n\r\n    @Bean(\"sessionManager\")\r\n    public SessionManager sessionManager(){\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n        sessionManager.setSessionValidationSchedulerEnabled(true);\r\n        sessionManager.setSessionIdCookieEnabled(true);\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean(\"securityManager\")\r\n    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(oAuth2Realm);\r\n        securityManager.setSessionManager(sessionManager);\r\n\r\n        return securityManager;\r\n    }\r\n\r\n    @Bean(\"shiroFilter\")\r\n    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n\r\n        //oauth\u8fc7\u6ee4\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"oauth2\", new OAuth2Filter());\r\n        shiroFilter.setFilters(filters);\r\n\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/webjars/**\", \"anon\");\r\n        filterMap.put(\"/druid/**\", \"anon\");\r\n        filterMap.put(\"/app/**\", \"anon\");\r\n        filterMap.put(\"/sys/login\", \"anon\");\r\n        filterMap.put(\"/swagger/**\", \"anon\");\r\n        filterMap.put(\"/v2/api-docs\", \"anon\");\r\n        filterMap.put(\"/swagger-ui.html\", \"anon\");\r\n        filterMap.put(\"/swagger-resources/**\", \"anon\");\r\n        filterMap.put(\"/captcha.jpg\", \"anon\");\r\n        filterMap.put(\"/webname\", \"anon\");\r\n        filterMap.put(\"/licence/**\", \"anon\");\r\n        filterMap.put(\"/report/**\", \"anon\");\r\n        filterMap.put(\"/**/*.html\", \"anon\");\r\n        filterMap.put(\"/fonts/**\", \"anon\");\r\n        filterMap.put(\"/**/*.js\", \"anon\");\r\n        filterMap.put(\"/**/*.css\", \"anon\");\r\n        filterMap.put(\"/plugins/**\", \"anon\");\r\n        filterMap.put(\"/**/*.jpg\", \"anon\");\r\n        filterMap.put(\"/**/*.mp4\", \"anon\");\r\n        filterMap.put(\"/**/*.zip\", \"anon\");\r\n        filterMap.put(\"/**/*.png\", \"anon\");\r\n        filterMap.put(\"/\", \"anon\");\r\n        filterMap.put(\"/**\", \"oauth2\");\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n\r\n        return shiroFilter;\r\n    }\r\n\r\n    @Bean(\"lifecycleBeanPostProcessor\")\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        proxyCreator.setProxyTargetClass(true);\r\n        return proxyCreator;\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n\r\n"]]}
{"hexsha": "117f3d055e06497bc9bf38c477b32879ef1305eb", "ext": "java", "lang": "Java", "content": "public class MultiAtlasTest\n{\n    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);\n\n    private final Atlas base = new PackedAtlasTest().getAtlas();\n    private Atlas other;\n\n    private MultiAtlas multi;\n\n    @Test\n    public void connectivityTest()\n    {\n        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));\n\n        // Out edges of CC2: 987\n        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());\n        Assert.assertEquals(987,\n                this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());\n        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());\n        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());\n        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());\n    }\n\n    public Atlas getAtlas()\n    {\n        if (this.multi == null)\n        {\n            setup();\n        }\n        return this.multi;\n    }\n\n    @Before\n    public void setup()\n    {\n        final PackedAtlasBuilder builder = new PackedAtlasBuilder()\n                .withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));\n        final Map<String, String> edge5Tags = new HashMap<>();\n        edge5Tags.put(\"highway\", \"primary\");\n        edge5Tags.put(\"name\", \"edge5\");\n        edge5Tags.put(\"surface\", \"concrete\");\n        edge5Tags.put(\"lanes\", \"3\");\n\n        final Map<String, String> edge6Tags = new HashMap<>();\n        edge6Tags.put(\"highway\", \"secondary\");\n        edge6Tags.put(\"name\", \"edge98\");\n        edge6Tags.put(\"bridge\", \"cantilever\");\n        edge6Tags.put(\"maxspeed\", \"100\");\n\n        final Map<String, String> nodeTags = new HashMap<>();\n        nodeTags.put(\"highway\", \"traffic_signal\");\n        // shared\n        builder.addNode(123, Location.TEST_6, nodeTags);\n        // shared\n        builder.addNode(12345, Location.TEST_2, nodeTags);\n        // private\n        builder.addNode(4, Location.TEST_1, nodeTags);\n        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);\n        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);\n\n        // Relation structure and tags\n        // This one is already in the base atlas\n        final RelationBean structure1 = new RelationBean();\n        // structure1.addItem(null, \"in\", ItemType.EDGE);\n        // structure1.addItem(null, \"node\", ItemType.NODE);\n        // structure1.addItem(null, \"out\", ItemType.EDGE);\n        structure1.addItem(4L, \"notThere\", ItemType.NODE);\n        final RelationBean structure3 = new RelationBean();\n        structure3.addItem(5L, \"in\", ItemType.EDGE);\n        structure3.addItem(12345L, \"node\", ItemType.NODE);\n        structure3.addItem(6L, \"out\", ItemType.EDGE);\n        // Add relations\n        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());\n        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());\n\n        this.other = builder.get();\n\n        this.multi = new MultiAtlas(this.base, this.other);\n    }\n\n    @Test\n    public void spatialIndexTest()\n    {\n        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);\n        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));\n        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());\n        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));\n        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();\n        Assert.assertEquals(6, edgeIterator.next().getIdentifier());\n        Assert.assertEquals(5, edgeIterator.next().getIdentifier());\n        Assert.assertFalse(edgeIterator.hasNext());\n    }\n\n    @Test\n    public void testSlicedRelation()\n    {\n        final Relation relation1 = this.multi.relation(1L);\n        final RelationMemberList members = relation1.members();\n        Assert.assertEquals(4, members.size());\n        for (int i = 0; i < members.size(); i++)\n        {\n            Assert.assertTrue(members.get(i) != null);\n        }\n        // Members are ordered by entity type and ascending member identifier\n        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());\n        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());\n        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());\n        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());\n\n        final Relation relation2 = this.multi.relation(2L);\n        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();\n        final Relation relation3 = this.multi.relation(3L);\n        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();\n        Assert.assertEquals(8, allMembers2.size());\n        Assert.assertEquals(8, allMembers3.size());\n    }\n\n    @Test\n    public void totalTest()\n    {\n        final Iterator<Edge> edges = this.multi.edges().iterator();\n        int numberEdges = 0;\n        while (edges.hasNext())\n        {\n            numberEdges++;\n            edges.next();\n        }\n        Assert.assertEquals(6, numberEdges);\n        // Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(3, Iterables.size(this.multi.relations()));\n    }\n}", "class_id": 0, "repo": "gitclonefun/atlas", "file": "src/test/java/org/openstreetmap/atlas/geography/atlas/multi/MultiAtlasTest.java", "last_update_at": "2021-07-07T12:27:00+00:00", "question_id": "117f3d055e06497bc9bf38c477b32879ef1305eb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MultiAtlasTest\n{\n    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);\n    private final Atlas base = new PackedAtlasTest().getAtlas();\n    private Atlas other;\n    private MultiAtlas multi;\n    @Test\n    public void connectivityTest()\n    {\n        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));\n        // Out edges of CC2: 987\n        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());\n        Assert.assertEquals(987,\n                this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());\n        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());\n        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());\n        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());\n    }\n    public Atlas getAtlas()\n    {\n        if (this.multi == null)\n        {\n            setup();\n        }\n        return this.multi;\n    }\n    @Before\n    public void setup()\n    {\n        final PackedAtlasBuilder builder = new PackedAtlasBuilder()\n                .withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));\n        final Map<String, String> edge5Tags = new HashMap<>();\n        edge5Tags.put(\"highway\", \"primary\");\n        edge5Tags.put(\"name\", \"edge5\");\n        edge5Tags.put(\"surface\", \"concrete\");\n        edge5Tags.put(\"lanes\", \"3\");\n        final Map<String, String> edge6Tags = new HashMap<>();\n        edge6Tags.put(\"highway\", \"secondary\");\n        edge6Tags.put(\"name\", \"edge98\");\n        edge6Tags.put(\"bridge\", \"cantilever\");\n        edge6Tags.put(\"maxspeed\", \"100\");\n        final Map<String, String> nodeTags = new HashMap<>();\n        nodeTags.put(\"highway\", \"traffic_signal\");\n        // shared\n        builder.addNode(123, Location.TEST_6, nodeTags);\n        // shared\n        builder.addNode(12345, Location.TEST_2, nodeTags);\n        // private\n        builder.addNode(4, Location.TEST_1, nodeTags);\n        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);\n        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);\n        // Relation structure and tags\n        // This one is already in the base atlas\n        final RelationBean structure1 = new RelationBean();\n        // structure1.addItem(null, \"in\", ItemType.EDGE);\n        // structure1.addItem(null, \"node\", ItemType.NODE);\n        // structure1.addItem(null, \"out\", ItemType.EDGE);\n        structure1.addItem(4L, \"notThere\", ItemType.NODE);\n        final RelationBean structure3 = new RelationBean();\n        structure3.addItem(5L, \"in\", ItemType.EDGE);\n        structure3.addItem(12345L, \"node\", ItemType.NODE);\n        structure3.addItem(6L, \"out\", ItemType.EDGE);\n        // Add relations\n        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());\n        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());\n        this.other = builder.get();\n        this.multi = new MultiAtlas(this.base, this.other);\n    }\n    @Test\n    public void spatialIndexTest()\n    {\n        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);\n        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));\n        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());\n        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));\n        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();\n        Assert.assertEquals(6, edgeIterator.next().getIdentifier());\n        Assert.assertEquals(5, edgeIterator.next().getIdentifier());\n        Assert.assertFalse(edgeIterator.hasNext());\n    }\n    @Test\n    public void testSlicedRelation()\n    {\n        final Relation relation1 = this.multi.relation(1L);\n        final RelationMemberList members = relation1.members();\n        Assert.assertEquals(4, members.size());\n        for (int i = 0; i < members.size(); i++)\n        {\n            Assert.assertTrue(members.get(i) != null);\n        }\n        // Members are ordered by entity type and ascending member identifier\n        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());\n        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());\n        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());\n        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());\n        final Relation relation2 = this.multi.relation(2L);\n        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();\n        final Relation relation3 = this.multi.relation(3L);\n        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();\n        Assert.assertEquals(8, allMembers2.size());\n        Assert.assertEquals(8, allMembers3.size());\n    }\n    @Test\n    public void totalTest()\n    {\n        final Iterator<Edge> edges = this.multi.edges().iterator();\n        int numberEdges = 0;\n        while (edges.hasNext())\n        {\n            numberEdges++;\n            edges.next();\n        }\n        Assert.assertEquals(6, numberEdges);\n        // Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(3, Iterables.size(this.multi.relations()));\n    }\n"]]}
{"hexsha": "6bfcbd87be2fa0596ebe5830cc52201b86851996", "ext": "java", "lang": "Java", "content": "public class FeedJournalStorage implements JournalStorage {\n    private FeedJournalBridge mFeedJournalBridge;\n\n    /**\n     * Creates a {@link FeedJournalStorage} for storing journals for the current user.\n     *\n     * @param profile {@link Profile} of the user we are rendering the Feed for.\n     */\n    public FeedJournalStorage(Profile profile) {\n        mFeedJournalBridge = new FeedJournalBridge(profile);\n    }\n\n    /**\n     * Creates a {@link FeedJournalStorage} for testing.\n     *\n     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.\n     */\n    @VisibleForTesting\n    public FeedJournalStorage(FeedJournalBridge bridge) {\n        mFeedJournalBridge = bridge;\n    }\n\n    /** Cleans up {@link FeedJournalStorage}. */\n    public void destroy() {\n        assert mFeedJournalBridge != null;\n        mFeedJournalBridge.destroy();\n        mFeedJournalBridge = null;\n    }\n\n    @Override\n    public void read(String journalName, Consumer < Result < List<byte[]>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {\n                List<byte[]> journal = Arrays.asList(entries);\n                consumer.accept(Result.success(journal));\n            }, (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.commitJournalMutation(mutation,\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n\n    @Override\n    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.doesJournalExist(journalName,\n                    (Boolean exist)\n                            -> consumer.accept(Result.success(exist)),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void getAllJournals(Consumer < Result < List<String>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadAllJournalKeys(\n                    (String[] data)\n                            -> consumer.accept(Result.success(Arrays.asList(data))),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void deleteAll(Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.deleteAllJournals(\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n}", "class_id": 0, "repo": "jhonatasrm/chromium-android", "file": "app/src/main/java/org/chromium/chrome/browser/feed/FeedJournalStorage.java", "last_update_at": "2021-11-18T09:04:42+00:00", "question_id": "6bfcbd87be2fa0596ebe5830cc52201b86851996", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FeedJournalStorage implements JournalStorage {\n    private FeedJournalBridge mFeedJournalBridge;\n    /**\n     * Creates a {@link FeedJournalStorage} for storing journals for the current user.\n     *\n     * @param profile {@link Profile} of the user we are rendering the Feed for.\n     */\n    public FeedJournalStorage(Profile profile) {\n        mFeedJournalBridge = new FeedJournalBridge(profile);\n    }\n    /**\n     * Creates a {@link FeedJournalStorage} for testing.\n     *\n     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.\n     */\n    @VisibleForTesting\n    public FeedJournalStorage(FeedJournalBridge bridge) {\n        mFeedJournalBridge = bridge;\n    }\n    /** Cleans up {@link FeedJournalStorage}. */\n    public void destroy() {\n        assert mFeedJournalBridge != null;\n        mFeedJournalBridge.destroy();\n        mFeedJournalBridge = null;\n    }\n    @Override\n    public void read(String journalName, Consumer < Result < List<byte[]>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {\n                List<byte[]> journal = Arrays.asList(entries);\n                consumer.accept(Result.success(journal));\n            }, (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n    @Override\n    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.commitJournalMutation(mutation,\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n    @Override\n    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.doesJournalExist(journalName,\n                    (Boolean exist)\n                            -> consumer.accept(Result.success(exist)),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n    @Override\n    public void getAllJournals(Consumer < Result < List<String>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadAllJournalKeys(\n                    (String[] data)\n                            -> consumer.accept(Result.success(Arrays.asList(data))),\n                    (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n    @Override\n    public void deleteAll(Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.deleteAllJournals(\n                    (Boolean result)\n                            -> consumer.accept(\n                                    result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n"]]}
{"hexsha": "73f3690e36701a98e4dd08553207601b0f576d1b", "ext": "java", "lang": "Java", "content": "public class EnvLoadFileTest {\n    @Test\n    public void envTest0() throws IOException {\n        System.setProperty(\"CONFLICTS_VAR\", \"with app\");\n        StandardEnvironment env = null;\n        //\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\");\n        assert \"my my my\".equals(env.evalString(\"%MY_ENV%\"));\n        assert \"with app\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n        //\n        //\n        Map<String, String> envMap = new HashMap<String, String>();\n        envMap.put(\"CONFLICTS_VAR\", \"with env\");\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\", envMap, Thread.currentThread().getContextClassLoader());\n        assert \"with env\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n    }\n}", "class_id": 0, "repo": "corner4world/hasor", "file": "hasor-core/src/test/java/net/hasor/core/environment/EnvLoadFileTest.java", "last_update_at": "2021-06-01T06:52:08+00:00", "question_id": "73f3690e36701a98e4dd08553207601b0f576d1b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EnvLoadFileTest {\n    @Test\n    public void envTest0() throws IOException {\n        System.setProperty(\"CONFLICTS_VAR\", \"with app\");\n        StandardEnvironment env = null;\n        //\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\");\n        assert \"my my my\".equals(env.evalString(\"%MY_ENV%\"));\n        assert \"with app\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n        //\n        //\n        Map<String, String> envMap = new HashMap<String, String>();\n        envMap.put(\"CONFLICTS_VAR\", \"with env\");\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\", envMap, Thread.currentThread().getContextClassLoader());\n        assert \"with env\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n    }\n"]]}
{"hexsha": "ffa598d57403bf725a49c67af6e7b5b8fddbdb6f", "ext": "java", "lang": "Java", "content": "public final class BoruvkaMST {\r\n\r\n    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> compute(int vertices, Iterable<E> edges) {\r\n        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();\r\n        for (E e : edges)\r\n            wrapper.add(new ContractedEdge<>(e));\r\n        return recurse(vertices, wrapper);\r\n    }\r\n\r\n    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {\r\n\r\n        if (vertices < 2)\r\n            return new EdgeList<>();\r\n\r\n        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);\r\n        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);\r\n        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);\r\n\r\n        // extract original edges\r\n        EdgeList<E> markedEdges = new EdgeList<>();\r\n        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);\r\n\r\n        markedEdges.meld(recurse(contracted.vertices, contractedEdges));\r\n        return markedEdges;\r\n    }\r\n}", "class_id": 0, "repo": "lazyguyy/optimal-mst", "file": "src/mst/BoruvkaMST.java", "last_update_at": "2021-12-07T21:13:34+00:00", "question_id": "ffa598d57403bf725a49c67af6e7b5b8fddbdb6f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class BoruvkaMST {\r\n\r\n    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> compute(int vertices, Iterable<E> edges) {\r\n        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();\r\n        for (E e : edges)\r\n            wrapper.add(new ContractedEdge<>(e));\r\n        return recurse(vertices, wrapper);\r\n    }\r\n\r\n    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>>\r\n            EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {\r\n\r\n        if (vertices < 2)\r\n            return new EdgeList<>();\r\n\r\n        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);\r\n        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);\r\n        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);\r\n\r\n        // extract original edges\r\n        EdgeList<E> markedEdges = new EdgeList<>();\r\n        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);\r\n\r\n        markedEdges.meld(recurse(contracted.vertices, contractedEdges));\r\n        return markedEdges;\r\n    }\r\n"]]}
{"hexsha": "19807beaf0c29dd03789fd7847ec074e209b45d0", "ext": "java", "lang": "Java", "content": "public class Client {\n    private static final List<String> data = List.of(\"some\", \"data\", \"for\", \"test\");\n\n    public Client() {\n        exp02();\n    }\n\n    private void exp01() {\n        Dao dao = new XmlDao();\n        Service service = new ServiceImpl(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    private void exp02() {\n        Dao dao = new MongoDBDao();\n        Service service = new ServiceImplWithLog(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    public static void main(String[] args) {\n        new Client();\n    }\n\n}", "class_id": 0, "repo": "ismailbenhallam/Design-Patterns", "file": "07-Bridge/src/main/java/client/Client.java", "last_update_at": "2021-07-23T22:52:40+00:00", "question_id": "19807beaf0c29dd03789fd7847ec074e209b45d0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Client {\n    private static final List<String> data = List.of(\"some\", \"data\", \"for\", \"test\");\n    public Client() {\n        exp02();\n    }\n    private void exp01() {\n        Dao dao = new XmlDao();\n        Service service = new ServiceImpl(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n    private void exp02() {\n        Dao dao = new MongoDBDao();\n        Service service = new ServiceImplWithLog(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n    public static void main(String[] args) {\n        new Client();\n    }\n"]]}
{"hexsha": "e6daad92b85ef23f3921081ecaf6d618b18c2f1b", "ext": "java", "lang": "Java", "content": "public class OrmBenchmarksTask extends Task\n{\n    public static final  String  TAG              = \"OrmBenchmarksTask\";\n    private static final boolean USE_IN_MEMORY_DB = false;\n    private static final int     NUM_ITERATIONS   = 5;\n\n    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] {\n                    new SquidbExecutor(),\n                    new SugarOrmExecutor(),\n                    new SQLiteExecutor(),\n                    new DBFlowExecutor(),\n                    new SqueakyExecutor(),\n                    new CupboardExecutor(),\n                    new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(),\n                    new RealmExecutor(),\n                    new RequeryExecutor(),\n                    new OptimizedSQLiteExecutor(),\n                    new ORMLiteExecutor(),\n                    new GreenDaoExecutor()\n};\n\n    public String resultString;\n\n    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();\n\n    enum BenchmarkTask\n    {\n        CREATE_DB,\n        WRITE_DATA,\n        READ_DATA,\n        DROP_DB;\n    }\n\n    @Override\n    protected void run(Context context) throws Throwable\n    {\n        for(BenchmarkExecutable orm : mOrms)\n        {\n            orm.init(context, USE_IN_MEMORY_DB);\n            Log.w(TAG, orm.getOrmName() + \" init\");\n        }\n\n        List<BenchmarkExecutable> failed = new ArrayList<>();\n\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n\n            for(BenchmarkExecutable item : mOrms)\n            {\n                for(BenchmarkTask task : BenchmarkTask.values())\n                {\n                    long result = 0;\n\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" start\");\n\n                    try\n                    {\n                        switch(task)\n                        {\n                            case CREATE_DB:\n                                result = item.createDbStructure();\n                                break;\n                            case DROP_DB:\n                                result = item.dropDb();\n                                break;\n                            case READ_DATA:\n                                result = item.readWholeData();\n                                break;\n                            case WRITE_DATA:\n                                result = item.writeWholeData();\n                                break;\n                        }\n                    }\n                    catch(Exception e)\n                    {\n                        result = Long.MIN_VALUE;\n                        failed.add(item);\n                    }\n\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() +\" end\");\n                    addProfilerResult(item.getOrmName(), task, result);\n                }\n            }\n        }\n\n        buildResultString();\n    }\n\n    private void buildResultString()\n    {\n        StringBuilder sb = new StringBuilder();\n\n        BenchmarkTask[] bTasks = new BenchmarkTask[]{BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA};\n        for(BenchmarkTask bTask : bTasks)\n        {\n            sb.append(\"<b>\").append(bTask.name()).append(\"</b>\").append(\"<br/>\");\n            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());\n            if(stringLongMap != null)\n            {\n                for(String ormName : stringLongMap.keySet())\n                {\n\n                    long result = stringLongMap.get(ormName);\n                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);\n                    sb.append(ormName).append(\" - \");\n\n                    if(printResult < 0)\n                    {\n                        sb.append(\"(crashed)\");\n                    }\n                    else\n                    {\n                        sb.append(Math.round(printResult)).append(\"ms\");\n                    }\n\n                    sb.append(\"<br/>\");\n\n                    Log.w(\"FOR_SPREADSHEET\", ormName + \",\" + Math.round(printResult));\n                }\n            }\n        }\n\n        resultString = sb.toString();\n    }\n\n    private void addProfilerResult(String ormName, BenchmarkTask task, long result)\n    {\n        Map<String, Long> taskMap = benchmarkResults.get(task.name());\n        if(taskMap == null)\n        {\n            taskMap = new TreeMap<>();\n            benchmarkResults.put(task.name(), taskMap);\n        }\n        Long storedResult = taskMap.get(ormName);\n        if(storedResult == null)\n        {\n            storedResult = 0l;\n        }\n        long value = result + storedResult;\n        taskMap.put(ormName, value);\n        Log.w(TAG, \"adding \"+ task.name() +\"-\"+ ormName+\"-\"+value);\n    }\n\n    @Override\n    protected boolean handleError(Context context, Throwable e)\n    {\n        return false;\n    }\n\n    @Override\n    protected void onComplete(Context context)\n    {\n        EventBusExt.getDefault().post(this);\n    }\n}", "class_id": 0, "repo": "greenrobot/android-orm-benchmark-updated", "file": "ORM-Benchmark/src/main/java/com/littleinc/orm_benchmark/tasks/OrmBenchmarksTask.java", "last_update_at": "2021-06-14T18:42:56+00:00", "question_id": "e6daad92b85ef23f3921081ecaf6d618b18c2f1b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrmBenchmarksTask extends Task\n{\n    public static final  String  TAG              = \"OrmBenchmarksTask\";\n    private static final boolean USE_IN_MEMORY_DB = false;\n    private static final int     NUM_ITERATIONS   = 5;\n    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] {\n                    new SquidbExecutor(),\n                    new SugarOrmExecutor(),\n                    new SQLiteExecutor(),\n                    new DBFlowExecutor(),\n                    new SqueakyExecutor(),\n                    new CupboardExecutor(),\n                    new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(),\n                    new RealmExecutor(),\n                    new RequeryExecutor(),\n                    new OptimizedSQLiteExecutor(),\n                    new ORMLiteExecutor(),\n                    new GreenDaoExecutor()\n};\n    public String resultString;\n    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();\n    enum BenchmarkTask\n    {\n        CREATE_DB,\n        WRITE_DATA,\n        READ_DATA,\n        DROP_DB;\n    }\n    @Override\n    protected void run(Context context) throws Throwable\n    {\n        for(BenchmarkExecutable orm : mOrms)\n        {\n            orm.init(context, USE_IN_MEMORY_DB);\n            Log.w(TAG, orm.getOrmName() + \" init\");\n        }\n        List<BenchmarkExecutable> failed = new ArrayList<>();\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n            for(BenchmarkExecutable item : mOrms)\n            {\n                for(BenchmarkTask task : BenchmarkTask.values())\n                {\n                    long result = 0;\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" start\");\n                    try\n                    {\n                        switch(task)\n                        {\n                            case CREATE_DB:\n                                result = item.createDbStructure();\n                                break;\n                            case DROP_DB:\n                                result = item.dropDb();\n                                break;\n                            case READ_DATA:\n                                result = item.readWholeData();\n                                break;\n                            case WRITE_DATA:\n                                result = item.writeWholeData();\n                                break;\n                        }\n                    }\n                    catch(Exception e)\n                    {\n                        result = Long.MIN_VALUE;\n                        failed.add(item);\n                    }\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() +\" end\");\n                    addProfilerResult(item.getOrmName(), task, result);\n                }\n            }\n        }\n        buildResultString();\n    }\n    private void buildResultString()\n    {\n        StringBuilder sb = new StringBuilder();\n        BenchmarkTask[] bTasks = new BenchmarkTask[]{BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA};\n        for(BenchmarkTask bTask : bTasks)\n        {\n            sb.append(\"<b>\").append(bTask.name()).append(\"</b>\").append(\"<br/>\");\n            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());\n            if(stringLongMap != null)\n            {\n                for(String ormName : stringLongMap.keySet())\n                {\n                    long result = stringLongMap.get(ormName);\n                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);\n                    sb.append(ormName).append(\" - \");\n                    if(printResult < 0)\n                    {\n                        sb.append(\"(crashed)\");\n                    }\n                    else\n                    {\n                        sb.append(Math.round(printResult)).append(\"ms\");\n                    }\n                    sb.append(\"<br/>\");\n                    Log.w(\"FOR_SPREADSHEET\", ormName + \",\" + Math.round(printResult));\n                }\n            }\n        }\n        resultString = sb.toString();\n    }\n    private void addProfilerResult(String ormName, BenchmarkTask task, long result)\n    {\n        Map<String, Long> taskMap = benchmarkResults.get(task.name());\n        if(taskMap == null)\n        {\n            taskMap = new TreeMap<>();\n            benchmarkResults.put(task.name(), taskMap);\n        }\n        Long storedResult = taskMap.get(ormName);\n        if(storedResult == null)\n        {\n            storedResult = 0l;\n        }\n        long value = result + storedResult;\n        taskMap.put(ormName, value);\n        Log.w(TAG, \"adding \"+ task.name() +\"-\"+ ormName+\"-\"+value);\n    }\n    @Override\n    protected boolean handleError(Context context, Throwable e)\n    {\n        return false;\n    }\n    @Override\n    protected void onComplete(Context context)\n    {\n        EventBusExt.getDefault().post(this);\n    }\n"]]}
{"hexsha": "e0aa48a7e2cf1b6234970b1b127112d88e948138", "ext": "java", "lang": "Java", "content": "public class PrivateMessage extends Chat {\n\tprivate static Pattern privateMessageRegex = Pattern.compile(\"\\\\[([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16}) -> mir\\\\] (.*)$\");\n\tprivate static Pattern privateMessageSentRegex = Pattern.compile(\"\\\\[mir -> ([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16})\\\\] (.*)$\");\n\tprivate long lastAfkMessage = 0;\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"privateMessage\";\n\t}\n\n\tpublic boolean doAction(String unformatted) {\n\t\tif(unformatted.trim().length() > 0) {\n\t\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\n\t\t\treturn privateMessage.find() || privateMessageSent.find();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doActionHandleChatMessage(String unformatted, String formatted) {\n\t\treturn getSettings().isPrivateChatRight() && doAction(unformatted);\n\t}\n\n\t@Override\n\tpublic boolean doActionModifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\n\t\treturn doAction(unformatted);\n\t}\n\n\t@Override\n\tpublic ChatDisplayAction handleChatMessage(String unformatted, String formatted) {\n\t\treturn ChatDisplayAction.SWAP;\n\t}\n\n\t@Override\n\tpublic IChatComponent modifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\n\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\n\t\tString suggestMsgHoverTxt =\n\t\t\t\tLanguageManager.translateOrReturnKey(\"message_gg_suggestMsgHoverMsg\");\n\t\tIChatComponent hoverText = new ChatComponentText(ModColor.cl(\"a\") + suggestMsgHoverTxt);\n\n\t\tif (privateMessage.find()) {\n\t\t\tString playerName = privateMessage.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\n\t\t\tif (getSettings().isPrivateChatSound()) {\n\t\t\t\tLabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);\n\t\t\t}\n\n\t\t\tif (getSettings().isMsgDisplayNameClick()) {\n\t\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\t\tint siblingCnt = 0;\n\t\t\t\tint nameStart = 0;\n\t\t\t\tint nameEnd = 0;\n\t\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().contains(\"\u00a76[\u00a7r\")) {\n\t\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t\t}\n\t\t\t\t\tsiblingCnt++;\n\t\t\t\t}\n\t\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage+1000 <= System.currentTimeMillis()) {\n\t\t\t\tString message = getSettings().getAfkMsgText();\n\t\t\t\tif(message.length() > 0) {\n\t\t\t\t\tif(message.startsWith(\"~\")) message = message.replaceFirst(\"~\", \"\");\n\t\t\t\t\tMinecraft.getMinecraft().thePlayer.sendChatMessage(\"/msg \" + playerName + \" \" + message);\n\t\t\t\t\tlastAfkMessage = System.currentTimeMillis();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {\n\t\t\tString playerName = privateMessageSent.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\n\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\tint siblingCnt = 0;\n\t\t\tint nameStart = 0;\n\t\t\tint nameEnd = 0;\n\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t}\n\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76] \u00a7r\")) {\n\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t}\n\t\t\t\tsiblingCnt++;\n\t\t\t}\n\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t}\n\t\t}\n\n\t\treturn msg;\n\t}\n}", "class_id": 0, "repo": "Dominic11/LabyMod-GrieferGames-Addon-1.8.9", "file": "src/main/java/de/neocraftr/griefergames/chat/PrivateMessage.java", "last_update_at": "2021-12-22T00:27:11+00:00", "question_id": "e0aa48a7e2cf1b6234970b1b127112d88e948138", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PrivateMessage extends Chat {\n\tprivate static Pattern privateMessageRegex = Pattern.compile(\"\\\\[([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16}) -> mir\\\\] (.*)$\");\n\tprivate static Pattern privateMessageSentRegex = Pattern.compile(\"\\\\[mir -> ([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16})\\\\] (.*)$\");\n\tprivate long lastAfkMessage = 0;\n\t@Override\n\tpublic String getName() {\n\t\treturn \"privateMessage\";\n\t}\n\tpublic boolean doAction(String unformatted) {\n\t\tif(unformatted.trim().length() > 0) {\n\t\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\t\t\treturn privateMessage.find() || privateMessageSent.find();\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic boolean doActionHandleChatMessage(String unformatted, String formatted) {\n\t\treturn getSettings().isPrivateChatRight() && doAction(unformatted);\n\t}\n\t@Override\n\tpublic boolean doActionModifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\t\treturn doAction(unformatted);\n\t}\n\t@Override\n\tpublic ChatDisplayAction handleChatMessage(String unformatted, String formatted) {\n\t\treturn ChatDisplayAction.SWAP;\n\t}\n\t@Override\n\tpublic IChatComponent modifyChatMessage(IChatComponent msg) {\n\t\tString unformatted = msg.getUnformattedText();\n\t\tMatcher privateMessage = privateMessageRegex.matcher(unformatted);\n\t\tMatcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n\t\tString suggestMsgHoverTxt =\n\t\t\t\tLanguageManager.translateOrReturnKey(\"message_gg_suggestMsgHoverMsg\");\n\t\tIChatComponent hoverText = new ChatComponentText(ModColor.cl(\"a\") + suggestMsgHoverTxt);\n\t\tif (privateMessage.find()) {\n\t\t\tString playerName = privateMessage.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\t\t\tif (getSettings().isPrivateChatSound()) {\n\t\t\t\tLabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);\n\t\t\t}\n\t\t\tif (getSettings().isMsgDisplayNameClick()) {\n\t\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\t\tint siblingCnt = 0;\n\t\t\t\tint nameStart = 0;\n\t\t\t\tint nameEnd = 0;\n\t\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().contains(\"\u00a76[\u00a7r\")) {\n\t\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t\t}\n\t\t\t\t\tsiblingCnt++;\n\t\t\t\t}\n\t\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage+1000 <= System.currentTimeMillis()) {\n\t\t\t\tString message = getSettings().getAfkMsgText();\n\t\t\t\tif(message.length() > 0) {\n\t\t\t\t\tif(message.startsWith(\"~\")) message = message.replaceFirst(\"~\", \"\");\n\t\t\t\t\tMinecraft.getMinecraft().thePlayer.sendChatMessage(\"/msg \" + playerName + \" \" + message);\n\t\t\t\t\tlastAfkMessage = System.currentTimeMillis();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {\n\t\t\tString playerName = privateMessageSent.group(2);\n\t\t\tif(playerName.startsWith(\"~\")) playerName = playerName.replaceFirst(\"~\", \"\");\n\t\t\tString username = \"/msg \" + playerName + \" \";\n\t\t\tint siblingCnt = 0;\n\t\t\tint nameStart = 0;\n\t\t\tint nameEnd = 0;\n\t\t\tfor (IChatComponent msgs : msg.getSiblings()) {\n\t\t\t\tif (nameStart == 0 && msgs.getFormattedText().equals(\"\u00a76 -> \u00a7r\")) {\n\t\t\t\t\tnameStart = siblingCnt + 1;\n\t\t\t\t}\n\t\t\t\tif (nameEnd == 0 && msgs.getFormattedText().equals(\"\u00a76] \u00a7r\")) {\n\t\t\t\t\tnameEnd = siblingCnt - 1;\n\t\t\t\t}\n\t\t\t\tsiblingCnt++;\n\t\t\t}\n\t\t\tfor (int i = nameStart; i <= nameEnd; i++) {\n\t\t\t\tmsg.getSiblings().get(i).getChatStyle()\n\t\t\t\t\t\t.setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username))\n\t\t\t\t\t\t.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n\t\t\t}\n\t\t}\n\t\treturn msg;\n\t}\n"]]}
{"hexsha": "22f1d27c88a69020fcf20563969e6c9de6ef532c", "ext": "java", "lang": "Java", "content": "@ChannelHandler.Sharable\npublic class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {\n    public static final String POOL_KEY = \"AsyncRpcClientHandler\";\n    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);\n    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();\n\n    public AsyncRpcClientHandler(String address) {\n        super(address);\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {\n        String requestId = response.getRequestId();\n        LOGGER.info(\"Receive response : \" + requestId);\n        RpcFuture rpcFuture = pendingRPC.get(requestId);\n        if (rpcFuture != null) {\n            pendingRPC.remove(requestId);\n            rpcFuture.done(response);\n        }\n        AsyncRpcPool.getInstance().returnObject(address, this);\n    }\n\n    public void close() {\n        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n    }\n\n    public RpcFuture send(final Request request) throws Exception {\n        RpcFuture rpcFuture = new SwiftFuture(request);\n        pendingRPC.put(request.getRequestId(), rpcFuture);\n        final CountDownLatch latch = new CountDownLatch(1);\n        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {\n            LOGGER.info(\"Send request : \" + request.getRequestId());\n            latch.countDown();\n        });\n        return rpcFuture;\n    }\n}", "class_id": 0, "repo": "fanruan/swift-engine", "file": "swift-rpc-netty/src/main/java/com/fr/swift/cloud/netty/rpc/client/async/AsyncRpcClientHandler.java", "last_update_at": "2021-12-03T03:41:22+00:00", "question_id": "22f1d27c88a69020fcf20563969e6c9de6ef532c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ChannelHandler.Sharable\npublic class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {\n    public static final String POOL_KEY = \"AsyncRpcClientHandler\";\n    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);\n    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();\n    public AsyncRpcClientHandler(String address) {\n        super(address);\n    }\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {\n        String requestId = response.getRequestId();\n        LOGGER.info(\"Receive response : \" + requestId);\n        RpcFuture rpcFuture = pendingRPC.get(requestId);\n        if (rpcFuture != null) {\n            pendingRPC.remove(requestId);\n            rpcFuture.done(response);\n        }\n        AsyncRpcPool.getInstance().returnObject(address, this);\n    }\n    public void close() {\n        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n    }\n    public RpcFuture send(final Request request) throws Exception {\n        RpcFuture rpcFuture = new SwiftFuture(request);\n        pendingRPC.put(request.getRequestId(), rpcFuture);\n        final CountDownLatch latch = new CountDownLatch(1);\n        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {\n            LOGGER.info(\"Send request : \" + request.getRequestId());\n            latch.countDown();\n        });\n        return rpcFuture;\n    }\n"]]}
{"hexsha": "afdbd11a44ee520634dc2f62fa377a7a4d3f4e36", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"planes\")\npublic class Plane extends Vehicle{\n    @Column(name=\"passenger_capacity\")\n    private int passengerCapacity;\n    @ManyToOne\n    private Company company;\n\n    public Plane(){}\n\n    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(id, model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n\n    public void setPassengerCapacity(int seats) {\n        this.passengerCapacity = seats;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"Plane{\");\n        sb.append(super.toString());\n        sb.append(\"passengerCapacity=\").append(passengerCapacity);\n        sb.append('}');\n        return sb.toString();\n    }\n}", "class_id": 0, "repo": "TsvetomirN1/Soft-Uni-Spring-Data", "file": "Lections/spring-data-master/04-jpa-codefirst-lab/src/main/java/course/springdata/codefirst/entity/Plane.java", "last_update_at": "2021-04-24T20:29:56+00:00", "question_id": "afdbd11a44ee520634dc2f62fa377a7a4d3f4e36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"planes\")\npublic class Plane extends Vehicle{\n    @Column(name=\"passenger_capacity\")\n    private int passengerCapacity;\n    @ManyToOne\n    private Company company;\n    public Plane(){}\n    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(id, model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n    public void setPassengerCapacity(int seats) {\n        this.passengerCapacity = seats;\n    }\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"Plane{\");\n        sb.append(super.toString());\n        sb.append(\"passengerCapacity=\").append(passengerCapacity);\n        sb.append('}');\n        return sb.toString();\n    }\n"]]}
{"hexsha": "b9f4d52f93a8b27867f96d7d2bf06ba3c97bf302", "ext": "java", "lang": "Java", "content": "public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {\n\n    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, \"textures/gui/dimmer_rack.png\");\n\n    private final ContainerDimmerRack inventoryPlayer;\n    private final TileEntityDimmerRack tileDimmerRack;\n    private final List<ISocapexReceiver> receivers;\n    private TextFieldWidget dmxStartField;\n    private final List<ButtonSocket> sockets;\n    private final List<ButtonPlug> plugs;\n    private int currentPage = 0;\n\n    private int activePlug = -1;\n\n    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {\n        super(container, inventory, title);\n        this.inventoryPlayer = container;\n        this.tileDimmerRack = container.dimmerRack;\n        this.xSize = 250;\n        this.ySize = 131;\n\n        sockets = new ArrayList<>();\n        plugs = new ArrayList<>();\n        receivers = inventoryPlayer.getDevices();\n    }\n\n    @Override\n    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {\n        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {\n            this.onClose();\n            this.getMinecraft().player.closeScreen();\n            return true;\n        }\n        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n        generateButtons();\n    }\n\n    @Override\n    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {\n        this.init(p_resize_1_, p_resize_2_, p_resize_3_);\n    }\n\n    public void generateButtons() {\n        this.buttons.removeAll(sockets);\n        this.buttons.removeAll(plugs);\n        this.children.removeAll(sockets);\n        this.children.removeAll(plugs);\n        this.plugs.clear();\n        this.sockets.clear();\n        int width = this.width / 2;\n        int height = (this.height - this.ySize) / 2;\n        for (int i = 0; i < 6; i++) {\n            SocapexPatch[] patch = inventoryPlayer.getPatch(i);\n            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);\n            int y = height + (i < 3 ? 25 : 70);\n            for (int j = 0; j < 2; j++) {\n                ButtonSocket buttonSocket;\n                if (patch == null || j >= patch.length) {\n                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                } else {\n                    SocapexPatch patch1 = patch[j];\n                    if (patch1 != null && patch1.getReceiver() != null) {\n                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);\n                    } else {\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j),  i, j == 1, this::handleSocket);\n                    }\n                }\n                this.addButton(buttonSocket);\n                sockets.add(buttonSocket);\n            }\n        }\n        if (receivers.size() > 0) {\n            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);\n            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {\n                for (int i = 0; i < channels.length; i++) {\n                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));\n                    int y = height + (i < 3 ? 45 : 65);\n                    if (channels[i] != 1) {\n                        int finalI = i;\n                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, \"\", activePlug == i, (button) -> {\n                            if (button instanceof ButtonPlug) {\n                                ButtonPlug plug = (ButtonPlug) button;\n                                if (activePlug == finalI) {\n                                    plug.setActive(false);\n                                    activePlug = -1;\n                                } else {\n                                    plug.setActive(true);\n                                    activePlug = finalI;\n                                }\n                            }\n                        });\n                        this.addButton(buttonPlug);\n                        plugs.add(buttonPlug);\n                    }\n                }\n            });\n        }\n    }\n\n\n    @Override\n    protected void init() {\n        super.init();\n        int lvt_1_1_ = (this.width - this.xSize) / 2;\n        int lvt_2_1_ = (this.height - this.ySize) / 2;\n        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\"<\"), (button) -> {\n            if (currentPage - 1 < 0) {\n                currentPage = receivers.size() - 1;\n            } else {\n                currentPage--;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\">\"), (button) -> {\n            if (currentPage + 1 > receivers.size() - 1) {\n                currentPage = 0;\n            } else {\n                currentPage++;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(\"\"));\n        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {\n            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));\n        }\n        this.dmxStartField.setCanLoseFocus(false);\n        this.dmxStartField.changeFocus(true);\n        this.dmxStartField.setTextColor(-1);\n        this.dmxStartField.setDisabledTextColour(-1);\n        this.dmxStartField.setEnableBackgroundDrawing(true);\n        this.dmxStartField.setMaxStringLength(35);\n        this.dmxStartField.setValidator(s -> {\n            if (s.length() == 0) {\n                return true;\n            }\n            try {\n                Integer.parseInt(s);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        });\n        this.children.add(this.dmxStartField);\n        this.setFocusedDefault(this.dmxStartField);\n        generateButtons();\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if(this.dmxStartField.isMouseOver(mouseX, mouseY)){\n            this.dmxStartField.setFocused2(true);\n        }\n        return super.mouseClicked(mouseX, mouseY, button);\n    }\n\n    @Override\n    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {\n        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);\n        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);\n        int lvt_4_1_ = this.guiLeft;\n        int lvt_5_1_ = (this.height - this.ySize) / 2;\n        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);\n    }\n\n    @Override\n    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {\n        this.renderBackground(ms);\n        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        RenderSystem.disableBlend();\n        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        this.renderHoveredTooltip(ms,  p_230430_2_, p_230430_3_);\n    }\n\n\n    @Override\n    public void onClose() {\n        super.onClose();\n        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));\n    }\n\n    @Override\n    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {\n        String name = container.dimmerRack.getDisplayName().getString();\n        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);\n        font.drawString(matrixStack, \"Plugs\", 180 + font.getStringWidth(\"Plugs\") / 2, 6, 0x404040);\n        for (int i = 0; i < 6; i++) {\n            int x1 = 33 + 46 * (i < 3 ? i : i - 3);\n            int y1 = (i < 3 ? 15 : 62);\n            font.drawString(matrixStack, \"\" + (i + 1), x1, y1, 0x000000);\n        }\n        if (receivers.size() > 0) {\n            String pageName = \"Panel \" + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());\n            font\n                    .drawString(matrixStack, pageName, 150 + font.getStringWidth(\n                            pageName\n                    ) / 2, 30, 0x404040);\n        }\n        if (activePlug != -1) {\n            int width = this.width / 2;\n            int height = (this.height - this.ySize) / 2;\n            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));\n            int plugY = height + (activePlug < 3 ? 45 : 65);\n            int xDist = plugX - x;\n            int yDist = plugY - y;\n            if (Minecraft.getInstance().currentScreen != null) {\n                long distanceSq = xDist * xDist + yDist * yDist;\n                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;\n                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);\n            }\n            final int color = 0x13C90A;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n            RenderSystem.disableTexture();\n            RenderSystem.disableCull();\n            RenderSystem.lineWidth(3);\n            RenderSystem.color4f(1F, 1F, 1F, 1F);\n            Tessellator tessellator = Tessellator.getInstance();\n            BufferBuilder bufferBuilder = tessellator.getBuffer();\n            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);\n            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();\n            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();\n            tessellator.draw();\n            RenderSystem.enableTexture();\n            RenderSystem.enableCull();\n        }\n    }\n\n    private void handleSocket(Button button) {\n        if (button instanceof ButtonSocket) {\n            ButtonSocket socket = (ButtonSocket) button;\n            int channel = socket.getChannelNumber();\n            int socketNumber = socket.isSecondSocket() ? 2 : 1;\n            if (activePlug == -1) {\n                if (socket.isPatched()) {\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));\n                    generateButtons();\n                }\n            } else {\n                if (!socket.isPatched()) {\n                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));\n                    activePlug = -1;\n                    generateButtons();\n                }\n            }\n        }\n    }\n}", "class_id": 0, "repo": "manmaed/theatrical-forge", "file": "src/main/java/dev/theatricalmod/theatrical/client/gui/screen/ScreenDimmerRack.java", "last_update_at": "2021-12-19T23:19:11+00:00", "question_id": "b9f4d52f93a8b27867f96d7d2bf06ba3c97bf302", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {\n    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, \"textures/gui/dimmer_rack.png\");\n    private final ContainerDimmerRack inventoryPlayer;\n    private final TileEntityDimmerRack tileDimmerRack;\n    private final List<ISocapexReceiver> receivers;\n    private TextFieldWidget dmxStartField;\n    private final List<ButtonSocket> sockets;\n    private final List<ButtonPlug> plugs;\n    private int currentPage = 0;\n    private int activePlug = -1;\n    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {\n        super(container, inventory, title);\n        this.inventoryPlayer = container;\n        this.tileDimmerRack = container.dimmerRack;\n        this.xSize = 250;\n        this.ySize = 131;\n        sockets = new ArrayList<>();\n        plugs = new ArrayList<>();\n        receivers = inventoryPlayer.getDevices();\n    }\n    @Override\n    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {\n        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {\n            this.onClose();\n            this.getMinecraft().player.closeScreen();\n            return true;\n        }\n        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);\n    }\n    @Override\n    public void tick() {\n        super.tick();\n        generateButtons();\n    }\n    @Override\n    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {\n        this.init(p_resize_1_, p_resize_2_, p_resize_3_);\n    }\n    public void generateButtons() {\n        this.buttons.removeAll(sockets);\n        this.buttons.removeAll(plugs);\n        this.children.removeAll(sockets);\n        this.children.removeAll(plugs);\n        this.plugs.clear();\n        this.sockets.clear();\n        int width = this.width / 2;\n        int height = (this.height - this.ySize) / 2;\n        for (int i = 0; i < 6; i++) {\n            SocapexPatch[] patch = inventoryPlayer.getPatch(i);\n            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);\n            int y = height + (i < 3 ? 25 : 70);\n            for (int j = 0; j < 2; j++) {\n                ButtonSocket buttonSocket;\n                if (patch == null || j >= patch.length) {\n                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                } else {\n                    SocapexPatch patch1 = patch[j];\n                    if (patch1 != null && patch1.getReceiver() != null) {\n                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);\n                    } else {\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j),  i, j == 1, this::handleSocket);\n                    }\n                }\n                this.addButton(buttonSocket);\n                sockets.add(buttonSocket);\n            }\n        }\n        if (receivers.size() > 0) {\n            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);\n            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {\n                for (int i = 0; i < channels.length; i++) {\n                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));\n                    int y = height + (i < 3 ? 45 : 65);\n                    if (channels[i] != 1) {\n                        int finalI = i;\n                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, \"\", activePlug == i, (button) -> {\n                            if (button instanceof ButtonPlug) {\n                                ButtonPlug plug = (ButtonPlug) button;\n                                if (activePlug == finalI) {\n                                    plug.setActive(false);\n                                    activePlug = -1;\n                                } else {\n                                    plug.setActive(true);\n                                    activePlug = finalI;\n                                }\n                            }\n                        });\n                        this.addButton(buttonPlug);\n                        plugs.add(buttonPlug);\n                    }\n                }\n            });\n        }\n    }\n    @Override\n    protected void init() {\n        super.init();\n        int lvt_1_1_ = (this.width - this.xSize) / 2;\n        int lvt_2_1_ = (this.height - this.ySize) / 2;\n        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\"<\"), (button) -> {\n            if (currentPage - 1 < 0) {\n                currentPage = receivers.size() - 1;\n            } else {\n                currentPage--;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\">\"), (button) -> {\n            if (currentPage + 1 > receivers.size() - 1) {\n                currentPage = 0;\n            } else {\n                currentPage++;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(\"\"));\n        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {\n            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));\n        }\n        this.dmxStartField.setCanLoseFocus(false);\n        this.dmxStartField.changeFocus(true);\n        this.dmxStartField.setTextColor(-1);\n        this.dmxStartField.setDisabledTextColour(-1);\n        this.dmxStartField.setEnableBackgroundDrawing(true);\n        this.dmxStartField.setMaxStringLength(35);\n        this.dmxStartField.setValidator(s -> {\n            if (s.length() == 0) {\n                return true;\n            }\n            try {\n                Integer.parseInt(s);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        });\n        this.children.add(this.dmxStartField);\n        this.setFocusedDefault(this.dmxStartField);\n        generateButtons();\n    }\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if(this.dmxStartField.isMouseOver(mouseX, mouseY)){\n            this.dmxStartField.setFocused2(true);\n        }\n        return super.mouseClicked(mouseX, mouseY, button);\n    }\n    @Override\n    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {\n        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);\n        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);\n        int lvt_4_1_ = this.guiLeft;\n        int lvt_5_1_ = (this.height - this.ySize) / 2;\n        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);\n    }\n    @Override\n    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {\n        this.renderBackground(ms);\n        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        RenderSystem.disableBlend();\n        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        this.renderHoveredTooltip(ms,  p_230430_2_, p_230430_3_);\n    }\n    @Override\n    public void onClose() {\n        super.onClose();\n        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));\n    }\n    @Override\n    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {\n        String name = container.dimmerRack.getDisplayName().getString();\n        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);\n        font.drawString(matrixStack, \"Plugs\", 180 + font.getStringWidth(\"Plugs\") / 2, 6, 0x404040);\n        for (int i = 0; i < 6; i++) {\n            int x1 = 33 + 46 * (i < 3 ? i : i - 3);\n            int y1 = (i < 3 ? 15 : 62);\n            font.drawString(matrixStack, \"\" + (i + 1), x1, y1, 0x000000);\n        }\n        if (receivers.size() > 0) {\n            String pageName = \"Panel \" + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());\n            font\n                    .drawString(matrixStack, pageName, 150 + font.getStringWidth(\n                            pageName\n                    ) / 2, 30, 0x404040);\n        }\n        if (activePlug != -1) {\n            int width = this.width / 2;\n            int height = (this.height - this.ySize) / 2;\n            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));\n            int plugY = height + (activePlug < 3 ? 45 : 65);\n            int xDist = plugX - x;\n            int yDist = plugY - y;\n            if (Minecraft.getInstance().currentScreen != null) {\n                long distanceSq = xDist * xDist + yDist * yDist;\n                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;\n                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);\n            }\n            final int color = 0x13C90A;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n            RenderSystem.disableTexture();\n            RenderSystem.disableCull();\n            RenderSystem.lineWidth(3);\n            RenderSystem.color4f(1F, 1F, 1F, 1F);\n            Tessellator tessellator = Tessellator.getInstance();\n            BufferBuilder bufferBuilder = tessellator.getBuffer();\n            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);\n            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();\n            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();\n            tessellator.draw();\n            RenderSystem.enableTexture();\n            RenderSystem.enableCull();\n        }\n    }\n    private void handleSocket(Button button) {\n        if (button instanceof ButtonSocket) {\n            ButtonSocket socket = (ButtonSocket) button;\n            int channel = socket.getChannelNumber();\n            int socketNumber = socket.isSecondSocket() ? 2 : 1;\n            if (activePlug == -1) {\n                if (socket.isPatched()) {\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));\n                    generateButtons();\n                }\n            } else {\n                if (!socket.isPatched()) {\n                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));\n                    activePlug = -1;\n                    generateButtons();\n                }\n            }\n        }\n    }\n"]]}
{"hexsha": "2f69a2cf43dadc045ceb638260afaf3f2210355e", "ext": "java", "lang": "Java", "content": "public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe\n{\n\tpublic Recipe_AA_Plating(ItemStack result, List components) \n\t{\n\t\tsuper(result, components);\n\t}\n\n\t@Override\n\tpublic ItemStack getCraftingResult(InventoryCrafting matrix)\n    {\n\t\tItemStack stack = this.getRecipeOutput().copy();\n\t\tItemStack previousAA = this.getAAFromMatrix(matrix);\n\t\t\n\t\tif (previousAA != null && previousAA.hasTagCompound())\t// Copying existing properties\n\t\t{\n\t\t\tstack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());\n\t\t}\n\t\telse\t// ...or just applying new ones\n\t\t{\n\t\t\tstack.setTagCompound(new NBTTagCompound());\n\t\t}\n\t\t\n\t\t// Apply the new upgrade now\n\t\tstack.getTagCompound().setBoolean(\"hasHeavyPlatingUpgrade\", true);\n\t\t\n        return stack;\n    }\n\t\n\t\n\tprivate ItemStack getAAFromMatrix(InventoryCrafting matrix)\n\t{\n\t\tint counter = 0;\n\t\t\n\t\twhile (counter < matrix.getSizeInventory())\n\t\t{\n\t\t\tif (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA)\n\t\t\t{\n\t\t\t\treturn matrix.getStackInSlot(counter);\t// Found it\n\t\t\t}\n\t\t\t\n\t\t\tcounter += 1;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}", "class_id": 0, "repo": "Domochevsky/minecraft-quiverbow", "file": "src/main/java/com/domochevsky/quiverbow/recipes/Recipe_AA_Plating.java", "last_update_at": "2021-05-10T04:57:25+00:00", "question_id": "2f69a2cf43dadc045ceb638260afaf3f2210355e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe\n{\n\tpublic Recipe_AA_Plating(ItemStack result, List components) \n\t{\n\t\tsuper(result, components);\n\t}\n\t@Override\n\tpublic ItemStack getCraftingResult(InventoryCrafting matrix)\n    {\n\t\tItemStack stack = this.getRecipeOutput().copy();\n\t\tItemStack previousAA = this.getAAFromMatrix(matrix);\n\t\t\n\t\tif (previousAA != null && previousAA.hasTagCompound())\t// Copying existing properties\n\t\t{\n\t\t\tstack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());\n\t\t}\n\t\telse\t// ...or just applying new ones\n\t\t{\n\t\t\tstack.setTagCompound(new NBTTagCompound());\n\t\t}\n\t\t\n\t\t// Apply the new upgrade now\n\t\tstack.getTagCompound().setBoolean(\"hasHeavyPlatingUpgrade\", true);\n\t\t\n        return stack;\n    }\n\t\n\t\n\tprivate ItemStack getAAFromMatrix(InventoryCrafting matrix)\n\t{\n\t\tint counter = 0;\n\t\t\n\t\twhile (counter < matrix.getSizeInventory())\n\t\t{\n\t\t\tif (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA)\n\t\t\t{\n\t\t\t\treturn matrix.getStackInSlot(counter);\t// Found it\n\t\t\t}\n\t\t\t\n\t\t\tcounter += 1;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n"]]}
{"hexsha": "1c582ac1b81910b0f81a82266c59f8c5b94e8164", "ext": "java", "lang": "Java", "content": "public class ShimBridgingClassloader extends ClassLoader implements BundleReference {\n  public static final String HADOOP_SPOON_PLUGIN = \"HadoopSpoonPlugin\";\n  private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();\n  private final BundleWiring bundleWiring;\n  private final PublicLoadResolveClassLoader bundleWiringClassloader;\n\n  public ShimBridgingClassloader( ClassLoader parentClassLoader, BundleContext bundleContext ) {\n    super( parentClassLoader );\n    this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt( BundleWiring.class );\n    this.bundleWiringClassloader = new PublicLoadResolveClassLoader( bundleWiring.getClassLoader() );\n  }\n\n  public static Object create( BundleContext bundleContext, String className, List<Object> arguments )\n    throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException,\n    InvocationTargetException {\n    ShimBridgingClassloader shimBridgingClassloader =\n      new ShimBridgingClassloader( pluginClassloaderGetter.getPluginClassloader(\n        LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN ), bundleContext );\n    Class<?> clazz = Class.forName( className, true, shimBridgingClassloader );\n    if ( arguments == null || arguments.size() == 0 ) {\n      return clazz.newInstance();\n    }\n    for ( Constructor<?> constructor : clazz.getConstructors() ) {\n      Class<?>[] parameterTypes = constructor.getParameterTypes();\n      if ( parameterTypes.length == arguments.size() ) {\n        boolean match = true;\n        for ( int i = 0; i < parameterTypes.length; i++ ) {\n          Object o = arguments.get( i );\n          if ( o != null && !parameterTypes[ i ].isInstance( o ) ) {\n            match = false;\n            break;\n          }\n        }\n        if ( match ) {\n          return constructor.newInstance( arguments.toArray() );\n        }\n      }\n    }\n    throw new InstantiationException(\n      \"Unable to find constructor for class \" + className + \" with arguments \" + arguments );\n  }\n\n  @VisibleForTesting\n  static PluginClassloaderGetter getPluginClassloaderGetter() {\n    return pluginClassloaderGetter;\n  }\n\n  @VisibleForTesting\n  static void setPluginClassloaderGetter( PluginClassloaderGetter pluginClassloaderGetter ) {\n    ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;\n  }\n\n  @Override\n  protected Class<?> findClass( String name ) throws ClassNotFoundException {\n    int lastIndexOfDot = name.lastIndexOf( '.' );\n    final String packageName;\n    final String translatedPath;\n    final String translatedName;\n    if ( lastIndexOfDot >= 0 ) {\n      packageName = name.substring( 0, lastIndexOfDot );\n      if ( getPackage( packageName ) == null ) {\n        definePackage( packageName, null, null, null, null, null, null, null );\n      }\n      translatedPath = \"/\" + packageName.replace( '.', '/' );\n      translatedName = name.substring( lastIndexOfDot + 1 ) + \".class\";\n    } else {\n      packageName = \"\";\n      translatedPath = \"/\";\n      translatedName = name;\n    }\n    if ( getPackage( packageName ) == null ) {\n      definePackage( packageName, null, null, null, null, null, null, null );\n    }\n    List<URL> entries = bundleWiring.findEntries( translatedPath, translatedName, 0 );\n    if ( entries.size() == 1 ) {\n      byte[] bytes;\n      try ( ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream() ) {\n        IOUtils.copy( entries.get( 0 ).openStream(), byteArrayOutputStream );\n        bytes = byteArrayOutputStream.toByteArray();\n      } catch ( IOException e ) {\n        throw new ClassNotFoundException( \"Unable to define class\", e );\n      }\n      return defineClass( name, bytes, 0, bytes.length );\n    }\n    throw new ClassNotFoundException();\n  }\n\n  @Override public URL getResource( String name ) {\n    int lastIndexOf = name.lastIndexOf( '/' );\n\n    List<URL> entries;\n    if ( lastIndexOf > 0 ) {\n      entries = bundleWiring.findEntries( name.substring( 0, lastIndexOf ), name.substring( lastIndexOf + 1 ), 0 );\n    } else {\n      entries = bundleWiring.findEntries( \"/\", name, 0 );\n    }\n    if ( entries.size() == 1 ) {\n      return entries.get( 0 );\n    }\n    URL resource = bundleWiringClassloader.getResource( name );\n    if ( resource == null ) {\n      resource = super.getResource( name );\n    }\n    return resource;\n  }\n\n  @Override\n  public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n    Class<?> result = null;\n    synchronized ( this ) {\n      result = findLoadedClass( name );\n    }\n    if ( result == null ) {\n      try {\n        result = findClass( name );\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      try {\n        Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass( name, resolve );\n        if ( osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader() ) {\n          // Give parent a chance to supercede the system classloader (workaround for boot delegation of packages we\n          // should have loaded from the parent)\n          try {\n            return super.loadClass( name, resolve );\n          } catch ( Exception e ) {\n            // Ignore\n          }\n        }\n        return osgiProvidedClass;\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      return super.loadClass( name, resolve );\n    }\n    if ( resolve ) {\n      resolveClass( result );\n    }\n    return result;\n  }\n\n  @Override\n  public Bundle getBundle() {\n    return this.bundleWiring.getBundle();\n  }\n\n  /**\n   * Trivial classloader subclass that lets us call loadClass with a resolve parameter\n   */\n  @VisibleForTesting\n  static class PublicLoadResolveClassLoader extends ClassLoader {\n    public PublicLoadResolveClassLoader( ClassLoader parent ) {\n      super( parent );\n    }\n\n    @Override\n    public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n      return super.loadClass( name, resolve );\n    }\n  }\n}", "class_id": 0, "repo": "plagoa/big-data-plugin", "file": "impl/shim/common/src/main/java/com/pentaho/big/data/bundles/impl/shim/common/ShimBridgingClassloader.java", "last_update_at": "2021-06-01T15:15:10+00:00", "question_id": "1c582ac1b81910b0f81a82266c59f8c5b94e8164", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShimBridgingClassloader extends ClassLoader implements BundleReference {\n  public static final String HADOOP_SPOON_PLUGIN = \"HadoopSpoonPlugin\";\n  private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();\n  private final BundleWiring bundleWiring;\n  private final PublicLoadResolveClassLoader bundleWiringClassloader;\n  public ShimBridgingClassloader( ClassLoader parentClassLoader, BundleContext bundleContext ) {\n    super( parentClassLoader );\n    this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt( BundleWiring.class );\n    this.bundleWiringClassloader = new PublicLoadResolveClassLoader( bundleWiring.getClassLoader() );\n  }\n  public static Object create( BundleContext bundleContext, String className, List<Object> arguments )\n    throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException,\n    InvocationTargetException {\n    ShimBridgingClassloader shimBridgingClassloader =\n      new ShimBridgingClassloader( pluginClassloaderGetter.getPluginClassloader(\n        LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN ), bundleContext );\n    Class<?> clazz = Class.forName( className, true, shimBridgingClassloader );\n    if ( arguments == null || arguments.size() == 0 ) {\n      return clazz.newInstance();\n    }\n    for ( Constructor<?> constructor : clazz.getConstructors() ) {\n      Class<?>[] parameterTypes = constructor.getParameterTypes();\n      if ( parameterTypes.length == arguments.size() ) {\n        boolean match = true;\n        for ( int i = 0; i < parameterTypes.length; i++ ) {\n          Object o = arguments.get( i );\n          if ( o != null && !parameterTypes[ i ].isInstance( o ) ) {\n            match = false;\n            break;\n          }\n        }\n        if ( match ) {\n          return constructor.newInstance( arguments.toArray() );\n        }\n      }\n    }\n    throw new InstantiationException(\n      \"Unable to find constructor for class \" + className + \" with arguments \" + arguments );\n  }\n  @VisibleForTesting\n  static PluginClassloaderGetter getPluginClassloaderGetter() {\n    return pluginClassloaderGetter;\n  }\n  @VisibleForTesting\n  static void setPluginClassloaderGetter( PluginClassloaderGetter pluginClassloaderGetter ) {\n    ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;\n  }\n  @Override\n  protected Class<?> findClass( String name ) throws ClassNotFoundException {\n    int lastIndexOfDot = name.lastIndexOf( '.' );\n    final String packageName;\n    final String translatedPath;\n    final String translatedName;\n    if ( lastIndexOfDot >= 0 ) {\n      packageName = name.substring( 0, lastIndexOfDot );\n      if ( getPackage( packageName ) == null ) {\n        definePackage( packageName, null, null, null, null, null, null, null );\n      }\n      translatedPath = \"/\" + packageName.replace( '.', '/' );\n      translatedName = name.substring( lastIndexOfDot + 1 ) + \".class\";\n    } else {\n      packageName = \"\";\n      translatedPath = \"/\";\n      translatedName = name;\n    }\n    if ( getPackage( packageName ) == null ) {\n      definePackage( packageName, null, null, null, null, null, null, null );\n    }\n    List<URL> entries = bundleWiring.findEntries( translatedPath, translatedName, 0 );\n    if ( entries.size() == 1 ) {\n      byte[] bytes;\n      try ( ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream() ) {\n        IOUtils.copy( entries.get( 0 ).openStream(), byteArrayOutputStream );\n        bytes = byteArrayOutputStream.toByteArray();\n      } catch ( IOException e ) {\n        throw new ClassNotFoundException( \"Unable to define class\", e );\n      }\n      return defineClass( name, bytes, 0, bytes.length );\n    }\n    throw new ClassNotFoundException();\n  }\n  @Override public URL getResource( String name ) {\n    int lastIndexOf = name.lastIndexOf( '/' );\n    List<URL> entries;\n    if ( lastIndexOf > 0 ) {\n      entries = bundleWiring.findEntries( name.substring( 0, lastIndexOf ), name.substring( lastIndexOf + 1 ), 0 );\n    } else {\n      entries = bundleWiring.findEntries( \"/\", name, 0 );\n    }\n    if ( entries.size() == 1 ) {\n      return entries.get( 0 );\n    }\n    URL resource = bundleWiringClassloader.getResource( name );\n    if ( resource == null ) {\n      resource = super.getResource( name );\n    }\n    return resource;\n  }\n  @Override\n  public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n    Class<?> result = null;\n    synchronized ( this ) {\n      result = findLoadedClass( name );\n    }\n    if ( result == null ) {\n      try {\n        result = findClass( name );\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      try {\n        Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass( name, resolve );\n        if ( osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader() ) {\n          // Give parent a chance to supercede the system classloader (workaround for boot delegation of packages we\n          // should have loaded from the parent)\n          try {\n            return super.loadClass( name, resolve );\n          } catch ( Exception e ) {\n            // Ignore\n          }\n        }\n        return osgiProvidedClass;\n      } catch ( Exception e ) {\n        // Ignore\n      }\n    }\n    if ( result == null ) {\n      return super.loadClass( name, resolve );\n    }\n    if ( resolve ) {\n      resolveClass( result );\n    }\n    return result;\n  }\n  @Override\n  public Bundle getBundle() {\n    return this.bundleWiring.getBundle();\n  }\n  /**\n   * Trivial classloader subclass that lets us call loadClass with a resolve parameter\n   */\n  @VisibleForTesting\n  static class PublicLoadResolveClassLoader extends ClassLoader {\n    public PublicLoadResolveClassLoader( ClassLoader parent ) {\n      super( parent );\n    }\n    @Override\n    public Class<?> loadClass( String name, boolean resolve ) throws ClassNotFoundException {\n      return super.loadClass( name, resolve );\n    }\n  }\n"]]}
{"hexsha": "0faf5feafc496ca15627b4ccf3b1a7b044eb1614", "ext": "java", "lang": "Java", "content": "@WebService(serviceName = \"vnfAdapterNotify\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\")\r\npublic class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify{\r\n\r\n\tprivate static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);\n\n\tprivate final String logMarker = \"[VNF-NOTIFY]\";\r\n\r\n\t@Context WebServiceContext wsContext;\r\n\r\n    @WebMethod(operationName = \"rollbackVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"rollbackVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification\")\r\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest\")\n    public void rollbackVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tRollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();\r\n\r\n\t\trollbackVnfNotification.setMessageId(messageId);\r\n\t\trollbackVnfNotification.setCompleted(completed);\r\n\t\trollbackVnfNotification.setException(exception);\r\n\t\trollbackVnfNotification.setErrorMessage(errorMessage);\r\n\r\n\t\tString method = \"rollbackVnfNotification\";\r\n\t\tObject message = rollbackVnfNotification;\r\n\t\tString messageEventName = \"rollbackVnfNotificationCallback\";\r\n\t\tString messageVariable = \"rollbackVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFRB_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n    @WebMethod(operationName = \"queryVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"queryVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest\")\n    public void queryVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"vnfExists\", targetNamespace = \"\")\r\n        Boolean vnfExists,\r\n        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n        String vnfId,\r\n        @WebParam(name = \"status\", targetNamespace = \"\")\r\n        VnfStatus status,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        QueryVnfNotification.Outputs outputs){\r\n\r\n\t\tString method = \"queryVnfNotification\";\r\n\t\tString messageEventName = \"queryVnfNotificationCallback\";\r\n\t\tString messageVariable = \"queryVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFQ_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tQueryVnfNotification message = new QueryVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setVnfExists(vnfExists);\r\n    \tmessage.setVnfId(vnfId);\r\n    \tmessage.setStatus(status);\r\n    \tmessage.setOutputs(outputs);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n\t@WebMethod(operationName = \"createVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"createVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest\")\n\tpublic void createVnfNotification(\r\n\t\t\t@WebParam(name = \"messageId\", targetNamespace = \"\")\r\n\t        String messageId,\r\n\t        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n\t        boolean completed,\r\n\t        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n\t        MsoExceptionCategory exception,\r\n\t        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n\t        String errorMessage,\r\n\t        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n\t        String vnfId,\r\n\t        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n\t        CreateVnfNotification.Outputs outputs,\r\n\t        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n\t        VnfRollback rollback){\r\n\r\n\t\tString method = \"createVnfNotification\";\r\n\t\tString messageEventName = \"createVnfNotificationCallback\";\r\n\t\tString messageVariable = \"createVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFC_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n\t\tCreateVnfNotification message = new CreateVnfNotification();\r\n\r\n\t\tmessage.setMessageId(messageId);\r\n\t\tmessage.setCompleted(completed);\r\n\t\tmessage.setException(exception);\r\n\t\tmessage.setErrorMessage(errorMessage);\r\n\t\tmessage.setVnfId(vnfId);\r\n\t\tmessage.setOutputs(outputs);\r\n\t\tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n\t@WebMethod(operationName = \"updateVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"updateVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest\")\n    public void updateVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        UpdateVnfNotification.Outputs outputs,\r\n        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n        VnfRollback rollback){\r\n\r\n\t\tString method = \"updateVnfNotification\";\r\n\t\tString messageEventName = \"updateVnfNotificationCallback\";\r\n\t\tString messageVariable = \"updateVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFU_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tUpdateVnfNotification message = new UpdateVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setOutputs(outputs);\r\n    \tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n    @WebMethod(operationName = \"deleteVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"deleteVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest\")\n    public void deleteVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tString method = \"deleteVnfNotification\";\r\n\t\tString messageEventName = \"deleteVnfACallback\";\r\n\t\tString messageVariable = \"deleteVnfACallback\";\r\n\t\tString correlationVariable = \"VNFDEL_uuid\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tDeleteVnfNotification message = new DeleteVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t}\r\n}", "class_id": 0, "repo": "onap/mso", "file": "bpmn/MSOCommonBPMN/src/main/java/org/openecomp/mso/bpmn/common/workflow/service/VnfAdapterNotifyServiceImpl.java", "last_update_at": "2021-10-15T19:28:17+00:00", "question_id": "0faf5feafc496ca15627b4ccf3b1a7b044eb1614", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebService(serviceName = \"vnfAdapterNotify\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\")\r\npublic class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify{\r\n\r\n\tprivate static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);\n\tprivate final String logMarker = \"[VNF-NOTIFY]\";\r\n\r\n\t@Context WebServiceContext wsContext;\r\n\r\n    @WebMethod(operationName = \"rollbackVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"rollbackVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification\")\r\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest\")\n    public void rollbackVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tRollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();\r\n\r\n\t\trollbackVnfNotification.setMessageId(messageId);\r\n\t\trollbackVnfNotification.setCompleted(completed);\r\n\t\trollbackVnfNotification.setException(exception);\r\n\t\trollbackVnfNotification.setErrorMessage(errorMessage);\r\n\r\n\t\tString method = \"rollbackVnfNotification\";\r\n\t\tObject message = rollbackVnfNotification;\r\n\t\tString messageEventName = \"rollbackVnfNotificationCallback\";\r\n\t\tString messageVariable = \"rollbackVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFRB_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n    @WebMethod(operationName = \"queryVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"queryVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest\")\n    public void queryVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"vnfExists\", targetNamespace = \"\")\r\n        Boolean vnfExists,\r\n        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n        String vnfId,\r\n        @WebParam(name = \"status\", targetNamespace = \"\")\r\n        VnfStatus status,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        QueryVnfNotification.Outputs outputs){\r\n\r\n\t\tString method = \"queryVnfNotification\";\r\n\t\tString messageEventName = \"queryVnfNotificationCallback\";\r\n\t\tString messageVariable = \"queryVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFQ_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tQueryVnfNotification message = new QueryVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setVnfExists(vnfExists);\r\n    \tmessage.setVnfId(vnfId);\r\n    \tmessage.setStatus(status);\r\n    \tmessage.setOutputs(outputs);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n    }\r\n\r\n\t@WebMethod(operationName = \"createVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"createVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest\")\n\tpublic void createVnfNotification(\r\n\t\t\t@WebParam(name = \"messageId\", targetNamespace = \"\")\r\n\t        String messageId,\r\n\t        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n\t        boolean completed,\r\n\t        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n\t        MsoExceptionCategory exception,\r\n\t        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n\t        String errorMessage,\r\n\t        @WebParam(name = \"vnfId\", targetNamespace = \"\")\r\n\t        String vnfId,\r\n\t        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n\t        CreateVnfNotification.Outputs outputs,\r\n\t        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n\t        VnfRollback rollback){\r\n\r\n\t\tString method = \"createVnfNotification\";\r\n\t\tString messageEventName = \"createVnfNotificationCallback\";\r\n\t\tString messageVariable = \"createVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFC_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n\t\tCreateVnfNotification message = new CreateVnfNotification();\r\n\r\n\t\tmessage.setMessageId(messageId);\r\n\t\tmessage.setCompleted(completed);\r\n\t\tmessage.setException(exception);\r\n\t\tmessage.setErrorMessage(errorMessage);\r\n\t\tmessage.setVnfId(vnfId);\r\n\t\tmessage.setOutputs(outputs);\r\n\t\tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n\t@WebMethod(operationName = \"updateVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"updateVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest\")\n    public void updateVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage,\r\n        @WebParam(name = \"outputs\", targetNamespace = \"\")\r\n        UpdateVnfNotification.Outputs outputs,\r\n        @WebParam(name = \"rollback\", targetNamespace = \"\")\r\n        VnfRollback rollback){\r\n\r\n\t\tString method = \"updateVnfNotification\";\r\n\t\tString messageEventName = \"updateVnfNotificationCallback\";\r\n\t\tString messageVariable = \"updateVnfNotificationCallback\";\r\n\t\tString correlationVariable = \"VNFU_messageId\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tUpdateVnfNotification message = new UpdateVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n    \tmessage.setOutputs(outputs);\r\n    \tmessage.setRollback(rollback);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t }\r\n\r\n    @WebMethod(operationName = \"deleteVnfNotification\")\r\n    @Oneway\r\n    @RequestWrapper(localName = \"deleteVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest\")\n    public void deleteVnfNotification(\r\n        @WebParam(name = \"messageId\", targetNamespace = \"\")\r\n        String messageId,\r\n        @WebParam(name = \"completed\", targetNamespace = \"\")\r\n        boolean completed,\r\n        @WebParam(name = \"exception\", targetNamespace = \"\")\r\n        MsoExceptionCategory exception,\r\n        @WebParam(name = \"errorMessage\", targetNamespace = \"\")\r\n        String errorMessage) {\r\n\r\n\t\tString method = \"deleteVnfNotification\";\r\n\t\tString messageEventName = \"deleteVnfACallback\";\r\n\t\tString messageVariable = \"deleteVnfACallback\";\r\n\t\tString correlationVariable = \"VNFDEL_uuid\";\r\n\t\tString correlationValue = messageId;\r\n\r\n\t\tMsoLogger.setServiceName(\"MSO.\" + method);\r\n\t\tMsoLogger.setLogContext(correlationValue, \"N/A\");\r\n\r\n    \tDeleteVnfNotification message = new DeleteVnfNotification();\r\n\r\n    \tmessage.setMessageId(messageId);\r\n    \tmessage.setCompleted(completed);\r\n    \tmessage.setException(exception);\r\n    \tmessage.setErrorMessage(errorMessage);\r\n\r\n\t\thandleCallback(method, message, messageEventName, messageVariable,\r\n\t\t\tcorrelationVariable, correlationValue, logMarker);\r\n\t}\r\n"]]}
{"hexsha": "ef4088695a2bdbb3f8b94bb4019081cc3a616e2e", "ext": "java", "lang": "Java", "content": "public class MatrixCalculator {\n\n    private static ILexicalDatabase db;\n\n    public MatrixCalculator(ILexicalDatabase db) {\n        MatrixCalculator.db = db;\n    }\n\n    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);\n                result[i][j] = score;\n            }\n        }\n        return result;\n    }\n\n    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] scores = getSimilarityMatrix(words1, words2, rc);\n        double bestScore = 1.0D;\n        for (double[] score : scores) {\n            for (double aScore : score) {\n                if (aScore > bestScore && aScore != Double.MAX_VALUE) bestScore = aScore;\n            }\n        }\n        for (int i = 0; i < scores.length; i++) {\n            for (int j = 0; j < scores[i].length; j++) {\n                if (scores[i][j] == Double.MAX_VALUE) scores[i][j] = 1;\n                else scores[i][j] /= bestScore;\n            }\n        }\n        return scores;\n    }\n\n    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {\n        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);\n        Arrays.asList(words1).forEach(aWords1 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms1.add(synonyms);\n        });\n        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);\n        Arrays.asList(words2).forEach(aWords2 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms2.add(synonyms);\n        });\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                String w1 = words1[i];\n                String w2 = words2[j];\n                if (w1.equals(w2)) {\n                    result[i][j] = 1.0D;\n                    continue;\n                }\n                Set<String> s1 = synonyms1.get(i);\n                Set<String> s2 = synonyms2.get(j);\n                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;\n            }\n        }\n        return result;\n    }\n}", "class_id": 0, "repo": "iamani123/Disatt", "file": "OpenNlp/src/main/java/one/ws4j/util/MatrixCalculator.java", "last_update_at": "2021-03-31T21:12:45+00:00", "question_id": "ef4088695a2bdbb3f8b94bb4019081cc3a616e2e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MatrixCalculator {\n    private static ILexicalDatabase db;\n    public MatrixCalculator(ILexicalDatabase db) {\n        MatrixCalculator.db = db;\n    }\n    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);\n                result[i][j] = score;\n            }\n        }\n        return result;\n    }\n    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] scores = getSimilarityMatrix(words1, words2, rc);\n        double bestScore = 1.0D;\n        for (double[] score : scores) {\n            for (double aScore : score) {\n                if (aScore > bestScore && aScore != Double.MAX_VALUE) bestScore = aScore;\n            }\n        }\n        for (int i = 0; i < scores.length; i++) {\n            for (int j = 0; j < scores[i].length; j++) {\n                if (scores[i][j] == Double.MAX_VALUE) scores[i][j] = 1;\n                else scores[i][j] /= bestScore;\n            }\n        }\n        return scores;\n    }\n    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {\n        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);\n        Arrays.asList(words1).forEach(aWords1 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms1.add(synonyms);\n        });\n        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);\n        Arrays.asList(words2).forEach(aWords2 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos)\n                    .forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms2.add(synonyms);\n        });\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                String w1 = words1[i];\n                String w2 = words2[j];\n                if (w1.equals(w2)) {\n                    result[i][j] = 1.0D;\n                    continue;\n                }\n                Set<String> s1 = synonyms1.get(i);\n                Set<String> s2 = synonyms2.get(j);\n                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;\n            }\n        }\n        return result;\n    }\n"]]}
{"hexsha": "2bb34c545567de1b63d21140f0cf44c5afcf6090", "ext": "java", "lang": "Java", "content": "public class WikiParserTest {\n    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));\n\n    @Test\n    public void parse() throws Exception {\n        final String sample = Resources.toString(getClass().getResource(\"/markdown/sample.md\"), StandardCharsets.UTF_8);\n        final WikiPageSource src = new WikiPageSource();\n        src.setMarkdownSource(sample);\n        final ParsedWikiPage page = toTest.parse(src);\n        System.out.println(page.getHtml());\n    }\n}", "class_id": 0, "repo": "voho/website", "file": "website/src/test/java/cz/voho/wiki/backend/WikiParserTest.java", "last_update_at": "2021-02-06T20:49:46+00:00", "question_id": "2bb34c545567de1b63d21140f0cf44c5afcf6090", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WikiParserTest {\n    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));\n    @Test\n    public void parse() throws Exception {\n        final String sample = Resources.toString(getClass().getResource(\"/markdown/sample.md\"), StandardCharsets.UTF_8);\n        final WikiPageSource src = new WikiPageSource();\n        src.setMarkdownSource(sample);\n        final ParsedWikiPage page = toTest.parse(src);\n        System.out.println(page.getHtml());\n    }\n"]]}
{"hexsha": "aec0215d4dc6b60e41e0cce06ce6ef28c82d7239", "ext": "java", "lang": "Java", "content": "public class Julius {\n\n\tpublic static void test() throws FileNotFoundException {\n\t\tif (!Settings.julius_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_bin.getAbsolutePath());\n\t\tif (!Settings.julius_mklm_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());\n\t\t// TODO: check config files, etc...\n\t}\n\n\tpublic static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {\n\n\t\tString[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), \"-C\", conf.getAbsolutePath(), \"-filelist\",\n\t\t\t\tfilelist.getAbsolutePath(), \"-v\", dic.getAbsolutePath(), \"-d\", binlm.getAbsolutePath() };\n\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\n\t\tLog.verbose(\"julius: \" + filelist.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\n\tpublic static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {\n\t\tString[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), \"-nrl\", model_bkwd.getAbsolutePath(),\n\t\t\t\tbinlm.getAbsolutePath() };\n\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\n\t\tLog.verbose(\"mkbingram: \" + model_bkwd.getName() + \" -> \" + binlm.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\n\tpublic static Segmentation align(File sound, File text) throws IOException, RuntimeException {\n\n\t\tFile files[] = new File[] { sound };\n\t\tFile conf = new File(\"julius_model/julius.jconf\");\n\n\t\tFile scp = new File(Settings.temp_dir, \"julius.scp\");\n\t\tFile vocab = new File(Settings.temp_dir, \"julius.voc\");\n\t\tFile dict = new File(Settings.temp_dir, \"julius.dic\");\n\t\tFile model = new File(Settings.temp_dir, \"julius.lm\");\n\t\tFile text_b = new File(Settings.temp_dir, \"julius_rev.txt\");\n\t\tFile binlm = new File(Settings.temp_dir, \"julius.jlm\");\n\n\t\t// FileUtils.makeVocab(text, vocab);\n\n\t\tFileUtils.reverse(text, text_b);\n\n\t\tNGram.srilm_estimate(text_b, vocab, model, 3);\n\n\t\tmkbingram(model, binlm);\n\n\t\tTranscriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);\n\t\tFileUtils.makeSCPFile(scp, files, false);\n\n\t\tLog.verbose(\"Running julius...\");\n\t\tjulius(conf, scp, dict, binlm);\n\n\t\tLog.verbose(\"Parsing julius output...\");\n\t\tString soundname = sound.getAbsolutePath();\n\t\tsoundname = soundname.substring(0, soundname.lastIndexOf('.'));\n\t\tFile outfile = new File(soundname + \".out\");\n\t\tVector<JuliusOutput> julouts = null;\n\n\t\tjulouts = JuliusOutput.loadFromJulius(outfile);\n\n\t\tif (julouts.isEmpty())\n\t\t\tthrow new RuntimeException(\"Julius didn't provide any outputs!\");\n\n\t\tSegmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);\n\n\t\tfor (int i = 1; i < julouts.size(); i++) {\n\t\t\tdouble offset = ret.tiers.get(0).max();\n\t\t\tret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Unit tests.\n\t * \n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\tLocale.setDefault(Locale.ENGLISH);\n\n\t\t\tLog.init(\"JuliusUnitTest\", false);\n\n\t\t\tTranscriber.init();\n\t\t\tTranscriber.test();\n\n\t\t\tSegmentation seg = align(new File(\"/home/guest/Desktop/Respeaking/test/kopacz.wav\"),\n\t\t\t\t\tnew File(\"/home/guest/Desktop/Respeaking/test/kopacz.txt\"));\n\n\t\t\tTextGrid grid = new TextGrid(seg);\n\n\t\t\tgrid.write(new File(\"/home/guest/Desktop/Respeaking/test/out.TextGrid\"));\n\n\t\t\tLog.info(\"Julius Test complete!\");\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "class_id": 0, "repo": "danijel3/KaldiJava", "file": "src/main/java/pl/edu/pjwstk/kaldi/programs/Julius.java", "last_update_at": "2021-09-30T09:16:45+00:00", "question_id": "aec0215d4dc6b60e41e0cce06ce6ef28c82d7239", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Julius {\n\tpublic static void test() throws FileNotFoundException {\n\t\tif (!Settings.julius_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_bin.getAbsolutePath());\n\t\tif (!Settings.julius_mklm_bin.exists())\n\t\t\tthrow new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());\n\t\t// TODO: check config files, etc...\n\t}\n\tpublic static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {\n\t\tString[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), \"-C\", conf.getAbsolutePath(), \"-filelist\",\n\t\t\t\tfilelist.getAbsolutePath(), \"-v\", dic.getAbsolutePath(), \"-d\", binlm.getAbsolutePath() };\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\t\tLog.verbose(\"julius: \" + filelist.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\tpublic static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {\n\t\tString[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), \"-nrl\", model_bkwd.getAbsolutePath(),\n\t\t\t\tbinlm.getAbsolutePath() };\n\t\tProgramLauncher launcher = new ProgramLauncher(cmd);\n\t\tlauncher.setStdoutStream(new Log.Stream());\n\t\tlauncher.setStderrStream(new Log.Stream(\"ERR>>\"));\n\t\tLog.verbose(\"mkbingram: \" + model_bkwd.getName() + \" -> \" + binlm.getName());\n\t\tlauncher.run();\n\t\tLog.verbose(\"Done.\");\n\t\tif (launcher.getReturnValue() != 0)\n\t\t\tthrow new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n\t}\n\tpublic static Segmentation align(File sound, File text) throws IOException, RuntimeException {\n\t\tFile files[] = new File[] { sound };\n\t\tFile conf = new File(\"julius_model/julius.jconf\");\n\t\tFile scp = new File(Settings.temp_dir, \"julius.scp\");\n\t\tFile vocab = new File(Settings.temp_dir, \"julius.voc\");\n\t\tFile dict = new File(Settings.temp_dir, \"julius.dic\");\n\t\tFile model = new File(Settings.temp_dir, \"julius.lm\");\n\t\tFile text_b = new File(Settings.temp_dir, \"julius_rev.txt\");\n\t\tFile binlm = new File(Settings.temp_dir, \"julius.jlm\");\n\t\t// FileUtils.makeVocab(text, vocab);\n\t\tFileUtils.reverse(text, text_b);\n\t\tNGram.srilm_estimate(text_b, vocab, model, 3);\n\t\tmkbingram(model, binlm);\n\t\tTranscriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);\n\t\tFileUtils.makeSCPFile(scp, files, false);\n\t\tLog.verbose(\"Running julius...\");\n\t\tjulius(conf, scp, dict, binlm);\n\t\tLog.verbose(\"Parsing julius output...\");\n\t\tString soundname = sound.getAbsolutePath();\n\t\tsoundname = soundname.substring(0, soundname.lastIndexOf('.'));\n\t\tFile outfile = new File(soundname + \".out\");\n\t\tVector<JuliusOutput> julouts = null;\n\t\tjulouts = JuliusOutput.loadFromJulius(outfile);\n\t\tif (julouts.isEmpty())\n\t\t\tthrow new RuntimeException(\"Julius didn't provide any outputs!\");\n\t\tSegmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);\n\t\tfor (int i = 1; i < julouts.size(); i++) {\n\t\t\tdouble offset = ret.tiers.get(0).max();\n\t\t\tret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);\n\t\t}\n\t\treturn ret;\n\t}\n\t/**\n\t * Unit tests.\n\t * \n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.ENGLISH);\n\t\t\tLog.init(\"JuliusUnitTest\", false);\n\t\t\tTranscriber.init();\n\t\t\tTranscriber.test();\n\t\t\tSegmentation seg = align(new File(\"/home/guest/Desktop/Respeaking/test/kopacz.wav\"),\n\t\t\t\t\tnew File(\"/home/guest/Desktop/Respeaking/test/kopacz.txt\"));\n\t\t\tTextGrid grid = new TextGrid(seg);\n\t\t\tgrid.write(new File(\"/home/guest/Desktop/Respeaking/test/out.TextGrid\"));\n\t\t\tLog.info(\"Julius Test complete!\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n"]]}
{"hexsha": "67b397e218f28a428fff73d04687e53b5722b22e", "ext": "java", "lang": "Java", "content": "public class RDateTest {\n\n    @Test\n    public void testOf1() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));\n    }\n\n    @Test\n    public void testOf2() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));\n        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));\n    }\n\n    @Test\n    public void testOf3() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));\n        // Normal cases are handled by the converter test.\n    }\n\n    @Test\n    public void testOfInvalidSpecialDay() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));\n\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));\n        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));\n    }\n\n    @Test\n    public void testDecade() {\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());\n    }\n\n    @Test\n    public void testIsBefore() {\n        RDate d1 = RDate.of(6, RMonth.Floreal, 4);\n        RDate d2 = RDate.of(6, RMonth.Floreal, 5);\n        assertTrue(d1.isBefore(d2));\n        assertFalse(d2.isBefore(d1));\n        assertFalse(d1.isBefore(d1));\n        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));\n        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));\n    }\n\n    @Test\n    public void testIsSextile() {\n        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());\n    }\n\n    @Test\n    public void testIsSpecialDay() {\n        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());\n        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());\n    }\n\n    @Test\n    public void testGetSpecialDay() {\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());\n    }\n\n    @Test\n    public void testPlusDays_success() {\n        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));\n        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));\n        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));\n        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));\n    }\n\n    @Test\n    public void testPlusDays_invalid() {\n        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));\n    }\n\n    @Test\n    public void testCompareTo() {\n        RDate rd = RDate.of(12, RMonth.Brumaire, 18);\n        assertEquals(-1, rd.compareTo(null));\n        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);\n        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));\n    }\n\n    @Test\n    public void testEquals() {\n        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);\n        RDate rd2 = RDate.of(12, 2, 18);\n        assertEquals(rd1, rd2);\n        assertNotEquals(rd1, new Object());\n        assertNotEquals(rd1, null);\n        assertEquals(rd2.hashCode(), rd1.hashCode());\n    }\n}", "class_id": 0, "repo": "jarnaud/republican-calendar", "file": "src/test/java/com/github/jarnaud/republican/RDateTest.java", "last_update_at": "2021-04-13T16:23:41+00:00", "question_id": "67b397e218f28a428fff73d04687e53b5722b22e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RDateTest {\n    @Test\n    public void testOf1() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));\n    }\n    @Test\n    public void testOf2() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));\n        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));\n    }\n    @Test\n    public void testOf3() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));\n        // Normal cases are handled by the converter test.\n    }\n    @Test\n    public void testOfInvalidSpecialDay() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));\n        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));\n    }\n    @Test\n    public void testDecade() {\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());\n    }\n    @Test\n    public void testIsBefore() {\n        RDate d1 = RDate.of(6, RMonth.Floreal, 4);\n        RDate d2 = RDate.of(6, RMonth.Floreal, 5);\n        assertTrue(d1.isBefore(d2));\n        assertFalse(d2.isBefore(d1));\n        assertFalse(d1.isBefore(d1));\n        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));\n        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));\n    }\n    @Test\n    public void testIsSextile() {\n        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());\n    }\n    @Test\n    public void testIsSpecialDay() {\n        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());\n        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());\n    }\n    @Test\n    public void testGetSpecialDay() {\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());\n    }\n    @Test\n    public void testPlusDays_success() {\n        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));\n        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));\n        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));\n        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));\n    }\n    @Test\n    public void testPlusDays_invalid() {\n        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));\n    }\n    @Test\n    public void testCompareTo() {\n        RDate rd = RDate.of(12, RMonth.Brumaire, 18);\n        assertEquals(-1, rd.compareTo(null));\n        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);\n        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));\n    }\n    @Test\n    public void testEquals() {\n        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);\n        RDate rd2 = RDate.of(12, 2, 18);\n        assertEquals(rd1, rd2);\n        assertNotEquals(rd1, new Object());\n        assertNotEquals(rd1, null);\n        assertEquals(rd2.hashCode(), rd1.hashCode());\n    }\n"]]}
{"hexsha": "f93ae094e9bce6ccecad58faf15cf654916b969b", "ext": "java", "lang": "Java", "content": "public class ProjectSaver {\n    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {\n        if (projectDef.getFileName() == null)\n            throw new IllegalArgumentException(\"Built-in projects cannot be exported.\");\n        final Path directory = Paths.get(rootDirectory);\n        if (!Files.exists(directory))\n            throw new IllegalArgumentException(\"Directory does not exist.\");\n\n        saveProjectFile(projectDef, directory);\n        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values())\n            saveNamespace(namespaceDef, directory);\n\n    }\n\n    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {\n        final ProjectFile projectFile = new ProjectFile();\n        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);\n        projectFile.Sources = new ProjectSource[]{new ProjectSource()};\n\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {\n            gson.toJson(projectFile, writer);\n        }\n    }\n\n    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {\n        Path currentDirectory = directory;\n        for (String component : namespaceDef.getNamespace().split(\"\\\\.\")) {\n            currentDirectory = currentDirectory.resolve(component);\n            Files.createDirectories(currentDirectory);\n        }\n\n        for (FileDef fileDef : namespaceDef.getFiles().values()) {\n            final CodeWriter writer = new CodeWriter(4);\n            writer.writeLine(String.format(\"namespace %s;\", namespaceDef.getNamespace()));\n\n            if (fileDef.getImports().size() > 0) {\n                writer.newLine();\n                for (ImportDef importDef : fileDef.getImports()) {\n                    switch (importDef.getKind()) {\n                        case NAMESPACE:\n                            writer.writeLine(String.format(\"import %s.*;\", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));\n                            break;\n\n                        case TYPE:\n                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;\n                            writer.writeLine(importTypeDef.getAlias() == null\n                                ? String.format(\"import %s.%s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName())\n                                : String.format(\"import %s.%s as %s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));\n                            break;\n\n                        default:\n                            throw new IllegalArgumentException(\"Type of import directive is unknown: \" + importDef.getKind());\n                    }\n                }\n            }\n\n            if (fileDef.getOptions().size() > 0) {\n                writer.newLine();\n                for (NameValuePair option : fileDef.getOptions())\n                    writer.writeLine(String.format(\"option %s = %s;\", option.getName(), option.getValue().toString()));\n            }\n\n            saveTypeScope(fileDef, writer);\n\n            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {\n                writer.saveTo(stream);\n            }\n        }\n    }\n\n    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {\n        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {\n            writer.newLine();\n            saveDecorator(decoratorDef, writer);\n        }\n        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {\n            writer.newLine();\n            saveEnumeration(enumerationDef, writer);\n        }\n        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {\n            writer.newLine();\n            saveInterface(interfaceDef, writer);\n        }\n        for (ClassDef classDef : scope.getDefinedClasses()) {\n            writer.newLine();\n            saveClass(classDef, writer);\n        }\n    }\n\n    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {\n        saveComments(decoratorDef, writer);\n        saveDecorators(decoratorDef, writer);\n\n        writer.write(String.format(\"decorator %s {\", decoratorDef.getName()));\n        writer.indent();\n\n        if (decoratorDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(decoratorDef, writer);\n        }\n\n        saveTypeScope(decoratorDef, writer);\n\n        if (decoratorDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < decoratorDef.getProperties().size(); i += 1) {\n                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s %s;\", propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s %s = %s;\", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < decoratorDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static String luminaryTypeName(IntegralType type) {\n        switch (type) {\n            case INT8:\n                return \"Int8\";\n\n            case UINT8:\n                return \"Int8\";\n\n            case INT16:\n                return \"Int8\";\n\n            case UINT16:\n                return \"Int8\";\n\n            case INT32:\n                return \"Int8\";\n\n            case UINT32:\n                return \"Int8\";\n\n            case INT64:\n                return \"Int8\";\n\n            case UINT64:\n                return \"Int8\";\n\n            default:\n                throw new IllegalArgumentException(\"Integral type '\" + type + \"' is unknown.\");\n        }\n    }\n\n    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {\n        saveComments(enumerationDef, writer);\n        saveDecorators(enumerationDef, writer);\n\n        writer.write(String.format(\"enum %s : %s {\", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));\n        writer.indent();\n\n        if (enumerationDef.getMembers().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < enumerationDef.getMembers().size(); i += 1) {\n                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);\n                saveComments(memberDef, writer);\n                saveDecorators(memberDef, writer);\n\n                writer.writeLine(String.format(\"%s = %s;\", memberDef.getName(), memberDef.getValue().toString()));\n                if (i + 1 < enumerationDef.getMembers().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {\n        saveComments(interfaceDef, writer);\n        saveDecorators(interfaceDef, writer);\n\n        writer.write(String.format(\"interface %s \", interfaceDef.getName()));\n        if (interfaceDef.getSuperInterfaces().size() > 0) {\n            writer.write(\": \" + interfaceDef.getSuperInterfaces().get(0).getName());\n            for (int i = 1; i < interfaceDef.getSuperInterfaces().size(); i += 1)\n                writer.write(\", \" + interfaceDef.getSuperInterfaces().get(i).getName());\n        }\n        writer.write(\" {\");\n        writer.indent();\n\n        saveTypeScope(interfaceDef, writer);\n\n        if (interfaceDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < interfaceDef.getProperties().size(); i += 1) {\n                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n\n                writer.write(String.format(\"%s %s\", propertyDef.getType().toString(), propertyDef.getName()));\n                if (propertyDef.isReadable())\n                    writer.write(\" get\");\n                if (propertyDef.isWritable())\n                    writer.write(\" set\");\n                writer.writeLine(\";\");\n                if (i + 1 < interfaceDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveClass(ClassDef classDef, CodeWriter writer) {\n        saveComments(classDef, writer);\n        saveDecorators(classDef, writer);\n\n        writer.write(String.format(classDef.isFinal() ? \"final class\" : \"class %s\", classDef.getName()));\n        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {\n            boolean isFirst = true;\n            if (classDef.getSuperClass() != null) {\n                isFirst = false;\n                writer.write(String.format(\": %s\", classDef.getSuperClass().getName()));\n            }\n            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {\n                if (isFirst) {\n                    isFirst = false;\n                    writer.write(String.format(\": %s\", superInterfaceDef.getName()));\n                } else\n                    writer.write(String.format(\", %s\", superInterfaceDef.getName()));\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n\n        if (classDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(classDef, writer);\n        }\n\n        saveTypeScope(classDef, writer);\n\n        if (classDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < classDef.getProperties().size(); i += 1) {\n                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n\n                final String prefix = propertyDef.isFinal()\n                    ? (propertyDef.isOverride() ? \"final override \" : \"final \")\n                    : (propertyDef.isOverride() ? \"override \" : \"\");\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s%s %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s%s %s = %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < classDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveComments(ItemDef commentable, CodeWriter writer) {\n        for (String comment : commentable.getComments())\n            writer.writeLine(\"/// \" + comment);\n    }\n\n    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {\n        for (Decorator decorator : decoratable.getDecorators()) {\n            final DecoratorDef decoratorDef = decorator.getDefinition();\n            writer.write(String.format(\"[%s\", decoratorDef.getName()));\n\n            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {\n                writer.write(\"(\");\n\n                boolean isFirst = true;\n                for (int i = 0; i < decorator.getArguments().size(); i += 1) {\n                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();\n                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {\n                        if (!isFirst)\n                            writer.write(\", \");\n                        else\n                            isFirst = false;\n\n                        writer.write(String.format(\"%s = %s\", propertyDef.getName(), decorator.getArguments().get(i).getValue()));\n                    }\n                }\n\n                writer.write(\")\");\n            }\n\n            writer.writeLine(\"]\");\n        }\n    }\n\n    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {\n        for (int i = 0; i < constantScope.getDefinedConstants().size(); i += 1) {\n            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);\n            saveComments(constantDef, writer);\n            saveDecorators(constantDef, writer);\n            writer.writeLine(String.format(\"const %s %s = %s;\", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));\n            if (i + 1 < constantScope.getDefinedConstants().size())\n                writer.newLine();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final ProjectLoader loader = new ProjectLoader();\n        System.setProperty(\"luminary.search.path\", \"C:\\\\Projects\\\\MaxiMarkets\\\\ProtocolGenerators\\\\luminary\");\n        final ProjectDef projectDef = loader.load(\"C:\\\\Projects\\\\MaxiMarkets\\\\TradingServer\\\\luminary\\\\External\\\\External.json\");\n        ProjectSaver.save(projectDef, \"D:\\\\Temporary\\\\Luminary\");\n    }\n}", "class_id": 0, "repo": "DeltixInc/Luminary", "file": "java/src/main/java/deltix/luminary/ProjectSaver.java", "last_update_at": "2021-08-19T12:50:45+00:00", "question_id": "f93ae094e9bce6ccecad58faf15cf654916b969b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProjectSaver {\n    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {\n        if (projectDef.getFileName() == null)\n            throw new IllegalArgumentException(\"Built-in projects cannot be exported.\");\n        final Path directory = Paths.get(rootDirectory);\n        if (!Files.exists(directory))\n            throw new IllegalArgumentException(\"Directory does not exist.\");\n        saveProjectFile(projectDef, directory);\n        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values())\n            saveNamespace(namespaceDef, directory);\n    }\n    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {\n        final ProjectFile projectFile = new ProjectFile();\n        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);\n        projectFile.Sources = new ProjectSource[]{new ProjectSource()};\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {\n            gson.toJson(projectFile, writer);\n        }\n    }\n    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {\n        Path currentDirectory = directory;\n        for (String component : namespaceDef.getNamespace().split(\"\\\\.\")) {\n            currentDirectory = currentDirectory.resolve(component);\n            Files.createDirectories(currentDirectory);\n        }\n        for (FileDef fileDef : namespaceDef.getFiles().values()) {\n            final CodeWriter writer = new CodeWriter(4);\n            writer.writeLine(String.format(\"namespace %s;\", namespaceDef.getNamespace()));\n            if (fileDef.getImports().size() > 0) {\n                writer.newLine();\n                for (ImportDef importDef : fileDef.getImports()) {\n                    switch (importDef.getKind()) {\n                        case NAMESPACE:\n                            writer.writeLine(String.format(\"import %s.*;\", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));\n                            break;\n                        case TYPE:\n                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;\n                            writer.writeLine(importTypeDef.getAlias() == null\n                                ? String.format(\"import %s.%s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName())\n                                : String.format(\"import %s.%s as %s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));\n                            break;\n                        default:\n                            throw new IllegalArgumentException(\"Type of import directive is unknown: \" + importDef.getKind());\n                    }\n                }\n            }\n            if (fileDef.getOptions().size() > 0) {\n                writer.newLine();\n                for (NameValuePair option : fileDef.getOptions())\n                    writer.writeLine(String.format(\"option %s = %s;\", option.getName(), option.getValue().toString()));\n            }\n            saveTypeScope(fileDef, writer);\n            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {\n                writer.saveTo(stream);\n            }\n        }\n    }\n    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {\n        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {\n            writer.newLine();\n            saveDecorator(decoratorDef, writer);\n        }\n        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {\n            writer.newLine();\n            saveEnumeration(enumerationDef, writer);\n        }\n        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {\n            writer.newLine();\n            saveInterface(interfaceDef, writer);\n        }\n        for (ClassDef classDef : scope.getDefinedClasses()) {\n            writer.newLine();\n            saveClass(classDef, writer);\n        }\n    }\n    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {\n        saveComments(decoratorDef, writer);\n        saveDecorators(decoratorDef, writer);\n        writer.write(String.format(\"decorator %s {\", decoratorDef.getName()));\n        writer.indent();\n        if (decoratorDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(decoratorDef, writer);\n        }\n        saveTypeScope(decoratorDef, writer);\n        if (decoratorDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < decoratorDef.getProperties().size(); i += 1) {\n                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s %s;\", propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s %s = %s;\", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < decoratorDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static String luminaryTypeName(IntegralType type) {\n        switch (type) {\n            case INT8:\n                return \"Int8\";\n            case UINT8:\n                return \"Int8\";\n            case INT16:\n                return \"Int8\";\n            case UINT16:\n                return \"Int8\";\n            case INT32:\n                return \"Int8\";\n            case UINT32:\n                return \"Int8\";\n            case INT64:\n                return \"Int8\";\n            case UINT64:\n                return \"Int8\";\n            default:\n                throw new IllegalArgumentException(\"Integral type '\" + type + \"' is unknown.\");\n        }\n    }\n    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {\n        saveComments(enumerationDef, writer);\n        saveDecorators(enumerationDef, writer);\n        writer.write(String.format(\"enum %s : %s {\", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));\n        writer.indent();\n        if (enumerationDef.getMembers().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < enumerationDef.getMembers().size(); i += 1) {\n                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);\n                saveComments(memberDef, writer);\n                saveDecorators(memberDef, writer);\n                writer.writeLine(String.format(\"%s = %s;\", memberDef.getName(), memberDef.getValue().toString()));\n                if (i + 1 < enumerationDef.getMembers().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {\n        saveComments(interfaceDef, writer);\n        saveDecorators(interfaceDef, writer);\n        writer.write(String.format(\"interface %s \", interfaceDef.getName()));\n        if (interfaceDef.getSuperInterfaces().size() > 0) {\n            writer.write(\": \" + interfaceDef.getSuperInterfaces().get(0).getName());\n            for (int i = 1; i < interfaceDef.getSuperInterfaces().size(); i += 1)\n                writer.write(\", \" + interfaceDef.getSuperInterfaces().get(i).getName());\n        }\n        writer.write(\" {\");\n        writer.indent();\n        saveTypeScope(interfaceDef, writer);\n        if (interfaceDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < interfaceDef.getProperties().size(); i += 1) {\n                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                writer.write(String.format(\"%s %s\", propertyDef.getType().toString(), propertyDef.getName()));\n                if (propertyDef.isReadable())\n                    writer.write(\" get\");\n                if (propertyDef.isWritable())\n                    writer.write(\" set\");\n                writer.writeLine(\";\");\n                if (i + 1 < interfaceDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static void saveClass(ClassDef classDef, CodeWriter writer) {\n        saveComments(classDef, writer);\n        saveDecorators(classDef, writer);\n        writer.write(String.format(classDef.isFinal() ? \"final class\" : \"class %s\", classDef.getName()));\n        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {\n            boolean isFirst = true;\n            if (classDef.getSuperClass() != null) {\n                isFirst = false;\n                writer.write(String.format(\": %s\", classDef.getSuperClass().getName()));\n            }\n            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {\n                if (isFirst) {\n                    isFirst = false;\n                    writer.write(String.format(\": %s\", superInterfaceDef.getName()));\n                } else\n                    writer.write(String.format(\", %s\", superInterfaceDef.getName()));\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n        if (classDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(classDef, writer);\n        }\n        saveTypeScope(classDef, writer);\n        if (classDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < classDef.getProperties().size(); i += 1) {\n                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                final String prefix = propertyDef.isFinal()\n                    ? (propertyDef.isOverride() ? \"final override \" : \"final \")\n                    : (propertyDef.isOverride() ? \"override \" : \"\");\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s%s %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s%s %s = %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < classDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n    private static void saveComments(ItemDef commentable, CodeWriter writer) {\n        for (String comment : commentable.getComments())\n            writer.writeLine(\"/// \" + comment);\n    }\n    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {\n        for (Decorator decorator : decoratable.getDecorators()) {\n            final DecoratorDef decoratorDef = decorator.getDefinition();\n            writer.write(String.format(\"[%s\", decoratorDef.getName()));\n            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {\n                writer.write(\"(\");\n                boolean isFirst = true;\n                for (int i = 0; i < decorator.getArguments().size(); i += 1) {\n                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();\n                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {\n                        if (!isFirst)\n                            writer.write(\", \");\n                        else\n                            isFirst = false;\n                        writer.write(String.format(\"%s = %s\", propertyDef.getName(), decorator.getArguments().get(i).getValue()));\n                    }\n                }\n                writer.write(\")\");\n            }\n            writer.writeLine(\"]\");\n        }\n    }\n    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {\n        for (int i = 0; i < constantScope.getDefinedConstants().size(); i += 1) {\n            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);\n            saveComments(constantDef, writer);\n            saveDecorators(constantDef, writer);\n            writer.writeLine(String.format(\"const %s %s = %s;\", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));\n            if (i + 1 < constantScope.getDefinedConstants().size())\n                writer.newLine();\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        final ProjectLoader loader = new ProjectLoader();\n        System.setProperty(\"luminary.search.path\", \"C:\\\\Projects\\\\MaxiMarkets\\\\ProtocolGenerators\\\\luminary\");\n        final ProjectDef projectDef = loader.load(\"C:\\\\Projects\\\\MaxiMarkets\\\\TradingServer\\\\luminary\\\\External\\\\External.json\");\n        ProjectSaver.save(projectDef, \"D:\\\\Temporary\\\\Luminary\");\n    }\n"]]}
{"hexsha": "b03dd0c9940a7be99af35e2cda606850ecc8f431", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(\"/applications\")\npublic class ApplicationCrudController extends AbstractCrudController<Application> {\n\tprivate static final String[] ALLOWED_FIELDS = new String[] {\n\t\t\"name\", \"shortDescription\", \"scm.user\", \"scm.repo\"\n\t};\n\t\n\t@Inject private ApplicationService applicationService;\n\t@Inject private FarmService farmService;\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getService()\n\t */\n\t@Override\n\tpublic CIService<Application> getService() { return applicationService; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()\n\t */\n\t@Override\n\tprotected String[] getAllowedFields() { return ALLOWED_FIELDS; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)\n\t */\n\t@Override\n\tprotected Application doGetDetails(Long id, Model model) {\n\t\tApplication app = getService().findOne(id);\n\t\tList<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));\n\t\tmodel.addAttribute(farms);\n\t\treturn app;\n\t}\n}", "class_id": 0, "repo": "williewheeler/zkybase", "file": "ui/src/main/java/org/zkybase/web/controller/application/ApplicationCrudController.java", "last_update_at": "2021-11-12T21:51:18+00:00", "question_id": "b03dd0c9940a7be99af35e2cda606850ecc8f431", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@RequestMapping(\"/applications\")\npublic class ApplicationCrudController extends AbstractCrudController<Application> {\n\tprivate static final String[] ALLOWED_FIELDS = new String[] {\n\t\t\"name\", \"shortDescription\", \"scm.user\", \"scm.repo\"\n\t};\n\t\n\t@Inject private ApplicationService applicationService;\n\t@Inject private FarmService farmService;\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getService()\n\t */\n\t@Override\n\tpublic CIService<Application> getService() { return applicationService; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()\n\t */\n\t@Override\n\tprotected String[] getAllowedFields() { return ALLOWED_FIELDS; }\n\t\n\t/* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)\n\t */\n\t@Override\n\tprotected Application doGetDetails(Long id, Model model) {\n\t\tApplication app = getService().findOne(id);\n\t\tList<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));\n\t\tmodel.addAttribute(farms);\n\t\treturn app;\n\t}\n"]]}
{"hexsha": "f62399e89a1c3106290095c2b907f8016f2f0999", "ext": "java", "lang": "Java", "content": "public class SimilarRatingGraph {\n    public double maxLength(int[] date, int[] rating) {\n    \tint n = date.length;\n    \tdouble ans = 0;\n    \tint[] ps = new int[n - 1];\n    \tint[] qs = new int[n - 1];\n    \tdouble[] hypot = new double[n - 1];\n    \tfor (int i = 0; i + 1 < n; i++) {\n    \t\tps[i] = date[i + 1] - date[i];\n    \t\tqs[i] = rating[i + 1] - rating[i];\n    \t\thypot[i] = Math.hypot(ps[i], qs[i]);\n    \t}\n    \tfor (int i = 0; i < n; i++) {\n    \t\tfor (int j = i + 1; j < n; j++) {\n    \t\t\tlong p01 = 0, p02 = 0;\n    \t\t\tdouble cur = 0;\n    \t\t\tfor (int k = 0;; k++) {\n    \t\t\t\tif (i + k + 1 == n || j + k + 1 == n) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tlong p1 = ps[i + k];\n    \t\t\t\tlong q1 = qs[i + k];\n    \t\t\t\tlong p2 = ps[j + k];\n    \t\t\t\tlong q2 = qs[j + k];\n    \t\t\t\tif (p1 * q2 != p2 * q1) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tif (k == 0) {\n    \t\t\t\t\tp01 = p1;\n    \t\t\t\t\tp02 = p2;\n    \t\t\t\t} else {\n    \t\t\t\t\tif (p1 * p02 != p2 * p01) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif (p1 > p2) {\n    \t\t\t\t\tcur += hypot[i + k];\n    \t\t\t\t} else {\n    \t\t\t\t\tcur += hypot[j + k];\n    \t\t\t\t}\n    \t\t\t\tans = Math.max(ans, cur);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n\n}", "class_id": 0, "repo": "mikhail-dvorkin/competitions", "file": "topcoder/srm635/SimilarRatingGraph.java", "last_update_at": "2021-06-24T10:52:44+00:00", "question_id": "f62399e89a1c3106290095c2b907f8016f2f0999", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimilarRatingGraph {\n    public double maxLength(int[] date, int[] rating) {\n    \tint n = date.length;\n    \tdouble ans = 0;\n    \tint[] ps = new int[n - 1];\n    \tint[] qs = new int[n - 1];\n    \tdouble[] hypot = new double[n - 1];\n    \tfor (int i = 0; i + 1 < n; i++) {\n    \t\tps[i] = date[i + 1] - date[i];\n    \t\tqs[i] = rating[i + 1] - rating[i];\n    \t\thypot[i] = Math.hypot(ps[i], qs[i]);\n    \t}\n    \tfor (int i = 0; i < n; i++) {\n    \t\tfor (int j = i + 1; j < n; j++) {\n    \t\t\tlong p01 = 0, p02 = 0;\n    \t\t\tdouble cur = 0;\n    \t\t\tfor (int k = 0;; k++) {\n    \t\t\t\tif (i + k + 1 == n || j + k + 1 == n) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tlong p1 = ps[i + k];\n    \t\t\t\tlong q1 = qs[i + k];\n    \t\t\t\tlong p2 = ps[j + k];\n    \t\t\t\tlong q2 = qs[j + k];\n    \t\t\t\tif (p1 * q2 != p2 * q1) {\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\tif (k == 0) {\n    \t\t\t\t\tp01 = p1;\n    \t\t\t\t\tp02 = p2;\n    \t\t\t\t} else {\n    \t\t\t\t\tif (p1 * p02 != p2 * p01) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif (p1 > p2) {\n    \t\t\t\t\tcur += hypot[i + k];\n    \t\t\t\t} else {\n    \t\t\t\t\tcur += hypot[j + k];\n    \t\t\t\t}\n    \t\t\t\tans = Math.max(ans, cur);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn ans;\n    }\n"]]}
{"hexsha": "e2ac5750c6ffaf6424160a62dbcfd9d31d5d8011", "ext": "java", "lang": "Java", "content": "public class LOServer {\n\n    /**\n     * Entry point from the command line\n     *\n     * @param args Command line arguments (currently nothing is supported)\n     */\n    public static void main(String[] args) {\n        Game game = new Game();\n        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);\n\n        Javalin app = Javalin.create(config ->\n                config.server(() ->\n                        new Server(queuedThreadPool))).start(7000);\n\n        app.routes(() -> {\n            get(\"/api/state\", ctx -> ctx.json(game.getState()));\n            post(\"/api/update\", ctx -> {\n                if (Objects.equals(ctx.contentType(), \"application/json\")) {\n                    List<Integer> list = ctx.bodyAsClass(List.class);\n                    game.update(list.get(0), list.get(1));\n                    ctx.json(game.getState());\n                }\n            });\n            get(\"/api/reset\", ctx -> {\n                game.reset();\n                ctx.json(game.getState());\n            });\n            get(\"/api/status\", ctx -> {\n                ctx.result(\"OK\");\n            });\n        });\n    }\n}", "class_id": 0, "repo": "codemaxx1/java_lights_out", "file": "server/src/main/java/cs/isu/edu/cs3321/server/LOServer.java", "last_update_at": "2021-11-15T00:20:10+00:00", "question_id": "e2ac5750c6ffaf6424160a62dbcfd9d31d5d8011", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LOServer {\n    /**\n     * Entry point from the command line\n     *\n     * @param args Command line arguments (currently nothing is supported)\n     */\n    public static void main(String[] args) {\n        Game game = new Game();\n        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);\n        Javalin app = Javalin.create(config ->\n                config.server(() ->\n                        new Server(queuedThreadPool))).start(7000);\n        app.routes(() -> {\n            get(\"/api/state\", ctx -> ctx.json(game.getState()));\n            post(\"/api/update\", ctx -> {\n                if (Objects.equals(ctx.contentType(), \"application/json\")) {\n                    List<Integer> list = ctx.bodyAsClass(List.class);\n                    game.update(list.get(0), list.get(1));\n                    ctx.json(game.getState());\n                }\n            });\n            get(\"/api/reset\", ctx -> {\n                game.reset();\n                ctx.json(game.getState());\n            });\n            get(\"/api/status\", ctx -> {\n                ctx.result(\"OK\");\n            });\n        });\n    }\n"]]}
{"hexsha": "54ecda69bf301ee6df3cd3d351eb78aa768b8338", "ext": "java", "lang": "Java", "content": "public class InferenceFrame<V extends Value> extends Frame<V> {\n    private V lostValue;\n\n    public InferenceFrame(int nLocals, int nStack) {\n        super(nLocals, nStack);\n    }\n\n    public InferenceFrame(Frame<? extends V> src) {\n        super(src);\n    }\n\n    public V getLostValue() {\n        return lostValue;\n    }\n\n    public void setLostValue(V lostValue) {\n        this.lostValue = lostValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Frame<V> init(Frame<? extends V> src) {\n        if (!(src instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)src;\n\n        super.init(inferenceFrame);\n\n        this.lostValue = inferenceFrame.lostValue;\n\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {\n        if (!(frame instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)frame;\n\n        boolean changed = super.merge(frame, interpreter);\n\n        if (lostValue == null) {\n            lostValue = inferenceFrame.lostValue;\n            changed |= lostValue != null;\n        } else if (inferenceFrame.lostValue != null) {\n            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);\n            changed |= lostValue != newLostValue;\n            lostValue = newLostValue;\n        }\n\n        return changed;\n    }\n}", "class_id": 0, "repo": "prezi/kannotator", "file": "src/org/jetbrains/kannotator/annotationsInference/engine/InferenceFrame.java", "last_update_at": "2021-11-08T09:49:52+00:00", "question_id": "54ecda69bf301ee6df3cd3d351eb78aa768b8338", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InferenceFrame<V extends Value> extends Frame<V> {\n    private V lostValue;\n    public InferenceFrame(int nLocals, int nStack) {\n        super(nLocals, nStack);\n    }\n    public InferenceFrame(Frame<? extends V> src) {\n        super(src);\n    }\n    public V getLostValue() {\n        return lostValue;\n    }\n    public void setLostValue(V lostValue) {\n        this.lostValue = lostValue;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Frame<V> init(Frame<? extends V> src) {\n        if (!(src instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)src;\n        super.init(inferenceFrame);\n        this.lostValue = inferenceFrame.lostValue;\n        return this;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {\n        if (!(frame instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>)frame;\n        boolean changed = super.merge(frame, interpreter);\n        if (lostValue == null) {\n            lostValue = inferenceFrame.lostValue;\n            changed |= lostValue != null;\n        } else if (inferenceFrame.lostValue != null) {\n            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);\n            changed |= lostValue != newLostValue;\n            lostValue = newLostValue;\n        }\n        return changed;\n    }\n"]]}
{"hexsha": "64bb9c2ab498522d17c515ad45125a5faeadbb58", "ext": "java", "lang": "Java", "content": "public class SaleRepository extends AbstractBaseRepository<Sale> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Sale get(Long id) {\n        Session session = getSession();\n\n        session.beginTransaction();\n\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale WHERE id = :id\", Sale.class);\n        query.setParameter(\"id\", id);\n\n        Sale result = query.getSingleResult();\n\n        session.getTransaction().commit();\n\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<Sale> getAll() {\n        Session session = getSession();\n\n        session.beginTransaction();\n\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale\", Sale.class);\n        List<Sale> result = query.getResultList();\n\n        session.getTransaction().commit();\n\n        return result;\n    }\n}", "class_id": 0, "repo": "clovergaze/dilithium-exchange-manager", "file": "src/main/java/org/infokin/repository/SaleRepository.java", "last_update_at": "2021-05-07T18:19:07+00:00", "question_id": "64bb9c2ab498522d17c515ad45125a5faeadbb58", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SaleRepository extends AbstractBaseRepository<Sale> {\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Sale get(Long id) {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale WHERE id = :id\", Sale.class);\n        query.setParameter(\"id\", id);\n        Sale result = query.getSingleResult();\n        session.getTransaction().commit();\n        return result;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<Sale> getAll() {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale\", Sale.class);\n        List<Sale> result = query.getResultList();\n        session.getTransaction().commit();\n        return result;\n    }\n"]]}
{"hexsha": "2ebc1707a010e070eba98804a31f5ec0cac11d57", "ext": "java", "lang": "Java", "content": "public class ProxyIT {\n\n    private static final int MOCK_SERVER_PORT = 8088;\n    public static final String MOCK_SERVER_BASE_URL = \"http://localhost:\" + MOCK_SERVER_PORT + \"/\";\n\n    private static final int PROXY_SERVER_PORT = 8080;\n    public static final String PROXY_SERVER_BASE_URL = \"http://localhost:\" + PROXY_SERVER_PORT + \"/\";\n\n    private final HttpClient client = new HttpClient();\n    {\n        try {\n            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, \"integration test client\"));\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @ClassRule\n    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);\n\n    @Test\n    public void forwardsSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL + \"boo\")\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n\n        assertEquals(202, response.getStatus());\n\n        Thread.sleep(500);\n\n        verify(postRequestedFor(urlMatching(\"/boo\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n    }\n\n    @Test\n    public void retriesSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(Scenario.STARTED)\n                .willReturn(aResponse().withStatus(503))\n                .willSetStateTo(\"retry1\"));\n\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retry1\")\n                .willReturn(aResponse().withStatus(202))\n                .willSetStateTo(\"retryN\"));\n\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retryN\")\n                .willReturn(aResponse().withStatus(208)));\n\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL)\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n\n        assertEquals(202, response.getStatus());\n\n        Thread.sleep(5000);\n\n        verify(2, postRequestedFor(urlMatching(\"/\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n\n        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:\n        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());\n    }\n\n\n    @Test\n    public void rejectsMalformedUri() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi.\\\"\";\n\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL.replace('/', '\\\\'))\n                .content(new StringContentProvider(body))\n                .send();\n\n        assertEquals(400, response.getStatus());\n    }\n\n    @Test\n    public void rejectsMissingUri() throws Exception {\n        final String body = \"\\\"boo\\\"\";\n\n        ContentResponse response = client.POST(\"http://localhost:\" + PROXY_SERVER_PORT + \"/\")\n                .content(new StringContentProvider(body))\n                .send();\n\n        assertEquals(400, response.getStatus());\n    }\n\n}", "class_id": 0, "repo": "XroadMedia/qproxy", "file": "src/test/java/tv/xrm/qproxy/ProxyIT.java", "last_update_at": "2021-06-17T12:13:24+00:00", "question_id": "2ebc1707a010e070eba98804a31f5ec0cac11d57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProxyIT {\n    private static final int MOCK_SERVER_PORT = 8088;\n    public static final String MOCK_SERVER_BASE_URL = \"http://localhost:\" + MOCK_SERVER_PORT + \"/\";\n    private static final int PROXY_SERVER_PORT = 8080;\n    public static final String PROXY_SERVER_BASE_URL = \"http://localhost:\" + PROXY_SERVER_PORT + \"/\";\n    private final HttpClient client = new HttpClient();\n    {\n        try {\n            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, \"integration test client\"));\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n    @ClassRule\n    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);\n    @Test\n    public void forwardsSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL + \"boo\")\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(500);\n        verify(postRequestedFor(urlMatching(\"/boo\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n    }\n    @Test\n    public void retriesSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi. La cig\u00fce\u00f1a tocaba el saxof\u00f3n detr\u00e1s del palenque de paja.\\\"\";\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(Scenario.STARTED)\n                .willReturn(aResponse().withStatus(503))\n                .willSetStateTo(\"retry1\"));\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retry1\")\n                .willReturn(aResponse().withStatus(202))\n                .willSetStateTo(\"retryN\"));\n        stubFor(post(urlMatching(\"/\"))\n                .inScenario(\"retry\")\n                .whenScenarioStateIs(\"retryN\")\n                .willReturn(aResponse().withStatus(208)));\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL)\n                .content(new StringContentProvider(body))\n                .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                .header(\"Foo-Header\", \"foo\")\n                .send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(5000);\n        verify(2, postRequestedFor(urlMatching(\"/\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:\n        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());\n    }\n    @Test\n    public void rejectsMalformedUri() throws Exception {\n        final String body = \"\\\"El veloz murci\u00e9lago hind\u00fa com\u00eda feliz cardillo y kiwi.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL)\n                .param(\"url\", MOCK_SERVER_BASE_URL.replace('/', '\\\\'))\n                .content(new StringContentProvider(body))\n                .send();\n        assertEquals(400, response.getStatus());\n    }\n    @Test\n    public void rejectsMissingUri() throws Exception {\n        final String body = \"\\\"boo\\\"\";\n        ContentResponse response = client.POST(\"http://localhost:\" + PROXY_SERVER_PORT + \"/\")\n                .content(new StringContentProvider(body))\n                .send();\n        assertEquals(400, response.getStatus());\n    }\n"]]}
{"hexsha": "df29abba1282769ae50dd6b261a43891e13c91c9", "ext": "java", "lang": "Java", "content": "public class SortCapList extends Vector {\n    public SortCap getSortCap(int n) {\n        return (SortCap) get(n);\n    }\n\n    public SortCap getSortCap(String type) {\n        if (type == null) {\n            return null;\n        }\n        int nLists = size();\n        for (int n = 0; n < nLists; n++) {\n            SortCap scap = getSortCap(n);\n            if (type.compareTo(scap.getType()) == 0) {\n                return scap;\n            }\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "tiwer/letv", "file": "src/main/java/org/cybergarage/upnp/std/av/server/object/SortCapList.java", "last_update_at": "2021-09-29T09:31:39+00:00", "question_id": "df29abba1282769ae50dd6b261a43891e13c91c9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SortCapList extends Vector {\n    public SortCap getSortCap(int n) {\n        return (SortCap) get(n);\n    }\n    public SortCap getSortCap(String type) {\n        if (type == null) {\n            return null;\n        }\n        int nLists = size();\n        for (int n = 0; n < nLists; n++) {\n            SortCap scap = getSortCap(n);\n            if (type.compareTo(scap.getType()) == 0) {\n                return scap;\n            }\n        }\n        return null;\n    }\n"]]}
{"hexsha": "d93af83b46884f4e33c75a2aeeab3e3f01c313cc", "ext": "java", "lang": "Java", "content": "public class CoreTests extends TestCase {\n\n    public static Test suite() {\n        TestSuite suite = new TestSuite(CoreTests.class.getName());\n        suite.addTest(AddImportTest.suite());\n        suite.addTest(SourceActionTests.suite());\n        suite.addTest(ASTNodesInsertTest.suite());\n        suite.addTest(BindingsNameTest.suite());\n        suite.addTest(CallHierarchyTest.suite());\n        suite.addTest(ClassPathDetectorTest.suite());\n        suite.addTest(CodeFormatterUtilTest.suite());\n        suite.addTest(CodeFormatterTest.suite());\n        suite.addTest(HierarchicalASTVisitorTest.suite());\n        suite.addTest(ImportOrganizeTest.suite());\n        suite.addTest(ImportOrganizeTest18.suite());\n        suite.addTest(JavaElementLabelsTest.suite());\n        suite.addTest(JavaElementLabelsTest18.suite());\n        suite.addTest(BindingLabelsTest.suite());\n        suite.addTest(BindingLabels18Test.suite());\n        suite.addTest(JavaElementPropertyTesterTest.suite());\n        suite.addTest(JavaModelUtilTest.suite());\n        suite.addTest(MethodOverrideTest.suite());\n        suite.addTest(MethodOverrideTest18.suite());\n        suite.addTest(NameProposerTest.suite());\n        suite.addTest(OverrideTest.suite());\n        suite.addTest(PartialASTTest.suite());\n        suite.addTest(ScopeAnalyzerTest.suite());\n        suite.addTest(TemplateStoreTest.suite());\n        suite.addTest(TypeHierarchyTest.suite());\n        suite.addTest(TypeRulesTest.suite());\n        suite.addTest(TypeInfoTest.suite());\n        suite.addTest(StringsTest.suite());\n        suite.addTest(IndentManipulationTest.suite());\n        suite.addTest(SelectionHistoryTest.suite());\n        suite.addTest(ASTProviderTest.suite());\n        suite.addTest(JDTFlagsTest18.suite());\n        return new ProjectTestSetup(suite);\n    }\n\n    public  CoreTests(String name) {\n        super(name);\n    }\n\n    public static void assertEqualString(String actual, String expected) {\n        StringAsserts.assertEqualString(actual, expected);\n    }\n\n    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {\n        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);\n    }\n\n    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {\n        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);\n    }\n\n    public static void assertNumberOf(String name, int is, int expected) {\n        assertTrue(\"Wrong number of \" + name + \", is: \" + is + \", expected: \" + expected, is == expected);\n    }\n\n    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {\n        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n\n    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {\n        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.ui/10378.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "d93af83b46884f4e33c75a2aeeab3e3f01c313cc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CoreTests extends TestCase {\n    public static Test suite() {\n        TestSuite suite = new TestSuite(CoreTests.class.getName());\n        suite.addTest(AddImportTest.suite());\n        suite.addTest(SourceActionTests.suite());\n        suite.addTest(ASTNodesInsertTest.suite());\n        suite.addTest(BindingsNameTest.suite());\n        suite.addTest(CallHierarchyTest.suite());\n        suite.addTest(ClassPathDetectorTest.suite());\n        suite.addTest(CodeFormatterUtilTest.suite());\n        suite.addTest(CodeFormatterTest.suite());\n        suite.addTest(HierarchicalASTVisitorTest.suite());\n        suite.addTest(ImportOrganizeTest.suite());\n        suite.addTest(ImportOrganizeTest18.suite());\n        suite.addTest(JavaElementLabelsTest.suite());\n        suite.addTest(JavaElementLabelsTest18.suite());\n        suite.addTest(BindingLabelsTest.suite());\n        suite.addTest(BindingLabels18Test.suite());\n        suite.addTest(JavaElementPropertyTesterTest.suite());\n        suite.addTest(JavaModelUtilTest.suite());\n        suite.addTest(MethodOverrideTest.suite());\n        suite.addTest(MethodOverrideTest18.suite());\n        suite.addTest(NameProposerTest.suite());\n        suite.addTest(OverrideTest.suite());\n        suite.addTest(PartialASTTest.suite());\n        suite.addTest(ScopeAnalyzerTest.suite());\n        suite.addTest(TemplateStoreTest.suite());\n        suite.addTest(TypeHierarchyTest.suite());\n        suite.addTest(TypeRulesTest.suite());\n        suite.addTest(TypeInfoTest.suite());\n        suite.addTest(StringsTest.suite());\n        suite.addTest(IndentManipulationTest.suite());\n        suite.addTest(SelectionHistoryTest.suite());\n        suite.addTest(ASTProviderTest.suite());\n        suite.addTest(JDTFlagsTest18.suite());\n        return new ProjectTestSetup(suite);\n    }\n    public  CoreTests(String name) {\n        super(name);\n    }\n    public static void assertEqualString(String actual, String expected) {\n        StringAsserts.assertEqualString(actual, expected);\n    }\n    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {\n        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);\n    }\n    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {\n        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);\n    }\n    public static void assertNumberOf(String name, int is, int expected) {\n        assertTrue(\"Wrong number of \" + name + \", is: \" + is + \", expected: \" + expected, is == expected);\n    }\n    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {\n        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {\n        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n"]]}
{"hexsha": "ffa7aaacd75d5ecdbf2cb0c38e1b729e373cae89", "ext": "java", "lang": "Java", "content": "public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {\n\n\n    private HashMap<String,HashMap<String,int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();\n    private int m_countSpectra = 0;\n    private int m_groups = 10;\n\n\n    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {\n        FragmentationSite fs = f.getFragmentationSites()[0];\n        String[] siteNames = new String[]{fs.NTerm.SequenceID,fs.CTerm.SequenceID};\n\n\n        if (fs.site==0) {\n            siteNames[0] += \"nt\";\n        }\n        if (fs.site == fs.peptide.length() - 1) {\n            siteNames[1] += \"ct\";\n        }\n\n        if (fs.site == match.getLinkingSite(fs.peptide)) {\n            siteNames[0] += \"xl\";\n        }\n\n        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {\n            siteNames[1] += \"xl\";\n        }\n\n        return siteNames;\n\n    }\n\n    protected boolean checkCrosslinked(Fragment f, int linkSide) {\n        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        }\n        return false;\n    }\n\n\n    /**\n     * @return the m_countSpectra\n     */\n    public int getSeenSpectra() {\n        return m_countSpectra;\n    }\n\n\n    // <editor-fold desc=\"construtors\">\n\n    public FragmentationSiteIntensityIonSpecific() {\n    }\n\n    // </editor-fold>\n    \n\n\n    public boolean validFragment(Fragment f) {\n        // no loss and no double fragmentation\n        return (! (f instanceof Loss)) && f.getFragmentationSites().length == 1;\n\n    }\n\n    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {\n        if (f.getFragmentationSites().length != 1) {\n            return false;\n        }\n        if (f instanceof Loss) {\n            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f,charge);\n            return mbf.isBaseFragmentFound();\n        } else\n            return true;\n    }\n\n    private void incrementSite(String n, String c, int group) {\n       HashMap<String,int[]> nGroup = m_FragmentationSiteOccurence.get(n);\n        if (nGroup == null) {\n            nGroup = new HashMap<String, int[]>();\n            int[] cGroup = new int[m_groups + 1];\n            java.util.Arrays.fill(cGroup, 0);\n            cGroup[group] = 1;\n            nGroup.put(c, cGroup);\n            m_FragmentationSiteOccurence.put(n,nGroup);\n        } else {\n            int[] cGroup = nGroup.get(c);\n            if (cGroup == null) {\n                cGroup = new int[m_groups + 1];\n                java.util.Arrays.fill(cGroup, 0);\n                cGroup[group] = 1;\n                nGroup.put(c, cGroup);\n            } else\n                cGroup[group]++;\n\n        }\n    }\n\n\n    public void countSpectraMatch(MatchedXlinkedPeptide match) {\n\n        MatchedFragmentCollection   mfc = match.getMatchedFragments();\n\n\n\n        Spectra deisotoped = match.getSpectrum().deIsotop();\n\n\n        HashMap<String,HashMap<String,Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();\n\n        HashMap<Fragment,Boolean> foundFragments = new HashMap<Fragment, Boolean>();\n\n        // read out all possible fragmentation sites\n        for (Fragment f: match.getPossibleFragments()) {\n            if (validFragment(f)) {\n                foundFragments.put(f, Boolean.FALSE);\n            }\n        }\n\n        // now look if and where we find them\n        // among all peaks sorted by intensity\n        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);\n\n        int group = 0;\n        int peakCount = peaks.size();\n        double groupSize = peakCount/(double)m_groups;\n        int currentPeak = -1;\n        int counted = 0;\n        for (SpectraPeak sp : peaks) {\n            currentPeak++;\n            group = (int) (currentPeak / groupSize);\n//            if (group > 9) {\n//                System.err.println(\"found it\");\n//            }\n\n            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {\n                Fragment f = mf.getFragment();\n                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());\n                \n                // only if the fragment matches the conditions and was not found yet\n                if (canCountFragment(f,mf.getCharge(),mfc) && ! foundFragments.get(mbf.getBaseFragment())) {\n\n                    String[] siteNames = convertFragmentationSite(match, f);\n                    String n = siteNames[0];\n                    String c = siteNames[1];\n\n                    // only if we didn't count that site combination already\n                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);\n                    incrementSite(n,c,group);\n                    counted++;\n \n                }\n            }\n        }\n\n        int found = 0;\n        int missed = 0;\n        // now look at all non matched fragmentation sites\n        for (Fragment f : foundFragments.keySet()) {\n            if (! foundFragments.get(f)) {\n                missed ++;\n\n                String[] siteNames = convertFragmentationSite(match, f);\n                String n = siteNames[0];\n                String c = siteNames[1];\n\n                incrementSite(n,c,m_groups);\n            } else {\n                found++;\n                //System.err.print('.');\n            }\n       }\n       System.err.println(\"counted : \" + counted + \",  found : \" + found + \",  missed : \" + missed);\n\n\n        m_countSpectra++;\n\n        \n\n    }\n\n    @Override\n    public void writeFile(OutputStream output) {\n        PrintStream out = new PrintStream(output);\n        out.print(\"C,N\");\n        for (int i=1;i<=m_groups;i++) {\n            out.print(\",\"+ (100.0 * i/(double)m_groups));\n        }\n        out.print(\", notFound\");\n        out.println(getTable());\n        out.flush();\n    }\n\n\n    public String getTable() {\n        //StringBuffer ret = new StringBuffer(\"#intesity based fragmentation events of aminoacid pairs\\n\");\n        StringBuffer ret = new StringBuffer();\n        String[] nList =  m_FragmentationSiteOccurence.keySet().toArray(new String[0]);\n        java.util.Arrays.sort(nList);\n\n        for (String n : nList) {\n            HashMap<String,int[]> cGroups = m_FragmentationSiteOccurence.get(n);\n            String[] cList = cGroups.keySet().toArray(new String[0]);\n            java.util.Arrays.sort(cList);\n            for (String c : cList) {\n                int[] groups = cGroups.get(c);\n                ret.append(n + \",\" + c);\n                for (int count : groups) {\n                    ret.append(\",\" + count);\n                }\n                ret.append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }\n\n\n}", "class_id": 0, "repo": "MireiaDiaz/XiSearch", "file": "src/main/java/rappsilber/ms/statistics/generator/FragmentationSiteIntensityIonSpecific.java", "last_update_at": "2021-02-16T00:30:24+00:00", "question_id": "ffa7aaacd75d5ecdbf2cb0c38e1b729e373cae89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {\n    private HashMap<String,HashMap<String,int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();\n    private int m_countSpectra = 0;\n    private int m_groups = 10;\n    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {\n        FragmentationSite fs = f.getFragmentationSites()[0];\n        String[] siteNames = new String[]{fs.NTerm.SequenceID,fs.CTerm.SequenceID};\n        if (fs.site==0) {\n            siteNames[0] += \"nt\";\n        }\n        if (fs.site == fs.peptide.length() - 1) {\n            siteNames[1] += \"ct\";\n        }\n        if (fs.site == match.getLinkingSite(fs.peptide)) {\n            siteNames[0] += \"xl\";\n        }\n        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {\n            siteNames[1] += \"xl\";\n        }\n        return siteNames;\n    }\n    protected boolean checkCrosslinked(Fragment f, int linkSide) {\n        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @return the m_countSpectra\n     */\n    public int getSeenSpectra() {\n        return m_countSpectra;\n    }\n    // <editor-fold desc=\"construtors\">\n    public FragmentationSiteIntensityIonSpecific() {\n    }\n    // </editor-fold>\n    public boolean validFragment(Fragment f) {\n        // no loss and no double fragmentation\n        return (! (f instanceof Loss)) && f.getFragmentationSites().length == 1;\n    }\n    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {\n        if (f.getFragmentationSites().length != 1) {\n            return false;\n        }\n        if (f instanceof Loss) {\n            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f,charge);\n            return mbf.isBaseFragmentFound();\n        } else\n            return true;\n    }\n    private void incrementSite(String n, String c, int group) {\n       HashMap<String,int[]> nGroup = m_FragmentationSiteOccurence.get(n);\n        if (nGroup == null) {\n            nGroup = new HashMap<String, int[]>();\n            int[] cGroup = new int[m_groups + 1];\n            java.util.Arrays.fill(cGroup, 0);\n            cGroup[group] = 1;\n            nGroup.put(c, cGroup);\n            m_FragmentationSiteOccurence.put(n,nGroup);\n        } else {\n            int[] cGroup = nGroup.get(c);\n            if (cGroup == null) {\n                cGroup = new int[m_groups + 1];\n                java.util.Arrays.fill(cGroup, 0);\n                cGroup[group] = 1;\n                nGroup.put(c, cGroup);\n            } else\n                cGroup[group]++;\n        }\n    }\n    public void countSpectraMatch(MatchedXlinkedPeptide match) {\n        MatchedFragmentCollection   mfc = match.getMatchedFragments();\n        Spectra deisotoped = match.getSpectrum().deIsotop();\n        HashMap<String,HashMap<String,Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();\n        HashMap<Fragment,Boolean> foundFragments = new HashMap<Fragment, Boolean>();\n        // read out all possible fragmentation sites\n        for (Fragment f: match.getPossibleFragments()) {\n            if (validFragment(f)) {\n                foundFragments.put(f, Boolean.FALSE);\n            }\n        }\n        // now look if and where we find them\n        // among all peaks sorted by intensity\n        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);\n        int group = 0;\n        int peakCount = peaks.size();\n        double groupSize = peakCount/(double)m_groups;\n        int currentPeak = -1;\n        int counted = 0;\n        for (SpectraPeak sp : peaks) {\n            currentPeak++;\n            group = (int) (currentPeak / groupSize);\n//            if (group > 9) {\n//                System.err.println(\"found it\");\n//            }\n            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {\n                Fragment f = mf.getFragment();\n                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());\n                // only if the fragment matches the conditions and was not found yet\n                if (canCountFragment(f,mf.getCharge(),mfc) && ! foundFragments.get(mbf.getBaseFragment())) {\n                    String[] siteNames = convertFragmentationSite(match, f);\n                    String n = siteNames[0];\n                    String c = siteNames[1];\n                    // only if we didn't count that site combination already\n                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);\n                    incrementSite(n,c,group);\n                    counted++;\n                }\n            }\n        }\n        int found = 0;\n        int missed = 0;\n        // now look at all non matched fragmentation sites\n        for (Fragment f : foundFragments.keySet()) {\n            if (! foundFragments.get(f)) {\n                missed ++;\n                String[] siteNames = convertFragmentationSite(match, f);\n                String n = siteNames[0];\n                String c = siteNames[1];\n                incrementSite(n,c,m_groups);\n            } else {\n                found++;\n                //System.err.print('.');\n            }\n       }\n       System.err.println(\"counted : \" + counted + \",  found : \" + found + \",  missed : \" + missed);\n        m_countSpectra++;\n    }\n    @Override\n    public void writeFile(OutputStream output) {\n        PrintStream out = new PrintStream(output);\n        out.print(\"C,N\");\n        for (int i=1;i<=m_groups;i++) {\n            out.print(\",\"+ (100.0 * i/(double)m_groups));\n        }\n        out.print(\", notFound\");\n        out.println(getTable());\n        out.flush();\n    }\n    public String getTable() {\n        //StringBuffer ret = new StringBuffer(\"#intesity based fragmentation events of aminoacid pairs\\n\");\n        StringBuffer ret = new StringBuffer();\n        String[] nList =  m_FragmentationSiteOccurence.keySet().toArray(new String[0]);\n        java.util.Arrays.sort(nList);\n        for (String n : nList) {\n            HashMap<String,int[]> cGroups = m_FragmentationSiteOccurence.get(n);\n            String[] cList = cGroups.keySet().toArray(new String[0]);\n            java.util.Arrays.sort(cList);\n            for (String c : cList) {\n                int[] groups = cGroups.get(c);\n                ret.append(n + \",\" + c);\n                for (int count : groups) {\n                    ret.append(\",\" + count);\n                }\n                ret.append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }\n"]]}
{"hexsha": "3ede65710f688d01a47e728a22d61210d6155313", "ext": "java", "lang": "Java", "content": "public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest\n        implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {\n\n    public static final String COLOR = \"color\";\n    public static final String IS_MUTED = \"is_muted\";\n    public static final String PIN_TO_TOP = \"pin_to_top\";\n    public static final String DESKTOP_NOTIFICATIONS = \"desktop_notifications\";\n    public static final String AUDIBLE_NOTIFICATIONS = \"audible_notifications\";\n    public static final String PUSH_NOTIFICATIONS = \"push_notifications\";\n    public static final String EMAIL_NOTIFICATIONS = \"email_notifications\";\n    public static final String SUBSCRIPTION_DATA = \"subscription_data\";\n\n    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();\n\n    /**\n     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.\n     *\n     * @param client The Zulip HTTP client\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {\n        super(client);\n    }\n\n    /**\n     * Sets the hex value of the color to display on the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  color    The hex value of the color\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {\n        addSetting(streamId, COLOR, color);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be muted.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {\n        addSetting(streamId, IS_MUTED, muted);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be pinned to the top in the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {\n        addSetting(streamId, PIN_TO_TOP, pinToTop);\n        return this;\n    }\n\n    /**\n     * Sets whether to show desktop notifications for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {\n        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to play a sound for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {\n        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId          The id of the stream for which the setting should be updated\n     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push\n     *                           notifications.\n     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {\n        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId           The id of the stream for which the setting should be updated\n     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.\n     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {\n        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);\n        return this;\n    }\n\n    private void addSetting(long streamId, String property, Object value) {\n        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);\n        settings.remove(setting);\n        settings.add(setting);\n    }\n\n    /**\n     * Executes the Zulip API request for updating stream subscription settings.\n     *\n     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}\n     * @throws ZulipClientException if the request was not successful\n     */\n    @Override\n    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {\n        putParamAsJsonString(SUBSCRIPTION_DATA, settings);\n\n        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(),\n                UpdateStreamSubscriptionSettingsApiResponse.class);\n        return response.getSubscriptionData();\n    }\n}", "class_id": 0, "repo": "mrchaos/zulip-java-client", "file": "src/main/java/com/github/jamesnetherton/zulip/client/api/stream/request/UpdateStreamSubscriptionSettingsApiRequest.java", "last_update_at": "2021-12-10T13:20:55+00:00", "question_id": "3ede65710f688d01a47e728a22d61210d6155313", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest\n        implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {\n    public static final String COLOR = \"color\";\n    public static final String IS_MUTED = \"is_muted\";\n    public static final String PIN_TO_TOP = \"pin_to_top\";\n    public static final String DESKTOP_NOTIFICATIONS = \"desktop_notifications\";\n    public static final String AUDIBLE_NOTIFICATIONS = \"audible_notifications\";\n    public static final String PUSH_NOTIFICATIONS = \"push_notifications\";\n    public static final String EMAIL_NOTIFICATIONS = \"email_notifications\";\n    public static final String SUBSCRIPTION_DATA = \"subscription_data\";\n    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();\n    /**\n     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.\n     *\n     * @param client The Zulip HTTP client\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {\n        super(client);\n    }\n    /**\n     * Sets the hex value of the color to display on the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  color    The hex value of the color\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {\n        addSetting(streamId, COLOR, color);\n        return this;\n    }\n    /**\n     * Sets whether the stream should be muted.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {\n        addSetting(streamId, IS_MUTED, muted);\n        return this;\n    }\n    /**\n     * Sets whether the stream should be pinned to the top in the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {\n        addSetting(streamId, PIN_TO_TOP, pinToTop);\n        return this;\n    }\n    /**\n     * Sets whether to show desktop notifications for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {\n        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);\n        return this;\n    }\n    /**\n     * Sets whether to play a sound for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {\n        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);\n        return this;\n    }\n    /**\n     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId          The id of the stream for which the setting should be updated\n     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push\n     *                           notifications.\n     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {\n        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);\n        return this;\n    }\n    /**\n     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId           The id of the stream for which the setting should be updated\n     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.\n     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {\n        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);\n        return this;\n    }\n    private void addSetting(long streamId, String property, Object value) {\n        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);\n        settings.remove(setting);\n        settings.add(setting);\n    }\n    /**\n     * Executes the Zulip API request for updating stream subscription settings.\n     *\n     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}\n     * @throws ZulipClientException if the request was not successful\n     */\n    @Override\n    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {\n        putParamAsJsonString(SUBSCRIPTION_DATA, settings);\n        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(),\n                UpdateStreamSubscriptionSettingsApiResponse.class);\n        return response.getSubscriptionData();\n    }\n"]]}
{"hexsha": "8ed1c75425218a94e5c8b30fb96444eeac5d7691", "ext": "java", "lang": "Java", "content": "public class PointPlot extends Plot2D {\n\tprotected double m_x;\n\tprotected double m_y;\n\tprotected boolean m_first;\n\t\n\tpublic PointPlot(double x, double y, ChartX chart, Color color)\n\t{\n\t\tsuper(chart, color);\n\t\tm_maxX=m_minX=m_x=x;\n\t\tm_maxY=m_minY=m_y=y;\n\t}\n\t\n\tpublic void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY)\n\t{\n\t\tg.setColor(m_color);\n\t\t\n\t\tint GX=projectX(m_x, minGX, maxGX);\n\t\tint GY=projectY(m_y, minGY, maxGY);\n\t\tg.fillOval(GX-5, GY-5, 10, 10);\n\t}\n\t\n\t\n\n}", "class_id": 0, "repo": "chen0040/cpp-ogre-mllab", "file": "ML/src/visualizer/simpleui/PointPlot.java", "last_update_at": "2021-10-04T09:40:26+00:00", "question_id": "8ed1c75425218a94e5c8b30fb96444eeac5d7691", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PointPlot extends Plot2D {\n\tprotected double m_x;\n\tprotected double m_y;\n\tprotected boolean m_first;\n\t\n\tpublic PointPlot(double x, double y, ChartX chart, Color color)\n\t{\n\t\tsuper(chart, color);\n\t\tm_maxX=m_minX=m_x=x;\n\t\tm_maxY=m_minY=m_y=y;\n\t}\n\t\n\tpublic void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY)\n\t{\n\t\tg.setColor(m_color);\n\t\t\n\t\tint GX=projectX(m_x, minGX, maxGX);\n\t\tint GY=projectY(m_y, minGY, maxGY);\n\t\tg.fillOval(GX-5, GY-5, 10, 10);\n\t}\n\t\n\t\n"]]}
{"hexsha": "58a1281ad64f50e807c784278332fa731843ae46", "ext": "java", "lang": "Java", "content": "public class FCBlockTorchBaseBurning extends FCBlockTorchBase\r\n{\r\n    protected FCBlockTorchBaseBurning( int iBlockID )\r\n    {\r\n    \tsuper( iBlockID );\r\n    }\r\n    \r\n    @Override\r\n    public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )\r\n    {\r\n    \treturn true;\r\n    }    \r\n    \r\n    @Override\r\n\tpublic void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid newBlock )\r\n\t{\r\n    \tif ( newBlock.blockMaterial == Material.water )\r\n    \t{\r\n\t        world.playAuxSFX( FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0 );\r\n\t        \r\n\t        dropBlockAsItem_do( world, i, j, k, new ItemStack( FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0 ) );\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tsuper.OnFluidFlowIntoBlock( world, i, j, k, newBlock );\r\n    \t}\r\n\t}\r\n\r\n\t//----------- Client Side Functionality -----------//\r\n    \r\n    @Override\r\n    public void randomDisplayTick( World world, int i, int j, int k, Random rand )\r\n    {\r\n    \tVec3 pos = GetParticalPos( world, i, j, k );\r\n    \t\r\n        world.spawnParticle( \"smoke\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n        world.spawnParticle( \"flame\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n    }\r\n    \r\n    protected Vec3 GetParticalPos( World world, int i, int j, int k )\r\n    {\r\n    \tVec3 pos = Vec3.createVectorHelper( i + 0.5D, j + 0.92D, k + 0.5D );\r\n    \t\r\n        int iOrientation = GetOrientation( world, i, j, k );\r\n        \r\n        double dHorizontalOffset = 0.27D;\r\n\r\n        if ( iOrientation == 1 )\r\n        {\r\n        \tpos.xCoord -= dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 2 )\r\n        {\r\n        \tpos.xCoord += dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 3 )\r\n        {\r\n        \tpos.zCoord -= dHorizontalOffset;        \t\r\n        }\r\n        else if ( iOrientation == 4 )\r\n        {\r\n        \tpos.zCoord += dHorizontalOffset;\r\n        }\r\n        else\r\n        {\r\n        \tpos.yCoord -= 0.22D;\r\n        }\r\n        \r\n    \treturn \tpos;\r\n    }\r\n}", "class_id": 0, "repo": "sargunv/better-than-wolves-mod", "file": "Src/FCBlockTorchBaseBurning.java", "last_update_at": "2021-04-11T22:29:23+00:00", "question_id": "58a1281ad64f50e807c784278332fa731843ae46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FCBlockTorchBaseBurning extends FCBlockTorchBase\r\n{\r\n    protected FCBlockTorchBaseBurning( int iBlockID )\r\n    {\r\n    \tsuper( iBlockID );\r\n    }\r\n    \r\n    @Override\r\n    public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )\r\n    {\r\n    \treturn true;\r\n    }    \r\n    \r\n    @Override\r\n\tpublic void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid newBlock )\r\n\t{\r\n    \tif ( newBlock.blockMaterial == Material.water )\r\n    \t{\r\n\t        world.playAuxSFX( FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0 );\r\n\t        \r\n\t        dropBlockAsItem_do( world, i, j, k, new ItemStack( FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0 ) );\r\n    \t}\r\n    \telse\r\n    \t{\r\n    \t\tsuper.OnFluidFlowIntoBlock( world, i, j, k, newBlock );\r\n    \t}\r\n\t}\r\n\r\n\t//----------- Client Side Functionality -----------//\r\n    \r\n    @Override\r\n    public void randomDisplayTick( World world, int i, int j, int k, Random rand )\r\n    {\r\n    \tVec3 pos = GetParticalPos( world, i, j, k );\r\n    \t\r\n        world.spawnParticle( \"smoke\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n        world.spawnParticle( \"flame\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D );\r\n    }\r\n    \r\n    protected Vec3 GetParticalPos( World world, int i, int j, int k )\r\n    {\r\n    \tVec3 pos = Vec3.createVectorHelper( i + 0.5D, j + 0.92D, k + 0.5D );\r\n    \t\r\n        int iOrientation = GetOrientation( world, i, j, k );\r\n        \r\n        double dHorizontalOffset = 0.27D;\r\n\r\n        if ( iOrientation == 1 )\r\n        {\r\n        \tpos.xCoord -= dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 2 )\r\n        {\r\n        \tpos.xCoord += dHorizontalOffset;\r\n        }\r\n        else if ( iOrientation == 3 )\r\n        {\r\n        \tpos.zCoord -= dHorizontalOffset;        \t\r\n        }\r\n        else if ( iOrientation == 4 )\r\n        {\r\n        \tpos.zCoord += dHorizontalOffset;\r\n        }\r\n        else\r\n        {\r\n        \tpos.yCoord -= 0.22D;\r\n        }\r\n        \r\n    \treturn \tpos;\r\n    }\r\n"]]}
{"hexsha": "76e896093e16ee748c72b09602331499e4880900", "ext": "java", "lang": "Java", "content": "public final class ClassTools {\n\n    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];\n    public static final Object[] ZERO_PARAMETERS = new Object[0];\n    private static final String CR = StringTools.CR;\n\n    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';\n\n    public static final char ARRAY_INDICATOR = '[';\n\n    public static final char REFERENCE_CLASS_CODE = 'L';\n    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';\n\n    private static PrimitiveClassCode[] primitiveClassCodes;\n    public static final char BYTE_CODE = 'B';\n    public static final char CHAR_CODE = 'C';\n    public static final char DOUBLE_CODE = 'D';\n    public static final char FLOAT_CODE = 'F';\n    public static final char INT_CODE = 'I';\n    public static final char LONG_CODE = 'J';\n    public static final char SHORT_CODE = 'S';\n    public static final char BOOLEAN_CODE = 'Z';\n    public static final char VOID_CODE = 'V';\n\n\n    /**\n     * Return all the fields for the\n     * specified class, including inherited fields.\n     * Class#allFields()\n     */\n    public static Field[] allFields(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredFields(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Field[]) stack.toArray(new Field[stack.size()]);\n    }\n\n    /**\n     * Return all the methods for the\n     * specified class, including inherited methods.\n     * Class#allMethods()\n     */\n    public static Method[] allMethods(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredMethods(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Method[]) stack.toArray(new Method[stack.size()]);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Throw an exception if the default constructor is not defined.\n     * Class#newInstance() throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        try {\n            return constructor(javaClass, parameterTypes).newInstance(parameters);\n        } catch (InstantiationException ie) {\n            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Attempt to get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#getFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(object, fieldName).get(object);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to get a static field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(javaClass, fieldName).get(null);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument method,\n     * given the receiver and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * If the invoked method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable, NoSuchMethodException\n    {\n        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Attempt to set a field value, given the\n     * containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(object, fieldName).set(object, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to set a static field value, given the\n     * containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(javaClass, fieldName).set(null, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor() throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return the constructor for the specified class\n     * and formal parameter types.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {\n        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);\n        constructor.setAccessible(true);\n        return constructor;\n    }\n\n    /**\n     * Convenience method.\n     * Return the constructor for the specified class\n     * and formal parameter type.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class parameterType) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {\n        return constructor(javaClass, new Class[] {parameterType});\n    }\n\n    /**\n     * Return the declared fields for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     * Class#accessibleDeclaredFields()\n     */\n    public static Field[] declaredFields(Class javaClass) {\n        Field[] fields = javaClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n        return fields;\n    }\n\n    /**\n     * Return the declared methods for the\n     * specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     * Class#accessibleDeclaredMethods()\n     */\n    public static Method[] declaredMethods(Class javaClass) {\n        Method[] methods = javaClass.getDeclaredMethods();\n        for (int i = 0; i < methods.length; i++) {\n            methods[i].setAccessible(true);\n        }\n        return methods;\n    }\n\n    /**\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#defaultConstructor()\n     */\n    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass);\n    }\n\n    /**\n     * Return a field for the specified class and field name.\n     * If the class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {\n        Field field = null;\n        try {\n            field = javaClass.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return field(superclass, fieldName);\n        }\n        field.setAccessible(true);\n        return field;\n    }\n\n    /**\n     * Convenience method.\n     * Return a field for the specified object and field name.\n     * If the object's class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Object object, String fieldName) throws NoSuchFieldException {\n        return field(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified constructor.\n     */\n    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        sb.append('.');\n        sb.append(fieldName);\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Object object, String fieldName) {\n        return fullyQualifiedFieldName(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        // this check allows us to use this code for constructors, where the methodName is null\n        if (methodName != null) {\n            sb.append('.');\n            sb.append(methodName);\n        }\n        sb.append('(');\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sb.append(parameterTypes[i].getName());\n            if (i < parameterTypes.length - 1)\n                sb.append(\", \");\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Object#getFieldValue(String fieldName)\n     */\n    public static Object getFieldValue(Object object, String fieldName) {\n        try {\n            return attemptToGetFieldValue(object, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Get a static field value, given the containing class and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Class#getStaticFieldValue(String fieldName)\n     */\n    public static Object getStaticFieldValue(Class javaClass, String fieldName) {\n        try {\n            return attemptToGetStaticFieldValue(javaClass, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethod(Object receiver, String methodName) {\n        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {\n        return invokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(method + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Convert all other exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause == null) {\n                throw new RuntimeException(method.toString(), ite);\n            }\n            throw cause;\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName) {\n        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {\n        return invokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Invoke the specified static method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeStaticMethod(Method method, Object[] parameters) {\n        return invokeMethod(method, null, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {\n        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = null;\n        try {\n            method = javaClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return method(superclass, methodName, parameterTypes);\n        }\n        method.setAccessible(true);\n        return method;\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(javaClass, methodName, new Class[] {parameterType});\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified object\n     * and method name. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName) throws NoSuchMethodException {\n        return method(object.getClass(), methodName);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter types. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter type. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterType);\n    }\n\n    /**\n     * Convenience method.\n     * Return the specified class (w/o the checked exception).\n     */\n    public static Class classForName(String className) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(className, ex);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(Class javaClass) {\n        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className) throws ClassNotFoundException {\n        return newInstance(className, null);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader));\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptNewInstance(javaClass, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {\n        return newInstance(className, parameterTypes, parameters, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {\n        return newInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {\n        return newInstance(className, parameterType, parameter, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);\n    }\n\n    /**\n     * Push the declared fields for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredFields(Class javaClass, Stack stack) {\n        Field[] fields = declaredFields(javaClass);\n        for (int i = fields.length - 1; i >= 0; i--) {\n            stack.push(fields[i]);\n        }\n    }\n\n    /**\n     * Push the declared methods for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredMethods(Class javaClass, Stack stack) {\n        Method[] methods = declaredMethods(javaClass);\n        for (int i = methods.length - 1; i >= 0; i--) {\n            stack.push(methods[i]);\n        }\n    }\n\n    /**\n     * Set a field value, given the containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Object#setFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetFieldValue(object, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Set a static field value, given the containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Return the short name of the object's class.\n     * Class#getShortName()\n     */\n    public static String shortClassNameForObject(Object object) {\n        return shortNameFor(object.getClass());\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameFor(Class javaClass) {\n        return shortNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the nested name of the object's class.\n     * Class#getNestedName()\n     */\n    public static String nestedClassNameForObject(Object object) {\n        return nestedNameFor(object.getClass());\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameFor(Class javaClass) {\n        return nestedNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the \"toString()\" name of the object's class.\n     */\n    public static String toStringClassNameForObject(Object object) {\n        return toStringNameFor(object.getClass());\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     * \"Member\" classes will return only the final name:\n     *     \"com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass\"\n     *         => \"NestedMemberClass\"\n     * \"Local\" and \"anonymous\" classes will still return the embedded '$'s:\n     *     \"com.foo.bar.TopLevelClass$1LocalClass\"\n     *         => \"TopLevelClass$1LocalClass\"\n     *     \"com.foo.bar.TopLevelClass$1\"\n     *         => \"TopLevelClass$1\"\n     */\n    public static String toStringNameForClassNamed(String className) {\n        return classNamedIsMember(className) ?\n            className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1)\n        :\n            className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     */\n    public static String toStringNameFor(Class javaClass) {\n        return toStringNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameFor(Class javaClass) {\n        return packageNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameForClassNamed(String className) {\n        int lastPeriod = className.lastIndexOf('.');\n        if (lastPeriod == -1) {\n            return \"\";\n        }\n        return className.substring(0, lastPeriod);\n    }\n\n    /**\n     * Return the short name of the class,\n     * followed by its package name (e.g. \"Object (java.lang)\").\n     * Class#getShortNameWithPackage()\n     */\n    public static String shortNameWithPackage(Class javaClass) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(shortNameFor(javaClass));\n        if ( ! javaClass.isPrimitive()) {\n            sb.append(\" (\");\n            sb.append(packageNameFor(javaClass));\n            sb.append(')');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument, static method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a static method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = method(javaClass, methodName, parameterTypes);\n        if (Modifier.isStatic(method.getModifiers())) {\n            return method;\n        }\n        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));\n    }\n\n    /**\n     * Convenience method.\n     * Return a static method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, new Class[] {parameterTypes});\n    }\n\n    /**\n     * Return whether the specified class can be \"declared\" in code;\n     * i.e. it is either a \"top-level\" class or a \"member\" class, but it\n     * is not an \"array\" class. This method rolls together all the checks\n     * from the other methods for a bit of a performance tweak.\n     * Class#isDeclarable()\n     */\n    public static boolean classNamedIsDeclarable(String className) {\n        if (className.charAt(0) == ARRAY_INDICATOR) {\n            return false;        // it is an \"array\" class\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return true;        // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"top-level\" class,\n     * as opposed to a \"member\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name does NOT contain a '$': \"TopLevelClass\").\n     * Class#isTopLevel()\n     */\n    public static boolean classNamedIsTopLevel(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;\n    }\n\n    /**\n     * Return whether the specified class is a \"member\" class,\n     * as opposed to a \"top-level\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name contains at least one '$' and all the names between\n     * each '$' are legal class names:\n     * \"TopLevelClass$MemberClass$NestedMemberClass\").\n     * Class#isMember()\n     */\n    public static boolean classNamedIsMember(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return false;    // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"local\" class,\n     * as opposed to a \"top-level\", \"member\", or \"anonymous\" class,\n     * using the standard jdk (or Eclipse) naming conventions.\n     * In the jdk, the class name ends with '$nnnXXX' where the '$' is\n     * followed by a series of numeric digits which are followed by the\n     * local class name: \"TopLevelClass$1LocalClass\".\n     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is\n     * followed by a series of numeric digits which are separated from\n     * the local class name by another '$': \"TopLevelClass$1$LocalClass\".\n     * Class#isLocal()\n     */\n    public static boolean classNamedIsLocal(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        if ( ! Character.isDigit(className.charAt(dollar + 1))) {\n            return false;\n        }\n        for (int i = dollar + 2; i < className.length(); i++) {\n            if (Character.isJavaIdentifierStart(className.charAt(i))) {\n                return true;\n            }\n        }\n        // all the characters past the $ are digits (anonymous)\n        return false;\n    }\n\n    /**\n     * Return whether the specified class is an \"anonymous\" class,\n     * as opposed to a \"top-level\", \"member\", or \"local\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name ends with '$nnn' where all the characters past the\n     * last '$' are numeric digits: \"TopLevelClass$1\").\n     * Class#isAnonymous()\n     */\n    public static boolean classNamedIsAnonymous(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        int start = dollar + 1;\n        for (int i = className.length(); i-- > start; ) {\n            if ( ! Character.isDigit(className.charAt(i))) {\n                return false;\n            }\n        }\n        // all the characters past the $ are digits\n        return true;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthFor(Class javaClass) {\n        int depth = 0;\n        while (javaClass.isArray()) {\n            depth++;\n            javaClass = javaClass.getComponentType();\n        }\n        return depth;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified object.\n     * The depth is the number of dimensions for an array.\n     * Non-arrays have a depth of zero.\n     */\n    public static int arrayDepthForObject(Object object) {\n        return arrayDepthFor(object.getClass());\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * @see java.lang.Class#getName()\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthForClassNamed(String className) {\n        int depth = 0;\n        while (className.charAt(depth) == ARRAY_INDICATOR) {\n            depth++;\n        }\n        return depth;\n    }\n\n    /**\n     * Return whether the specified class is an array type.\n     * @see java.lang.Class#getName()\n     */\n    public static boolean classNamedIsArray(String className) {\n        return className.charAt(0) == ARRAY_INDICATOR;\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * A non-array type simply returns itself.\n     * Class#getElementType()\n     */\n    public static Class elementTypeFor(Class javaClass) {\n        while (javaClass.isArray()) {\n            javaClass = javaClass.getComponentType();\n        }\n        return javaClass;\n    }\n\n    /**\n     * Return the \"element type\" of the specified object.\n     * The element type is the base type held by an array.\n     * A non-array simply returns its class.\n     */\n    public static Class elementTypeForObject(Object object) {\n        return elementTypeFor(object.getClass());\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * Class#getElementType()\n     */\n    public static String elementTypeNameFor(Class javaClass) {\n        return elementTypeFor(javaClass).getName();\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * @see java.lang.Class#getName()\n     * Class#getElementType()\n     */\n    public static String elementTypeNameForClassNamed(String className) {\n        int depth = arrayDepthForClassNamed(className);\n        if (depth == 0) {\n            // the name is in the form: \"java.lang.Object\" or \"int\"\n            return className;\n        }\n        int last = className.length() - 1;\n        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {\n            // the name is in the form: \"[[[Ljava.lang.Object;\"\n            return className.substring(depth + 1, last);    // drop the trailing ';'\n        }\n        // the name is in the form: \"[[[I\"\n        return classNameForCode(className.charAt(last));\n    }\n\n    /**\n     * Return whether the specified class is a \"reference\"\n     * class (i.e. not void or one of the primitives).\n     */\n    public static boolean classNamedIsReference(String className) {\n        return ! classNamedIsNonReference(className);\n    }\n\n    /**\n     * Return whether the specified class is a \"non-reference\"\n     * class (i.e. void or one of the primitives).\n     */\n    public static boolean classNamedIsNonReference(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(char classCode) {\n        return classForCode(classCode).getName();\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(int classCode) {\n        return classNameForCode((char) classCode);\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(char classCode) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].code == classCode) {\n                return codes[i].javaClass;\n            }\n        }\n        throw new IllegalArgumentException(String.valueOf(classCode));\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(int classCode) {\n        return classForCode((char) classCode);\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClass(Class javaClass) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass == javaClass) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(javaClass.getName());\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClassNamed(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(className);\n    }\n\n    /**\n     * Return the class for specified \"type declaration\".\n     */\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {\n        return classForTypeDeclaration(elementTypeName, arrayDepth, null);\n    }\n\n    /**\n     * Return the class for specified \"type declaration\",\n     * using the specified class loader.\n     */\n    // see the \"Evaluation\" of jdk bug 6446627 for a discussion of loading classes\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {\n        // primitives cannot be loaded via Class#forName(),\n        // so check for a primitive class name first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n\n        // non-array\n        if (arrayDepth == 0) {\n            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;\n        }\n\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return Class.forName(sb.toString(), false, classLoader);\n    }\n\n    /**\n     * Return the class name for specified \"type declaration\".\n     */\n    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {\n        // non-array\n        if (arrayDepth == 0) {\n            return elementTypeName;\n        }\n\n        if (elementTypeName.equals(void.class.getName())) {\n            throw new IllegalArgumentException(\"'void' must have an array depth of zero: \" + arrayDepth + '.');\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n\n        // look for a primitive first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n\n        return sb.toString();\n    }\n\n    private static PrimitiveClassCode[] getPrimitiveClassCodes() {\n        if (primitiveClassCodes == null) {\n            primitiveClassCodes = buildPrimitiveClassCodes();\n        }\n        return primitiveClassCodes;\n    }\n\n    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {\n        PrimitiveClassCode[] result = new PrimitiveClassCode[9];\n        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);\n        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);\n        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);\n        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);\n        result[4] = new PrimitiveClassCode(INT_CODE, int.class);\n        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);\n        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);\n        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);\n        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);\n        return result;\n    }\n\n    /**\n     * Suppress default constructor, ensuring non-instantiability.\n     */\n    private ClassTools() {\n        super();\n        throw new UnsupportedOperationException();\n    }\n\n\n    // ********** member class **********\n\n    private static class PrimitiveClassCode {\n        char code;\n        Class javaClass;\n        PrimitiveClassCode(char code, Class javaClass) {\n            this.code = code;\n            this.javaClass = javaClass;\n        }\n    }\n\n}", "class_id": 0, "repo": "Pandrex247/patched-src-eclipselink", "file": "utils/eclipselink.utils.workbench/utility/source/org/eclipse/persistence/tools/workbench/utility/ClassTools.java", "last_update_at": "2021-12-14T20:59:52+00:00", "question_id": "76e896093e16ee748c72b09602331499e4880900", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ClassTools {\n    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];\n    public static final Object[] ZERO_PARAMETERS = new Object[0];\n    private static final String CR = StringTools.CR;\n    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';\n    public static final char ARRAY_INDICATOR = '[';\n    public static final char REFERENCE_CLASS_CODE = 'L';\n    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';\n    private static PrimitiveClassCode[] primitiveClassCodes;\n    public static final char BYTE_CODE = 'B';\n    public static final char CHAR_CODE = 'C';\n    public static final char DOUBLE_CODE = 'D';\n    public static final char FLOAT_CODE = 'F';\n    public static final char INT_CODE = 'I';\n    public static final char LONG_CODE = 'J';\n    public static final char SHORT_CODE = 'S';\n    public static final char BOOLEAN_CODE = 'Z';\n    public static final char VOID_CODE = 'V';\n    /**\n     * Return all the fields for the\n     * specified class, including inherited fields.\n     * Class#allFields()\n     */\n    public static Field[] allFields(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredFields(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Field[]) stack.toArray(new Field[stack.size()]);\n    }\n    /**\n     * Return all the methods for the\n     * specified class, including inherited methods.\n     * Class#allMethods()\n     */\n    public static Method[] allMethods(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredMethods(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Method[]) stack.toArray(new Method[stack.size()]);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Throw an exception if the default constructor is not defined.\n     * Class#newInstance() throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        try {\n            return constructor(javaClass, parameterTypes).newInstance(parameters);\n        } catch (InstantiationException ie) {\n            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);\n        }\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Attempt to get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#getFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(object, fieldName).get(object);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n    /**\n     * Attempt to get a static field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(javaClass, fieldName).get(null);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument method,\n     * given the receiver and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * If the invoked method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable, NoSuchMethodException\n    {\n        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);\n    }\n    /**\n     * Convenience method.\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Attempt to set a field value, given the\n     * containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(object, fieldName).set(object, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n    /**\n     * Attempt to set a static field value, given the\n     * containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(javaClass, fieldName).set(null, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n    /**\n     * Convenience method.\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor() throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass, ZERO_PARAMETER_TYPES);\n    }\n    /**\n     * Return the constructor for the specified class\n     * and formal parameter types.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {\n        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);\n        constructor.setAccessible(true);\n        return constructor;\n    }\n    /**\n     * Convenience method.\n     * Return the constructor for the specified class\n     * and formal parameter type.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class parameterType) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {\n        return constructor(javaClass, new Class[] {parameterType});\n    }\n    /**\n     * Return the declared fields for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     * Class#accessibleDeclaredFields()\n     */\n    public static Field[] declaredFields(Class javaClass) {\n        Field[] fields = javaClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n        return fields;\n    }\n    /**\n     * Return the declared methods for the\n     * specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     * Class#accessibleDeclaredMethods()\n     */\n    public static Method[] declaredMethods(Class javaClass) {\n        Method[] methods = javaClass.getDeclaredMethods();\n        for (int i = 0; i < methods.length; i++) {\n            methods[i].setAccessible(true);\n        }\n        return methods;\n    }\n    /**\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#defaultConstructor()\n     */\n    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass);\n    }\n    /**\n     * Return a field for the specified class and field name.\n     * If the class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {\n        Field field = null;\n        try {\n            field = javaClass.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return field(superclass, fieldName);\n        }\n        field.setAccessible(true);\n        return field;\n    }\n    /**\n     * Convenience method.\n     * Return a field for the specified object and field name.\n     * If the object's class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Object object, String fieldName) throws NoSuchFieldException {\n        return field(object.getClass(), fieldName);\n    }\n    /**\n     * Return a string representation of the specified constructor.\n     */\n    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);\n    }\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        sb.append('.');\n        sb.append(fieldName);\n        return sb.toString();\n    }\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Object object, String fieldName) {\n        return fullyQualifiedFieldName(object.getClass(), fieldName);\n    }\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        // this check allows us to use this code for constructors, where the methodName is null\n        if (methodName != null) {\n            sb.append('.');\n            sb.append(methodName);\n        }\n        sb.append('(');\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sb.append(parameterTypes[i].getName());\n            if (i < parameterTypes.length - 1)\n                sb.append(\", \");\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);\n    }\n    /**\n     * Get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Object#getFieldValue(String fieldName)\n     */\n    public static Object getFieldValue(Object object, String fieldName) {\n        try {\n            return attemptToGetFieldValue(object, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n    /**\n     * Get a static field value, given the containing class and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Class#getStaticFieldValue(String fieldName)\n     */\n    public static Object getStaticFieldValue(Class javaClass, String fieldName) {\n        try {\n            return attemptToGetStaticFieldValue(javaClass, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethod(Object receiver, String methodName) {\n        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {\n        return invokeMethod(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter)\n        throws Throwable\n    {\n        return invokeMethodWithException(receiver, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(method + CR + ite.getTargetException(), ite);\n        }\n    }\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Convert all other exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters)\n        throws Throwable\n    {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause == null) {\n                throw new RuntimeException(method.toString(), ite);\n            }\n            throw cause;\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName) {\n        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Convenience method.\n     * Invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {\n        return invokeStaticMethod(javaClass, methodName, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Invoke the specified static method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeStaticMethod(Method method, Object[] parameters) {\n        return invokeMethod(method, null, parameters);\n    }\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {\n        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n    /**\n     * Return a method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = null;\n        try {\n            method = javaClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return method(superclass, methodName, parameterTypes);\n        }\n        method.setAccessible(true);\n        return method;\n    }\n    /**\n     * Convenience method.\n     * Return a method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(javaClass, methodName, new Class[] {parameterType});\n    }\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified object\n     * and method name. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName) throws NoSuchMethodException {\n        return method(object.getClass(), methodName);\n    }\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter types. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterTypes);\n    }\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter type. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterType);\n    }\n    /**\n     * Convenience method.\n     * Return the specified class (w/o the checked exception).\n     */\n    public static Class classForName(String className) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(className, ex);\n        }\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(Class javaClass) {\n        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className) throws ClassNotFoundException {\n        return newInstance(className, null);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader));\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptNewInstance(javaClass, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);\n        }\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {\n        return newInstance(className, parameterTypes, parameters, null);\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);\n    }\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {\n        return newInstance(javaClass, new Class[] {parameterType}, new Object[] {parameter});\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {\n        return newInstance(className, parameterType, parameter, null);\n    }\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);\n    }\n    /**\n     * Push the declared fields for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredFields(Class javaClass, Stack stack) {\n        Field[] fields = declaredFields(javaClass);\n        for (int i = fields.length - 1; i >= 0; i--) {\n            stack.push(fields[i]);\n        }\n    }\n    /**\n     * Push the declared methods for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredMethods(Class javaClass, Stack stack) {\n        Method[] methods = declaredMethods(javaClass);\n        for (int i = methods.length - 1; i >= 0; i--) {\n            stack.push(methods[i]);\n        }\n    }\n    /**\n     * Set a field value, given the containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Object#setFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetFieldValue(object, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n    /**\n     * Set a static field value, given the containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n    /**\n     * Return the short name of the object's class.\n     * Class#getShortName()\n     */\n    public static String shortClassNameForObject(Object object) {\n        return shortNameFor(object.getClass());\n    }\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf('.') + 1);\n    }\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameFor(Class javaClass) {\n        return shortNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the nested name of the object's class.\n     * Class#getNestedName()\n     */\n    public static String nestedClassNameForObject(Object object) {\n        return nestedNameFor(object.getClass());\n    }\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);\n    }\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameFor(Class javaClass) {\n        return nestedNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the \"toString()\" name of the object's class.\n     */\n    public static String toStringClassNameForObject(Object object) {\n        return toStringNameFor(object.getClass());\n    }\n    /**\n     * Return the \"toString()\" name of the class.\n     * \"Member\" classes will return only the final name:\n     *     \"com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass\"\n     *         => \"NestedMemberClass\"\n     * \"Local\" and \"anonymous\" classes will still return the embedded '$'s:\n     *     \"com.foo.bar.TopLevelClass$1LocalClass\"\n     *         => \"TopLevelClass$1LocalClass\"\n     *     \"com.foo.bar.TopLevelClass$1\"\n     *         => \"TopLevelClass$1\"\n     */\n    public static String toStringNameForClassNamed(String className) {\n        return classNamedIsMember(className) ?\n            className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1)\n        :\n            className.substring(className.lastIndexOf('.') + 1);\n    }\n    /**\n     * Return the \"toString()\" name of the class.\n     */\n    public static String toStringNameFor(Class javaClass) {\n        return toStringNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameFor(Class javaClass) {\n        return packageNameForClassNamed(javaClass.getName());\n    }\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameForClassNamed(String className) {\n        int lastPeriod = className.lastIndexOf('.');\n        if (lastPeriod == -1) {\n            return \"\";\n        }\n        return className.substring(0, lastPeriod);\n    }\n    /**\n     * Return the short name of the class,\n     * followed by its package name (e.g. \"Object (java.lang)\").\n     * Class#getShortNameWithPackage()\n     */\n    public static String shortNameWithPackage(Class javaClass) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(shortNameFor(javaClass));\n        if ( ! javaClass.isPrimitive()) {\n            sb.append(\" (\");\n            sb.append(packageNameFor(javaClass));\n            sb.append(')');\n        }\n        return sb.toString();\n    }\n    /**\n     * Convenience method.\n     * Return a zero-argument, static method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n    /**\n     * Return a static method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = method(javaClass, methodName, parameterTypes);\n        if (Modifier.isStatic(method.getModifiers())) {\n            return method;\n        }\n        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));\n    }\n    /**\n     * Convenience method.\n     * Return a static method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, new Class[] {parameterTypes});\n    }\n    /**\n     * Return whether the specified class can be \"declared\" in code;\n     * i.e. it is either a \"top-level\" class or a \"member\" class, but it\n     * is not an \"array\" class. This method rolls together all the checks\n     * from the other methods for a bit of a performance tweak.\n     * Class#isDeclarable()\n     */\n    public static boolean classNamedIsDeclarable(String className) {\n        if (className.charAt(0) == ARRAY_INDICATOR) {\n            return false;        // it is an \"array\" class\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return true;        // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n    /**\n     * Return whether the specified class is a \"top-level\" class,\n     * as opposed to a \"member\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name does NOT contain a '$': \"TopLevelClass\").\n     * Class#isTopLevel()\n     */\n    public static boolean classNamedIsTopLevel(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;\n    }\n    /**\n     * Return whether the specified class is a \"member\" class,\n     * as opposed to a \"top-level\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name contains at least one '$' and all the names between\n     * each '$' are legal class names:\n     * \"TopLevelClass$MemberClass$NestedMemberClass\").\n     * Class#isMember()\n     */\n    public static boolean classNamedIsMember(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            return false;    // it is a \"top-level\" class\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n    /**\n     * Return whether the specified class is a \"local\" class,\n     * as opposed to a \"top-level\", \"member\", or \"anonymous\" class,\n     * using the standard jdk (or Eclipse) naming conventions.\n     * In the jdk, the class name ends with '$nnnXXX' where the '$' is\n     * followed by a series of numeric digits which are followed by the\n     * local class name: \"TopLevelClass$1LocalClass\".\n     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is\n     * followed by a series of numeric digits which are separated from\n     * the local class name by another '$': \"TopLevelClass$1$LocalClass\".\n     * Class#isLocal()\n     */\n    public static boolean classNamedIsLocal(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        if ( ! Character.isDigit(className.charAt(dollar + 1))) {\n            return false;\n        }\n        for (int i = dollar + 2; i < className.length(); i++) {\n            if (Character.isJavaIdentifierStart(className.charAt(i))) {\n                return true;\n            }\n        }\n        // all the characters past the $ are digits (anonymous)\n        return false;\n    }\n    /**\n     * Return whether the specified class is an \"anonymous\" class,\n     * as opposed to a \"top-level\", \"member\", or \"local\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name ends with '$nnn' where all the characters past the\n     * last '$' are numeric digits: \"TopLevelClass$1\").\n     * Class#isAnonymous()\n     */\n    public static boolean classNamedIsAnonymous(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        int start = dollar + 1;\n        for (int i = className.length(); i-- > start; ) {\n            if ( ! Character.isDigit(className.charAt(i))) {\n                return false;\n            }\n        }\n        // all the characters past the $ are digits\n        return true;\n    }\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthFor(Class javaClass) {\n        int depth = 0;\n        while (javaClass.isArray()) {\n            depth++;\n            javaClass = javaClass.getComponentType();\n        }\n        return depth;\n    }\n    /**\n     * Return the \"array depth\" of the specified object.\n     * The depth is the number of dimensions for an array.\n     * Non-arrays have a depth of zero.\n     */\n    public static int arrayDepthForObject(Object object) {\n        return arrayDepthFor(object.getClass());\n    }\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * @see java.lang.Class#getName()\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthForClassNamed(String className) {\n        int depth = 0;\n        while (className.charAt(depth) == ARRAY_INDICATOR) {\n            depth++;\n        }\n        return depth;\n    }\n    /**\n     * Return whether the specified class is an array type.\n     * @see java.lang.Class#getName()\n     */\n    public static boolean classNamedIsArray(String className) {\n        return className.charAt(0) == ARRAY_INDICATOR;\n    }\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * A non-array type simply returns itself.\n     * Class#getElementType()\n     */\n    public static Class elementTypeFor(Class javaClass) {\n        while (javaClass.isArray()) {\n            javaClass = javaClass.getComponentType();\n        }\n        return javaClass;\n    }\n    /**\n     * Return the \"element type\" of the specified object.\n     * The element type is the base type held by an array.\n     * A non-array simply returns its class.\n     */\n    public static Class elementTypeForObject(Object object) {\n        return elementTypeFor(object.getClass());\n    }\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * Class#getElementType()\n     */\n    public static String elementTypeNameFor(Class javaClass) {\n        return elementTypeFor(javaClass).getName();\n    }\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * @see java.lang.Class#getName()\n     * Class#getElementType()\n     */\n    public static String elementTypeNameForClassNamed(String className) {\n        int depth = arrayDepthForClassNamed(className);\n        if (depth == 0) {\n            // the name is in the form: \"java.lang.Object\" or \"int\"\n            return className;\n        }\n        int last = className.length() - 1;\n        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {\n            // the name is in the form: \"[[[Ljava.lang.Object;\"\n            return className.substring(depth + 1, last);    // drop the trailing ';'\n        }\n        // the name is in the form: \"[[[I\"\n        return classNameForCode(className.charAt(last));\n    }\n    /**\n     * Return whether the specified class is a \"reference\"\n     * class (i.e. not void or one of the primitives).\n     */\n    public static boolean classNamedIsReference(String className) {\n        return ! classNamedIsNonReference(className);\n    }\n    /**\n     * Return whether the specified class is a \"non-reference\"\n     * class (i.e. void or one of the primitives).\n     */\n    public static boolean classNamedIsNonReference(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(char classCode) {\n        return classForCode(classCode).getName();\n    }\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(int classCode) {\n        return classNameForCode((char) classCode);\n    }\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(char classCode) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].code == classCode) {\n                return codes[i].javaClass;\n            }\n        }\n        throw new IllegalArgumentException(String.valueOf(classCode));\n    }\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(int classCode) {\n        return classForCode((char) classCode);\n    }\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClass(Class javaClass) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass == javaClass) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(javaClass.getName());\n    }\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClassNamed(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(className);\n    }\n    /**\n     * Return the class for specified \"type declaration\".\n     */\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {\n        return classForTypeDeclaration(elementTypeName, arrayDepth, null);\n    }\n    /**\n     * Return the class for specified \"type declaration\",\n     * using the specified class loader.\n     */\n    // see the \"Evaluation\" of jdk bug 6446627 for a discussion of loading classes\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {\n        // primitives cannot be loaded via Class#forName(),\n        // so check for a primitive class name first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        // non-array\n        if (arrayDepth == 0) {\n            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return Class.forName(sb.toString(), false, classLoader);\n    }\n    /**\n     * Return the class name for specified \"type declaration\".\n     */\n    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {\n        // non-array\n        if (arrayDepth == 0) {\n            return elementTypeName;\n        }\n        if (elementTypeName.equals(void.class.getName())) {\n            throw new IllegalArgumentException(\"'void' must have an array depth of zero: \" + arrayDepth + '.');\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        // look for a primitive first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return sb.toString();\n    }\n    private static PrimitiveClassCode[] getPrimitiveClassCodes() {\n        if (primitiveClassCodes == null) {\n            primitiveClassCodes = buildPrimitiveClassCodes();\n        }\n        return primitiveClassCodes;\n    }\n    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {\n        PrimitiveClassCode[] result = new PrimitiveClassCode[9];\n        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);\n        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);\n        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);\n        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);\n        result[4] = new PrimitiveClassCode(INT_CODE, int.class);\n        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);\n        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);\n        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);\n        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);\n        return result;\n    }\n    /**\n     * Suppress default constructor, ensuring non-instantiability.\n     */\n    private ClassTools() {\n        super();\n        throw new UnsupportedOperationException();\n    }\n    // ********** member class **********\n    private static class PrimitiveClassCode {\n        char code;\n        Class javaClass;\n        PrimitiveClassCode(char code, Class javaClass) {\n            this.code = code;\n            this.javaClass = javaClass;\n        }\n    }\n"]]}
{"hexsha": "7a7b8318fe1ee8708edc850e3756a533331a9ffb", "ext": "java", "lang": "Java", "content": "public class ConsumerAuthInterceptor implements HandlerInterceptor {\n\n    private WeChatUserRepository weChatUserRepository;\n\n    @Autowired\n    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {\n        this.weChatUserRepository = weChatUserRepository;\n    }\n\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {\n        this.jwtTokenUtil = jwtTokenUtil;\n    }\n\n    @Override\n    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object)\n            throws NullTokenException, UserNotExistException {\n        // check annotation\n        if (!(object instanceof HandlerMethod)) {\n            return true;\n        }\n        final HandlerMethod handlerMethod = (HandlerMethod) object;\n        final Method method = handlerMethod.getMethod();\n        // request\n        if (method.isAnnotationPresent(WeChatUser.class)) {\n            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);\n            if (!weChatUser.required()) {\n                return true;\n            }\n            // get token\n            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);\n            if (token == null || token.replace(\" \", \"\").equals(\"\")) {\n                throw new NullTokenException(\"Null token.\");\n            }\n            // verify user exist in database\n            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);\n            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);\n            if (wechatUserDoList.isEmpty()) {\n                throw new UserNotExistException();\n            }\n        }\n        return true;\n    }\n\n}", "class_id": 0, "repo": "Kenhuey/freethru", "file": "src/main/java/com/mythsart/freethru/framework/common/interceptor/ConsumerAuthInterceptor.java", "last_update_at": "2021-01-08T18:53:12+00:00", "question_id": "7a7b8318fe1ee8708edc850e3756a533331a9ffb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConsumerAuthInterceptor implements HandlerInterceptor {\n    private WeChatUserRepository weChatUserRepository;\n    @Autowired\n    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {\n        this.weChatUserRepository = weChatUserRepository;\n    }\n    private JwtTokenUtil jwtTokenUtil;\n    @Autowired\n    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {\n        this.jwtTokenUtil = jwtTokenUtil;\n    }\n    @Override\n    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object)\n            throws NullTokenException, UserNotExistException {\n        // check annotation\n        if (!(object instanceof HandlerMethod)) {\n            return true;\n        }\n        final HandlerMethod handlerMethod = (HandlerMethod) object;\n        final Method method = handlerMethod.getMethod();\n        // request\n        if (method.isAnnotationPresent(WeChatUser.class)) {\n            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);\n            if (!weChatUser.required()) {\n                return true;\n            }\n            // get token\n            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);\n            if (token == null || token.replace(\" \", \"\").equals(\"\")) {\n                throw new NullTokenException(\"Null token.\");\n            }\n            // verify user exist in database\n            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);\n            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);\n            if (wechatUserDoList.isEmpty()) {\n                throw new UserNotExistException();\n            }\n        }\n        return true;\n    }\n"]]}
{"hexsha": "fa6beaa76b8c1e5865d612bbe2c25921a6e42fb2", "ext": "java", "lang": "Java", "content": "public class S3ArtifactContentProvider implements ArtifactContentProvider {\n\n  private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());\n  private final ServerPaths myServerPaths;\n\n  public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {\n    myServerPaths = serverPaths;\n  }\n\n  @NotNull\n  @Override\n  public String getType() {\n    return S3Constants.S3_STORAGE_TYPE;\n  }\n\n  @NotNull\n  @Override\n  public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {\n    final Map<String, String> params;\n    final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();\n    if (artifactData == null) {\n      throw new IOException(\"Invalid artifact data: S3 object path property is not set\");\n    }\n\n    final String artifactPath = artifactData.getPath();\n    try {\n      params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());\n    } catch (IllegalArgumentException e) {\n      throw new IOException(\"Failed to get artifact \" + artifactPath + \" content: Invalid storage settings \" + e.getMessage(), e);\n    }\n\n    final String bucketName = S3Util.getBucketName(params);\n    final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;\n\n    try {\n      return S3Util.withS3Client(\n        ParamUtil.putSslValues(myServerPaths, params),\n        client -> client.getObject(bucketName, key).getObjectContent()\n      );\n    } catch (Throwable t) {\n      final AWSException awsException = new AWSException(t);\n      final String details = awsException.getDetails();\n      if (StringUtil.isNotEmpty(details)) {\n        final String message = awsException.getMessage() + details;\n        LOG.warn(message);\n      }\n      throw new IOException(String.format(\n        \"Failed to get artifact '%s' content in bucket '%s': %s\",\n        artifactPath, bucketName, awsException.getMessage()\n      ), awsException);\n    }\n  }\n}", "class_id": 0, "repo": "ChildOfJustice/teamcity-s3-artifact-storage-plugin", "file": "s3-artifact-storage-server/src/main/java/jetbrains/buildServer/artifacts/s3/S3ArtifactContentProvider.java", "last_update_at": "2021-11-08T09:50:20+00:00", "question_id": "fa6beaa76b8c1e5865d612bbe2c25921a6e42fb2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class S3ArtifactContentProvider implements ArtifactContentProvider {\n  private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());\n  private final ServerPaths myServerPaths;\n  public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {\n    myServerPaths = serverPaths;\n  }\n  @NotNull\n  @Override\n  public String getType() {\n    return S3Constants.S3_STORAGE_TYPE;\n  }\n  @NotNull\n  @Override\n  public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {\n    final Map<String, String> params;\n    final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();\n    if (artifactData == null) {\n      throw new IOException(\"Invalid artifact data: S3 object path property is not set\");\n    }\n    final String artifactPath = artifactData.getPath();\n    try {\n      params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());\n    } catch (IllegalArgumentException e) {\n      throw new IOException(\"Failed to get artifact \" + artifactPath + \" content: Invalid storage settings \" + e.getMessage(), e);\n    }\n    final String bucketName = S3Util.getBucketName(params);\n    final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;\n    try {\n      return S3Util.withS3Client(\n        ParamUtil.putSslValues(myServerPaths, params),\n        client -> client.getObject(bucketName, key).getObjectContent()\n      );\n    } catch (Throwable t) {\n      final AWSException awsException = new AWSException(t);\n      final String details = awsException.getDetails();\n      if (StringUtil.isNotEmpty(details)) {\n        final String message = awsException.getMessage() + details;\n        LOG.warn(message);\n      }\n      throw new IOException(String.format(\n        \"Failed to get artifact '%s' content in bucket '%s': %s\",\n        artifactPath, bucketName, awsException.getMessage()\n      ), awsException);\n    }\n  }\n"]]}
{"hexsha": "b73d67eeb7296ad974a93d8acc1f52b681a08a15", "ext": "java", "lang": "Java", "content": "public class AnnotationTest extends RecognationExtended{\n\n\t@Test\n\tpublic void testSamePackage(){\n\t\tboolean annotationFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(5, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageA(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageB(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageC(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n}", "class_id": 0, "repo": "senkz/HUSACCT", "file": "src/husaccttest/analyse/java/recognition/AnnotationTest.java", "last_update_at": "2021-02-02T12:58:55+00:00", "question_id": "b73d67eeb7296ad974a93d8acc1f52b681a08a15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AnnotationTest extends RecognationExtended{\n\t@Test\n\tpublic void testSamePackage(){\n\t\tboolean annotationFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.a.SamePackage\");\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(5, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageA(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageB(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n\t\n\t@Test\n\tpublic void testOtherPackageC(){\n\t\tboolean annotationFound = false;\n\t\tboolean importFound = false;\n//\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\tDependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n\t\t\n\t\tfor (DependencyDTO dependency : dependencies){\n\t\t\tif(dependency.type.equals(\"Annotation\")){\n\t\t\t\tannotationFound = true;\n\t\t\t\tassertEquals(7, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t\telse if(dependency.type.equals(\"Import\")){\n\t\t\t\timportFound = true;\n\t\t\t\tassertEquals(3, dependency.lineNumber);\n\t\t\t\tassertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n\t\t\t}\n\t\t}\n\t\tassertEquals(true, annotationFound);\n\t\tassertEquals(true, importFound);\n\t}\n"]]}
{"hexsha": "ddca8f972e4ef486dd342e78f4884eef0e4fa00e", "ext": "java", "lang": "Java", "content": "@lombok.extern.slf4j.Slf4j\npublic abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C>\n        extends ClientBuilderBase<B, C> {\n    public RegionalClientBuilder(Service service) {\n        super(service);\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param region region\n     * @return this builder\n     */\n    public B region(com.oracle.bmc.Region region) {\n        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);\n        if (endpoint.isPresent()) {\n            endpoint(endpoint.get());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Endpoint for \" + service + \" is not known in region \" + region);\n        }\n        return (B) this;\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param regionId region\n     * @return this builder\n     */\n    public B region(String regionId) {\n        regionId = regionId.toLowerCase(Locale.ENGLISH);\n        try {\n            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);\n            return region(region);\n        } catch (IllegalArgumentException e) {\n            LOG.info(\"Unknown regionId '{}', falling back to default endpoint format\", regionId);\n            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);\n            return endpoint(endpoint);\n        }\n    }\n}", "class_id": 0, "repo": "skichiku/oci-java-sdk", "file": "bmc-common/src/main/java/com/oracle/bmc/common/RegionalClientBuilder.java", "last_update_at": "2021-04-09T18:17:14+00:00", "question_id": "ddca8f972e4ef486dd342e78f4884eef0e4fa00e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@lombok.extern.slf4j.Slf4j\npublic abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C>\n        extends ClientBuilderBase<B, C> {\n    public RegionalClientBuilder(Service service) {\n        super(service);\n    }\n    /**\n     * Set the region for the client to be created.\n     * @param region region\n     * @return this builder\n     */\n    public B region(com.oracle.bmc.Region region) {\n        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);\n        if (endpoint.isPresent()) {\n            endpoint(endpoint.get());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Endpoint for \" + service + \" is not known in region \" + region);\n        }\n        return (B) this;\n    }\n    /**\n     * Set the region for the client to be created.\n     * @param regionId region\n     * @return this builder\n     */\n    public B region(String regionId) {\n        regionId = regionId.toLowerCase(Locale.ENGLISH);\n        try {\n            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);\n            return region(region);\n        } catch (IllegalArgumentException e) {\n            LOG.info(\"Unknown regionId '{}', falling back to default endpoint format\", regionId);\n            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);\n            return endpoint(endpoint);\n        }\n    }\n"]]}
{"hexsha": "681fd5b93140fff33f986615cacd9efcac085276", "ext": "java", "lang": "Java", "content": "public class DecisionMaker extends Thread {\n\tprivate ArrayList<Integer> preferredPeers = new ArrayList<Integer>();                       // An array that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// maintains preferred\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// peerInfos.\n\tprivate int optUnchockedPeer = -1;\n\n\tprivate ArrayList<Integer> previousRequestList = new ArrayList<>();\n\tprivate ArrayList<Integer> requestingList = new ArrayList<>();\n\t\n\t/**\n\t * Update preferred peers\n\t */\n\tprivate class updatePreferredPeers extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\tif (PeerProcess.peers.size() > 0) {\n\t\t\t\t\tpreferredPeers.clear();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {\n\t\t\t\t\tArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();\n\t\t\t\t\tCollections.shuffle(interestedPeers);\n\t\t\t\t\tfor(int peerId: interestedPeers) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();\n\t\t\t\t\tfor(int peerId: PeerProcess.getInterestedPeers()) {\n\t\t\t\t\t\tpeerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));\n\t\t\t\t\t}\n\t\t\t\t\tpeerId_ChunkCounts.sort(null);\n\t\t\t\t\t\n\t\t\t\t\tfor(PeerId_ChunkCount tuple: peerId_ChunkCounts) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(tuple.peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\t\tp.resetChunkCount();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// iterate over all peers to check and send proper choke/unchoke msgs\n\t\t\t\tfor (DynamicPeerInfo p : PeerProcess.peers) {\n\t\t\t\t\tif (p.isConnected) {\n\t\t\t\t\t\tif (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Unchoking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Choking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPeerProcess.write(\"has the preferred neighbors \" + preferredPeers);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Optimistically unchoke a peer\n\t */\n\tprivate class optimisiticUnchoke extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\ttry {\n\t\t\t\t\tPeerProcess.checkTermination();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> chockedList = new ArrayList<>();\n\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\tif(p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {\n\t\t\t\t\t\tchockedList.add(p.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!chockedList.isEmpty()) {\n\t\t\t\t\tint index = (int) (Math.random() * chockedList.size());\n\t\t\t\t\toptUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;\n\t\t\t\t\tPeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));\n\t\t\t\t\tPeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\tPeerProcess.write(\"has the optimistically unchoked neighbor \" + optUnchockedPeer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate class requestTimeout extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized(requestingList) {\n\t\t\t\tfor(int i = 0; i < previousRequestList.size(); i++) {\n\t\t\t\t\tif(requestingList.contains(previousRequestList.get(i))) {\n\t\t\t\t\t\trequestingList.remove(Integer.valueOf(previousRequestList.get(i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousRequestList = requestingList;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void removeRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\trequestingList.remove(Integer.valueOf(pieceIndex));\n\t\t}\n\t}\n\t\n\tpublic boolean addRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\tif(requestingList.contains(pieceIndex)) {\n\t\t\t\treturn false;\n\t\t\t}else {\n\t\t\t\trequestingList.add(pieceIndex);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Main method of decision maker as a thread.\n\t */\n\t@Override\n\tpublic void run() {\n\t\tTimer timerUpdate = new Timer();// create a new Timer\n\t\tTimer timerOptUpdate = new Timer();\n\t\tTimer timerRequestTimeout = new Timer();\n\t\tTimerTask task1 = new optimisiticUnchoke();\n\t\tTimerTask task2 = new updatePreferredPeers();\n\t\tTimerTask task3 = new requestTimeout();\n\t\ttimerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);\n\t\ttimerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);\n\t\ttimerRequestTimeout.schedule(task3, 0, 10000);\n\t}\n}", "class_id": 0, "repo": "rajatraiuf/BitTorrent-Java-CN5106C", "file": "src/cnt5106C/DecisionMaker.java", "last_update_at": "2021-01-18T18:08:54+00:00", "question_id": "681fd5b93140fff33f986615cacd9efcac085276", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DecisionMaker extends Thread {\n\tprivate ArrayList<Integer> preferredPeers = new ArrayList<Integer>();                       // An array that\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// maintains preferred\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// peerInfos.\n\tprivate int optUnchockedPeer = -1;\n\tprivate ArrayList<Integer> previousRequestList = new ArrayList<>();\n\tprivate ArrayList<Integer> requestingList = new ArrayList<>();\n\t\n\t/**\n\t * Update preferred peers\n\t */\n\tprivate class updatePreferredPeers extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\tif (PeerProcess.peers.size() > 0) {\n\t\t\t\t\tpreferredPeers.clear();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {\n\t\t\t\t\tArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();\n\t\t\t\t\tCollections.shuffle(interestedPeers);\n\t\t\t\t\tfor(int peerId: interestedPeers) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();\n\t\t\t\t\tfor(int peerId: PeerProcess.getInterestedPeers()) {\n\t\t\t\t\t\tpeerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));\n\t\t\t\t\t}\n\t\t\t\t\tpeerId_ChunkCounts.sort(null);\n\t\t\t\t\t\n\t\t\t\t\tfor(PeerId_ChunkCount tuple: peerId_ChunkCounts) {\n\t\t\t\t\t\tif(preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n\t\t\t\t\t\t\tpreferredPeers.add(tuple.peerId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\t\tp.resetChunkCount();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// iterate over all peers to check and send proper choke/unchoke msgs\n\t\t\t\tfor (DynamicPeerInfo p : PeerProcess.peers) {\n\t\t\t\t\tif (p.isConnected) {\n\t\t\t\t\t\tif (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Unchoking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {\n\t\t\t\t\t\t\t// PeerProcess.write(\"Choking peer \" + p.peerId);\n\t\t\t\t\t\t\tPeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));\n\t\t\t\t\t\t\tp.isLocalPeerChockingRemotePeer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPeerProcess.write(\"has the preferred neighbors \" + preferredPeers);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Optimistically unchoke a peer\n\t */\n\tprivate class optimisiticUnchoke extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized (preferredPeers) {\n\t\t\t\ttry {\n\t\t\t\t\tPeerProcess.checkTermination();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tArrayList<Integer> chockedList = new ArrayList<>();\n\t\t\t\tfor(DynamicPeerInfo p: PeerProcess.peers) {\n\t\t\t\t\tif(p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {\n\t\t\t\t\t\tchockedList.add(p.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!chockedList.isEmpty()) {\n\t\t\t\t\tint index = (int) (Math.random() * chockedList.size());\n\t\t\t\t\toptUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;\n\t\t\t\t\tPeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));\n\t\t\t\t\tPeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;\n\t\t\t\t\tPeerProcess.write(\"has the optimistically unchoked neighbor \" + optUnchockedPeer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate class requestTimeout extends TimerTask {\n\t\tpublic void run() {\n\t\t\tsynchronized(requestingList) {\n\t\t\t\tfor(int i = 0; i < previousRequestList.size(); i++) {\n\t\t\t\t\tif(requestingList.contains(previousRequestList.get(i))) {\n\t\t\t\t\t\trequestingList.remove(Integer.valueOf(previousRequestList.get(i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousRequestList = requestingList;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void removeRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\trequestingList.remove(Integer.valueOf(pieceIndex));\n\t\t}\n\t}\n\t\n\tpublic boolean addRequest(int pieceIndex) {\n\t\tsynchronized(requestingList) {\n\t\t\tif(requestingList.contains(pieceIndex)) {\n\t\t\t\treturn false;\n\t\t\t}else {\n\t\t\t\trequestingList.add(pieceIndex);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Main method of decision maker as a thread.\n\t */\n\t@Override\n\tpublic void run() {\n\t\tTimer timerUpdate = new Timer();// create a new Timer\n\t\tTimer timerOptUpdate = new Timer();\n\t\tTimer timerRequestTimeout = new Timer();\n\t\tTimerTask task1 = new optimisiticUnchoke();\n\t\tTimerTask task2 = new updatePreferredPeers();\n\t\tTimerTask task3 = new requestTimeout();\n\t\ttimerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);\n\t\ttimerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);\n\t\ttimerRequestTimeout.schedule(task3, 0, 10000);\n\t}\n"]]}
{"hexsha": "4998e4e78f75aacee3fa24faf1e1124b33ea528c", "ext": "java", "lang": "Java", "content": "public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {\n\n    public TypeBinding resolveType(BlockScope scope) {\n        this.argumentTypes = Binding.NO_PARAMETERS;\n        if (this.arguments != null) {\n            int argsLength = this.arguments.length;\n            int length = this.arguments.length;\n            this.argumentTypes = new TypeBinding[length];\n            for (int a = argsLength; --a >= 0; ) {\n                this.argumentTypes[a] = this.arguments[a].resolveType(scope);\n            }\n        }\n        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;\n        if (this.enclosingInstance != null) {\n            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);\n            if (enclosingType == null) {\n                // Eg.: new Test<>().new Test<>(#cursor#\n                if (this.enclosingInstance instanceof AllocationExpression) {\n                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;\n                    if (enclosingInstanceType != null) {\n                        enclosingType = enclosingInstanceType.resolvedType;\n                    }\n                }\n            }\n            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {\n                throw new CompletionNodeFound();\n            }\n            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n            if (// handle the anonymous class definition case\n            this.resolvedType.isInterface())\n                this.resolvedType = scope.getJavaLangObject();\n        } else {\n            this.resolvedType = this.type.resolveType(scope, /* check bounds*/\n            true);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n        }\n        throw new CompletionNodeFound(this, this.resolvedType, scope);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        if (this.enclosingInstance == null)\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnAllocationExpression:\");\n        else\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnQualifiedAllocationExpression:\");\n        return super.printExpression(indent, output).append('>');\n    }\n}", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.core/176.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "4998e4e78f75aacee3fa24faf1e1124b33ea528c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {\n    public TypeBinding resolveType(BlockScope scope) {\n        this.argumentTypes = Binding.NO_PARAMETERS;\n        if (this.arguments != null) {\n            int argsLength = this.arguments.length;\n            int length = this.arguments.length;\n            this.argumentTypes = new TypeBinding[length];\n            for (int a = argsLength; --a >= 0; ) {\n                this.argumentTypes[a] = this.arguments[a].resolveType(scope);\n            }\n        }\n        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;\n        if (this.enclosingInstance != null) {\n            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);\n            if (enclosingType == null) {\n                // Eg.: new Test<>().new Test<>(#cursor#\n                if (this.enclosingInstance instanceof AllocationExpression) {\n                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;\n                    if (enclosingInstanceType != null) {\n                        enclosingType = enclosingInstanceType.resolvedType;\n                    }\n                }\n            }\n            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {\n                throw new CompletionNodeFound();\n            }\n            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n            if (// handle the anonymous class definition case\n            this.resolvedType.isInterface())\n                this.resolvedType = scope.getJavaLangObject();\n        } else {\n            this.resolvedType = this.type.resolveType(scope, /* check bounds*/\n            true);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n        }\n        throw new CompletionNodeFound(this, this.resolvedType, scope);\n    }\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        if (this.enclosingInstance == null)\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnAllocationExpression:\");\n        else\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnQualifiedAllocationExpression:\");\n        return super.printExpression(indent, output).append('>');\n    }\n"]]}
{"hexsha": "6b004f72007f03d3e280511f6add5590dab3610a", "ext": "java", "lang": "Java", "content": "public class Configuration\n    implements Comparable<Configuration> {\n\n    /**\n     * Prefix for instructions for the configurator.\n     */\n    public static final String CONFIGURATOR_PREFIX = \":configurator:\";\n\n    /**\n     * Prefix for special properties which are not configuration properties.\n     */\n    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + \"feature-\";\n\n    /**\n     * This optional configuration property stores the artifact id (mvn id) of the\n     * bundle this configuration belongs to.\n     */\n    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + \"service.bundleLocation\";\n\n    /**\n     * This optional configuration property stores the artifact ids (array) of the\n     * features this configuration has been specified.\n     * @since 1.6\n     */\n    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + \"origins\";\n\n    /** The pid or name for factory pids. */\n    private final String pid;\n\n    /** The ordered properties. */\n    private final Dictionary<String, Object> properties = Configurations.newConfiguration();\n\n    /**\n     * Create a new configuration\n     * @param pid The pid\n     * @throws IllegalArgumentException If pid is {@code null}\n     */\n    public Configuration(final String pid) {\n        if ( pid == null ) {\n            throw new IllegalArgumentException(\"pid must not be null\");\n        }\n        this.pid = pid;\n    }\n\n    @Override\n    public int compareTo(final Configuration o) {\n        return this.pid.compareTo(o.pid);\n    }\n\n    /**\n     * Get the pid.\n     *\n     * @return The pid\n     */\n    public String getPid() {\n        return this.pid;\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @return {@code true} if it's a factory pid\n     * @since 1.3\n     */\n    public boolean isFactoryConfiguration() {\n        return isFactoryConfiguration(this.pid);\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getFactoryPid() {\n        return getFactoryPid(this.pid);\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getName() {\n        return getName(this.pid);\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @param pid The pid\n     * @return {@code true} if it's a factory pid\n     */\n    public static boolean isFactoryConfiguration(final String pid) {\n        return pid.contains(\"~\");\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @param pid The pid\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getFactoryPid(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(0, pos);\n        }\n        return null;\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @param pid The pid\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getName(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(pos + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Get all properties of the configuration. This method returns a mutable\n     * dictionary which can be mutated to alter the properties for this\n     * configuration.\n     *\n     * @return The properties\n     */\n    public Dictionary<String, Object> getProperties() {\n        return this.properties;\n    }\n\n    /**\n     * Get the feature origins - if recorded\n     * \n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.6\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins() {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n   /**\n     * Get the feature origins.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.7\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.6\n     */\n    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS);\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS, values);\n        }\n    }\n\n    /**\n     * Get the feature origins for a property - if recorded\n     * \n     * @param propertyName The name of the property\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Get the feature origins for a property.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param propertyName The name of the property\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins for a property\n     * @param propertyName The name of the property\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.8\n     */\n    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName), values);\n        }\n    }\n\n    /**\n     * Get the configuration properties of the configuration. This configuration\n     * properties are all properties minus properties used to manage the\n     * configuration. Managing properties have to start with\n     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which\n     * represents a snapshot of the properties at the time this method is called.\n     *\n     * @return The configuration properties\n     */\n    public Dictionary<String, Object> getConfigurationProperties() {\n        final Dictionary<String, Object> p = new Hashtable<>();\n        final Enumeration<String> keys = this.properties.keys();\n        while (keys.hasMoreElements()) {\n            final String key = keys.nextElement();\n            if (!key.startsWith(CONFIGURATOR_PREFIX)) {\n                p.put(key, this.properties.get(key));\n            }\n        }\n        return p;\n    }\n\n    /**\n     * Create a copy of the configuration with a provided PID.\n     *\n     * @param aPid The pid of the configuration\n     * @return A copy of this configuration with the given PID\n     */\n    public Configuration copy(final String aPid) {\n        final Configuration result = new Configuration(aPid);\n        final Enumeration<String> keyEnum = this.getProperties().keys();\n        while (keyEnum.hasMoreElements()) {\n            final String key = keyEnum.nextElement();\n            result.getProperties().put(key, this.getProperties().get(key));\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Configuration [pid=\" + pid\n                + \", properties=\" + properties\n                + \"]\";\n    }\n}", "class_id": 0, "repo": "hboutemy/sling-org-apache-sling-feature", "file": "src/main/java/org/apache/sling/feature/Configuration.java", "last_update_at": "2021-11-08T14:02:09+00:00", "question_id": "6b004f72007f03d3e280511f6add5590dab3610a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Configuration\n    implements Comparable<Configuration> {\n    /**\n     * Prefix for instructions for the configurator.\n     */\n    public static final String CONFIGURATOR_PREFIX = \":configurator:\";\n    /**\n     * Prefix for special properties which are not configuration properties.\n     */\n    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + \"feature-\";\n    /**\n     * This optional configuration property stores the artifact id (mvn id) of the\n     * bundle this configuration belongs to.\n     */\n    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + \"service.bundleLocation\";\n    /**\n     * This optional configuration property stores the artifact ids (array) of the\n     * features this configuration has been specified.\n     * @since 1.6\n     */\n    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + \"origins\";\n    /** The pid or name for factory pids. */\n    private final String pid;\n    /** The ordered properties. */\n    private final Dictionary<String, Object> properties = Configurations.newConfiguration();\n    /**\n     * Create a new configuration\n     * @param pid The pid\n     * @throws IllegalArgumentException If pid is {@code null}\n     */\n    public Configuration(final String pid) {\n        if ( pid == null ) {\n            throw new IllegalArgumentException(\"pid must not be null\");\n        }\n        this.pid = pid;\n    }\n    @Override\n    public int compareTo(final Configuration o) {\n        return this.pid.compareTo(o.pid);\n    }\n    /**\n     * Get the pid.\n     *\n     * @return The pid\n     */\n    public String getPid() {\n        return this.pid;\n    }\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @return {@code true} if it's a factory pid\n     * @since 1.3\n     */\n    public boolean isFactoryConfiguration() {\n        return isFactoryConfiguration(this.pid);\n    }\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getFactoryPid() {\n        return getFactoryPid(this.pid);\n    }\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getName() {\n        return getName(this.pid);\n    }\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @param pid The pid\n     * @return {@code true} if it's a factory pid\n     */\n    public static boolean isFactoryConfiguration(final String pid) {\n        return pid.contains(\"~\");\n    }\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @param pid The pid\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getFactoryPid(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(0, pos);\n        }\n        return null;\n    }\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @param pid The pid\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getName(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(pos + 1);\n        }\n        return null;\n    }\n    /**\n     * Get all properties of the configuration. This method returns a mutable\n     * dictionary which can be mutated to alter the properties for this\n     * configuration.\n     *\n     * @return The properties\n     */\n    public Dictionary<String, Object> getProperties() {\n        return this.properties;\n    }\n    /**\n     * Get the feature origins - if recorded\n     * \n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.6\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins() {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n   /**\n     * Get the feature origins.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.7\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n    /**\n     * Set the feature origins\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.6\n     */\n    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS);\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS, values);\n        }\n    }\n    /**\n     * Get the feature origins for a property - if recorded\n     * \n     * @param propertyName The name of the property\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n    /**\n     * Get the feature origins for a property.\n     * If no origins are recorded, the provided id is returned.\n     * \n     * @param propertyName The name of the property\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if ( origins != null ) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for(final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if ( list.isEmpty() ) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n    /**\n     * Set the feature origins for a property\n     * @param propertyName The name of the property\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.8\n     */\n    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {\n        if ( featureOrigins == null || featureOrigins.isEmpty() ) {\n            this.properties.remove(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName), values);\n        }\n    }\n    /**\n     * Get the configuration properties of the configuration. This configuration\n     * properties are all properties minus properties used to manage the\n     * configuration. Managing properties have to start with\n     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which\n     * represents a snapshot of the properties at the time this method is called.\n     *\n     * @return The configuration properties\n     */\n    public Dictionary<String, Object> getConfigurationProperties() {\n        final Dictionary<String, Object> p = new Hashtable<>();\n        final Enumeration<String> keys = this.properties.keys();\n        while (keys.hasMoreElements()) {\n            final String key = keys.nextElement();\n            if (!key.startsWith(CONFIGURATOR_PREFIX)) {\n                p.put(key, this.properties.get(key));\n            }\n        }\n        return p;\n    }\n    /**\n     * Create a copy of the configuration with a provided PID.\n     *\n     * @param aPid The pid of the configuration\n     * @return A copy of this configuration with the given PID\n     */\n    public Configuration copy(final String aPid) {\n        final Configuration result = new Configuration(aPid);\n        final Enumeration<String> keyEnum = this.getProperties().keys();\n        while (keyEnum.hasMoreElements()) {\n            final String key = keyEnum.nextElement();\n            result.getProperties().put(key, this.getProperties().get(key));\n        }\n        return result;\n    }\n    @Override\n    public String toString() {\n        return \"Configuration [pid=\" + pid\n                + \", properties=\" + properties\n                + \"]\";\n    }\n"]]}
{"hexsha": "135e2861092daaa6b77ef88ad408f7b6a510cb30", "ext": "java", "lang": "Java", "content": "public class TestMySQLDialect {\n\n  @Test\n  public void testGetLimitString() {\n    MySQLDialect mySQLDialect = new MySQLDialect();\n\n    String sql = \"select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}\";\n\n    System.out.println(mySQLDialect.getLimitString(sql, 1, 5));\n\n    System.out.println(mySQLDialect.getCountString(sql));\n\n    System.out.print(sql);\n  }\n}", "class_id": 0, "repo": "limaofeng/jfantasy-framework", "file": "core/src/test/java/org/jfantasy/framework/dao/mybatis/dialect/TestMySQLDialect.java", "last_update_at": "2021-08-13T15:25:01+00:00", "question_id": "135e2861092daaa6b77ef88ad408f7b6a510cb30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestMySQLDialect {\n  @Test\n  public void testGetLimitString() {\n    MySQLDialect mySQLDialect = new MySQLDialect();\n    String sql = \"select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}\";\n    System.out.println(mySQLDialect.getLimitString(sql, 1, 5));\n    System.out.println(mySQLDialect.getCountString(sql));\n    System.out.print(sql);\n  }\n"]]}
{"hexsha": "89aaa2b36a7cb677b7e7a1d9c911382031ef7316", "ext": "java", "lang": "Java", "content": "public class ExtensionUtility {\n\n    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {\n        Project project = event.getData(PlatformDataKeys.PROJECT);\n        if (project == null) {\n            return null;\n        }\n\n        DataContext dataContext = event.getDataContext();\n        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n        if (view == null) {\n            return null;\n        }\n\n        PsiDirectory[] directories = view.getDirectories();\n        if (directories.length == 0) {\n            return null;\n        }\n\n        return FilesystemUtil.findParentExtensionDirectory(directories[0]);\n    }\n\n    @Nullable\n    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory(\"Classes\");\n        if (classesDirectory == null) {\n            return null;\n        }\n\n        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);\n        if (composerManifest != null) {\n            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n\n        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);\n        if (extEmConf != null) {\n            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n\n        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);\n        if (strings.size() == 0 || strings.get(0).isEmpty()) {\n            return null;\n        }\n\n        return strings.get(0);\n    }\n\n    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {\n        return new String[0];\n    }\n\n    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {\n        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();\n\n        phpElementVisitor.visitFile(extEmConf);\n\n        return phpElementVisitor.getNamespaces();\n    }\n\n    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"ext_emconf.php\");\n        if (file == null) {\n            return null;\n        }\n\n        return file.getVirtualFile();\n    }\n\n    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {\n        return extensionRootDirectory.findFile(\"ext_emconf.php\");\n    }\n\n    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"composer.json\");\n        if (file == null) {\n            return null;\n        }\n\n        return file.getVirtualFile();\n    }\n\n    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {\n        private List<String> ns;\n\n        @Override\n        public void visitElement(@NotNull PsiElement element) {\n\n            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(\n                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(\n                            PlatformPatterns.psiElement(ArrayHashElement.class).withParent(\n                                    PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(\n                                            PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(\n                                                    PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(\n                                                            PlatformPatterns.or(\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"'psr-4'\"),\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"\\\"psr-4\\\"\")\n                                                            )\n                                                    )\n                                            )\n                                    )\n                            )\n                    )\n            ).accepts(element)) {\n                if (ns == null) {\n                    ns = new ArrayList<>();\n                }\n\n                String contents = ((StringLiteralExpression) element).getContents();\n                if (contents.contains(\"\\\\\")) {\n                    contents = contents.replace(\"\\\\\\\\\", \"\\\\\");\n                }\n\n                if (contents.endsWith(\"\\\\\")) {\n                    ns.add(contents);\n                }\n\n                ns.add((contents + \"\\\\\"));\n            }\n\n            super.visitElement(element);\n        }\n\n        public String[] getNamespaces() {\n            if (ns == null) {\n                return new String[0];\n            }\n\n            return ns.toArray(new String[0]);\n        }\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {\n        return findExtensionKeyFromFile(file.getVirtualFile());\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {\n        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);\n        if (extensionRootFolder == null) {\n            return null;\n        }\n\n        String extensionKey;\n        VirtualFile composerJsonFile = extensionRootFolder.findChild(\"composer.json\");\n        if (composerJsonFile != null) {\n            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);\n            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);\n        } else {\n            extensionKey = extensionRootFolder.getName();\n        }\n\n        return extensionKey;\n    }\n}", "class_id": 0, "repo": "cedricziel/idea-php-typo3-plugin", "file": "typo3-cms/src/main/java/com/cedricziel/idea/typo3/util/ExtensionUtility.java", "last_update_at": "2021-12-11T18:44:02+00:00", "question_id": "89aaa2b36a7cb677b7e7a1d9c911382031ef7316", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExtensionUtility {\n    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {\n        Project project = event.getData(PlatformDataKeys.PROJECT);\n        if (project == null) {\n            return null;\n        }\n        DataContext dataContext = event.getDataContext();\n        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n        if (view == null) {\n            return null;\n        }\n        PsiDirectory[] directories = view.getDirectories();\n        if (directories.length == 0) {\n            return null;\n        }\n        return FilesystemUtil.findParentExtensionDirectory(directories[0]);\n    }\n    @Nullable\n    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory(\"Classes\");\n        if (classesDirectory == null) {\n            return null;\n        }\n        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);\n        if (composerManifest != null) {\n            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);\n        if (extEmConf != null) {\n            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);\n        if (strings.size() == 0 || strings.get(0).isEmpty()) {\n            return null;\n        }\n        return strings.get(0);\n    }\n    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {\n        return new String[0];\n    }\n    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {\n        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();\n        phpElementVisitor.visitFile(extEmConf);\n        return phpElementVisitor.getNamespaces();\n    }\n    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"ext_emconf.php\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {\n        return extensionRootDirectory.findFile(\"ext_emconf.php\");\n    }\n    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"composer.json\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {\n        private List<String> ns;\n        @Override\n        public void visitElement(@NotNull PsiElement element) {\n            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(\n                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(\n                            PlatformPatterns.psiElement(ArrayHashElement.class).withParent(\n                                    PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(\n                                            PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(\n                                                    PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(\n                                                            PlatformPatterns.or(\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"'psr-4'\"),\n                                                                    PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"\\\"psr-4\\\"\")\n                                                            )\n                                                    )\n                                            )\n                                    )\n                            )\n                    )\n            ).accepts(element)) {\n                if (ns == null) {\n                    ns = new ArrayList<>();\n                }\n                String contents = ((StringLiteralExpression) element).getContents();\n                if (contents.contains(\"\\\\\")) {\n                    contents = contents.replace(\"\\\\\\\\\", \"\\\\\");\n                }\n                if (contents.endsWith(\"\\\\\")) {\n                    ns.add(contents);\n                }\n                ns.add((contents + \"\\\\\"));\n            }\n            super.visitElement(element);\n        }\n        public String[] getNamespaces() {\n            if (ns == null) {\n                return new String[0];\n            }\n            return ns.toArray(new String[0]);\n        }\n    }\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {\n        return findExtensionKeyFromFile(file.getVirtualFile());\n    }\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {\n        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);\n        if (extensionRootFolder == null) {\n            return null;\n        }\n        String extensionKey;\n        VirtualFile composerJsonFile = extensionRootFolder.findChild(\"composer.json\");\n        if (composerJsonFile != null) {\n            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);\n            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);\n        } else {\n            extensionKey = extensionRootFolder.getName();\n        }\n        return extensionKey;\n    }\n"]]}
{"hexsha": "12c6b162778cfc33f04b38dd1d9c10eacd9db16e", "ext": "java", "lang": "Java", "content": "public class LocalBoundary {\n\n\tprivate static final int MAX_LOCAL_SEGS = 8;\n\n\tprivate static class Segment {\n\t\t/** Segment start/end */\n\t\tfloat[] s = new float[6];\n\t\t/** Distance for pruning. */\n\t\tfloat d;\n\t}\n\n\tfloat[] m_center = new float[3];\n\tList<Segment> m_segs = new ArrayList<>();\n\tList<Long> m_polys = new ArrayList<>();\n\n\tprotected LocalBoundary() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t}\n\n\tprotected void reset() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t\tm_polys.clear();\n\t\tm_segs.clear();\n\t}\n\n\tprotected void addSegment(float dist, float[] s) {\n\t\t// Insert neighbour based on the distance.\n\t\tSegment seg = new Segment();\n\t\tSystem.arraycopy(s, 0, seg.s, 0, 6);\n\t\tseg.d = dist;\n\t\tif (m_segs.isEmpty()) {\n\t\t\tm_segs.add(seg);\n\t\t} else if (dist >= m_segs.get(m_segs.size() - 1).d) {\n\t\t\tif (m_segs.size() >= MAX_LOCAL_SEGS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tm_segs.add(seg);\n\t\t} else {\n\t\t\t// Insert inbetween.\n\t\t\tint i;\n\t\t\tfor (i = 0; i < m_segs.size(); ++i)\n\t\t\t\tif (dist <= m_segs.get(i).d)\n\t\t\t\t\tbreak;\n\t\t\tm_segs.add(i, seg);\n\t\t}\n\t\twhile (m_segs.size() > MAX_LOCAL_SEGS) {\n\t\t\tm_segs.remove(m_segs.size() - 1);\n\t\t}\n\t}\n\n\tpublic void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (ref == 0) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\t\tvCopy(m_center, pos);\n\t\t// First query non-overlapping polygons.\n\t\tFindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);\n\t\tthis.m_polys = res.getRefs();\n\t\tm_segs.clear();\n\t\t// Secondly, store all polygon edges.\n\t\tfor (int j = 0; j < m_polys.size(); ++j) {\n\t\t\tGetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);\n\t\t\tfor (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {\n\t\t\t\tfloat[] s = gpws.getSegmentVerts().get(k);\n\t\t\t\t// Skip too distant segments.\n\t\t\t\tTupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);\n\t\t\t\tif (distseg.first > sqr(collisionQueryRange))\n\t\t\t\t\tcontinue;\n\t\t\t\taddSegment(distseg.first, s);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean isValid(NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (m_polys.isEmpty())\n\t\t\treturn false;\n\n\t\t// Check that all polygons still pass query filter.\n\t\tfor (long ref : m_polys) {\n\t\t\tif (!navquery.isValidPolyRef(ref, filter))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic float[] getCenter() {\n\t\treturn m_center;\n\t}\n\n\tpublic float[] getSegment(int j) {\n\t\treturn m_segs.get(j).s;\n\t}\n\n\tpublic int getSegmentCount() {\n\t\treturn m_segs.size();\n\t}\n}", "class_id": 0, "repo": "Warkdev/recast4j", "file": "detourcrowd/src/main/java/org/recast4j/detour/crowd/LocalBoundary.java", "last_update_at": "2021-06-25T15:46:37+00:00", "question_id": "12c6b162778cfc33f04b38dd1d9c10eacd9db16e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocalBoundary {\n\tprivate static final int MAX_LOCAL_SEGS = 8;\n\tprivate static class Segment {\n\t\t/** Segment start/end */\n\t\tfloat[] s = new float[6];\n\t\t/** Distance for pruning. */\n\t\tfloat d;\n\t}\n\tfloat[] m_center = new float[3];\n\tList<Segment> m_segs = new ArrayList<>();\n\tList<Long> m_polys = new ArrayList<>();\n\tprotected LocalBoundary() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t}\n\tprotected void reset() {\n\t\tm_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n\t\tm_polys.clear();\n\t\tm_segs.clear();\n\t}\n\tprotected void addSegment(float dist, float[] s) {\n\t\t// Insert neighbour based on the distance.\n\t\tSegment seg = new Segment();\n\t\tSystem.arraycopy(s, 0, seg.s, 0, 6);\n\t\tseg.d = dist;\n\t\tif (m_segs.isEmpty()) {\n\t\t\tm_segs.add(seg);\n\t\t} else if (dist >= m_segs.get(m_segs.size() - 1).d) {\n\t\t\tif (m_segs.size() >= MAX_LOCAL_SEGS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tm_segs.add(seg);\n\t\t} else {\n\t\t\t// Insert inbetween.\n\t\t\tint i;\n\t\t\tfor (i = 0; i < m_segs.size(); ++i)\n\t\t\t\tif (dist <= m_segs.get(i).d)\n\t\t\t\t\tbreak;\n\t\t\tm_segs.add(i, seg);\n\t\t}\n\t\twhile (m_segs.size() > MAX_LOCAL_SEGS) {\n\t\t\tm_segs.remove(m_segs.size() - 1);\n\t\t}\n\t}\n\tpublic void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (ref == 0) {\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\t\tvCopy(m_center, pos);\n\t\t// First query non-overlapping polygons.\n\t\tFindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);\n\t\tthis.m_polys = res.getRefs();\n\t\tm_segs.clear();\n\t\t// Secondly, store all polygon edges.\n\t\tfor (int j = 0; j < m_polys.size(); ++j) {\n\t\t\tGetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);\n\t\t\tfor (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {\n\t\t\t\tfloat[] s = gpws.getSegmentVerts().get(k);\n\t\t\t\t// Skip too distant segments.\n\t\t\t\tTupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);\n\t\t\t\tif (distseg.first > sqr(collisionQueryRange))\n\t\t\t\t\tcontinue;\n\t\t\t\taddSegment(distseg.first, s);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isValid(NavMeshQuery navquery, QueryFilter filter) {\n\t\tif (m_polys.isEmpty())\n\t\t\treturn false;\n\t\t// Check that all polygons still pass query filter.\n\t\tfor (long ref : m_polys) {\n\t\t\tif (!navquery.isValidPolyRef(ref, filter))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic float[] getCenter() {\n\t\treturn m_center;\n\t}\n\tpublic float[] getSegment(int j) {\n\t\treturn m_segs.get(j).s;\n\t}\n\tpublic int getSegmentCount() {\n\t\treturn m_segs.size();\n\t}\n"]]}
{"hexsha": "88dd300f77e53e19d8f96d18b70087d68f88fb62", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class InstantiatedLambdasTestRunner extends TestBase {\n\n  static final Class<?> CLASS = InstantiatedLambdasTest.class;\n  static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;\n  static final String EXPECTED = StringUtils.lines(\"Class implementation\", \"Lambda implementation\");\n\n  private final TestParameters parameters;\n\n  private Path inputJar;\n\n  @Parameters(name = \"{0}\")\n  public static TestParametersCollection data() {\n    return getTestParameters().withAllRuntimesAndApiLevels().build();\n  }\n\n  public InstantiatedLambdasTestRunner(TestParameters parameters) {\n    this.parameters = parameters;\n  }\n\n  @Before\n  public void writeAndRunInputJar() throws IOException {\n    inputJar = temp.getRoot().toPath().resolve(\"input.jar\");\n    ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);\n    for (Class<?> clazz : CLASSES) {\n      buildInput.accept(\n          ByteDataView.of(ToolHelper.getClassAsBytes(clazz)),\n          DescriptorUtils.javaTypeToDescriptor(clazz.getName()),\n          null);\n    }\n    buildInput.finished(null);\n  }\n\n  @Test\n  public void testProguard() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg.jar\", false);\n  }\n\n  @Test\n  public void testProguardAggressive() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg-aggressive.jar\", true);\n  }\n\n  @Test\n  public void testR8() throws Exception {\n    testR8(false);\n  }\n\n  @Test\n  public void testR8Aggressive() throws Exception {\n    testR8(true);\n  }\n\n  private void testR8(boolean aggressive) throws Exception {\n    testForR8(parameters.getBackend())\n        .addProgramFiles(inputJar)\n        .addKeepMainRule(CLASS)\n        .applyIf(aggressive, builder -> builder.addKeepRules(\"-overloadaggressively\"))\n        .debug()\n        .setMinApi(parameters.getApiLevel())\n        .compile()\n        .apply(\n            compileResult ->\n                compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED))\n        .applyIf(\n            parameters.isDexRuntime(),\n            compileResult ->\n                compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());\n  }\n\n  private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {\n    Path pgConfig = writeProguardRules(aggressive);\n    Path outPg = temp.getRoot().toPath().resolve(outName);\n    ProcessResult proguardResult =\n        ToolHelper.runProguard6Raw(\n            inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);\n    System.out.println(proguardResult.stdout);\n    if (proguardResult.exitCode != 0) {\n      System.out.println(proguardResult.stderr);\n    }\n    assertEquals(0, proguardResult.exitCode);\n    ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());\n    assertEquals(0, runPg.exitCode);\n  }\n\n  private Path writeProguardRules(boolean aggressive) throws IOException {\n    Path pgConfig = temp.getRoot().toPath().resolve(\"keep.txt\");\n    FileUtils.writeTextFile(\n        pgConfig,\n        \"-keep public class \" + CLASS.getCanonicalName() + \" {\",\n        \"  public static void main(...);\",\n        \"}\",\n        aggressive ? \"-overloadaggressively\" : \"# Not overloading aggressively\");\n    return pgConfig;\n  }\n}", "class_id": 0, "repo": "kami-lang/madex-r8", "file": "src/test/java/com/android/tools/r8/shaking/InstantiatedLambdasTestRunner.java", "last_update_at": "2021-09-01T09:50:44+00:00", "question_id": "88dd300f77e53e19d8f96d18b70087d68f88fb62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class InstantiatedLambdasTestRunner extends TestBase {\n  static final Class<?> CLASS = InstantiatedLambdasTest.class;\n  static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;\n  static final String EXPECTED = StringUtils.lines(\"Class implementation\", \"Lambda implementation\");\n  private final TestParameters parameters;\n  private Path inputJar;\n  @Parameters(name = \"{0}\")\n  public static TestParametersCollection data() {\n    return getTestParameters().withAllRuntimesAndApiLevels().build();\n  }\n  public InstantiatedLambdasTestRunner(TestParameters parameters) {\n    this.parameters = parameters;\n  }\n  @Before\n  public void writeAndRunInputJar() throws IOException {\n    inputJar = temp.getRoot().toPath().resolve(\"input.jar\");\n    ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);\n    for (Class<?> clazz : CLASSES) {\n      buildInput.accept(\n          ByteDataView.of(ToolHelper.getClassAsBytes(clazz)),\n          DescriptorUtils.javaTypeToDescriptor(clazz.getName()),\n          null);\n    }\n    buildInput.finished(null);\n  }\n  @Test\n  public void testProguard() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg.jar\", false);\n  }\n  @Test\n  public void testProguardAggressive() throws Exception {\n    assumeTrue(parameters.isCfRuntime());\n    buildAndRunProguard(\"pg-aggressive.jar\", true);\n  }\n  @Test\n  public void testR8() throws Exception {\n    testR8(false);\n  }\n  @Test\n  public void testR8Aggressive() throws Exception {\n    testR8(true);\n  }\n  private void testR8(boolean aggressive) throws Exception {\n    testForR8(parameters.getBackend())\n        .addProgramFiles(inputJar)\n        .addKeepMainRule(CLASS)\n        .applyIf(aggressive, builder -> builder.addKeepRules(\"-overloadaggressively\"))\n        .debug()\n        .setMinApi(parameters.getApiLevel())\n        .compile()\n        .apply(\n            compileResult ->\n                compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED))\n        .applyIf(\n            parameters.isDexRuntime(),\n            compileResult ->\n                compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());\n  }\n  private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {\n    Path pgConfig = writeProguardRules(aggressive);\n    Path outPg = temp.getRoot().toPath().resolve(outName);\n    ProcessResult proguardResult =\n        ToolHelper.runProguard6Raw(\n            inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);\n    System.out.println(proguardResult.stdout);\n    if (proguardResult.exitCode != 0) {\n      System.out.println(proguardResult.stderr);\n    }\n    assertEquals(0, proguardResult.exitCode);\n    ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());\n    assertEquals(0, runPg.exitCode);\n  }\n  private Path writeProguardRules(boolean aggressive) throws IOException {\n    Path pgConfig = temp.getRoot().toPath().resolve(\"keep.txt\");\n    FileUtils.writeTextFile(\n        pgConfig,\n        \"-keep public class \" + CLASS.getCanonicalName() + \" {\",\n        \"  public static void main(...);\",\n        \"}\",\n        aggressive ? \"-overloadaggressively\" : \"# Not overloading aggressively\");\n    return pgConfig;\n  }\n"]]}
{"hexsha": "176afd6c9a0292ae4cd8a03ac5d1212ccc2d7dc6", "ext": "java", "lang": "Java", "content": "class Arithmatic\r\n{\r\n    public static void main(String args[])\r\n    {\r\n        if(args.length != 2)\r\n        {\r\n            System.out.println(\"Please Enter Values \");\r\n            return;\r\n        }\r\n\r\n        // take the numbers from args, would be in string form \r\n        String s1 = args[0];\r\n        String s2 = args[1];\r\n\r\n        // convert them into numeric\r\n        double d1 = Double.parseDouble(s1);\r\n        double d2 = Double.parseDouble(s2);\r\n\r\n        double d3 = d1 + d2;\r\n        System.out.println(\"The Sum is : \" + d3);\r\n    }\r\n}", "class_id": 0, "repo": "PRASAD-DANGARE/JAVA", "file": "Command_Line_args2.java", "last_update_at": "2021-07-06T16:41:07+00:00", "question_id": "176afd6c9a0292ae4cd8a03ac5d1212ccc2d7dc6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Arithmatic\r\n{\r\n    public static void main(String args[])\r\n    {\r\n        if(args.length != 2)\r\n        {\r\n            System.out.println(\"Please Enter Values \");\r\n            return;\r\n        }\r\n\r\n        // take the numbers from args, would be in string form \r\n        String s1 = args[0];\r\n        String s2 = args[1];\r\n\r\n        // convert them into numeric\r\n        double d1 = Double.parseDouble(s1);\r\n        double d2 = Double.parseDouble(s2);\r\n\r\n        double d3 = d1 + d2;\r\n        System.out.println(\"The Sum is : \" + d3);\r\n    }\r\n"]]}
{"hexsha": "b58650221f683f40085428f04a18ec28d51489f9", "ext": "java", "lang": "Java", "content": "public class c {\n    private static final String a;\n\n    static {\n        a = c.class.getSimpleName();\n    }\n\n    public static void a(a aVar) {\n        if (DownloadService.a() == null) {\n            Bundle bundle;\n            Intent intent = new Intent();\n            intent.setClass(BrothersApplication.a(), LoadingActivity.class);\n            intent.addFlags(268435456);\n            intent.addFlags(67108864);\n            if (aVar == null) {\n                bundle = null;\n            } else {\n                bundle = new Bundle();\n                bundle.putString(\"cooperation_url\", aVar.a);\n                bundle.putString(\"cooperation_decode_url\", aVar.b);\n                bundle.putString(\"cooperation_title\", aVar.c);\n                bundle.putInt(\"cooperation_type\", aVar.d);\n                bundle.putInt(\"cooperation_play_time\", aVar.e);\n            }\n            if (bundle != null) {\n                intent.putExtras(bundle);\n            }\n            BrothersApplication.a().startActivity(intent);\n            return;\n        }\n        Object obj;\n        String str = aVar.a;\n        if (str.isEmpty() || !str.endsWith(\".torrent\")) {\n            obj = null;\n        } else {\n            obj = 1;\n        }\n        if (obj == null) {\n            aVar.b = aVar.a;\n            VodUtil.a();\n            VodUtil.a(aVar);\n        } else if (TextUtils.isEmpty(aVar.b)) {\n            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);\n            intent2.putExtra(\"cooperation_url\", aVar.a);\n            intent2.putExtra(\"cooperation_caller_packagename\", aVar.g);\n            intent2.setFlags(268435456);\n            intent2.addFlags(67108864);\n            BrothersApplication.a().startActivity(intent2);\n        } else {\n            VodUtil.a();\n            VodUtil.a(aVar);\n        }\n    }\n\n    public static a a(Intent intent) {\n        if (intent == null) {\n            return null;\n        }\n        a aVar;\n        int intExtra = intent.getIntExtra(\"cooperation_type\", 0);\n        if (b.a(intExtra)) {\n            String stringExtra = intent.getStringExtra(\"cooperation_url\");\n            intent.getStringExtra(\"cooperation_decode_url\");\n            aVar = new a(stringExtra, intent.getStringExtra(\"cooperation_title\"), intExtra, intent.getIntExtra(\"cooperation_play_time\", 0), null);\n        } else {\n            aVar = null;\n        }\n        return aVar;\n    }\n\n    public static String a(int i) {\n        return i == 1 ? \"uc\" : a.d;\n    }\n\n    public static int a(String str) {\n        return \"uc\".equals(str) ? 1 : 0;\n    }\n}", "class_id": 0, "repo": "megahertz0/android_thunder", "file": "dex_src/com/xunlei/downloadprovider/vod/a/c.java", "last_update_at": "2021-11-18T02:55:40+00:00", "question_id": "b58650221f683f40085428f04a18ec28d51489f9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class c {\n    private static final String a;\n    static {\n        a = c.class.getSimpleName();\n    }\n    public static void a(a aVar) {\n        if (DownloadService.a() == null) {\n            Bundle bundle;\n            Intent intent = new Intent();\n            intent.setClass(BrothersApplication.a(), LoadingActivity.class);\n            intent.addFlags(268435456);\n            intent.addFlags(67108864);\n            if (aVar == null) {\n                bundle = null;\n            } else {\n                bundle = new Bundle();\n                bundle.putString(\"cooperation_url\", aVar.a);\n                bundle.putString(\"cooperation_decode_url\", aVar.b);\n                bundle.putString(\"cooperation_title\", aVar.c);\n                bundle.putInt(\"cooperation_type\", aVar.d);\n                bundle.putInt(\"cooperation_play_time\", aVar.e);\n            }\n            if (bundle != null) {\n                intent.putExtras(bundle);\n            }\n            BrothersApplication.a().startActivity(intent);\n            return;\n        }\n        Object obj;\n        String str = aVar.a;\n        if (str.isEmpty() || !str.endsWith(\".torrent\")) {\n            obj = null;\n        } else {\n            obj = 1;\n        }\n        if (obj == null) {\n            aVar.b = aVar.a;\n            VodUtil.a();\n            VodUtil.a(aVar);\n        } else if (TextUtils.isEmpty(aVar.b)) {\n            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);\n            intent2.putExtra(\"cooperation_url\", aVar.a);\n            intent2.putExtra(\"cooperation_caller_packagename\", aVar.g);\n            intent2.setFlags(268435456);\n            intent2.addFlags(67108864);\n            BrothersApplication.a().startActivity(intent2);\n        } else {\n            VodUtil.a();\n            VodUtil.a(aVar);\n        }\n    }\n    public static a a(Intent intent) {\n        if (intent == null) {\n            return null;\n        }\n        a aVar;\n        int intExtra = intent.getIntExtra(\"cooperation_type\", 0);\n        if (b.a(intExtra)) {\n            String stringExtra = intent.getStringExtra(\"cooperation_url\");\n            intent.getStringExtra(\"cooperation_decode_url\");\n            aVar = new a(stringExtra, intent.getStringExtra(\"cooperation_title\"), intExtra, intent.getIntExtra(\"cooperation_play_time\", 0), null);\n        } else {\n            aVar = null;\n        }\n        return aVar;\n    }\n    public static String a(int i) {\n        return i == 1 ? \"uc\" : a.d;\n    }\n    public static int a(String str) {\n        return \"uc\".equals(str) ? 1 : 0;\n    }\n"]]}
{"hexsha": "3821c2ca9d58dbb74b7f64e42156ebd845507391", "ext": "java", "lang": "Java", "content": "@Data\r\npublic class RouteClientInit {\r\n\tprivate final String url;\r\n\tprivate final int maxContentLength;\r\n\tprivate final String headerRouteValue;\r\n\tprivate Channel channel;\r\n\tprivate CompletableFuture<DefaultFullHttpResponse> response;\r\n\r\n\tpublic RouteClientInit(String url, int maxContentLength, String headerRouteValue) {\r\n\t\tthis.url = url;\r\n\t\tthis.maxContentLength = maxContentLength;\r\n\t\tthis.headerRouteValue = headerRouteValue;\r\n\t}\r\n\r\n\tpublic DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {\r\n\t\tinit().writeAndFlush(defaultFullHttpRequest);\r\n\t\treturn response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);\r\n\t}\r\n\r\n\tpublic void call(DefaultFullHttpResponse defaultFullHttpResponse) {\r\n\t\tresponse.complete(defaultFullHttpResponse);\r\n\t}\r\n\r\n\tprivate Channel init() throws InterruptedException {\r\n\t\tresponse = new CompletableFuture<>();\r\n\t\tif (ChannelUtils.channelIsActive(channel)) {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\t\tchannel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue))\r\n\t\t\t\t.channel(NioSocketChannel.class)\r\n\t\t\t\t.handler(new RouteClientInitializer(this))\r\n\t\t\t\t.connect(SocketAddressUtils.getInetSocketAddress(url))\r\n\t\t\t\t.sync()\r\n\t\t\t\t.channel();\r\n\t\treturn channel;\r\n\t}\r\n\r\n\r\n}", "class_id": 0, "repo": "15662664518/web-route-spring-boot-starter", "file": "web-route-spring-boot-autoconfigure/src/main/java/com/github/thierrysquirrel/web/route/netty/client/init/RouteClientInit.java", "last_update_at": "2021-05-22T03:56:42+00:00", "question_id": "3821c2ca9d58dbb74b7f64e42156ebd845507391", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\r\npublic class RouteClientInit {\r\n\tprivate final String url;\r\n\tprivate final int maxContentLength;\r\n\tprivate final String headerRouteValue;\r\n\tprivate Channel channel;\r\n\tprivate CompletableFuture<DefaultFullHttpResponse> response;\r\n\r\n\tpublic RouteClientInit(String url, int maxContentLength, String headerRouteValue) {\r\n\t\tthis.url = url;\r\n\t\tthis.maxContentLength = maxContentLength;\r\n\t\tthis.headerRouteValue = headerRouteValue;\r\n\t}\r\n\r\n\tpublic DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {\r\n\t\tinit().writeAndFlush(defaultFullHttpRequest);\r\n\t\treturn response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);\r\n\t}\r\n\r\n\tpublic void call(DefaultFullHttpResponse defaultFullHttpResponse) {\r\n\t\tresponse.complete(defaultFullHttpResponse);\r\n\t}\r\n\r\n\tprivate Channel init() throws InterruptedException {\r\n\t\tresponse = new CompletableFuture<>();\r\n\t\tif (ChannelUtils.channelIsActive(channel)) {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\t\tchannel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue))\r\n\t\t\t\t.channel(NioSocketChannel.class)\r\n\t\t\t\t.handler(new RouteClientInitializer(this))\r\n\t\t\t\t.connect(SocketAddressUtils.getInetSocketAddress(url))\r\n\t\t\t\t.sync()\r\n\t\t\t\t.channel();\r\n\t\treturn channel;\r\n\t}\r\n\r\n\r\n"]]}
{"hexsha": "ff542139117e2ec97abdccaa834b9817bd33a05d", "ext": "java", "lang": "Java", "content": "public class DBController {\n    private static final String DB_NAME = \"fruits_db.db\";\n    private DaoMaster.DevOpenHelper mHelpler;\n    private SQLiteDatabase mDb;\n    private DaoMaster mDaoMaster;\n    private DaoSession mDaoSession;\n    private Context mContext;\n    private UserDao mUserDao;\n    private HistoryDao mHistoryDao;\n    private CollectionDao mCollectionDao;\n    private QuickDao mQuickDao;\n    private static DBController sDbController;\n\n    public static DBController getInstance(Context context) {\n        if (sDbController == null) {\n            synchronized (DBController.class){\n                if (sDbController == null) {\n                    sDbController = new DBController(context);\n                }\n            }\n        }\n        return sDbController;\n    }\n\n    public DBController(Context context) {\n        mContext = context;\n        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        mDaoMaster = new DaoMaster(getWrittableDatabase());\n        mDaoSession = mDaoMaster.newSession();\n        mUserDao = mDaoSession.getUserDao();\n        mHistoryDao = mDaoSession.getHistoryDao();\n        mCollectionDao = mDaoSession.getCollectionDao();\n        mQuickDao = mDaoSession.getQuickDao();\n    }\n\n    private SQLiteDatabase getWrittableDatabase() {\n        if (mHelpler == null) {\n            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        }\n        mDb = mHelpler.getWritableDatabase();\n        return mDb;\n    }\n\n    public long insertUser(User user) {\n        return mUserDao.insert(user);\n    }\n\n    public User checkUserAndPassword(String whereUser, String wherePassword) {\n        User user = mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser),\n                        UserDao.Properties.Password.eq(wherePassword)).build().unique();\n        return user;\n    }\n\n    public boolean checkUserExist(String whereUser) {\n        List<User>users = (List<User>)mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser)).build().list();\n        return !users.isEmpty();\n    }\n\n    public void insertHistory(List<History> histories) {\n        for (int i = 0; i < histories.size(); i++) {\n            List<History>res = mHistoryDao.queryBuilder()\n                    .where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(histories.get(i).getTime()))\n                    .build().list();\n            if (res == null || res.isEmpty()) {\n                mHistoryDao.insert(histories.get(i));\n            } else {\n                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                        HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete()\n                        .executeDeleteWithoutDetachingEntities();\n                mHistoryDao.insert(histories.get(i));\n            }\n        }\n    }\n\n    public void deleteAllHistory() {\n        mHistoryDao.deleteAll();\n    }\n\n    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < historiesToBeDeleted.size(); i++) {\n                    mHistoryDao.queryBuilder()\n                            .where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public List<History> getAll() {\n        List<History> all = (List<History>)mHistoryDao.queryBuilder().build().list();\n        return all;\n    }\n\n    public List<Collection> getUserCollection(String username) {\n        List<Collection> res = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username)).build().list();\n        return res;\n    }\n\n    public void addCollection(String username, String url, String title) {\n        List<Collection> exist = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username),\n                        CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title))\n                .build().list();\n        if (exist == null || exist.isEmpty()) {\n            mCollectionDao.insert(new Collection(username, url, title));\n        } else {\n            return;\n        }\n    }\n\n    public void deleteAllCollection(String username) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void deleteSelectedCollection(List<Collection> toBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < toBeDeleted.size(); i++) {\n                    mCollectionDao.queryBuilder()\n                            .where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()),\n                            CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()),\n                            CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public void changeUsername(String name, String newName) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setCustomizeName(newName);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public String getProfile(String name) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        return findUser.getProfile();\n    }\n\n    public void setProfile(String name, String profile) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setProfile(profile);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void changePassword(String name, String newPassword) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setPassword(newPassword);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void deleteUser(String name) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public boolean insertQuick(String title, String url) {\n        Quick quick = new Quick(null, title, url);\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        if (res != null) {\n            return false;\n        } else {\n            mQuickDao.insert(quick);\n            return true;\n        }\n    }\n\n    public List<Quick> getQuick() {\n        return mQuickDao.loadAll();\n    }\n\n    public void deleteQuick(String title, String url) {\n        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void changeQuick(String title, String url, String newTitle, String newUrl) {\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        res.setTitle(newTitle);\n        res.setUrl(newUrl);\n        mQuickDao.update(res);\n    }\n}", "class_id": 0, "repo": "HeXavi8/Orange-Browser", "file": "app/src/main/java/com/example/fruit/dao/DBController.java", "last_update_at": "2021-11-28T01:58:02+00:00", "question_id": "ff542139117e2ec97abdccaa834b9817bd33a05d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DBController {\n    private static final String DB_NAME = \"fruits_db.db\";\n    private DaoMaster.DevOpenHelper mHelpler;\n    private SQLiteDatabase mDb;\n    private DaoMaster mDaoMaster;\n    private DaoSession mDaoSession;\n    private Context mContext;\n    private UserDao mUserDao;\n    private HistoryDao mHistoryDao;\n    private CollectionDao mCollectionDao;\n    private QuickDao mQuickDao;\n    private static DBController sDbController;\n    public static DBController getInstance(Context context) {\n        if (sDbController == null) {\n            synchronized (DBController.class){\n                if (sDbController == null) {\n                    sDbController = new DBController(context);\n                }\n            }\n        }\n        return sDbController;\n    }\n    public DBController(Context context) {\n        mContext = context;\n        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        mDaoMaster = new DaoMaster(getWrittableDatabase());\n        mDaoSession = mDaoMaster.newSession();\n        mUserDao = mDaoSession.getUserDao();\n        mHistoryDao = mDaoSession.getHistoryDao();\n        mCollectionDao = mDaoSession.getCollectionDao();\n        mQuickDao = mDaoSession.getQuickDao();\n    }\n    private SQLiteDatabase getWrittableDatabase() {\n        if (mHelpler == null) {\n            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        }\n        mDb = mHelpler.getWritableDatabase();\n        return mDb;\n    }\n    public long insertUser(User user) {\n        return mUserDao.insert(user);\n    }\n    public User checkUserAndPassword(String whereUser, String wherePassword) {\n        User user = mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser),\n                        UserDao.Properties.Password.eq(wherePassword)).build().unique();\n        return user;\n    }\n    public boolean checkUserExist(String whereUser) {\n        List<User>users = (List<User>)mUserDao.queryBuilder()\n                .where(UserDao.Properties.Name.eq(whereUser)).build().list();\n        return !users.isEmpty();\n    }\n    public void insertHistory(List<History> histories) {\n        for (int i = 0; i < histories.size(); i++) {\n            List<History>res = mHistoryDao.queryBuilder()\n                    .where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(histories.get(i).getTime()))\n                    .build().list();\n            if (res == null || res.isEmpty()) {\n                mHistoryDao.insert(histories.get(i));\n            } else {\n                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()),\n                        HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete()\n                        .executeDeleteWithoutDetachingEntities();\n                mHistoryDao.insert(histories.get(i));\n            }\n        }\n    }\n    public void deleteAllHistory() {\n        mHistoryDao.deleteAll();\n    }\n    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < historiesToBeDeleted.size(); i++) {\n                    mHistoryDao.queryBuilder()\n                            .where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()),\n                            HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n    public List<History> getAll() {\n        List<History> all = (List<History>)mHistoryDao.queryBuilder().build().list();\n        return all;\n    }\n    public List<Collection> getUserCollection(String username) {\n        List<Collection> res = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username)).build().list();\n        return res;\n    }\n    public void addCollection(String username, String url, String title) {\n        List<Collection> exist = mCollectionDao.queryBuilder()\n                .where(CollectionDao.Properties.Name.eq(username),\n                        CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title))\n                .build().list();\n        if (exist == null || exist.isEmpty()) {\n            mCollectionDao.insert(new Collection(username, url, title));\n        } else {\n            return;\n        }\n    }\n    public void deleteAllCollection(String username) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n    public void deleteSelectedCollection(List<Collection> toBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < toBeDeleted.size(); i++) {\n                    mCollectionDao.queryBuilder()\n                            .where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()),\n                            CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()),\n                            CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle()))\n                            .buildDelete()\n                            .executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n    public void changeUsername(String name, String newName) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setCustomizeName(newName);\n            mUserDao.update(findUser);\n        }\n    }\n    public String getProfile(String name) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        return findUser.getProfile();\n    }\n    public void setProfile(String name, String profile) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setProfile(profile);\n            mUserDao.update(findUser);\n        }\n    }\n    public void changePassword(String name, String newPassword) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .build().unique();\n        if (findUser != null) {\n            findUser.setPassword(newPassword);\n            mUserDao.update(findUser);\n        }\n    }\n    public void deleteUser(String name) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n    public boolean insertQuick(String title, String url) {\n        Quick quick = new Quick(null, title, url);\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        if (res != null) {\n            return false;\n        } else {\n            mQuickDao.insert(quick);\n            return true;\n        }\n    }\n    public List<Quick> getQuick() {\n        return mQuickDao.loadAll();\n    }\n    public void deleteQuick(String title, String url) {\n        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url))\n                .buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n    public void changeQuick(String title, String url, String newTitle, String newUrl) {\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title),\n                QuickDao.Properties.Url.eq(url)).build().unique();\n        res.setTitle(newTitle);\n        res.setUrl(newUrl);\n        mQuickDao.update(res);\n    }\n"]]}
{"hexsha": "48e6cf123eb4cbfdcdfdd0e229d4bb6928328e8c", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class CommonFloatService {\n\n    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);\n\n    private final CommonFloatRepository commonFloatRepository;\n\n    private final CacheManager cacheManager;\n\n    private final CommonFloatMapper commonFloatMapper;\n\n    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {\n        this.commonFloatRepository = commonFloatRepository;\n        this.cacheManager = cacheManager;\n        this.commonFloatMapper = commonFloatMapper;\n    }\n\n    /**\n     * Save a commonFloat.\n     *\n     * @param commonFloatDTO the entity to save.\n     * @return the persisted entity.\n     */\n    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {\n        log.debug(\"Request to save CommonFloat : {}\", commonFloatDTO);\n        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);\n        commonFloat = commonFloatRepository.save(commonFloat);\n        return commonFloatMapper.toDto(commonFloat);\n    }\n\n    /**\n     * Get all the commonFloats.\n     *\n     * @param pageable the pagination information.\n     * @return the list of entities.\n     */\n    @Transactional(readOnly = true)\n    public Page<CommonFloatDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all CommonFloats\");\n        return commonFloatRepository.findAll(pageable)\n            .map(commonFloatMapper::toDto);\n    }\n\n    /**\n    * count all the commonFloats.\n    *\n    * @return the count of entities\n    * by wangxin\n    */\n    @Transactional(readOnly = true)\n    public long count() {\n        log.debug(\"Request to count all CommonFloats\");\n        return commonFloatRepository.count();\n    }\n\n    /**\n     * Get one commonFloat by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Transactional(readOnly = true)\n    public Optional<CommonFloatDTO> findOne(Long id) {\n        log.debug(\"Request to get CommonFloat : {}\", id);\n        return commonFloatRepository.findById(id)\n            .map(commonFloatMapper::toDto);\n    }\n\n    /**\n     * Delete the commonFloat by id.\n     *\n     * @param id the id of the entity.\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete CommonFloat : {}\", id);\n        commonFloatRepository.deleteById(id);\n    }\n\n    /**\n     * Update specified fields by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n\n    /**\n     * Update specified field by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO,fieldName));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n    // jhipster-needle-service-add-method - JHipster will add getters and setters here, do not remove\n\n}", "class_id": 0, "repo": "wangxinxx/jhi-ant-vue", "file": "src/main/java/com/aidriveall/cms/service/CommonFloatService.java", "last_update_at": "2021-08-18T18:54:11+00:00", "question_id": "48e6cf123eb4cbfdcdfdd0e229d4bb6928328e8c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class CommonFloatService {\n    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);\n    private final CommonFloatRepository commonFloatRepository;\n    private final CacheManager cacheManager;\n    private final CommonFloatMapper commonFloatMapper;\n    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {\n        this.commonFloatRepository = commonFloatRepository;\n        this.cacheManager = cacheManager;\n        this.commonFloatMapper = commonFloatMapper;\n    }\n    /**\n     * Save a commonFloat.\n     *\n     * @param commonFloatDTO the entity to save.\n     * @return the persisted entity.\n     */\n    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {\n        log.debug(\"Request to save CommonFloat : {}\", commonFloatDTO);\n        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);\n        commonFloat = commonFloatRepository.save(commonFloat);\n        return commonFloatMapper.toDto(commonFloat);\n    }\n    /**\n     * Get all the commonFloats.\n     *\n     * @param pageable the pagination information.\n     * @return the list of entities.\n     */\n    @Transactional(readOnly = true)\n    public Page<CommonFloatDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all CommonFloats\");\n        return commonFloatRepository.findAll(pageable)\n            .map(commonFloatMapper::toDto);\n    }\n    /**\n    * count all the commonFloats.\n    *\n    * @return the count of entities\n    * by wangxin\n    */\n    @Transactional(readOnly = true)\n    public long count() {\n        log.debug(\"Request to count all CommonFloats\");\n        return commonFloatRepository.count();\n    }\n    /**\n     * Get one commonFloat by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Transactional(readOnly = true)\n    public Optional<CommonFloatDTO> findOne(Long id) {\n        log.debug(\"Request to get CommonFloat : {}\", id);\n        return commonFloatRepository.findById(id)\n            .map(commonFloatMapper::toDto);\n    }\n    /**\n     * Delete the commonFloat by id.\n     *\n     * @param id the id of the entity.\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete CommonFloat : {}\", id);\n        commonFloatRepository.deleteById(id);\n    }\n    /**\n     * Update specified fields by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n    /**\n     * Update specified field by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO,fieldName));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n    // jhipster-needle-service-add-method - JHipster will add getters and setters here, do not remove\n"]]}
{"hexsha": "a38fec13b412ae11bdd8b5e9e7e1fe1d7cd98108", "ext": "java", "lang": "Java", "content": "public class IndustrialJackhammerItem extends JackhammerItem {\n\n\tpublic IndustrialJackhammerItem() {\n\t\tsuper(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);\n\t}\n\n\t// Cycle Inactive, Active 3*3 and Active 5*5\n\tprivate void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {\n\t\tItemUtils.checkActive(stack, cost, isClient, messageId);\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\tif (isClient) {\n\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"3*3\"));\n\t\t\t}\n\t\t} else {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\t} else {\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", true);\n\t\t\t\tif (isClient) {\n\t\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"5*5\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {\n\t\tif (originalPos.equals(pos)) {\n\t\t\treturn false;\n\t\t}\n\t\tBlockState blockState = worldIn.getBlockState(pos);\n\t\tif (blockState.getMaterial() == Material.AIR) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getMaterial().isLiquid()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof OreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof RedstoneOreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (Items.IRON_PICKAXE.isEffectiveOn(blockState));\n\t}\n\n\tprivate boolean isAOE5(ItemStack stack) {\n\t\treturn !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean(\"AOE5\");\n\t}\n\n\t// JackhammerItem\n\t@Override\n\tpublic boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t\t}\n\t\tint radius = isAOE5(stack) ? 2 : 1;\n\t\tfor (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {\n\t\t\tif (shouldBreak(worldIn, pos, additionalPos)) {\n\t\t\t\tToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);\n\t\t\t}\n\t\t}\n\n\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t}\n\n\t// PickaxeItem\n\t@Override\n\tpublic float getMiningSpeed(ItemStack stack, BlockState state) {\n\t\tif (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {\n\t\t\t// x4 diamond mining speed\n\t\t\treturn 32.0F;\n\t\t} else {\n\t\t\treturn 0.5F;\n\t\t}\n\t}\n\n\t// Item\n\t@Override\n\tpublic TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {\n\t\tfinal ItemStack stack = player.getStackInHand(hand);\n\t\tif (player.isSneaking()) {\n\t\t\tswitchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);\n\t\t\treturn new TypedActionResult<>(ActionResult.SUCCESS, stack);\n\t\t}\n\t\treturn new TypedActionResult<>(ActionResult.PASS, stack);\n\t}\n\n\t@Override\n\tpublic void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {\n\t\tItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);\n\t}\n\n\t@Environment(EnvType.CLIENT)\n\t@Override\n\tpublic void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {\n\t\tItemUtils.buildActiveTooltip(stack, tooltip);\n\t\tif (ItemUtils.isActive(stack)) {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\ttooltip.add(new LiteralText(\"5*5\").formatted(Formatting.RED));\n\t\t\t} else {\n\t\t\t\ttooltip.add(new LiteralText(\"3*3\").formatted(Formatting.RED));\n\t\t\t}\n\t\t}\n\t}\n}", "class_id": 0, "repo": "PhoneixS/TechReborn", "file": "src/main/java/techreborn/items/tool/industrial/IndustrialJackhammerItem.java", "last_update_at": "2021-03-12T06:48:49+00:00", "question_id": "a38fec13b412ae11bdd8b5e9e7e1fe1d7cd98108", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IndustrialJackhammerItem extends JackhammerItem {\n\tpublic IndustrialJackhammerItem() {\n\t\tsuper(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);\n\t}\n\t// Cycle Inactive, Active 3*3 and Active 5*5\n\tprivate void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {\n\t\tItemUtils.checkActive(stack, cost, isClient, messageId);\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\tif (isClient) {\n\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"3*3\"));\n\t\t\t}\n\t\t} else {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\tItemUtils.switchActive(stack, cost, isClient, messageId);\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", false);\n\t\t\t} else {\n\t\t\t\tstack.getOrCreateTag().putBoolean(\"AOE5\", true);\n\t\t\t\tif (isClient) {\n\t\t\t\t\tChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"5*5\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {\n\t\tif (originalPos.equals(pos)) {\n\t\t\treturn false;\n\t\t}\n\t\tBlockState blockState = worldIn.getBlockState(pos);\n\t\tif (blockState.getMaterial() == Material.AIR) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getMaterial().isLiquid()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof OreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\tif (blockState.getBlock() instanceof RedstoneOreBlock) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (Items.IRON_PICKAXE.isEffectiveOn(blockState));\n\t}\n\tprivate boolean isAOE5(ItemStack stack) {\n\t\treturn !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean(\"AOE5\");\n\t}\n\t// JackhammerItem\n\t@Override\n\tpublic boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {\n\t\tif (!ItemUtils.isActive(stack)) {\n\t\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t\t}\n\t\tint radius = isAOE5(stack) ? 2 : 1;\n\t\tfor (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {\n\t\t\tif (shouldBreak(worldIn, pos, additionalPos)) {\n\t\t\t\tToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);\n\t\t\t}\n\t\t}\n\t\treturn super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n\t}\n\t// PickaxeItem\n\t@Override\n\tpublic float getMiningSpeed(ItemStack stack, BlockState state) {\n\t\tif (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {\n\t\t\t// x4 diamond mining speed\n\t\t\treturn 32.0F;\n\t\t} else {\n\t\t\treturn 0.5F;\n\t\t}\n\t}\n\t// Item\n\t@Override\n\tpublic TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {\n\t\tfinal ItemStack stack = player.getStackInHand(hand);\n\t\tif (player.isSneaking()) {\n\t\t\tswitchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);\n\t\t\treturn new TypedActionResult<>(ActionResult.SUCCESS, stack);\n\t\t}\n\t\treturn new TypedActionResult<>(ActionResult.PASS, stack);\n\t}\n\t@Override\n\tpublic void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {\n\t\tItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);\n\t}\n\t@Environment(EnvType.CLIENT)\n\t@Override\n\tpublic void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {\n\t\tItemUtils.buildActiveTooltip(stack, tooltip);\n\t\tif (ItemUtils.isActive(stack)) {\n\t\t\tif (isAOE5(stack)) {\n\t\t\t\ttooltip.add(new LiteralText(\"5*5\").formatted(Formatting.RED));\n\t\t\t} else {\n\t\t\t\ttooltip.add(new LiteralText(\"3*3\").formatted(Formatting.RED));\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "0258fec1fbbbd04e532d61c0a501cd3898fe0f43", "ext": "java", "lang": "Java", "content": "public class MockXDSBridge extends XDSBridge {\n\n    /**\n     * Constructs ...\n     *\n     *\n     * @param config\n     */\n    public MockXDSBridge(XDSBridgeServiceContext config) {\n\n        super();\n        XDSBridge.serviceContext = config;\n    }\n\n    /**\n     * Method description\n     *\n     *\n     * @param service_name\n     * @param request\n     *\n     * @return\n     *\n     * @throws AxisFault\n     */\n    @Override\n    protected void beginTransaction(String service_name,\n            OMElement request)\n            throws SOAPFaultException {\n\n        String remoteIP = \"127.0.0.2\";\n        XLogger xlogger = XLogger.getInstance();\n\n        log_message = xlogger.getNewMessage(remoteIP);\n        log_message.setTestMessage(\"TEST\");\n    }\n\n    /**\n     * Method description\n     *\n     *\n     * @return\n     */\n    @Override\n    protected MessageContext getCurrentMessageContext() {\n\n        return new MockMessageContext();\n    }\n}", "class_id": 0, "repo": "kef/hieos", "file": "src/xdsbridge/src/test/java/com/vangent/hieos/services/xds/bridge/mock/MockXDSBridge.java", "last_update_at": "2021-11-27T10:56:53+00:00", "question_id": "0258fec1fbbbd04e532d61c0a501cd3898fe0f43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockXDSBridge extends XDSBridge {\n    /**\n     * Constructs ...\n     *\n     *\n     * @param config\n     */\n    public MockXDSBridge(XDSBridgeServiceContext config) {\n        super();\n        XDSBridge.serviceContext = config;\n    }\n    /**\n     * Method description\n     *\n     *\n     * @param service_name\n     * @param request\n     *\n     * @return\n     *\n     * @throws AxisFault\n     */\n    @Override\n    protected void beginTransaction(String service_name,\n            OMElement request)\n            throws SOAPFaultException {\n        String remoteIP = \"127.0.0.2\";\n        XLogger xlogger = XLogger.getInstance();\n        log_message = xlogger.getNewMessage(remoteIP);\n        log_message.setTestMessage(\"TEST\");\n    }\n    /**\n     * Method description\n     *\n     *\n     * @return\n     */\n    @Override\n    protected MessageContext getCurrentMessageContext() {\n        return new MockMessageContext();\n    }\n"]]}
{"hexsha": "9118fce3ef781ce323072a537ba766e7bc58d1c4", "ext": "java", "lang": "Java", "content": "public class EinfacheGui implements ActionListener, KeyListener {\n  private JFrame myFrame;\n  private Container myContentPane;\n  private JButton myButtonClickMich;\n\n  private int height = 350;\n  private int width = 350;\n  private double factor = 0.3;\n\n  public EinfacheGui() {\n    myFrame = new JFrame(\"Einfache Gui\");\n    myFrame.setSize(width, height);\n    myFrame.setLocationRelativeTo(null);\n    myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    myButtonClickMich = new JButton(\"Button\");\n    myButtonClickMich.addActionListener(this);\n    myButtonClickMich.addKeyListener(this);\n\n    myFrame.add(myButtonClickMich);\n    myFrame.setVisible(true);\n\n  }\n\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    double w = myFrame.getWidth() - myFrame.getWidth() * factor;\n    double h = myFrame.getHeight() - myFrame.getHeight() * factor;\n\n    if ((w + h) < 150)\n      myFrame.setSize(width, height);\n    else\n      myFrame.setSize((int) w, (int) h);\n\n    myFrame.setLocationRelativeTo(null);\n  }\n\n  @Override\n  public void keyTyped(KeyEvent e) {\n  }\n\n  @Override\n  public void keyPressed(KeyEvent e) {\n    if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {\n      JOptionPane.showMessageDialog(myFrame, \"Geschafft\");\n    }\n    System.out.println(e.getExtendedKeyCode() + \" pressed\");\n  }\n\n  @Override\n  public void keyReleased(KeyEvent e) {\n  }\n\n}", "class_id": 0, "repo": "thieleju/studium", "file": "Programmiertechnik_II/Workbook4/EinfacheGui.java", "last_update_at": "2021-11-17T12:30:49+00:00", "question_id": "9118fce3ef781ce323072a537ba766e7bc58d1c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EinfacheGui implements ActionListener, KeyListener {\n  private JFrame myFrame;\n  private Container myContentPane;\n  private JButton myButtonClickMich;\n  private int height = 350;\n  private int width = 350;\n  private double factor = 0.3;\n  public EinfacheGui() {\n    myFrame = new JFrame(\"Einfache Gui\");\n    myFrame.setSize(width, height);\n    myFrame.setLocationRelativeTo(null);\n    myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    myButtonClickMich = new JButton(\"Button\");\n    myButtonClickMich.addActionListener(this);\n    myButtonClickMich.addKeyListener(this);\n    myFrame.add(myButtonClickMich);\n    myFrame.setVisible(true);\n  }\n  @Override\n  public void actionPerformed(ActionEvent e) {\n    double w = myFrame.getWidth() - myFrame.getWidth() * factor;\n    double h = myFrame.getHeight() - myFrame.getHeight() * factor;\n    if ((w + h) < 150)\n      myFrame.setSize(width, height);\n    else\n      myFrame.setSize((int) w, (int) h);\n    myFrame.setLocationRelativeTo(null);\n  }\n  @Override\n  public void keyTyped(KeyEvent e) {\n  }\n  @Override\n  public void keyPressed(KeyEvent e) {\n    if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {\n      JOptionPane.showMessageDialog(myFrame, \"Geschafft\");\n    }\n    System.out.println(e.getExtendedKeyCode() + \" pressed\");\n  }\n  @Override\n  public void keyReleased(KeyEvent e) {\n  }\n"]]}
{"hexsha": "895b29ca56c1e747cd96f886c95fd5020c83bf5d", "ext": "java", "lang": "Java", "content": "public class ConnectionOpeningImpl implements IBestPractice {\n\n\t@Value(\"${connections.connectionOpening.title}\")\n\tprivate String overviewTitle;\n\t\n\t@Value(\"${connections.connectionOpening.detailedTitle}\")\n\tprivate String detailTitle;\n\t\n\t@Value(\"${connections.connectionOpening.desc}\")\n\tprivate String aboutText;\n\t\n\t@Value(\"${connections.connectionOpening.url}\")\n\tprivate String learnMoreUrl;\n\t\n\t@Value(\"${connections.connectionOpening.selfEvaluation}\")\n\tprivate String textResult;\n\t\n\t\n\t@Override\n\tpublic AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {\n\t\tConnectionOpeningResult result = new ConnectionOpeningResult();\n\t\tresult.setSelfTest(true);\n\t\tresult.setAboutText(aboutText);\n\t\tresult.setDetailTitle(detailTitle);\n\t\tresult.setLearnMoreUrl(learnMoreUrl);\n\t\tresult.setOverviewTitle(overviewTitle);\n\t\tresult.setResultText(textResult);\n\t\tresult.setResultType(BPResultType.SELF_TEST);\n\t\t\n\t\treturn result;\n\t}\n\n}", "class_id": 0, "repo": "j420247/ARO", "file": "5.0.0/ARO.Core/src/main/java/com/att/aro/core/bestpractice/impl/ConnectionOpeningImpl.java", "last_update_at": "2021-11-12T11:34:34+00:00", "question_id": "895b29ca56c1e747cd96f886c95fd5020c83bf5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConnectionOpeningImpl implements IBestPractice {\n\t@Value(\"${connections.connectionOpening.title}\")\n\tprivate String overviewTitle;\n\t\n\t@Value(\"${connections.connectionOpening.detailedTitle}\")\n\tprivate String detailTitle;\n\t\n\t@Value(\"${connections.connectionOpening.desc}\")\n\tprivate String aboutText;\n\t\n\t@Value(\"${connections.connectionOpening.url}\")\n\tprivate String learnMoreUrl;\n\t\n\t@Value(\"${connections.connectionOpening.selfEvaluation}\")\n\tprivate String textResult;\n\t\n\t\n\t@Override\n\tpublic AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {\n\t\tConnectionOpeningResult result = new ConnectionOpeningResult();\n\t\tresult.setSelfTest(true);\n\t\tresult.setAboutText(aboutText);\n\t\tresult.setDetailTitle(detailTitle);\n\t\tresult.setLearnMoreUrl(learnMoreUrl);\n\t\tresult.setOverviewTitle(overviewTitle);\n\t\tresult.setResultText(textResult);\n\t\tresult.setResultType(BPResultType.SELF_TEST);\n\t\t\n\t\treturn result;\n\t}\n"]]}
{"hexsha": "b7cad21f3c37603e9f2c3cc34f0e1a6e357d10f3", "ext": "java", "lang": "Java", "content": "public class BulletEffectAttractive implements BulletEffect {\n\t@Override\n\tpublic String getID() {\n\t\treturn \"attractive\";\n\t}\n\n\t@Override\n\tpublic boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {\n\t\tif (hitEntity instanceof EntityAnimal) {\n\t\t\t((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.setCollision(true);\n\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {\n\t\t\tbuild.setLifetime(RandUtil.nextInt(20, 40));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));\n\t\t\tbuild.setAlphaFunction(new InterpFadeInOut(0f, 1f));\n\t\t\tbuild.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));\n\t\t\tbuild.setDeceleration(new Vec3d(0.7, 0.7, 0.7));\n\n\t\t\tdouble radius = 2 * RandUtil.nextFloat();\n\t\t\tdouble theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();\n\t\t\tdouble x = radius * MathHelper.cos((float) theta);\n\t\t\tdouble z = radius * MathHelper.sin((float) theta);\n\n\t\t\tbuild.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));\n\t\t});\n\t}\n\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.setCollision(true);\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.disableRandom();\n\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {\n\t\t\tbuild.setScaleFunction(new InterpScale(0.5f, 0));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));\n\t\t});\n\t}\n\n\t@Override\n\tpublic @Nullable\n\tSoundEvent getImpactSound() {\n\t\treturn RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;\n\t}\n}", "class_id": 0, "repo": "Demoniaque/Shotguns-And-Glitter", "file": "src/main/java/com/teamwizardry/shotgunsandglitter/common/effects/BulletEffectAttractive.java", "last_update_at": "2021-01-07T21:18:51+00:00", "question_id": "b7cad21f3c37603e9f2c3cc34f0e1a6e357d10f3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BulletEffectAttractive implements BulletEffect {\n\t@Override\n\tpublic String getID() {\n\t\treturn \"attractive\";\n\t}\n\t@Override\n\tpublic boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {\n\t\tif (hitEntity instanceof EntityAnimal) {\n\t\t\t((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.setCollision(true);\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {\n\t\t\tbuild.setLifetime(RandUtil.nextInt(20, 40));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));\n\t\t\tbuild.setAlphaFunction(new InterpFadeInOut(0f, 1f));\n\t\t\tbuild.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));\n\t\t\tbuild.setDeceleration(new Vec3d(0.7, 0.7, 0.7));\n\t\t\tdouble radius = 2 * RandUtil.nextFloat();\n\t\t\tdouble theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();\n\t\t\tdouble x = radius * MathHelper.cos((float) theta);\n\t\t\tdouble z = radius * MathHelper.sin((float) theta);\n\t\t\tbuild.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));\n\t\t});\n\t}\n\t@SideOnly(Side.CLIENT)\n\t@Override\n\tpublic void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {\n\t\tParticleBuilder glitter = new ParticleBuilder(10);\n\t\tglitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n\t\tglitter.setCollision(true);\n\t\tglitter.disableMotionCalculation();\n\t\tglitter.disableRandom();\n\t\tParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {\n\t\t\tbuild.setScaleFunction(new InterpScale(0.5f, 0));\n\t\t\tbuild.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));\n\t\t});\n\t}\n\t@Override\n\tpublic @Nullable\n\tSoundEvent getImpactSound() {\n\t\treturn RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;\n\t}\n"]]}
{"hexsha": "71f70801a9b50116a217f6493cec5ea7f30a0487", "ext": "java", "lang": "Java", "content": "@ServiceComponentRenderer\npublic class CryptoAdapterRegistrationRenderer implements Renderer {\n\tprivate final String INLINE_JS =\n        \"function setCryptoKey(key) {\\n\" +\n        \"    var buffer, view;\\n\" +\n        \"    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\\n\" +\n        \"        try {\\n\" +\n        \"            buffer = new ArrayBuffer(key.length);\\n\" +\n        \"            view = new Uint8Array(buffer);\\n\" +\n        \"            view.set(key);\\n\" +\n        \"        } catch (ignored) {}\\n\" +\n        \"    }\\n\" +\n        \"    CryptoAdapter.setKey(buffer);\\n\" +\n        \"}\\n\" +\n        \"debug && $A.log('CryptoAdapter registering');\\n\" +\n        \"var CryptoAdapter = $A.storageService.CryptoAdapter;\\n\" +\n        \"CryptoAdapter.register();\\n\" +\n        \"if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\\n\" +\n        \"    $A.log('CryptoAdapter was not registered');\\n\" +\n        \"    return;\\n\" +\n        \"}\\n\" +\n        \"setCryptoKey(key);\\n\"\n    ;\n\n    private ConfigAdapter configAdapter;\n\n    @Override\n    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {\n\n        Boolean debug = (Boolean) component.getAttributes().getValue(\"debugLoggingEnabled\");\n        String key = configAdapter.getEncryptionKey();\n        \n        renderContext.pushScript();\n        renderContext.getCurrent()\n                .append(\"(function(debug, key){\\n\")\n                .append(INLINE_JS)\n                .append(\"\\n}(\").append(String.valueOf(debug)).append(\",\").append(String.valueOf(key)).append(\"));\");\n        renderContext.popScript();\n    }\n\n    @Inject\n    public void setConfigAdapter(ConfigAdapter configAdapter) {\n        this.configAdapter = configAdapter;\n    }\n}", "class_id": 0, "repo": "madmax983/aura", "file": "aura-components/src/main/java/org/auraframework/components/aura/CryptoAdapterRegistrationRenderer.java", "last_update_at": "2021-08-11T08:25:14+00:00", "question_id": "71f70801a9b50116a217f6493cec5ea7f30a0487", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ServiceComponentRenderer\npublic class CryptoAdapterRegistrationRenderer implements Renderer {\n\tprivate final String INLINE_JS =\n        \"function setCryptoKey(key) {\\n\" +\n        \"    var buffer, view;\\n\" +\n        \"    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\\n\" +\n        \"        try {\\n\" +\n        \"            buffer = new ArrayBuffer(key.length);\\n\" +\n        \"            view = new Uint8Array(buffer);\\n\" +\n        \"            view.set(key);\\n\" +\n        \"        } catch (ignored) {}\\n\" +\n        \"    }\\n\" +\n        \"    CryptoAdapter.setKey(buffer);\\n\" +\n        \"}\\n\" +\n        \"debug && $A.log('CryptoAdapter registering');\\n\" +\n        \"var CryptoAdapter = $A.storageService.CryptoAdapter;\\n\" +\n        \"CryptoAdapter.register();\\n\" +\n        \"if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\\n\" +\n        \"    $A.log('CryptoAdapter was not registered');\\n\" +\n        \"    return;\\n\" +\n        \"}\\n\" +\n        \"setCryptoKey(key);\\n\"\n    ;\n    private ConfigAdapter configAdapter;\n    @Override\n    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {\n        Boolean debug = (Boolean) component.getAttributes().getValue(\"debugLoggingEnabled\");\n        String key = configAdapter.getEncryptionKey();\n        renderContext.pushScript();\n        renderContext.getCurrent()\n                .append(\"(function(debug, key){\\n\")\n                .append(INLINE_JS)\n                .append(\"\\n}(\").append(String.valueOf(debug)).append(\",\").append(String.valueOf(key)).append(\"));\");\n        renderContext.popScript();\n    }\n    @Inject\n    public void setConfigAdapter(ConfigAdapter configAdapter) {\n        this.configAdapter = configAdapter;\n    }\n"]]}
{"hexsha": "99d08e11b8fd9b4837646757477e56f3f5aea269", "ext": "java", "lang": "Java", "content": "public class ForLoopCalculator implements Calculator {\n    public long sumUp(long[] numbers) {\n        long total = 0;\n        for (long i : numbers) {\n            total += i;\n        }\n        return total;\n    }\n}", "class_id": 0, "repo": "gaohanghang/Java-Concurrency-Multithreading-in-Practice", "file": "doc/doc1/ForLoopCalculator.java", "last_update_at": "2021-11-04T13:49:22+00:00", "question_id": "99d08e11b8fd9b4837646757477e56f3f5aea269", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ForLoopCalculator implements Calculator {\n    public long sumUp(long[] numbers) {\n        long total = 0;\n        for (long i : numbers) {\n            total += i;\n        }\n        return total;\n    }\n"]]}
{"hexsha": "3895af397ca10b213eeedd58eb68713c339171f4", "ext": "java", "lang": "Java", "content": "public class BinaryTree {\n\n    private String symbol;\n    private int start;\n    private int end;\n    private BinaryTree leftChild;\n    private BinaryTree rightChild;\n    private boolean isLexical;\n    private BinaryTree parent;\n    \n    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode,\n            BinaryTree rightChildNode, boolean isLexical) {\n        this.symbol = symbol;\n        this.start = start;\n        this.end = end;\n        this.leftChild = leftChildNode;\n        this.rightChild = rightChildNode;\n        this.isLexical = isLexical;\n        this.parent = null;\n        if (leftChild != null) {\n            leftChild.parent = this;\n        }\n        if (rightChild != null) {\n            rightChild.parent = this;\n        }\n    }\n\n//    public Span getSpan() {\n//        return new Span(start, end);\n//    }\n       \n    private static String canonicalizeTreeString(String newTreeStr) {\n        return newTreeStr.trim().replaceAll(\"\\\\s+\\\\)\", \")\").replaceAll(\"\\\\s+\", \" \");\n    }\n    \n    public String getAsOneLineString() {\n        // TODO: speedup.\n        return canonicalizeTreeString(getAsPennTreebankString());\n    }\n    \n    /**\n     * Gets a string representation of this parse that looks like the typical \n     * Penn Treebank style parse.\n     * \n     * Example:\n     *  ((ROOT (S (NP (NN time))\n     *           (VP (VBZ flies)\n     *               (PP (IN like)\n     *                   (NP (DT an)\n     *                       (NN arrow)))))))\n     *                       \n     * @return A string representing this parse.\n     */\n    public String getAsPennTreebankString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        getAsPennTreebankString(1, 1, sb);\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {\n        int numSpaces = indent - numOnLine;\n        for (int i=0; i<numSpaces; i++) {\n            sb.append(\" \");\n        }\n        if (isLexical) {\n            sb.append(getSymbol());\n        } else {\n            sb.append(\"(\");\n            sb.append(getSymbol());\n            \n            // If this is a constant instead, then we have each depth in one column.\n            int numNewChars = 1 + getSymbol().length();\n\n            if (leftChild != null) {\n                //sb.append(\"\\n\");\n                leftChild.getAsPennTreebankString(indent+numNewChars+1, indent + numNewChars, sb);\n            }\n            if (rightChild != null) {\n                sb.append(\"\\n\");\n                rightChild.getAsPennTreebankString(indent+numNewChars+1, 0, sb);\n            }\n            sb.append(\")\");\n        }\n    }\n\n    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Visit this node.\n        function.call(this);\n        // Pre-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.preOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.preOrderTraversal(function);\n        }\n    }\n\n    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // In-order traversal of left child.\n        if (leftChild != null) {\n            leftChild.inOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n        // In-order traversal of right child.\n        if (rightChild != null) {\n            rightChild.inOrderTraversal(function);\n        }\n    }\n    \n    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Post-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.postOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.postOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n    }\n    \n    public int getStart() {\n        return start;\n    }\n    \n    public int getEnd() {\n        return end;\n    }\n\n    public boolean isLeaf() {\n        return leftChild == null && rightChild == null;\n    }\n\n    public boolean isLexical() {\n        return isLexical;\n    }\n    \n    public BinaryTree getLeftChild() {\n        return leftChild;\n    }\n\n    public BinaryTree getRightChild() {\n        return rightChild;\n    }\n    \n    public String getSymbol() {\n        return symbol;\n    }\n\n    public void setSymbol(String symbol) {\n        this.symbol = symbol;\n    }\n    \n    public BinaryTree getParent() {\n        return parent;\n    }\n    \n    /**\n     * Updates all the start end fields, treating the current node as the root.\n     */\n    public void updateStartEnd() {\n        ArrayList<BinaryTree> leaves = getLeaves();\n        for (int i=0; i<leaves.size(); i++) {\n            BinaryTree leaf = leaves.get(i);\n            leaf.start = i;\n            leaf.end = i+1;\n        }\n        postOrderTraversal(new UpdateStartEnd());\n    }\n\n    /**\n     * Gets the leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLeaves() {\n        LeafCollector leafCollector = new LeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n    \n    /**\n     * Gets the lexical leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLexicalLeaves() {\n        LexicalLeafCollector leafCollector = new LexicalLeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n\n    /** Gets the leaf containing the specified token index. */\n    public BinaryTree getLeafAt(int idx) {\n        BinaryTree leaf = null;\n        for (BinaryTree l : this.getLeaves()) {\n            if (l.start <= idx && idx < l.end) {\n                leaf = l;\n            }\n        }\n        return leaf;\n    }\n    \n    /**\n     * Gets the lexical item ids comprising the sentence.\n     */\n    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        int[] sent = new int[leaves.size()];\n        for (int i=0; i<sent.length; i++) {\n            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);\n        }\n        return sent;\n    }\n\n    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> labels = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {\n            labels.add(leaves.get(i).symbol);\n        }\n        return new Sentence(lexAlphabet, labels);\n    }\n\n    public List<String> getWords() {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> words = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {            \n            words.add(leaves.get(i).symbol);\n        }\n        return words;\n    }\n\n    private class LeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        \n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf()) {\n                leaves.add(node);\n            }\n        }\n        \n    }\n    \n    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        \n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf() && node.isLexical()) {\n                leaves.add(node);\n            }\n        }\n        \n    }\n    \n    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {\n\n        @Override\n        public void call(BinaryTree node) {\n            if (!node.isLeaf()) {\n                node.start = node.leftChild.start;\n                if (node.rightChild == null) {\n                    node.end = node.leftChild.end;\n                } else {\n                    node.end = node.rightChild.end;\n                }\n            }\n        }\n        \n    }\n    \n    /** Intern all the strings. */\n    public void intern() {\n        symbol = symbol.intern();\n        if (leftChild != null) {\n            leftChild.intern();\n        }\n        if (rightChild != null) {\n            rightChild.intern();\n        }\n    }\n\n    public NaryTree collapseToNary() {        \n        ArrayList<NaryTree> children = null;\n        if (!isLeaf()) {\n            assert (leftChild != null);\n            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();\n            addToQueue(queue, leftChild);\n            addToQueue(queue, rightChild);\n            children = new ArrayList<NaryTree>(queue);\n        }\n        \n        return new NaryTree(symbol, start, end, children, isLexical);\n    }\n\n    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {\n        if (child == null) {\n            return;\n        }\n        String symbolStr = child.getSymbol();\n        if (GrammarConstants.isBinarized(symbolStr)) {\n            addToQueue(queue, child.leftChild);\n            addToQueue(queue, child.rightChild);\n        } else {\n            queue.add(child.collapseToNary());\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"BinaryTreeNode [symbol=\" + getSymbol() + \"_{\" + start + \", \"\n                + end + \"}, leftChildNode=\" + leftChild\n                + \", rightChildNode=\" + rightChild + \"]\";\n    }\n    \n}", "class_id": 0, "repo": "mgormley/pacaya", "file": "src/main/java/edu/jhu/pacaya/parse/cky/data/BinaryTree.java", "last_update_at": "2021-07-25T23:58:37+00:00", "question_id": "3895af397ca10b213eeedd58eb68713c339171f4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinaryTree {\n    private String symbol;\n    private int start;\n    private int end;\n    private BinaryTree leftChild;\n    private BinaryTree rightChild;\n    private boolean isLexical;\n    private BinaryTree parent;\n    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode,\n            BinaryTree rightChildNode, boolean isLexical) {\n        this.symbol = symbol;\n        this.start = start;\n        this.end = end;\n        this.leftChild = leftChildNode;\n        this.rightChild = rightChildNode;\n        this.isLexical = isLexical;\n        this.parent = null;\n        if (leftChild != null) {\n            leftChild.parent = this;\n        }\n        if (rightChild != null) {\n            rightChild.parent = this;\n        }\n    }\n//    public Span getSpan() {\n//        return new Span(start, end);\n//    }\n    private static String canonicalizeTreeString(String newTreeStr) {\n        return newTreeStr.trim().replaceAll(\"\\\\s+\\\\)\", \")\").replaceAll(\"\\\\s+\", \" \");\n    }\n    public String getAsOneLineString() {\n        // TODO: speedup.\n        return canonicalizeTreeString(getAsPennTreebankString());\n    }\n    /**\n     * Gets a string representation of this parse that looks like the typical \n     * Penn Treebank style parse.\n     * \n     * Example:\n     *  ((ROOT (S (NP (NN time))\n     *           (VP (VBZ flies)\n     *               (PP (IN like)\n     *                   (NP (DT an)\n     *                       (NN arrow)))))))\n     *                       \n     * @return A string representing this parse.\n     */\n    public String getAsPennTreebankString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        getAsPennTreebankString(1, 1, sb);\n        sb.append(\")\");\n        return sb.toString();\n    }\n    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {\n        int numSpaces = indent - numOnLine;\n        for (int i=0; i<numSpaces; i++) {\n            sb.append(\" \");\n        }\n        if (isLexical) {\n            sb.append(getSymbol());\n        } else {\n            sb.append(\"(\");\n            sb.append(getSymbol());\n            // If this is a constant instead, then we have each depth in one column.\n            int numNewChars = 1 + getSymbol().length();\n            if (leftChild != null) {\n                //sb.append(\"\\n\");\n                leftChild.getAsPennTreebankString(indent+numNewChars+1, indent + numNewChars, sb);\n            }\n            if (rightChild != null) {\n                sb.append(\"\\n\");\n                rightChild.getAsPennTreebankString(indent+numNewChars+1, 0, sb);\n            }\n            sb.append(\")\");\n        }\n    }\n    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Visit this node.\n        function.call(this);\n        // Pre-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.preOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.preOrderTraversal(function);\n        }\n    }\n    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // In-order traversal of left child.\n        if (leftChild != null) {\n            leftChild.inOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n        // In-order traversal of right child.\n        if (rightChild != null) {\n            rightChild.inOrderTraversal(function);\n        }\n    }\n    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Post-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.postOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.postOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n    }\n    public int getStart() {\n        return start;\n    }\n    public int getEnd() {\n        return end;\n    }\n    public boolean isLeaf() {\n        return leftChild == null && rightChild == null;\n    }\n    public boolean isLexical() {\n        return isLexical;\n    }\n    public BinaryTree getLeftChild() {\n        return leftChild;\n    }\n    public BinaryTree getRightChild() {\n        return rightChild;\n    }\n    public String getSymbol() {\n        return symbol;\n    }\n    public void setSymbol(String symbol) {\n        this.symbol = symbol;\n    }\n    public BinaryTree getParent() {\n        return parent;\n    }\n    /**\n     * Updates all the start end fields, treating the current node as the root.\n     */\n    public void updateStartEnd() {\n        ArrayList<BinaryTree> leaves = getLeaves();\n        for (int i=0; i<leaves.size(); i++) {\n            BinaryTree leaf = leaves.get(i);\n            leaf.start = i;\n            leaf.end = i+1;\n        }\n        postOrderTraversal(new UpdateStartEnd());\n    }\n    /**\n     * Gets the leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLeaves() {\n        LeafCollector leafCollector = new LeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n    /**\n     * Gets the lexical leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLexicalLeaves() {\n        LexicalLeafCollector leafCollector = new LexicalLeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n    /** Gets the leaf containing the specified token index. */\n    public BinaryTree getLeafAt(int idx) {\n        BinaryTree leaf = null;\n        for (BinaryTree l : this.getLeaves()) {\n            if (l.start <= idx && idx < l.end) {\n                leaf = l;\n            }\n        }\n        return leaf;\n    }\n    /**\n     * Gets the lexical item ids comprising the sentence.\n     */\n    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        int[] sent = new int[leaves.size()];\n        for (int i=0; i<sent.length; i++) {\n            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);\n        }\n        return sent;\n    }\n    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> labels = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {\n            labels.add(leaves.get(i).symbol);\n        }\n        return new Sentence(lexAlphabet, labels);\n    }\n    public List<String> getWords() {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> words = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {            \n            words.add(leaves.get(i).symbol);\n        }\n        return words;\n    }\n    private class LeafCollector implements FnO1ToVoid<BinaryTree> {\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf()) {\n                leaves.add(node);\n            }\n        }\n    }\n    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf() && node.isLexical()) {\n                leaves.add(node);\n            }\n        }\n    }\n    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {\n        @Override\n        public void call(BinaryTree node) {\n            if (!node.isLeaf()) {\n                node.start = node.leftChild.start;\n                if (node.rightChild == null) {\n                    node.end = node.leftChild.end;\n                } else {\n                    node.end = node.rightChild.end;\n                }\n            }\n        }\n    }\n    /** Intern all the strings. */\n    public void intern() {\n        symbol = symbol.intern();\n        if (leftChild != null) {\n            leftChild.intern();\n        }\n        if (rightChild != null) {\n            rightChild.intern();\n        }\n    }\n    public NaryTree collapseToNary() {        \n        ArrayList<NaryTree> children = null;\n        if (!isLeaf()) {\n            assert (leftChild != null);\n            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();\n            addToQueue(queue, leftChild);\n            addToQueue(queue, rightChild);\n            children = new ArrayList<NaryTree>(queue);\n        }\n        return new NaryTree(symbol, start, end, children, isLexical);\n    }\n    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {\n        if (child == null) {\n            return;\n        }\n        String symbolStr = child.getSymbol();\n        if (GrammarConstants.isBinarized(symbolStr)) {\n            addToQueue(queue, child.leftChild);\n            addToQueue(queue, child.rightChild);\n        } else {\n            queue.add(child.collapseToNary());\n        }\n    }\n    @Override\n    public String toString() {\n        return \"BinaryTreeNode [symbol=\" + getSymbol() + \"_{\" + start + \", \"\n                + end + \"}, leftChildNode=\" + leftChild\n                + \", rightChildNode=\" + rightChild + \"]\";\n    }\n"]]}
{"hexsha": "6010ce895b3af2938615bae54d10caa4a458667d", "ext": "java", "lang": "Java", "content": "public class SegmentHandler {\n\n\tpublic LinkedList<vec> segments;\n\tpublic LinkedList<EnumFacing> segmentbottomsides;\n\tpublic LinkedList<EnumFacing> segmenttopsides;\n\tpublic World world;\n\tpublic grappleArrow arrow;\n\t\n\tvec prevhookpos = null;\n\tvec prevplayerpos = null;;\n\t\n\tfinal double bendoffset = 0.05;\n\tfinal double intoblock = 0.05;\n\t\n\tpublic SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {\n\t\tsegments = new LinkedList<vec>();\n\t\tsegments.add(hookpos);\n\t\tsegments.add(playerpos);\n\t\tsegmentbottomsides = new LinkedList<EnumFacing>();\n\t\tsegmentbottomsides.add(null);\n\t\tsegmentbottomsides.add(null);\n\t\tsegmenttopsides = new LinkedList<EnumFacing>();\n\t\tsegmenttopsides.add(null);\n\t\tsegmenttopsides.add(null);\n\t\tthis.world = w;\n\t\tthis.arrow = arrow;\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n\t\t\n//\t\tSystem.out.println(\"segments:\");\n//\t\thookpos.print();\n//\t\tplayerpos.print();\n\t}\n\t\n\tpublic void forceSetPos(vec hookpos, vec playerpos) {\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n    \tthis.segments.set(0, new vec(hookpos));\n    \tthis.segments.set(this.segments.size() - 1, new vec(playerpos));\n\t}\n\t\n\tdouble ropelen;\n\t\n\tpublic void updatepos(vec hookpos, vec playerpos, double ropelen) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t}\n\t\n\tpublic void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {\n\t\tif (prevhookpos == null) {\n\t        prevhookpos = hookpos;\n\t        prevplayerpos = playerpos;\n\t\t}\n\t\t\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t\t\n\t\t\n\t\tvec closest = segments.get(segments.size()-2);\n\t\t\n\t\twhile (true) {\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint index = segments.size()-2;\n\t\t\tclosest = segments.get(index);\n\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\tvec ropevec = playerpos.sub(closest);\n\t\t\t\n\t\t\tvec beforepoint = segments.get(index-1);\n\t\t\t\n\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\tvec planenormal = beforepoint.sub(closest).cross(edgevec);\n//\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\n//\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\n\t\t\tif (ropevec.dot(planenormal) > 0) {\n\t\t\t\tthis.removesegment(index);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec farthest = segments.get(1);\n\t\t\n\t\tif (movinghook) {\n\t\t\twhile (true) {\n\t\t\t\tif (segments.size() == 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint index = 1;\n\t\t\t\tfarthest = segments.get(index);\n\t\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\t\tvec ropevec = farthest.sub(hookpos);\n\t\t\t\t\n\t\t\t\tvec beforepoint = segments.get(index+1);\n\t\t\t\t\n\t\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\t\tvec planenormal = beforepoint.sub(farthest).cross(edgevec);\n//\t\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\t\n\t\t\t\tif (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {\n//\t\t\t\t\tSystem.out.println(\"removed farthest\");\n\t\t\t\t\tthis.removesegment(index);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tif (this.getDistToFarthest() > ropelen) {\n\t\t\t\t\tthis.removesegment(1);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (movinghook) {\n\t\t\tfarthest = segments.get(1);\n\t\t\tvec prevfarthest = farthest;\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tprevfarthest = prevplayerpos;\n\t\t\t}\n\t\t\tupdatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);\n\t\t}\n\t\t\n\t\tvec prevclosest = closest;\n\t\tif (segments.size() == 2) {\n\t\t\tprevclosest = prevhookpos;\n\t\t}\n\t\tupdatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);\n\t\t\n\t\t\n        prevhookpos = hookpos;\n        prevplayerpos = playerpos;\n\t}\n\t\n\tpublic void removesegment(int index) {\n/*\t\tSystem.out.println(\"removed segment\");*/\n\t\t\n\t\tsegments.remove(index);\n\t\tsegmentbottomsides.remove(index);\n\t\tsegmenttopsides.remove(index);\n\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {\n        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);\n        \n        // if rope hit block\n        if (bottomraytraceresult != null)\n        {\n        \tif (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {\n//        \t\tSystem.out.println(\"Warning: prev collision\");\n        \t\treturn;\n        \t}\n        \t\n//        \tSystem.out.println(bottomraytraceresult.typeOfHit);\n            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);\n/*            this.arrow.debugpos = bottomhitvec;\n            this.arrow.debugpos2 = bottom;\n            this.arrow.debugpos3 = top;*/\n            EnumFacing bottomside = bottomraytraceresult.sideHit;\n            vec bottomnormal = this.getnormal(bottomside);\n            \n            // calculate where bottomhitvec was along the rope in the previous tick\n//            double ropelen = top.sub(bottom).length();\n            double prevropelen = prevtop.sub(prevbottom).length();\n            \n//            double bottomtohit = bottom.sub(bottomhitvec).length();\n//            double prevbottomtohit = bottomtohit * ropelen / prevropelen;\n            \n//            vec prevbottomhit = prevtop.sub(prevbottom).changelen(prevbottomtohit).add(prevbottom);\n            \n            // use prevbottomhit to calculate the velocity of that part of the rope when it hit the block\n //           vec motionalonghit = bottomhitvec.sub(prevbottomhit);\n            \n            // calculate the motion parallel to the block side\n//            vec motionparallel = motionalonghit.removealong(bottomnormal);\n            \n            // the rope must have hit the corner on the plane across the edge of the block\n            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom\n            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));\n            \n//            vec cornerbound2 = null;\n//            double cornerlinedist = Double.POSITIVE_INFINITY;\n            \n            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option1;\n            \tcornerlinedist = cornerbound1.sub(bound_option1).length();\n            }*/\n            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option2;\n            \tcornerlinedist = cornerbound1.sub(bound_option2).length();\n            }*/\n            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option3).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option3;\n            \tcornerlinedist = cornerbound1.sub(bound_option3).length();\n            }*/\n            \n//            if (cornerbound2 != null) {\n            for (vec cornerbound2 : new vec[] {bound_option1, bound_option2, bound_option3}) {\n            \tif (cornerbound2 == null) {\n            \t\tcontinue;\n            \t}\n            \t\n            \t// the corner must be in the line (cornerbound2, cornerbound1)\n                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);\n                if (cornerraytraceresult != null) {\n                \tvec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);\n                \tEnumFacing cornerside = cornerraytraceresult.sideHit;\n                \t\n                \tif (cornerside == bottomside || \n                \t\t\tcornerside.getOpposite() == bottomside) {\n                \t\t// this should not happen\n//                \t\tSystem.out.println(\"Warning: corner is same or opposite of bottomside\");\n                \t\tcontinue;\n                \t} else {\n                \t\t// add a bend around the corner\n                \t\tvec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));\n                \t\tvec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));\n                \t\tvec topropevec = bend.sub(top);\n                \t\tvec bottomropevec = bend.sub(bottom);\n                \t\t\n                \t\t// ignore bends that are too close to another bend\n                \t\tif (topropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: top bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\tif (bottomropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: bottom bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\t\n                \t\tthis.actuallyaddsegment(index, bend, bottomside, cornerside);\n                \t\t\n                \t\t// if not enough rope length left, undo\n                \t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n//                \t\t\tSystem.out.println(\"Warning: not enough length left, removing\");\n                \t\t\tthis.removesegment(index);\n                \t\t\tcontinue;\n                \t\t}\n                \t\t\n                \t\t// now to recurse on top section of rope\n                \t\tdouble newropelen = topropevec.length() + bottomropevec.length();\n                \t\t\n                \t\tdouble prevtoptobend = topropevec.length() * prevropelen / newropelen;\n                \t\tvec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));\n                \t\t\n                \t\tif (numberrecursions < 10) {\n                    \t\tupdatesegment(top, prevtop, bend, prevbend, index, numberrecursions+1);\n                \t\t} else {\n                \t\t\tSystem.out.println(\"Warning: number recursions exceeded\");\n                \t\t}\n                \t\tbreak;\n                \t}\n//                } else {\n//                \tSystem.out.println(\"Warning: no corner collision\");\n                }\n//            } else {\n//            \tSystem.out.println(\"Warning: cornerbound2 is null\");\n            }\n            \n            \n            \n/*            RayTraceResult topraytraceresult = this.world.rayTraceBlocks(top.toVec3d(), bottom.toVec3d());\n            vec tophitvec = new vec(topraytraceresult.hitVec.x, topraytraceresult.hitVec.y, topraytraceresult.hitVec.z);\n            EnumFacing topside = topraytraceresult.sideHit;\n            \n            if (bottomhitvec.sub(top).length() > 0.01 && tophitvec.sub(bottom).length() > 0.01) {\n            \tif (bottomside == topside) {\n            \t\tSystem.out.println(\"Warning: bottomside == topside\");\n            \t} else if ((bottomside == EnumFacing.DOWN && topside == EnumFacing.UP) || \n\t            \t\t(bottomside == EnumFacing.UP && topside == EnumFacing.DOWN) || \n\t            \t\t(bottomside == EnumFacing.EAST && topside == EnumFacing.WEST) || \n\t            \t\t(bottomside == EnumFacing.WEST && topside == EnumFacing.EAST) || \n\t            \t\t(bottomside == EnumFacing.NORTH && topside == EnumFacing.SOUTH) || \n\t            \t\t(bottomside == EnumFacing.SOUTH && topside == EnumFacing.NORTH)) {\n\t            \tSystem.out.println(\"two sides\");\n\t            \t// binary search to find 3rd side\n\t            \tvec newprevtop = prevtop;\n\t            \tvec newprevbottom = prevbottom;\n            \t\tvec center = bottomhitvec.add(tophitvec).mult(0.5);\n\t            \tfor (int i = 0; i < 20; i++) {\n\t            \t\tvec prevcenter = newprevtop.add(newprevbottom).mult(0.5);\n\t            \t\tRayTraceResult thirdsidetrace = this.world.rayTraceBlocks(prevcenter.toVec3d(), center.toVec3d());\n\t            \t\tif (thirdsidetrace == null) {\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t\tEnumFacing thirdside = thirdsidetrace.sideHit;\n\t            \t\tif (thirdside == bottomside) {\n\t            \t\t\tnewprevbottom = prevcenter;\n\t            \t\t} else if (thirdside == topside) {\n\t            \t\t\tnewprevtop = prevcenter;\n\t            \t\t} else {\n\t            \t\t\tvec collisionpoint = new vec(thirdsidetrace.hitVec.x, thirdsidetrace.hitVec.y, thirdsidetrace.hitVec.z);\n\t            \t\t\tthis.addsegment(bottomhitvec, collisionpoint, bottomside, thirdside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tthis.addsegment(collisionpoint, tophitvec, thirdside, topside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t}\n\t            } else {\n                    this.addsegment(bottomhitvec, tophitvec, bottomside, topside, index, top, prevtop, bottom, prevbottom);\n\t            }\n            }*/\n        }\n\t}\n\t\n\tpublic vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {\n\t\t// calculate the intersection of a line and a plane\n\t\t// formula: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n\t\t\n\t\tvec linevec = linepoint2.sub(linepoint1);\n\t\t\n\t\tif (linevec.dot(planenormal) == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tdouble d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);\n\t\treturn linepoint1.add(linevec.mult(d));\n\t}\n\t\n\tpublic vec getnormal(EnumFacing facing) {\n\t\tVec3i facingvec = facing.getDirectionVec();\n\t\treturn new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());\n\t}\n\t\n\tpublic boolean hookpastbend(double ropelen) {\n\t\treturn (this.getDistToFarthest() > ropelen);\n\t}\n\t\n\tpublic BlockPos getbendblock(int index) {\n\t\tvec bendpos = this.segments.get(index);\n\t\tbendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));\n\t\tbendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));\n\t\treturn new BlockPos(bendpos.x, bendpos.y, bendpos.z);\n\t}\n\t\n/*\tpublic void addsegment(vec bottomhit, vec tophit, EnumFacing bottomside, EnumFacing topside, int index, vec top, vec prevtop, vec bottom, vec prevbottom) {\n\t\tSystem.out.println(\"Computing bend point\");\n\t\t\n\t\tvec bottomnormal = getnormal(bottomside);\n\t\tvec topnormal = getnormal(topside);\n\t\tvec edgevec = bottomnormal.cross(topnormal);\n\t\t\n\t\tedgevec.print();\n\t\t\n\t\tdouble d = (tophit.sub(bottomhit)).dot(topnormal) / topnormal.dot(topnormal);\n\t\tvec edgepoint = topnormal.mult(d).add(bottomhit);\n\t\t\n\t\tedgepoint.print();\n\t\t\n\t\tvec movement = bottom.sub(prevbottom);\n\t\tif (movement.length() == 0) {\n\t\t\tmovement = top.sub(prevtop);\n\t\t}\n\t\tvec planenormal = movement.cross(top.sub(bottom));\n\t\t\n\t\tmovement.print();\n\t\tplanenormal.print();\n\t\t\n\t\tif (edgevec.dot(planenormal) == 0) {\n\t\t\tSystem.out.println(\"warning: can't compute bend point\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdouble d2 = (top.sub(edgepoint)).dot(planenormal) / edgevec.dot(planenormal);\n\t\t\n\t\tvec intersectionpoint = edgevec.mult(d2).add(edgepoint);\n\t\t\n\t\tintersectionpoint.print();\n\t\t\n\t\tvec offset = bottomnormal.add(topnormal).mult(0.1);\n\t\tvec bendpoint = intersectionpoint.add(offset);\n\t\t\n\t\tthis.actuallyaddsegment(index, bendpoint, bottomside, topside);\n\n\t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n\t\t\tSystem.out.println(\"not enough length left, removing\");\n\t\t\tthis.removesegment(index);\n\t\t\treturn;\n\t\t}\n\t}*/\n\t\n\tpublic void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {\n        segments.add(index, bendpoint);\n        segmentbottomsides.add(index, bottomside);\n        segmenttopsides.add(index, topside);\n\n        /*System.out.println(\"added segment\");\n\t\tthis.print();*/\n\t\t\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void print() {\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tSystem.out.print(i);\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmenttopsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmentbottomsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tsegments.get(i).print();\n\t\t}\n\t}\n\t\n\tpublic vec getclosest(vec hookpos) {\n\t\tsegments.set(0, hookpos);\n\t\t\n\t\treturn segments.get(segments.size() - 2);\n\t}\n\t\n\tpublic double getDistToAnchor() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 2; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic vec getfarthest() {\n\t\treturn segments.get(1);\n\t}\n\t\n\tpublic double getDistToFarthest() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic double getDist(vec hookpos, vec playerpos) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {\n\t\tthis.updatepos(hookpos, playerpos, this.ropelen);\n\t\tvec minvec = new vec(hookpos);\n\t\tvec maxvec = new vec(hookpos);\n\t\tfor (int i = 1; i < segments.size(); i++) {\n\t\t\tvec segpos = segments.get(i);\n\t\t\tif (segpos.x < minvec.x) {\n\t\t\t\tminvec.x = segpos.x;\n\t\t\t} else if (segpos.x > maxvec.x) {\n\t\t\t\tmaxvec.x = segpos.x;\n\t\t\t}\n\t\t\tif (segpos.y < minvec.y) {\n\t\t\t\tminvec.y = segpos.y;\n\t\t\t} else if (segpos.y > maxvec.y) {\n\t\t\t\tmaxvec.y = segpos.y;\n\t\t\t}\n\t\t\tif (segpos.z < minvec.z) {\n\t\t\t\tminvec.z = segpos.z;\n\t\t\t} else if (segpos.z > maxvec.z) {\n\t\t\t\tmaxvec.z = segpos.z;\n\t\t\t}\n\t\t}\n\t\tAxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);\n//\t\tSystem.out.print(bb.minX);\n//\t\tSystem.out.print(\" \");\n//\t\tSystem.out.println(bb.maxX);\n\t\treturn bb;\n\t}\n}", "class_id": 0, "repo": "Nyfaria/grapplemod", "file": "main/java/com/yyon/grapplinghook/controllers/SegmentHandler.java", "last_update_at": "2021-10-31T06:34:38+00:00", "question_id": "6010ce895b3af2938615bae54d10caa4a458667d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SegmentHandler {\n\tpublic LinkedList<vec> segments;\n\tpublic LinkedList<EnumFacing> segmentbottomsides;\n\tpublic LinkedList<EnumFacing> segmenttopsides;\n\tpublic World world;\n\tpublic grappleArrow arrow;\n\t\n\tvec prevhookpos = null;\n\tvec prevplayerpos = null;;\n\t\n\tfinal double bendoffset = 0.05;\n\tfinal double intoblock = 0.05;\n\t\n\tpublic SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {\n\t\tsegments = new LinkedList<vec>();\n\t\tsegments.add(hookpos);\n\t\tsegments.add(playerpos);\n\t\tsegmentbottomsides = new LinkedList<EnumFacing>();\n\t\tsegmentbottomsides.add(null);\n\t\tsegmentbottomsides.add(null);\n\t\tsegmenttopsides = new LinkedList<EnumFacing>();\n\t\tsegmenttopsides.add(null);\n\t\tsegmenttopsides.add(null);\n\t\tthis.world = w;\n\t\tthis.arrow = arrow;\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n\t\t\n//\t\tSystem.out.println(\"segments:\");\n//\t\thookpos.print();\n//\t\tplayerpos.print();\n\t}\n\t\n\tpublic void forceSetPos(vec hookpos, vec playerpos) {\n\t\tthis.prevhookpos = new vec(hookpos);\n\t\tthis.prevplayerpos = new vec(playerpos);\n    \tthis.segments.set(0, new vec(hookpos));\n    \tthis.segments.set(this.segments.size() - 1, new vec(playerpos));\n\t}\n\t\n\tdouble ropelen;\n\t\n\tpublic void updatepos(vec hookpos, vec playerpos, double ropelen) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t}\n\t\n\tpublic void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {\n\t\tif (prevhookpos == null) {\n\t        prevhookpos = hookpos;\n\t        prevplayerpos = playerpos;\n\t\t}\n\t\t\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tthis.ropelen = ropelen;\n\t\t\n\t\t\n\t\tvec closest = segments.get(segments.size()-2);\n\t\t\n\t\twhile (true) {\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint index = segments.size()-2;\n\t\t\tclosest = segments.get(index);\n\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\tvec ropevec = playerpos.sub(closest);\n\t\t\t\n\t\t\tvec beforepoint = segments.get(index-1);\n\t\t\t\n\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\tvec planenormal = beforepoint.sub(closest).cross(edgevec);\n//\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\n//\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\n\t\t\tif (ropevec.dot(planenormal) > 0) {\n\t\t\t\tthis.removesegment(index);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec farthest = segments.get(1);\n\t\t\n\t\tif (movinghook) {\n\t\t\twhile (true) {\n\t\t\t\tif (segments.size() == 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint index = 1;\n\t\t\t\tfarthest = segments.get(index);\n\t\t\t\tEnumFacing bottomside = segmentbottomsides.get(index);\n\t\t\t\tEnumFacing topside = segmenttopsides.get(index);\n\t\t\t\tvec ropevec = farthest.sub(hookpos);\n\t\t\t\t\n\t\t\t\tvec beforepoint = segments.get(index+1);\n\t\t\t\t\n\t\t\t\tvec edgevec = getnormal(bottomside).cross(getnormal(topside));\n\t\t\t\tvec planenormal = beforepoint.sub(farthest).cross(edgevec);\n//\t\t\t\tplanenormal = getnormal(bottomside).add(getnormal(topside)).proj(planenormal);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(ropevec.dot(planenormal));\n\t\t\t\t\n\t\t\t\tif (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {\n//\t\t\t\t\tSystem.out.println(\"removed farthest\");\n\t\t\t\t\tthis.removesegment(index);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tif (this.getDistToFarthest() > ropelen) {\n\t\t\t\t\tthis.removesegment(1);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (movinghook) {\n\t\t\tfarthest = segments.get(1);\n\t\t\tvec prevfarthest = farthest;\n\t\t\tif (segments.size() == 2) {\n\t\t\t\tprevfarthest = prevplayerpos;\n\t\t\t}\n\t\t\tupdatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);\n\t\t}\n\t\t\n\t\tvec prevclosest = closest;\n\t\tif (segments.size() == 2) {\n\t\t\tprevclosest = prevhookpos;\n\t\t}\n\t\tupdatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);\n\t\t\n\t\t\n        prevhookpos = hookpos;\n        prevplayerpos = playerpos;\n\t}\n\t\n\tpublic void removesegment(int index) {\n/*\t\tSystem.out.println(\"removed segment\");*/\n\t\t\n\t\tsegments.remove(index);\n\t\tsegmentbottomsides.remove(index);\n\t\tsegmenttopsides.remove(index);\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {\n        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);\n        // if rope hit block\n        if (bottomraytraceresult != null)\n        {\n        \tif (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {\n//        \t\tSystem.out.println(\"Warning: prev collision\");\n        \t\treturn;\n        \t}\n        \t\n//        \tSystem.out.println(bottomraytraceresult.typeOfHit);\n            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);\n/*            this.arrow.debugpos = bottomhitvec;\n            this.arrow.debugpos2 = bottom;\n            this.arrow.debugpos3 = top;*/\n            EnumFacing bottomside = bottomraytraceresult.sideHit;\n            vec bottomnormal = this.getnormal(bottomside);\n            // calculate where bottomhitvec was along the rope in the previous tick\n//            double ropelen = top.sub(bottom).length();\n            double prevropelen = prevtop.sub(prevbottom).length();\n//            double bottomtohit = bottom.sub(bottomhitvec).length();\n//            double prevbottomtohit = bottomtohit * ropelen / prevropelen;\n//            vec prevbottomhit = prevtop.sub(prevbottom).changelen(prevbottomtohit).add(prevbottom);\n            // use prevbottomhit to calculate the velocity of that part of the rope when it hit the block\n //           vec motionalonghit = bottomhitvec.sub(prevbottomhit);\n            // calculate the motion parallel to the block side\n//            vec motionparallel = motionalonghit.removealong(bottomnormal);\n            // the rope must have hit the corner on the plane across the edge of the block\n            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom\n            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));\n//            vec cornerbound2 = null;\n//            double cornerlinedist = Double.POSITIVE_INFINITY;\n            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option1;\n            \tcornerlinedist = cornerbound1.sub(bound_option1).length();\n            }*/\n            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option2;\n            \tcornerlinedist = cornerbound1.sub(bound_option2).length();\n            }*/\n            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);\n/*            if (cornerbound1.sub(bound_option3).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option3;\n            \tcornerlinedist = cornerbound1.sub(bound_option3).length();\n            }*/\n//            if (cornerbound2 != null) {\n            for (vec cornerbound2 : new vec[] {bound_option1, bound_option2, bound_option3}) {\n            \tif (cornerbound2 == null) {\n            \t\tcontinue;\n            \t}\n            \t\n            \t// the corner must be in the line (cornerbound2, cornerbound1)\n                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);\n                if (cornerraytraceresult != null) {\n                \tvec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);\n                \tEnumFacing cornerside = cornerraytraceresult.sideHit;\n                \t\n                \tif (cornerside == bottomside || \n                \t\t\tcornerside.getOpposite() == bottomside) {\n                \t\t// this should not happen\n//                \t\tSystem.out.println(\"Warning: corner is same or opposite of bottomside\");\n                \t\tcontinue;\n                \t} else {\n                \t\t// add a bend around the corner\n                \t\tvec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));\n                \t\tvec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));\n                \t\tvec topropevec = bend.sub(top);\n                \t\tvec bottomropevec = bend.sub(bottom);\n                \t\t\n                \t\t// ignore bends that are too close to another bend\n                \t\tif (topropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: top bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\tif (bottomropevec.length() < 0.05) {\n                \t\t\tif (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {\n//                    \t\t\tSystem.out.println(\"Warning: bottom bend is too close\");\n                    \t\t\tcontinue;\n                \t\t\t}\n                \t\t}\n                \t\t\n                \t\tthis.actuallyaddsegment(index, bend, bottomside, cornerside);\n                \t\t\n                \t\t// if not enough rope length left, undo\n                \t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n//                \t\t\tSystem.out.println(\"Warning: not enough length left, removing\");\n                \t\t\tthis.removesegment(index);\n                \t\t\tcontinue;\n                \t\t}\n                \t\t\n                \t\t// now to recurse on top section of rope\n                \t\tdouble newropelen = topropevec.length() + bottomropevec.length();\n                \t\t\n                \t\tdouble prevtoptobend = topropevec.length() * prevropelen / newropelen;\n                \t\tvec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));\n                \t\t\n                \t\tif (numberrecursions < 10) {\n                    \t\tupdatesegment(top, prevtop, bend, prevbend, index, numberrecursions+1);\n                \t\t} else {\n                \t\t\tSystem.out.println(\"Warning: number recursions exceeded\");\n                \t\t}\n                \t\tbreak;\n                \t}\n//                } else {\n//                \tSystem.out.println(\"Warning: no corner collision\");\n                }\n//            } else {\n//            \tSystem.out.println(\"Warning: cornerbound2 is null\");\n            }\n/*            RayTraceResult topraytraceresult = this.world.rayTraceBlocks(top.toVec3d(), bottom.toVec3d());\n            vec tophitvec = new vec(topraytraceresult.hitVec.x, topraytraceresult.hitVec.y, topraytraceresult.hitVec.z);\n            EnumFacing topside = topraytraceresult.sideHit;\n            if (bottomhitvec.sub(top).length() > 0.01 && tophitvec.sub(bottom).length() > 0.01) {\n            \tif (bottomside == topside) {\n            \t\tSystem.out.println(\"Warning: bottomside == topside\");\n            \t} else if ((bottomside == EnumFacing.DOWN && topside == EnumFacing.UP) || \n\t            \t\t(bottomside == EnumFacing.UP && topside == EnumFacing.DOWN) || \n\t            \t\t(bottomside == EnumFacing.EAST && topside == EnumFacing.WEST) || \n\t            \t\t(bottomside == EnumFacing.WEST && topside == EnumFacing.EAST) || \n\t            \t\t(bottomside == EnumFacing.NORTH && topside == EnumFacing.SOUTH) || \n\t            \t\t(bottomside == EnumFacing.SOUTH && topside == EnumFacing.NORTH)) {\n\t            \tSystem.out.println(\"two sides\");\n\t            \t// binary search to find 3rd side\n\t            \tvec newprevtop = prevtop;\n\t            \tvec newprevbottom = prevbottom;\n            \t\tvec center = bottomhitvec.add(tophitvec).mult(0.5);\n\t            \tfor (int i = 0; i < 20; i++) {\n\t            \t\tvec prevcenter = newprevtop.add(newprevbottom).mult(0.5);\n\t            \t\tRayTraceResult thirdsidetrace = this.world.rayTraceBlocks(prevcenter.toVec3d(), center.toVec3d());\n\t            \t\tif (thirdsidetrace == null) {\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t\tEnumFacing thirdside = thirdsidetrace.sideHit;\n\t            \t\tif (thirdside == bottomside) {\n\t            \t\t\tnewprevbottom = prevcenter;\n\t            \t\t} else if (thirdside == topside) {\n\t            \t\t\tnewprevtop = prevcenter;\n\t            \t\t} else {\n\t            \t\t\tvec collisionpoint = new vec(thirdsidetrace.hitVec.x, thirdsidetrace.hitVec.y, thirdsidetrace.hitVec.z);\n\t            \t\t\tthis.addsegment(bottomhitvec, collisionpoint, bottomside, thirdside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tthis.addsegment(collisionpoint, tophitvec, thirdside, topside, index, top, prevtop, bottom, prevbottom);\n\t            \t\t\tbreak;\n\t            \t\t}\n\t            \t}\n\t            } else {\n                    this.addsegment(bottomhitvec, tophitvec, bottomside, topside, index, top, prevtop, bottom, prevbottom);\n\t            }\n            }*/\n        }\n\t}\n\t\n\tpublic vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {\n\t\t// calculate the intersection of a line and a plane\n\t\t// formula: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n\t\t\n\t\tvec linevec = linepoint2.sub(linepoint1);\n\t\t\n\t\tif (linevec.dot(planenormal) == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tdouble d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);\n\t\treturn linepoint1.add(linevec.mult(d));\n\t}\n\t\n\tpublic vec getnormal(EnumFacing facing) {\n\t\tVec3i facingvec = facing.getDirectionVec();\n\t\treturn new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());\n\t}\n\t\n\tpublic boolean hookpastbend(double ropelen) {\n\t\treturn (this.getDistToFarthest() > ropelen);\n\t}\n\t\n\tpublic BlockPos getbendblock(int index) {\n\t\tvec bendpos = this.segments.get(index);\n\t\tbendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));\n\t\tbendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));\n\t\treturn new BlockPos(bendpos.x, bendpos.y, bendpos.z);\n\t}\n\t\n/*\tpublic void addsegment(vec bottomhit, vec tophit, EnumFacing bottomside, EnumFacing topside, int index, vec top, vec prevtop, vec bottom, vec prevbottom) {\n\t\tSystem.out.println(\"Computing bend point\");\n\t\t\n\t\tvec bottomnormal = getnormal(bottomside);\n\t\tvec topnormal = getnormal(topside);\n\t\tvec edgevec = bottomnormal.cross(topnormal);\n\t\t\n\t\tedgevec.print();\n\t\t\n\t\tdouble d = (tophit.sub(bottomhit)).dot(topnormal) / topnormal.dot(topnormal);\n\t\tvec edgepoint = topnormal.mult(d).add(bottomhit);\n\t\t\n\t\tedgepoint.print();\n\t\t\n\t\tvec movement = bottom.sub(prevbottom);\n\t\tif (movement.length() == 0) {\n\t\t\tmovement = top.sub(prevtop);\n\t\t}\n\t\tvec planenormal = movement.cross(top.sub(bottom));\n\t\t\n\t\tmovement.print();\n\t\tplanenormal.print();\n\t\t\n\t\tif (edgevec.dot(planenormal) == 0) {\n\t\t\tSystem.out.println(\"warning: can't compute bend point\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdouble d2 = (top.sub(edgepoint)).dot(planenormal) / edgevec.dot(planenormal);\n\t\t\n\t\tvec intersectionpoint = edgevec.mult(d2).add(edgepoint);\n\t\t\n\t\tintersectionpoint.print();\n\t\t\n\t\tvec offset = bottomnormal.add(topnormal).mult(0.1);\n\t\tvec bendpoint = intersectionpoint.add(offset);\n\t\t\n\t\tthis.actuallyaddsegment(index, bendpoint, bottomside, topside);\n\t\tif(this.getDistToAnchor() + .2 > this.ropelen) {\n\t\t\tSystem.out.println(\"not enough length left, removing\");\n\t\t\tthis.removesegment(index);\n\t\t\treturn;\n\t\t}\n\t}*/\n\t\n\tpublic void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {\n        segments.add(index, bendpoint);\n        segmentbottomsides.add(index, bottomside);\n        segmenttopsides.add(index, topside);\n        /*System.out.println(\"added segment\");\n\t\tthis.print();*/\n\t\t\n\t\tif (!this.world.isRemote) {\n\t\t\tSegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);\n\t\t\tvec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n\t\t\tgrapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n\t\t}\n\t}\n\t\n\tpublic void print() {\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tSystem.out.print(i);\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmenttopsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tSystem.out.print(segmentbottomsides.get(i).toString());\n\t\t\tSystem.out.print(\" \");\n\t\t\tsegments.get(i).print();\n\t\t}\n\t}\n\t\n\tpublic vec getclosest(vec hookpos) {\n\t\tsegments.set(0, hookpos);\n\t\t\n\t\treturn segments.get(segments.size() - 2);\n\t}\n\t\n\tpublic double getDistToAnchor() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 2; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic vec getfarthest() {\n\t\treturn segments.get(1);\n\t}\n\t\n\tpublic double getDistToFarthest() {\n\t\tdouble dist = 0;\n\t\tfor (int i = 1; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic double getDist(vec hookpos, vec playerpos) {\n\t\tsegments.set(0, hookpos);\n\t\tsegments.set(segments.size() - 1, playerpos);\n\t\tdouble dist = 0;\n\t\tfor (int i = 0; i < segments.size() - 1; i++) {\n\t\t\tdist += segments.get(i).sub(segments.get(i+1)).length();\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\t\n\tpublic AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {\n\t\tthis.updatepos(hookpos, playerpos, this.ropelen);\n\t\tvec minvec = new vec(hookpos);\n\t\tvec maxvec = new vec(hookpos);\n\t\tfor (int i = 1; i < segments.size(); i++) {\n\t\t\tvec segpos = segments.get(i);\n\t\t\tif (segpos.x < minvec.x) {\n\t\t\t\tminvec.x = segpos.x;\n\t\t\t} else if (segpos.x > maxvec.x) {\n\t\t\t\tmaxvec.x = segpos.x;\n\t\t\t}\n\t\t\tif (segpos.y < minvec.y) {\n\t\t\t\tminvec.y = segpos.y;\n\t\t\t} else if (segpos.y > maxvec.y) {\n\t\t\t\tmaxvec.y = segpos.y;\n\t\t\t}\n\t\t\tif (segpos.z < minvec.z) {\n\t\t\t\tminvec.z = segpos.z;\n\t\t\t} else if (segpos.z > maxvec.z) {\n\t\t\t\tmaxvec.z = segpos.z;\n\t\t\t}\n\t\t}\n\t\tAxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);\n//\t\tSystem.out.print(bb.minX);\n//\t\tSystem.out.print(\" \");\n//\t\tSystem.out.println(bb.maxX);\n\t\treturn bb;\n\t}\n"]]}
{"hexsha": "771fae9bb70c50c42d7f3b36993cef4a89b3c044", "ext": "java", "lang": "Java", "content": "public class Reassociate {\n\tprivate static Log log = LogFactory.getLog(Reassociate.class);\n\t\n\tprivate List<String> errorList = new ArrayList<String>();\n\tprivate List<String> msgList = new ArrayList<String>();\n\tprivate Map<String,String> locMap = new HashMap<String,String>();\n\tprivate Map<String,String> toMap = new HashMap<String,String>();\n\tInventoryQuery iq = InventoryFactory.getInstance().getQuery();\n\tInventoryAccess ia = InventoryFactory.getInstance().getAccess();\n\tprivate boolean testMode = true;\n\tprivate boolean interactive = true;\n\t//the default, overwrite files\n\tprivate boolean updateMetaOnMissing = false;\n\tprivate boolean overwrite = true;\n\t\n\t\n\tpublic void setTestMode(boolean val){\n\t\tthis.testMode = val;\n\t}\n\t\n\t\n\tpublic Map<String,Object> productReassociate(Long productId, String toProductType){\n\t\tinteractive = false;\n\t\tProduct g = iq.getProductMetadata(productId).getProduct();\n\n\t\tlog.debug(\"From ProductType:\" +g.getPtId());\n\t\tProductType fromD = iq.fetchProductType(g.getPtId());\n\t\t\n\t\t\n\t\tlog.debug(\"To ProductType:\" +toProductType);\n\n\t\tProductType toD = iq.fetchProductTypeByPersistentId(toProductType);\n\t\tString toBasePath = null;\n\t\t\n\t\t//make sure locMaps are defined (location policies).\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\t\n\t\tHashMap<String,Object> ret = new HashMap<String,Object>();\n\t\t\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\terrorList.add(\"No 'to basepath' found for productType [\"+toProductType+\"]. Failed to reassociate product.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tlog.info(\"Reassociating Product [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\treassociateProduct(g,toBasePath,toD, fromD);\n\t\tif(errorList.size() > 0 ){\n\t\t\tlog.debug(\"Errors processing reassociate.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\telse{\n\t\t\tlog.debug(\"Successfully processed product\");\n\t\t\tret.put(\"type\", \"success\");\n\t\t\tret.put(\"msgs\", msgList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void reassociateProducts(ProductType fromD, ProductType toD,\n\t\t\tString gnp, boolean moveAll) {\n\t\t\n\t\t\n\t\tString toBasePath = null;\n\t\tList<Long> productIds;\n\t\t\n\t\t//get products by name/pattern\n\t\tif(moveAll){\n\t\t\tproductIds = iq.getProductIdList(fromD.getId());\n\t\t}\n\t\telse{\n\t\t\t//find the products by pattern...\n\t\t\tproductIds = new ArrayList<Long>();\n\t\t\tList<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);\n\t\t\tfor(Product g: gList){\n\t\t\t\tproductIds.add(g.getId());\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Number of products to reassociate: \" + productIds.size());\n\t\t\n\t\t//fetch fromBasePaths\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\tSystem.exit(99);\n\t\t}\n\t\tint count = 1;\n\t\tfor(Long i : productIds){\n\n\t\t\tProduct g  = iq.getProductMetadata(i).getProduct();\n\t\t\tSystem.out.println(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\tlog.info(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\treassociateProduct(g, toBasePath, toD,fromD);\n\t\t\t++count;\n\t\t}\n\t\t\n\t\tif(errorList.size() > 0){\n\t\t\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed with errors:\");\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tSystem.out.println(\"\\t\" + s);\n\t\t\t}\n\t\t\t\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tlog.debug(\"Processing completed with errors:\");\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tlog.debug(\"\\t\" + s);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed without errors\");\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\t\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t\tlog.debug(\"Processing completed without errors\");\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t}\n\t}\n\n\tprivate void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD){\n\t\t/*\n\t\tif(this.testMode){\n\t\t\tString fromLoc=null, toLoc=null;\n\t\t\tfor(ProductArchive ga : iq.getProductArchiveSet()){\n\t\t\t\t//create old,new file locations\n\t\t\t\tfromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\ttoLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*/\n\t\t\n\t\t//offlineProduct\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"OFFLINE\");\n\t\t\n\t\t//move files\n\t\tif(!moveFiles(g,toBasePath)){\n\t\t\t//ERROR OCCURED, should we skip the rest?\n\t\t\tlog.warn(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.\");\n\t\t\terrorList.add(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.)\");\n\t\t\t\n\t\t\treturn;\n\t\t}\t\n\t\tlog.debug(\"Set product root, productType to [\"+toBasePath+\",\" + toD.getId()+\"]\");\n\t\tg.setRootPath(toBasePath);\n\t\tg.setPtId(toD.getId());\n\t\tString at = null;\n\t\ttry{\n\t\t\tat = iq.getProductTypeAccessType(toD.getId());\n\t\t}catch(Exception e){\n\t\t\tlog.debug(\"error getting productType info.\");\n\t\t\t//at = iq.getProductTypeMetadata(toD.getId()).getProductType().getProductTypePolicy().getAccessType();\n\t\t}\n\t\t//TODO see if this was necessary at all\n\t\t//g.setAccessType(at);\n\t\t\n\t\t\n\t\t//see if there exists a product for the toProductType already\n\t\tlog.debug(\"Delete Checks\");\n\t\tProduct exists =  iq.fetchProduct(toD.getId(), g.getName());\n\t\tif(exists != null){\n\t\t\tlog.debug(\"Product exists in destination product type.Removing product[\"+exists.getId()+\"]\");\n\n\t\t\tia.deleteProduct(exists, false);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tia.updateProductInfo(g);  //UNCOMMENT THIS \n\t\t\n\t\t//update productRefs\n\t\tlog.debug(\"Changing local product reference paths\");\n\t\t//reReference(g,toMap, locMap);\n\t\t\n\t\t\n\t\t//TODO\n\t\t//update product_real, date, int, char, spatial\n\t\t//Productelements will need to be mapped to the new DEIDS and updated in the product_* tables\n\t\tlog.debug(\"Chagning product elements to use new productType IDs\");\n\t\t//reElement(g, toD, fromD);\n\t\n\t\t//set product to online\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"ONLINE\");\n\t}\n\t\n\t//TODO reimplement when ready\n\t/*\n\tprivate void reElement(Product g, ProductType toD, ProductType fromD) {\n\t\t\n\t\tia.reElement(g,toD,fromD);\n//\t\tMap<Integer,String> deIDmapping = new HashMap<Integer,String>();\n//\t\tfor(ProductTypeElement toDE : toD.getProductTypeElementSet()){\n//\t\t\t\n//\t\t\tfor(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){\n//\t\t\t\tif(toDE.getElementDD().equals(fromDE.getElementDD()))\n//\t\t\t\t\tdeIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+\",\"+toDE.getDeId());\n//\t\t\t}\t\n//\t\t}\n//\t\tlog.debug(\"DEID Mappings\");\n//\t\tfor(Entry<Integer,String> me : deIDmapping.entrySet()){\n//\t\t\tString[] ary = me.getValue().split(\",\"); \n//\t\t\tString type = ary[0].trim();\n//\t\t\tInteger deId = Integer.valueOf(ary[1].trim());\n//\t\t\tif(type.equals(\"time\"))\n//\t\t\t\ttype = \"DATETIME\";\n//\t\t\t\n//\t\t\tlog.debug(\"map \"+ me.getKey() + \" to \" + deId + \"[\"+type+\"]\");\n//\t\t\tia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);\n//\t\t}\n\t}\n\n\tprivate void reReference(Product g, Map<String, String> toMap,\n\t\t\tMap<String, String> locMap) {\n\t\tfor(ProductReference ref : g.getProductReferenceSet()){\n\t\t\tif(ref.getType().contains(\"LOCAL\")){\n\t\t\t\tlog.debug(\"from: \" + ref.getPath());\n\t\t\t\t//check to make sure the *Map.gets are not null\n\t\t\t\tString replaceWith = toMap.get(ref.getType());\n\t\t\t\tif(replaceWith == null)\n\t\t\t\t{\n\t\t\t\t\terrorList.add(\"No entry in \\\"toProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString replace = locMap.get(ref.getType());\n\t\t\t\tif(replace == null){\n\t\t\t\t\terrorList.add(\"No entry in \\\"fromProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\t//this should never happen\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString newRef = ref.getPath().replaceAll(replace, replaceWith);\n\t\t\t\tlog.debug(\"newRef: \" + newRef);\n\t\t\t\t//make sure newRef is different that oldRef\n\t\t\t\tif(newRef.equals(ref.getPath())){\n\t\t\t\t\tlog.debug(\"newRef same as oldRef.\");\n\t\t\t\t\terrorList.add(\"product [\"+g.getProductId()+\"] newReference same as old reference.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n   */\n   private boolean moveFiles(Product g, String toBasePath) {\n\n      boolean noErrors = true;\n      log.debug(\"Product name: \" + g.getName());\n      String fromLoc = null, toLoc = null;\n      for (ProductArchive ga : iq.getProductArchives(g.getId())) {\n         // create old,new file locations\n         fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n         toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n         if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {\n            errorList.add(\"Error moving product file [\" + fromLoc + \"] to [\" + toLoc + \"]. Run with debug mode for more details.\");\n            noErrors = false;\n         } else\n            log.info(\"Successfully moved product file [\" + fromLoc + \"] to [\" + toLoc + \"].\");\n      }\n\n      // return true if we had an error.\n      return noErrors;\n\n   }\n\n}", "class_id": 0, "repo": "dataplumber/horizon", "file": "archive/src/main/java/gov/nasa/horizon/archive/core/Reassociate.java", "last_update_at": "2021-07-02T23:50:52+00:00", "question_id": "771fae9bb70c50c42d7f3b36993cef4a89b3c044", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Reassociate {\n\tprivate static Log log = LogFactory.getLog(Reassociate.class);\n\t\n\tprivate List<String> errorList = new ArrayList<String>();\n\tprivate List<String> msgList = new ArrayList<String>();\n\tprivate Map<String,String> locMap = new HashMap<String,String>();\n\tprivate Map<String,String> toMap = new HashMap<String,String>();\n\tInventoryQuery iq = InventoryFactory.getInstance().getQuery();\n\tInventoryAccess ia = InventoryFactory.getInstance().getAccess();\n\tprivate boolean testMode = true;\n\tprivate boolean interactive = true;\n\t//the default, overwrite files\n\tprivate boolean updateMetaOnMissing = false;\n\tprivate boolean overwrite = true;\n\t\n\t\n\tpublic void setTestMode(boolean val){\n\t\tthis.testMode = val;\n\t}\n\t\n\t\n\tpublic Map<String,Object> productReassociate(Long productId, String toProductType){\n\t\tinteractive = false;\n\t\tProduct g = iq.getProductMetadata(productId).getProduct();\n\t\tlog.debug(\"From ProductType:\" +g.getPtId());\n\t\tProductType fromD = iq.fetchProductType(g.getPtId());\n\t\t\n\t\t\n\t\tlog.debug(\"To ProductType:\" +toProductType);\n\t\tProductType toD = iq.fetchProductTypeByPersistentId(toProductType);\n\t\tString toBasePath = null;\n\t\t\n\t\t//make sure locMaps are defined (location policies).\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\t\n\t\tHashMap<String,Object> ret = new HashMap<String,Object>();\n\t\t\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\terrorList.add(\"No 'to basepath' found for productType [\"+toProductType+\"]. Failed to reassociate product.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tlog.info(\"Reassociating Product [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\treassociateProduct(g,toBasePath,toD, fromD);\n\t\tif(errorList.size() > 0 ){\n\t\t\tlog.debug(\"Errors processing reassociate.\");\n\t\t\tret.put(\"type\", \"failure\");\n\t\t\tret.put(\"msgs\", errorList);\n\t\t\treturn ret;\n\t\t}\n\t\telse{\n\t\t\tlog.debug(\"Successfully processed product\");\n\t\t\tret.put(\"type\", \"success\");\n\t\t\tret.put(\"msgs\", msgList);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic void reassociateProducts(ProductType fromD, ProductType toD,\n\t\t\tString gnp, boolean moveAll) {\n\t\t\n\t\t\n\t\tString toBasePath = null;\n\t\tList<Long> productIds;\n\t\t\n\t\t//get products by name/pattern\n\t\tif(moveAll){\n\t\t\tproductIds = iq.getProductIdList(fromD.getId());\n\t\t}\n\t\telse{\n\t\t\t//find the products by pattern...\n\t\t\tproductIds = new ArrayList<Long>();\n\t\t\tList<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);\n\t\t\tfor(Product g: gList){\n\t\t\t\tproductIds.add(g.getId());\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Number of products to reassociate: \" + productIds.size());\n\t\t\n\t\t//fetch fromBasePaths\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())){\n\t\t\tlocMap.put(dlp.getType(), dlp.getBasePath());\n\t\t}\n\t\t//fetch toBasePath\n\t\tfor(ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())){\n\t\t\tif(dlp.getType().contains(\"ARCHIVE\"))\n\t\t\t\ttoBasePath = dlp.getBasePath();\n\t\t\ttoMap.put(dlp.getType(),dlp.getBasePath());\n\t\t}\n\t\tif(toBasePath == null){\n\t\t\tlog.info(\"No toBasePath Found. Exiting.\");\n\t\t\tSystem.exit(99);\n\t\t}\n\t\tint count = 1;\n\t\tfor(Long i : productIds){\n\t\t\tProduct g  = iq.getProductMetadata(i).getProduct();\n\t\t\tSystem.out.println(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\tlog.info(\"Processing product \"+count+\" of \" + productIds.size() + \" [\"+g.getId()+\":\"+g.getName()+\"]\");\n\t\t\treassociateProduct(g, toBasePath, toD,fromD);\n\t\t\t++count;\n\t\t}\n\t\t\n\t\tif(errorList.size() > 0){\n\t\t\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed with errors:\");\n\t\t\tSystem.out.println(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tSystem.out.println(\"\\t\" + s);\n\t\t\t}\n\t\t\t\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tlog.debug(\"Processing completed with errors:\");\n\t\t\tlog.debug(\"---------------------------------\");\n\t\t\tfor(String s : errorList){\n\t\t\t\tlog.debug(\"\\t\" + s);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\tSystem.out.println(\"Processing completed without errors\");\n\t\t\tSystem.out.println(\"-----------------------------------\");\n\t\t\t\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t\tlog.debug(\"Processing completed without errors\");\n\t\t\tlog.debug(\"-----------------------------------\");\n\t\t}\n\t}\n\tprivate void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD){\n\t\t/*\n\t\tif(this.testMode){\n\t\t\tString fromLoc=null, toLoc=null;\n\t\t\tfor(ProductArchive ga : iq.getProductArchiveSet()){\n\t\t\t\t//create old,new file locations\n\t\t\t\tfromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tFrom: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\ttoLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n\t\t\t\tif(interactive)\n\t\t\t\t\tSystem.out.println(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tlog.info(\"\\tto: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t\tmsgList.add(\"[\"+g.getId()+\"] to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*/\n\t\t\n\t\t//offlineProduct\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"OFFLINE\");\n\t\t\n\t\t//move files\n\t\tif(!moveFiles(g,toBasePath)){\n\t\t\t//ERROR OCCURED, should we skip the rest?\n\t\t\tlog.warn(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.\");\n\t\t\terrorList.add(\"Error moving files. Product id [\"+g.getId()+\"] will abort processing (metadata has not been changed.)\");\n\t\t\t\n\t\t\treturn;\n\t\t}\t\n\t\tlog.debug(\"Set product root, productType to [\"+toBasePath+\",\" + toD.getId()+\"]\");\n\t\tg.setRootPath(toBasePath);\n\t\tg.setPtId(toD.getId());\n\t\tString at = null;\n\t\ttry{\n\t\t\tat = iq.getProductTypeAccessType(toD.getId());\n\t\t}catch(Exception e){\n\t\t\tlog.debug(\"error getting productType info.\");\n\t\t\t//at = iq.getProductTypeMetadata(toD.getId()).getProductType().getProductTypePolicy().getAccessType();\n\t\t}\n\t\t//TODO see if this was necessary at all\n\t\t//g.setAccessType(at);\n\t\t\n\t\t\n\t\t//see if there exists a product for the toProductType already\n\t\tlog.debug(\"Delete Checks\");\n\t\tProduct exists =  iq.fetchProduct(toD.getId(), g.getName());\n\t\tif(exists != null){\n\t\t\tlog.debug(\"Product exists in destination product type.Removing product[\"+exists.getId()+\"]\");\n\t\t\tia.deleteProduct(exists, false);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tia.updateProductInfo(g);  //UNCOMMENT THIS \n\t\t\n\t\t//update productRefs\n\t\tlog.debug(\"Changing local product reference paths\");\n\t\t//reReference(g,toMap, locMap);\n\t\t\n\t\t\n\t\t//TODO\n\t\t//update product_real, date, int, char, spatial\n\t\t//Productelements will need to be mapped to the new DEIDS and updated in the product_* tables\n\t\tlog.debug(\"Chagning product elements to use new productType IDs\");\n\t\t//reElement(g, toD, fromD);\n\t\n\t\t//set product to online\n\t\t//ia.updateProductArchiveStatus(g.getProductId(), \"ONLINE\");\n\t}\n\t\n\t//TODO reimplement when ready\n\t/*\n\tprivate void reElement(Product g, ProductType toD, ProductType fromD) {\n\t\t\n\t\tia.reElement(g,toD,fromD);\n//\t\tMap<Integer,String> deIDmapping = new HashMap<Integer,String>();\n//\t\tfor(ProductTypeElement toDE : toD.getProductTypeElementSet()){\n//\t\t\t\n//\t\t\tfor(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){\n//\t\t\t\tif(toDE.getElementDD().equals(fromDE.getElementDD()))\n//\t\t\t\t\tdeIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+\",\"+toDE.getDeId());\n//\t\t\t}\t\n//\t\t}\n//\t\tlog.debug(\"DEID Mappings\");\n//\t\tfor(Entry<Integer,String> me : deIDmapping.entrySet()){\n//\t\t\tString[] ary = me.getValue().split(\",\"); \n//\t\t\tString type = ary[0].trim();\n//\t\t\tInteger deId = Integer.valueOf(ary[1].trim());\n//\t\t\tif(type.equals(\"time\"))\n//\t\t\t\ttype = \"DATETIME\";\n//\t\t\t\n//\t\t\tlog.debug(\"map \"+ me.getKey() + \" to \" + deId + \"[\"+type+\"]\");\n//\t\t\tia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);\n//\t\t}\n\t}\n\tprivate void reReference(Product g, Map<String, String> toMap,\n\t\t\tMap<String, String> locMap) {\n\t\tfor(ProductReference ref : g.getProductReferenceSet()){\n\t\t\tif(ref.getType().contains(\"LOCAL\")){\n\t\t\t\tlog.debug(\"from: \" + ref.getPath());\n\t\t\t\t//check to make sure the *Map.gets are not null\n\t\t\t\tString replaceWith = toMap.get(ref.getType());\n\t\t\t\tif(replaceWith == null)\n\t\t\t\t{\n\t\t\t\t\terrorList.add(\"No entry in \\\"toProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString replace = locMap.get(ref.getType());\n\t\t\t\tif(replace == null){\n\t\t\t\t\terrorList.add(\"No entry in \\\"fromProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\t//this should never happen\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString newRef = ref.getPath().replaceAll(replace, replaceWith);\n\t\t\t\tlog.debug(\"newRef: \" + newRef);\n\t\t\t\t//make sure newRef is different that oldRef\n\t\t\t\tif(newRef.equals(ref.getPath())){\n\t\t\t\t\tlog.debug(\"newRef same as oldRef.\");\n\t\t\t\t\terrorList.add(\"product [\"+g.getProductId()+\"] newReference same as old reference.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n   */\n   private boolean moveFiles(Product g, String toBasePath) {\n      boolean noErrors = true;\n      log.debug(\"Product name: \" + g.getName());\n      String fromLoc = null, toLoc = null;\n      for (ProductArchive ga : iq.getProductArchives(g.getId())) {\n         // create old,new file locations\n         fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n         toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n         log.debug(\"to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n         if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {\n            errorList.add(\"Error moving product file [\" + fromLoc + \"] to [\" + toLoc + \"]. Run with debug mode for more details.\");\n            noErrors = false;\n         } else\n            log.info(\"Successfully moved product file [\" + fromLoc + \"] to [\" + toLoc + \"].\");\n      }\n      // return true if we had an error.\n      return noErrors;\n   }\n"]]}
{"hexsha": "aaf5418ef49cbe5565f0b3cf9c16a929b43a0ec1", "ext": "java", "lang": "Java", "content": "public class BaconHistogram {\r\n\tpublic static void main(String[] args) {\r\n\t\tSymbolGraph sg = new SymbolGraph(\"movies.txt\", \"/\");\r\n\r\n\t\tGraph G = sg.G();\r\n\r\n\t\tString source = \"Bacon, Kevin\";\r\n\t\tif (!sg.contains(source)) {\r\n\t\t\tStdOut.println(source + \"not in database.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint s = sg.index(source);\r\n\t\tBreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\r\n\r\n\t\tint[] num = new int[G.V()];\r\n\t\tint infinite = 0;\r\n\t\tfor (int v = 0; v < G.V(); v++) {\r\n\t\t\tint distance = bfs.distTo(v);\r\n\t\t\tif (distance != Integer.MAX_VALUE) {\r\n\t\t\t\tnum[distance]++;\r\n\t\t\t} else {\r\n\t\t\t\tinfinite++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0; i < num.length; i += 2) {\r\n\t\t\tif (num[i] != 0) {\r\n\t\t\t\tSystem.out.println(\"Kevin Bacon = \" + i / 2 + \" : \" + num[i]);\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Infinite(actors and movies): \" + infinite);\r\n\t}\r\n}", "class_id": 0, "repo": "wenghengcong/Algorithms", "file": "cs61b_algo4_other/src/com/luci/algorithms/chapter4_1/BaconHistogram.java", "last_update_at": "2021-12-14T21:17:40+00:00", "question_id": "aaf5418ef49cbe5565f0b3cf9c16a929b43a0ec1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaconHistogram {\r\n\tpublic static void main(String[] args) {\r\n\t\tSymbolGraph sg = new SymbolGraph(\"movies.txt\", \"/\");\r\n\r\n\t\tGraph G = sg.G();\r\n\r\n\t\tString source = \"Bacon, Kevin\";\r\n\t\tif (!sg.contains(source)) {\r\n\t\t\tStdOut.println(source + \"not in database.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint s = sg.index(source);\r\n\t\tBreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\r\n\r\n\t\tint[] num = new int[G.V()];\r\n\t\tint infinite = 0;\r\n\t\tfor (int v = 0; v < G.V(); v++) {\r\n\t\t\tint distance = bfs.distTo(v);\r\n\t\t\tif (distance != Integer.MAX_VALUE) {\r\n\t\t\t\tnum[distance]++;\r\n\t\t\t} else {\r\n\t\t\t\tinfinite++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0; i < num.length; i += 2) {\r\n\t\t\tif (num[i] != 0) {\r\n\t\t\t\tSystem.out.println(\"Kevin Bacon = \" + i / 2 + \" : \" + num[i]);\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Infinite(actors and movies): \" + infinite);\r\n\t}\r\n"]]}
{"hexsha": "bd5b15cd144abcfa59c8caa88db76b914d05a608", "ext": "java", "lang": "Java", "content": "public class CalendarFormatterStressTest {\n\n  private static final int DATE = 0x01;\n  private static final int TIME = 0x02;\n  private static final int WRAPPER = 0x04;\n  private static final int DATESKEL = 0x08;\n  private static final int TIMESKEL = 0x10;\n  \n  private static final CalendarFormat[] FORMATS = CalendarFormat.values();\n  private static final int FORMATS_LEN = FORMATS.length;\n  private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();\n  private static final int SKELETONS_LEN = SKELETONS.length;\n  \n  @Test\n  public void testCalendarFormatter() {\n    StringBuilder buffer = new StringBuilder();\n    long epoch = 1288648500000L;\n    CLDR.Locale[] locales = new CLDR.Locale[] {\n      CLDR.Locale.en_US,\n      CLDR.Locale.am,\n      CLDR.Locale.ar,\n      CLDR.Locale.fr,\n      CLDR.Locale.de,\n      CLDR.Locale.en_GB\n    };\n    \n    ZoneId zoneId = ZoneId.of(\"America/New_York\");\n    ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);\n\n    for (CLDR.Locale locale : locales) {\n      CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);\n      int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;\n      int inner = FORMATS_LEN * SKELETONS_LEN;\n      for (int i = 0; i < outer; i++) {\n        for (int j = 0; j < inner; j++) {\n          CalendarFormatOptions options = options(i, j);\n          buffer.setLength(0);\n          f.format(datetime, options, buffer);\n        }\n      }\n    }\n  }\n  \n  private static CalendarFormatOptions options(int flag, int choice) {\n    CalendarFormatOptions opts = new CalendarFormatOptions();\n    if ((flag & DATE) != 0) {\n      opts.setDateFormat(format(choice));\n    }\n    if ((flag & TIME) != 0) {\n      opts.setTimeFormat(format(choice));\n    }\n    if ((flag & WRAPPER) != 0) {\n      opts.setWrapperFormat(format(choice));\n    }\n    if ((flag & DATESKEL) != 0) {\n      opts.setDateSkeleton(skeleton(choice));\n    }\n    if ((flag & TIMESKEL) != 0) {\n      opts.setTimeSkeleton(skeleton(choice));\n    }\n    return opts;\n  }\n  \n  private static CalendarFormat format(int choice) {\n    return FORMATS[choice % FORMATS_LEN];\n  }\n  \n  private static CalendarSkeleton skeleton(int choice) {\n    return SKELETONS[choice % SKELETONS_LEN];\n  }\n  \n}", "class_id": 0, "repo": "Squarespace/cldr", "file": "runtime/src/test/java/com/squarespace/cldr/dates/CalendarFormatterStressTest.java", "last_update_at": "2021-03-10T13:56:40+00:00", "question_id": "bd5b15cd144abcfa59c8caa88db76b914d05a608", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CalendarFormatterStressTest {\n  private static final int DATE = 0x01;\n  private static final int TIME = 0x02;\n  private static final int WRAPPER = 0x04;\n  private static final int DATESKEL = 0x08;\n  private static final int TIMESKEL = 0x10;\n  private static final CalendarFormat[] FORMATS = CalendarFormat.values();\n  private static final int FORMATS_LEN = FORMATS.length;\n  private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();\n  private static final int SKELETONS_LEN = SKELETONS.length;\n  @Test\n  public void testCalendarFormatter() {\n    StringBuilder buffer = new StringBuilder();\n    long epoch = 1288648500000L;\n    CLDR.Locale[] locales = new CLDR.Locale[] {\n      CLDR.Locale.en_US,\n      CLDR.Locale.am,\n      CLDR.Locale.ar,\n      CLDR.Locale.fr,\n      CLDR.Locale.de,\n      CLDR.Locale.en_GB\n    };\n    ZoneId zoneId = ZoneId.of(\"America/New_York\");\n    ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);\n    for (CLDR.Locale locale : locales) {\n      CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);\n      int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;\n      int inner = FORMATS_LEN * SKELETONS_LEN;\n      for (int i = 0; i < outer; i++) {\n        for (int j = 0; j < inner; j++) {\n          CalendarFormatOptions options = options(i, j);\n          buffer.setLength(0);\n          f.format(datetime, options, buffer);\n        }\n      }\n    }\n  }\n  private static CalendarFormatOptions options(int flag, int choice) {\n    CalendarFormatOptions opts = new CalendarFormatOptions();\n    if ((flag & DATE) != 0) {\n      opts.setDateFormat(format(choice));\n    }\n    if ((flag & TIME) != 0) {\n      opts.setTimeFormat(format(choice));\n    }\n    if ((flag & WRAPPER) != 0) {\n      opts.setWrapperFormat(format(choice));\n    }\n    if ((flag & DATESKEL) != 0) {\n      opts.setDateSkeleton(skeleton(choice));\n    }\n    if ((flag & TIMESKEL) != 0) {\n      opts.setTimeSkeleton(skeleton(choice));\n    }\n    return opts;\n  }\n  private static CalendarFormat format(int choice) {\n    return FORMATS[choice % FORMATS_LEN];\n  }\n  private static CalendarSkeleton skeleton(int choice) {\n    return SKELETONS[choice % SKELETONS_LEN];\n  }\n"]]}
{"hexsha": "2861105d837d7c45ed2e603975d65a33155fbc51", "ext": "java", "lang": "Java", "content": "@ObjectHolder(Reference.MOD_ID)\npublic class ModSoundEvents\n{\n    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();\n\n    static\n    {\n        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS)\n        {\n            Instrument instrument = handHeld.getInstrument();\n            if (!SOUNDS.containsKey(instrument.sounds.timbre))\n            {\n                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));\n            }\n        }\n    }\n\n    /**\n     * Register a {@link SoundEvent}.\n     *\n     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound\n     *                  resources. Without the prefix it will reference vanilla sound resources.\n     * @return The SoundEvent\n     */\n    @Nullable\n    private static SoundEvent registerSound(String soundName)\n    {\n        final ResourceLocation soundID = new ResourceLocation(soundName);\n        SoundEvent soundEvent;\n\n        if (soundName.contains(Reference.MOD_DOMAIN))\n            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);\n        else\n            soundEvent = SoundEvent.REGISTRY.getObject(soundID);\n\n        return soundEvent;\n    }\n\n    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)\n    public static class RegistrationHandler\n    {\n        @SubscribeEvent\n        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event)\n        {\n            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));\n        }\n    }\n\n    /**\n     * Get a {@link SoundEvent} by name\n     *\n     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the\n     *                  instruments.json file can be returned. However, in the event a key is not found the default\n     *                  will be the vanilla note block 'pling' sound.\n     * @return The SoundEvent\n     */\n    public static SoundEvent getSound(String soundName) {return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);}\n}", "class_id": 0, "repo": "Aeronica/BardMania", "file": "src/main/java/net/aeronica/mods/bard_mania/server/init/ModSoundEvents.java", "last_update_at": "2021-02-28T19:44:44+00:00", "question_id": "2861105d837d7c45ed2e603975d65a33155fbc51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ObjectHolder(Reference.MOD_ID)\npublic class ModSoundEvents\n{\n    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();\n    static\n    {\n        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS)\n        {\n            Instrument instrument = handHeld.getInstrument();\n            if (!SOUNDS.containsKey(instrument.sounds.timbre))\n            {\n                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));\n            }\n        }\n    }\n    /**\n     * Register a {@link SoundEvent}.\n     *\n     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound\n     *                  resources. Without the prefix it will reference vanilla sound resources.\n     * @return The SoundEvent\n     */\n    @Nullable\n    private static SoundEvent registerSound(String soundName)\n    {\n        final ResourceLocation soundID = new ResourceLocation(soundName);\n        SoundEvent soundEvent;\n        if (soundName.contains(Reference.MOD_DOMAIN))\n            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);\n        else\n            soundEvent = SoundEvent.REGISTRY.getObject(soundID);\n        return soundEvent;\n    }\n    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)\n    public static class RegistrationHandler\n    {\n        @SubscribeEvent\n        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event)\n        {\n            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));\n        }\n    }\n    /**\n     * Get a {@link SoundEvent} by name\n     *\n     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the\n     *                  instruments.json file can be returned. However, in the event a key is not found the default\n     *                  will be the vanilla note block 'pling' sound.\n     * @return The SoundEvent\n     */\n    public static SoundEvent getSound(String soundName) {return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);}\n"]]}
{"hexsha": "6ae321693fd396814c3cd664d6f460c3b1c7fca7", "ext": "java", "lang": "Java", "content": "public class ChangePasswordRequestValidator implements Validator {\n\n  static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(\n      new LengthRule(8, 30),\n      new CharacterRule(EnglishCharacterData.UpperCase, 1),\n      new CharacterRule(EnglishCharacterData.LowerCase, 1),\n      new CharacterRule(EnglishCharacterData.Digit, 1),\n      new CharacterRule(EnglishCharacterData.Special, 1),\n      new WhitespaceRule()));\n\n  @Override\n  public boolean supports(Class<?> clazz) {\n    return ChangePasswordRequest.class.equals(clazz);\n  }\n\n  @Override\n  public void validate(Object target, Errors e) {\n    ChangePasswordRequest request = (ChangePasswordRequest) target;\n    if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {\n      e.rejectValue(\"newPasswordAgain\", \"password.mismatch\");\n    }\n\n    RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));\n    if (!result.isValid()) {\n      List<String> messages = PASSWORD_VALIDATOR.getMessages(result);\n      String messageTemplate = messages.stream()\n          .collect(Collectors.joining(\",\"));\n      e.rejectValue(\"newPassword\", messageTemplate);\n    }\n  }\n}", "class_id": 0, "repo": "tsvetinakalcheva/air-quality-hackathon-project", "file": "src/main/java/bg/startit/hackathon/airquiality/validation/ChangePasswordRequestValidator.java", "last_update_at": "2021-01-06T18:37:06+00:00", "question_id": "6ae321693fd396814c3cd664d6f460c3b1c7fca7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChangePasswordRequestValidator implements Validator {\n  static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(\n      new LengthRule(8, 30),\n      new CharacterRule(EnglishCharacterData.UpperCase, 1),\n      new CharacterRule(EnglishCharacterData.LowerCase, 1),\n      new CharacterRule(EnglishCharacterData.Digit, 1),\n      new CharacterRule(EnglishCharacterData.Special, 1),\n      new WhitespaceRule()));\n  @Override\n  public boolean supports(Class<?> clazz) {\n    return ChangePasswordRequest.class.equals(clazz);\n  }\n  @Override\n  public void validate(Object target, Errors e) {\n    ChangePasswordRequest request = (ChangePasswordRequest) target;\n    if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {\n      e.rejectValue(\"newPasswordAgain\", \"password.mismatch\");\n    }\n    RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));\n    if (!result.isValid()) {\n      List<String> messages = PASSWORD_VALIDATOR.getMessages(result);\n      String messageTemplate = messages.stream()\n          .collect(Collectors.joining(\",\"));\n      e.rejectValue(\"newPassword\", messageTemplate);\n    }\n  }\n"]]}
{"hexsha": "4cd1cd9c2d1e80e72112eab945a3b2e22ef7b82b", "ext": "java", "lang": "Java", "content": "public class LoginSessionHandler implements MinecraftSessionHandler {\n    private final ServerConnection connection;\n    private boolean informationForwarded;\n\n    public LoginSessionHandler(ServerConnection connection) {\n        this.connection = connection;\n    }\n\n    @Override\n    public void handle(MinecraftPacket packet) {\n        if (packet instanceof EncryptionRequest) {\n            throw new IllegalStateException(\"Backend server is online-mode!\");\n        } else if (packet instanceof LoginPluginMessage) {\n            LoginPluginMessage message = (LoginPluginMessage) packet;\n            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();\n            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(true);\n                response.setId(message.getId());\n                response.setData(createForwardingData(configuration.getForwardingSecret(),\n                        connection.getProxyPlayer().getRemoteAddress().getHostString(),\n                        connection.getProxyPlayer().getProfile()));\n                connection.getMinecraftConnection().write(response);\n                informationForwarded = true;\n            } else {\n                // Don't understand\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(false);\n                response.setId(message.getId());\n                response.setData(Unpooled.EMPTY_BUFFER);\n                connection.getMinecraftConnection().write(response);\n            }\n        } else if (packet instanceof Disconnect) {\n            Disconnect disconnect = (Disconnect) packet;\n            // Do we have an outstanding notification? If so, fulfill it.\n            doNotify(ConnectionRequestResults.forDisconnect(disconnect));\n            connection.disconnect();\n        } else if (packet instanceof SetCompression) {\n            SetCompression sc = (SetCompression) packet;\n            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());\n        } else if (packet instanceof ServerLoginSuccess) {\n            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    !informationForwarded) {\n                doNotify(ConnectionRequestResults.forDisconnect(\n                        TextComponent.of(\"Your server did not send a forwarding request to the proxy. Is it set up correctly?\")));\n                connection.disconnect();\n                return;\n            }\n\n            // The player has been logged on to the backend server.\n            connection.getMinecraftConnection().setState(StateRegistry.PLAY);\n            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();\n            if (existingConnection == null) {\n                // Strap on the play session handler\n                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));\n            } else {\n                // The previous server connection should become obsolete.\n                existingConnection.disconnect();\n            }\n\n            doNotify(ConnectionRequestResults.SUCCESSFUL);\n            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));\n            connection.getProxyPlayer().setConnectedServer(connection);\n        }\n    }\n\n    @Override\n    public void exception(Throwable throwable) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.completeExceptionally(throwable);\n        }\n    }\n\n    private void doNotify(ConnectionRequestBuilder.Result result) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.complete(result);\n        }\n    }\n\n    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {\n        ByteBuf dataToForward = Unpooled.buffer();\n        ByteBuf finalData = Unpooled.buffer();\n        try {\n            ProtocolUtils.writeString(dataToForward, address);\n            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());\n            ProtocolUtils.writeString(dataToForward, profile.getName());\n            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());\n            for (GameProfile.Property property : profile.getProperties()) {\n                ProtocolUtils.writeString(dataToForward, property.getName());\n                ProtocolUtils.writeString(dataToForward, property.getValue());\n                String signature = property.getSignature();\n                if (signature != null) {\n                    dataToForward.writeBoolean(true);\n                    ProtocolUtils.writeString(dataToForward, signature);\n                } else {\n                    dataToForward.writeBoolean(false);\n                }\n            }\n\n            SecretKey key = new SecretKeySpec(hmacSecret, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(key);\n            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());\n            byte[] sig = mac.doFinal();\n            finalData.writeBytes(sig);\n            finalData.writeBytes(dataToForward);\n            return finalData;\n        } catch (InvalidKeyException e) {\n            finalData.release();\n            throw new RuntimeException(\"Unable to authenticate data\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen\n            finalData.release();\n            throw new AssertionError(e);\n        } finally {\n            dataToForward.release();\n        }\n    }\n}", "class_id": 0, "repo": "phase/Velocity", "file": "proxy/src/main/java/com/velocitypowered/proxy/connection/backend/LoginSessionHandler.java", "last_update_at": "2021-09-24T22:44:49+00:00", "question_id": "4cd1cd9c2d1e80e72112eab945a3b2e22ef7b82b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoginSessionHandler implements MinecraftSessionHandler {\n    private final ServerConnection connection;\n    private boolean informationForwarded;\n    public LoginSessionHandler(ServerConnection connection) {\n        this.connection = connection;\n    }\n    @Override\n    public void handle(MinecraftPacket packet) {\n        if (packet instanceof EncryptionRequest) {\n            throw new IllegalStateException(\"Backend server is online-mode!\");\n        } else if (packet instanceof LoginPluginMessage) {\n            LoginPluginMessage message = (LoginPluginMessage) packet;\n            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();\n            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(true);\n                response.setId(message.getId());\n                response.setData(createForwardingData(configuration.getForwardingSecret(),\n                        connection.getProxyPlayer().getRemoteAddress().getHostString(),\n                        connection.getProxyPlayer().getProfile()));\n                connection.getMinecraftConnection().write(response);\n                informationForwarded = true;\n            } else {\n                // Don't understand\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(false);\n                response.setId(message.getId());\n                response.setData(Unpooled.EMPTY_BUFFER);\n                connection.getMinecraftConnection().write(response);\n            }\n        } else if (packet instanceof Disconnect) {\n            Disconnect disconnect = (Disconnect) packet;\n            // Do we have an outstanding notification? If so, fulfill it.\n            doNotify(ConnectionRequestResults.forDisconnect(disconnect));\n            connection.disconnect();\n        } else if (packet instanceof SetCompression) {\n            SetCompression sc = (SetCompression) packet;\n            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());\n        } else if (packet instanceof ServerLoginSuccess) {\n            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN &&\n                    !informationForwarded) {\n                doNotify(ConnectionRequestResults.forDisconnect(\n                        TextComponent.of(\"Your server did not send a forwarding request to the proxy. Is it set up correctly?\")));\n                connection.disconnect();\n                return;\n            }\n            // The player has been logged on to the backend server.\n            connection.getMinecraftConnection().setState(StateRegistry.PLAY);\n            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();\n            if (existingConnection == null) {\n                // Strap on the play session handler\n                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));\n            } else {\n                // The previous server connection should become obsolete.\n                existingConnection.disconnect();\n            }\n            doNotify(ConnectionRequestResults.SUCCESSFUL);\n            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));\n            connection.getProxyPlayer().setConnectedServer(connection);\n        }\n    }\n    @Override\n    public void exception(Throwable throwable) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.completeExceptionally(throwable);\n        }\n    }\n    private void doNotify(ConnectionRequestBuilder.Result result) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel()\n                .attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.complete(result);\n        }\n    }\n    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {\n        ByteBuf dataToForward = Unpooled.buffer();\n        ByteBuf finalData = Unpooled.buffer();\n        try {\n            ProtocolUtils.writeString(dataToForward, address);\n            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());\n            ProtocolUtils.writeString(dataToForward, profile.getName());\n            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());\n            for (GameProfile.Property property : profile.getProperties()) {\n                ProtocolUtils.writeString(dataToForward, property.getName());\n                ProtocolUtils.writeString(dataToForward, property.getValue());\n                String signature = property.getSignature();\n                if (signature != null) {\n                    dataToForward.writeBoolean(true);\n                    ProtocolUtils.writeString(dataToForward, signature);\n                } else {\n                    dataToForward.writeBoolean(false);\n                }\n            }\n            SecretKey key = new SecretKeySpec(hmacSecret, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(key);\n            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());\n            byte[] sig = mac.doFinal();\n            finalData.writeBytes(sig);\n            finalData.writeBytes(dataToForward);\n            return finalData;\n        } catch (InvalidKeyException e) {\n            finalData.release();\n            throw new RuntimeException(\"Unable to authenticate data\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen\n            finalData.release();\n            throw new AssertionError(e);\n        } finally {\n            dataToForward.release();\n        }\n    }\n"]]}
{"hexsha": "e221bba277ec3b7366089248282c8d030b848dd5", "ext": "java", "lang": "Java", "content": "public class GtidSet {\n\n    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();\n\n    /**\n     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).\n     */\n    public GtidSet(String gtidSet) {\n        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(\",\");\n        for (String uuidSet : uuidSets) {\n            int uuidSeparatorIndex = uuidSet.indexOf(\":\");\n            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);\n            List<Interval> intervals = new ArrayList<Interval>();\n            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(\":\");\n            for (String interval : rawIntervals) {\n                String[] is = interval.split(\"-\");\n                long[] split = new long[is.length];\n                for (int i = 0, e = is.length; i < e; i++) {\n                    split[i] = Long.parseLong(is[i]);\n                }\n                if (split.length == 1) {\n                    split = new long[] {split[0], split[0]};\n                }\n                intervals.add(new Interval(split[0], split[1]));\n            }\n            map.put(sourceId, new UUIDSet(sourceId, intervals));\n        }\n    }\n\n    public Collection<UUIDSet> getUUIDSets() {\n        return map.values();\n    }\n\n    /**\n     * @param gtid GTID (\"source_id:transaction_id\")\n     * @return whether or not gtid was added to the set (false if it was already there)\n     */\n    public boolean add(String gtid) {\n        String[] split = gtid.split(\":\");\n        String sourceId = split[0];\n        long transactionId = Long.parseLong(split[1]);\n        UUIDSet uuidSet = map.get(sourceId);\n        if (uuidSet == null) {\n            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));\n        }\n        List<Interval> intervals = (List<Interval>) uuidSet.intervals;\n        int index = findInterval(intervals, transactionId);\n        boolean addedToExisting = false;\n        if (index < intervals.size()) {\n            Interval interval = intervals.get(index);\n            if (interval.start == transactionId + 1) {\n                interval.start = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.end + 1 == transactionId) {\n                interval.end = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.start <= transactionId && transactionId <= interval.end) {\n                return false;\n            }\n        }\n        if (!addedToExisting) {\n            intervals.add(index, new Interval(transactionId, transactionId));\n        }\n        if (intervals.size() > 1) {\n            joinAdjacentIntervals(intervals, index);\n        }\n        return true;\n    }\n\n    /**\n     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).\n     */\n    private void joinAdjacentIntervals(List<Interval> intervals, int index) {\n        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {\n            Interval a = intervals.get(i - 1), b = intervals.get(i);\n            if (a.end + 1 == b.start) {\n                a.end = b.end;\n                intervals.remove(i);\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        List<String> gtids = new ArrayList<String>();\n        for (UUIDSet uuidSet : map.values()) {\n            gtids.add(uuidSet.getUUID() + \":\" + join(uuidSet.intervals, \":\"));\n        }\n        return join(gtids, \",\");\n    }\n\n    /**\n     * @return index which is either a pointer to the interval containing v or a position at which v can be added\n     */\n    private static int findInterval(List<Interval> ii, long v) {\n        int l = 0, p = 0, r = ii.size();\n        while (l < r) {\n            p = (l + r) / 2;\n            Interval i = ii.get(p);\n            if (i.end < v) {\n                l = p + 1;\n            } else\n            if (v < i.start) {\n                r = p;\n            } else {\n                return p;\n            }\n        }\n        if (!ii.isEmpty() && ii.get(p).end < v) {\n            p++;\n        }\n        return p;\n    }\n\n    private String join(Collection o, String delimiter) {\n        if (o.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Object o1 : o) {\n            sb.append(o1).append(delimiter);\n        }\n        return sb.substring(0, sb.length() - delimiter.length());\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class UUIDSet {\n\n        private String uuid;\n        private Collection<Interval> intervals;\n\n        private UUIDSet(String uuid, Collection<Interval> intervals) {\n            this.uuid = uuid;\n            this.intervals = intervals;\n        }\n\n        public String getUUID() {\n            return uuid;\n        }\n\n        public Collection<Interval> getIntervals() {\n            return intervals;\n        }\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class Interval implements Comparable<Interval> {\n\n        private long start;\n        private long end;\n\n        private Interval(long start, long end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        public long getStart() {\n            return start;\n        }\n\n        public long getEnd() {\n            return end;\n        }\n\n        @Override\n        public String toString() {\n            return start + \"-\" + end;\n        }\n\n        @Override\n        public int compareTo(Interval o) {\n            return saturatedCast(this.start - o.start);\n        }\n\n        private static int saturatedCast(long value) {\n            if (value > Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n            if (value < Integer.MIN_VALUE) {\n                return Integer.MIN_VALUE;\n            }\n            return (int) value;\n        }\n    }\n\n}", "class_id": 0, "repo": "rong360/cdc", "file": "src/main/java/com/github/shyiko/mysql/binlog/GtidSet.java", "last_update_at": "2021-07-20T01:41:18+00:00", "question_id": "e221bba277ec3b7366089248282c8d030b848dd5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GtidSet {\n    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();\n    /**\n     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).\n     */\n    public GtidSet(String gtidSet) {\n        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(\",\");\n        for (String uuidSet : uuidSets) {\n            int uuidSeparatorIndex = uuidSet.indexOf(\":\");\n            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);\n            List<Interval> intervals = new ArrayList<Interval>();\n            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(\":\");\n            for (String interval : rawIntervals) {\n                String[] is = interval.split(\"-\");\n                long[] split = new long[is.length];\n                for (int i = 0, e = is.length; i < e; i++) {\n                    split[i] = Long.parseLong(is[i]);\n                }\n                if (split.length == 1) {\n                    split = new long[] {split[0], split[0]};\n                }\n                intervals.add(new Interval(split[0], split[1]));\n            }\n            map.put(sourceId, new UUIDSet(sourceId, intervals));\n        }\n    }\n    public Collection<UUIDSet> getUUIDSets() {\n        return map.values();\n    }\n    /**\n     * @param gtid GTID (\"source_id:transaction_id\")\n     * @return whether or not gtid was added to the set (false if it was already there)\n     */\n    public boolean add(String gtid) {\n        String[] split = gtid.split(\":\");\n        String sourceId = split[0];\n        long transactionId = Long.parseLong(split[1]);\n        UUIDSet uuidSet = map.get(sourceId);\n        if (uuidSet == null) {\n            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));\n        }\n        List<Interval> intervals = (List<Interval>) uuidSet.intervals;\n        int index = findInterval(intervals, transactionId);\n        boolean addedToExisting = false;\n        if (index < intervals.size()) {\n            Interval interval = intervals.get(index);\n            if (interval.start == transactionId + 1) {\n                interval.start = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.end + 1 == transactionId) {\n                interval.end = transactionId;\n                addedToExisting = true;\n            } else\n            if (interval.start <= transactionId && transactionId <= interval.end) {\n                return false;\n            }\n        }\n        if (!addedToExisting) {\n            intervals.add(index, new Interval(transactionId, transactionId));\n        }\n        if (intervals.size() > 1) {\n            joinAdjacentIntervals(intervals, index);\n        }\n        return true;\n    }\n    /**\n     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).\n     */\n    private void joinAdjacentIntervals(List<Interval> intervals, int index) {\n        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {\n            Interval a = intervals.get(i - 1), b = intervals.get(i);\n            if (a.end + 1 == b.start) {\n                a.end = b.end;\n                intervals.remove(i);\n            }\n        }\n    }\n    @Override\n    public String toString() {\n        List<String> gtids = new ArrayList<String>();\n        for (UUIDSet uuidSet : map.values()) {\n            gtids.add(uuidSet.getUUID() + \":\" + join(uuidSet.intervals, \":\"));\n        }\n        return join(gtids, \",\");\n    }\n    /**\n     * @return index which is either a pointer to the interval containing v or a position at which v can be added\n     */\n    private static int findInterval(List<Interval> ii, long v) {\n        int l = 0, p = 0, r = ii.size();\n        while (l < r) {\n            p = (l + r) / 2;\n            Interval i = ii.get(p);\n            if (i.end < v) {\n                l = p + 1;\n            } else\n            if (v < i.start) {\n                r = p;\n            } else {\n                return p;\n            }\n        }\n        if (!ii.isEmpty() && ii.get(p).end < v) {\n            p++;\n        }\n        return p;\n    }\n    private String join(Collection o, String delimiter) {\n        if (o.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Object o1 : o) {\n            sb.append(o1).append(delimiter);\n        }\n        return sb.substring(0, sb.length() - delimiter.length());\n    }\n    /**\n     * @see GtidSet\n     */\n    public static final class UUIDSet {\n        private String uuid;\n        private Collection<Interval> intervals;\n        private UUIDSet(String uuid, Collection<Interval> intervals) {\n            this.uuid = uuid;\n            this.intervals = intervals;\n        }\n        public String getUUID() {\n            return uuid;\n        }\n        public Collection<Interval> getIntervals() {\n            return intervals;\n        }\n    }\n    /**\n     * @see GtidSet\n     */\n    public static final class Interval implements Comparable<Interval> {\n        private long start;\n        private long end;\n        private Interval(long start, long end) {\n            this.start = start;\n            this.end = end;\n        }\n        public long getStart() {\n            return start;\n        }\n        public long getEnd() {\n            return end;\n        }\n        @Override\n        public String toString() {\n            return start + \"-\" + end;\n        }\n        @Override\n        public int compareTo(Interval o) {\n            return saturatedCast(this.start - o.start);\n        }\n        private static int saturatedCast(long value) {\n            if (value > Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n            if (value < Integer.MIN_VALUE) {\n                return Integer.MIN_VALUE;\n            }\n            return (int) value;\n        }\n    }\n"]]}
{"hexsha": "76a729674dee4fe36c1fccda5f23c96fd9c3eae6", "ext": "java", "lang": "Java", "content": "public class ECSTaskTemplateTest {\n\n    @Test\n    public void shouldMerge() throws Exception {\n\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n\n\n        ECSTaskTemplate result = child.merge(parent);\n\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnSettingsFromParent() throws Exception {\n\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, null, \"child-repository-credentials\", \"EC2\", \"child-network-mode\",  \"child-remoteFSRoot\", // image is set to null\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"parent-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate result = child.merge(parent);\n\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnChildIfNoParent() throws Exception {\n\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null); // inheritFrom is null\n\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n\n        ECSTaskTemplate result = child.merge(null);\n\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n}", "class_id": 0, "repo": "kdvy/amazon-ecs-plugin", "file": "src/test/java/com/cloudbees/jenkins/plugins/amazonecs/ECSTaskTemplateTest.java", "last_update_at": "2021-04-11T06:11:28+00:00", "question_id": "76a729674dee4fe36c1fccda5f23c96fd9c3eae6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ECSTaskTemplateTest {\n    @Test\n    public void shouldMerge() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n    @Test\n    public void shouldReturnSettingsFromParent() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, null, \"child-repository-credentials\", \"EC2\", \"child-network-mode\",  \"child-remoteFSRoot\", // image is set to null\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\n            \"parent-name\", \"parent-label\",\n            null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"parent-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n    @Test\n    public void shouldReturnChildIfNoParent() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null); // inheritFrom is null\n        ECSTaskTemplate expected = new ECSTaskTemplate(\n            \"child-name\", \"child-label\",\n            null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\",\n            0, 0, 0, null, null, false, false,\n            \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(null);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n"]]}
{"hexsha": "21acef61c95ebaa70ee8aa8170419592df0fc1f2", "ext": "java", "lang": "Java", "content": "public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {\n\n    private HttpServletResponse response;\n    private MessageBodyWriter<Object> wrapped;\n\n    @SuppressWarnings(\"unchecked\") //\n    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {\n        this.response = response;\n        this.wrapped = (MessageBodyWriter<Object>) writer;\n    }\n\n    @Override //\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.isWriteable(type, genericType, annotations, mediaType);\n    }\n\n    @Override //\n    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.getSize(entity, type, genericType, annotations, mediaType);\n    }\n\n    @Override //\n    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType,\n            MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n\n        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\n            throws IOException, WebApplicationException {\n\n        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    private static class HeadersWriterOutputStream extends FilterOutputStream {\n\n        private static final Http HTTP = new Http();\n\n        private boolean done;\n        private HttpServletResponse response;\n        private MultivaluedMap<String, Object> httpHeaders;\n\n        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {\n            super(out);\n            this.response = response;\n            this.httpHeaders = httpHeaders;\n        }\n\n        private void writeHeaders() {\n            if (done) {\n                return;\n            }\n            done = true;\n            if (httpHeaders == null) {\n                return;\n            }\n            HTTP.writeHeaders(response, httpHeaders);\n        }\n\n        @Override //\n        public void write(int b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        @Override //\n        public void write(byte[] b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        @Override //\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeHeaders();\n            super.write(b, off, len);\n        }\n\n        @Override //\n        public void flush() throws IOException {\n            writeHeaders();\n            super.flush();\n        }\n\n        @Override //\n        public void close() throws IOException {\n            writeHeaders();\n            super.close();\n        }\n    }\n}", "class_id": 0, "repo": "Gmugra/net.cactusthorn.routing", "file": "core/src/main/java/net/cactusthorn/routing/body/writer/MessageBodyHeadersWriter.java", "last_update_at": "2021-08-30T09:07:33+00:00", "question_id": "21acef61c95ebaa70ee8aa8170419592df0fc1f2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {\n    private HttpServletResponse response;\n    private MessageBodyWriter<Object> wrapped;\n    @SuppressWarnings(\"unchecked\") //\n    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {\n        this.response = response;\n        this.wrapped = (MessageBodyWriter<Object>) writer;\n    }\n    @Override //\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.isWriteable(type, genericType, annotations, mediaType);\n    }\n    @Override //\n    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.getSize(entity, type, genericType, annotations, mediaType);\n    }\n    @Override //\n    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType,\n            MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\n            throws IOException, WebApplicationException {\n        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders,\n                new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n    private static class HeadersWriterOutputStream extends FilterOutputStream {\n        private static final Http HTTP = new Http();\n        private boolean done;\n        private HttpServletResponse response;\n        private MultivaluedMap<String, Object> httpHeaders;\n        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {\n            super(out);\n            this.response = response;\n            this.httpHeaders = httpHeaders;\n        }\n        private void writeHeaders() {\n            if (done) {\n                return;\n            }\n            done = true;\n            if (httpHeaders == null) {\n                return;\n            }\n            HTTP.writeHeaders(response, httpHeaders);\n        }\n        @Override //\n        public void write(int b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n        @Override //\n        public void write(byte[] b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n        @Override //\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeHeaders();\n            super.write(b, off, len);\n        }\n        @Override //\n        public void flush() throws IOException {\n            writeHeaders();\n            super.flush();\n        }\n        @Override //\n        public void close() throws IOException {\n            writeHeaders();\n            super.close();\n        }\n    }\n"]]}
{"hexsha": "94049e169d9faa662dadee598b08f54cfa434623", "ext": "java", "lang": "Java", "content": "public class FilesTest {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\t// \u83b7\u53d6\u5de5\u4f5c\u76ee\u5f55\r\n\t\tString workDir = System.getProperty(\"user.dir\");\r\n\t\t// \u83b7\u53d6\u7c7b\u540d\r\n\t\tString className = Thread.currentThread().getStackTrace()[1]\r\n\t\t\t\t.getClassName();\r\n\t\t// \u7c7b\u7684\u8def\u5f84\r\n\t\tString classPath = workDir + \"\\\\src\\\\main\\\\java\\\\\" + className;\r\n\t\t// \u53cd\u659c\u6760\u66ff\u6362\u6389\".\"\r\n\t\tString currentClass = classPath.replace(\".\", \"\\\\\") + \".java\";\r\n\r\n\t\t// \u590d\u5236\u6587\u4ef6\uff0c\u628acurrentClass\u5185\u5bb9\u590d\u5236\u5230files.txt\r\n\t\tFiles.copy(Paths.get(currentClass), new FileOutputStream(\r\n\t\t\t\t\"testFile\\\\files.txt\"));\r\n\t\t// \u5224\u8bfbFilesTest.java\u662f\u5426\u4e3a\u9690\u85cf\u6587\u4ef6\r\n\t\tSystem.out.println(Files.isHidden(Paths.get(currentClass)));\r\n\t\t// \u4e00\u6b21\u6027\u8bfb\u53d6FilesTest.java\u6587\u4ef6\u7684\u6240\u6709\u884c\r\n\t\tList<String> lines = Files.readAllLines(Paths.get(currentClass),\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\tSystem.out.println(lines);\r\n\t\t// \u83b7\u53d6\u6307\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\r\n\t\tSystem.out.println(\"FilesTest.java\u6587\u4ef6\u5927\u5c0f\uff1a\"\r\n\t\t\t\t+ Files.size(Paths.get(currentClass)));\r\n\t\tList<String> poem = new ArrayList<String>();\r\n\t\tpoem.add(\"\u5e74\u5e74\u5fc6\u4eca\u671d\");\r\n\t\tpoem.add(\"\u832b\u832b\u8d76\u56fd\u8003\");\r\n\t\t// \u5c06\u591a\u4e2a\u5b57\u7b26\u4e32\u5185\u5bb9\u5199\u5165\u6307\u5b9a\u6587\u4ef6files.txt\u4e2d\r\n\t\tFiles.write(Paths.get(\"testFile\\\\files.txt\"), poem,\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\t// \u5224\u65adC\u76d8\u7684\u603b\u7a7a\u95f4\u548c\u53ef\u7528\u7a7a\u95f4\r\n\t\tFileStore cStore = Files.getFileStore(Paths.get(currentClass));\r\n\t\tSystem.out.println(\"C\u76d8\u5171\u6709\u7a7a\u95f4\uff1a\" + cStore.getTotalSpace());\r\n\t\tSystem.out.println(\"C\u76d8\u7684\u53ef\u7528\u7a7a\u95f4\uff1a\" + cStore.getUsableSpace());\r\n\t}\r\n}", "class_id": 0, "repo": "longjiazuo/j2se-project", "file": "j2se-project/java-nio/src/main/java/org/light4j/nio/nio2/FilesTest.java", "last_update_at": "2021-03-01T09:19:06+00:00", "question_id": "94049e169d9faa662dadee598b08f54cfa434623", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FilesTest {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\t// \u83b7\u53d6\u5de5\u4f5c\u76ee\u5f55\r\n\t\tString workDir = System.getProperty(\"user.dir\");\r\n\t\t// \u83b7\u53d6\u7c7b\u540d\r\n\t\tString className = Thread.currentThread().getStackTrace()[1]\r\n\t\t\t\t.getClassName();\r\n\t\t// \u7c7b\u7684\u8def\u5f84\r\n\t\tString classPath = workDir + \"\\\\src\\\\main\\\\java\\\\\" + className;\r\n\t\t// \u53cd\u659c\u6760\u66ff\u6362\u6389\".\"\r\n\t\tString currentClass = classPath.replace(\".\", \"\\\\\") + \".java\";\r\n\r\n\t\t// \u590d\u5236\u6587\u4ef6\uff0c\u628acurrentClass\u5185\u5bb9\u590d\u5236\u5230files.txt\r\n\t\tFiles.copy(Paths.get(currentClass), new FileOutputStream(\r\n\t\t\t\t\"testFile\\\\files.txt\"));\r\n\t\t// \u5224\u8bfbFilesTest.java\u662f\u5426\u4e3a\u9690\u85cf\u6587\u4ef6\r\n\t\tSystem.out.println(Files.isHidden(Paths.get(currentClass)));\r\n\t\t// \u4e00\u6b21\u6027\u8bfb\u53d6FilesTest.java\u6587\u4ef6\u7684\u6240\u6709\u884c\r\n\t\tList<String> lines = Files.readAllLines(Paths.get(currentClass),\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\tSystem.out.println(lines);\r\n\t\t// \u83b7\u53d6\u6307\u5b9a\u6587\u4ef6\u7684\u5927\u5c0f\r\n\t\tSystem.out.println(\"FilesTest.java\u6587\u4ef6\u5927\u5c0f\uff1a\"\r\n\t\t\t\t+ Files.size(Paths.get(currentClass)));\r\n\t\tList<String> poem = new ArrayList<String>();\r\n\t\tpoem.add(\"\u5e74\u5e74\u5fc6\u4eca\u671d\");\r\n\t\tpoem.add(\"\u832b\u832b\u8d76\u56fd\u8003\");\r\n\t\t// \u5c06\u591a\u4e2a\u5b57\u7b26\u4e32\u5185\u5bb9\u5199\u5165\u6307\u5b9a\u6587\u4ef6files.txt\u4e2d\r\n\t\tFiles.write(Paths.get(\"testFile\\\\files.txt\"), poem,\r\n\t\t\t\tCharset.forName(\"UTF-8\"));\r\n\t\t// \u5224\u65adC\u76d8\u7684\u603b\u7a7a\u95f4\u548c\u53ef\u7528\u7a7a\u95f4\r\n\t\tFileStore cStore = Files.getFileStore(Paths.get(currentClass));\r\n\t\tSystem.out.println(\"C\u76d8\u5171\u6709\u7a7a\u95f4\uff1a\" + cStore.getTotalSpace());\r\n\t\tSystem.out.println(\"C\u76d8\u7684\u53ef\u7528\u7a7a\u95f4\uff1a\" + cStore.getUsableSpace());\r\n\t}\r\n"]]}
{"hexsha": "d435c5d4df7f64a11710b7026aabff7141738bd6", "ext": "java", "lang": "Java", "content": "public class Check implements Report {\n    public static Boolean check() {\n        File epubFile = new File(\"D:\\\\play\\\\epub\\\\public\\\\epub\\\\epub3.0\\\\q.epub\");\n\n        // simple constructor; errors are printed on stderr stream\n        EpubCheck epubcheck = new EpubCheck(epubFile);\n\n        // validate() returns true if no errors or warnings are found\n        Boolean result = epubcheck.validate();\n        return result;\n    }\n\n    @Override\n    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {\n\n    }\n\n    @Override\n    public void message(Message message, EPUBLocation epubLocation, Object... objects) {\n\n    }\n\n    @Override\n    public void info(String s, FeatureEnum featureEnum, String s2) {\n\n    }\n\n    @Override\n    public int getErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int getWarningCount() {\n        return 0;\n    }\n\n    @Override\n    public int getFatalErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int generate() {\n        return 0;\n    }\n\n    @Override\n    public void initialize() {\n\n    }\n\n    @Override\n    public void setEpubFileName(String s) {\n\n    }\n\n    @Override\n    public String getEpubFileName() {\n        return null;\n    }\n\n    @Override\n    public void setCustomMessageFile(String s) {\n\n    }\n\n    @Override\n    public String getCustomMessageFile() {\n        return null;\n    }\n\n    @Override\n    public int getReportingLevel() {\n        return 0;\n    }\n\n    @Override\n    public void setReportingLevel(int i) {\n\n    }\n\n    @Override\n    public void close() {\n\n    }\n\n    @Override\n    public void setOverrideFile(File file) {\n\n    }\n\n    @Override\n    public MessageDictionary getDictionary() {\n        return null;\n    }\n}", "class_id": 0, "repo": "seaalan/epub", "file": "app/controllers/EPUBCheck/Check.java", "last_update_at": "2021-05-08T11:24:20+00:00", "question_id": "d435c5d4df7f64a11710b7026aabff7141738bd6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Check implements Report {\n    public static Boolean check() {\n        File epubFile = new File(\"D:\\\\play\\\\epub\\\\public\\\\epub\\\\epub3.0\\\\q.epub\");\n        // simple constructor; errors are printed on stderr stream\n        EpubCheck epubcheck = new EpubCheck(epubFile);\n        // validate() returns true if no errors or warnings are found\n        Boolean result = epubcheck.validate();\n        return result;\n    }\n    @Override\n    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {\n    }\n    @Override\n    public void message(Message message, EPUBLocation epubLocation, Object... objects) {\n    }\n    @Override\n    public void info(String s, FeatureEnum featureEnum, String s2) {\n    }\n    @Override\n    public int getErrorCount() {\n        return 0;\n    }\n    @Override\n    public int getWarningCount() {\n        return 0;\n    }\n    @Override\n    public int getFatalErrorCount() {\n        return 0;\n    }\n    @Override\n    public int generate() {\n        return 0;\n    }\n    @Override\n    public void initialize() {\n    }\n    @Override\n    public void setEpubFileName(String s) {\n    }\n    @Override\n    public String getEpubFileName() {\n        return null;\n    }\n    @Override\n    public void setCustomMessageFile(String s) {\n    }\n    @Override\n    public String getCustomMessageFile() {\n        return null;\n    }\n    @Override\n    public int getReportingLevel() {\n        return 0;\n    }\n    @Override\n    public void setReportingLevel(int i) {\n    }\n    @Override\n    public void close() {\n    }\n    @Override\n    public void setOverrideFile(File file) {\n    }\n    @Override\n    public MessageDictionary getDictionary() {\n        return null;\n    }\n"]]}
{"hexsha": "d4b842cf649bd0cd1ede7fa0da8285f1b5d69bd0", "ext": "java", "lang": "Java", "content": "public final class SeaSlater64RNG implements RandomnessSource, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private long stateA, stateB;\n\n    /**\n     * Creates a new generator seeded using two calls to Math.random().\n     */\n    public SeaSlater64RNG() {\n        setState((long) ((Math.random() - 0.5) * 0x10000000000000L)\n                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),\n                (long) ((Math.random() - 0.5) * 0x10000000000000L)\n                        ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));\n    }\n    /**\n     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for\n     * the two parts of state this has with {@link #setSeed(long)}.\n     * @param seed a long that will be used to generate both components of state\n     */\n    public SeaSlater64RNG(final long seed) {\n        setSeed(seed);\n    }\n    /**\n     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that\n     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).\n     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0\n     * @param stateB the number to use as the second part of the state\n     */\n    public SeaSlater64RNG(final long stateA, final long stateB) {\n        setState(stateA, stateB);\n    }\n    \n    @Override\n    public final int next(int bits) {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));\n    }\n\n    /**\n     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.\n     * @return any int, all 32 bits are random\n     */\n    public final int nextInt() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);\n    }\n\n    @Override\n    public final long nextLong() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (result << 12) - (result << 9 | result >>> 55);\n    }\n\n    /**\n     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the\n     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to\n     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.\n     *\n     * @return a copy of this RandomnessSource\n     */\n    @Override\n    public SeaSlater64RNG copy() {\n        return new SeaSlater64RNG(stateA, stateB);\n    }\n\n    /**\n     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get \n     * two longs. If the states would both be 0, state A is assigned 1 instead.\n     * @param seed the long to use to produce this generator's state\n     */\n    public void setSeed(final long seed) {\n        long z = seed;\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateA = z ^ (z >>> 31);\n        z = (seed + 0x9E3779B97F4A7C15L);\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateB = z ^ (z >>> 31);\n        // not possible with SplitMix64\n//        if((stateA | stateB) == 0)\n//            stateA = 1;\n    }\n\n    public long getStateA()\n    {\n        return stateA;\n    }\n    /**\n     * Sets the first part of the state to the given int. As a special case, if the parameter is 0 and stateB is\n     * already 0, this will set stateA to 1 instead, since both states cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateA any int\n     */\n\n    public void setStateA(long stateA)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n    }\n    public long getStateB()\n    {\n        return stateB;\n    }\n\n    /**\n     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is\n     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateB any int\n     */\n    public void setStateB(long stateB)\n    {\n        this.stateB = stateB;\n        if((stateB | stateA) == 0) stateA = 1;\n    }\n\n    /**\n     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any\n     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).\n     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)\n     * @param stateB any int\n     */\n    public void setState(long stateA, long stateB)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n        this.stateB = stateB;\n    }\n    \n    @Override\n    public String toString() {\n        return \"SeaSlater32RNG with stateA 0x\" + StringKit.hex(stateA) + \"L and stateB 0x\" + StringKit.hex(stateB) + 'L';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;\n\n        if (stateA != seaSlater64RNG.stateA) return false;\n        return stateB == seaSlater64RNG.stateB;\n    }\n\n    @Override\n    public int hashCode() {\n        final long h = (31L * stateA + stateB);\n        return (int)(h ^ h >>> 32);\n    }\n}", "class_id": 0, "repo": "Solido/sarong", "file": "src/main/java/sarong/SeaSlater64RNG.java", "last_update_at": "2021-07-24T14:10:33+00:00", "question_id": "d4b842cf649bd0cd1ede7fa0da8285f1b5d69bd0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SeaSlater64RNG implements RandomnessSource, Serializable {\n    private static final long serialVersionUID = 1L;\n    private long stateA, stateB;\n    /**\n     * Creates a new generator seeded using two calls to Math.random().\n     */\n    public SeaSlater64RNG() {\n        setState((long) ((Math.random() - 0.5) * 0x10000000000000L)\n                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),\n                (long) ((Math.random() - 0.5) * 0x10000000000000L)\n                        ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));\n    }\n    /**\n     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for\n     * the two parts of state this has with {@link #setSeed(long)}.\n     * @param seed a long that will be used to generate both components of state\n     */\n    public SeaSlater64RNG(final long seed) {\n        setSeed(seed);\n    }\n    /**\n     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that\n     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).\n     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0\n     * @param stateB the number to use as the second part of the state\n     */\n    public SeaSlater64RNG(final long stateA, final long stateB) {\n        setState(stateA, stateB);\n    }\n    @Override\n    public final int next(int bits) {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));\n    }\n    /**\n     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.\n     * @return any int, all 32 bits are random\n     */\n    public final int nextInt() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);\n    }\n    @Override\n    public final long nextLong() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (result << 12) - (result << 9 | result >>> 55);\n    }\n    /**\n     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the\n     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to\n     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.\n     *\n     * @return a copy of this RandomnessSource\n     */\n    @Override\n    public SeaSlater64RNG copy() {\n        return new SeaSlater64RNG(stateA, stateB);\n    }\n    /**\n     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get \n     * two longs. If the states would both be 0, state A is assigned 1 instead.\n     * @param seed the long to use to produce this generator's state\n     */\n    public void setSeed(final long seed) {\n        long z = seed;\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateA = z ^ (z >>> 31);\n        z = (seed + 0x9E3779B97F4A7C15L);\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateB = z ^ (z >>> 31);\n        // not possible with SplitMix64\n//        if((stateA | stateB) == 0)\n//            stateA = 1;\n    }\n    public long getStateA()\n    {\n        return stateA;\n    }\n    /**\n     * Sets the first part of the state to the given int. As a special case, if the parameter is 0 and stateB is\n     * already 0, this will set stateA to 1 instead, since both states cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateA any int\n     */\n    public void setStateA(long stateA)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n    }\n    public long getStateB()\n    {\n        return stateB;\n    }\n    /**\n     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is\n     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateB any int\n     */\n    public void setStateB(long stateB)\n    {\n        this.stateB = stateB;\n        if((stateB | stateA) == 0) stateA = 1;\n    }\n    /**\n     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any\n     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).\n     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)\n     * @param stateB any int\n     */\n    public void setState(long stateA, long stateB)\n    {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n        this.stateB = stateB;\n    }\n    @Override\n    public String toString() {\n        return \"SeaSlater32RNG with stateA 0x\" + StringKit.hex(stateA) + \"L and stateB 0x\" + StringKit.hex(stateB) + 'L';\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;\n        if (stateA != seaSlater64RNG.stateA) return false;\n        return stateB == seaSlater64RNG.stateB;\n    }\n    @Override\n    public int hashCode() {\n        final long h = (31L * stateA + stateB);\n        return (int)(h ^ h >>> 32);\n    }\n"]]}
{"hexsha": "4f01c8a8bfaf6520ab50b8203cdbd576b2539387", "ext": "java", "lang": "Java", "content": "@TypeCapability(inputs = { \"de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS\" })\npublic class POSTokenRatio\nextends FeatureExtractorResource_ImplBase\nimplements FeatureExtractor\n{\n\tpublic static final String FN_NounRatio = \"NounRatio\";\n\tpublic static final String FN_VerbRatio = \"VerbRatio\";\n\tpublic static final String FN_AdjectivRatio = \"AdjectivRatio\";\n\t\n\n\t@Override\n\tpublic Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget)\n\t\t\tthrows TextClassificationException\n\t{\n\t\t\n\t\tint numberOfTokens = JCasUtil.select(jcas, POS.class).size();\n\t\t\n\t\t//Nouns, Verbs\n\t\tint numberOfNouns = 0;\n\t\tint numberOfVerbs = 0;\n\t\tint numberOfAdjectives = 0;\n\t\t\n\t\tfor (POS pos : JCasUtil.select(jcas, POS.class)) {\n\t\t\tSystem.out.println(pos.getCoarseValue());\n\t\t\tif (pos.getCoarseValue().startsWith(\"N\")){\n\t\t\t\tnumberOfNouns++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"VERB\")){\n\t\t\t\tnumberOfVerbs++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"ADJ\")){\n\t\t\t\tnumberOfAdjectives++;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tdouble nr = (1.0*numberOfNouns)/numberOfTokens;\n\t\tdouble vr = (1.0*numberOfVerbs)/numberOfTokens;\n\t\tdouble ar = (1.0*numberOfAdjectives)/numberOfTokens;\n\n\t\t\n\t\tSet<Feature> features = new HashSet<Feature>();\n\t\tfeatures.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));\n\t\treturn features;\n\t}\n\n}", "class_id": 0, "repo": "ltl-ude/escrito", "file": "de.unidue.ltl.escrito/de.unidue.ltl.escrito.features/src/main/java/de/unidue/ltl/escrito/features/complexity/POSTokenRatio.java", "last_update_at": "2021-04-17T16:57:54+00:00", "question_id": "4f01c8a8bfaf6520ab50b8203cdbd576b2539387", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TypeCapability(inputs = { \"de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS\" })\npublic class POSTokenRatio\nextends FeatureExtractorResource_ImplBase\nimplements FeatureExtractor\n{\n\tpublic static final String FN_NounRatio = \"NounRatio\";\n\tpublic static final String FN_VerbRatio = \"VerbRatio\";\n\tpublic static final String FN_AdjectivRatio = \"AdjectivRatio\";\n\t\n\t@Override\n\tpublic Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget)\n\t\t\tthrows TextClassificationException\n\t{\n\t\t\n\t\tint numberOfTokens = JCasUtil.select(jcas, POS.class).size();\n\t\t\n\t\t//Nouns, Verbs\n\t\tint numberOfNouns = 0;\n\t\tint numberOfVerbs = 0;\n\t\tint numberOfAdjectives = 0;\n\t\t\n\t\tfor (POS pos : JCasUtil.select(jcas, POS.class)) {\n\t\t\tSystem.out.println(pos.getCoarseValue());\n\t\t\tif (pos.getCoarseValue().startsWith(\"N\")){\n\t\t\t\tnumberOfNouns++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"VERB\")){\n\t\t\t\tnumberOfVerbs++;\n\t\t\t}\n\t\t\tif (pos.getCoarseValue().equals(\"ADJ\")){\n\t\t\t\tnumberOfAdjectives++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble nr = (1.0*numberOfNouns)/numberOfTokens;\n\t\tdouble vr = (1.0*numberOfVerbs)/numberOfTokens;\n\t\tdouble ar = (1.0*numberOfAdjectives)/numberOfTokens;\n\t\t\n\t\tSet<Feature> features = new HashSet<Feature>();\n\t\tfeatures.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));\n\t\tfeatures.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));\n\t\treturn features;\n\t}\n"]]}
{"hexsha": "0b6a14048aa7baf6a73dc2a1cc1f8a4284ce3354", "ext": "java", "lang": "Java", "content": "@TestPropertySource(\"classpath:testFm.properties\")\npublic class DgFmTest extends AbstractWebTest {\n\n    @Autowired\n    private DgFmService fmService;\n\n    @Test\n    public void testFmInit() {\n        assertTrue(\"Must have at least one feature\", fmService.featuresCount() > 0);\n    }\n\n    @Test\n    public void testBasics() {\n        assertThatFeature(\"defaults\", allOf(visible(), enabled(), not(mandatory())));\n        assertThatFeature(\"allEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"allDisabled\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"reverseDefaults\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testMixins() {\n        assertThatFeature(\"allDisabledMixin\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"mandatoryWithAllDisabledMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mandatoryWithAllDisabledChainedMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mixingInAllEnabled\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testVisibleDeps() {\n        assertThatFeature(\"visibleDepsAllDisabled\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllDisabledChained\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllEnabled\", allOf(not(visible()), enabled(), not(mandatory())));\n    }\n\n    @Test\n    public void testMandatoryDeps() {\n        assertThatFeature(\"mandatoryDepsAllDisabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabledChained\", allOf(visible(), enabled(), mandatory()));\n    }\n\n    @Test\n    public void testEnabledDeps() {\n        assertThatFeature(\"enabledDepsAllDisabled\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllDisabledChained\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllEnabled\", allOf(visible(), not(enabled()), not(mandatory())));\n    }\n\n    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {\n        assertThat(fmService.getFeature(featureName), matcher);\n    }\n\n    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {\n        assertEquals(fmService.isFeatureVisible(featureName), visible);\n        assertEquals(fmService.isFeatureEnabled(featureName), enabled);\n        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);\n    }\n\n    private Matcher<DgFeature> visible() {\n        return describedAs(\"visible\", hasProperty(\"visible\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> mandatory() {\n        return describedAs(\"mandatory\", hasProperty(\"mandatory\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> enabled() {\n        return describedAs(\"enabled\", hasProperty(\"enabled\", equalTo(true)));\n    }\n}", "class_id": 0, "repo": "devgateway/ocportal", "file": "web/src/test/java/org/devgateway/toolkit/web/fm/DgFmTest.java", "last_update_at": "2021-11-06T19:24:23+00:00", "question_id": "0b6a14048aa7baf6a73dc2a1cc1f8a4284ce3354", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TestPropertySource(\"classpath:testFm.properties\")\npublic class DgFmTest extends AbstractWebTest {\n    @Autowired\n    private DgFmService fmService;\n    @Test\n    public void testFmInit() {\n        assertTrue(\"Must have at least one feature\", fmService.featuresCount() > 0);\n    }\n    @Test\n    public void testBasics() {\n        assertThatFeature(\"defaults\", allOf(visible(), enabled(), not(mandatory())));\n        assertThatFeature(\"allEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"allDisabled\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"reverseDefaults\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n    @Test\n    public void testMixins() {\n        assertThatFeature(\"allDisabledMixin\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"mandatoryWithAllDisabledMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mandatoryWithAllDisabledChainedMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mixingInAllEnabled\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n    @Test\n    public void testVisibleDeps() {\n        assertThatFeature(\"visibleDepsAllDisabled\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllDisabledChained\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllEnabled\", allOf(not(visible()), enabled(), not(mandatory())));\n    }\n    @Test\n    public void testMandatoryDeps() {\n        assertThatFeature(\"mandatoryDepsAllDisabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabledChained\", allOf(visible(), enabled(), mandatory()));\n    }\n    @Test\n    public void testEnabledDeps() {\n        assertThatFeature(\"enabledDepsAllDisabled\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllDisabledChained\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllEnabled\", allOf(visible(), not(enabled()), not(mandatory())));\n    }\n    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {\n        assertThat(fmService.getFeature(featureName), matcher);\n    }\n    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {\n        assertEquals(fmService.isFeatureVisible(featureName), visible);\n        assertEquals(fmService.isFeatureEnabled(featureName), enabled);\n        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);\n    }\n    private Matcher<DgFeature> visible() {\n        return describedAs(\"visible\", hasProperty(\"visible\", equalTo(true)));\n    }\n    private Matcher<DgFeature> mandatory() {\n        return describedAs(\"mandatory\", hasProperty(\"mandatory\", equalTo(true)));\n    }\n    private Matcher<DgFeature> enabled() {\n        return describedAs(\"enabled\", hasProperty(\"enabled\", equalTo(true)));\n    }\n"]]}
{"hexsha": "65080318e0435ec7c0c7d4789c2b76ffc5799d38", "ext": "java", "lang": "Java", "content": "public class CSSRule {\n    private Set<String> selectors;\n    private Map<String, String> properties;\n\n    public CSSRule() {\n        this.selectors = new HashSet<>();\n        this.properties = new HashMap<>();\n    }\n\n    public CSSRule(Set<String> selectors, Map<String, String> properties) {\n        this.selectors = selectors;\n        this.properties = properties;\n    }\n\n    public static List<CSSRule> fromString(String text) {\n        List<CSSRule> rep = new ArrayList<>();\n\n        text = text.replaceAll(\"\\\\s+\", \"\");\n\n        String[] declarations = text.split(\"}\");\n\n        for (String declaration : declarations) {\n            Set<String> selectors = new HashSet<>();\n            Map<String, String> properties = new HashMap<>();\n            CSSRule current = new CSSRule(selectors, properties);\n\n            String[] strings = declaration.split(\"\\\\{\");\n            \n            if(strings.length < 2) {\n                continue;\n            }\n\n            String[] selectorsStr = strings[0].split(\",\");\n            String[] propertiesStr = strings[1].split(\";\");\n\n            selectors.addAll(Arrays.asList(selectorsStr));\n\n            for (String property : propertiesStr) {\n                String[] parts = property.split(\":\");\n                properties.put(parts[0], parts[1]);\n            }\n\n            rep.add(current);\n        }\n        return rep;\n    }\n\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    public boolean hasStyle(String style) {\n        return hasProperty(style);\n    }\n\n    public String getPropertyValue(String name) {\n        return properties.get(name);\n    }\n\n    public void setProperty(String name, String value) {\n        properties.put(name, value);\n    }\n\n    public Set<String> getSelectors() {\n        return selectors;\n    }\n\n    public void addSelector(String selector) {\n        this.selectors.add(selector);\n    }\n\n    public boolean hasSelector(String selector) {\n        return selectors.contains(selector);\n    }\n\n    public boolean hasClass(String clazz) {\n        return selectors.contains(\".\" + clazz);\n    }\n\n    public String toString(int indent) {\n        StringBuilder rep = new StringBuilder();\n        rep.append(spaces(indent)).append(String.join(\", \", selectors)).append(\" {\").append(\"\\n\");\n        for (Map.Entry<String, String> entry : properties.entrySet()) {\n            rep.append(spaces(indent + 2)).append(entry.getKey()).append(\": \").append(entry.getValue()).append(\";\\n\");\n        }\n        rep.append(spaces(indent)).append(\"}\\n\");\n        return rep.toString();\n    }\n\n    @Override\n    public String toString() {\n        return toString(0);\n    }\n\n    @Override\n    public CSSRule clone() {\n        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));\n    }\n}", "class_id": 0, "repo": "Feavy/Fea-XML-CSS-Parser", "file": "src/main/java/fr/feavy/xml/CSSRule.java", "last_update_at": "2021-04-20T20:07:40+00:00", "question_id": "65080318e0435ec7c0c7d4789c2b76ffc5799d38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CSSRule {\n    private Set<String> selectors;\n    private Map<String, String> properties;\n    public CSSRule() {\n        this.selectors = new HashSet<>();\n        this.properties = new HashMap<>();\n    }\n    public CSSRule(Set<String> selectors, Map<String, String> properties) {\n        this.selectors = selectors;\n        this.properties = properties;\n    }\n    public static List<CSSRule> fromString(String text) {\n        List<CSSRule> rep = new ArrayList<>();\n        text = text.replaceAll(\"\\\\s+\", \"\");\n        String[] declarations = text.split(\"}\");\n        for (String declaration : declarations) {\n            Set<String> selectors = new HashSet<>();\n            Map<String, String> properties = new HashMap<>();\n            CSSRule current = new CSSRule(selectors, properties);\n            String[] strings = declaration.split(\"\\\\{\");\n            if(strings.length < 2) {\n                continue;\n            }\n            String[] selectorsStr = strings[0].split(\",\");\n            String[] propertiesStr = strings[1].split(\";\");\n            selectors.addAll(Arrays.asList(selectorsStr));\n            for (String property : propertiesStr) {\n                String[] parts = property.split(\":\");\n                properties.put(parts[0], parts[1]);\n            }\n            rep.add(current);\n        }\n        return rep;\n    }\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n    public boolean hasStyle(String style) {\n        return hasProperty(style);\n    }\n    public String getPropertyValue(String name) {\n        return properties.get(name);\n    }\n    public void setProperty(String name, String value) {\n        properties.put(name, value);\n    }\n    public Set<String> getSelectors() {\n        return selectors;\n    }\n    public void addSelector(String selector) {\n        this.selectors.add(selector);\n    }\n    public boolean hasSelector(String selector) {\n        return selectors.contains(selector);\n    }\n    public boolean hasClass(String clazz) {\n        return selectors.contains(\".\" + clazz);\n    }\n    public String toString(int indent) {\n        StringBuilder rep = new StringBuilder();\n        rep.append(spaces(indent)).append(String.join(\", \", selectors)).append(\" {\").append(\"\\n\");\n        for (Map.Entry<String, String> entry : properties.entrySet()) {\n            rep.append(spaces(indent + 2)).append(entry.getKey()).append(\": \").append(entry.getValue()).append(\";\\n\");\n        }\n        rep.append(spaces(indent)).append(\"}\\n\");\n        return rep.toString();\n    }\n    @Override\n    public String toString() {\n        return toString(0);\n    }\n    @Override\n    public CSSRule clone() {\n        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));\n    }\n"]]}
{"hexsha": "60326de5da5cf57c599ba2b10b06462f073332a3", "ext": "java", "lang": "Java", "content": "public class APIResponse {\n    private String responseMessage;\n    private int responseCode;\n    private String body;\n\n    APIResponse(int responseCode, String responseMessage, String body) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.body = body;\n    }\n\n    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {\n        final int responseCode = conn.getResponseCode();\n        final String responseMessage = conn.getResponseMessage();\n\n        String body;\n\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            body = read(conn.getInputStream());\n        } else {\n            body = read(conn.getErrorStream());\n        }\n\n        return new APIResponse(responseCode, responseMessage, body);\n    }\n\n    public String getResponseMessage() {\n        return responseMessage;\n    }\n\n    public int getResponseCode() {\n        return responseCode;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public boolean isOK() {\n        return responseCode == HttpURLConnection.HTTP_OK;\n    }\n\n    public boolean isNotFound() {\n        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;\n    }\n\n    public boolean isError() {\n        return !isOK();\n    }\n\n    /**\n     * Read an input stream to a String.\n     *\n     * @param is The input stream.\n     * @return The data from the input stream as a String.\n     */\n    private static String read(InputStream is) {\n        if (is == null){\n            return \"\";\n        }\n        Scanner scanner = new Scanner(is);\n\n        StringBuilder sb = new StringBuilder();\n\n        while (scanner.hasNextLine()) {\n            sb.append(scanner.nextLine());\n        }\n\n        return sb.toString();\n    }\n\n}", "class_id": 0, "repo": "dalelane/ML4K-AI-Extension", "file": "src/com/kylecorry/ml4k/APIResponse.java", "last_update_at": "2021-12-05T13:30:19+00:00", "question_id": "60326de5da5cf57c599ba2b10b06462f073332a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class APIResponse {\n    private String responseMessage;\n    private int responseCode;\n    private String body;\n    APIResponse(int responseCode, String responseMessage, String body) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.body = body;\n    }\n    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {\n        final int responseCode = conn.getResponseCode();\n        final String responseMessage = conn.getResponseMessage();\n        String body;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            body = read(conn.getInputStream());\n        } else {\n            body = read(conn.getErrorStream());\n        }\n        return new APIResponse(responseCode, responseMessage, body);\n    }\n    public String getResponseMessage() {\n        return responseMessage;\n    }\n    public int getResponseCode() {\n        return responseCode;\n    }\n    public String getBody() {\n        return body;\n    }\n    public boolean isOK() {\n        return responseCode == HttpURLConnection.HTTP_OK;\n    }\n    public boolean isNotFound() {\n        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;\n    }\n    public boolean isError() {\n        return !isOK();\n    }\n    /**\n     * Read an input stream to a String.\n     *\n     * @param is The input stream.\n     * @return The data from the input stream as a String.\n     */\n    private static String read(InputStream is) {\n        if (is == null){\n            return \"\";\n        }\n        Scanner scanner = new Scanner(is);\n        StringBuilder sb = new StringBuilder();\n        while (scanner.hasNextLine()) {\n            sb.append(scanner.nextLine());\n        }\n        return sb.toString();\n    }\n"]]}
{"hexsha": "c100f09e24353bbe744b998aaca1669e27678b45", "ext": "java", "lang": "Java", "content": "public class exercicio5 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.print(\"Ol\u00e1! Por favor informe qual o valor do seu sal\u00e1rio: R$ \");\n        Double salario = scanner.nextDouble();\n\n        final Double salarioMinimo = 788.0;\n\n        Double quantidadeSalariosMinimos = salario/salarioMinimo;\n\n       /* System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + Math.round(quantidadeSalariosMinimos)); ESSE FORMATO IR\u00c1 ARREDONDAR O VALOR. */\n        \n        DecimalFormat df = new DecimalFormat(\"##.##\");\n\n        System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + df.format(quantidadeSalariosMinimos));\n\n        scanner.close();\n    }\n}", "class_id": 0, "repo": "jpshimidt/Estudojava", "file": "ListaExercicios/ListaExercicios/src/exercicio5.java", "last_update_at": "2021-04-03T04:11:55+00:00", "question_id": "c100f09e24353bbe744b998aaca1669e27678b45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class exercicio5 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Ol\u00e1! Por favor informe qual o valor do seu sal\u00e1rio: R$ \");\n        Double salario = scanner.nextDouble();\n        final Double salarioMinimo = 788.0;\n        Double quantidadeSalariosMinimos = salario/salarioMinimo;\n       /* System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + Math.round(quantidadeSalariosMinimos)); ESSE FORMATO IR\u00c1 ARREDONDAR O VALOR. */\n        DecimalFormat df = new DecimalFormat(\"##.##\");\n        System.out.println(\"A quantidade de sal\u00e1rios m\u00ednimos \u00e9: \" + df.format(quantidadeSalariosMinimos));\n        scanner.close();\n    }\n"]]}
{"hexsha": "225847a731ab9bc895536af2abea87cf195f916c", "ext": "java", "lang": "Java", "content": "@DynamicSerialize\npublic class FFMPBasinData {\n\n    public static final double GUIDANCE_MISSING = -999999.0;\n\n    // defaults\n    @DynamicSerializeElement\n    private String hucLevel;\n\n    @DynamicSerializeElement\n    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();\n\n    /**\n     * Pending load tasks that need to be run to fully populate basins\n     */\n    private final List<LoadTask> tasks = new ArrayList<LoadTask>();\n\n    /**\n     * Cache of basins in order for easy population from Load Tasks.\n     */\n    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();\n\n    /**\n     * Shared factory for efficient storage of data in basins.\n     */\n    private BasinMapFactory<Date> mapFactory = null;\n\n    /**\n     * Public one arg constructor\n     * \n     * @param huc_level\n     */\n    public FFMPBasinData(String hucLevel) {\n        setHucLevel(hucLevel);\n    }\n\n    /**\n     * No arg hibernate constructor\n     */\n    public FFMPBasinData() {\n\n    }\n\n    /**\n     * get the basin map\n     * \n     * @return\n     */\n    public Map<Long, FFMPBasin> getBasins() {\n        if (!tasks.isEmpty()) {\n            loadNow();\n        }\n        return basins;\n    }\n\n    /**\n     * Sets the basin map\n     * \n     * @param basins\n     */\n    public void setBasins(Map<Long, FFMPBasin> basins) {\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n        this.basins = basins;\n    }\n\n    /**\n     * Gets the HUC Level for this map\n     * \n     * @return\n     */\n    public String getHucLevel() {\n        return hucLevel;\n    }\n\n    /**\n     * Sets the HUC Level for this map\n     */\n    public void setHucLevel(String hucLevel) {\n        this.hucLevel = hucLevel;\n    }\n\n    /**\n     * Add to the hash\n     * \n     * @param key\n     * @param basin\n     */\n    public void put(Long key, FFMPBasin basin) {\n        getBasins().put(key, basin);\n    }\n\n    /**\n     * Gets the FFMPBasin from the hash\n     * \n     * @param key\n     * @return\n     */\n    public FFMPBasin get(Long key) {\n        return getBasins().get(key);\n    }\n\n    /**\n     * Gets a list of pfaf ids from the keys\n     * \n     * @return\n     */\n    public List<Long> getPfafIds() {\n        return new ArrayList<Long>(getBasins().keySet());\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param startDate\n     * @param finishDate\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(beforeDate, afterDate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param exact\n     *            date\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(date);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expirationTime\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date,\n            long epirationTime) {\n\n        float tvalue = 0.0f;\n        int i = 0;\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = getBasins().get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAverageValue(date, epirationTime);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins with areal\n     * weighting\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids,\n            ArrayList<Double> areas) {\n\n        float tvalue = 0.0f;\n        float tarea = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                if (basin.getValue() != FFMPUtils.MISSING) {\n                    tvalue += (basin.getValue() * areas.get(i));\n                    tarea += areas.get(i);\n                }\n            }\n        }\n\n        if (tvalue < 0.0f) {\n            tvalue = FFMPUtils.MISSING;\n        } else {\n            tvalue = tvalue / tarea;\n        }\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins to a given time\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a range of times in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(beforeDate, afterDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(List<Long> pfaf_ids, Date date,\n            long expiration) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(date, expiration);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate,\n            Date beforeDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(afterDate, beforeDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a specific time in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(List<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(date);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Average Guidance\n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, float guidance,\n            List<Long> forcedPfafs, long expiration) {\n        float tvalue = 0.0f;\n        float value;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n\n            if (basin == null) {\n                return guidance;\n            }\n\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (forcedPfafs.contains(pfaf)) {\n                    if (interpolation.isInterpolate()) {\n                        value = fgb.getInterpolatedValue(interpolation,\n                                expiration);\n                    } else {\n                        value = fgb.getValue(interpolation.getStandardSource(),\n                                interpolation, expiration);\n                    }\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    tvalue += value;\n                    i++;\n                } else {\n                    if (interpolation.isInterpolate()) {\n                        float nvalue;\n                        if (new Float(guidance).isNaN()) {\n                            nvalue = fgb.getInterpolatedValue(interpolation,\n                                    expiration);\n                        } else {\n                            nvalue = guidance;\n                        }\n\n                        if (nvalue > 0.0f) {\n                            tvalue += nvalue;\n                        }\n                        i++;\n                    } else {\n                        if (new Float(guidance).isNaN()) {\n                            value = fgb.getValue(\n                                    interpolation.getStandardSource(),\n                                    interpolation, expiration);\n                        } else {\n                            value = guidance;\n                        }\n                        if (value > 0.0f) {\n                            tvalue += value;\n                        }\n                        i++;\n                    }\n                }\n            }\n        }\n\n        if (tvalue == 0.0f) {\n            return Float.NaN;\n        }\n\n        return tvalue / i;\n    }\n\n    /**\n     * Extracts the Max value for a guidance aggregation of basins THIS IS\n     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse\n     * \n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getMaxGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration,\n            long parentPfaf) {\n        float tvalue = Float.NaN;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                fgb.setCountyFips(parentPfaf);\n                if (interpolation.isInterpolate()) {\n                    float nvalue = fgb.getInterpolatedValue(interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (nvalue < -999) {\n                        continue;\n                    }\n                    if (((nvalue < tvalue) && (nvalue > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = nvalue;\n                    }\n                } else {\n                    float value = fgb.getValue(\n                            interpolation.getStandardSource(), interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    if (((value < tvalue) && (value > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = value;\n                    }\n                }\n            }\n        }\n\n        if (tvalue == 0.0f) {\n            tvalue = Float.NaN;\n        }\n\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Accumulated Max value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @return\n     */\n    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n\n                float val = basin.getAccumValue(afterDate, beforeDate,\n                        expirationTime, rate);\n\n                if (val > tvalue) {\n                    tvalue = val;\n                }\n            }\n        }\n\n        return tvalue;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @return\n     */\n    public List<Float> getGuidanceValues(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (interpolation.isInterpolate()) {\n                    values.add(fgb.getInterpolatedValue(interpolation,\n                            expiration));\n                } else {\n                    values.add(fgb.getValue(interpolation.getStandardSource(),\n                            interpolation, expiration));\n                }\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Gets the average guidance value for an aggregate basin\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @param expiration\n     * @return\n     */\n    public Float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n\n        float tvalue = 0.0f;\n        int i = 0;\n\n        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation,\n                expiration);\n        if (vals != null) {\n            for (Float val : vals) {\n                tvalue += val;\n                i++;\n            }\n        } else {\n            return null;\n        }\n\n        return tvalue / i;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @param rate\n     * @return\n     */\n    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                values.add(basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate));\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Purge out old data\n     * \n     * @param date\n     */\n    public void purgeData(Date date) {\n        // remove old tasks before calling getBasins() since that may\n        // cause them to run\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                Iterator<LoadTask> itr = tasks.iterator();\n                {\n                    while (itr.hasNext()) {\n                        LoadTask task = itr.next();\n                        if (task instanceof LoadMapTask) {\n                            LoadMapTask mtask = (LoadMapTask) task;\n                            if (mtask.date.before(date)) {\n                                itr.remove();\n                            }\n                        }\n                    }\n                }\n                if (tasks.isEmpty()) {\n                    orderedBasinsCache.clear();\n                }\n            }\n        }\n        for (FFMPBasin basin : basins.values()) {\n            basin.purgeData(date);\n        }\n    }\n\n    /**\n     * deserialize data from the aggregate record\n     * \n     * @param times\n     */\n    public void populate(List<Long> times) {\n        if (mapFactory == null) {\n            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(),\n                    getBasins().size());\n        }\n\n        long[] timesArr = new long[times.size()];\n        for (int i = 0; i < timesArr.length; i += 1) {\n            timesArr[i] = times.get(i);\n        }\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.deserialize(timesArr, mapFactory);\n        }\n    }\n\n    /**\n     * populates the serialized array/objects\n     */\n    public void serialize() {\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.serialize();\n        }\n    }\n\n    /**\n     * Add basins some basins from a datastoreFile. The basins will not be\n     * loaded immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param siteKey\n     *            - siteKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param huc\n     *            - huc to load\n     * @param sourceName\n     *            - the sourceName for the data.\n     * @param date\n     *            - the date of the data.\n     * @param orderedPfafs\n     *            - a collection of Longs which is in the same order as the data\n     *            in the dataStore.\n     * @param aggregate\n     */\n    public void addBasins(File datastoreFile, String uri, String siteKey,\n            String cwa, String huc, String sourceName, Date date,\n            Collection<Long> orderedPfafs, boolean aggregate) {\n        SourceXML source = FFMPSourceConfigurationManager.getInstance()\n                .getSource(sourceName);\n        boolean guidance = source.getSourceType().equals(\n                SOURCE_TYPE.GUIDANCE.getSourceType());\n        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + huc;\n\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedPfafs.size()];\n                int j = 0;\n                for (Long pfaf : orderedPfafs) {\n                    FFMPBasin basin = this.basins.get(pfaf);\n                    if (basin == null) {\n                        if (guidance) {\n                            basin = new FFMPGuidanceBasin(pfaf, aggregate);\n                        } else {\n                            if (mapFactory == null) {\n                                mapFactory = new BasinMapFactory<Date>(\n                                        Collections.reverseOrder(),\n                                        orderedPfafs.size());\n                            }\n                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);\n                        }\n                        this.basins.put(pfaf, basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            if (guidance) {\n                tasks.add(new LoadGuidanceMapTask(datastoreFile,\n                        datasetGroupPath, basins, date, sourceName));\n            } else {\n                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath,\n                        basins, date));\n            }\n        }\n    }\n\n    /**\n     * Add virtual basins from a datastoreFile. The basins will not be loaded\n     * immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param dataKey\n     *            - dataKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param date\n     *            - the date of the data.\n     * @param orderedMetadata\n     *            - a collection of FFMPVirtualGageBasinMetaData which is in the\n     *            same order as the data in the dataStore.\n     */\n    public void addVirtualBasins(File datastoreFile, String uri,\n            String dataKey, String cwa, Date date,\n            Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {\n        String basinsKey = dataKey + ' ' + cwa;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedMetadata.size()];\n                int j = 0;\n                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {\n                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());\n                    if (basin == null) {\n                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(),\n                                fvgbmd.getParentPfaf(), false);\n                        this.basins.put(fvgbmd.getLookupId(), basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath,\n                    basins, date));\n        }\n    }\n\n    /**\n     * Returns whether or not any basins have been put in the basins map. Faster\n     * than calling getBasins().size() or getBasins().isEmpty().\n     * \n     * @return\n     */\n    public boolean hasAnyBasins() {\n        return !basins.isEmpty();\n    }\n\n    /**\n     * Load now.\n     */\n    public void loadNow() {\n        synchronized (tasks) {\n            if (!tasks.isEmpty()) {\n                FFMPDataRecordLoader.loadRecords(tasks);\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n    }\n\n    /**\n     * Base task for loading data from a dataRecord into FFMPBasins\n     */\n    private class LoadMapTask extends LoadTask {\n\n        protected final FFMPBasin[] basins;\n\n        protected final Date date;\n\n        public LoadMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath);\n            this.basins = basins;\n            this.date = date;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void process(FloatDataRecord record) {\n            float[] values = record.getFloatData();\n            for (int j = 0; j < values.length; j += 1) {\n                applyValue(basins[j], values[j]);\n            }\n        }\n\n        /**\n         * Apply the value to the basin/\n         */\n        protected void applyValue(FFMPBasin basin, float value) {\n            if (basin.contains(date)) {\n                float curval = basin.getValue(date);\n                // These are QPF and QPE so, 0.0 is a valid amount\n                if (curval >= 0.0f && value >= 0.0f) {\n                    basin.setValue(date, (curval + value) / 2);\n                } else if (value >= 0.0f) {\n                    basin.setValue(date, value);\n                } \n                // do not overwrite original value\n            } else {\n                // no value at time exists, write regardless\n                basin.setValue(date, value);\n            }\n        }\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPGuidanceBasins\n     */\n    private class LoadGuidanceMapTask extends LoadMapTask {\n\n        private final String sourceName;\n\n        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date, String sourceName) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n            this.sourceName = sourceName;\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            \n            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;\n            Float curval = gBasin.getValue(date, sourceName);\n\n            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {\n                // average of original and new value\n                if (curval > 0.0f && value > 0.0f) {\n                    gBasin.setValue(sourceName, date, (curval + value) / 2);\n                } else {\n                    // curval zero, overwrite original value \n                    if (curval == 0.0f) {\n                        gBasin.setValue(sourceName, date, value);\n                    }\n                }\n            } else {\n                // curval NaN or MISSING, Overwrite original value \n                gBasin.setValue(sourceName, date, value);\n            }\n        }\n\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPVirtualGageBasins\n     */\n    private class LoadVirtualMapTask extends LoadMapTask {\n\n        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            basin.setValue(date, value);\n        }\n\n    }\n\n}", "class_id": 0, "repo": "srcarter3/awips2", "file": "edexOsgi/com.raytheon.uf.common.dataplugin.ffmp/src/com/raytheon/uf/common/dataplugin/ffmp/FFMPBasinData.java", "last_update_at": "2021-10-30T00:03:05+00:00", "question_id": "225847a731ab9bc895536af2abea87cf195f916c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@DynamicSerialize\npublic class FFMPBasinData {\n    public static final double GUIDANCE_MISSING = -999999.0;\n    // defaults\n    @DynamicSerializeElement\n    private String hucLevel;\n    @DynamicSerializeElement\n    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();\n    /**\n     * Pending load tasks that need to be run to fully populate basins\n     */\n    private final List<LoadTask> tasks = new ArrayList<LoadTask>();\n    /**\n     * Cache of basins in order for easy population from Load Tasks.\n     */\n    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();\n    /**\n     * Shared factory for efficient storage of data in basins.\n     */\n    private BasinMapFactory<Date> mapFactory = null;\n    /**\n     * Public one arg constructor\n     * \n     * @param huc_level\n     */\n    public FFMPBasinData(String hucLevel) {\n        setHucLevel(hucLevel);\n    }\n    /**\n     * No arg hibernate constructor\n     */\n    public FFMPBasinData() {\n    }\n    /**\n     * get the basin map\n     * \n     * @return\n     */\n    public Map<Long, FFMPBasin> getBasins() {\n        if (!tasks.isEmpty()) {\n            loadNow();\n        }\n        return basins;\n    }\n    /**\n     * Sets the basin map\n     * \n     * @param basins\n     */\n    public void setBasins(Map<Long, FFMPBasin> basins) {\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n        this.basins = basins;\n    }\n    /**\n     * Gets the HUC Level for this map\n     * \n     * @return\n     */\n    public String getHucLevel() {\n        return hucLevel;\n    }\n    /**\n     * Sets the HUC Level for this map\n     */\n    public void setHucLevel(String hucLevel) {\n        this.hucLevel = hucLevel;\n    }\n    /**\n     * Add to the hash\n     * \n     * @param key\n     * @param basin\n     */\n    public void put(Long key, FFMPBasin basin) {\n        getBasins().put(key, basin);\n    }\n    /**\n     * Gets the FFMPBasin from the hash\n     * \n     * @param key\n     * @return\n     */\n    public FFMPBasin get(Long key) {\n        return getBasins().get(key);\n    }\n    /**\n     * Gets a list of pfaf ids from the keys\n     * \n     * @return\n     */\n    public List<Long> getPfafIds() {\n        return new ArrayList<Long>(getBasins().keySet());\n    }\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param startDate\n     * @param finishDate\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(beforeDate, afterDate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param exact\n     *            date\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(date);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expirationTime\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date,\n            long epirationTime) {\n        float tvalue = 0.0f;\n        int i = 0;\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = getBasins().get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAverageValue(date, epirationTime);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins with areal\n     * weighting\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids,\n            ArrayList<Double> areas) {\n        float tvalue = 0.0f;\n        float tarea = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                if (basin.getValue() != FFMPUtils.MISSING) {\n                    tvalue += (basin.getValue() * areas.get(i));\n                    tarea += areas.get(i);\n                }\n            }\n        }\n        if (tvalue < 0.0f) {\n            tvalue = FFMPUtils.MISSING;\n        } else {\n            tvalue = tvalue / tarea;\n        }\n        return tvalue;\n    }\n    /**\n     * Extracts the average value for an aggregation of basins to a given time\n     * \n     * @param pfaf_ids\n     * @return\n     */\n    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n    /**\n     * Extracts the Max value for a range of times in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate,\n            Date afterDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(beforeDate, afterDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(List<Long> pfaf_ids, Date date,\n            long expiration) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(date, expiration);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Used for mosaic sources\n     * \n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate,\n            Date beforeDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(afterDate, beforeDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Extracts the Max value for a specific time in an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(List<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(date);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * Average Guidance\n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, float guidance,\n            List<Long> forcedPfafs, long expiration) {\n        float tvalue = 0.0f;\n        float value;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin == null) {\n                return guidance;\n            }\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (forcedPfafs.contains(pfaf)) {\n                    if (interpolation.isInterpolate()) {\n                        value = fgb.getInterpolatedValue(interpolation,\n                                expiration);\n                    } else {\n                        value = fgb.getValue(interpolation.getStandardSource(),\n                                interpolation, expiration);\n                    }\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    tvalue += value;\n                    i++;\n                } else {\n                    if (interpolation.isInterpolate()) {\n                        float nvalue;\n                        if (new Float(guidance).isNaN()) {\n                            nvalue = fgb.getInterpolatedValue(interpolation,\n                                    expiration);\n                        } else {\n                            nvalue = guidance;\n                        }\n                        if (nvalue > 0.0f) {\n                            tvalue += nvalue;\n                        }\n                        i++;\n                    } else {\n                        if (new Float(guidance).isNaN()) {\n                            value = fgb.getValue(\n                                    interpolation.getStandardSource(),\n                                    interpolation, expiration);\n                        } else {\n                            value = guidance;\n                        }\n                        if (value > 0.0f) {\n                            tvalue += value;\n                        }\n                        i++;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            return Float.NaN;\n        }\n        return tvalue / i;\n    }\n    /**\n     * Extracts the Max value for a guidance aggregation of basins THIS IS\n     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse\n     * \n     * \n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getMaxGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration,\n            long parentPfaf) {\n        float tvalue = Float.NaN;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                fgb.setCountyFips(parentPfaf);\n                if (interpolation.isInterpolate()) {\n                    float nvalue = fgb.getInterpolatedValue(interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (nvalue < -999) {\n                        continue;\n                    }\n                    if (((nvalue < tvalue) && (nvalue > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = nvalue;\n                    }\n                } else {\n                    float value = fgb.getValue(\n                            interpolation.getStandardSource(), interpolation,\n                            expiration);\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    if (((value < tvalue) && (value > 0.0f))\n                            || Float.isNaN(tvalue)) {\n                        tvalue = value;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            tvalue = Float.NaN;\n        }\n        return tvalue;\n    }\n    /**\n     * Extracts the Accumulated Max value for an aggregation of basins\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @return\n     */\n    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                float val = basin.getAccumValue(afterDate, beforeDate,\n                        expirationTime, rate);\n                if (val > tvalue) {\n                    tvalue = val;\n                }\n            }\n        }\n        return tvalue;\n    }\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @return\n     */\n    public List<Float> getGuidanceValues(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (interpolation.isInterpolate()) {\n                    values.add(fgb.getInterpolatedValue(interpolation,\n                            expiration));\n                } else {\n                    values.add(fgb.getValue(interpolation.getStandardSource(),\n                            interpolation, expiration));\n                }\n            }\n        }\n        return values;\n    }\n    /**\n     * Gets the average guidance value for an aggregate basin\n     * \n     * @param pfaf_ids\n     * @param interpolation\n     * @param expiration\n     * @return\n     */\n    public Float getAverageGuidanceValue(List<Long> pfaf_ids,\n            FFMPGuidanceInterpolation interpolation, long expiration) {\n        float tvalue = 0.0f;\n        int i = 0;\n        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation,\n                expiration);\n        if (vals != null) {\n            for (Float val : vals) {\n                tvalue += val;\n                i++;\n            }\n        } else {\n            return null;\n        }\n        return tvalue / i;\n    }\n    /**\n     * used for max ratio and diff calcs\n     * \n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @param rate\n     * @return\n     */\n    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate,\n            Date afterDate, long expirationTime, boolean rate) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                values.add(basin.getAccumValue(beforeDate, afterDate,\n                        expirationTime, rate));\n            }\n        }\n        return values;\n    }\n    /**\n     * Purge out old data\n     * \n     * @param date\n     */\n    public void purgeData(Date date) {\n        // remove old tasks before calling getBasins() since that may\n        // cause them to run\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                Iterator<LoadTask> itr = tasks.iterator();\n                {\n                    while (itr.hasNext()) {\n                        LoadTask task = itr.next();\n                        if (task instanceof LoadMapTask) {\n                            LoadMapTask mtask = (LoadMapTask) task;\n                            if (mtask.date.before(date)) {\n                                itr.remove();\n                            }\n                        }\n                    }\n                }\n                if (tasks.isEmpty()) {\n                    orderedBasinsCache.clear();\n                }\n            }\n        }\n        for (FFMPBasin basin : basins.values()) {\n            basin.purgeData(date);\n        }\n    }\n    /**\n     * deserialize data from the aggregate record\n     * \n     * @param times\n     */\n    public void populate(List<Long> times) {\n        if (mapFactory == null) {\n            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(),\n                    getBasins().size());\n        }\n        long[] timesArr = new long[times.size()];\n        for (int i = 0; i < timesArr.length; i += 1) {\n            timesArr[i] = times.get(i);\n        }\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.deserialize(timesArr, mapFactory);\n        }\n    }\n    /**\n     * populates the serialized array/objects\n     */\n    public void serialize() {\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.serialize();\n        }\n    }\n    /**\n     * Add basins some basins from a datastoreFile. The basins will not be\n     * loaded immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param siteKey\n     *            - siteKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param huc\n     *            - huc to load\n     * @param sourceName\n     *            - the sourceName for the data.\n     * @param date\n     *            - the date of the data.\n     * @param orderedPfafs\n     *            - a collection of Longs which is in the same order as the data\n     *            in the dataStore.\n     * @param aggregate\n     */\n    public void addBasins(File datastoreFile, String uri, String siteKey,\n            String cwa, String huc, String sourceName, Date date,\n            Collection<Long> orderedPfafs, boolean aggregate) {\n        SourceXML source = FFMPSourceConfigurationManager.getInstance()\n                .getSource(sourceName);\n        boolean guidance = source.getSourceType().equals(\n                SOURCE_TYPE.GUIDANCE.getSourceType());\n        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + huc;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedPfafs.size()];\n                int j = 0;\n                for (Long pfaf : orderedPfafs) {\n                    FFMPBasin basin = this.basins.get(pfaf);\n                    if (basin == null) {\n                        if (guidance) {\n                            basin = new FFMPGuidanceBasin(pfaf, aggregate);\n                        } else {\n                            if (mapFactory == null) {\n                                mapFactory = new BasinMapFactory<Date>(\n                                        Collections.reverseOrder(),\n                                        orderedPfafs.size());\n                            }\n                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);\n                        }\n                        this.basins.put(pfaf, basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            if (guidance) {\n                tasks.add(new LoadGuidanceMapTask(datastoreFile,\n                        datasetGroupPath, basins, date, sourceName));\n            } else {\n                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath,\n                        basins, date));\n            }\n        }\n    }\n    /**\n     * Add virtual basins from a datastoreFile. The basins will not be loaded\n     * immediately, they will be loaded when they are needed.\n     * \n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param dataKey\n     *            - dataKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param date\n     *            - the date of the data.\n     * @param orderedMetadata\n     *            - a collection of FFMPVirtualGageBasinMetaData which is in the\n     *            same order as the data in the dataStore.\n     */\n    public void addVirtualBasins(File datastoreFile, String uri,\n            String dataKey, String cwa, Date date,\n            Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {\n        String basinsKey = dataKey + ' ' + cwa;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa\n                + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedMetadata.size()];\n                int j = 0;\n                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {\n                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());\n                    if (basin == null) {\n                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(),\n                                fvgbmd.getParentPfaf(), false);\n                        this.basins.put(fvgbmd.getLookupId(), basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath,\n                    basins, date));\n        }\n    }\n    /**\n     * Returns whether or not any basins have been put in the basins map. Faster\n     * than calling getBasins().size() or getBasins().isEmpty().\n     * \n     * @return\n     */\n    public boolean hasAnyBasins() {\n        return !basins.isEmpty();\n    }\n    /**\n     * Load now.\n     */\n    public void loadNow() {\n        synchronized (tasks) {\n            if (!tasks.isEmpty()) {\n                FFMPDataRecordLoader.loadRecords(tasks);\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n    }\n    /**\n     * Base task for loading data from a dataRecord into FFMPBasins\n     */\n    private class LoadMapTask extends LoadTask {\n        protected final FFMPBasin[] basins;\n        protected final Date date;\n        public LoadMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath);\n            this.basins = basins;\n            this.date = date;\n        }\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void process(FloatDataRecord record) {\n            float[] values = record.getFloatData();\n            for (int j = 0; j < values.length; j += 1) {\n                applyValue(basins[j], values[j]);\n            }\n        }\n        /**\n         * Apply the value to the basin/\n         */\n        protected void applyValue(FFMPBasin basin, float value) {\n            if (basin.contains(date)) {\n                float curval = basin.getValue(date);\n                // These are QPF and QPE so, 0.0 is a valid amount\n                if (curval >= 0.0f && value >= 0.0f) {\n                    basin.setValue(date, (curval + value) / 2);\n                } else if (value >= 0.0f) {\n                    basin.setValue(date, value);\n                } \n                // do not overwrite original value\n            } else {\n                // no value at time exists, write regardless\n                basin.setValue(date, value);\n            }\n        }\n    }\n    /**\n     * Task for loading data from a dataRecord into FFMPGuidanceBasins\n     */\n    private class LoadGuidanceMapTask extends LoadMapTask {\n        private final String sourceName;\n        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date, String sourceName) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n            this.sourceName = sourceName;\n        }\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;\n            Float curval = gBasin.getValue(date, sourceName);\n            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {\n                // average of original and new value\n                if (curval > 0.0f && value > 0.0f) {\n                    gBasin.setValue(sourceName, date, (curval + value) / 2);\n                } else {\n                    // curval zero, overwrite original value \n                    if (curval == 0.0f) {\n                        gBasin.setValue(sourceName, date, value);\n                    }\n                }\n            } else {\n                // curval NaN or MISSING, Overwrite original value \n                gBasin.setValue(sourceName, date, value);\n            }\n        }\n    }\n    /**\n     * Task for loading data from a dataRecord into FFMPVirtualGageBasins\n     */\n    private class LoadVirtualMapTask extends LoadMapTask {\n        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath,\n                FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n        }\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            basin.setValue(date, value);\n        }\n    }\n"]]}
{"hexsha": "e32741ad1544b9465ebc4976051bd0b87f903644", "ext": "java", "lang": "Java", "content": "public class SupplierCompileCompletionTest extends OfficeFrameTestCase {\n\n\t/**\n\t * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeFloorCompileScope() {\n\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeFloorMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();\n\t\tMockTeamSource team = new MockTeamSource();\n\t\tMockExecutiveSource executive = new MockExecutiveSource();\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockSupplierSource officeSupplier = new MockSupplierSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.officeFloor((context) -> {\n\t\t\tOfficeFloorDeployer deployer = context.getOfficeFloorDeployer();\n\t\t\tDeployedOffice office = context.getDeployedOffice();\n\n\t\t\t// Managed Object\n\t\t\tOfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource(\"MOS\", officeFloorMos);\n\t\t\tdeployer.link(mos.getManagingOffice(), office);\n\t\t\tmos.addOfficeFloorManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tOfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool(\"POOL\", officeFloorPool);\n\t\t\tdeployer.link(mos, pool);\n\n\t\t\t// Team\n\t\t\tdeployer.addTeam(\"TEAM\", team);\n\n\t\t\t// Executive\n\t\t\tdeployer.setExecutive(executive);\n\n\t\t\t// Supplier\n\t\t\tdeployer.addSupplier(\"SUPPLIER\", completeSupplier);\n\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after OfficeFloor sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\n\t\t\t// Ensure the supplier is now available\n\t\t\tassertNotNull(\"Supplier should have setup context\", compileScopedSources.get());\n\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", officeSupplier);\n\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing (OfficeFloor) supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object\", completeSupplier.completed.contains(officeFloorMos));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object pool\",\n\t\t\t\t\tcompleteSupplier.completed.contains(officeFloorPool));\n\t\t\tassertTrue(\"Missing team\", completeSupplier.completed.contains(team));\n\t\t\tassertTrue(\"Missing executive\", completeSupplier.completed.contains(executive));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing (office) supplier\", completeSupplier.completed.contains(officeSupplier));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 13,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Ensure capture {@link Office} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeCompileScope() {\n\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", completeSupplier);\n\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after Office sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 8,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\n\tprivate static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {\n\t\tassertIllegalStateException(() -> context.addManagedObjectSource(null, null, null),\n\t\t\t\t\"Unable to add further ManagedObject as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addSupplierThreadLocal(null, null),\n\t\t\t\t\"Unable to add further SupplierThreadLocal as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addThreadSynchroniser(null),\n\t\t\t\t\"Unable to add further ThreadSynchroniser as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addInternalSupplier(null),\n\t\t\t\t\"Unable to add further InternalSupplier as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null),\n\t\t\t\t\"Unable to add further SupplierCompileCompletion as SupplierSource completing\");\n\t}\n\n\tprivate static void assertIllegalStateException(Runnable logic, String message) {\n\t\ttry {\n\t\t\tlogic.run();\n\t\t\tfail(\"Should not be successful. \" + message);\n\t\t} catch (IllegalStateException ex) {\n\t\t\tassertEquals(\"Incorrect cause\", message, ex.getMessage());\n\t\t}\n\t}\n\n\tprivate static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();\n\n\t@TestSource\n\tprivate static class CompleteSupplierSource extends AbstractSupplierSource {\n\n\t\tprivate final List<Object> completed = new ArrayList<>();\n\n\t\t/**\n\t\t * Initial {@link SupplierSourceContext}.\n\t\t */\n\t\tprivate SupplierSourceContext initialContext;\n\n\t\t/**\n\t\t * Completion {@link SupplierCompileContext}.\n\t\t */\n\t\tprivate SupplierCompileContext completeContext;\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tthis.initialContext = context;\n\n\t\t\t// Clear scoped objects\n\t\t\tLinkedList<Object> sources = new LinkedList<>();\n\t\t\tsources.add(this);\n\t\t\tcompileScopedSources.set(sources);\n\n\t\t\t// Capture sources on completion\n\t\t\tcontext.addCompileCompletion((completion) -> {\n\t\t\t\tthis.completeContext = completion;\n\t\t\t\tthis.completed.addAll(compileScopedSources.get());\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockSupplierSource extends AbstractSupplierSource {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<None, None> context) throws Exception {\n\t\t\tcontext.setObjectClass(Object.class);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\n\t\t@Override\n\t\tprotected ManagedObject getManagedObject() throws Throwable {\n\t\t\tfail(\"Should not be run\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource\n\t\t\timplements ManagedObjectPoolFactory {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext context) throws Exception {\n\t\t\tcontext.setPooledObjectType(Object.class);\n\t\t\tcontext.setManagedObjectPoolFactory(this);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext)\n\t\t\t\tthrows Throwable {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockTeamSource extends AbstractTeamSource implements Team {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic Team createTeam(TeamSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic void startWorking() {\n\t\t\t// nothing to start\n\t\t}\n\n\t\t@Override\n\t\tpublic void assignJob(Job job) throws TeamOverloadException, Exception {\n\t\t\tfail(\"Should not run\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void stopWorking() {\n\t\t\t// nothing to stop\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockExecutiveSource extends DefaultExecutive {\n\n\t\t@Override\n\t\tpublic Executive createExecutive(ExecutiveSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn super.createExecutive(context);\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setAdministrationFactory(() -> (adminContext) -> {\n\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setGovernanceFactory(() -> null);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\n\t@TestSource\n\tprivate static class MockManagedFunctionSource extends AbstractManagedFunctionSource {\n\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\n\t\t@Override\n\t\tpublic void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder,\n\t\t\t\tManagedFunctionSourceContext context) throws Exception {\n\t\t\tfunctionNamespaceTypeBuilder.addManagedFunctionType(\"function\", None.class, None.class)\n\t\t\t\t\t.setFunctionFactory(() -> (mfContext) -> {\n\t\t\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "officefloor/OfficeFloor", "file": "officefloor/core/officecompiler/src/test/java/net/officefloor/compile/impl/supplier/SupplierCompileCompletionTest.java", "last_update_at": "2021-12-20T04:51:03+00:00", "question_id": "e32741ad1544b9465ebc4976051bd0b87f903644", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SupplierCompileCompletionTest extends OfficeFrameTestCase {\n\t/**\n\t * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeFloorCompileScope() {\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeFloorMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();\n\t\tMockTeamSource team = new MockTeamSource();\n\t\tMockExecutiveSource executive = new MockExecutiveSource();\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockSupplierSource officeSupplier = new MockSupplierSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.officeFloor((context) -> {\n\t\t\tOfficeFloorDeployer deployer = context.getOfficeFloorDeployer();\n\t\t\tDeployedOffice office = context.getDeployedOffice();\n\t\t\t// Managed Object\n\t\t\tOfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource(\"MOS\", officeFloorMos);\n\t\t\tdeployer.link(mos.getManagingOffice(), office);\n\t\t\tmos.addOfficeFloorManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tOfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool(\"POOL\", officeFloorPool);\n\t\t\tdeployer.link(mos, pool);\n\t\t\t// Team\n\t\t\tdeployer.addTeam(\"TEAM\", team);\n\t\t\t// Executive\n\t\t\tdeployer.setExecutive(executive);\n\t\t\t// Supplier\n\t\t\tdeployer.addSupplier(\"SUPPLIER\", completeSupplier);\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after OfficeFloor sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\t\t\t// Ensure the supplier is now available\n\t\t\tassertNotNull(\"Supplier should have setup context\", compileScopedSources.get());\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", officeSupplier);\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing (OfficeFloor) supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object\", completeSupplier.completed.contains(officeFloorMos));\n\t\t\tassertTrue(\"Missing (OfficeFloor) managed object pool\",\n\t\t\t\t\tcompleteSupplier.completed.contains(officeFloorPool));\n\t\t\tassertTrue(\"Missing team\", completeSupplier.completed.contains(team));\n\t\t\tassertTrue(\"Missing executive\", completeSupplier.completed.contains(executive));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing (office) supplier\", completeSupplier.completed.contains(officeSupplier));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 13,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\t/**\n\t * Ensure capture {@link Office} scope for {@link SupplierSource}.\n\t */\n\tpublic void testOfficeCompileScope() {\n\t\t// Capture the sources\n\t\tCompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n\t\t// Provide sources to capture the profiles\n\t\tMockManagedObjectSource officeMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n\t\tMockAdministrationSource admin = new MockAdministrationSource();\n\t\tMockGovernanceSource govern = new MockGovernanceSource();\n\t\tMockManagedObjectSource sectionMos = new MockManagedObjectSource();\n\t\tMockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n\t\tMockManagedFunctionSource function = new MockManagedFunctionSource();\n\t\t// Compile\n\t\tCompileOfficeFloor compiler = new CompileOfficeFloor();\n\t\tcompiler.office((context) -> {\n\t\t\tOfficeArchitect office = context.getOfficeArchitect();\n\t\t\t// Managed Object\n\t\t\tOfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n\t\t\tmos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tOfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n\t\t\toffice.link(mos, pool);\n\t\t\t// Administration\n\t\t\tOfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n\t\t\tOfficeSection section = office.getOfficeSection(\"SECTION\");\n\t\t\tsection.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n\t\t\t// Governance\n\t\t\toffice.addOfficeGovernance(\"GOVERNANCE\", govern);\n\t\t\t// Supplier\n\t\t\toffice.addSupplier(\"SUPPLIER\", completeSupplier);\n\t\t\t// Only adding, so should not have sources\n\t\t\t// (Note compiling of added items happens after Office sourcing)\n\t\t\tassertNull(\"Supplier should yet be created\", compileScopedSources.get());\n\t\t});\n\t\tcompiler.section((context) -> {\n\t\t\tSectionDesigner designer = context.getSectionDesigner();\n\t\t\t// Managed Object\n\t\t\tSectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n\t\t\tmos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n\t\t\t// Managed Object Pool\n\t\t\tSectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n\t\t\tdesigner.link(mos, pool);\n\t\t\t// Function\n\t\t\tdesigner.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n\t\t});\n\t\t// Undertake compiling with clean state\n\t\tcompileScopedSources.remove();\n\t\ttry (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n\t\t\t// Ensure complete supplier source context\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.initialContext);\n\t\t\tassertCompletedSupplierCompileContext(completeSupplier.completeContext);\n\t\t\t// Ensure all functionality are added\n\t\t\tassertTrue(\"Missing supplier\", completeSupplier.completed.contains(completeSupplier));\n\t\t\tassertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n\t\t\tassertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n\t\t\tassertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n\t\t\tassertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n\t\t\tassertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n\t\t\tassertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n\t\t\tassertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n\t\t\tassertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 8,\n\t\t\t\t\tcompleteSupplier.completed.size());\n\t\t} catch (Exception ex) {\n\t\t\tthrow fail(ex);\n\t\t}\n\t}\n\tprivate static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {\n\t\tassertIllegalStateException(() -> context.addManagedObjectSource(null, null, null),\n\t\t\t\t\"Unable to add further ManagedObject as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addSupplierThreadLocal(null, null),\n\t\t\t\t\"Unable to add further SupplierThreadLocal as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addThreadSynchroniser(null),\n\t\t\t\t\"Unable to add further ThreadSynchroniser as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> context.addInternalSupplier(null),\n\t\t\t\t\"Unable to add further InternalSupplier as SupplierSource loaded\");\n\t\tassertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null),\n\t\t\t\t\"Unable to add further SupplierCompileCompletion as SupplierSource completing\");\n\t}\n\tprivate static void assertIllegalStateException(Runnable logic, String message) {\n\t\ttry {\n\t\t\tlogic.run();\n\t\t\tfail(\"Should not be successful. \" + message);\n\t\t} catch (IllegalStateException ex) {\n\t\t\tassertEquals(\"Incorrect cause\", message, ex.getMessage());\n\t\t}\n\t}\n\tprivate static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();\n\t@TestSource\n\tprivate static class CompleteSupplierSource extends AbstractSupplierSource {\n\t\tprivate final List<Object> completed = new ArrayList<>();\n\t\t/**\n\t\t * Initial {@link SupplierSourceContext}.\n\t\t */\n\t\tprivate SupplierSourceContext initialContext;\n\t\t/**\n\t\t * Completion {@link SupplierCompileContext}.\n\t\t */\n\t\tprivate SupplierCompileContext completeContext;\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tthis.initialContext = context;\n\t\t\t// Clear scoped objects\n\t\t\tLinkedList<Object> sources = new LinkedList<>();\n\t\t\tsources.add(this);\n\t\t\tcompileScopedSources.set(sources);\n\t\t\t// Capture sources on completion\n\t\t\tcontext.addCompileCompletion((completion) -> {\n\t\t\t\tthis.completeContext = completion;\n\t\t\t\tthis.completed.addAll(compileScopedSources.get());\n\t\t\t});\n\t\t}\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockSupplierSource extends AbstractSupplierSource {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic void supply(SupplierSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t\t@Override\n\t\tpublic void terminate() {\n\t\t\t// nothing to terminate\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<None, None> context) throws Exception {\n\t\t\tcontext.setObjectClass(Object.class);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t\t@Override\n\t\tprotected ManagedObject getManagedObject() throws Throwable {\n\t\t\tfail(\"Should not be run\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource\n\t\t\timplements ManagedObjectPoolFactory {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext context) throws Exception {\n\t\t\tcontext.setPooledObjectType(Object.class);\n\t\t\tcontext.setManagedObjectPoolFactory(this);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t\t@Override\n\t\tpublic ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext)\n\t\t\t\tthrows Throwable {\n\t\t\treturn null;\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockTeamSource extends AbstractTeamSource implements Team {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic Team createTeam(TeamSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn this;\n\t\t}\n\t\t@Override\n\t\tpublic void startWorking() {\n\t\t\t// nothing to start\n\t\t}\n\t\t@Override\n\t\tpublic void assignJob(Job job) throws TeamOverloadException, Exception {\n\t\t\tfail(\"Should not run\");\n\t\t}\n\t\t@Override\n\t\tpublic void stopWorking() {\n\t\t\t// nothing to stop\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockExecutiveSource extends DefaultExecutive {\n\t\t@Override\n\t\tpublic Executive createExecutive(ExecutiveSourceContext context) throws Exception {\n\t\t\tcompileScopedSources.get().add(this);\n\t\t\treturn super.createExecutive(context);\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setAdministrationFactory(() -> (adminContext) -> {\n\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tprotected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {\n\t\t\tcontext.setExtensionInterface(Object.class);\n\t\t\tcontext.setGovernanceFactory(() -> null);\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n\t@TestSource\n\tprivate static class MockManagedFunctionSource extends AbstractManagedFunctionSource {\n\t\t@Override\n\t\tprotected void loadSpecification(SpecificationContext context) {\n\t\t\t// no specification\n\t\t}\n\t\t@Override\n\t\tpublic void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder,\n\t\t\t\tManagedFunctionSourceContext context) throws Exception {\n\t\t\tfunctionNamespaceTypeBuilder.addManagedFunctionType(\"function\", None.class, None.class)\n\t\t\t\t\t.setFunctionFactory(() -> (mfContext) -> {\n\t\t\t\t\t});\n\t\t\tcompileScopedSources.get().add(this);\n\t\t}\n\t}\n"]]}
{"hexsha": "d620dafeb60e8e45312cbc5cd34054b25cd5a7e5", "ext": "java", "lang": "Java", "content": "public class Conta \n{\n\tprivate static int chave_conta;\n\t\n\tprivate String nome;\n\tprivate String descricao;\n\tprivate String senha;\n\t\n\tprivate Pessoa pessoa;\n\tprivate java.util.Date data;\n\t\n\tpublic Conta() { Conta.chave_conta++; }\n\t\n\tpublic Conta(String nome) {\n\t\tthis.nome = nome;\n\t\tConta.chave_conta++; \n\t}\n\n\tpublic static int CHAVE_CONTA() { return Conta.chave_conta; }\n\n\tpublic String getNome() { return this.nome; }\n\tpublic void setNome(String nome) { this.nome = nome; }\n\n\tpublic String getDescricao() { return this.descricao; }\n\tpublic void setDescricao(String descricao) { this.descricao = descricao; }\n\n\tpublic String getSenha() { return this.senha; }\n\tpublic void setSenha(String senha) { this.senha = senha; }\n\t\n\tpublic Pessoa getPessoa() { return this.pessoa; }\n\tpublic void setPessoa(Pessoa pessoa) { this.pessoa = pessoa; }\n\t\n\tpublic java.util.Date getData() { return this.data; }\n\tpublic void setData(java.util.Date data) {\n\t\tGregorianCalendar gc = new GregorianCalendar(2021, 2, 31);\n\t\tif (data.equals(gc.getTime())) {\n\t\t\tthis.data = null;\n\t\t}\n\t\t\n\t\tthis.data = data; \n\t}\n}", "class_id": 0, "repo": "RyanCasf/Java", "file": "src/main/java/br/com/estatico/aplication/Conta.java", "last_update_at": "2021-08-02T22:32:24+00:00", "question_id": "d620dafeb60e8e45312cbc5cd34054b25cd5a7e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Conta \n{\n\tprivate static int chave_conta;\n\t\n\tprivate String nome;\n\tprivate String descricao;\n\tprivate String senha;\n\t\n\tprivate Pessoa pessoa;\n\tprivate java.util.Date data;\n\t\n\tpublic Conta() { Conta.chave_conta++; }\n\t\n\tpublic Conta(String nome) {\n\t\tthis.nome = nome;\n\t\tConta.chave_conta++; \n\t}\n\tpublic static int CHAVE_CONTA() { return Conta.chave_conta; }\n\tpublic String getNome() { return this.nome; }\n\tpublic void setNome(String nome) { this.nome = nome; }\n\tpublic String getDescricao() { return this.descricao; }\n\tpublic void setDescricao(String descricao) { this.descricao = descricao; }\n\tpublic String getSenha() { return this.senha; }\n\tpublic void setSenha(String senha) { this.senha = senha; }\n\t\n\tpublic Pessoa getPessoa() { return this.pessoa; }\n\tpublic void setPessoa(Pessoa pessoa) { this.pessoa = pessoa; }\n\t\n\tpublic java.util.Date getData() { return this.data; }\n\tpublic void setData(java.util.Date data) {\n\t\tGregorianCalendar gc = new GregorianCalendar(2021, 2, 31);\n\t\tif (data.equals(gc.getTime())) {\n\t\t\tthis.data = null;\n\t\t}\n\t\t\n\t\tthis.data = data; \n\t}\n"]]}
{"hexsha": "3f156fc483ff7ed9a55cefd3b01cbbcdd2d04d3a", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/passwordSecurityPolicy\")\n@Extension\n@Tag(name = \"passwordSecurityPolicy\")\n@ProtectedREST\n@OperationsInside\npublic class PasswordSecurityPolicyController implements Plugin {\n\n\t@Autowired\n\tprivate PasswordSecurityPolicyService passwordSecurityPolicyService;\n\n\t@PostMapping(\"/create\")\n\t@Operation(description = \"creates Security Policy\",summary = \"creates Security Policy\")\n\tpublic PasswordSecurityPolicy create(@RequestHeader(value = \"authenticationKey\",required = false)String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyCreate,securityContext);\n\t\treturn passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate,securityContext);\n\t}\n\n\t@PostMapping(\"/getAll\")\n\t@Operation(description = \"returns Security Policies\",summary = \"returns Security Policies\")\n\n\tpublic PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyFilter securityPolicyFilter,  @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyFilter,securityContext);\n\t\treturn passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter,securityContext);\n\t}\n\n\t@PutMapping(\"/update\")\n\t@Operation(description = \"updates Security Policies\",summary = \"updates Security Policies\")\n\n\tpublic PasswordSecurityPolicy update(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext){\n\t\tString id=securityPolicyUpdate.getId();\n\t\tPasswordSecurityPolicy passwordSecurityPolicy=id!=null? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id,PasswordSecurityPolicy.class,securityContext):null;\n\t\tif(passwordSecurityPolicy==null){\n\t\t\tthrow new ResponseStatusException(HttpStatus.BAD_REQUEST,\"no PasswordSecurityPolicy user with id \"+id);\n\t\t}\n\t\tsecurityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);\n\t\tpasswordSecurityPolicyService.validate(securityPolicyUpdate,securityContext);\n\t\treturn passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate,securityContext);\n\t}\n}", "class_id": 0, "repo": "wizzdi/flexicore-base-service", "file": "src/main/java/com/flexicore/rest/PasswordSecurityPolicyController.java", "last_update_at": "2021-06-11T04:13:36+00:00", "question_id": "3f156fc483ff7ed9a55cefd3b01cbbcdd2d04d3a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/passwordSecurityPolicy\")\n@Extension\n@Tag(name = \"passwordSecurityPolicy\")\n@ProtectedREST\n@OperationsInside\npublic class PasswordSecurityPolicyController implements Plugin {\n\t@Autowired\n\tprivate PasswordSecurityPolicyService passwordSecurityPolicyService;\n\t@PostMapping(\"/create\")\n\t@Operation(description = \"creates Security Policy\",summary = \"creates Security Policy\")\n\tpublic PasswordSecurityPolicy create(@RequestHeader(value = \"authenticationKey\",required = false)String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyCreate,securityContext);\n\t\treturn passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate,securityContext);\n\t}\n\t@PostMapping(\"/getAll\")\n\t@Operation(description = \"returns Security Policies\",summary = \"returns Security Policies\")\n\tpublic PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyFilter securityPolicyFilter,  @RequestAttribute SecurityContextBase securityContext){\n\t\tpasswordSecurityPolicyService.validate(securityPolicyFilter,securityContext);\n\t\treturn passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter,securityContext);\n\t}\n\t@PutMapping(\"/update\")\n\t@Operation(description = \"updates Security Policies\",summary = \"updates Security Policies\")\n\tpublic PasswordSecurityPolicy update(@RequestHeader(value = \"authenticationKey\",required = false)String key,@RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext){\n\t\tString id=securityPolicyUpdate.getId();\n\t\tPasswordSecurityPolicy passwordSecurityPolicy=id!=null? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id,PasswordSecurityPolicy.class,securityContext):null;\n\t\tif(passwordSecurityPolicy==null){\n\t\t\tthrow new ResponseStatusException(HttpStatus.BAD_REQUEST,\"no PasswordSecurityPolicy user with id \"+id);\n\t\t}\n\t\tsecurityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);\n\t\tpasswordSecurityPolicyService.validate(securityPolicyUpdate,securityContext);\n\t\treturn passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate,securityContext);\n\t}\n"]]}
{"hexsha": "18b49af96dd5814b6f008015faacfeda2a05682a", "ext": "java", "lang": "Java", "content": "@Component\n@Description(\"Ends execution of entity event.\")\npublic class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {\n\t\n\tpublic static final String PROCESSOR_NAME = \"entity-event-end-processor\";\n\t//\n\t@Autowired private IdmEntityEventService service;\n\t\n\tpublic EntityEventEndProcessor() {\n\t\tsuper(EntityEventType.EXECUTE);\n\t}\n\t\n\t@Override\n\tpublic String getName() {\n\t\treturn PROCESSOR_NAME;\n\t}\n\n\t@Override\n\tpublic EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {\n\t\tIdmEntityEventDto entityEvent = event.getContent();\n\t\tentityEvent.setEventEnded(ZonedDateTime.now());\n\t\tentityEvent = service.save(entityEvent);\n\t\tevent.setContent(entityEvent);\n\t\t//\n\t\treturn new DefaultEventResult<>(event, this);\n\t}\n\t\n\t/**\n\t * Asynchronous processing can be disabled\n\t */\n\t@Override\n\tpublic boolean conditional(EntityEvent<IdmEntityEventDto> event) {\n\t\treturn event.getContent().getId() != null;\n\t}\n\t\n\t@Override\n\tpublic int getOrder() {\n\t\t// after process\n\t\treturn 1000;\n\t}\n}", "class_id": 0, "repo": "piougy/CzechIdMng", "file": "Realization/backend/core/core-impl/src/main/java/eu/bcvsolutions/idm/core/model/event/processor/event/EntityEventEndProcessor.java", "last_update_at": "2021-08-06T19:55:05+00:00", "question_id": "18b49af96dd5814b6f008015faacfeda2a05682a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Description(\"Ends execution of entity event.\")\npublic class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {\n\t\n\tpublic static final String PROCESSOR_NAME = \"entity-event-end-processor\";\n\t//\n\t@Autowired private IdmEntityEventService service;\n\t\n\tpublic EntityEventEndProcessor() {\n\t\tsuper(EntityEventType.EXECUTE);\n\t}\n\t\n\t@Override\n\tpublic String getName() {\n\t\treturn PROCESSOR_NAME;\n\t}\n\t@Override\n\tpublic EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {\n\t\tIdmEntityEventDto entityEvent = event.getContent();\n\t\tentityEvent.setEventEnded(ZonedDateTime.now());\n\t\tentityEvent = service.save(entityEvent);\n\t\tevent.setContent(entityEvent);\n\t\t//\n\t\treturn new DefaultEventResult<>(event, this);\n\t}\n\t\n\t/**\n\t * Asynchronous processing can be disabled\n\t */\n\t@Override\n\tpublic boolean conditional(EntityEvent<IdmEntityEventDto> event) {\n\t\treturn event.getContent().getId() != null;\n\t}\n\t\n\t@Override\n\tpublic int getOrder() {\n\t\t// after process\n\t\treturn 1000;\n\t}\n"]]}
{"hexsha": "2b5d7a6df824e402ae1c26cbf10970eb75941eb6", "ext": "java", "lang": "Java", "content": "public class PlaceLocation {\n    public String name;\n    public String address;\n\n    public boolean isNotInUsa() {\n        return address != null && !address.endsWith(\"USA\") && !address.endsWith(\"United States\");\n    }\n\n    public String country() {\n        if (address == null) {\n            return null;\n        }\n        String countryMatch = address.substring(address.lastIndexOf(\"\\n\") + 1);\n        String trimmedCountry;\n        if (!countryMatch.contains(\",\")) {\n            trimmedCountry = countryMatch.trim();\n        } else  {\n            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(\",\") + 1).trim();\n        }\n\n        switch (trimmedCountry) {\n        case \"United States\":\n            return \"USA\";\n        case \"Italia\":\n            return \"Italy\";\n        case \"Tanz\u00e1nie\":\n            return \"Tanzania\";\n        case \"\u00c9ire\":\n            return \"Ireland\";\n        case \"United Kingdom\":\n            return \"UK\";\n        default:\n            return trimmedCountry;\n        }\n    }\n\n\n}", "class_id": 0, "repo": "vmware/workflowTools", "file": "core/src/test/java/PlaceLocation.java", "last_update_at": "2021-12-06T22:26:15+00:00", "question_id": "2b5d7a6df824e402ae1c26cbf10970eb75941eb6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlaceLocation {\n    public String name;\n    public String address;\n    public boolean isNotInUsa() {\n        return address != null && !address.endsWith(\"USA\") && !address.endsWith(\"United States\");\n    }\n    public String country() {\n        if (address == null) {\n            return null;\n        }\n        String countryMatch = address.substring(address.lastIndexOf(\"\\n\") + 1);\n        String trimmedCountry;\n        if (!countryMatch.contains(\",\")) {\n            trimmedCountry = countryMatch.trim();\n        } else  {\n            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(\",\") + 1).trim();\n        }\n        switch (trimmedCountry) {\n        case \"United States\":\n            return \"USA\";\n        case \"Italia\":\n            return \"Italy\";\n        case \"Tanz\u00e1nie\":\n            return \"Tanzania\";\n        case \"\u00c9ire\":\n            return \"Ireland\";\n        case \"United Kingdom\":\n            return \"UK\";\n        default:\n            return trimmedCountry;\n        }\n    }\n"]]}
{"hexsha": "d337b228a1e219df9c9fd234cc3062ebe9e0e205", "ext": "java", "lang": "Java", "content": "public class InMemoryBulkDataSorterTest\n{\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n    \n    /* A counter of tuple files */\n    private int counter = 0;\n\n    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>()\n    {\n\n        @Override\n        public int compare( Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2 )\n        {\n            return o1.getKey().compareTo( o2.getKey() );\n        }\n    };\n\n\n    @Test\n    public void testSortedFileCount() throws IOException\n    {\n        int count = 7;\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n\n        File dataFile = tempFolder.newFile( \"tuple.data\" );\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( 100 );\n\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n\n            arr[i] = t;\n\n            itrw.storeSortedTuple( t, out );\n        }\n\n        out.close();\n\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, 4 );\n        bds.sort( dataFile );\n\n        assertEquals( 2, bds.getWorkDir().list().length );\n\n        deleteDir( bds.getWorkDir() );\n    }\n\n\n    @Test\n    public void testSortedFileMerge() throws IOException\n    {\n        testSortedFileMerge( 10, 2 );\n        testSortedFileMerge( 100, 7 );\n        testSortedFileMerge( 1000, 25 );\n        testSortedFileMerge( 10000, 100 );\n        testSortedFileMerge( 10000, 101 );\n        testSortedFileMerge( 100000, 501 );\n    }\n\n\n    private void testSortedFileMerge( int count, int splitAfter ) throws IOException\n    {\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n\n        File dataFile = tempFolder.newFile( \"tuple.data\" + counter );\n        counter++;\n        dataFile.deleteOnExit();\n\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n\n        int randUpper = count;\n        if ( count < 100 )\n        {\n            randUpper = 100;\n        }\n\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( randUpper );\n\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n\n            arr[i] = t;\n\n            itrw.storeSortedTuple( t, out );\n        }\n\n        out.close();\n\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, splitAfter );\n        bds.sort( dataFile );\n\n        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();\n\n        Integer prev = null;\n\n        while ( itr.hasNext() )\n        {\n            Tuple<Integer, Integer> t = itr.next();\n\n            if ( prev == null )\n            {\n                prev = t.getKey();\n            }\n            else\n            {\n                assertTrue( prev <= t.getKey() );\n            }\n        }\n\n        deleteDir( bds.getWorkDir() );\n    }\n\n\n    private void deleteDir( File dir )\n    {\n        if ( dir.isFile() )\n        {\n            dir.delete();\n        }\n\n        File[] files = dir.listFiles();\n\n        for ( File f : files )\n        {\n            f.delete();\n        }\n\n        dir.delete();\n    }\n}", "class_id": 0, "repo": "kupl/starlab-benchmarks", "file": "Benchmarks_with_Safety_Bugs/Java/directory-mavibot/src/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBulkDataSorterTest.java", "last_update_at": "2021-11-08T13:39:38+00:00", "question_id": "d337b228a1e219df9c9fd234cc3062ebe9e0e205", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InMemoryBulkDataSorterTest\n{\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n    /* A counter of tuple files */\n    private int counter = 0;\n    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>()\n    {\n        @Override\n        public int compare( Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2 )\n        {\n            return o1.getKey().compareTo( o2.getKey() );\n        }\n    };\n    @Test\n    public void testSortedFileCount() throws IOException\n    {\n        int count = 7;\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile( \"tuple.data\" );\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( 100 );\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n            arr[i] = t;\n            itrw.storeSortedTuple( t, out );\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, 4 );\n        bds.sort( dataFile );\n        assertEquals( 2, bds.getWorkDir().list().length );\n        deleteDir( bds.getWorkDir() );\n    }\n    @Test\n    public void testSortedFileMerge() throws IOException\n    {\n        testSortedFileMerge( 10, 2 );\n        testSortedFileMerge( 100, 7 );\n        testSortedFileMerge( 1000, 25 );\n        testSortedFileMerge( 10000, 100 );\n        testSortedFileMerge( 10000, 101 );\n        testSortedFileMerge( 100000, 501 );\n    }\n    private void testSortedFileMerge( int count, int splitAfter ) throws IOException\n    {\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile( \"tuple.data\" + counter );\n        counter++;\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream( new FileOutputStream( dataFile ) );\n        Tuple<Integer, Integer>[] arr = ( Tuple<Integer, Integer>[] ) Array.newInstance( Tuple.class, count );\n        int randUpper = count;\n        if ( count < 100 )\n        {\n            randUpper = 100;\n        }\n        for ( int i = 0; i < count; i++ )\n        {\n            int x = random.nextInt( randUpper );\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>( x, x );\n            arr[i] = t;\n            itrw.storeSortedTuple( t, out );\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>( itrw, tupleComp, splitAfter );\n        bds.sort( dataFile );\n        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();\n        Integer prev = null;\n        while ( itr.hasNext() )\n        {\n            Tuple<Integer, Integer> t = itr.next();\n            if ( prev == null )\n            {\n                prev = t.getKey();\n            }\n            else\n            {\n                assertTrue( prev <= t.getKey() );\n            }\n        }\n        deleteDir( bds.getWorkDir() );\n    }\n    private void deleteDir( File dir )\n    {\n        if ( dir.isFile() )\n        {\n            dir.delete();\n        }\n        File[] files = dir.listFiles();\n        for ( File f : files )\n        {\n            f.delete();\n        }\n        dir.delete();\n    }\n"]]}
{"hexsha": "7bdc9937970a43098edff3a966f21a3d4997caf4", "ext": "java", "lang": "Java", "content": "public class HomePage extends TestBase {\n\n    @Override\n    public void excute() throws Exception {\n\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(\"http://atealxt.appspot.com/guestbook\");\n        Assert.assertEquals(\"Guestbook - Hero's Grave\", page.getTitleText());\n\n        String pageAsXml = page.asXml();// \u548c\u5b9e\u9645\u7684\u7f51\u9875\u6e90\u7801\u4e0d\u5b8c\u5168\u4e00\u81f4\uff0c\u7ecf\u8fc7\u4e86\u683c\u5f0f\u5316\u7b49\u5904\u7406\u3002\u5c0f\u5fc3\u4f7f\u7528\uff01\n        Assert.assertTrue(pageAsXml.contains(\"<script src=\\\"/javascripts/guestbook.js\\\" type=\\\"text/javascript\\\">\"));\n        logger.info(pageAsXml);\n\n        String pageAsText = page.asText();\n        Assert.assertTrue(pageAsText\n                .contains(\"Welcome to my personal website, hope you to find out your own territory!\"));\n        logger.info(pageAsText);\n\n        webClient.closeAllWindows();\n    }\n\n}", "class_id": 0, "repo": "atealxt/work-workspaces", "file": "HtmlUnitDemo/test/htmlunitdemo/test/getstarted/HomePage.java", "last_update_at": "2021-12-18T18:17:34+00:00", "question_id": "7bdc9937970a43098edff3a966f21a3d4997caf4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HomePage extends TestBase {\n    @Override\n    public void excute() throws Exception {\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(\"http://atealxt.appspot.com/guestbook\");\n        Assert.assertEquals(\"Guestbook - Hero's Grave\", page.getTitleText());\n        String pageAsXml = page.asXml();// \u548c\u5b9e\u9645\u7684\u7f51\u9875\u6e90\u7801\u4e0d\u5b8c\u5168\u4e00\u81f4\uff0c\u7ecf\u8fc7\u4e86\u683c\u5f0f\u5316\u7b49\u5904\u7406\u3002\u5c0f\u5fc3\u4f7f\u7528\uff01\n        Assert.assertTrue(pageAsXml.contains(\"<script src=\\\"/javascripts/guestbook.js\\\" type=\\\"text/javascript\\\">\"));\n        logger.info(pageAsXml);\n        String pageAsText = page.asText();\n        Assert.assertTrue(pageAsText\n                .contains(\"Welcome to my personal website, hope you to find out your own territory!\"));\n        logger.info(pageAsText);\n        webClient.closeAllWindows();\n    }\n"]]}
{"hexsha": "919def75c26c20661ebc949f53445ab95efa46ca", "ext": "java", "lang": "Java", "content": "@Service\npublic class LinkManager implements LinkService {\n\t\n\tprivate LinkDao linkDao;\n\n\t@Autowired\n\tpublic LinkManager(LinkDao linkDao) {\n\t\tsuper();\n\t\tthis.linkDao = linkDao;\n\t}\n\t\n\t@Override\n\tpublic Result add(Link link) {\n\t\tvar result = this.linkDao.save(link);\n\t\tif (result != null) {\n\t\t\treturn new SuccessResult(\"link add ok\");\n\t\t}\n\t\treturn new ErrorResult(\"link add NOT ok\");\n\t}\n\n\t@Override\n\tpublic DataResult<List<Link>> getAll() {\n\t\tvar result = this.linkDao.findAll();\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get NOT ok\");\n\t}\n\n\t@Override\n\tpublic DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {\n\t\tvar result = this.linkDao.getByJobSeekerId(jobSeekerId);\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get by jobSeeker Id ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get by jobSeeker Id NOT ok\");\n\t}\n\n}", "class_id": 0, "repo": "CerenSusuz/HRMS", "file": "hrms/src/main/java/com/hrms/business/concretes/LinkManager.java", "last_update_at": "2021-08-18T23:17:34+00:00", "question_id": "919def75c26c20661ebc949f53445ab95efa46ca", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class LinkManager implements LinkService {\n\t\n\tprivate LinkDao linkDao;\n\t@Autowired\n\tpublic LinkManager(LinkDao linkDao) {\n\t\tsuper();\n\t\tthis.linkDao = linkDao;\n\t}\n\t\n\t@Override\n\tpublic Result add(Link link) {\n\t\tvar result = this.linkDao.save(link);\n\t\tif (result != null) {\n\t\t\treturn new SuccessResult(\"link add ok\");\n\t\t}\n\t\treturn new ErrorResult(\"link add NOT ok\");\n\t}\n\t@Override\n\tpublic DataResult<List<Link>> getAll() {\n\t\tvar result = this.linkDao.findAll();\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get NOT ok\");\n\t}\n\t@Override\n\tpublic DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {\n\t\tvar result = this.linkDao.getByJobSeekerId(jobSeekerId);\n\t\tif (result != null) {\n\t\t\treturn new SuccessDataResult<List<Link>>(result,\"links get by jobSeeker Id ok\");\n\t\t}\n\t\treturn new ErrorDataResult<List<Link>>(\"links get by jobSeeker Id NOT ok\");\n\t}\n"]]}
{"hexsha": "fe322982427c837c12bccb9a2b78b51af11bbe10", "ext": "java", "lang": "Java", "content": "public class DefaultDockerImageMigrationHandlerTest {\n\n    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"bar\").saveNode();\n\n    @Test\n    public void invalidConstructorInput() {\n        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler\n                (null));\n    }\n\n    @Test\n    public void noopMigrationScript() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE);\n    }\n\n    @Test\n    public void effectiveMigration() {\n        URL url = TestURLBuilder.forContent(script(\"input.foo = 'baz';\")).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"foo\", \"baz\"));\n    }\n\n    @Test\n    public void globalStateMustBeCleared() {\n        URL url = TestURLBuilder.forContent(\"var globalVar = 0;\" +\n                script(\"input.cpt = globalVar; globalVar++;\")).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n\n        result = migrationHandler.performMigration(TEST_NODE);\n\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n    }\n\n    @Test\n    public void mustHandleJSONEscapeCharacters() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"{\\\"\\':\").saveNode();\n\n        Node result = migrationHandler.performMigration(testNode);\n\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void mustHandleMultiByteCharSequences() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"\ud83d\ude00\").saveNode();\n\n        Node result = migrationHandler.performMigration(testNode);\n\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void invalidScriptMustThrowException() {\n        URL url = TestURLBuilder.forContent(script(\"throw 'invalid script';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n\n        assertThatExceptionOfType(IllegalArgumentException.class).\n                isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));\n    }\n\n    private String noopScript() {\n        return script(\"\");\n    }\n\n    private String script(String content) {\n        return \"module.exports = function(input) { \" + content + \"};\";\n    }\n}", "class_id": 0, "repo": "JeanRev/TeamcityDockerCloudPlugin", "file": "server/src/test/java/run/var/teamcity/cloud/docker/DefaultDockerImageMigrationHandlerTest.java", "last_update_at": "2021-10-14T10:42:50+00:00", "question_id": "fe322982427c837c12bccb9a2b78b51af11bbe10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultDockerImageMigrationHandlerTest {\n    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"bar\").saveNode();\n    @Test\n    public void invalidConstructorInput() {\n        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler\n                (null));\n    }\n    @Test\n    public void noopMigrationScript() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE);\n    }\n    @Test\n    public void effectiveMigration() {\n        URL url = TestURLBuilder.forContent(script(\"input.foo = 'baz';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"foo\", \"baz\"));\n    }\n    @Test\n    public void globalStateMustBeCleared() {\n        URL url = TestURLBuilder.forContent(\"var globalVar = 0;\" +\n                script(\"input.cpt = globalVar; globalVar++;\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n        result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n    }\n    @Test\n    public void mustHandleJSONEscapeCharacters() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"{\\\"\\':\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n    @Test\n    public void mustHandleMultiByteCharSequences() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"\ud83d\ude00\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n    @Test\n    public void invalidScriptMustThrowException() {\n        URL url = TestURLBuilder.forContent(script(\"throw 'invalid script';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        assertThatExceptionOfType(IllegalArgumentException.class).\n                isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));\n    }\n    private String noopScript() {\n        return script(\"\");\n    }\n    private String script(String content) {\n        return \"module.exports = function(input) { \" + content + \"};\";\n    }\n"]]}
{"hexsha": "312f282becf9715a6ec29fbea270e619ab8bcb3b", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({ \"SpringJavaAutowiringInspection\" })\npublic abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {\n    protected AbstractApplicationContext appContext;\n    protected Class<? extends T> targetArgsClass;\n    protected Class<? extends U> targetReturnTypeClass;\n    protected boolean resolveArgs;\n    protected boolean handleReturnValue;\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);\n\n    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs,\n        boolean handleReturnValue) {\n        this.targetArgsClass = targetArgsClass;\n        this.targetReturnTypeClass = targetReturnTypeClass;\n        this.resolveArgs = resolveArgs;\n        this.handleReturnValue = handleReturnValue;\n    }\n\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter methodParam) {\n        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);\n    }\n\n    @Override\n    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n        throws Exception {\n        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);\n\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(),\n            ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));\n    }\n\n    @Nullable\n    @Override\n    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);\n\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(),\n            ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));\n\n        return argObj;\n    }\n\n    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,\n        NativeWebRequest webRequest) throws Exception {\n    }\n\n    @Nullable\n    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext appContext) throws BeansException {\n        this.appContext = (AbstractApplicationContext) appContext;\n    }\n}", "class_id": 0, "repo": "elizabethso/direct-certificate-discovery-tool", "file": "dcdt-web/src/main/java/gov/hhs/onc/dcdt/web/handler/impl/AbstractToolHandlerMethodProcessor.java", "last_update_at": "2021-06-25T19:17:50+00:00", "question_id": "312f282becf9715a6ec29fbea270e619ab8bcb3b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({ \"SpringJavaAutowiringInspection\" })\npublic abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {\n    protected AbstractApplicationContext appContext;\n    protected Class<? extends T> targetArgsClass;\n    protected Class<? extends U> targetReturnTypeClass;\n    protected boolean resolveArgs;\n    protected boolean handleReturnValue;\n    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);\n    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs,\n        boolean handleReturnValue) {\n        this.targetArgsClass = targetArgsClass;\n        this.targetReturnTypeClass = targetReturnTypeClass;\n        this.resolveArgs = resolveArgs;\n        this.handleReturnValue = handleReturnValue;\n    }\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);\n    }\n    @Override\n    public boolean supportsParameter(MethodParameter methodParam) {\n        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);\n    }\n    @Override\n    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n        throws Exception {\n        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(),\n            ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));\n    }\n    @Nullable\n    @Override\n    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).\",\n            ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(),\n            ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));\n        return argObj;\n    }\n    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,\n        NativeWebRequest webRequest) throws Exception {\n    }\n    @Nullable\n    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest,\n        WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n    @Override\n    public void setApplicationContext(ApplicationContext appContext) throws BeansException {\n        this.appContext = (AbstractApplicationContext) appContext;\n    }\n"]]}
{"hexsha": "82ffa0c5c43034bbc57a5c1a00a6cd9ed811d54a", "ext": "java", "lang": "Java", "content": "public class AWSV4AuthParser implements AWSAuthParser {\n\n  private final static Logger LOG =\n      LoggerFactory.getLogger(AWSV4AuthParser.class);\n  private MultivaluedMap<String, String> headerMap;\n  private MultivaluedMap<String, String> queryMap;\n  private String uri;\n  private String method;\n  private AuthorizationHeaderV4 v4Header;\n  private String stringToSign;\n  private String amzContentPayload;\n\n  public AWSV4AuthParser(ContainerRequestContext context)\n      throws OS3Exception {\n    this.headerMap = context.getHeaders();\n    this.queryMap = context.getUriInfo().getQueryParameters();\n    try {\n      this.uri = new URI(context.getUriInfo().getRequestUri()\n          .getPath().replaceAll(\"\\\\/+\",\n              \"/\")).normalize().getPath();\n    } catch (URISyntaxException e) {\n      throw S3_TOKEN_CREATION_ERROR;\n    }\n\n    this.method = context.getMethod();\n    v4Header = new AuthorizationHeaderV4(\n        headerMap.getFirst(AUTHORIZATION_HEADER));\n  }\n\n  public void parse() throws Exception {\n    StringBuilder strToSign = new StringBuilder();\n\n    // According to AWS sigv4 documentation, authorization header should be\n    // in following format.\n    // Authorization: algorithm Credential=access key ID/credential scope,\n    // SignedHeaders=SignedHeaders, Signature=signature\n\n    // Construct String to sign in below format.\n    // StringToSign =\n    //    Algorithm + \\n +\n    //    RequestDateTime + \\n +\n    //    CredentialScope + \\n +\n    //    HashedCanonicalRequest\n    String algorithm, requestDateTime, credentialScope, canonicalRequest;\n    algorithm = v4Header.getAlgorithm();\n    requestDateTime = headerMap.getFirst(X_AMAZ_DATE);\n    Credential credential = v4Header.getCredentialObj();\n    credentialScope = String.format(\"%s/%s/%s/%s\", credential.getDate(),\n        credential.getAwsRegion(), credential.getAwsService(),\n        credential.getAwsRequest());\n\n    // If the absolute path is empty, use a forward slash (/)\n    uri = (uri.trim().length() > 0) ? uri : \"/\";\n    // Encode URI and preserve forward slashes\n    strToSign.append(algorithm + NEWLINE);\n    strToSign.append(requestDateTime + NEWLINE);\n    strToSign.append(credentialScope + NEWLINE);\n\n    canonicalRequest = buildCanonicalRequest();\n    strToSign.append(hash(canonicalRequest));\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n    }\n\n    if (LOG.isTraceEnabled()) {\n      headerMap.keySet().forEach(k -> LOG.trace(\"Header:{},value:{}\", k,\n          headerMap.get(k)));\n    }\n\n    LOG.debug(\"StringToSign:[{}]\", strToSign);\n    stringToSign = strToSign.toString();\n  }\n\n  private String buildCanonicalRequest() throws OS3Exception {\n    Iterable<String> parts = split(\"/\", uri);\n    List<String> encParts = new ArrayList<>();\n    for (String p : parts) {\n      encParts.add(urlEncode(p));\n    }\n    String canonicalUri = join(\"/\", encParts);\n\n    String canonicalQueryStr = getQueryParamString();\n\n    StringBuilder canonicalHeaders = new StringBuilder();\n\n    for (String header : v4Header.getSignedHeaders()) {\n      List<String> headerValue = new ArrayList<>();\n      canonicalHeaders.append(header.toLowerCase());\n      canonicalHeaders.append(\":\");\n      for (String originalHeader : headerMap.keySet()) {\n        if (originalHeader.toLowerCase().equals(header)) {\n          headerValue.add(headerMap.getFirst(originalHeader).trim());\n        }\n      }\n\n      if (headerValue.size() == 0) {\n        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n            \"request\");\n      }\n      if (headerValue.size() > 1) {\n        Collections.sort(headerValue);\n      }\n\n      // Set for testing purpose only to skip date and host validation.\n      validateSignedHeader(header, headerValue.get(0));\n\n      canonicalHeaders.append(join(\",\", headerValue));\n      canonicalHeaders.append(NEWLINE);\n    }\n\n    String payloadHash;\n    if (UNSIGNED_PAYLOAD.equals(\n        headerMap.get(X_AMZ_CONTENT_SHA256))) {\n      payloadHash = UNSIGNED_PAYLOAD;\n    } else {\n      payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);\n    }\n\n    String signedHeaderStr = v4Header.getSignedHeaderString();\n    String canonicalRequest = method + NEWLINE\n        + canonicalUri + NEWLINE\n        + canonicalQueryStr + NEWLINE\n        + canonicalHeaders + NEWLINE\n        + signedHeaderStr + NEWLINE\n        + payloadHash;\n\n    return canonicalRequest;\n  }\n\n  @VisibleForTesting\n  void validateSignedHeader(String header, String headerValue)\n      throws OS3Exception {\n    switch (header) {\n    case HOST:\n      try {\n        URI hostUri = new URI(headerValue);\n        InetAddress.getByName(hostUri.getHost());\n        // TODO: Validate if current request is coming from same host.\n      } catch (UnknownHostException|URISyntaxException e) {\n        LOG.error(\"Host value mentioned in signed header is not valid. \" +\n            \"Host:{}\", headerValue);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMAZ_DATE:\n      LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);\n      LocalDate now = LocalDate.now();\n      if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))\n          || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS,\n          SECONDS))) {\n        LOG.error(\"AWS date not in valid range. Request timestamp:{} should \" +\n                \"not be older than {} seconds.\", headerValue,\n            PRESIGN_URL_MAX_EXPIRATION_SECONDS);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMZ_CONTENT_SHA256:\n      // TODO: Construct request payload and match HEX(SHA256(requestPayload))\n      break;\n    default:\n      break;\n    }\n  }\n\n  /**\n   * String join that also works with empty strings.\n   *\n   * @return joined string\n   */\n  private static String join(String glue, List<String> parts) {\n    StringBuilder result = new StringBuilder();\n    boolean addSeparator = false;\n    for (String p : parts) {\n      if (addSeparator) {\n        result.append(glue);\n      }\n      result.append(p);\n      addSeparator = true;\n    }\n    return result.toString();\n  }\n\n  /**\n   * Returns matching strings.\n   *\n   * @param regex Regular expression to split by\n   * @param whole The string to split\n   * @return pieces\n   */\n  private static Iterable<String> split(String regex, String whole) {\n    Pattern p = Pattern.compile(regex);\n    Matcher m = p.matcher(whole);\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    while (m.find()) {\n      result.add(whole.substring(pos, m.start()));\n      pos = m.end();\n    }\n    result.add(whole.substring(pos));\n    return result;\n  }\n\n  private String urlEncode(String str) {\n    try {\n\n      return URLEncoder.encode(str, UTF_8.name())\n          .replaceAll(\"\\\\+\", \"%20\")\n          .replaceAll(\"%7E\", \"~\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private String getQueryParamString() {\n    List<String> params = new ArrayList<>(queryMap.keySet());\n\n    // Sort by name, then by value\n    Collections.sort(params, (o1, o2) -> o1.equals(o2) ?\n        queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) :\n        o1.compareTo(o2));\n\n    StringBuilder result = new StringBuilder();\n    for (String p : params) {\n      if (result.length() > 0) {\n        result.append(\"&\");\n      }\n      result.append(urlEncode(p));\n      result.append('=');\n\n      result.append(urlEncode(queryMap.getFirst(p)));\n    }\n    return result.toString();\n  }\n\n  public static String hash(String payload) throws NoSuchAlgorithmException {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(payload.getBytes(UTF_8));\n    return Hex.encode(md.digest()).toLowerCase();\n  }\n\n  public String getAwsAccessId() {\n    return v4Header.getAccessKeyID();\n  }\n\n  public String getSignature() {\n    return v4Header.getSignature();\n  }\n\n  public String getStringToSign() throws Exception {\n    return stringToSign;\n  }\n}", "class_id": 0, "repo": "mohammadjkhan/hadoop-ozone", "file": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/AWSV4AuthParser.java", "last_update_at": "2021-09-02T16:12:45+00:00", "question_id": "82ffa0c5c43034bbc57a5c1a00a6cd9ed811d54a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AWSV4AuthParser implements AWSAuthParser {\n  private final static Logger LOG =\n      LoggerFactory.getLogger(AWSV4AuthParser.class);\n  private MultivaluedMap<String, String> headerMap;\n  private MultivaluedMap<String, String> queryMap;\n  private String uri;\n  private String method;\n  private AuthorizationHeaderV4 v4Header;\n  private String stringToSign;\n  private String amzContentPayload;\n  public AWSV4AuthParser(ContainerRequestContext context)\n      throws OS3Exception {\n    this.headerMap = context.getHeaders();\n    this.queryMap = context.getUriInfo().getQueryParameters();\n    try {\n      this.uri = new URI(context.getUriInfo().getRequestUri()\n          .getPath().replaceAll(\"\\\\/+\",\n              \"/\")).normalize().getPath();\n    } catch (URISyntaxException e) {\n      throw S3_TOKEN_CREATION_ERROR;\n    }\n    this.method = context.getMethod();\n    v4Header = new AuthorizationHeaderV4(\n        headerMap.getFirst(AUTHORIZATION_HEADER));\n  }\n  public void parse() throws Exception {\n    StringBuilder strToSign = new StringBuilder();\n    // According to AWS sigv4 documentation, authorization header should be\n    // in following format.\n    // Authorization: algorithm Credential=access key ID/credential scope,\n    // SignedHeaders=SignedHeaders, Signature=signature\n    // Construct String to sign in below format.\n    // StringToSign =\n    //    Algorithm + \\n +\n    //    RequestDateTime + \\n +\n    //    CredentialScope + \\n +\n    //    HashedCanonicalRequest\n    String algorithm, requestDateTime, credentialScope, canonicalRequest;\n    algorithm = v4Header.getAlgorithm();\n    requestDateTime = headerMap.getFirst(X_AMAZ_DATE);\n    Credential credential = v4Header.getCredentialObj();\n    credentialScope = String.format(\"%s/%s/%s/%s\", credential.getDate(),\n        credential.getAwsRegion(), credential.getAwsService(),\n        credential.getAwsRequest());\n    // If the absolute path is empty, use a forward slash (/)\n    uri = (uri.trim().length() > 0) ? uri : \"/\";\n    // Encode URI and preserve forward slashes\n    strToSign.append(algorithm + NEWLINE);\n    strToSign.append(requestDateTime + NEWLINE);\n    strToSign.append(credentialScope + NEWLINE);\n    canonicalRequest = buildCanonicalRequest();\n    strToSign.append(hash(canonicalRequest));\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n    }\n    if (LOG.isTraceEnabled()) {\n      headerMap.keySet().forEach(k -> LOG.trace(\"Header:{},value:{}\", k,\n          headerMap.get(k)));\n    }\n    LOG.debug(\"StringToSign:[{}]\", strToSign);\n    stringToSign = strToSign.toString();\n  }\n  private String buildCanonicalRequest() throws OS3Exception {\n    Iterable<String> parts = split(\"/\", uri);\n    List<String> encParts = new ArrayList<>();\n    for (String p : parts) {\n      encParts.add(urlEncode(p));\n    }\n    String canonicalUri = join(\"/\", encParts);\n    String canonicalQueryStr = getQueryParamString();\n    StringBuilder canonicalHeaders = new StringBuilder();\n    for (String header : v4Header.getSignedHeaders()) {\n      List<String> headerValue = new ArrayList<>();\n      canonicalHeaders.append(header.toLowerCase());\n      canonicalHeaders.append(\":\");\n      for (String originalHeader : headerMap.keySet()) {\n        if (originalHeader.toLowerCase().equals(header)) {\n          headerValue.add(headerMap.getFirst(originalHeader).trim());\n        }\n      }\n      if (headerValue.size() == 0) {\n        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n            \"request\");\n      }\n      if (headerValue.size() > 1) {\n        Collections.sort(headerValue);\n      }\n      // Set for testing purpose only to skip date and host validation.\n      validateSignedHeader(header, headerValue.get(0));\n      canonicalHeaders.append(join(\",\", headerValue));\n      canonicalHeaders.append(NEWLINE);\n    }\n    String payloadHash;\n    if (UNSIGNED_PAYLOAD.equals(\n        headerMap.get(X_AMZ_CONTENT_SHA256))) {\n      payloadHash = UNSIGNED_PAYLOAD;\n    } else {\n      payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);\n    }\n    String signedHeaderStr = v4Header.getSignedHeaderString();\n    String canonicalRequest = method + NEWLINE\n        + canonicalUri + NEWLINE\n        + canonicalQueryStr + NEWLINE\n        + canonicalHeaders + NEWLINE\n        + signedHeaderStr + NEWLINE\n        + payloadHash;\n    return canonicalRequest;\n  }\n  @VisibleForTesting\n  void validateSignedHeader(String header, String headerValue)\n      throws OS3Exception {\n    switch (header) {\n    case HOST:\n      try {\n        URI hostUri = new URI(headerValue);\n        InetAddress.getByName(hostUri.getHost());\n        // TODO: Validate if current request is coming from same host.\n      } catch (UnknownHostException|URISyntaxException e) {\n        LOG.error(\"Host value mentioned in signed header is not valid. \" +\n            \"Host:{}\", headerValue);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMAZ_DATE:\n      LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);\n      LocalDate now = LocalDate.now();\n      if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))\n          || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS,\n          SECONDS))) {\n        LOG.error(\"AWS date not in valid range. Request timestamp:{} should \" +\n                \"not be older than {} seconds.\", headerValue,\n            PRESIGN_URL_MAX_EXPIRATION_SECONDS);\n        throw S3_TOKEN_CREATION_ERROR;\n      }\n      break;\n    case X_AMZ_CONTENT_SHA256:\n      // TODO: Construct request payload and match HEX(SHA256(requestPayload))\n      break;\n    default:\n      break;\n    }\n  }\n  /**\n   * String join that also works with empty strings.\n   *\n   * @return joined string\n   */\n  private static String join(String glue, List<String> parts) {\n    StringBuilder result = new StringBuilder();\n    boolean addSeparator = false;\n    for (String p : parts) {\n      if (addSeparator) {\n        result.append(glue);\n      }\n      result.append(p);\n      addSeparator = true;\n    }\n    return result.toString();\n  }\n  /**\n   * Returns matching strings.\n   *\n   * @param regex Regular expression to split by\n   * @param whole The string to split\n   * @return pieces\n   */\n  private static Iterable<String> split(String regex, String whole) {\n    Pattern p = Pattern.compile(regex);\n    Matcher m = p.matcher(whole);\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    while (m.find()) {\n      result.add(whole.substring(pos, m.start()));\n      pos = m.end();\n    }\n    result.add(whole.substring(pos));\n    return result;\n  }\n  private String urlEncode(String str) {\n    try {\n      return URLEncoder.encode(str, UTF_8.name())\n          .replaceAll(\"\\\\+\", \"%20\")\n          .replaceAll(\"%7E\", \"~\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private String getQueryParamString() {\n    List<String> params = new ArrayList<>(queryMap.keySet());\n    // Sort by name, then by value\n    Collections.sort(params, (o1, o2) -> o1.equals(o2) ?\n        queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) :\n        o1.compareTo(o2));\n    StringBuilder result = new StringBuilder();\n    for (String p : params) {\n      if (result.length() > 0) {\n        result.append(\"&\");\n      }\n      result.append(urlEncode(p));\n      result.append('=');\n      result.append(urlEncode(queryMap.getFirst(p)));\n    }\n    return result.toString();\n  }\n  public static String hash(String payload) throws NoSuchAlgorithmException {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(payload.getBytes(UTF_8));\n    return Hex.encode(md.digest()).toLowerCase();\n  }\n  public String getAwsAccessId() {\n    return v4Header.getAccessKeyID();\n  }\n  public String getSignature() {\n    return v4Header.getSignature();\n  }\n  public String getStringToSign() throws Exception {\n    return stringToSign;\n  }\n"]]}
{"hexsha": "f162c0c0620935df0e24658be449595dcc99b9e7", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest(classes={ShiroAdminApplication.class})// \u6307\u5b9a\u542f\u52a8\u7c7b\npublic class MonsterlanApplicationTests {\n    @Autowired\n    DataSourceProperties dataSourceProperties;\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    @Test\n    public void contextLoads() {\n        // \u83b7\u53d6\u914d\u7f6e\u7684\u6570\u636e\u6e90\n        DataSource dataSource = applicationContext.getBean(DataSource.class);\n        // \u67e5\u770b\u914d\u7f6e\u6570\u636e\u6e90\u4fe1\u606f\n        //System.out.println(dataSource);\n        //System.out.println(data/Source.getClass().getName());\n        System.out.println(dataSourceProperties.getUrl());\n    }\n}", "class_id": 0, "repo": "supertonsystem/project_management", "file": "shiro-admin/src/test/java/com/suteng/shiro/MonsterlanApplicationTests.java", "last_update_at": "2021-09-24T14:40:48+00:00", "question_id": "f162c0c0620935df0e24658be449595dcc99b9e7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest(classes={ShiroAdminApplication.class})// \u6307\u5b9a\u542f\u52a8\u7c7b\npublic class MonsterlanApplicationTests {\n    @Autowired\n    DataSourceProperties dataSourceProperties;\n    @Autowired\n    ApplicationContext applicationContext;\n    @Test\n    public void contextLoads() {\n        // \u83b7\u53d6\u914d\u7f6e\u7684\u6570\u636e\u6e90\n        DataSource dataSource = applicationContext.getBean(DataSource.class);\n        // \u67e5\u770b\u914d\u7f6e\u6570\u636e\u6e90\u4fe1\u606f\n        //System.out.println(dataSource);\n        //System.out.println(data/Source.getClass().getName());\n        System.out.println(dataSourceProperties.getUrl());\n    }\n"]]}
{"hexsha": "5d1826baaf2a8d3a3ee04fea5ba7cdaf784abf75", "ext": "java", "lang": "Java", "content": "public class PaymentPlansApi {\n    private ApiClient apiClient;\n\n    public PaymentPlansApi() {\n        this(Environment.getGlobalEnv().getApiClient());\n    }\n\n    public PaymentPlansApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    /**\n     * Build call for paymentPlansGet\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        if (count != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"count\", count));\n        if (offset != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"offset\", offset));\n        if (fields != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"fields\", fields));\n        if (q != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"q\", q));\n        if (sort != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"sort\", sort));\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n\n        return paymentPlansGetCall(count, offset, fields, q, sort);\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return PaymentPlansList\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return ApiResponse&lt;PaymentPlansList&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans (asynchronously)\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansGetById\n     * @param paymentPlanId Payment plan id (required)\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {\n        Object localVarPostBody = null;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)\");\n        }\n\n        return paymentPlansGetByIdCall(paymentPlanId);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId} (asynchronously)\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPatch\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)\");\n        }\n\n        return paymentPlansPatchCall(paymentPlanId, body);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPost\n     * @param body Payment plan properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {\n\n        return paymentPlansPostCall(body);\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);\n        return resp.getData();\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * POST Payment/Plans (asynchronously)\n     * Add new plan\n     * @param body Payment plan properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPut\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)\");\n        }\n\n        return paymentPlansPutCall(paymentPlanId, body);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}", "class_id": 0, "repo": "secuconnect/secuconnect-java-sdk", "file": "src/main/java/com/secuconnect/client/api/PaymentPlansApi.java", "last_update_at": "2021-12-13T21:45:02+00:00", "question_id": "5d1826baaf2a8d3a3ee04fea5ba7cdaf784abf75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PaymentPlansApi {\n    private ApiClient apiClient;\n    public PaymentPlansApi() {\n        this(Environment.getGlobalEnv().getApiClient());\n    }\n    public PaymentPlansApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n    /**\n     * Build call for paymentPlansGet\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        if (count != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"count\", count));\n        if (offset != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"offset\", offset));\n        if (fields != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"fields\", fields));\n        if (q != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"q\", q));\n        if (sort != null)\n        localVarQueryParams.addAll(apiClient.parameterToPair(\"sort\", sort));\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        return paymentPlansGetCall(count, offset, fields, q, sort);\n    }\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return PaymentPlansList\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);\n        return resp.getData();\n    }\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return ApiResponse&lt;PaymentPlansList&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * GET Payment/Plans (asynchronously)\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansGetById\n     * @param paymentPlanId Payment plan id (required)\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)\");\n        }\n        return paymentPlansGetByIdCall(paymentPlanId);\n    }\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);\n        return resp.getData();\n    }\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * GET Payment/Plans/{paymentPlanId} (asynchronously)\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansPatch\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)\");\n        }\n        return paymentPlansPatchCall(paymentPlanId, body);\n    }\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansPost\n     * @param body Payment plan properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {\n        return paymentPlansPostCall(body);\n    }\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);\n        return resp.getData();\n    }\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * POST Payment/Plans (asynchronously)\n     * Add new plan\n     * @param body Payment plan properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n    /**\n     * Build call for paymentPlansPut\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\"\n            .replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = {\n            \"application/json\"\n        };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null) localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {\n            \"application/json\"\n        };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)\");\n        }\n        return paymentPlansPutCall(paymentPlanId, body);\n    }\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n    /**\n     * PUT Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>(){}.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n"]]}
{"hexsha": "343375c62eaba4f174329b4d7593ae534bc80666", "ext": "java", "lang": "Java", "content": "public class IOHelper {\n\n    public static void copy(Reader in, Writer out) throws IOException {\n        int c = -1;\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    }\n\n    public static String readFile(File file) throws IOException {\n        Reader in = new FileReader(file);\n        StringWriter out = new StringWriter();\n        copy(in, out);\n        return out.toString();\n    }\n\n    public static void saveFile(File file, String content) throws IOException {\n        Writer writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n}", "class_id": 0, "repo": "uupu/CodeWrench", "file": "src/main/java/com/uupu/wrench/util/IOHelper.java", "last_update_at": "2021-11-25T09:58:54+00:00", "question_id": "343375c62eaba4f174329b4d7593ae534bc80666", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IOHelper {\n    public static void copy(Reader in, Writer out) throws IOException {\n        int c = -1;\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    }\n    public static String readFile(File file) throws IOException {\n        Reader in = new FileReader(file);\n        StringWriter out = new StringWriter();\n        copy(in, out);\n        return out.toString();\n    }\n    public static void saveFile(File file, String content) throws IOException {\n        Writer writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n"]]}
{"hexsha": "5494e9ba86572e92df36c029d9a6c0fb67dd4722", "ext": "java", "lang": "Java", "content": "@XmlRootElement\npublic class IssueUpdates {\n    @XmlElement(name = \"issueUpdate\")\n    public final List<IssueUpdate> issueUpdates = new ArrayList<>();\n\n    @Override\n    public boolean equals(Object otherObject) {\n        return this == otherObject\n            || (otherObject instanceof IssueUpdates\n                && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(issueUpdates);\n    }\n\n    public static class IssueUpdate {\n        public @Nullable String issueKey;\n        public @Nullable Issue issue;\n\n        @Override\n        public boolean equals(@Nullable Object otherObject) {\n            if (this == otherObject) {\n                return true;\n            } else if (otherObject == null || getClass() != otherObject.getClass()) {\n                return false;\n            }\n\n            IssueUpdate other = (IssueUpdate) otherObject;\n            return Objects.equals(issueKey, other.issueKey)\n                && Objects.equals(issue, other.issue);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(issueKey, issue);\n        }\n    }\n}", "class_id": 0, "repo": "fschopp/asana-to-youtrack", "file": "issue-tracking-youtrack/src/main/java/net/florianschoppmann/issuetracking/youtrack/IssueUpdates.java", "last_update_at": "2021-12-07T18:28:16+00:00", "question_id": "5494e9ba86572e92df36c029d9a6c0fb67dd4722", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@XmlRootElement\npublic class IssueUpdates {\n    @XmlElement(name = \"issueUpdate\")\n    public final List<IssueUpdate> issueUpdates = new ArrayList<>();\n    @Override\n    public boolean equals(Object otherObject) {\n        return this == otherObject\n            || (otherObject instanceof IssueUpdates\n                && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(issueUpdates);\n    }\n    public static class IssueUpdate {\n        public @Nullable String issueKey;\n        public @Nullable Issue issue;\n        @Override\n        public boolean equals(@Nullable Object otherObject) {\n            if (this == otherObject) {\n                return true;\n            } else if (otherObject == null || getClass() != otherObject.getClass()) {\n                return false;\n            }\n            IssueUpdate other = (IssueUpdate) otherObject;\n            return Objects.equals(issueKey, other.issueKey)\n                && Objects.equals(issue, other.issue);\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(issueKey, issue);\n        }\n    }\n"]]}
{"hexsha": "4731e4fd483b82796b665b993ea78c300897dbb5", "ext": "java", "lang": "Java", "content": "public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {\n\n  /**\n   * the logging facility provided by log4j\n   */\n  private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return type.equals(MediaPackageElement.Type.Track);\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)\n   */\n  @Override\n  public boolean accept(Node elementNode) {\n    String name = elementNode.getNodeName();\n    if (name.contains(\":\")) {\n      name = name.substring(name.indexOf(\":\") + 1);\n    }\n    return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,\n   *      org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return MediaPackageElement.Type.Track.equals(type);\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)\n   */\n  @Override\n  public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {\n    logger.trace(\"Creating track from \" + uri);\n    Track track = TrackImpl.fromURI(uri);\n    return track;\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type\n   *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    Track track = new TrackImpl();\n    track.setFlavor(flavor);\n    return track;\n  }\n\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,\n   *      org.opencastproject.mediapackage.MediaPackageSerializer)\n   */\n  @Override\n  public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer)\n          throws UnsupportedElementException {\n\n    String id = null;\n    MimeType mimeType = null;\n    MediaPackageElementFlavor flavor = null;\n    TrackImpl.StreamingProtocol transport = null;\n    String reference = null;\n    URI url = null;\n    long size = -1;\n    Checksum checksum = null;\n\n    try {\n      // id\n      id = (String) xpath.evaluate(\"@id\", elementNode, XPathConstants.STRING);\n\n      // url\n      url = serializer.decodeURI(new URI(xpath.evaluate(\"url/text()\", elementNode).trim()));\n\n      // reference\n      reference = (String) xpath.evaluate(\"@ref\", elementNode, XPathConstants.STRING);\n\n      // size\n      String trackSize = xpath.evaluate(\"size/text()\", elementNode).trim();\n      if (!\"\".equals(trackSize))\n        size = Long.parseLong(trackSize);\n\n      // flavor\n      String flavorValue = (String) xpath.evaluate(\"@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(flavorValue))\n        flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);\n\n      // transport\n      String transportValue = (String) xpath.evaluate(\"@transport\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(transportValue))\n        transport = TrackImpl.StreamingProtocol.valueOf(transportValue);\n\n      // checksum\n      String checksumValue = (String) xpath.evaluate(\"checksum/text()\", elementNode, XPathConstants.STRING);\n      String checksumType = (String) xpath.evaluate(\"checksum/@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)\n        checksum = Checksum.create(checksumType.trim(), checksumValue.trim());\n\n      // mimetype\n      String mimeTypeValue = (String) xpath.evaluate(\"mimetype/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(mimeTypeValue))\n        mimeType = MimeTypes.parseMimeType(mimeTypeValue);\n\n      //\n      // Build the track\n\n      TrackImpl track = TrackImpl.fromURI(url);\n\n      if (StringUtils.isNotBlank(id))\n        track.setIdentifier(id);\n\n      // Add url\n      track.setURI(url);\n\n      // Add reference\n      if (StringUtils.isNotEmpty(reference))\n        track.referTo(MediaPackageReferenceImpl.fromString(reference));\n\n      // Set size\n      if (size > 0)\n        track.setSize(size);\n\n      // Set checksum\n      if (checksum != null)\n        track.setChecksum(checksum);\n\n      // Set mimetpye\n      if (mimeType != null)\n        track.setMimeType(mimeType);\n\n      if (flavor != null)\n        track.setFlavor(flavor);\n\n      //set transport\n      if (transport != null)\n        track.setTransport(transport);\n\n      // description\n      String description = (String) xpath.evaluate(\"description/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotBlank(description))\n        track.setElementDescription(description.trim());\n\n      // tags\n      NodeList tagNodes = (NodeList) xpath.evaluate(\"tags/tag\", elementNode, XPathConstants.NODESET);\n      for (int i = 0; i < tagNodes.getLength(); i++) {\n        track.addTag(tagNodes.item(i).getTextContent());\n      }\n\n      // duration\n      try {\n        String strDuration = (String) xpath.evaluate(\"duration/text()\", elementNode, XPathConstants.STRING);\n        if (StringUtils.isNotEmpty(strDuration)) {\n          long duration = Long.parseLong(strDuration.trim());\n          track.setDuration(duration);\n        }\n      } catch (NumberFormatException e) {\n        throw new UnsupportedElementException(\"Duration of track \" + url + \" is malformatted\");\n      }\n\n      // is live\n      String strLive = (String) xpath.evaluate(\"live/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(strLive)) {\n        boolean live = Boolean.parseBoolean(strLive.trim());\n        track.setLive(live);\n      }\n\n      // audio settings\n      Node audioSettingsNode = (Node) xpath.evaluate(\"audio\", elementNode, XPathConstants.NODE);\n      if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {\n        try {\n          AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);\n          track.addStream(as);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading audio settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing audio settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n\n      // video settings\n      Node videoSettingsNode = (Node) xpath.evaluate(\"video\", elementNode, XPathConstants.NODE);\n      if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {\n        try {\n          VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);\n          track.addStream(vs);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading video settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing video settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n\n      return track;\n    } catch (XPathExpressionException e) {\n      throw new UnsupportedElementException(\"Error while reading track information from manifest: \" + e.getMessage());\n    } catch (NoSuchAlgorithmException e) {\n      throw new UnsupportedElementException(\"Unsupported digest algorithm: \" + e.getMessage());\n    } catch (URISyntaxException e) {\n      throw new UnsupportedElementException(\"Error while reading presenter track \" + url + \": \" + e.getMessage());\n    }\n  }\n\n  private String createStreamID(Track track) {\n    return \"stream-\" + (track.getStreams().length + 1);\n  }\n\n  @Override\n  public String toString() {\n    return \"Track Builder Plugin\";\n  }\n\n}", "class_id": 0, "repo": "Rillke/opencast", "file": "modules/common/src/main/java/org/opencastproject/mediapackage/elementbuilder/TrackBuilderPlugin.java", "last_update_at": "2021-07-10T13:16:24+00:00", "question_id": "4731e4fd483b82796b665b993ea78c300897dbb5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {\n  /**\n   * the logging facility provided by log4j\n   */\n  private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return type.equals(MediaPackageElement.Type.Track);\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)\n   */\n  @Override\n  public boolean accept(Node elementNode) {\n    String name = elementNode.getNodeName();\n    if (name.contains(\":\")) {\n      name = name.substring(name.indexOf(\":\") + 1);\n    }\n    return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,\n   *      org.opencastproject.mediapackage.MediaPackageElement.Type,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    return MediaPackageElement.Type.Track.equals(type);\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)\n   */\n  @Override\n  public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {\n    logger.trace(\"Creating track from \" + uri);\n    Track track = TrackImpl.fromURI(uri);\n    return track;\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type\n   *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)\n   */\n  @Override\n  public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    Track track = new TrackImpl();\n    track.setFlavor(flavor);\n    return track;\n  }\n  /**\n   * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,\n   *      org.opencastproject.mediapackage.MediaPackageSerializer)\n   */\n  @Override\n  public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer)\n          throws UnsupportedElementException {\n    String id = null;\n    MimeType mimeType = null;\n    MediaPackageElementFlavor flavor = null;\n    TrackImpl.StreamingProtocol transport = null;\n    String reference = null;\n    URI url = null;\n    long size = -1;\n    Checksum checksum = null;\n    try {\n      // id\n      id = (String) xpath.evaluate(\"@id\", elementNode, XPathConstants.STRING);\n      // url\n      url = serializer.decodeURI(new URI(xpath.evaluate(\"url/text()\", elementNode).trim()));\n      // reference\n      reference = (String) xpath.evaluate(\"@ref\", elementNode, XPathConstants.STRING);\n      // size\n      String trackSize = xpath.evaluate(\"size/text()\", elementNode).trim();\n      if (!\"\".equals(trackSize))\n        size = Long.parseLong(trackSize);\n      // flavor\n      String flavorValue = (String) xpath.evaluate(\"@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(flavorValue))\n        flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);\n      // transport\n      String transportValue = (String) xpath.evaluate(\"@transport\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(transportValue))\n        transport = TrackImpl.StreamingProtocol.valueOf(transportValue);\n      // checksum\n      String checksumValue = (String) xpath.evaluate(\"checksum/text()\", elementNode, XPathConstants.STRING);\n      String checksumType = (String) xpath.evaluate(\"checksum/@type\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)\n        checksum = Checksum.create(checksumType.trim(), checksumValue.trim());\n      // mimetype\n      String mimeTypeValue = (String) xpath.evaluate(\"mimetype/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(mimeTypeValue))\n        mimeType = MimeTypes.parseMimeType(mimeTypeValue);\n      //\n      // Build the track\n      TrackImpl track = TrackImpl.fromURI(url);\n      if (StringUtils.isNotBlank(id))\n        track.setIdentifier(id);\n      // Add url\n      track.setURI(url);\n      // Add reference\n      if (StringUtils.isNotEmpty(reference))\n        track.referTo(MediaPackageReferenceImpl.fromString(reference));\n      // Set size\n      if (size > 0)\n        track.setSize(size);\n      // Set checksum\n      if (checksum != null)\n        track.setChecksum(checksum);\n      // Set mimetpye\n      if (mimeType != null)\n        track.setMimeType(mimeType);\n      if (flavor != null)\n        track.setFlavor(flavor);\n      //set transport\n      if (transport != null)\n        track.setTransport(transport);\n      // description\n      String description = (String) xpath.evaluate(\"description/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotBlank(description))\n        track.setElementDescription(description.trim());\n      // tags\n      NodeList tagNodes = (NodeList) xpath.evaluate(\"tags/tag\", elementNode, XPathConstants.NODESET);\n      for (int i = 0; i < tagNodes.getLength(); i++) {\n        track.addTag(tagNodes.item(i).getTextContent());\n      }\n      // duration\n      try {\n        String strDuration = (String) xpath.evaluate(\"duration/text()\", elementNode, XPathConstants.STRING);\n        if (StringUtils.isNotEmpty(strDuration)) {\n          long duration = Long.parseLong(strDuration.trim());\n          track.setDuration(duration);\n        }\n      } catch (NumberFormatException e) {\n        throw new UnsupportedElementException(\"Duration of track \" + url + \" is malformatted\");\n      }\n      // is live\n      String strLive = (String) xpath.evaluate(\"live/text()\", elementNode, XPathConstants.STRING);\n      if (StringUtils.isNotEmpty(strLive)) {\n        boolean live = Boolean.parseBoolean(strLive.trim());\n        track.setLive(live);\n      }\n      // audio settings\n      Node audioSettingsNode = (Node) xpath.evaluate(\"audio\", elementNode, XPathConstants.NODE);\n      if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {\n        try {\n          AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);\n          track.addStream(as);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading audio settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing audio settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n      // video settings\n      Node videoSettingsNode = (Node) xpath.evaluate(\"video\", elementNode, XPathConstants.NODE);\n      if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {\n        try {\n          VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);\n          track.addStream(vs);\n        } catch (IllegalStateException e) {\n          throw new UnsupportedElementException(\"Illegal state encountered while reading video settings from \" + url\n                  + \": \" + e.getMessage());\n        } catch (XPathException e) {\n          throw new UnsupportedElementException(\"Error while parsing video settings from \" + url + \": \"\n                  + e.getMessage());\n        }\n      }\n      return track;\n    } catch (XPathExpressionException e) {\n      throw new UnsupportedElementException(\"Error while reading track information from manifest: \" + e.getMessage());\n    } catch (NoSuchAlgorithmException e) {\n      throw new UnsupportedElementException(\"Unsupported digest algorithm: \" + e.getMessage());\n    } catch (URISyntaxException e) {\n      throw new UnsupportedElementException(\"Error while reading presenter track \" + url + \": \" + e.getMessage());\n    }\n  }\n  private String createStreamID(Track track) {\n    return \"stream-\" + (track.getStreams().length + 1);\n  }\n  @Override\n  public String toString() {\n    return \"Track Builder Plugin\";\n  }\n"]]}
{"hexsha": "cd257f0dce4bba1a21fbdb15fd284702dd48600f", "ext": "java", "lang": "Java", "content": "public class SimpleBlockingQueueTest {\n    @Test\n    public void whenUseBlockingQueue() {\n//        SimpleBlockingQueue<Integer> testQueue = new SimpleBlockingQueue<Integer>();\n//\n//        Thread producer = new Thread(() -> {\n//            for (int i = 0; i <= 20;) {\n//                testQueue.offer(++i);\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \" + i);\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        Thread consumer = new Thread(() -> {\n//            try {\n//                Thread.sleep(1000);\n//            } catch (InterruptedException e) {\n//                e.printStackTrace();\n//            }\n//            for (int i = 1; i <= 20; i++) {\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u044b\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u0435\u0442 \" + testQueue.poll());\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        consumer.start();\n//        producer.start();\n//        try {\n//            consumer.join();\n//            producer.join();\n//        } catch (InterruptedException e) {\n//            e.printStackTrace();\n//        }\n    }\n}", "class_id": 0, "repo": "NURGALIMOV/inurgalimov", "file": "level_junior_002/src/test/java/ru/inurgalimov/wait/SimpleBlockingQueueTest.java", "last_update_at": "2021-12-14T21:18:26+00:00", "question_id": "cd257f0dce4bba1a21fbdb15fd284702dd48600f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimpleBlockingQueueTest {\n    @Test\n    public void whenUseBlockingQueue() {\n//        SimpleBlockingQueue<Integer> testQueue = new SimpleBlockingQueue<Integer>();\n//\n//        Thread producer = new Thread(() -> {\n//            for (int i = 0; i <= 20;) {\n//                testQueue.offer(++i);\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \" + i);\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        Thread consumer = new Thread(() -> {\n//            try {\n//                Thread.sleep(1000);\n//            } catch (InterruptedException e) {\n//                e.printStackTrace();\n//            }\n//            for (int i = 1; i <= 20; i++) {\n//                System.out.println(Thread.currentThread().getName() + \" \u0432\u044b\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u0435\u0442 \" + testQueue.poll());\n//                try {\n//                    Thread.sleep(1000);\n//                } catch (InterruptedException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n//            Thread.currentThread().interrupt();\n//        });\n//        consumer.start();\n//        producer.start();\n//        try {\n//            consumer.join();\n//            producer.join();\n//        } catch (InterruptedException e) {\n//            e.printStackTrace();\n//        }\n    }\n"]]}
{"hexsha": "2fdee659338464d3cee41b3776ec8893a1c5cafb", "ext": "java", "lang": "Java", "content": "public class HttpClientUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);\n\t\n    public static CloseableHttpClient getHttpClient (HasProxySettings proxySetting) {\n    \t// http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e475\n    \t\n    \tCloseableHttpClient httpclient = null ;\n    \tif (proxySetting != null && proxySetting.isActive()) {\n    \t\tlogger.info(\"Set the http proxy (\" + proxySetting.getHost() + \":\" + proxySetting.getPort() + \")\") ;\n    \t\tCredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider()) ;\n        \tHttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());\n        \tDefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);\n        \thttpclient = HttpClients.custom()\n        \t        .setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider)\n        \t        .build();\n    \t} else {\n    \t\thttpclient = HttpClients.createDefault();\n    \t}\n    \treturn httpclient ;\n    }\n}", "class_id": 0, "repo": "hjg0706/google_Drive", "file": "src/main/java/io/uploader/drive/drive/largefile/HttpClientUtils.java", "last_update_at": "2021-11-27T05:58:07+00:00", "question_id": "2fdee659338464d3cee41b3776ec8893a1c5cafb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HttpClientUtils {\n\tprivate static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);\n\t\n    public static CloseableHttpClient getHttpClient (HasProxySettings proxySetting) {\n    \t// http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e475\n    \t\n    \tCloseableHttpClient httpclient = null ;\n    \tif (proxySetting != null && proxySetting.isActive()) {\n    \t\tlogger.info(\"Set the http proxy (\" + proxySetting.getHost() + \":\" + proxySetting.getPort() + \")\") ;\n    \t\tCredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider()) ;\n        \tHttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());\n        \tDefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);\n        \thttpclient = HttpClients.custom()\n        \t        .setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider)\n        \t        .build();\n    \t} else {\n    \t\thttpclient = HttpClients.createDefault();\n    \t}\n    \treturn httpclient ;\n    }\n"]]}
{"hexsha": "382e9cd082afd4101e37c36d08eb9143aed3b34e", "ext": "java", "lang": "Java", "content": "public class Resources {\n  public static Path getResourcePath(String path) throws URISyntaxException {\n    ClassLoader classLoader = Stream\n        .of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null)\n        .findFirst().get();\n\n    return Paths.get(classLoader.getResource(path).toURI());\n  }\n\n  public static String getResource(String file) throws IOException, URISyntaxException {\n    Path path = getResourcePath(file);\n    return new String(Files.readAllBytes(path));\n  }\n\n  public static List<String> listResources(String dir) throws IOException, URISyntaxException {\n    Path dirpath = getResourcePath(dir);\n\n    List<String> filenames = null;\n\n    try (Stream<Path> walk = Files.walk(dirpath)) {\n      filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString())\n          .collect(Collectors.toList());\n    } catch (IOException e) {\n      throw e;\n    }\n\n    return filenames;\n  }\n}", "class_id": 0, "repo": "craft-ai/craft-ai-client-java", "file": "src/test/java/com/craft_ai/interpreter/tools/Resources.java", "last_update_at": "2021-12-09T21:16:39+00:00", "question_id": "382e9cd082afd4101e37c36d08eb9143aed3b34e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Resources {\n  public static Path getResourcePath(String path) throws URISyntaxException {\n    ClassLoader classLoader = Stream\n        .of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null)\n        .findFirst().get();\n    return Paths.get(classLoader.getResource(path).toURI());\n  }\n  public static String getResource(String file) throws IOException, URISyntaxException {\n    Path path = getResourcePath(file);\n    return new String(Files.readAllBytes(path));\n  }\n  public static List<String> listResources(String dir) throws IOException, URISyntaxException {\n    Path dirpath = getResourcePath(dir);\n    List<String> filenames = null;\n    try (Stream<Path> walk = Files.walk(dirpath)) {\n      filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString())\n          .collect(Collectors.toList());\n    } catch (IOException e) {\n      throw e;\n    }\n    return filenames;\n  }\n"]]}
{"hexsha": "1933efc9aa1b1d5e9b432865d575e9d6ff573c10", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"api/v1\")\npublic class CollaboratorController {\n\n\t@Autowired\n\tCollaboratorService collaboratorServ;\n\t\n\t@ApiOperation(value = \"Get All the Collaborators\")\n\t@GetMapping(\"/collaborators\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators(){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaborators();\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\n\t@ApiOperation(value = \"Get Collaborators by Organization\")\n\t@GetMapping(\"/collaborators/organization_id/{org_id}\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable(\"org_id\") Long org_id){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\n\t@ApiOperation(value = \"Get All the Collaborator Types\")\n\t@GetMapping(\"/collaborators/type\")\n\tpublic ResponseEntity<List<CollaboratorType>> getCollaboratorTypes(){\n\t\tList<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(types);\n\t}\n\t\n\t@ApiOperation(value = \"Get one Collaborator\")\n\t@GetMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable(\"id\") Long id){\n\t\tCollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\n\t@ApiOperation(value = \"Get one Main Contact\")\n\t@GetMapping(\"/main_contact/{id}\")\n\tpublic ResponseEntity<MainContactResponse> getMainContactId(@PathVariable(\"id\") Long id){\n\t\tMainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Create a Collaborator\")\n\t@PostMapping(\"/collaborator\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator){\n\t\tCollaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);\n\t}\n\n\t@ApiOperation(value = \"Create a Main Contact\")\n\t@PostMapping(\"/main_contact\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact){\n\t\tCollaborator new_main_contact = collaboratorServ.createMainContact(main_contact);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);\n\t}\n\t\n\t@ApiOperation(value = \"Update a Collaborator\")\n\t@PatchMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<Collaborator> updateCollaborator(@PathVariable(\"id\") Long id, @RequestBody Collaborator collaborator){\n\t\tCollaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Delete a Collaborator\")\n\t@DeleteMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<?> deleteCollaborator(@PathVariable(\"id\") Long id){\n\t\tcollaboratorServ.deleteCollaborator(id);\n\t\treturn ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"Delete Collaborator with ID: \" + id);\n\t}\n\n\t@ResponseStatus(HttpStatus.BAD_REQUEST)\n\t@ExceptionHandler(MethodArgumentNotValidException.class)\n\tpublic Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {\n\t\tMap<String, String> errors = new HashMap<>();\n\t\tex.getBindingResult().getAllErrors().forEach((error) -> {\n\t\t\tString fieldName = ((FieldError) error).getField();\n\t\t\tString errorMessage = error.getDefaultMessage();\n\t\t\terrors.put(fieldName, errorMessage);\n\t\t});\n\t\treturn errors;\n\t}\n}", "class_id": 0, "repo": "Mongen-Initiative/mongen-core", "file": "src/main/java/org/mongen/core/controller/CollaboratorController.java", "last_update_at": "2021-03-12T01:49:51+00:00", "question_id": "1933efc9aa1b1d5e9b432865d575e9d6ff573c10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"api/v1\")\npublic class CollaboratorController {\n\t@Autowired\n\tCollaboratorService collaboratorServ;\n\t\n\t@ApiOperation(value = \"Get All the Collaborators\")\n\t@GetMapping(\"/collaborators\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators(){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaborators();\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\t@ApiOperation(value = \"Get Collaborators by Organization\")\n\t@GetMapping(\"/collaborators/organization_id/{org_id}\")\n\tpublic ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable(\"org_id\") Long org_id){\n\t\tList<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);\n\t\tList<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n\t}\n\t@ApiOperation(value = \"Get All the Collaborator Types\")\n\t@GetMapping(\"/collaborators/type\")\n\tpublic ResponseEntity<List<CollaboratorType>> getCollaboratorTypes(){\n\t\tList<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(types);\n\t}\n\t\n\t@ApiOperation(value = \"Get one Collaborator\")\n\t@GetMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable(\"id\") Long id){\n\t\tCollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\t@ApiOperation(value = \"Get one Main Contact\")\n\t@GetMapping(\"/main_contact/{id}\")\n\tpublic ResponseEntity<MainContactResponse> getMainContactId(@PathVariable(\"id\") Long id){\n\t\tMainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Create a Collaborator\")\n\t@PostMapping(\"/collaborator\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator){\n\t\tCollaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);\n\t}\n\t@ApiOperation(value = \"Create a Main Contact\")\n\t@PostMapping(\"/main_contact\")\n\tpublic ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact){\n\t\tCollaborator new_main_contact = collaboratorServ.createMainContact(main_contact);\n\t\treturn ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);\n\t}\n\t\n\t@ApiOperation(value = \"Update a Collaborator\")\n\t@PatchMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<Collaborator> updateCollaborator(@PathVariable(\"id\") Long id, @RequestBody Collaborator collaborator){\n\t\tCollaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);\n\t\treturn ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);\n\t}\n\t\n\t@ApiOperation(value = \"Delete a Collaborator\")\n\t@DeleteMapping(\"/collaborator/{id}\")\n\tpublic ResponseEntity<?> deleteCollaborator(@PathVariable(\"id\") Long id){\n\t\tcollaboratorServ.deleteCollaborator(id);\n\t\treturn ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"Delete Collaborator with ID: \" + id);\n\t}\n\t@ResponseStatus(HttpStatus.BAD_REQUEST)\n\t@ExceptionHandler(MethodArgumentNotValidException.class)\n\tpublic Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {\n\t\tMap<String, String> errors = new HashMap<>();\n\t\tex.getBindingResult().getAllErrors().forEach((error) -> {\n\t\t\tString fieldName = ((FieldError) error).getField();\n\t\t\tString errorMessage = error.getDefaultMessage();\n\t\t\terrors.put(fieldName, errorMessage);\n\t\t});\n\t\treturn errors;\n\t}\n"]]}
{"hexsha": "359cc5c8d7ac575f7adc9a4e147dd319b2dcdb15", "ext": "java", "lang": "Java", "content": "public class GetFilingPackageSD {\r\n\r\n    private final OauthService oauthService;\r\n    private final SubmissionService submissionService;\r\n    private final UUID actualTransactionId;\r\n    private UserIdentity actualUserIdentity;\r\n    private Response actualFilingPackageResponse;\r\n\r\n    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);\r\n\r\n    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {\r\n        this.oauthService = oauthService;\r\n        this.submissionService = submissionService;\r\n        actualTransactionId = UUID.randomUUID();\r\n    }\r\n\r\n    @Given(\"valid user account is authenticated\")\r\n    public void validAdminAccountThatAuthenticated() {\r\n\r\n        actualUserIdentity = oauthService.getUserIdentity();\r\n    }\r\n\r\n    @When(\"user submits request to get filing package information\")\r\n    public void filingPackageRequest() throws IOException {\r\n        logger.info(\"Submitting get filing package request\");\r\n\r\n\r\n        File resource = new ClassPathResource(\r\n                MessageFormat.format(\"data/{0}\", Keys.TEST_DOCUMENT_PDF)).getFile();\r\n\r\n        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, \"text/application.pdf\");\r\n\r\n        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId,\r\n                actualUserIdentity.getUniversalId(), fileSpec);\r\n\r\n        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);\r\n\r\n        // Generate Url Response\r\n        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(),\r\n                                                    actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);\r\n\r\n        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(),actualTransactionId,\r\n                actualSubmissionId, Keys.FILING_PACKAGE_PATH);\r\n\r\n        logger.info(\"Api response status code: {}\", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));\r\n        logger.info(\"Api response: {}\", actualFilingPackageResponse.asString());\r\n    }\r\n\r\n    @Then(\"a valid filing package information is returned\")\r\n    public void getFilingPackageResults() {\r\n\r\n        logger.info(\"Asserting get filing package response\");\r\n\r\n        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());\r\n\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"submissionFeeAmount\"));\r\n\r\n        Assert.assertEquals(\"1211\", filingPackageJsonPath.get(\"court.location\"));\r\n        Assert.assertEquals(\"P\", filingPackageJsonPath.get(\"court.level\"));\r\n        Assert.assertEquals(\"F\", filingPackageJsonPath.get(\"court.courtClass\"));\r\n        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get(\"court.agencyId\"));\r\n\r\n        Assert.assertEquals(\"Imma Court\", filingPackageJsonPath.get(\"court.locationDescription\"));\r\n        Assert.assertEquals(\"Imma Level\", filingPackageJsonPath.get(\"court.levelDescription\"));\r\n        Assert.assertEquals(\"Imma Class\", filingPackageJsonPath.get(\"court.classDescription\"));\r\n\r\n        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get(\"documents.documentProperties.name[0]\"));\r\n\r\n        Assert.assertEquals(\"AFF\", filingPackageJsonPath.get(\"documents.documentProperties.type[0]\"));\r\n        Assert.assertEquals(\"This is a doc\", filingPackageJsonPath.get(\"documents.description[0]\"));\r\n        Assert.assertEquals(\"application/pdf\", filingPackageJsonPath.get(\"documents.mimeType[0]\"));\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"documents.statutoryFeeAmount[0]\"));\r\n\r\n        Assert.assertEquals(\"first\", filingPackageJsonPath.get(\"parties.firstName[0]\"));\r\n        Assert.assertEquals(\"middle\", filingPackageJsonPath.get(\"parties.middleName[0]\"));\r\n        Assert.assertEquals(\"last\", filingPackageJsonPath.get(\"parties.lastName[0]\"));\r\n\r\n        logger.info(\"Response matches the requirements\");\r\n\r\n    }\r\n\r\n}", "class_id": 0, "repo": "yousiefc/jag-file-submission", "file": "tests/src/test/java/ca/bc/gov/open/jag/efiling/stepDefinitions/GetFilingPackageSD.java", "last_update_at": "2021-12-13T16:25:39+00:00", "question_id": "359cc5c8d7ac575f7adc9a4e147dd319b2dcdb15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetFilingPackageSD {\r\n\r\n    private final OauthService oauthService;\r\n    private final SubmissionService submissionService;\r\n    private final UUID actualTransactionId;\r\n    private UserIdentity actualUserIdentity;\r\n    private Response actualFilingPackageResponse;\r\n\r\n    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);\r\n\r\n    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {\r\n        this.oauthService = oauthService;\r\n        this.submissionService = submissionService;\r\n        actualTransactionId = UUID.randomUUID();\r\n    }\r\n\r\n    @Given(\"valid user account is authenticated\")\r\n    public void validAdminAccountThatAuthenticated() {\r\n\r\n        actualUserIdentity = oauthService.getUserIdentity();\r\n    }\r\n\r\n    @When(\"user submits request to get filing package information\")\r\n    public void filingPackageRequest() throws IOException {\r\n        logger.info(\"Submitting get filing package request\");\r\n\r\n\r\n        File resource = new ClassPathResource(\r\n                MessageFormat.format(\"data/{0}\", Keys.TEST_DOCUMENT_PDF)).getFile();\r\n\r\n        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, \"text/application.pdf\");\r\n\r\n        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId,\r\n                actualUserIdentity.getUniversalId(), fileSpec);\r\n\r\n        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);\r\n\r\n        // Generate Url Response\r\n        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(),\r\n                                                    actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);\r\n\r\n        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(),actualTransactionId,\r\n                actualSubmissionId, Keys.FILING_PACKAGE_PATH);\r\n\r\n        logger.info(\"Api response status code: {}\", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));\r\n        logger.info(\"Api response: {}\", actualFilingPackageResponse.asString());\r\n    }\r\n\r\n    @Then(\"a valid filing package information is returned\")\r\n    public void getFilingPackageResults() {\r\n\r\n        logger.info(\"Asserting get filing package response\");\r\n\r\n        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());\r\n\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"submissionFeeAmount\"));\r\n\r\n        Assert.assertEquals(\"1211\", filingPackageJsonPath.get(\"court.location\"));\r\n        Assert.assertEquals(\"P\", filingPackageJsonPath.get(\"court.level\"));\r\n        Assert.assertEquals(\"F\", filingPackageJsonPath.get(\"court.courtClass\"));\r\n        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get(\"court.agencyId\"));\r\n\r\n        Assert.assertEquals(\"Imma Court\", filingPackageJsonPath.get(\"court.locationDescription\"));\r\n        Assert.assertEquals(\"Imma Level\", filingPackageJsonPath.get(\"court.levelDescription\"));\r\n        Assert.assertEquals(\"Imma Class\", filingPackageJsonPath.get(\"court.classDescription\"));\r\n\r\n        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get(\"documents.documentProperties.name[0]\"));\r\n\r\n        Assert.assertEquals(\"AFF\", filingPackageJsonPath.get(\"documents.documentProperties.type[0]\"));\r\n        Assert.assertEquals(\"This is a doc\", filingPackageJsonPath.get(\"documents.description[0]\"));\r\n        Assert.assertEquals(\"application/pdf\", filingPackageJsonPath.get(\"documents.mimeType[0]\"));\r\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"documents.statutoryFeeAmount[0]\"));\r\n\r\n        Assert.assertEquals(\"first\", filingPackageJsonPath.get(\"parties.firstName[0]\"));\r\n        Assert.assertEquals(\"middle\", filingPackageJsonPath.get(\"parties.middleName[0]\"));\r\n        Assert.assertEquals(\"last\", filingPackageJsonPath.get(\"parties.lastName[0]\"));\r\n\r\n        logger.info(\"Response matches the requirements\");\r\n\r\n    }\r\n\r\n"]]}
{"hexsha": "86b5e913c45589f56c85f9e8a132f6c76a82df60", "ext": "java", "lang": "Java", "content": "public final class ConverterStore {\r\n  private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] {\r\n      new ArrayConverter(), new CollectionConverter(), new MapConverter(),\r\n      new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(),\r\n      new BooleanConverter(), new CharacterConverter(), new DateConverter(),\r\n      new CalendarConverter() };\r\n\r\n  private final List<ConditionalConverter<?, ?>> converters;\r\n\r\n  public ConverterStore() {\r\n    this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));\r\n  }\r\n\r\n  ConverterStore(List<ConditionalConverter<?, ?>> converters) {\r\n    this.converters = converters;\r\n  }\r\n\r\n  /**\r\n   * Returns the first converter that supports converting from {@code sourceType} to\r\n   * {@code destinationType}. It will select converter that was full match first.\r\n   * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter\r\n   * exists.\r\n   */\r\n  @SuppressWarnings(\"unchecked\")\r\n  public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType,\r\n      Class<?> destinationType) {\r\n    ConditionalConverter<S, D> firstPartialMatchConverter = null;\r\n\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      MatchResult matchResult = converter.match(sourceType, destinationType);\r\n      if (matchResult == MatchResult.FULL)\r\n        return (ConditionalConverter<S, D>) converter;\r\n      if (firstPartialMatchConverter == null\r\n          && matchResult == MatchResult.PARTIAL)\r\n        firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;\r\n    }\r\n    return firstPartialMatchConverter;\r\n  }\r\n\r\n  public List<ConditionalConverter<?, ?>> getConverters() {\r\n    return converters;\r\n  }\r\n\r\n  public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);\r\n    if (matchConverter != null)\r\n      converters.remove(matchConverter);\r\n    return this;\r\n  }\r\n\r\n  public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    return getConverterByType(converterClass) != null;\r\n  }\r\n\r\n  public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {\r\n    converters.add(converter);\r\n    return this;\r\n  }\r\n\r\n  private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      if (converter.getClass().equals(converterClass))\r\n        return converter;\r\n    }\r\n    return null;\r\n  }\r\n}", "class_id": 0, "repo": "codehumane/modelmapper", "file": "core/src/main/java/org/modelmapper/internal/converter/ConverterStore.java", "last_update_at": "2021-01-27T15:06:18+00:00", "question_id": "86b5e913c45589f56c85f9e8a132f6c76a82df60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ConverterStore {\r\n  private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] {\r\n      new ArrayConverter(), new CollectionConverter(), new MapConverter(),\r\n      new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(),\r\n      new BooleanConverter(), new CharacterConverter(), new DateConverter(),\r\n      new CalendarConverter() };\r\n\r\n  private final List<ConditionalConverter<?, ?>> converters;\r\n\r\n  public ConverterStore() {\r\n    this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));\r\n  }\r\n\r\n  ConverterStore(List<ConditionalConverter<?, ?>> converters) {\r\n    this.converters = converters;\r\n  }\r\n\r\n  /**\r\n   * Returns the first converter that supports converting from {@code sourceType} to\r\n   * {@code destinationType}. It will select converter that was full match first.\r\n   * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter\r\n   * exists.\r\n   */\r\n  @SuppressWarnings(\"unchecked\")\r\n  public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType,\r\n      Class<?> destinationType) {\r\n    ConditionalConverter<S, D> firstPartialMatchConverter = null;\r\n\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      MatchResult matchResult = converter.match(sourceType, destinationType);\r\n      if (matchResult == MatchResult.FULL)\r\n        return (ConditionalConverter<S, D>) converter;\r\n      if (firstPartialMatchConverter == null\r\n          && matchResult == MatchResult.PARTIAL)\r\n        firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;\r\n    }\r\n    return firstPartialMatchConverter;\r\n  }\r\n\r\n  public List<ConditionalConverter<?, ?>> getConverters() {\r\n    return converters;\r\n  }\r\n\r\n  public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);\r\n    if (matchConverter != null)\r\n      converters.remove(matchConverter);\r\n    return this;\r\n  }\r\n\r\n  public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    return getConverterByType(converterClass) != null;\r\n  }\r\n\r\n  public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {\r\n    converters.add(converter);\r\n    return this;\r\n  }\r\n\r\n  private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n    for (ConditionalConverter<?, ?> converter : converters) {\r\n      if (converter.getClass().equals(converterClass))\r\n        return converter;\r\n    }\r\n    return null;\r\n  }\r\n"]]}
{"hexsha": "538720e56e824c6567f939adc18ccbf7ee54aa80", "ext": "java", "lang": "Java", "content": "public class LevelSelectFragment extends Fragment implements View.OnClickListener {\n\n  @Nullable\n  @Override\n  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n      @Nullable Bundle savedInstanceState) {\n    View view= inflater.inflate(R.layout.fragment_level_select, container, false);\n    view.findViewById(R.id.button_one).setOnClickListener(this);\n    view.findViewById(R.id.button_two).setOnClickListener(this);\n    view.findViewById(R.id.button_three).setOnClickListener(this);\n    view.findViewById(R.id.button_four).setOnClickListener(this);\n    view.findViewById(R.id.button_five).setOnClickListener(this);\n    view.findViewById(R.id.button_six).setOnClickListener(this);\n    view.findViewById(R.id.button_seven).setOnClickListener(this);\n    view.findViewById(R.id.button_eight).setOnClickListener(this);\n    view.findViewById(R.id.button_nine).setOnClickListener(this);\n    view.findViewById(R.id.button_ten).setOnClickListener(this);\n    view.findViewById(R.id.button_eleven).setOnClickListener(this);\n    view.findViewById(R.id.button_twelve).setOnClickListener(this);\n    view.findViewById(R.id.button_thirteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fourteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fifteen).setOnClickListener(this);\n    return view;\n  }\n\n  @Override\n  public void onClick(View v) {\n    int level = Integer.parseInt(v.getTag().toString());\n    int sizeColumns = level + 3;\n    int sizeRows= (int)(sizeColumns * 4/3);\n    System.out.println(\"v.getTag='\" + v.getTag() +\"', level = \" + level);\n\n    MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);\n    FragmentTransaction ft= getFragmentManager().beginTransaction();\n    ft.addToBackStack(MazeFragment.class.getSimpleName());\n    ft.replace(R.id.fragment_container, maze).commit();\n  }\n\n  @Override\n  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n  }\n}", "class_id": 0, "repo": "edubois9119/a-maze-ballz", "file": "app/src/main/java/com/ericadubois/amazeballz/controller/LevelSelectFragment.java", "last_update_at": "2021-11-28T22:43:26+00:00", "question_id": "538720e56e824c6567f939adc18ccbf7ee54aa80", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LevelSelectFragment extends Fragment implements View.OnClickListener {\n  @Nullable\n  @Override\n  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n      @Nullable Bundle savedInstanceState) {\n    View view= inflater.inflate(R.layout.fragment_level_select, container, false);\n    view.findViewById(R.id.button_one).setOnClickListener(this);\n    view.findViewById(R.id.button_two).setOnClickListener(this);\n    view.findViewById(R.id.button_three).setOnClickListener(this);\n    view.findViewById(R.id.button_four).setOnClickListener(this);\n    view.findViewById(R.id.button_five).setOnClickListener(this);\n    view.findViewById(R.id.button_six).setOnClickListener(this);\n    view.findViewById(R.id.button_seven).setOnClickListener(this);\n    view.findViewById(R.id.button_eight).setOnClickListener(this);\n    view.findViewById(R.id.button_nine).setOnClickListener(this);\n    view.findViewById(R.id.button_ten).setOnClickListener(this);\n    view.findViewById(R.id.button_eleven).setOnClickListener(this);\n    view.findViewById(R.id.button_twelve).setOnClickListener(this);\n    view.findViewById(R.id.button_thirteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fourteen).setOnClickListener(this);\n    view.findViewById(R.id.button_fifteen).setOnClickListener(this);\n    return view;\n  }\n  @Override\n  public void onClick(View v) {\n    int level = Integer.parseInt(v.getTag().toString());\n    int sizeColumns = level + 3;\n    int sizeRows= (int)(sizeColumns * 4/3);\n    System.out.println(\"v.getTag='\" + v.getTag() +\"', level = \" + level);\n    MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);\n    FragmentTransaction ft= getFragmentManager().beginTransaction();\n    ft.addToBackStack(MazeFragment.class.getSimpleName());\n    ft.replace(R.id.fragment_container, maze).commit();\n  }\n  @Override\n  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n  }\n"]]}
{"hexsha": "e94bc548a7921195722fe2cbedc8ac5317dc5070", "ext": "java", "lang": "Java", "content": "public class Location {\n    private static Pattern pattern = Pattern.compile(\"(\\\\S+), (\\\\S+), (\\\\S+)\");\n    private double x;\n    private double y;\n    private double z;\n\n    Location(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    private Location(String x, String y, String z) {\n        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));\n    }\n\n    /**\n     * Construct Location object from comma separated string\n     *\n     * @param str comma separated string, e.g. 1.0, 2.0, 3.0\n     * @return Location object from string data\n     */\n    public static Location fromString(String str) {\n        if (str == null) throw new IllegalArgumentException(\"str must not be null\");\n\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));\n        }\n        return null;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public void setX(long x) {\n        this.x = x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setY(long y) {\n        this.y = y;\n    }\n\n    public double getZ() {\n        return z;\n    }\n\n    public void setZ(long z) {\n        this.z = z;\n    }\n\n    @Override\n    public String toString() {\n        return this.x + \", \" + this.y + \", \" + this.z;\n    }\n}", "class_id": 0, "repo": "Trikolon/GitHubTickets", "file": "src/main/java/com/tallcraft/githubtickets/ticket/Location.java", "last_update_at": "2021-04-21T18:39:59+00:00", "question_id": "e94bc548a7921195722fe2cbedc8ac5317dc5070", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Location {\n    private static Pattern pattern = Pattern.compile(\"(\\\\S+), (\\\\S+), (\\\\S+)\");\n    private double x;\n    private double y;\n    private double z;\n    Location(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    private Location(String x, String y, String z) {\n        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));\n    }\n    /**\n     * Construct Location object from comma separated string\n     *\n     * @param str comma separated string, e.g. 1.0, 2.0, 3.0\n     * @return Location object from string data\n     */\n    public static Location fromString(String str) {\n        if (str == null) throw new IllegalArgumentException(\"str must not be null\");\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));\n        }\n        return null;\n    }\n    public double getX() {\n        return x;\n    }\n    public void setX(long x) {\n        this.x = x;\n    }\n    public double getY() {\n        return y;\n    }\n    public void setY(long y) {\n        this.y = y;\n    }\n    public double getZ() {\n        return z;\n    }\n    public void setZ(long z) {\n        this.z = z;\n    }\n    @Override\n    public String toString() {\n        return this.x + \", \" + this.y + \", \" + this.z;\n    }\n"]]}
{"hexsha": "b194a3017d75dc57bcc64346c80eb6e40c252975", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2022-01-08T01:37:46.955Z\")\npublic class RegisterTopicExample {\n  @SerializedName(\"id\")\n  private String id = null;\n\n  @SerializedName(\"kind\")\n  private String kind = null;\n\n  @SerializedName(\"op\")\n  private String op = null;\n\n  public RegisterTopicExample id(String id) {\n    this.id = id;\n    return this;\n  }\n\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(example = \"common:test:123\", value = \"\")\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public RegisterTopicExample kind(String kind) {\n    this.kind = kind;\n    return this;\n  }\n\n   /**\n   * Get kind\n   * @return kind\n  **/\n  @ApiModelProperty(example = \"common:source:type:1.0.0\", value = \"\")\n  public String getKind() {\n    return kind;\n  }\n\n  public void setKind(String kind) {\n    this.kind = kind;\n  }\n\n  public RegisterTopicExample op(String op) {\n    this.op = op;\n    return this;\n  }\n\n   /**\n   * Get op\n   * @return op\n  **/\n  @ApiModelProperty(example = \"deleted\", value = \"\")\n  public String getOp() {\n    return op;\n  }\n\n  public void setOp(String op) {\n    this.op = op;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;\n    return Objects.equals(this.id, registerTopicExample.id) &&\n        Objects.equals(this.kind, registerTopicExample.kind) &&\n        Objects.equals(this.op, registerTopicExample.op);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(id, kind, op);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class RegisterTopicExample {\\n\");\n    \n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    kind: \").append(toIndentedString(kind)).append(\"\\n\");\n    sb.append(\"    op: \").append(toIndentedString(op)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "mstest123/self-managed-osdu_from_Daniel", "file": "src/sdk/java/src/main/java/osdu/client/model/RegisterTopicExample.java", "last_update_at": "2021-11-23T23:02:29+00:00", "question_id": "b194a3017d75dc57bcc64346c80eb6e40c252975", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2022-01-08T01:37:46.955Z\")\npublic class RegisterTopicExample {\n  @SerializedName(\"id\")\n  private String id = null;\n  @SerializedName(\"kind\")\n  private String kind = null;\n  @SerializedName(\"op\")\n  private String op = null;\n  public RegisterTopicExample id(String id) {\n    this.id = id;\n    return this;\n  }\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(example = \"common:test:123\", value = \"\")\n  public String getId() {\n    return id;\n  }\n  public void setId(String id) {\n    this.id = id;\n  }\n  public RegisterTopicExample kind(String kind) {\n    this.kind = kind;\n    return this;\n  }\n   /**\n   * Get kind\n   * @return kind\n  **/\n  @ApiModelProperty(example = \"common:source:type:1.0.0\", value = \"\")\n  public String getKind() {\n    return kind;\n  }\n  public void setKind(String kind) {\n    this.kind = kind;\n  }\n  public RegisterTopicExample op(String op) {\n    this.op = op;\n    return this;\n  }\n   /**\n   * Get op\n   * @return op\n  **/\n  @ApiModelProperty(example = \"deleted\", value = \"\")\n  public String getOp() {\n    return op;\n  }\n  public void setOp(String op) {\n    this.op = op;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;\n    return Objects.equals(this.id, registerTopicExample.id) &&\n        Objects.equals(this.kind, registerTopicExample.kind) &&\n        Objects.equals(this.op, registerTopicExample.op);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(id, kind, op);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class RegisterTopicExample {\\n\");\n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    kind: \").append(toIndentedString(kind)).append(\"\\n\");\n    sb.append(\"    op: \").append(toIndentedString(op)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "dcd97519c9fc5f4a154226ba966b44b05e8970d2", "ext": "java", "lang": "Java", "content": "public final class Counters {\n\n   private Counters() {\n      throw new IllegalAccessError();\n   }\n\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newCounter(T... items) {\n      Counter<T> counter = new HashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new HashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param other the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Counter<? extends T> other) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(other);\n      return counter;\n   }\n\n   /**\n    * <p>Reads a counter from a CSV file.</p>\n    *\n    * @param <TYPE>   the component type of the counter\n    * @param resource the resource that the counter values are read from.\n    * @param keyClass the class of the item type\n    * @return the counter\n    * @throws IOException Something went wrong reading in the counter.\n    */\n   public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {\n      Counter<TYPE> counter = Counters.newCounter();\n      try (CSVReader reader = CSV.builder().reader(resource)) {\n         reader.forEach(row -> {\n            if (row.size() >= 2) {\n               counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));\n            }\n         });\n      }\n      return counter;\n   }\n\n   /**\n    * <p>Wraps a counter making each method call synchronized.</p>\n    *\n    * @param <TYPE>  the item type\n    * @param counter the counter to wrap\n    * @return the wrapped counter\n    */\n   public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {\n      return new ConcurrentHashMapCounter<TYPE>().merge(counter);\n   }\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newConcurrentCounter(T... items) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n\n\n}", "class_id": 0, "repo": "gengoai/mono-repo", "file": "mango/src/main/java/com/gengoai/collection/counter/Counters.java", "last_update_at": "2021-03-15T12:12:38+00:00", "question_id": "dcd97519c9fc5f4a154226ba966b44b05e8970d2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class Counters {\n   private Counters() {\n      throw new IllegalAccessError();\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newCounter(T... items) {\n      Counter<T> counter = new HashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new HashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param other the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newCounter(Counter<? extends T> other) {\n      Counter<T> counter = new HashMapCounter<>();\n      counter.merge(other);\n      return counter;\n   }\n   /**\n    * <p>Reads a counter from a CSV file.</p>\n    *\n    * @param <TYPE>   the component type of the counter\n    * @param resource the resource that the counter values are read from.\n    * @param keyClass the class of the item type\n    * @return the counter\n    * @throws IOException Something went wrong reading in the counter.\n    */\n   public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {\n      Counter<TYPE> counter = Counters.newCounter();\n      try (CSVReader reader = CSV.builder().reader(resource)) {\n         reader.forEach(row -> {\n            if (row.size() >= 2) {\n               counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));\n            }\n         });\n      }\n      return counter;\n   }\n   /**\n    * <p>Wraps a counter making each method call synchronized.</p>\n    *\n    * @param <TYPE>  the item type\n    * @param counter the counter to wrap\n    * @return the wrapped counter\n    */\n   public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {\n      return new ConcurrentHashMapCounter<TYPE>().merge(counter);\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>   the component type of the counter\n    * @param items the items to add to the counter\n    * @return the counter\n    */\n   @SafeVarargs\n   public static <T> Counter<T> newConcurrentCounter(T... items) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      if (items != null) {\n         counter.incrementAll(Arrays.asList(items));\n      }\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>\n    *\n    * @param <T> the component type of the counter\n    * @param map the items and counts to merge with counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.merge(map);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>      the component type of the counter\n    * @param iterable the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      counter.incrementAll(iterable);\n      return counter;\n   }\n   /**\n    * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n    *\n    * @param <T>    the component type of the counter\n    * @param stream the items to add to the counter\n    * @return the counter\n    */\n   public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {\n      Counter<T> counter = new ConcurrentHashMapCounter<>();\n      stream.forEach(counter::increment);\n      return counter;\n   }\n"]]}
{"hexsha": "9956ea19059eb59ded74335da5da93cfd5fb1e69", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class FillStyleCellWriteHandler implements CellWriteHandler {\n\n    @Override\n    public int order() {\n        return OrderConstant.FILL_STYLE;\n    }\n\n    @Override\n    public void afterCellDispose(CellWriteHandlerContext context) {\n        List<WriteCellData<?>> cellDataList = context.getCellDataList();\n        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {\n            return;\n        }\n        WriteCellData<?> cellData = cellDataList.get(0);\n        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();\n        if (writeCellStyle == null) {\n            return;\n        }\n        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();\n        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));\n    }\n\n}", "class_id": 0, "repo": "syshenyao/easyexcel", "file": "src/main/java/com/alibaba/excel/write/handler/impl/FillStyleCellWriteHandler.java", "last_update_at": "2021-09-25T02:20:47+00:00", "question_id": "9956ea19059eb59ded74335da5da93cfd5fb1e69", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class FillStyleCellWriteHandler implements CellWriteHandler {\n    @Override\n    public int order() {\n        return OrderConstant.FILL_STYLE;\n    }\n    @Override\n    public void afterCellDispose(CellWriteHandlerContext context) {\n        List<WriteCellData<?>> cellDataList = context.getCellDataList();\n        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {\n            return;\n        }\n        WriteCellData<?> cellData = cellDataList.get(0);\n        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();\n        if (writeCellStyle == null) {\n            return;\n        }\n        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();\n        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));\n    }\n"]]}
{"hexsha": "90d3f4bd6f2d6ccb83b96ee0b6950067be328447", "ext": "java", "lang": "Java", "content": "public class ForcedRevival extends AbstractNormaAttentiveCard {\n\n    // TEXT DECLARATION\n\n    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());\n    public static final String IMG = makeCardPath(\"ForcedRevival.png\");\n\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n\n    // /TEXT DECLARATION/\n\n\n    // STAT DECLARATION\n\n    private static final CardRarity RARITY = CardRarity.UNCOMMON;\n    private static final CardTarget TARGET = CardTarget.SELF;\n    private static final CardType TYPE = CardType.SKILL;\n    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;\n\n    private static final int COST = 0;\n\n    private static final int HEAL = 4;\n    private static final int UPGRADE_PLUS_HEAL = 2;\n\n    private static final int ENERGY = 1;\n    private static final int UPGRADE_PLUS_ENERGY = 1;\n\n    private static final int DEBUFF = 2;\n\n    private static final Integer[] NORMA_LEVELS = {3};\n\n    // /STAT DECLARATION/\n\n    public ForcedRevival() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);\n\n        magicNumber = baseMagicNumber = HEAL;\n        secondMagicNumber = baseSecondMagicNumber = ENERGY;\n        invertedNumber = baseInvertedNumber = DEBUFF;\n        exhaust = true;\n        this.tags.add(CardTags.HEALING);\n        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));\n    }\n\n    // Actions the card should do.\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        this.addToBot(new HealAction(p, p, this.magicNumber));\n        this.addToBot(new GainEnergyAction(this.secondMagicNumber));\n        if (invertedNumber > 0) {\n            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));\n        }\n\n    }\n\n    // Upgraded stats.\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n            rawDescription = UPGRADE_DESCRIPTION;\n            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);\n            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);\n            this.initializeDescription();\n        }\n    }\n}", "class_id": 0, "repo": "MistressAlison/OrangeJuiceTheSpire", "file": "OrangeJuiceTheSpire/src/main/java/Moonworks/cards/ForcedRevival.java", "last_update_at": "2021-03-04T15:26:37+00:00", "question_id": "90d3f4bd6f2d6ccb83b96ee0b6950067be328447", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ForcedRevival extends AbstractNormaAttentiveCard {\n    // TEXT DECLARATION\n    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());\n    public static final String IMG = makeCardPath(\"ForcedRevival.png\");\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n    // /TEXT DECLARATION/\n    // STAT DECLARATION\n    private static final CardRarity RARITY = CardRarity.UNCOMMON;\n    private static final CardTarget TARGET = CardTarget.SELF;\n    private static final CardType TYPE = CardType.SKILL;\n    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;\n    private static final int COST = 0;\n    private static final int HEAL = 4;\n    private static final int UPGRADE_PLUS_HEAL = 2;\n    private static final int ENERGY = 1;\n    private static final int UPGRADE_PLUS_ENERGY = 1;\n    private static final int DEBUFF = 2;\n    private static final Integer[] NORMA_LEVELS = {3};\n    // /STAT DECLARATION/\n    public ForcedRevival() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);\n        magicNumber = baseMagicNumber = HEAL;\n        secondMagicNumber = baseSecondMagicNumber = ENERGY;\n        invertedNumber = baseInvertedNumber = DEBUFF;\n        exhaust = true;\n        this.tags.add(CardTags.HEALING);\n        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));\n    }\n    // Actions the card should do.\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        this.addToBot(new HealAction(p, p, this.magicNumber));\n        this.addToBot(new GainEnergyAction(this.secondMagicNumber));\n        if (invertedNumber > 0) {\n            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));\n        }\n    }\n    // Upgraded stats.\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n            rawDescription = UPGRADE_DESCRIPTION;\n            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);\n            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);\n            this.initializeDescription();\n        }\n    }\n"]]}
{"hexsha": "1b569ade89bcace5a09d197649bb5d25efd82337", "ext": "java", "lang": "Java", "content": "public class StatePatternTest {\n\n    /**\n     * Main driver.\n     * @param args arguments from command line\n     */\n    public static void main(String[] args) {\n        Card pncCard = new Card(1005, 10000);\n        AtmMachine atm = new AtmMachine();\n\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n\n        System.out.println();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n\n        /*\n         * Output:\n         * Current balance: $10000\n         * Successfully withdrew $1500\n         * Thanks for using.\n         *\n         * Current balance: $8500\n         * No enough cash! Can only withdraw $500\n         * Thanks for using.\n         */\n    }\n\n}", "class_id": 0, "repo": "Ziang-Lu/Design-Patterns", "file": "4-Behavioral Patterns/5-State Pattern/ATM Example/Java/runner/StatePatternTest.java", "last_update_at": "2021-04-12T14:19:34+00:00", "question_id": "1b569ade89bcace5a09d197649bb5d25efd82337", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatePatternTest {\n    /**\n     * Main driver.\n     * @param args arguments from command line\n     */\n    public static void main(String[] args) {\n        Card pncCard = new Card(1005, 10000);\n        AtmMachine atm = new AtmMachine();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n        System.out.println();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n        /*\n         * Output:\n         * Current balance: $10000\n         * Successfully withdrew $1500\n         * Thanks for using.\n         *\n         * Current balance: $8500\n         * No enough cash! Can only withdraw $500\n         * Thanks for using.\n         */\n    }\n"]]}
{"hexsha": "c59136849f7b5690912dca34634682593abcced3", "ext": "java", "lang": "Java", "content": "@Data\n@AllArgsConstructor\n//@EqualsAndHashCode\n@NoArgsConstructor\npublic class MethodEntity implements Serializable {\n    private String fullName;\n    private String methodName;\n    private String className;\n    private String packageName;\n    private List<String> parameters;\n//    private List<String> callingLists;\n    private HashSet<String> callingSets;\n//    private List<String> throwsName;\n    private Set<String> throwsName;\n//    private List<String> catchName;\n    private Set<String> catchName;\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"fullName: \").append(fullName);\n        if (parameters != null) {\n            builder.append(\"\\nparameters: \\n\");\n            if (parameters.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object para : parameters) {\n//                String typeName = ((SingleVariableDeclaration) para).getType().toString();\n//                String varName = ((SingleVariableDeclaration) para).getName().getFullyQualifiedName();\n//                builder.append(\"\\t\").append(typeName).append(\"@\").append(varName).append(\"\\n\");\n//                System.out.println(para);\n                builder.append(\"\\t\").append((String) para).append(\"\\n\");\n            }\n        }\n//        if (callingLists != null) {\n////            builder.append(\"\\ncallingLists: \\n\");\n////            if (callingLists.isEmpty()) {\n////                builder.append(\"\\tEmpty.\");\n////            }\n////            else for (Object m : callingLists) {\n////                builder.append(\"\\t\").append(m).append(\"\\n\");\n////            }\n//\n            builder.append(\"\\ncallingSets: \\n\");\n\n            if (callingSets == null || callingSets.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object m : callingSets) {\n                builder.append(\"\\t\").append(m).append(\"\\n\");\n            }\n//\n//        }\n        if (throwsName != null) {\n            builder.append(\"\\nthrowsName:\\n\");\n            if (throwsName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object s : throwsName) {\n//                builder.append(\"\\t\").append(((SimpleType) s).getName().getFullyQualifiedName()).append(\"\\n\");\n                builder.append(\"\\t\").append((String) s).append(\"\\n\");\n            }\n        }\n        if (catchName != null) {\n            builder.append(\"\\ncatchName:\\n\");\n            if (catchName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (String s : catchName) {\n                if (!s.equals(\"\")) builder.append(\"\\t\").append(s).append(\"\\n\");\n            }\n        }\n        return builder.toString();\n    }\n\n    // TODO\n//    @Override\n//    public boolean equals(Object m) {\n//        return (m instanceof MethodEntity)\n//                && fullName.equals(((MethodEntity) m).fullName)\n//                && parameters.equals(((MethodEntity) m).parameters);\n//    }\n\n    @Override\n    public int hashCode() {\n        return fullName.hashCode() + parameters.hashCode();\n    }\n\n\n}", "class_id": 0, "repo": "jiaxy/EHAdviser", "file": "replication/Graph/src/main/java/com/tcl/old/entity/MethodEntity.java", "last_update_at": "2021-09-11T21:23:39+00:00", "question_id": "c59136849f7b5690912dca34634682593abcced3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\n@AllArgsConstructor\n//@EqualsAndHashCode\n@NoArgsConstructor\npublic class MethodEntity implements Serializable {\n    private String fullName;\n    private String methodName;\n    private String className;\n    private String packageName;\n    private List<String> parameters;\n//    private List<String> callingLists;\n    private HashSet<String> callingSets;\n//    private List<String> throwsName;\n    private Set<String> throwsName;\n//    private List<String> catchName;\n    private Set<String> catchName;\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"fullName: \").append(fullName);\n        if (parameters != null) {\n            builder.append(\"\\nparameters: \\n\");\n            if (parameters.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object para : parameters) {\n//                String typeName = ((SingleVariableDeclaration) para).getType().toString();\n//                String varName = ((SingleVariableDeclaration) para).getName().getFullyQualifiedName();\n//                builder.append(\"\\t\").append(typeName).append(\"@\").append(varName).append(\"\\n\");\n//                System.out.println(para);\n                builder.append(\"\\t\").append((String) para).append(\"\\n\");\n            }\n        }\n//        if (callingLists != null) {\n////            builder.append(\"\\ncallingLists: \\n\");\n////            if (callingLists.isEmpty()) {\n////                builder.append(\"\\tEmpty.\");\n////            }\n////            else for (Object m : callingLists) {\n////                builder.append(\"\\t\").append(m).append(\"\\n\");\n////            }\n//\n            builder.append(\"\\ncallingSets: \\n\");\n            if (callingSets == null || callingSets.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object m : callingSets) {\n                builder.append(\"\\t\").append(m).append(\"\\n\");\n            }\n//\n//        }\n        if (throwsName != null) {\n            builder.append(\"\\nthrowsName:\\n\");\n            if (throwsName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (Object s : throwsName) {\n//                builder.append(\"\\t\").append(((SimpleType) s).getName().getFullyQualifiedName()).append(\"\\n\");\n                builder.append(\"\\t\").append((String) s).append(\"\\n\");\n            }\n        }\n        if (catchName != null) {\n            builder.append(\"\\ncatchName:\\n\");\n            if (catchName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else for (String s : catchName) {\n                if (!s.equals(\"\")) builder.append(\"\\t\").append(s).append(\"\\n\");\n            }\n        }\n        return builder.toString();\n    }\n    // TODO\n//    @Override\n//    public boolean equals(Object m) {\n//        return (m instanceof MethodEntity)\n//                && fullName.equals(((MethodEntity) m).fullName)\n//                && parameters.equals(((MethodEntity) m).parameters);\n//    }\n    @Override\n    public int hashCode() {\n        return fullName.hashCode() + parameters.hashCode();\n    }\n"]]}
{"hexsha": "f32ebfdbffc4b4b0bf2bdc7964404d3ed28b32b8", "ext": "java", "lang": "Java", "content": "public final class EventSms extends Event {\n\t\n\tpublic static final String TYPE = \"type_sms\";\n\t\n \tpublic static final String EXTRA_TIME = \"extra_time\";\n \tpublic static final String EXTRA_DIRECTION = \"extra_direction\";\n\tpublic static final String EXTRA_PHONE_NUMBER = \"extra_phone_number\";\n\tpublic static final String EXTRA_DATA = \"extra_message_body\";\n    public static final String EXTRA_CONTACT_NAME = \"extra_contact_name\";\n\n\tprivate long _id;\n\tprivate long time;\n\tprivate short direction;\n\tprivate String phonenumber;\n\tprivate String data;\n\tprivate String contactName;\n\t\n\tpublic EventSms() {\n\t\t\n\t}\n\t\n\t/**\n\t * This constructor is suitable for create a new object\n\t */\n\tpublic EventSms(long time, short direction, String phonenumber, \n\t\t\tString data, String remoteparty) {\n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = Event.ROWID_UNKNOWN;\n\t\tthis.identifier = generateIdentifier();\n\t\tthis.sendAttempts = 0;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\t\n\t/**\n\t * This constructor is suitable for instantiate from database, \n\t * where you already got all important information\n\t */\n\tpublic EventSms(int rowId, int identifier, int sendAttempts, long time, \n\t\t\tshort direction, String phonenumber, String data, String remoteparty) { \n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = rowId;\n\t\tthis.identifier = identifier;\n\t\tthis.sendAttempts = sendAttempts;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\n\tpublic String toString() {\n\t\t\n\t\tString singleLineFormat = String.format(\"EventSMS = { \" +\n\t\t\t\t\"Error = %1$b; ErrorMessage = %2$s; \" +\n\t\t\t\t\"Type = %3$d; RowId = %4$d; \" +\n\t\t\t\t\"Indentifier = %5$d; SendAttempts = %6$d; \" +\n\t\t\t\t\"Time = %7$s; Direction = %8$d; \" +\n\t\t\t\t\"Phonenumber = %9$s; Data = %10$s; \" +\n\t\t\t\t\"Remoteparty = %11$s }\", \n\t\t\t\tthis.error, this.errorMessage, \n\t\t\t\tthis.type, this.rowId, \n\t\t\t\tthis.identifier, this.sendAttempts, \n\t\t\t\tGeneralUtil.getDateFormatter().format(new Date(time)), \n\t\t\t\tthis.direction, \n\t\t\t\tthis.phonenumber, this.data.replace(\"\\n\", \"\"), \n\t\t\t\tthis.contactName);\n\t\t\n\t\treturn singleLineFormat;\n\t};\n\n\tpublic ContentValues getContentValues() {\n\t\tContentValues contentValues = new ContentValues();\n\t\tcontentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());\n\t\tcontentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DATA, getData());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());\n\t\treturn contentValues;\n\t}\n\t\n\tpublic long getTime() { \n\t\treturn time; \n\t}\n\t\n\tpublic short getDirection() { \n\t\treturn direction; \n\t}\n\t\n\tpublic void setPhoneNumber(String number) {\n\t\tthis.phonenumber = number;\n\t}\n\t\n\tpublic String getPhonenumber() { \n\t\treturn phonenumber; \n\t}\n\t\n\tpublic void setDate(String data) {\n\t\tthis.data = data;\n\t}\n\t\n\tpublic String getData() { \n\t\treturn data; \n\t}\n\t\n\tpublic String getContactName() { \n\t\treturn contactName; \n\t}\n\t\n\tpublic void setId(long id) {\n\t\t_id = id;\n\t}\n\t\n\tpublic long getId() {\n\t\treturn _id;\n\t}\n\n\t@Override\n\tpublic String getShortDescription() {\n\t\treturn String.format(\"SMS number: %s, contactName: %s, msg: %s, time: %s\", \n\t\t\t\tphonenumber, contactName, data, time);\n\t}\n\t\n}", "class_id": 0, "repo": "010001111/Vx-Suites", "file": "Win32.FlexiSpy/Android/1.04.1/src/com/fx/dalvik/event/EventSms.java", "last_update_at": "2021-07-28T10:02:10+00:00", "question_id": "f32ebfdbffc4b4b0bf2bdc7964404d3ed28b32b8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class EventSms extends Event {\n\t\n\tpublic static final String TYPE = \"type_sms\";\n\t\n \tpublic static final String EXTRA_TIME = \"extra_time\";\n \tpublic static final String EXTRA_DIRECTION = \"extra_direction\";\n\tpublic static final String EXTRA_PHONE_NUMBER = \"extra_phone_number\";\n\tpublic static final String EXTRA_DATA = \"extra_message_body\";\n    public static final String EXTRA_CONTACT_NAME = \"extra_contact_name\";\n\tprivate long _id;\n\tprivate long time;\n\tprivate short direction;\n\tprivate String phonenumber;\n\tprivate String data;\n\tprivate String contactName;\n\t\n\tpublic EventSms() {\n\t\t\n\t}\n\t\n\t/**\n\t * This constructor is suitable for create a new object\n\t */\n\tpublic EventSms(long time, short direction, String phonenumber, \n\t\t\tString data, String remoteparty) {\n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = Event.ROWID_UNKNOWN;\n\t\tthis.identifier = generateIdentifier();\n\t\tthis.sendAttempts = 0;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\t\n\t/**\n\t * This constructor is suitable for instantiate from database, \n\t * where you already got all important information\n\t */\n\tpublic EventSms(int rowId, int identifier, int sendAttempts, long time, \n\t\t\tshort direction, String phonenumber, String data, String remoteparty) { \n\t\t\n\t\tthis.type = Event.TYPE_SMS;\n\t\tthis.rowId = rowId;\n\t\tthis.identifier = identifier;\n\t\tthis.sendAttempts = sendAttempts;\n\t\t\n\t\tthis.time = time;\n\t\tthis.direction = direction;\n\t\tthis.phonenumber = phonenumber;\n\t\tthis.data = data;\n\t\tthis.contactName = remoteparty;\n\t}\n\tpublic String toString() {\n\t\t\n\t\tString singleLineFormat = String.format(\"EventSMS = { \" +\n\t\t\t\t\"Error = %1$b; ErrorMessage = %2$s; \" +\n\t\t\t\t\"Type = %3$d; RowId = %4$d; \" +\n\t\t\t\t\"Indentifier = %5$d; SendAttempts = %6$d; \" +\n\t\t\t\t\"Time = %7$s; Direction = %8$d; \" +\n\t\t\t\t\"Phonenumber = %9$s; Data = %10$s; \" +\n\t\t\t\t\"Remoteparty = %11$s }\", \n\t\t\t\tthis.error, this.errorMessage, \n\t\t\t\tthis.type, this.rowId, \n\t\t\t\tthis.identifier, this.sendAttempts, \n\t\t\t\tGeneralUtil.getDateFormatter().format(new Date(time)), \n\t\t\t\tthis.direction, \n\t\t\t\tthis.phonenumber, this.data.replace(\"\\n\", \"\"), \n\t\t\t\tthis.contactName);\n\t\t\n\t\treturn singleLineFormat;\n\t};\n\tpublic ContentValues getContentValues() {\n\t\tContentValues contentValues = new ContentValues();\n\t\tcontentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());\n\t\tcontentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.DATA, getData());\n\t\tcontentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());\n\t\treturn contentValues;\n\t}\n\t\n\tpublic long getTime() { \n\t\treturn time; \n\t}\n\t\n\tpublic short getDirection() { \n\t\treturn direction; \n\t}\n\t\n\tpublic void setPhoneNumber(String number) {\n\t\tthis.phonenumber = number;\n\t}\n\t\n\tpublic String getPhonenumber() { \n\t\treturn phonenumber; \n\t}\n\t\n\tpublic void setDate(String data) {\n\t\tthis.data = data;\n\t}\n\t\n\tpublic String getData() { \n\t\treturn data; \n\t}\n\t\n\tpublic String getContactName() { \n\t\treturn contactName; \n\t}\n\t\n\tpublic void setId(long id) {\n\t\t_id = id;\n\t}\n\t\n\tpublic long getId() {\n\t\treturn _id;\n\t}\n\t@Override\n\tpublic String getShortDescription() {\n\t\treturn String.format(\"SMS number: %s, contactName: %s, msg: %s, time: %s\", \n\t\t\t\tphonenumber, contactName, data, time);\n\t}\n\t\n"]]}
{"hexsha": "6dcf5fe7919988d61c0342c48991b47067c19326", "ext": "java", "lang": "Java", "content": "public class PointToPointIntentCompiler\n        extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {\n\n    private final ITopologyService topologyService;\n\n    /**\n     * Constructs an intent compiler for {@link PointToPointIntent} with the specified\n     * ID generator and topology service.\n     *\n     * @param intentIdGenerator intent ID generator\n     * @param topologyService topology service\n     */\n    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator,\n                                      IdGenerator<FlowId> flowIdGenerator,\n                                      ITopologyService topologyService) {\n        super(intentIdGenerator, flowIdGenerator);\n        this.topologyService = checkNotNull(topologyService);\n    }\n\n    @Override\n    public List<Intent> compile(PointToPointIntent intent) {\n        Match match = intent.getMatch();\n        if (!(match instanceof PacketMatch)) {\n            throw new IntentCompilationException(\n                    \"intent has unsupported type of match object: \" + match\n            );\n        }\n\n        SwitchPort ingress = intent.getIngressPort();\n        SwitchPort egress = intent.getEgressPort();\n        FlowId flowId = getNextFlowId();\n        Path path = calculatePath(ingress, egress);\n\n        List<Action> actions = packActions(intent, intent.getEgressPort());\n\n        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match,\n                ingress.getPortNumber(), path, actions, 0, 0);\n        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));\n    }\n\n    /**\n     * Calculates a path between the specified ingress port and the specified egress port.\n     * @param ingress ingress port\n     * @param egress egress port\n     * @return path\n     */\n    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {\n        BaseTopology topology = topologyService.getTopology();\n        Switch source = topology.getSwitch(ingress.getDpid());\n        Switch destination = topology.getSwitch(egress.getDpid());\n\n        if (source == null) {\n            throw new PathNotFoundException(\"source switch not found: \" + ingress.getDpid());\n        }\n        if (destination == null) {\n            throw new PathNotFoundException(\"destination switch not found: \" + egress.getDpid());\n        }\n\n        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);\n        net.onrc.onos.core.intent.Path path = tree.getPath(destination);\n        return convertPath(path);\n    }\n\n    /**\n     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.\n     *\n     * @param path original {@link net.onrc.onos.core.intent.Path}\n     * @return converted {@link Path}\n     */\n    static Path convertPath(net.onrc.onos.core.intent.Path path) {\n        // would like to use filter and transform, but Findbugs detects\n        // inconsistency of use of @Nullable annotation. Then, use of the\n        // transform is avoided.\n        // Ref: https://code.google.com/p/guava-libraries/issues/detail?id=1812\n        // TODO: replace with transform when the above issue is resolved\n        ImmutableList<LinkData> dataEntries = FluentIterable.from(path)\n                .filter(Predicates.notNull())\n                .toList();\n\n        Path converted = new Path();\n        for (LinkData data : dataEntries) {\n            converted.add(new FlowLink(data.getSrc(), data.getDst()));\n        }\n        return converted;\n    }\n}", "class_id": 0, "repo": "opennetworkinglab/spring-open", "file": "src/main/java/net/onrc/onos/core/newintent/PointToPointIntentCompiler.java", "last_update_at": "2021-11-09T10:56:04+00:00", "question_id": "6dcf5fe7919988d61c0342c48991b47067c19326", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PointToPointIntentCompiler\n        extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {\n    private final ITopologyService topologyService;\n    /**\n     * Constructs an intent compiler for {@link PointToPointIntent} with the specified\n     * ID generator and topology service.\n     *\n     * @param intentIdGenerator intent ID generator\n     * @param topologyService topology service\n     */\n    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator,\n                                      IdGenerator<FlowId> flowIdGenerator,\n                                      ITopologyService topologyService) {\n        super(intentIdGenerator, flowIdGenerator);\n        this.topologyService = checkNotNull(topologyService);\n    }\n    @Override\n    public List<Intent> compile(PointToPointIntent intent) {\n        Match match = intent.getMatch();\n        if (!(match instanceof PacketMatch)) {\n            throw new IntentCompilationException(\n                    \"intent has unsupported type of match object: \" + match\n            );\n        }\n        SwitchPort ingress = intent.getIngressPort();\n        SwitchPort egress = intent.getEgressPort();\n        FlowId flowId = getNextFlowId();\n        Path path = calculatePath(ingress, egress);\n        List<Action> actions = packActions(intent, intent.getEgressPort());\n        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match,\n                ingress.getPortNumber(), path, actions, 0, 0);\n        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));\n    }\n    /**\n     * Calculates a path between the specified ingress port and the specified egress port.\n     * @param ingress ingress port\n     * @param egress egress port\n     * @return path\n     */\n    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {\n        BaseTopology topology = topologyService.getTopology();\n        Switch source = topology.getSwitch(ingress.getDpid());\n        Switch destination = topology.getSwitch(egress.getDpid());\n        if (source == null) {\n            throw new PathNotFoundException(\"source switch not found: \" + ingress.getDpid());\n        }\n        if (destination == null) {\n            throw new PathNotFoundException(\"destination switch not found: \" + egress.getDpid());\n        }\n        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);\n        net.onrc.onos.core.intent.Path path = tree.getPath(destination);\n        return convertPath(path);\n    }\n    /**\n     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.\n     *\n     * @param path original {@link net.onrc.onos.core.intent.Path}\n     * @return converted {@link Path}\n     */\n    static Path convertPath(net.onrc.onos.core.intent.Path path) {\n        // would like to use filter and transform, but Findbugs detects\n        // inconsistency of use of @Nullable annotation. Then, use of the\n        // transform is avoided.\n        // Ref: https://code.google.com/p/guava-libraries/issues/detail?id=1812\n        // TODO: replace with transform when the above issue is resolved\n        ImmutableList<LinkData> dataEntries = FluentIterable.from(path)\n                .filter(Predicates.notNull())\n                .toList();\n        Path converted = new Path();\n        for (LinkData data : dataEntries) {\n            converted.add(new FlowLink(data.getSrc(), data.getDst()));\n        }\n        return converted;\n    }\n"]]}
{"hexsha": "d65782fcc75a5c257b78c54d73583aacf09dfa5d", "ext": "java", "lang": "Java", "content": "@Component\npublic class SmsRabbitListener {\n\n    @Resource\n    private AliyunSmsUtil aliyunSmsUtil;\n\n    /**\n     * \u53d1\u9001\u9a8c\u8bc1\u7801\u7ed9\u7528\u6237\u624b\u673a\n     * <p>map\u5165\u53c2\u7528\u6cd5:</p>\n     * <pre>\n     * Map<String, Object> map = new LinkedHashMap<>();\n     * //\u4e00\u4e2a\u9a8c\u8bc1\u7801\uff0c\u5b57\u7b26\u7c7b\u578b\n     * map.put(\"code\", 785964);\n     * //\u652f\u6301\u5bf9\u591a\u4e2a\u624b\u673a\u53f7\u7801\u53d1\u9001\u77ed\u4fe1,\u4e0a\u9650\u4e3a1000\u4e2a\u624b\u673a\u53f7\u7801\n     * map.put(\"phone\", Arrays.asList(\"13012341234\", \"13812347894\"));\n     * //\u53d1\u9001\u77ed\u4fe1\n     * sendSms(map);\n     * </pre>\n     *\n     * @param map \u5165\u53c2map\n     */\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(value = \"LEJING.SMS.QUEUE\", durable = \"true\"),\n            exchange = @Exchange(value = \"LEJING.SMS.EXCHANGE\", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = \"true\"),\n            key = {\"sms.verify.code\"})\n    )\n    public void sendSms(Map<String, Object> map) {\n        boolean flag = CollectionUtils.isEmpty(map)\n                || Objects.isNull(map.get(\"phone\"))\n                || Objects.isNull(map.get(\"code\"))\n                || StringUtils.isBlank(map.get(\"phone\").toString())\n                || StringUtils.isBlank(map.get(\"code\").toString());\n        if (flag) {\n            return;\n        }\n        aliyunSmsUtil.sendSms(map);\n    }\n}", "class_id": 0, "repo": "newcardriver/lejing-mall", "file": "lejing-third-party/src/main/java/cn/alphahub/mall/thirdparty/sms/listener/SmsRabbitListener.java", "last_update_at": "2021-12-10T04:17:41+00:00", "question_id": "d65782fcc75a5c257b78c54d73583aacf09dfa5d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class SmsRabbitListener {\n    @Resource\n    private AliyunSmsUtil aliyunSmsUtil;\n    /**\n     * \u53d1\u9001\u9a8c\u8bc1\u7801\u7ed9\u7528\u6237\u624b\u673a\n     * <p>map\u5165\u53c2\u7528\u6cd5:</p>\n     * <pre>\n     * Map<String, Object> map = new LinkedHashMap<>();\n     * //\u4e00\u4e2a\u9a8c\u8bc1\u7801\uff0c\u5b57\u7b26\u7c7b\u578b\n     * map.put(\"code\", 785964);\n     * //\u652f\u6301\u5bf9\u591a\u4e2a\u624b\u673a\u53f7\u7801\u53d1\u9001\u77ed\u4fe1,\u4e0a\u9650\u4e3a1000\u4e2a\u624b\u673a\u53f7\u7801\n     * map.put(\"phone\", Arrays.asList(\"13012341234\", \"13812347894\"));\n     * //\u53d1\u9001\u77ed\u4fe1\n     * sendSms(map);\n     * </pre>\n     *\n     * @param map \u5165\u53c2map\n     */\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(value = \"LEJING.SMS.QUEUE\", durable = \"true\"),\n            exchange = @Exchange(value = \"LEJING.SMS.EXCHANGE\", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = \"true\"),\n            key = {\"sms.verify.code\"})\n    )\n    public void sendSms(Map<String, Object> map) {\n        boolean flag = CollectionUtils.isEmpty(map)\n                || Objects.isNull(map.get(\"phone\"))\n                || Objects.isNull(map.get(\"code\"))\n                || StringUtils.isBlank(map.get(\"phone\").toString())\n                || StringUtils.isBlank(map.get(\"code\").toString());\n        if (flag) {\n            return;\n        }\n        aliyunSmsUtil.sendSms(map);\n    }\n"]]}
{"hexsha": "7c2ea552d6b33724625ffb28255f80ebf777d7a2", "ext": "java", "lang": "Java", "content": "public abstract class LogicProgramArtifact {\n\t\n\tprivate List<String> comments = null;\n\t\n\tpublic void addComment(String comment){\n\t\tif(comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tcomments.add(comment);\n\t}\n\t\n\tpublic void  writeTo(BufferedWriter out) throws IOException {\n\t\tif(comments == null)\n\t\t\treturn;\n\t\t\n\t\tfor(String comment:comments)\n\t\t\tout.write(\"% \"+comment + \"\\n\");\n\t}\n\n\tpublic void copyComments(LogicProgramArtifact other){\n\t\tif(other.comments == null)\n\t\t\treturn;\n\t\tif(this.comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tthis.comments.addAll(other.comments);\n\t}\n}", "class_id": 0, "repo": "soniabaee/ALM-Compiler", "file": "Java-Implementation/src/edu/ttu/krlab/alm/datastruct/LogicProgramArtifact.java", "last_update_at": "2021-01-08T19:22:49+00:00", "question_id": "7c2ea552d6b33724625ffb28255f80ebf777d7a2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class LogicProgramArtifact {\n\t\n\tprivate List<String> comments = null;\n\t\n\tpublic void addComment(String comment){\n\t\tif(comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tcomments.add(comment);\n\t}\n\t\n\tpublic void  writeTo(BufferedWriter out) throws IOException {\n\t\tif(comments == null)\n\t\t\treturn;\n\t\t\n\t\tfor(String comment:comments)\n\t\t\tout.write(\"% \"+comment + \"\\n\");\n\t}\n\tpublic void copyComments(LogicProgramArtifact other){\n\t\tif(other.comments == null)\n\t\t\treturn;\n\t\tif(this.comments == null)\n\t\t\tcomments = new ArrayList<String>();\n\t\tthis.comments.addAll(other.comments);\n\t}\n"]]}
{"hexsha": "26dda56691b09a01ad828c280432170a49807b73", "ext": "java", "lang": "Java", "content": "public class LineSegment {\n  \n  private Point start;\n  private Point end;\n  private double dX;\n  private double dY;\n  \n  /**\n   * Constructor LineSegment\n   * @param start point\n   * @param end point\n   * @return new LineSegment Object\n   */\n  public LineSegment (Point start, Point end) throws Exception {\n    \n    this.start = start;\n    this.end = end;\n    this.dX = this.start.getX() - this.end.getX();\n    this.dY = this.start.getY() - this.end.getY();\n  }\n\n  /**\n   * getStart\n   * @return this line's start point\n   * @throws Exception\n   */\n  public Point getStart () throws Exception {\n    \n    return this.start;\n  }\n  \n  /**\n   * getEnd\n   * @return this line's end point\n   * @throws Exception\n   */\n  public Point getEnd () throws Exception {\n    \n    return this.end;\n  }\n  \n  /**\n   * equal\n   * @param line\n   * @return true if lines are equivalent and false otherwise\n   * @throws Exception\n   */\n  public boolean equal (LineSegment line) throws Exception {\n    \n    if (this.start.equal(line.start) == true &&\n        this.end.equal(line.end) == true) {\n      \n      return true;\n    }\n    \n    if (this.start.equal(line.end) == true &&\n        this.end.equal(line.start) == true) {\n      \n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * getLength\n   * @return the line segment's length\n   * @throws Exception\n   */\n  public double getLength () throws Exception {\n    \n    return this.start.getDistance(this.end);\n  }\n  \n  /**\n   * getSlope\n   * @return this line's slope\n   * @throws Exception\n   */\n  public double getSlope () throws Exception {\n    \n    return\n      (this.start.getY() - this.end.getY() ) /\n      (this.start.getX() - this.end.getX() );\n  }\n  \n  /**\n   * getDirection\n   * @return this line's direction [-180 ... 180]\n   * @throws Exception\n   */\n  public double getDirection () throws Exception {\n    \n    return Math.toDegrees(Math.atan2(\n        this.end.getX() - this.start.getX(),\n        this.end.getY() - this.start.getY() ) );\n  }\n  \n  // 0 to 180\n  /**\n   * getDirectionDelta\n   * @param line\n   * @return the delta direction between this line and the param line\n   * @throws Exception\n   */\n  public double getDirectionDelta (LineSegment line) throws Exception {\n    \n    double deltaDir = Math.abs(this.getDirection() - line.getDirection() );\n    \n    if (deltaDir > 180) {\n      \n      deltaDir = 360 - deltaDir;\n    }\n    \n    return deltaDir;\n  }\n  \n  /**\n   * isPointOnLine\n   * @param point\n   * @return true if param point is on this line and false otherwise\n   * @throws Exception\n   */\n  public boolean isPointOnLine (Point point) throws Exception {\n    \n    if (this.start.equal(point) == true ||\n        this.end.equal(point) == true) {\n      \n      return true;\n    }\n    \n    if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX() ) &&\n          point.getX() >= Math.min(this.start.getX(), this.end.getX() ) ) ) {\n\n      return false;\n    }\n    \n    if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY() ) &&\n          point.getY() >= Math.min(this.start.getY(), this.end.getY() ) ) ) {\n    \n      return false;\n    }\n    \n    LineSegment testLine = new LineSegment(point, this.start);\n    \n    if (this.getSlope() != testLine.getSlope() ) {\n      \n      return false;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * getNearestPointOnLine\n   * @param point\n   * @return nearest point on this line to param point\n   * @throws Exception\n   */\n  public Point getNearestPointOnLine (Point point) throws Exception {\n    \n    if (this.isPointOnLine(point) == true) {\n      \n      return point;\n    }\n    \n    double u =\n      ((point.getX() - this.end.getX() ) *\n       this.dX + (point.getY() - this.end.getY() ) * this.dY) /\n      (this.dX * this.dX + this.dY * this.dY);\n    \n    if (u < 0.0) {\n      \n      return this.end;\n    } else if (u > 1.0) {\n      \n      return this.start;\n    } else {\n\n      return new Point (\n        this.end.getX() + u * this.dX,\n        this.end.getY() + u * this.dY);\n    }\n  }\n  \n  /**\n   * getMinDistance\n   * @param point\n   * @return minimum distance between param point and this line\n   * @throws Exception\n   */\n  public double getMinDistance (Point point) throws Exception {\n    \n    return point.getDistance(this.getNearestPointOnLine(point) );\n  }\n  \n  /**\n   * getIntersectionPoint\n   * @param line\n   * @return returns the point where this line and param line intersects and\n   *           null otherwise\n   * @throws Exception\n   */\n  public Point getIntersectionPoint (LineSegment line) throws Exception {\n    \n    StraightLine lineOne = new StraightLine(line);\n    StraightLine lineTwo = new StraightLine(this);\n    \n    Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);\n    \n    if (intersectionPoint == null) {\n      \n      return null;\n    }\n    \n    if (this.isPointOnLine(intersectionPoint) == true) {\n      \n      return intersectionPoint;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * projectionInRange\n   * @param point\n   * @return true if the point's projection intersects with this line and\n   *           false otherwise\n   * @throws Exception\n   */\n  public boolean pointProjectionInRange (Point point) throws Exception {\n    \n    double dx = this.end.getX() - this.start.getX();\n    double dy = this.end.getY() - this.start.getY();\n    \n    double innerProduct =\n      (point.getX() - this.start.getX() ) *\n      dx +\n      (point.getY() - this.start.getY() ) *\n      dy;\n    \n    return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;\n  }\n  \n  @Override\n  public String toString () {\n    \n    return\n      \"LineSegment: Start: \"\n      + this.start.toString()\n      + \" End: \"\n      + this.end.toString();\n  }\n}", "class_id": 0, "repo": "vangav/vos_backend", "file": "src/com/vangav/backend/math/geometry/LineSegment.java", "last_update_at": "2021-08-09T19:54:45+00:00", "question_id": "26dda56691b09a01ad828c280432170a49807b73", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LineSegment {\n  private Point start;\n  private Point end;\n  private double dX;\n  private double dY;\n  /**\n   * Constructor LineSegment\n   * @param start point\n   * @param end point\n   * @return new LineSegment Object\n   */\n  public LineSegment (Point start, Point end) throws Exception {\n    this.start = start;\n    this.end = end;\n    this.dX = this.start.getX() - this.end.getX();\n    this.dY = this.start.getY() - this.end.getY();\n  }\n  /**\n   * getStart\n   * @return this line's start point\n   * @throws Exception\n   */\n  public Point getStart () throws Exception {\n    return this.start;\n  }\n  /**\n   * getEnd\n   * @return this line's end point\n   * @throws Exception\n   */\n  public Point getEnd () throws Exception {\n    return this.end;\n  }\n  /**\n   * equal\n   * @param line\n   * @return true if lines are equivalent and false otherwise\n   * @throws Exception\n   */\n  public boolean equal (LineSegment line) throws Exception {\n    if (this.start.equal(line.start) == true &&\n        this.end.equal(line.end) == true) {\n      return true;\n    }\n    if (this.start.equal(line.end) == true &&\n        this.end.equal(line.start) == true) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * getLength\n   * @return the line segment's length\n   * @throws Exception\n   */\n  public double getLength () throws Exception {\n    return this.start.getDistance(this.end);\n  }\n  /**\n   * getSlope\n   * @return this line's slope\n   * @throws Exception\n   */\n  public double getSlope () throws Exception {\n    return\n      (this.start.getY() - this.end.getY() ) /\n      (this.start.getX() - this.end.getX() );\n  }\n  /**\n   * getDirection\n   * @return this line's direction [-180 ... 180]\n   * @throws Exception\n   */\n  public double getDirection () throws Exception {\n    return Math.toDegrees(Math.atan2(\n        this.end.getX() - this.start.getX(),\n        this.end.getY() - this.start.getY() ) );\n  }\n  // 0 to 180\n  /**\n   * getDirectionDelta\n   * @param line\n   * @return the delta direction between this line and the param line\n   * @throws Exception\n   */\n  public double getDirectionDelta (LineSegment line) throws Exception {\n    double deltaDir = Math.abs(this.getDirection() - line.getDirection() );\n    if (deltaDir > 180) {\n      deltaDir = 360 - deltaDir;\n    }\n    return deltaDir;\n  }\n  /**\n   * isPointOnLine\n   * @param point\n   * @return true if param point is on this line and false otherwise\n   * @throws Exception\n   */\n  public boolean isPointOnLine (Point point) throws Exception {\n    if (this.start.equal(point) == true ||\n        this.end.equal(point) == true) {\n      return true;\n    }\n    if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX() ) &&\n          point.getX() >= Math.min(this.start.getX(), this.end.getX() ) ) ) {\n      return false;\n    }\n    if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY() ) &&\n          point.getY() >= Math.min(this.start.getY(), this.end.getY() ) ) ) {\n      return false;\n    }\n    LineSegment testLine = new LineSegment(point, this.start);\n    if (this.getSlope() != testLine.getSlope() ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * getNearestPointOnLine\n   * @param point\n   * @return nearest point on this line to param point\n   * @throws Exception\n   */\n  public Point getNearestPointOnLine (Point point) throws Exception {\n    if (this.isPointOnLine(point) == true) {\n      return point;\n    }\n    double u =\n      ((point.getX() - this.end.getX() ) *\n       this.dX + (point.getY() - this.end.getY() ) * this.dY) /\n      (this.dX * this.dX + this.dY * this.dY);\n    if (u < 0.0) {\n      return this.end;\n    } else if (u > 1.0) {\n      return this.start;\n    } else {\n      return new Point (\n        this.end.getX() + u * this.dX,\n        this.end.getY() + u * this.dY);\n    }\n  }\n  /**\n   * getMinDistance\n   * @param point\n   * @return minimum distance between param point and this line\n   * @throws Exception\n   */\n  public double getMinDistance (Point point) throws Exception {\n    return point.getDistance(this.getNearestPointOnLine(point) );\n  }\n  /**\n   * getIntersectionPoint\n   * @param line\n   * @return returns the point where this line and param line intersects and\n   *           null otherwise\n   * @throws Exception\n   */\n  public Point getIntersectionPoint (LineSegment line) throws Exception {\n    StraightLine lineOne = new StraightLine(line);\n    StraightLine lineTwo = new StraightLine(this);\n    Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);\n    if (intersectionPoint == null) {\n      return null;\n    }\n    if (this.isPointOnLine(intersectionPoint) == true) {\n      return intersectionPoint;\n    }\n    return null;\n  }\n  /**\n   * projectionInRange\n   * @param point\n   * @return true if the point's projection intersects with this line and\n   *           false otherwise\n   * @throws Exception\n   */\n  public boolean pointProjectionInRange (Point point) throws Exception {\n    double dx = this.end.getX() - this.start.getX();\n    double dy = this.end.getY() - this.start.getY();\n    double innerProduct =\n      (point.getX() - this.start.getX() ) *\n      dx +\n      (point.getY() - this.start.getY() ) *\n      dy;\n    return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;\n  }\n  @Override\n  public String toString () {\n    return\n      \"LineSegment: Start: \"\n      + this.start.toString()\n      + \" End: \"\n      + this.end.toString();\n  }\n"]]}
{"hexsha": "aa0633d649b8023aede213d3d74bbd8b265feda2", "ext": "java", "lang": "Java", "content": "public class Configuration {\n    /* private constructor: static class */\n    private Configuration() {\n    }\n\n    /** Version number of the tool */\n    public static final String VERSION = \"1.0\";\n    /** General short description text to be encapsulated */\n    public static final String TOOL_DESCRIPTION = \"The PeriCAT - PERICLES Content Aggregation Tool, version \" + VERSION\n\t    + \", was used to encapsulate these information.\";\n    /** Directory for test data. This is for the unit tests. */\n    public static final String TEST_DIRECTORY = \"src\" + File.separator + \"test\" + File.separator + \"resources\"\n\t    + File.separator;\n\n    /** The directory where the projects directory will be created. */\n    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + \"test_directory\" + File.separator;\n    /** The result files of encapsulation processes will be stored here */\n    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"output\" + File.separator;\n    /** If encapsulated files are restored, they will be stored here */\n    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + \"restored\" + File.separator;\n    /** Directory where the scenarios or roles are stored */\n    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"scenarios\" + File.separator;\n    /** Directory in which external libraries are stored */\n    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + \"PeriCAT_libs\" + File.separator;\n\n    /** Image icon, for add buttons */\n    public static final Icon ADD_ICON = new ImageIcon(getImage(\"/images/add.png\"));\n    /** Image icon for delete buttons */\n    public static final Icon DELETE_ICON = new ImageIcon(getImage(\"/images/delete.png\"));\n    /** Image icon for save buttons */\n    public static final Icon SAVE_ICON = new ImageIcon(getImage(\"/images/disk.png\"));\n    /** Image icon for buttons that start a process */\n    public static final Icon START_ICON = new ImageIcon(getImage(\"/images/control_play_blue.png\"));\n\n    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();\n\n    /**\n     * Configures the constants of the projects directories.\n     */\n    public static void createEncapsulationConstants() {\n\tWORKING_DIRECTORY = getCurrentJarFolder() + File.separator;\n\tif (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {\n\t    OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_output\" + File.separator;\n\t}\n\tif (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {\n\t    RESTORED_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_restored\" + File.separator;\n\t}\n\tSCENARIO_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_scenarios\" + File.separator;\n\tLIBRARY_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_libs\" + File.separator;\n\tcreateProjectDirectories();\n    }\n\n    /**\n     * Load an image icon to be displayed on a button.\n     * \n     * @param path\n     * @return image for a button\n     */\n    public static Image getImage(String path) {\n\tURL url = Configuration.class.getResource(path);\n\tif (url == null) {\n\t    return null;\n\t}\n\treturn Toolkit.getDefaultToolkit().getImage(url);\n    }\n\n    /**\n     * Creates the project directories. To be called on tool start.\n     */\n    public static void createProjectDirectories() {\n\ttry {\n\t    FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));\n\t} catch (IOException e) {\n\t}\n    }\n\n    /**\n     * Gets the location of the .jar, to figure out where to create the project\n     * directory.\n     * \n     * @return File with path to jar directory\n     */\n    private static File getCurrentJarFolder() {\n\ttry {\n\t    File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI())\n\t\t    .getParentFile();\n\t    if (file.exists() && file.isDirectory()) {\n\t\treturn file;\n\t    }\n\t} catch (URISyntaxException e) {\n\t    System.err.println(\n\t\t    \"Exception while getting the locatio of the .jar. for the creation of the projects directory.\");\n\t}\n\treturn new File(\"./\");\n    }\n\n    /**\n     * Get the list of available algorithms\n     *\n     * Add here further algorithms, and comment out the \"not yet finished\"\n     * algorithms.\n     * \n     * @return algorithms for information encapsulation\n     */\n    public static List<AbstractAlgorithm> getAlgorithms() {\n\tif (algorithms.size() == 0) {\n\t    algorithms.add(new TextInformationFrame());\n\t    algorithms.add(new OpenStegoRandomLSBSteganography());\n\t    algorithms.add(new F5Steganography());\n\t    algorithms.add(new BagItPackaging());\n\t    algorithms.add(new PNGChunkAdding());\n\t    algorithms.add(new JPEGTextAdding());\n\t    algorithms.add(new PDFFileAttacher());\n\t    algorithms.add(new ZipPackaging());\n\t    algorithms.add(new TarPackaging());\n\t    algorithms.add(new OaiOreSubmissionInformationPackage());\n\t    algorithms.add(new MetsSubmissionInformationPackage());\n\t    algorithms.add(new QRCodeWatermarking());\n\t    algorithms.add(new ImageImageFrameExpanding());\n\t    algorithms.add(new ImageInformationEmbeddingFrame());\n\t}\n\treturn algorithms;\n    }\n}", "class_id": 0, "repo": "pericles-project/PeriCAT", "file": "src/main/java/main/Configuration.java", "last_update_at": "2021-04-26T20:56:53+00:00", "question_id": "aa0633d649b8023aede213d3d74bbd8b265feda2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Configuration {\n    /* private constructor: static class */\n    private Configuration() {\n    }\n    /** Version number of the tool */\n    public static final String VERSION = \"1.0\";\n    /** General short description text to be encapsulated */\n    public static final String TOOL_DESCRIPTION = \"The PeriCAT - PERICLES Content Aggregation Tool, version \" + VERSION\n\t    + \", was used to encapsulate these information.\";\n    /** Directory for test data. This is for the unit tests. */\n    public static final String TEST_DIRECTORY = \"src\" + File.separator + \"test\" + File.separator + \"resources\"\n\t    + File.separator;\n    /** The directory where the projects directory will be created. */\n    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + \"test_directory\" + File.separator;\n    /** The result files of encapsulation processes will be stored here */\n    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"output\" + File.separator;\n    /** If encapsulated files are restored, they will be stored here */\n    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + \"restored\" + File.separator;\n    /** Directory where the scenarios or roles are stored */\n    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"scenarios\" + File.separator;\n    /** Directory in which external libraries are stored */\n    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + \"PeriCAT_libs\" + File.separator;\n    /** Image icon, for add buttons */\n    public static final Icon ADD_ICON = new ImageIcon(getImage(\"/images/add.png\"));\n    /** Image icon for delete buttons */\n    public static final Icon DELETE_ICON = new ImageIcon(getImage(\"/images/delete.png\"));\n    /** Image icon for save buttons */\n    public static final Icon SAVE_ICON = new ImageIcon(getImage(\"/images/disk.png\"));\n    /** Image icon for buttons that start a process */\n    public static final Icon START_ICON = new ImageIcon(getImage(\"/images/control_play_blue.png\"));\n    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();\n    /**\n     * Configures the constants of the projects directories.\n     */\n    public static void createEncapsulationConstants() {\n\tWORKING_DIRECTORY = getCurrentJarFolder() + File.separator;\n\tif (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {\n\t    OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_output\" + File.separator;\n\t}\n\tif (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {\n\t    RESTORED_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_restored\" + File.separator;\n\t}\n\tSCENARIO_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_scenarios\" + File.separator;\n\tLIBRARY_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_libs\" + File.separator;\n\tcreateProjectDirectories();\n    }\n    /**\n     * Load an image icon to be displayed on a button.\n     * \n     * @param path\n     * @return image for a button\n     */\n    public static Image getImage(String path) {\n\tURL url = Configuration.class.getResource(path);\n\tif (url == null) {\n\t    return null;\n\t}\n\treturn Toolkit.getDefaultToolkit().getImage(url);\n    }\n    /**\n     * Creates the project directories. To be called on tool start.\n     */\n    public static void createProjectDirectories() {\n\ttry {\n\t    FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));\n\t    FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));\n\t} catch (IOException e) {\n\t}\n    }\n    /**\n     * Gets the location of the .jar, to figure out where to create the project\n     * directory.\n     * \n     * @return File with path to jar directory\n     */\n    private static File getCurrentJarFolder() {\n\ttry {\n\t    File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI())\n\t\t    .getParentFile();\n\t    if (file.exists() && file.isDirectory()) {\n\t\treturn file;\n\t    }\n\t} catch (URISyntaxException e) {\n\t    System.err.println(\n\t\t    \"Exception while getting the locatio of the .jar. for the creation of the projects directory.\");\n\t}\n\treturn new File(\"./\");\n    }\n    /**\n     * Get the list of available algorithms\n     *\n     * Add here further algorithms, and comment out the \"not yet finished\"\n     * algorithms.\n     * \n     * @return algorithms for information encapsulation\n     */\n    public static List<AbstractAlgorithm> getAlgorithms() {\n\tif (algorithms.size() == 0) {\n\t    algorithms.add(new TextInformationFrame());\n\t    algorithms.add(new OpenStegoRandomLSBSteganography());\n\t    algorithms.add(new F5Steganography());\n\t    algorithms.add(new BagItPackaging());\n\t    algorithms.add(new PNGChunkAdding());\n\t    algorithms.add(new JPEGTextAdding());\n\t    algorithms.add(new PDFFileAttacher());\n\t    algorithms.add(new ZipPackaging());\n\t    algorithms.add(new TarPackaging());\n\t    algorithms.add(new OaiOreSubmissionInformationPackage());\n\t    algorithms.add(new MetsSubmissionInformationPackage());\n\t    algorithms.add(new QRCodeWatermarking());\n\t    algorithms.add(new ImageImageFrameExpanding());\n\t    algorithms.add(new ImageInformationEmbeddingFrame());\n\t}\n\treturn algorithms;\n    }\n"]]}
{"hexsha": "4d4c08f2c43d46e7c3aa9a89f65e3118d5a52e33", "ext": "java", "lang": "Java", "content": "@Slf4j\nclass DiRowStructVisitorTest extends VisitorsTest {\n\n    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {\n        final DynamicMetadata meta = new DynamicMetadata();\n        meta.setName(name);\n        meta.setType(type);\n        dynamic.metadatas.add(meta);\n        dynamic.addColumnValue(value);\n    }\n\n    @Test\n    void visit() {\n        final RowStruct rowStruct = new RowStruct();\n        rowStruct.id = \":testing:\";\n        rowStruct.name = NAME;\n        rowStruct.shortP = SHORT;\n        rowStruct.shortC = SHORT;\n        rowStruct.intP = INT;\n        rowStruct.intC = INT;\n        rowStruct.longP = LONG;\n        rowStruct.longC = LONG;\n        rowStruct.floatP = FLOAT;\n        rowStruct.floatC = FLOAT;\n        rowStruct.doubleP = DOUBLE;\n        rowStruct.doubleC = DOUBLE;\n        rowStruct.bytes0 = BYTES0;\n        rowStruct.date0 = DATE;\n        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());\n        rowStruct.bigDecimal0 = BIGDEC;\n        rowStruct.bool1 = Boolean.TRUE;\n        rowStruct.array0 = INTEGERS;\n        rowStruct.object0 = new Rcd();\n        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;\n        rowStruct.h = NAME;\n        // dynamic\n        final Dynamic dynamic = new Dynamic();\n        createMetadata(dynamic, \"dynString\", \"id_String\", \"stringy\");\n        createMetadata(dynamic, \"dynInteger\", \"id_Integer\", INT);\n        createMetadata(dynamic, \"dynDouble\", \"id_Double\", DOUBLE);\n        createMetadata(dynamic, \"dynBytes\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesArray\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesBuffer\", \"id_byte[]\", ByteBuffer.allocate(100).wrap(BYTES0));\n        createMetadata(dynamic, \"dynBytesWString\", \"id_byte[]\", String.valueOf(BYTES0));\n        createMetadata(dynamic, \"dynBigDecimal\", \"id_BigDecimal\", BIGDEC);\n        createMetadata(dynamic, \"dynObject\", \"id_Object\", new Rcd());\n        createMetadata(dynamic, \"STRINGS\", \"id_List\", STRINGS);\n        createMetadata(dynamic, \"LONGS\", \"id_List\", LONGS);\n        createMetadata(dynamic, \"FLOATS\", \"id_List\", FLOATS);\n        createMetadata(dynamic, \"DOUBLES\", \"id_List\", DOUBLES);\n        createMetadata(dynamic, \"BOOLEANS\", \"id_List\", BOOLEANS);\n        createMetadata(dynamic, \"BYTES\", \"id_List\", BYTES);\n        createMetadata(dynamic, \"DATES\", \"id_List\", DATES);\n        createMetadata(dynamic, \"RECORDS\", \"id_List\", RECORDS);\n        rowStruct.dynamic = dynamic;\n        //\n        final DiRowStructVisitor visitor = new DiRowStructVisitor();\n        final Record record = visitor.get(rowStruct, factory);\n        final Schema schema = record.getSchema();\n        // should have 3 excluded fields\n        assertEquals(42, schema.getEntries().size());\n        // asserts Record\n        log.info(\"[visit] values: {}\", record);\n        assertEquals(\":testing:\", record.getString(\"id\"));\n        assertEquals(NAME, record.getString(\"name\"));\n        assertEquals(SHORT, record.getInt(\"shortP\"));\n        assertEquals(SHORT, record.getInt(\"shortC\"));\n        assertEquals(INT, record.getInt(\"intP\"));\n        assertEquals(INT, record.getInt(\"intC\"));\n        assertEquals(LONG, record.getLong(\"longP\"));\n        assertEquals(LONG, record.getLong(\"longC\"));\n        assertEquals(FLOAT, record.getFloat(\"floatP\"));\n        assertEquals(FLOAT, record.getFloat(\"floatC\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleP\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleC\"));\n        assertEquals(DATE.toInstant(), record.getDateTime(\"date0\").toInstant());\n        assertNull(record.getDateTime(\"date1\"));\n        assertEquals(ZONED_DATE_TIME, record.getDateTime(\"date2\"));\n        assertEquals(1946, record.getDateTime(\"date2\").getYear());\n        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString(\"bigDecimal0\")).doubleValue());\n        assertEquals(BIGDEC.toString(), record.getString(\"bigDecimal0\"));\n        assertFalse(record.getBoolean(\"bool0\"));\n        assertTrue(record.getBoolean(\"bool1\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"bytes0\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytes\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesArray\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesBuffer\"));\n        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes(\"dynBytesWString\"));\n        assertEquals(BIGDEC.toString(), record.getString(\"dynBigDecimal\"));\n        assertEquals(BIGDEC, new BigDecimal(record.getString(\"dynBigDecimal\")));\n        assertEquals(RECORD.toString(), record.getString(\"object0\"));\n        assertTrue(record.getBoolean(\"hAshcOdEdIrtY\"));\n        assertEquals(NAME, record.getString(\"h\"));\n        assertEquals(RECORD.toString(), record.getString(\"dynObject\"));\n        assertEquals(INTEGERS, record.getArray(Integer.class, \"array0\"));\n        assertEquals(STRINGS, record.getArray(String.class, \"STRINGS\"));\n        assertEquals(LONGS, record.getArray(Long.class, \"LONGS\"));\n        assertEquals(FLOATS, record.getArray(Float.class, \"FLOATS\"));\n        assertEquals(DOUBLES, record.getArray(Double.class, \"DOUBLES\"));\n        assertEquals(BOOLEANS, record.getArray(Boolean.class, \"BOOLEANS\"));\n        assertEquals(BYTES, record.getArray(byte[].class, \"BYTES\"));\n        assertEquals(DATES, record.getArray(ZonedDateTime.class, \"DATES\"));\n        assertEquals(RECORDS, record.getArray(Record.class, \"RECORDS\"));\n        record.getArray(Record.class, \"RECORDS\").forEach(r -> {\n            assertEquals(1, r.getInt(\"ntgr\"));\n            assertEquals(\"one\", r.getString(\"str\"));\n        });\n        assertEquals(3,\n                schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hAshcOdEdIrtY|h|id\")).count());\n        // check we don't have any technical field in our schema/record\n        assertEquals(0,\n                schema\n                        .getEntries()\n                        .stream()\n                        .filter(entry -> entry.getName().matches(\"hashCodeDirty|loopKey|lookKey\"))\n                        .count());\n        assertThrows(NullPointerException.class, () -> record.getBoolean(\"hashCodeDirty\"));\n        assertNull(record.getString(\"loopKey\"));\n        assertNull(record.getString(\"lookKey\"));\n    }\n\n    public static class Rcd {\n\n        public String str = \"one\";\n\n        public int ntgr = 1;\n    }\n}", "class_id": 0, "repo": "Talend/component-runtime", "file": "component-studio/component-runtime-di/src/test/java/org/talend/sdk/component/runtime/di/record/DiRowStructVisitorTest.java", "last_update_at": "2021-06-05T13:15:05+00:00", "question_id": "4d4c08f2c43d46e7c3aa9a89f65e3118d5a52e33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\nclass DiRowStructVisitorTest extends VisitorsTest {\n    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {\n        final DynamicMetadata meta = new DynamicMetadata();\n        meta.setName(name);\n        meta.setType(type);\n        dynamic.metadatas.add(meta);\n        dynamic.addColumnValue(value);\n    }\n    @Test\n    void visit() {\n        final RowStruct rowStruct = new RowStruct();\n        rowStruct.id = \":testing:\";\n        rowStruct.name = NAME;\n        rowStruct.shortP = SHORT;\n        rowStruct.shortC = SHORT;\n        rowStruct.intP = INT;\n        rowStruct.intC = INT;\n        rowStruct.longP = LONG;\n        rowStruct.longC = LONG;\n        rowStruct.floatP = FLOAT;\n        rowStruct.floatC = FLOAT;\n        rowStruct.doubleP = DOUBLE;\n        rowStruct.doubleC = DOUBLE;\n        rowStruct.bytes0 = BYTES0;\n        rowStruct.date0 = DATE;\n        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());\n        rowStruct.bigDecimal0 = BIGDEC;\n        rowStruct.bool1 = Boolean.TRUE;\n        rowStruct.array0 = INTEGERS;\n        rowStruct.object0 = new Rcd();\n        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;\n        rowStruct.h = NAME;\n        // dynamic\n        final Dynamic dynamic = new Dynamic();\n        createMetadata(dynamic, \"dynString\", \"id_String\", \"stringy\");\n        createMetadata(dynamic, \"dynInteger\", \"id_Integer\", INT);\n        createMetadata(dynamic, \"dynDouble\", \"id_Double\", DOUBLE);\n        createMetadata(dynamic, \"dynBytes\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesArray\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesBuffer\", \"id_byte[]\", ByteBuffer.allocate(100).wrap(BYTES0));\n        createMetadata(dynamic, \"dynBytesWString\", \"id_byte[]\", String.valueOf(BYTES0));\n        createMetadata(dynamic, \"dynBigDecimal\", \"id_BigDecimal\", BIGDEC);\n        createMetadata(dynamic, \"dynObject\", \"id_Object\", new Rcd());\n        createMetadata(dynamic, \"STRINGS\", \"id_List\", STRINGS);\n        createMetadata(dynamic, \"LONGS\", \"id_List\", LONGS);\n        createMetadata(dynamic, \"FLOATS\", \"id_List\", FLOATS);\n        createMetadata(dynamic, \"DOUBLES\", \"id_List\", DOUBLES);\n        createMetadata(dynamic, \"BOOLEANS\", \"id_List\", BOOLEANS);\n        createMetadata(dynamic, \"BYTES\", \"id_List\", BYTES);\n        createMetadata(dynamic, \"DATES\", \"id_List\", DATES);\n        createMetadata(dynamic, \"RECORDS\", \"id_List\", RECORDS);\n        rowStruct.dynamic = dynamic;\n        //\n        final DiRowStructVisitor visitor = new DiRowStructVisitor();\n        final Record record = visitor.get(rowStruct, factory);\n        final Schema schema = record.getSchema();\n        // should have 3 excluded fields\n        assertEquals(42, schema.getEntries().size());\n        // asserts Record\n        log.info(\"[visit] values: {}\", record);\n        assertEquals(\":testing:\", record.getString(\"id\"));\n        assertEquals(NAME, record.getString(\"name\"));\n        assertEquals(SHORT, record.getInt(\"shortP\"));\n        assertEquals(SHORT, record.getInt(\"shortC\"));\n        assertEquals(INT, record.getInt(\"intP\"));\n        assertEquals(INT, record.getInt(\"intC\"));\n        assertEquals(LONG, record.getLong(\"longP\"));\n        assertEquals(LONG, record.getLong(\"longC\"));\n        assertEquals(FLOAT, record.getFloat(\"floatP\"));\n        assertEquals(FLOAT, record.getFloat(\"floatC\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleP\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleC\"));\n        assertEquals(DATE.toInstant(), record.getDateTime(\"date0\").toInstant());\n        assertNull(record.getDateTime(\"date1\"));\n        assertEquals(ZONED_DATE_TIME, record.getDateTime(\"date2\"));\n        assertEquals(1946, record.getDateTime(\"date2\").getYear());\n        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString(\"bigDecimal0\")).doubleValue());\n        assertEquals(BIGDEC.toString(), record.getString(\"bigDecimal0\"));\n        assertFalse(record.getBoolean(\"bool0\"));\n        assertTrue(record.getBoolean(\"bool1\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"bytes0\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytes\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesArray\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesBuffer\"));\n        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes(\"dynBytesWString\"));\n        assertEquals(BIGDEC.toString(), record.getString(\"dynBigDecimal\"));\n        assertEquals(BIGDEC, new BigDecimal(record.getString(\"dynBigDecimal\")));\n        assertEquals(RECORD.toString(), record.getString(\"object0\"));\n        assertTrue(record.getBoolean(\"hAshcOdEdIrtY\"));\n        assertEquals(NAME, record.getString(\"h\"));\n        assertEquals(RECORD.toString(), record.getString(\"dynObject\"));\n        assertEquals(INTEGERS, record.getArray(Integer.class, \"array0\"));\n        assertEquals(STRINGS, record.getArray(String.class, \"STRINGS\"));\n        assertEquals(LONGS, record.getArray(Long.class, \"LONGS\"));\n        assertEquals(FLOATS, record.getArray(Float.class, \"FLOATS\"));\n        assertEquals(DOUBLES, record.getArray(Double.class, \"DOUBLES\"));\n        assertEquals(BOOLEANS, record.getArray(Boolean.class, \"BOOLEANS\"));\n        assertEquals(BYTES, record.getArray(byte[].class, \"BYTES\"));\n        assertEquals(DATES, record.getArray(ZonedDateTime.class, \"DATES\"));\n        assertEquals(RECORDS, record.getArray(Record.class, \"RECORDS\"));\n        record.getArray(Record.class, \"RECORDS\").forEach(r -> {\n            assertEquals(1, r.getInt(\"ntgr\"));\n            assertEquals(\"one\", r.getString(\"str\"));\n        });\n        assertEquals(3,\n                schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hAshcOdEdIrtY|h|id\")).count());\n        // check we don't have any technical field in our schema/record\n        assertEquals(0,\n                schema\n                        .getEntries()\n                        .stream()\n                        .filter(entry -> entry.getName().matches(\"hashCodeDirty|loopKey|lookKey\"))\n                        .count());\n        assertThrows(NullPointerException.class, () -> record.getBoolean(\"hashCodeDirty\"));\n        assertNull(record.getString(\"loopKey\"));\n        assertNull(record.getString(\"lookKey\"));\n    }\n    public static class Rcd {\n        public String str = \"one\";\n        public int ntgr = 1;\n    }\n"]]}
{"hexsha": "89a1a2463b6876a99f9253a15a2bbf7c892f989a", "ext": "java", "lang": "Java", "content": "public class JavaDebugImages {\n\n    //$NON-NLS-1$\n    private static String ICONS_PATH = \"$nl$/icons/full/\";\n\n    // The plugin registry\n    private static ImageRegistry fgImageRegistry = null;\n\n    /*\n\t * Available cached Images in the Java debug plug-in image registry.\n\t */\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION = \"IMG_OBJS_EXCEPTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_DISABLED = \"IMG_OBJS_EXCEPTION_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_ERROR = \"IMG_OBJS_ERROR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED = \"IMG_OBJS_BREAKPOINT_INSTALLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = \"IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LOCAL_VARIABLE = \"IMG_OBJS_LOCAL_VARIABLE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT = \"IMG_OBJS_METHOD_RESULT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = \"IMG_OBJS_METHOD_RESULT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = \"IMG_OBJS_CONDITIONAL_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = \"IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT = \"IMG_OBJS_SCOPED_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = \"IMG_OBJS_SCOPED_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = \"IMG_OBJS_UNCAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT = \"IMG_OBJS_CAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_SNIPPET_EVALUATING = \"IMG_OBJS_SNIPPET_EVALUATING\";\n\n    //$NON-NLS-1$\n    public static final String IMG_VIEW_ARGUMENTS_TAB = \"IMG_VIEW_ARGUMENTS_TAB\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_MONITOR = \"IMG_OBJS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CONTENDED_MONITOR = \"IMG_OBJS_CONTENDED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_OWNED_MONITOR = \"IMG_OBJS_OWNED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_REFERENCE = \"IMG_OBJS_REFERENCE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNED = \"IMG_OVR_OWNED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNS_MONITOR = \"IMG_OVR_OWNS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION = \"IMG_OVR_IN_CONTENTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = \"IMG_OVR_IN_CONTENTION_FOR_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_DEADLOCK = \"IMG_OVR_IN_DEADLOCK\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = \"IMG_OBJS_EXCEPTION_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LINE_BRKPT_TYPE = \"IMG_OBJS_LINE_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = \"IMG_OBJS_CLASSLOAD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_WATCHPOINT_TYPE = \"IMG_OBJS_WATCHPOINT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_JSP_BRKPT_TYPE = \"IMG_OBJS_JSP_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = \"IMG_OBJS_METHOD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_THREAD_GROUP = \"IMG_OBJS_THREAD_GROUP\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSPATH = \"IMG_OBJS_CLASSPATH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OUT_OF_SYNCH = \"IMG_OVR_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = \"IMG_OVR_MAY_BE_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SYNCHRONIZED = \"IMG_OVR_SYNCHRONIZED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_NEWSCRAPPAGE = \"IMG_WIZBAN_NEWSCRAPPAGE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_LIBRARY = \"IMG_WIZBAN_LIBRARY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET = \"IMG_TOOL_TERMSNIPPET\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_HOVER = \"IMG_TOOL_TERMSNIPPET_HOVER\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = \"IMG_TOOL_TERMSNIPPET_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = \"IMG_OBJ_JAVA_INSPECT_EXPRESSION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_AUTO_FORMAT = \"IMG_ELCL_AUTO_FORMAT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_ALL_REFERENCES = \"IMG_ELCL_ALL_REFERENCES\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_TRIGGER_POINT = \"IMG_OVR_IN_TRIGGER_POINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_TRIGGER_SUPPRESSED = \"IMG_OVR_TRIGGER_SUPPRESSED\";\n\n    /*\n\t * Set of predefined Image Descriptors.\n\t */\n    //$NON-NLS-1$\n    private static final String T_OBJ = ICONS_PATH + \"obj16/\";\n\n    //$NON-NLS-1$\n    private static final String T_OVR = ICONS_PATH + \"ovr16/\";\n\n    //$NON-NLS-1$\n    private static final String T_WIZBAN = ICONS_PATH + \"wizban/\";\n\n    //$NON-NLS-1$\n    private static final String T_EVIEW = ICONS_PATH + \"eview16/\";\n\n    //$NON-NLS-1$\n    private static final String T_DLCL = ICONS_PATH + \"dtool16/\";\n\n    //$NON-NLS-1$\n    private static final String T_ELCL = ICONS_PATH + \"etool16/\";\n\n    //$NON-NLS-1$\n    private static final String E_LCL = ICONS_PATH + \"elcl16/\";\n\n    /**\n\t * Returns the image managed under the given key in this registry.\n\t *\n\t * @param key the image's key\n\t * @return the image managed under the given key\n\t */\n    public static Image get(String key) {\n        return getImageRegistry().get(key);\n    }\n\n    /**\n\t * Returns the <code>ImageDescriptor</code> identified by the given key,\n\t * or <code>null</code> if it does not exist.\n\t */\n    public static ImageDescriptor getImageDescriptor(String key) {\n        return getImageRegistry().getDescriptor(key);\n    }\n\n    /*\n\t * Helper method to access the image registry from the JDIDebugUIPlugin class.\n\t */\n    /* package */\n    static ImageRegistry getImageRegistry() {\n        if (fgImageRegistry == null) {\n            initializeImageRegistry();\n        }\n        return fgImageRegistry;\n    }\n\n    private static void initializeImageRegistry() {\n        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());\n        declareImages();\n    }\n\n    private static void declareImages() {\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + \"jexceptiond_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + \"installed_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + \"installed_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + \"reference_obj.gif\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + \"localvariable_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + \"methodresult_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + \"methodresult_obj_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + \"entry_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + \"entry_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + \"exit_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + \"exit_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + \"conditional_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + \"conditional_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + \"scoped_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + \"scoped_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + \"uncaught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + \"uncaught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + \"caught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + \"caught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + \"jrtexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + \"jsbook_run_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + \"variable_tab.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + \"error_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + \"warning_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + \"sync_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + \"monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNED, T_OVR + \"owned_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + \"ownsmonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + \"contention_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + \"contentionformonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + \"deadlock_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + \"contended_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + \"owned_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + \"threadgroup_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + \"newsbook_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + \"library_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + \"insp_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + \"classpath_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + \"jline_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + \"jload_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + \"jmeth_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + \"jspbrkpt_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + \"jwatch_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + \"autoform_menu.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + \"all_references.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + \"trigger_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + \"trigger_suppressed_ovr.png\");\n    }\n\n    /**\n     * Declare an Image in the registry table.\n     * @param key   The key to use when registering the image\n     * @param path  The path where the image can be found. This path is relative to where\n     *              this plugin class is found (i.e. typically the packages directory)\n     */\n    private static final void declareRegistryImage(String key, String path) {\n        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());\n        URL url = null;\n        if (bundle != null) {\n            url = FileLocator.find(bundle, new Path(path), null);\n            if (url != null) {\n                desc = ImageDescriptor.createFromURL(url);\n            }\n        }\n        fgImageRegistry.put(key, desc);\n    }\n}", "class_id": 0, "repo": "masud-technope/BLIZZARD-Replication-Package-ESEC-FSE2018", "file": "Corpus/eclipse.jdt.debug/147.java", "last_update_at": "2021-11-29T08:28:07+00:00", "question_id": "89a1a2463b6876a99f9253a15a2bbf7c892f989a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JavaDebugImages {\n    //$NON-NLS-1$\n    private static String ICONS_PATH = \"$nl$/icons/full/\";\n    // The plugin registry\n    private static ImageRegistry fgImageRegistry = null;\n    /*\n\t * Available cached Images in the Java debug plug-in image registry.\n\t */\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION = \"IMG_OBJS_EXCEPTION\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_DISABLED = \"IMG_OBJS_EXCEPTION_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_ERROR = \"IMG_OBJS_ERROR\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED = \"IMG_OBJS_BREAKPOINT_INSTALLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = \"IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LOCAL_VARIABLE = \"IMG_OBJS_LOCAL_VARIABLE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT = \"IMG_OBJS_METHOD_RESULT\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = \"IMG_OBJS_METHOD_RESULT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = \"IMG_OBJS_CONDITIONAL_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = \"IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT = \"IMG_OBJS_SCOPED_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = \"IMG_OBJS_SCOPED_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = \"IMG_OBJS_UNCAUGHT_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT = \"IMG_OBJS_CAUGHT_BREAKPOINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_SNIPPET_EVALUATING = \"IMG_OBJS_SNIPPET_EVALUATING\";\n    //$NON-NLS-1$\n    public static final String IMG_VIEW_ARGUMENTS_TAB = \"IMG_VIEW_ARGUMENTS_TAB\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_MONITOR = \"IMG_OBJS_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CONTENDED_MONITOR = \"IMG_OBJS_CONTENDED_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_OWNED_MONITOR = \"IMG_OBJS_OWNED_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_REFERENCE = \"IMG_OBJS_REFERENCE\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNED = \"IMG_OVR_OWNED\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNS_MONITOR = \"IMG_OVR_OWNS_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION = \"IMG_OVR_IN_CONTENTION\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = \"IMG_OVR_IN_CONTENTION_FOR_MONITOR\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_DEADLOCK = \"IMG_OVR_IN_DEADLOCK\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = \"IMG_OBJS_EXCEPTION_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LINE_BRKPT_TYPE = \"IMG_OBJS_LINE_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = \"IMG_OBJS_CLASSLOAD_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_WATCHPOINT_TYPE = \"IMG_OBJS_WATCHPOINT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_JSP_BRKPT_TYPE = \"IMG_OBJS_JSP_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = \"IMG_OBJS_METHOD_BRKPT_TYPE\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_THREAD_GROUP = \"IMG_OBJS_THREAD_GROUP\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSPATH = \"IMG_OBJS_CLASSPATH\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OUT_OF_SYNCH = \"IMG_OVR_OUT_OF_SYNCH\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = \"IMG_OVR_MAY_BE_OUT_OF_SYNCH\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SYNCHRONIZED = \"IMG_OVR_SYNCHRONIZED\";\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_NEWSCRAPPAGE = \"IMG_WIZBAN_NEWSCRAPPAGE\";\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_LIBRARY = \"IMG_WIZBAN_LIBRARY\";\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET = \"IMG_TOOL_TERMSNIPPET\";\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_HOVER = \"IMG_TOOL_TERMSNIPPET_HOVER\";\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = \"IMG_TOOL_TERMSNIPPET_DISABLED\";\n    //$NON-NLS-1$\n    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = \"IMG_OBJ_JAVA_INSPECT_EXPRESSION\";\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_AUTO_FORMAT = \"IMG_ELCL_AUTO_FORMAT\";\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_ALL_REFERENCES = \"IMG_ELCL_ALL_REFERENCES\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_TRIGGER_POINT = \"IMG_OVR_IN_TRIGGER_POINT\";\n    //$NON-NLS-1$\n    public static final String IMG_OVR_TRIGGER_SUPPRESSED = \"IMG_OVR_TRIGGER_SUPPRESSED\";\n    /*\n\t * Set of predefined Image Descriptors.\n\t */\n    //$NON-NLS-1$\n    private static final String T_OBJ = ICONS_PATH + \"obj16/\";\n    //$NON-NLS-1$\n    private static final String T_OVR = ICONS_PATH + \"ovr16/\";\n    //$NON-NLS-1$\n    private static final String T_WIZBAN = ICONS_PATH + \"wizban/\";\n    //$NON-NLS-1$\n    private static final String T_EVIEW = ICONS_PATH + \"eview16/\";\n    //$NON-NLS-1$\n    private static final String T_DLCL = ICONS_PATH + \"dtool16/\";\n    //$NON-NLS-1$\n    private static final String T_ELCL = ICONS_PATH + \"etool16/\";\n    //$NON-NLS-1$\n    private static final String E_LCL = ICONS_PATH + \"elcl16/\";\n    /**\n\t * Returns the image managed under the given key in this registry.\n\t *\n\t * @param key the image's key\n\t * @return the image managed under the given key\n\t */\n    public static Image get(String key) {\n        return getImageRegistry().get(key);\n    }\n    /**\n\t * Returns the <code>ImageDescriptor</code> identified by the given key,\n\t * or <code>null</code> if it does not exist.\n\t */\n    public static ImageDescriptor getImageDescriptor(String key) {\n        return getImageRegistry().getDescriptor(key);\n    }\n    /*\n\t * Helper method to access the image registry from the JDIDebugUIPlugin class.\n\t */\n    /* package */\n    static ImageRegistry getImageRegistry() {\n        if (fgImageRegistry == null) {\n            initializeImageRegistry();\n        }\n        return fgImageRegistry;\n    }\n    private static void initializeImageRegistry() {\n        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());\n        declareImages();\n    }\n    private static void declareImages() {\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + \"jexceptiond_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + \"installed_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + \"installed_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + \"reference_obj.gif\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + \"localvariable_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + \"methodresult_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + \"methodresult_obj_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + \"entry_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + \"entry_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + \"exit_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + \"exit_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + \"conditional_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + \"conditional_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + \"scoped_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + \"scoped_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + \"uncaught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + \"uncaught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + \"caught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + \"caught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + \"jrtexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + \"jsbook_run_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + \"variable_tab.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + \"error_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + \"warning_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + \"sync_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + \"monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNED, T_OVR + \"owned_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + \"ownsmonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + \"contention_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + \"contentionformonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + \"deadlock_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + \"contended_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + \"owned_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + \"threadgroup_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + \"newsbook_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + \"library_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + \"insp_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + \"classpath_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + \"jline_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + \"jload_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + \"jmeth_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + \"jspbrkpt_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + \"jwatch_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + \"autoform_menu.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + \"all_references.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + \"trigger_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + \"trigger_suppressed_ovr.png\");\n    }\n    /**\n     * Declare an Image in the registry table.\n     * @param key   The key to use when registering the image\n     * @param path  The path where the image can be found. This path is relative to where\n     *              this plugin class is found (i.e. typically the packages directory)\n     */\n    private static final void declareRegistryImage(String key, String path) {\n        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());\n        URL url = null;\n        if (bundle != null) {\n            url = FileLocator.find(bundle, new Path(path), null);\n            if (url != null) {\n                desc = ImageDescriptor.createFromURL(url);\n            }\n        }\n        fgImageRegistry.put(key, desc);\n    }\n"]]}
{"hexsha": "200206ad1100a42ddac095ef06efa73f03de0dd3", "ext": "java", "lang": "Java", "content": "class Example5_ConcatAndAppend {\n\n    /**\n     * Main Method. This is where the program begins.\n     */\n    public static void main(String[] args) {\n        String united = \"United\";\n        String states = \"States\";\n        String of = \"of\";\n        String america = \"America\";\n\n        String usa1;\n\n        usa1 = united + \" \" + states + \" \" + of + \" \" + america;            //Initializes the usa1 variable by...\n                                                                            // concatenating the united, states, of and america variables (with spaces)\n\n        System.out.println(\"Example 1: \" + usa1);                           //Prints the value of the usa variable\n\n        \n\n        String usa2;\n        usa2 = united;                                                      //Assigns the value of united to usa2\n\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n        usa2 = usa2 + states;                                               //Appends the value of states to usa2\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n\n        usa2 += of;                                                         //Appends the value of of to usa2\n        usa2 += \" \";                                                        //Appends a sapce to usa2\n        usa2 += america;                                                    //Appends the value of america to usa2\n\n        System.out.println(\"Example 2: \" + usa2);                           //Prints the value of usa2 variable\n    }\n\n}", "class_id": 0, "repo": "hackettccp/CSCI111", "file": "Modules/Module8/src/java_basics/Example5_ConcatAndAppend.java", "last_update_at": "2021-02-23T04:09:03+00:00", "question_id": "200206ad1100a42ddac095ef06efa73f03de0dd3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Example5_ConcatAndAppend {\n    /**\n     * Main Method. This is where the program begins.\n     */\n    public static void main(String[] args) {\n        String united = \"United\";\n        String states = \"States\";\n        String of = \"of\";\n        String america = \"America\";\n        String usa1;\n        usa1 = united + \" \" + states + \" \" + of + \" \" + america;            //Initializes the usa1 variable by...\n                                                                            // concatenating the united, states, of and america variables (with spaces)\n        System.out.println(\"Example 1: \" + usa1);                           //Prints the value of the usa variable\n        String usa2;\n        usa2 = united;                                                      //Assigns the value of united to usa2\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n        usa2 = usa2 + states;                                               //Appends the value of states to usa2\n        usa2 = usa2 + \" \";                                                  //Appends a space to usa2\n        usa2 += of;                                                         //Appends the value of of to usa2\n        usa2 += \" \";                                                        //Appends a sapce to usa2\n        usa2 += america;                                                    //Appends the value of america to usa2\n        System.out.println(\"Example 2: \" + usa2);                           //Prints the value of usa2 variable\n    }\n"]]}
{"hexsha": "be33f2724e1da203f9adeebe11e277cb5a219833", "ext": "java", "lang": "Java", "content": "@Structure(name = \"QSD\", structureType = StructureType.DATATYPE)\npublic class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {\n\n\t// The minuend of this difference\n\tprivate ISetComponent<T> m_minuend;\n\t// The subtrahend of this difference\n\tprivate ISetComponent<T> m_subtrahend;\n\t\n\t/**\n\t * Creates a new instance of the QSD{T} class\n\t */\n\tpublic QSD() { super(); }\n\t/**\n\t * Creates a new instance of the QSD class with the specified minuend and subtrahend\n\t * @param minuend The initial value of the minuend\n\t * @param subtrahend The initial value of the subtrahend\n\t */\n\tpublic QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend)\n\t{\n\t\tthis.m_minuend = minuend;\n\t\tthis.m_subtrahend = subtrahend;\n\t}\n\t\n\t/**\n\t * Gets the value representing the minuend of the difference expression\n\t */\n\t@Property(name = \"minuend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getMinuend() {\n\t\treturn this.m_minuend;\n\t}\n\t/**\n\t * Sets the value representing the minuend of the difference expression\n\t */\n\tpublic void setMinuend(ISetComponent<T> value) {\n\t\tthis.m_minuend = value;\n\t}\n\t/**\n\t * Gets the value representing the subtrahend\n\t */\n\t@Property(name = \"subtrahend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getSubtrahend() {\n\t\treturn this.m_subtrahend;\n\t}\n\t/**\n\t * Sets a value representing the subtrahend\n\t */\n\tpublic void setSubtrahend(ISetComponent<T> value) {\n\t\tthis.m_subtrahend = value;\n\t}\n\t/**\n\t * Normalize the expression\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic IGraphable normalize() {\n\t\tQSD<T> retVal = (QSD<T>)this.shallowCopy();\n        if (retVal.m_minuend instanceof SXPR<?>)\n            retVal.m_minuend = ((SXPR<T>)retVal.m_minuend).translateToQSET();\n        if (retVal.m_subtrahend instanceof SXPR<?>)\n            retVal.m_subtrahend = ((SXPR<T>)retVal.m_subtrahend).translateToQSET();\n        return retVal;\n\t}\n\n\t/**\n\t * Get the iterator\n\t */\n\t@Override\n\tpublic Iterator<ISetComponent<T>> iterator() {\n\t\tArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();\n\t\titerable.add(this.m_minuend);\n\t\titerable.add(this.m_subtrahend);\n\t\treturn iterable.iterator();\n\t}\n\n\t/**\n\t * Get the equivalent set operator\n\t */\n\t@Override\n\tprotected SetOperator getEquivalentSetOperator() {\n\t\treturn SetOperator.Exclusive;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.ANY#validateEx()\n\t */\n\t@Override\n\tpublic Collection<IResultDetail> validateEx() {\n\t\tList<IResultDetail> retVal = new ArrayList<IResultDetail>();\n        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));\n        if (this.m_minuend == null || this.m_minuend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Minuend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        if (this.m_subtrahend == null || this.m_subtrahend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Subtrahend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        return retVal;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.HXIT#validate()\n\t */\n\t@Override\n\tpublic boolean validate() {\n\t\tboolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());\n        return isValid;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = super.hashCode();\n\t\tresult = prime * result\n\t\t\t\t+ ((m_minuend == null) ? 0 : m_minuend.hashCode());\n\t\tresult = prime * result\n\t\t\t\t+ ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());\n\t\treturn result;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.equals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tQSD<T> other = (QSD<T>) obj;\n\t\tif (m_minuend == null) {\n\t\t\tif (other.m_minuend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_minuend.equals(other.m_minuend))\n\t\t\treturn false;\n\t\tif (m_subtrahend == null) {\n\t\t\tif (other.m_subtrahend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_subtrahend.equals(other.m_subtrahend))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\n}", "class_id": 0, "repo": "santedb/jeverest", "file": "org.marc.everest/src/main/java/org/marc/everest/datatypes/generic/QSD.java", "last_update_at": "2021-12-20T03:13:45+00:00", "question_id": "be33f2724e1da203f9adeebe11e277cb5a219833", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Structure(name = \"QSD\", structureType = StructureType.DATATYPE)\npublic class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {\n\t// The minuend of this difference\n\tprivate ISetComponent<T> m_minuend;\n\t// The subtrahend of this difference\n\tprivate ISetComponent<T> m_subtrahend;\n\t\n\t/**\n\t * Creates a new instance of the QSD{T} class\n\t */\n\tpublic QSD() { super(); }\n\t/**\n\t * Creates a new instance of the QSD class with the specified minuend and subtrahend\n\t * @param minuend The initial value of the minuend\n\t * @param subtrahend The initial value of the subtrahend\n\t */\n\tpublic QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend)\n\t{\n\t\tthis.m_minuend = minuend;\n\t\tthis.m_subtrahend = subtrahend;\n\t}\n\t\n\t/**\n\t * Gets the value representing the minuend of the difference expression\n\t */\n\t@Property(name = \"minuend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getMinuend() {\n\t\treturn this.m_minuend;\n\t}\n\t/**\n\t * Sets the value representing the minuend of the difference expression\n\t */\n\tpublic void setMinuend(ISetComponent<T> value) {\n\t\tthis.m_minuend = value;\n\t}\n\t/**\n\t * Gets the value representing the subtrahend\n\t */\n\t@Property(name = \"subtrahend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n\tpublic ISetComponent<T> getSubtrahend() {\n\t\treturn this.m_subtrahend;\n\t}\n\t/**\n\t * Sets a value representing the subtrahend\n\t */\n\tpublic void setSubtrahend(ISetComponent<T> value) {\n\t\tthis.m_subtrahend = value;\n\t}\n\t/**\n\t * Normalize the expression\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic IGraphable normalize() {\n\t\tQSD<T> retVal = (QSD<T>)this.shallowCopy();\n        if (retVal.m_minuend instanceof SXPR<?>)\n            retVal.m_minuend = ((SXPR<T>)retVal.m_minuend).translateToQSET();\n        if (retVal.m_subtrahend instanceof SXPR<?>)\n            retVal.m_subtrahend = ((SXPR<T>)retVal.m_subtrahend).translateToQSET();\n        return retVal;\n\t}\n\t/**\n\t * Get the iterator\n\t */\n\t@Override\n\tpublic Iterator<ISetComponent<T>> iterator() {\n\t\tArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();\n\t\titerable.add(this.m_minuend);\n\t\titerable.add(this.m_subtrahend);\n\t\treturn iterable.iterator();\n\t}\n\t/**\n\t * Get the equivalent set operator\n\t */\n\t@Override\n\tprotected SetOperator getEquivalentSetOperator() {\n\t\treturn SetOperator.Exclusive;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.ANY#validateEx()\n\t */\n\t@Override\n\tpublic Collection<IResultDetail> validateEx() {\n\t\tList<IResultDetail> retVal = new ArrayList<IResultDetail>();\n        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));\n        if (this.m_minuend == null || this.m_minuend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Minuend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        if (this.m_subtrahend == null || this.m_subtrahend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Subtrahend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        return retVal;\n\t}\n\t/** (non-Javadoc)\n\t * @see org.marc.everest.datatypes.HXIT#validate()\n\t */\n\t@Override\n\tpublic boolean validate() {\n\t\tboolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());\n        return isValid;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = super.hashCode();\n\t\tresult = prime * result\n\t\t\t\t+ ((m_minuend == null) ? 0 : m_minuend.hashCode());\n\t\tresult = prime * result\n\t\t\t\t+ ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());\n\t\treturn result;\n\t}\n\t/** (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (!super.equals(obj))\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tQSD<T> other = (QSD<T>) obj;\n\t\tif (m_minuend == null) {\n\t\t\tif (other.m_minuend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_minuend.equals(other.m_minuend))\n\t\t\treturn false;\n\t\tif (m_subtrahend == null) {\n\t\t\tif (other.m_subtrahend != null)\n\t\t\t\treturn false;\n\t\t} else if (!m_subtrahend.equals(other.m_subtrahend))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n"]]}
{"hexsha": "24ef2e880679f1e3b10ea8823a888c5bb2050a57", "ext": "java", "lang": "Java", "content": "public class LocalResourceSimpleAdapterTest extends AndroidTestCase {\n\n  public void testEagerAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertFalse(simpleAdapter.isLazy());\n  }\n\n  public void testLazyAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertTrue(simpleAdapter.isLazy());\n  }\n\n  private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {\n    Assert.assertNotNull(simpleAdapter);\n    Assert.assertEquals(10, requestedSize);\n    Assert.assertEquals(simpleAdapter.getSize(), requestedSize);\n    Uri firstUri = simpleAdapter.get(0);\n    assertNotNull(firstUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file1\"), firstUri);\n    Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);\n    assertNotNull(lastUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file10\"), lastUri);\n  }\n}", "class_id": 0, "repo": "app9gag/fresco", "file": "samples/scrollperf/src/androidTest/java/com/facebook/samples/scrollperf/data/impl/LocalResourceSimpleAdapterTest.java", "last_update_at": "2021-07-10T00:32:19+00:00", "question_id": "24ef2e880679f1e3b10ea8823a888c5bb2050a57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocalResourceSimpleAdapterTest extends AndroidTestCase {\n  public void testEagerAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertFalse(simpleAdapter.isLazy());\n  }\n  public void testLazyAdapter() {\n    final Context context = getContext();\n    final Resources res = context.getResources();\n    final String[] uris = res.getStringArray(R.array.local_uri_test);\n    Assert.assertNotNull(uris);\n    SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter\n        .getEagerAdapter(context, R.array.local_uri_test);\n    checkSimpleAdapterData(simpleAdapter, uris.length);\n    Assert.assertTrue(simpleAdapter.isLazy());\n  }\n  private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {\n    Assert.assertNotNull(simpleAdapter);\n    Assert.assertEquals(10, requestedSize);\n    Assert.assertEquals(simpleAdapter.getSize(), requestedSize);\n    Uri firstUri = simpleAdapter.get(0);\n    assertNotNull(firstUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file1\"), firstUri);\n    Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);\n    assertNotNull(lastUri);\n    assertEquals(Uri.parse(\"http://myserver.com/file10\"), lastUri);\n  }\n"]]}
{"hexsha": "0556eb05af9e2291d3785cc5ac51b749d932d51e", "ext": "java", "lang": "Java", "content": "public class HandleResponseImpl implements ResponseHandler<ResponseDto> {\n\n    @Override\n    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {\n        ResponseDto response = new ResponseDto();\n        if (null != httpResponse) {\n            response.setResponse(httpResponse);\n            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());\n            for (Header header : httpResponse.getAllHeaders()) {\n                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));\n            }\n            response.setContentType(response.getHeader(\"Content-Type\"));\n            response.setRequestId(response.getHeader(\"X-Ca-Request-Id\"));\n            response.setErrorMessage(response.getHeader(\"X-Ca-Error-Message\"));\n            if (httpResponse.getEntity() == null) {\n                response.setBody(null);\n            } else {\n                String s = readStreamAsStr(httpResponse.getEntity().getContent());\n                response.setBody(s);\n                response.setErrorMessage(s);\n            }\n        } else {\n            response.setStatusCode(500);\n            response.setErrorMessage(\"No Response\");\n        }\n        return response;\n    }\n\n    public static String readStreamAsStr(InputStream is) throws IOException {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            WritableByteChannel dest = Channels.newChannel(bos); ReadableByteChannel src = Channels.newChannel(is);) {\n            ByteBuffer bb = ByteBuffer.allocate(4096);\n            while (src.read(bb) != -1) {\n                bb.flip();\n                dest.write(bb);\n                bb.clear();\n            }\n            return new String(bos.toByteArray(), StandardCharsets.UTF_8);\n        }\n\n    }\n}", "class_id": 0, "repo": "MasterChenJiaWang/dahua-sdk", "file": "src/main/java/com/daren/chen/dahua/api/utils/HandleResponseImpl.java", "last_update_at": "2021-08-06T12:36:06+00:00", "question_id": "0556eb05af9e2291d3785cc5ac51b749d932d51e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HandleResponseImpl implements ResponseHandler<ResponseDto> {\n    @Override\n    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {\n        ResponseDto response = new ResponseDto();\n        if (null != httpResponse) {\n            response.setResponse(httpResponse);\n            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());\n            for (Header header : httpResponse.getAllHeaders()) {\n                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));\n            }\n            response.setContentType(response.getHeader(\"Content-Type\"));\n            response.setRequestId(response.getHeader(\"X-Ca-Request-Id\"));\n            response.setErrorMessage(response.getHeader(\"X-Ca-Error-Message\"));\n            if (httpResponse.getEntity() == null) {\n                response.setBody(null);\n            } else {\n                String s = readStreamAsStr(httpResponse.getEntity().getContent());\n                response.setBody(s);\n                response.setErrorMessage(s);\n            }\n        } else {\n            response.setStatusCode(500);\n            response.setErrorMessage(\"No Response\");\n        }\n        return response;\n    }\n    public static String readStreamAsStr(InputStream is) throws IOException {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            WritableByteChannel dest = Channels.newChannel(bos); ReadableByteChannel src = Channels.newChannel(is);) {\n            ByteBuffer bb = ByteBuffer.allocate(4096);\n            while (src.read(bb) != -1) {\n                bb.flip();\n                dest.write(bb);\n                bb.clear();\n            }\n            return new String(bos.toByteArray(), StandardCharsets.UTF_8);\n        }\n    }\n"]]}
{"hexsha": "9ef0a07c6c93211f564dd0ee9ac62d005881284a", "ext": "java", "lang": "Java", "content": "public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());\n    final static String HTTP_HEADER_NAME = \"Authorization\";\n    final static String HTTP_HEADER_VALUE_PREFIX = \"Bearer \";\n\n    final static String OIDC = \"oidc\";\n    public ServiceConfiguration conf;\n    public ConfigurationCacheService configCache;\n    private PulsarAuthorizationProvider defaultProvider;\n    private OidcTenantConfig oidcConfig;\n\n    public AuthorizationProviderOidc() { }\n\n    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache)\n            throws IOException {\n        initialize(conf, configCache);\n    }\n\n    @Override\n    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        this.conf = conf;\n        this.configCache = configCache;\n        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);\n        this.oidcConfig = new OidcConfig(conf);\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if(!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canProduceAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canLookupAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.isSuperUser(role, serviceConfiguration);\n        }\n\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    // TODO should this not be part of the OIDC client setup?\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {\n        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {\n        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);\n    }\n\n    @Override\n    public void close() throws IOException {\n        // NOP\n    }\n\n\n    @Override\n    public void initialize(ServiceConfiguration config) throws IOException {\n        this.oidcConfig = new OidcConfig(config);\n    }\n\n    @Override\n    public String getAuthMethodName() {\n        return OIDC;\n    }\n\n    @Override\n    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {\n        String biscuit = getJwt(authData);\n        return parseBiscuit(biscuit);\n    }\n\n    private static String validateJwt(final String jwt) throws AuthenticationException {\n        // Key check\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        } else {\n            throw new AuthenticationException(\"Blank biscuit found\");\n        }\n    }\n\n    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {\n        if (authData.hasDataFromCommand()) {\n            // Authenticate Pulsar binary connection\n            return authData.getCommandData();\n        } else if (authData.hasDataFromHttp()) {\n            // Authentication HTTP request. The format here should be compliant to RFC-6750\n            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx\n            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);\n            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {\n                throw new AuthenticationException(\"Invalid HTTP Authorization header\");\n            }\n\n            // Remove prefix\n            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());\n            return validateJwt(jwt);\n        } else {\n            throw new AuthenticationException(\"No JWT credentials passed\");\n        }\n    }\n\n    private String parseBiscuit(final String jwt) throws AuthenticationException {\n        LOGGER.info(\"Jwt to parse: {}\", jwt);\n\n//        Either<Error, Biscuit> deser = Biscuit.from_bytes(Base64.getUrlDecoder().decode(biscuit));\n//\n//        if (deser.isLeft()) {\n//            throw new AuthenticationException(\"Could not deserialize biscuit\");\n//        } else {\n//            Biscuit realBiscuit = deser.get();\n//            LOGGER.info(\"Deserialized biscuit\");\n//\n//            if (realBiscuit.check_root_key(rootKey).isLeft()) {\n//                throw new AuthenticationException(\"This biscuit was not generated with the expected root key\");\n//            }\n//            LOGGER.info(\"Root key is valid\");\n//\n//            byte[] sealed = realBiscuit.seal(BISCUIT_SEALING_KEY.getBytes()).get();\n//            LOGGER.info(\"Biscuit deserialized and sealed\");\n//            return \"biscuit:\" + Base64.getEncoder().encodeToString(sealed);\n//        }\n        // TODO\n        return \"\";\n    }\n}", "class_id": 0, "repo": "mvniekerk/poc-apache-pulsar-authz-oidc", "file": "src/main/java/za/co/koperfontein/poc/pulsar/oidc/AuthorizationProviderOidc.java", "last_update_at": "2021-11-18T16:58:34+00:00", "question_id": "9ef0a07c6c93211f564dd0ee9ac62d005881284a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());\n    final static String HTTP_HEADER_NAME = \"Authorization\";\n    final static String HTTP_HEADER_VALUE_PREFIX = \"Bearer \";\n    final static String OIDC = \"oidc\";\n    public ServiceConfiguration conf;\n    public ConfigurationCacheService configCache;\n    private PulsarAuthorizationProvider defaultProvider;\n    private OidcTenantConfig oidcConfig;\n    public AuthorizationProviderOidc() { }\n    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache)\n            throws IOException {\n        initialize(conf, configCache);\n    }\n    @Override\n    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        this.conf = conf;\n        this.configCache = configCache;\n        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);\n        this.oidcConfig = new OidcConfig(conf);\n    }\n    @Override\n    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if(!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canProduceAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canLookupAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    @Override\n    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.isSuperUser(role, serviceConfiguration);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n    // TODO should this not be part of the OIDC client setup?\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);\n    }\n    @Override\n    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {\n        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);\n    }\n    @Override\n    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {\n        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);\n    }\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);\n    }\n    @Override\n    public void close() throws IOException {\n        // NOP\n    }\n    @Override\n    public void initialize(ServiceConfiguration config) throws IOException {\n        this.oidcConfig = new OidcConfig(config);\n    }\n    @Override\n    public String getAuthMethodName() {\n        return OIDC;\n    }\n    @Override\n    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {\n        String biscuit = getJwt(authData);\n        return parseBiscuit(biscuit);\n    }\n    private static String validateJwt(final String jwt) throws AuthenticationException {\n        // Key check\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        } else {\n            throw new AuthenticationException(\"Blank biscuit found\");\n        }\n    }\n    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {\n        if (authData.hasDataFromCommand()) {\n            // Authenticate Pulsar binary connection\n            return authData.getCommandData();\n        } else if (authData.hasDataFromHttp()) {\n            // Authentication HTTP request. The format here should be compliant to RFC-6750\n            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx\n            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);\n            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {\n                throw new AuthenticationException(\"Invalid HTTP Authorization header\");\n            }\n            // Remove prefix\n            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());\n            return validateJwt(jwt);\n        } else {\n            throw new AuthenticationException(\"No JWT credentials passed\");\n        }\n    }\n    private String parseBiscuit(final String jwt) throws AuthenticationException {\n        LOGGER.info(\"Jwt to parse: {}\", jwt);\n//        Either<Error, Biscuit> deser = Biscuit.from_bytes(Base64.getUrlDecoder().decode(biscuit));\n//\n//        if (deser.isLeft()) {\n//            throw new AuthenticationException(\"Could not deserialize biscuit\");\n//        } else {\n//            Biscuit realBiscuit = deser.get();\n//            LOGGER.info(\"Deserialized biscuit\");\n//\n//            if (realBiscuit.check_root_key(rootKey).isLeft()) {\n//                throw new AuthenticationException(\"This biscuit was not generated with the expected root key\");\n//            }\n//            LOGGER.info(\"Root key is valid\");\n//\n//            byte[] sealed = realBiscuit.seal(BISCUIT_SEALING_KEY.getBytes()).get();\n//            LOGGER.info(\"Biscuit deserialized and sealed\");\n//            return \"biscuit:\" + Base64.getEncoder().encodeToString(sealed);\n//        }\n        // TODO\n        return \"\";\n    }\n"]]}
{"hexsha": "ac8564a3b708ca4495959d57dc906f61cac2ece9", "ext": "java", "lang": "Java", "content": "public class LeftJoinTest {\n    @Test\n    public void testLeftJoin(){\n        HashMap one = new HashMap();\n        one.put(\"kis\",\"pande\");\n        one.put(\"kiss\",\"pan\");\n        one.put(\"kisss\",\"pnde\");\n        one.put(\"kissss\",\"pae\");\n\n        HashMap two = new HashMap();\n        two.put(\"kis\",\"Sarvin\");\n        two.put(\"kiss\",\"Srvin\");\n        two.put(\"kisss\",\"Savin\");\n        two.put(\"kissss\",\"Sarvn\");\n\n        HashMap<String,String[]> test = LeftJoin.leftJoin(one,two);\n        assertEquals(\"\",4 , test.size());\n        assertTrue(\"\",test.containsKey(\"kisss\"));\n        assertEquals(\"\",\"pande\",test.get(\"kis\")[0]);\n\n    }\n\n}", "class_id": 0, "repo": "kishorpan2/data-structures-and-algorithms", "file": "code401Challenges/src/test/java/code401Challenges/hashTable/LeftJoinTest.java", "last_update_at": "2021-05-08T15:13:22+00:00", "question_id": "ac8564a3b708ca4495959d57dc906f61cac2ece9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LeftJoinTest {\n    @Test\n    public void testLeftJoin(){\n        HashMap one = new HashMap();\n        one.put(\"kis\",\"pande\");\n        one.put(\"kiss\",\"pan\");\n        one.put(\"kisss\",\"pnde\");\n        one.put(\"kissss\",\"pae\");\n        HashMap two = new HashMap();\n        two.put(\"kis\",\"Sarvin\");\n        two.put(\"kiss\",\"Srvin\");\n        two.put(\"kisss\",\"Savin\");\n        two.put(\"kissss\",\"Sarvn\");\n        HashMap<String,String[]> test = LeftJoin.leftJoin(one,two);\n        assertEquals(\"\",4 , test.size());\n        assertTrue(\"\",test.containsKey(\"kisss\"));\n        assertEquals(\"\",\"pande\",test.get(\"kis\")[0]);\n    }\n"]]}
{"hexsha": "763200963b9fac7b80736eb5620170b19b635e7e", "ext": "java", "lang": "Java", "content": "class TestingComponentD extends Component implements Cloneable {\n\n  @Prop(\n    resType = ResType.NONE,\n    optional = false\n  )\n  int prop1;\n\n  private TestingComponentD(ComponentContext context) {\n    super(\"TestingComponentD\");\n  }\n\n  public static Builder create(ComponentContext context) {\n    return create(context, 0, 0);\n  }\n\n  public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {\n    final Builder builder = new Builder();\n    TestingComponentD instance = new TestingComponentD(context);\n    builder.init(context, defStyleAttr, defStyleRes, instance);\n    return builder;\n  }\n\n  public static class Builder extends Component.Builder<Builder> {\n    @Nullable TestingComponentD mLithoComponent;\n    ComponentContext mContext;\n\n    private final String[] REQUIRED_PROPS_NAMES = new String[] {\"prop1\"};\n    private final int REQUIRED_PROPS_COUNT = 1;\n    private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n\n    private void init(\n        ComponentContext context,\n        int defStyleAttr,\n        int defStyleRes,\n        TestingComponentD lithoComponentRef) {\n      super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);\n      mLithoComponent = lithoComponentRef;\n      mContext = context;\n      mRequired.clear();\n    }\n\n    @Override\n    protected void setComponent(Component component) {\n      mLithoComponent = (TestingComponentD) component;\n    }\n\n    public Builder prop1(int prop1) {\n      this.mLithoComponent.prop1 = prop1;\n      mRequired.set(0);\n      return this;\n    }\n\n    @Override\n    public @Nullable TestingComponentD build() {\n      checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n      return mLithoComponent;\n    }\n\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n  }\n}", "class_id": 5, "repo": "penguin-wwy/redex", "file": "test/instr/RemoveBuilderPatternTest.java", "last_update_at": "2021-12-28T09:52:33+00:00", "question_id": "763200963b9fac7b80736eb5620170b19b635e7e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TestingComponentD extends Component implements Cloneable {\n  @Prop(\n    resType = ResType.NONE,\n    optional = false\n  )\n  int prop1;\n  private TestingComponentD(ComponentContext context) {\n    super(\"TestingComponentD\");\n  }\n  public static Builder create(ComponentContext context) {\n    return create(context, 0, 0);\n  }\n  public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {\n    final Builder builder = new Builder();\n    TestingComponentD instance = new TestingComponentD(context);\n    builder.init(context, defStyleAttr, defStyleRes, instance);\n    return builder;\n  }\n  public static class Builder extends Component.Builder<Builder> {\n    @Nullable TestingComponentD mLithoComponent;\n    ComponentContext mContext;\n    private final String[] REQUIRED_PROPS_NAMES = new String[] {\"prop1\"};\n    private final int REQUIRED_PROPS_COUNT = 1;\n    private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n    private void init(\n        ComponentContext context,\n        int defStyleAttr,\n        int defStyleRes,\n        TestingComponentD lithoComponentRef) {\n      super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);\n      mLithoComponent = lithoComponentRef;\n      mContext = context;\n      mRequired.clear();\n    }\n    @Override\n    protected void setComponent(Component component) {\n      mLithoComponent = (TestingComponentD) component;\n    }\n    public Builder prop1(int prop1) {\n      this.mLithoComponent.prop1 = prop1;\n      mRequired.set(0);\n      return this;\n    }\n    @Override\n    public @Nullable TestingComponentD build() {\n      checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n      return mLithoComponent;\n    }\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n  }\n"]]}
{"hexsha": "23db7ae693e11efffaedcecc41a12084a78574f9", "ext": "java", "lang": "Java", "content": "public class Aufgabe1 {\n\n\n//    Aufgabe 1 \u2014 Summe aller Arrayelemente:\n//    Vervollst\u00e4ndigen Sie das folgende Programm, so dass\n//    es die Summe aller Elemente des Arrays berechnet.\n//    Schreiben Sie das Programm, so dass es sogar dann\n//        funktioniert, wenn die Dimensionen der Zeilen und\n//    Spalten ge\u00e4ndert werden. (Mit anderen Worten,\n//    verwenden Sie eher length als fest kodierte Zahlen).\n\n    public static void aufg() {\n\n\n\n\n        int[][] data = { {3, 2, 5, 7},\n                {1, 4, 4, 8},\n                {9, 1, 0, 2},\n                {0, 2, 6, 3} };\n        // Summe deklarieren\n        int summe = 0;\n        // Summe berechnen\n        for ( int zeile=0; zeile < data.length; zeile++)\n        {\n            for ( int spalte = 0; spalte < data[zeile].length; spalte++)\n            {\n                summe += data[spalte][zeile];\n            }\n        }\n\n        // Summe ausgeben\n        System.out.println(\"Summe: \" + summe);\n\n\n\n\n    }\n\n\n\n}", "class_id": 0, "repo": "deanomus/SZUT", "file": "src/de/deanomus/FirstLehrjahr/A20_1_Mehrdimensionale_Arrays/Aufgabe1.java", "last_update_at": "2021-10-13T20:56:24+00:00", "question_id": "23db7ae693e11efffaedcecc41a12084a78574f9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Aufgabe1 {\n//    Aufgabe 1 \u2014 Summe aller Arrayelemente:\n//    Vervollst\u00e4ndigen Sie das folgende Programm, so dass\n//    es die Summe aller Elemente des Arrays berechnet.\n//    Schreiben Sie das Programm, so dass es sogar dann\n//        funktioniert, wenn die Dimensionen der Zeilen und\n//    Spalten ge\u00e4ndert werden. (Mit anderen Worten,\n//    verwenden Sie eher length als fest kodierte Zahlen).\n    public static void aufg() {\n        int[][] data = { {3, 2, 5, 7},\n                {1, 4, 4, 8},\n                {9, 1, 0, 2},\n                {0, 2, 6, 3} };\n        // Summe deklarieren\n        int summe = 0;\n        // Summe berechnen\n        for ( int zeile=0; zeile < data.length; zeile++)\n        {\n            for ( int spalte = 0; spalte < data[zeile].length; spalte++)\n            {\n                summe += data[spalte][zeile];\n            }\n        }\n        // Summe ausgeben\n        System.out.println(\"Summe: \" + summe);\n    }\n"]]}
{"hexsha": "a9493bf8c49764bbd03c7dd221f326510d0d8afa", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class CooldownsTest {\n\n    private static final String ENCHANT_NAME = \"enchantName\";\n    private static final UUID USER_ID = UUID.randomUUID();\n\n    @Mock\n    private Clock clock;\n    @Mock\n    private CustomEnchantment enchantment;\n    @Mock\n    private LivingEntity user;\n    @Mock\n    private Settings settings;\n\n    @Before\n    public void setUp() throws Exception {\n        TestUtils.set(Cooldowns.class, \"clock\", clock);\n\n        when(enchantment.getName()).thenReturn(ENCHANT_NAME);\n        when(user.getUniqueId()).thenReturn(USER_ID);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n\n    @Test\n    public void configure() throws Exception {\n        Cooldowns.configure(settings, 12, 23);\n\n        verify(settings).set(\"cooldown\", 12, 23);\n    }\n\n    @Test\n    public void secondsLeft() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 14);\n    }\n\n    @Test\n    public void secondsLeft_roundedUp() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1000L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(1.0);\n\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 1);\n    }\n\n    @Test\n    public void onCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n\n    @Test\n    public void onCooldown_exact() throws Exception {\n        when(clock.millis()).thenReturn(100L, 15100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void onCooldown_offCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduce() throws Exception {\n        when(clock.millis()).thenReturn(100L, 10100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, 6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduceNegative() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, -6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n}", "class_id": 0, "repo": "Eniripsa96/EnchantmentAPI", "file": "tst/com/sucy/enchant/api/CooldownsTest.java", "last_update_at": "2021-05-09T13:51:15+00:00", "question_id": "a9493bf8c49764bbd03c7dd221f326510d0d8afa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class CooldownsTest {\n    private static final String ENCHANT_NAME = \"enchantName\";\n    private static final UUID USER_ID = UUID.randomUUID();\n    @Mock\n    private Clock clock;\n    @Mock\n    private CustomEnchantment enchantment;\n    @Mock\n    private LivingEntity user;\n    @Mock\n    private Settings settings;\n    @Before\n    public void setUp() throws Exception {\n        TestUtils.set(Cooldowns.class, \"clock\", clock);\n        when(enchantment.getName()).thenReturn(ENCHANT_NAME);\n        when(user.getUniqueId()).thenReturn(USER_ID);\n    }\n    @After\n    public void tearDown() throws Exception {\n    }\n    @Test\n    public void configure() throws Exception {\n        Cooldowns.configure(settings, 12, 23);\n        verify(settings).set(\"cooldown\", 12, 23);\n    }\n    @Test\n    public void secondsLeft() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 14);\n    }\n    @Test\n    public void secondsLeft_roundedUp() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1000L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(1.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 1);\n    }\n    @Test\n    public void onCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n    @Test\n    public void onCooldown_exact() throws Exception {\n        when(clock.millis()).thenReturn(100L, 15100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n    @Test\n    public void onCooldown_offCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n    @Test\n    public void reduce() throws Exception {\n        when(clock.millis()).thenReturn(100L, 10100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, 6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n    @Test\n    public void reduceNegative() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, -6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n"]]}
{"hexsha": "13885d2553f83227a07c14f88340bf149ac6a251", "ext": "java", "lang": "Java", "content": "public class IndexBall extends CommandBase {\n\t\n\tFeederSubsystem feeder;\n\tint targetPositon;\n\tint incrementTicks;\n\tboolean reversing;\n\tboolean isDone;\n\n\tboolean maxBalls;\n\tboolean outputSwitchPressed;\n\n\tprivate final boolean setTalonPosistionEveryCycle = true;\n\t\n\n\tpublic IndexBall() {\n\t\t\n\t\tfeeder = FeederSubsystem.getInstance();\n\n\t\taddRequirements(feeder);\n\t}\n\n\t// Called when the command is initially scheduled.\n\t@Override\n\tpublic void initialize() {\n\t\tincrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();\n\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\ttargetPositon = currentPosition + incrementTicks;\n\n\t\treversing = false;\n\t\tisDone = false;\n\n\t\tif (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {\n\t\t\tmaxBalls = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tmaxBalls = false;\n\t\toutputSwitchPressed = false;\n\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t\n\t}\n\n\t// Called every time the scheduler runs while the command is scheduled.\n\t@Override\n\tpublic void execute() {\n\t\tif (maxBalls == true) {\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t}\n\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\tboolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);\n\t\tint ticksChanged = currentPosition - (targetPositon - incrementTicks);\n\t\t\n\t\tif (currentPosition >= targetPositon || atPosistion) {\n\t\t\tisDone = true;\n\t\t} else if (reversing) {\n\t\t\tif (atPosistion) {\n\t\t\t\tisDone = true;\n\t\t\t} else if(setTalonPosistionEveryCycle) {\n\t\t\t\tfeeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t}\n\t\t// } else if (feeder.isBallAtInput() == false && ticksChanged < Config.FEEDERSUBSYSTEM_POS_PAST_SWITCH) {\n\t\t\t// Limit unpressed & in range that it should be pressed then reverse, likely ball bounced away\n\t\t\t// feeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t// reversing = true;\n\t\t} else if (setTalonPosistionEveryCycle) {\n\t\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t}\n\n\t}\n\n\t// Called once the command ends or is interrupted.\n\t@Override\n\tpublic void end(boolean interrupted) {\n\t\tif (reversing == false && maxBalls == false && outputSwitchPressed == false) {\n\t\t\tfeeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);\n\t\t}\n\n\t\tif (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {\n\t\t\tfeeder.setFeederPosistion((int) feeder.getCurrentPosition());\n\t\t\tfeeder.stopFeeder();\n\t\t}\n\t}\n\n\t// Returns true when the command should end.\n\t@Override\n\tpublic boolean isFinished() {\n\t\treturn isDone;\n\t}\n}", "class_id": 0, "repo": "davidliu-2706/2022-Test", "file": "src/main/java/frc/robot/commands/IndexBall.java", "last_update_at": "2021-11-10T21:09:19+00:00", "question_id": "13885d2553f83227a07c14f88340bf149ac6a251", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IndexBall extends CommandBase {\n\t\n\tFeederSubsystem feeder;\n\tint targetPositon;\n\tint incrementTicks;\n\tboolean reversing;\n\tboolean isDone;\n\tboolean maxBalls;\n\tboolean outputSwitchPressed;\n\tprivate final boolean setTalonPosistionEveryCycle = true;\n\t\n\tpublic IndexBall() {\n\t\t\n\t\tfeeder = FeederSubsystem.getInstance();\n\t\taddRequirements(feeder);\n\t}\n\t// Called when the command is initially scheduled.\n\t@Override\n\tpublic void initialize() {\n\t\tincrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\ttargetPositon = currentPosition + incrementTicks;\n\t\treversing = false;\n\t\tisDone = false;\n\t\tif (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {\n\t\t\tmaxBalls = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tthis.cancel();\n\t\t\treturn;\n\t\t}\n\t\tmaxBalls = false;\n\t\toutputSwitchPressed = false;\n\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t\n\t}\n\t// Called every time the scheduler runs while the command is scheduled.\n\t@Override\n\tpublic void execute() {\n\t\tif (maxBalls == true) {\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t} else if (FeederSubsystem.isBallAtOutput()) {\n\t\t\toutputSwitchPressed = true;\n\t\t\tisDone = true;\n\t\t\treturn;\n\t\t}\n\t\tint currentPosition = (int) feeder.getCurrentPosition();\n\t\tboolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);\n\t\tint ticksChanged = currentPosition - (targetPositon - incrementTicks);\n\t\t\n\t\tif (currentPosition >= targetPositon || atPosistion) {\n\t\t\tisDone = true;\n\t\t} else if (reversing) {\n\t\t\tif (atPosistion) {\n\t\t\t\tisDone = true;\n\t\t\t} else if(setTalonPosistionEveryCycle) {\n\t\t\t\tfeeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t}\n\t\t// } else if (feeder.isBallAtInput() == false && ticksChanged < Config.FEEDERSUBSYSTEM_POS_PAST_SWITCH) {\n\t\t\t// Limit unpressed & in range that it should be pressed then reverse, likely ball bounced away\n\t\t\t// feeder.setFeederPosistion(targetPositon - incrementTicks);\n\t\t\t// reversing = true;\n\t\t} else if (setTalonPosistionEveryCycle) {\n\t\t\tfeeder.setFeederPosistion(targetPositon);\n\t\t}\n\t}\n\t// Called once the command ends or is interrupted.\n\t@Override\n\tpublic void end(boolean interrupted) {\n\t\tif (reversing == false && maxBalls == false && outputSwitchPressed == false) {\n\t\t\tfeeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);\n\t\t}\n\t\tif (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {\n\t\t\tfeeder.setFeederPosistion((int) feeder.getCurrentPosition());\n\t\t\tfeeder.stopFeeder();\n\t\t}\n\t}\n\t// Returns true when the command should end.\n\t@Override\n\tpublic boolean isFinished() {\n\t\treturn isDone;\n\t}\n"]]}
{"hexsha": "f5cc2e0b1cbf8f1821a97d425e7f630fd91e4d34", "ext": "java", "lang": "Java", "content": "public abstract class ObjProperty extends AbstractParseTreeNode {\n  private static final long serialVersionUID = 3384973990326624609L;\n\n  public ObjProperty(StringLiteral name, Expression value) {\n    this(FilePosition.span(name.getFilePosition(), value.getFilePosition()),\n         name, value);\n  }\n\n  public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {\n    super(pos, Expression.class);\n    this.createMutation().appendChild(name).appendChild(value).execute();\n  }\n\n  /**\n   * Provided for reflection.\n   * @param value unused\n   */\n  protected ObjProperty(\n      FilePosition pos, Void value, List<? extends Expression> children) {\n    this(pos, (StringLiteral) children.get(0), children.get(1));\n    assert children.size() == 2;\n  }\n\n  @Override public final Object getValue() { return null; }\n\n  @Override\n  public List<? extends Expression> children() {\n    return childrenAs(Expression.class);\n  }\n\n  public final StringLiteral getPropertyNameNode() {\n    return (StringLiteral) children().get(0);\n  }\n\n  @Override\n  public void childrenChanged() {\n    super.childrenChanged();\n    if (2 != children().size()) { throw new IndexOutOfBoundsException(); }\n    getPropertyName();\n  }\n\n  public final String getPropertyName() {\n    return ((StringLiteral) children().get(0)).getUnquotedValue();\n  }\n\n  public boolean isPropertyNameQuoted() {\n    StringLiteral name = (StringLiteral) children().get(0);\n    String rawName = name.getValue();\n    if (rawName.length() == 0) { return false; }\n    char ch0 = rawName.charAt(0);\n    return ch0 == '\"' || ch0 == '\\'';\n  }\n\n  public final TokenConsumer makeRenderer(\n      Appendable out, Callback<IOException> handler) {\n    return new JsPrettyPrinter(new Concatenator(out, handler));\n  }\n\n  protected final void renderPropertyName(\n      RenderContext rc, boolean preferUnquoted) {\n    StringLiteral key = (StringLiteral) children().get(0);\n    TokenConsumer out = rc.getOut();\n    boolean unquoted = preferUnquoted;\n    switch (rc.propertyNameQuotingMode()) {\n      case NO_QUOTES: unquoted = true; break;\n      case PRESERVE_QUOTES:\n        String name = key.getValue();\n        if (name.length() == 0) {\n          unquoted = true;\n        } else {\n          char ch = name.charAt(0);\n          if (ch != '\"' && ch != '\\'') {\n            unquoted = true;\n          }\n        }\n        break;\n      default: break;\n    }\n    if (unquoted || preferUnquoted) {\n      String uqVal = key.getUnquotedValue();\n      if (ParserBase.isJavascriptIdentifier(uqVal)\n          && !(\"get\".equals(uqVal) || \"set\".equals(uqVal))) {\n        out.mark(key.getFilePosition());\n        out.consume(uqVal);\n        return;\n      }\n    }\n    key.render(rc);\n  }\n}", "class_id": 0, "repo": "michaelfig/caja", "file": "src/com/google/caja/parser/js/ObjProperty.java", "last_update_at": "2021-01-28T19:10:42+00:00", "question_id": "f5cc2e0b1cbf8f1821a97d425e7f630fd91e4d34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class ObjProperty extends AbstractParseTreeNode {\n  private static final long serialVersionUID = 3384973990326624609L;\n  public ObjProperty(StringLiteral name, Expression value) {\n    this(FilePosition.span(name.getFilePosition(), value.getFilePosition()),\n         name, value);\n  }\n  public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {\n    super(pos, Expression.class);\n    this.createMutation().appendChild(name).appendChild(value).execute();\n  }\n  /**\n   * Provided for reflection.\n   * @param value unused\n   */\n  protected ObjProperty(\n      FilePosition pos, Void value, List<? extends Expression> children) {\n    this(pos, (StringLiteral) children.get(0), children.get(1));\n    assert children.size() == 2;\n  }\n  @Override public final Object getValue() { return null; }\n  @Override\n  public List<? extends Expression> children() {\n    return childrenAs(Expression.class);\n  }\n  public final StringLiteral getPropertyNameNode() {\n    return (StringLiteral) children().get(0);\n  }\n  @Override\n  public void childrenChanged() {\n    super.childrenChanged();\n    if (2 != children().size()) { throw new IndexOutOfBoundsException(); }\n    getPropertyName();\n  }\n  public final String getPropertyName() {\n    return ((StringLiteral) children().get(0)).getUnquotedValue();\n  }\n  public boolean isPropertyNameQuoted() {\n    StringLiteral name = (StringLiteral) children().get(0);\n    String rawName = name.getValue();\n    if (rawName.length() == 0) { return false; }\n    char ch0 = rawName.charAt(0);\n    return ch0 == '\"' || ch0 == '\\'';\n  }\n  public final TokenConsumer makeRenderer(\n      Appendable out, Callback<IOException> handler) {\n    return new JsPrettyPrinter(new Concatenator(out, handler));\n  }\n  protected final void renderPropertyName(\n      RenderContext rc, boolean preferUnquoted) {\n    StringLiteral key = (StringLiteral) children().get(0);\n    TokenConsumer out = rc.getOut();\n    boolean unquoted = preferUnquoted;\n    switch (rc.propertyNameQuotingMode()) {\n      case NO_QUOTES: unquoted = true; break;\n      case PRESERVE_QUOTES:\n        String name = key.getValue();\n        if (name.length() == 0) {\n          unquoted = true;\n        } else {\n          char ch = name.charAt(0);\n          if (ch != '\"' && ch != '\\'') {\n            unquoted = true;\n          }\n        }\n        break;\n      default: break;\n    }\n    if (unquoted || preferUnquoted) {\n      String uqVal = key.getUnquotedValue();\n      if (ParserBase.isJavascriptIdentifier(uqVal)\n          && !(\"get\".equals(uqVal) || \"set\".equals(uqVal))) {\n        out.mark(key.getFilePosition());\n        out.consume(uqVal);\n        return;\n      }\n    }\n    key.render(rc);\n  }\n"]]}
{"hexsha": "0edf3c02e23be62144e02ee6a86e492b3b1ef462", "ext": "java", "lang": "Java", "content": "public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {\n    private Spin spin;\n\n    public void setSpin(Spin spin) {\n        this.spin = spin;\n    }\n\n    @Override\n    public void apply(String pluginId) {\n        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);\n        plugin.apply(spin);\n        spin.getPluginContainer()\n                .addPlugin(pluginId, plugin);\n    }\n\n    @Override\n    public Object invokeMethod(String name, Object[] args) {\n        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {\n            Object result = tryInvokeMethod(plugin, name, args);\n            if (result != null) {\n                return result;\n            }\n        }\n        throw new NoMethodFoundException(name);\n    }\n}", "class_id": 0, "repo": "tianxunaicaoke/LogSpin", "file": "core/src/main/java/org/logSpin/script/DefaultScriptDelegate.java", "last_update_at": "2021-02-03T02:12:13+00:00", "question_id": "0edf3c02e23be62144e02ee6a86e492b3b1ef462", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {\n    private Spin spin;\n    public void setSpin(Spin spin) {\n        this.spin = spin;\n    }\n    @Override\n    public void apply(String pluginId) {\n        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);\n        plugin.apply(spin);\n        spin.getPluginContainer()\n                .addPlugin(pluginId, plugin);\n    }\n    @Override\n    public Object invokeMethod(String name, Object[] args) {\n        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {\n            Object result = tryInvokeMethod(plugin, name, args);\n            if (result != null) {\n                return result;\n            }\n        }\n        throw new NoMethodFoundException(name);\n    }\n"]]}
{"hexsha": "4c2bc8c459162886daf755bef05a05afec9240d5", "ext": "java", "lang": "Java", "content": "public class LinkCommand extends RemoteControlCommandBase implements Cloneable{\n\n\t@Getter\n\tprivate String repeaterCallsign;\n\n\t@Getter\n\tprivate ReconnectType reconnectType;\n\n\t@Getter\n\tprivate String reflectorCallsign;\n\n\tpublic LinkCommand() {\n\t\tsuper(RemoteControlCommandType.LINK);\n\t}\n\n\t@Override\n\tpublic LinkCommand clone() {\n\t\tLinkCommand copy = null;\n\t\tcopy = (LinkCommand)super.clone();\n\n\t\tcopy.repeaterCallsign = repeaterCallsign;\n\n\t\tcopy.reconnectType = reconnectType;\n\n\t\tcopy.reflectorCallsign = reflectorCallsign;\n\n\t\treturn copy;\n\t}\n\n\t@Override\n\tprotected String getHeader() {\n\t\treturn \"LNK\";\n\t}\n\n\t@Override\n\tprotected boolean parseCommand(ByteBuffer srcBuffer) {\n\t\tint dataLength =\n\t\t\t\tDSTARDefines.CallsignFullLength +\n\t\t\t\t4 +\n\t\t\t\tDSTARDefines.CallsignFullLength;\n\n\t\tif(srcBuffer == null || srcBuffer.remaining() < dataLength)\n\t\t\treturn false;\n\n\t\tchar[] call = new char[DSTARDefines.CallsignFullLength];\n\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\n\t\trepeaterCallsign = String.valueOf(call);\n\n\t\tint reconnectTypeValue = 0;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\treconnectTypeValue <<= 8;\n\t\t\treconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();\n\t\t}\n\n\t\tthis.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);\n\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\n\t\treflectorCallsign = String.valueOf(call);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected Optional<byte[]> assembleCommandInt() {\n\t\treturn Optional.empty();\n\t}\n\n}", "class_id": 0, "repo": "jg1uaa/NoraSeries", "file": "src/NoraCommon/src/main/java/org/jp/illg/dstar/service/remotecontrol/model/command/LinkCommand.java", "last_update_at": "2021-05-03T04:39:05+00:00", "question_id": "4c2bc8c459162886daf755bef05a05afec9240d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LinkCommand extends RemoteControlCommandBase implements Cloneable{\n\t@Getter\n\tprivate String repeaterCallsign;\n\t@Getter\n\tprivate ReconnectType reconnectType;\n\t@Getter\n\tprivate String reflectorCallsign;\n\tpublic LinkCommand() {\n\t\tsuper(RemoteControlCommandType.LINK);\n\t}\n\t@Override\n\tpublic LinkCommand clone() {\n\t\tLinkCommand copy = null;\n\t\tcopy = (LinkCommand)super.clone();\n\t\tcopy.repeaterCallsign = repeaterCallsign;\n\t\tcopy.reconnectType = reconnectType;\n\t\tcopy.reflectorCallsign = reflectorCallsign;\n\t\treturn copy;\n\t}\n\t@Override\n\tprotected String getHeader() {\n\t\treturn \"LNK\";\n\t}\n\t@Override\n\tprotected boolean parseCommand(ByteBuffer srcBuffer) {\n\t\tint dataLength =\n\t\t\t\tDSTARDefines.CallsignFullLength +\n\t\t\t\t4 +\n\t\t\t\tDSTARDefines.CallsignFullLength;\n\t\tif(srcBuffer == null || srcBuffer.remaining() < dataLength)\n\t\t\treturn false;\n\t\tchar[] call = new char[DSTARDefines.CallsignFullLength];\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\t\trepeaterCallsign = String.valueOf(call);\n\t\tint reconnectTypeValue = 0;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\treconnectTypeValue <<= 8;\n\t\t\treconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();\n\t\t}\n\t\tthis.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);\n\t\tfor(int i = 0; i < DSTARDefines.CallsignFullLength; i++)\n\t\t\tcall[i] = (char)srcBuffer.get();\n\t\treflectorCallsign = String.valueOf(call);\n\t\treturn true;\n\t}\n\t@Override\n\tprotected Optional<byte[]> assembleCommandInt() {\n\t\treturn Optional.empty();\n\t}\n"]]}
{"hexsha": "028d0eb48fa34b8302e7d54fb8e8862b7ef0b42c", "ext": "java", "lang": "Java", "content": "public class CustomError {\n\tprivate final Logger logger;\n\tprivate boolean some_enabled = false;\n\n\t// Options\n\tprivate boolean escalate_exceptions = false;\n\tprivate boolean equal_is_strict_equal = false;\n\tprivate boolean enforce_existing_properties = false;\n\tprivate boolean boolean_op_only_boolean_operands = false;\n\tprivate boolean arith_op_no_undefined = false;\n\tprivate boolean arith_op_no_null = false;\n\tprivate boolean arith_op_no_nan = false;\n\tprivate boolean arith_op_no_infinity = false;\n\tprivate boolean division_op_no_zero = false;\n\n\tpublic CustomError(Logger lgr) {\n\t\tthis.logger = lgr;\n\t}\n\n\t/**\n\t * Set an option for this instance.\n\t *\n\t * @param name Name of the option\n\t * @param value Option value\n\t */\n\tpublic void setOption(String name, Object value) {\n\t\ttry {\n\t\t\tswitch (name) {\n\t\t\t\tcase \"escalate_exceptions\":\n\t\t\t\t\tescalate_exceptions = (boolean) value;\n\t\t\t\t\tlogSetOption(name, escalate_exceptions);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\t\tequal_is_strict_equal = (boolean) value;\n\t\t\t\t\tlogSetOption(name, equal_is_strict_equal);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\t\tenforce_existing_properties = (boolean) value;\n\t\t\t\t\tlogSetOption(name, enforce_existing_properties);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\t\tboolean_op_only_boolean_operands = (boolean) value;\n\t\t\t\t\tlogSetOption(name, boolean_op_only_boolean_operands);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\t\tarith_op_no_undefined = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_undefined);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_null\":\n\t\t\t\t\tarith_op_no_null = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\t\tarith_op_no_nan = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_nan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\t\tarith_op_no_infinity = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_infinity);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"division_op_no_zero\":\n\t\t\t\t\tdivision_op_no_zero = (boolean) value;\n\t\t\t\t\tlogSetOption(name, division_op_no_zero);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t}\n\t\t} catch (ClassCastException cce) {\n\t\t\tlogger.warning(\"CustomError: Cannot cast value for option '\" + name + \"'\");\n\t\t}\n\t\trecalculateSomeEnabled();\n\t}\n\n\tprivate void logSetOption(String name, boolean enabled) {\n\t\tif (enabled) {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' enabled\");\n\t\t} else {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' disabled\");\n\t\t}\n\t}\n\n\t/**\n\t * Get an option value from the instance.\n\t *\n\t * @param name Name of the option\n\t * @return Option value\n\t */\n\tpublic Object getOption(String name) {\n\t\tswitch (name) {\n\t\t\tcase \"escalate_exceptions\":\n\t\t\t\treturn this.escalate_exceptions;\n\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\treturn this.equal_is_strict_equal;\n\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\treturn this.enforce_existing_properties;\n\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\treturn this.boolean_op_only_boolean_operands;\n\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\treturn this.arith_op_no_undefined;\n\t\t\tcase \"arith_op_no_null\":\n\t\t\t\treturn this.arith_op_no_null;\n\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\treturn this.arith_op_no_nan;\n\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\treturn this.arith_op_no_infinity;\n\t\t\tcase \"division_op_no_zero\":\n\t\t\t\treturn this.division_op_no_zero;\n\t\t\tdefault:\n\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Check if at least one option is enabled.\n\t *\n\t * @return true, if at least one custom error class is enabled\n\t */\n\tpublic boolean someEnabled() {\n\t\treturn this.some_enabled;\n\t}\n\n\t/**\n\t * Recalculate if at least one option is enabled.\n\t */\n\tprivate void recalculateSomeEnabled() {\n\t\tthis.some_enabled = this.escalate_exceptions ||\n\t\t\t\t\t\t\tthis.equal_is_strict_equal ||\n\t\t\t\t\t\t\tthis.enforce_existing_properties ||\n\t\t\t\t\t\t\tthis.boolean_op_only_boolean_operands ||\n\t\t\t\t\t\t\tthis.arith_op_no_undefined ||\n\t\t\t\t\t\t\tthis.arith_op_no_null ||\n\t\t\t\t\t\t\tthis.arith_op_no_nan ||\n\t\t\t\t\t\t\tthis.arith_op_no_infinity ||\n\t\t\t\t\t\t\tthis.division_op_no_zero;\n\t}\n\n\t/**\n\t * Enable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void enable(String type) {\n\t\tsetOption(type, true);\n\t}\n\n\t/**\n\t * Disable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void disable(String type) {\n\t\tsetOption(type, false);\n\t}\n\n\t// exposed functions for use in wrapper nodes\n\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\t\tinspectDivisionZero(operation_name, value, input_index, line_num);\n\t\t\t\t// no break, division is also arithmetic operation\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t\tcase \"JSAndNode\":\n\t\t\tcase \"JSOrNode\":\n\t\t\tcase \"JSNotNodeGen\":\n\t\t\t\tif (boolean_op_only_boolean_operands) {\n\t\t\t\t\tif (!JSGuards.isBoolean(value)) {\n\t\t\t\t\t\tlogger.info(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands)\");\n\t\t\t\t\t\tthrow new EscalatedException(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {\n\t\tif (division_op_no_zero && input_index == 1) {\n\t\t\tObject num = JSRuntime.toNumeric(value);\n\t\t\tif (num instanceof BigInt) {\n\t\t\t\tBigInt bigint_num = (BigInt) num;\n\t\t\t\tif (bigint_num.equals(BigInt.ZERO)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Integer) {\n\t\t\t\tInteger int_num = (Integer) num;\n\t\t\t\tif (int_num.equals(0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name +\n\t\t\t\t\t\t\t\t\t\", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof SafeInteger) {\n\t\t\t\tSafeInteger safeint_num = (SafeInteger) num;\n\t\t\t\tif (safeint_num.intValue() == 0) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Double) {\n\t\t\t\tDouble double_num = (Double) num;\n\t\t\t\tif (double_num.equals(0.0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.warning(\"CustomError::inspect(): Unexpected value \" + num.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectReturnValue(String operation_name, Object value, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void inspectArithmeticValues(String operation_name, Object value, int line_num) {\n\t\tif (arith_op_no_undefined) {\n\t\t\tif (JSGuards.isUndefined(value)) {\n\t\t\t\tlogger.info(\"Detected undefined value for arithmetic operation (arith_op_no_undefined)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected undefined value for arithmetic operation (arith_op_no_undefined). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_null) {\n\t\t\t//if (JSGuards.isJSNull(value)) { //TODO does not work\n\t\t\tif (value.toString().startsWith(\"DynamicObject<null>\")) {\n\t\t\t\tlogger.info(\"Detected null value for arithmetic operation (arith_op_no_null)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected null value for arithmetic operation (arith_op_no_null). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_nan) {\n\t\t\tif (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {\n\t\t\t\tlogger.info(\"Detected NaN value for arithmetic operation (arith_op_no_nan)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected NaN value for arithmetic operation (arith_op_no_nan). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_infinity) {\n\t\t\tif (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {\n\t\t\t\tlogger.info(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected Infinity value for arithmetic operation (arith_op_no_infinity). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return Value of option \"escalate_exceptions\"\n\t */\n\tpublic boolean escalateExceptionsEnabled() {\n\t\treturn escalate_exceptions;\n\t}\n\n\t/**\n\t * @return Value of option \"equal_is_strict_equal\"\n\t */\n\tpublic boolean equalIsStrictEqualEnabled() {\n\t\treturn equal_is_strict_equal;\n\t}\n\n\t/**\n\t * @return Value of option \"enforce_existing_properties\"\n\t */\n\tpublic boolean enforceExistingPropertiesEnabled() {\n\t\treturn enforce_existing_properties;\n\t}\n\n\t/**\n\t * Create a new Exception that cannot be caught.\n\t *\n\t * @param message Message of the exception\n\t * @return Exception of type \"EscalatedException\"\n\t */\n\tpublic static EscalatedException createException(String message) {\n\t\treturn new EscalatedException(message);\n\t}\n\n\t/**\n\t * This class should be used whenever an error occurs in the programs execution.\n\t * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)\n\t * will be caught by a try-catch-statement in the guest language source code.\n\t * This exception extends RuntimeException directly and therefore will not be caught\n\t * by any safety measures in the guest language. It can only be caught by the Fuzzer\n\t * itself.\n\t */\n\tpublic static class EscalatedException extends RuntimeException {\n\t\tpublic EscalatedException() {\n\t\t\tsuper();\n\t\t}\n\n\t\tpublic EscalatedException(String message) {\n\t\t\tsuper(message);\n\t\t}\n\n\t\tpublic EscalatedException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\n\t\tpublic EscalatedException(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\n\t\tprotected EscalatedException(String message, Throwable cause,\n\t\t\t\t\t\t\t\t   boolean enableSuppression,\n\t\t\t\t\t\t\t\t   boolean writableStackTrace) {\n\t\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "rdelhougne/GraalFuzzing", "file": "fuzzingtool/core/src/main/java/org/fuzzingtool/core/components/CustomError.java", "last_update_at": "2021-04-13T15:48:38+00:00", "question_id": "028d0eb48fa34b8302e7d54fb8e8862b7ef0b42c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomError {\n\tprivate final Logger logger;\n\tprivate boolean some_enabled = false;\n\t// Options\n\tprivate boolean escalate_exceptions = false;\n\tprivate boolean equal_is_strict_equal = false;\n\tprivate boolean enforce_existing_properties = false;\n\tprivate boolean boolean_op_only_boolean_operands = false;\n\tprivate boolean arith_op_no_undefined = false;\n\tprivate boolean arith_op_no_null = false;\n\tprivate boolean arith_op_no_nan = false;\n\tprivate boolean arith_op_no_infinity = false;\n\tprivate boolean division_op_no_zero = false;\n\tpublic CustomError(Logger lgr) {\n\t\tthis.logger = lgr;\n\t}\n\t/**\n\t * Set an option for this instance.\n\t *\n\t * @param name Name of the option\n\t * @param value Option value\n\t */\n\tpublic void setOption(String name, Object value) {\n\t\ttry {\n\t\t\tswitch (name) {\n\t\t\t\tcase \"escalate_exceptions\":\n\t\t\t\t\tescalate_exceptions = (boolean) value;\n\t\t\t\t\tlogSetOption(name, escalate_exceptions);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\t\tequal_is_strict_equal = (boolean) value;\n\t\t\t\t\tlogSetOption(name, equal_is_strict_equal);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\t\tenforce_existing_properties = (boolean) value;\n\t\t\t\t\tlogSetOption(name, enforce_existing_properties);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\t\tboolean_op_only_boolean_operands = (boolean) value;\n\t\t\t\t\tlogSetOption(name, boolean_op_only_boolean_operands);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\t\tarith_op_no_undefined = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_undefined);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_null\":\n\t\t\t\t\tarith_op_no_null = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\t\tarith_op_no_nan = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_nan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\t\tarith_op_no_infinity = (boolean) value;\n\t\t\t\t\tlogSetOption(name, arith_op_no_infinity);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"division_op_no_zero\":\n\t\t\t\t\tdivision_op_no_zero = (boolean) value;\n\t\t\t\t\tlogSetOption(name, division_op_no_zero);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t}\n\t\t} catch (ClassCastException cce) {\n\t\t\tlogger.warning(\"CustomError: Cannot cast value for option '\" + name + \"'\");\n\t\t}\n\t\trecalculateSomeEnabled();\n\t}\n\tprivate void logSetOption(String name, boolean enabled) {\n\t\tif (enabled) {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' enabled\");\n\t\t} else {\n\t\t\tlogger.info(\"Custom error class '\" + name + \"' disabled\");\n\t\t}\n\t}\n\t/**\n\t * Get an option value from the instance.\n\t *\n\t * @param name Name of the option\n\t * @return Option value\n\t */\n\tpublic Object getOption(String name) {\n\t\tswitch (name) {\n\t\t\tcase \"escalate_exceptions\":\n\t\t\t\treturn this.escalate_exceptions;\n\t\t\tcase \"equal_is_strict_equal\":\n\t\t\t\treturn this.equal_is_strict_equal;\n\t\t\tcase \"enforce_existing_properties\":\n\t\t\t\treturn this.enforce_existing_properties;\n\t\t\tcase \"boolean_op_only_boolean_operands\":\n\t\t\t\treturn this.boolean_op_only_boolean_operands;\n\t\t\tcase \"arith_op_no_undefined\":\n\t\t\t\treturn this.arith_op_no_undefined;\n\t\t\tcase \"arith_op_no_null\":\n\t\t\t\treturn this.arith_op_no_null;\n\t\t\tcase \"arith_op_no_nan\":\n\t\t\t\treturn this.arith_op_no_nan;\n\t\t\tcase \"arith_op_no_infinity\":\n\t\t\t\treturn this.arith_op_no_infinity;\n\t\t\tcase \"division_op_no_zero\":\n\t\t\t\treturn this.division_op_no_zero;\n\t\t\tdefault:\n\t\t\t\tlogger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n\t\t\t\treturn null;\n\t\t}\n\t}\n\t/**\n\t * Check if at least one option is enabled.\n\t *\n\t * @return true, if at least one custom error class is enabled\n\t */\n\tpublic boolean someEnabled() {\n\t\treturn this.some_enabled;\n\t}\n\t/**\n\t * Recalculate if at least one option is enabled.\n\t */\n\tprivate void recalculateSomeEnabled() {\n\t\tthis.some_enabled = this.escalate_exceptions ||\n\t\t\t\t\t\t\tthis.equal_is_strict_equal ||\n\t\t\t\t\t\t\tthis.enforce_existing_properties ||\n\t\t\t\t\t\t\tthis.boolean_op_only_boolean_operands ||\n\t\t\t\t\t\t\tthis.arith_op_no_undefined ||\n\t\t\t\t\t\t\tthis.arith_op_no_null ||\n\t\t\t\t\t\t\tthis.arith_op_no_nan ||\n\t\t\t\t\t\t\tthis.arith_op_no_infinity ||\n\t\t\t\t\t\t\tthis.division_op_no_zero;\n\t}\n\t/**\n\t * Enable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void enable(String type) {\n\t\tsetOption(type, true);\n\t}\n\t/**\n\t * Disable an error class, shorthand for {@link #setOption(String, Object)}.\n\t *\n\t * @param type Name of the error class\n\t */\n\tpublic void disable(String type) {\n\t\tsetOption(type, false);\n\t}\n\t// exposed functions for use in wrapper nodes\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\t\tinspectDivisionZero(operation_name, value, input_index, line_num);\n\t\t\t\t// no break, division is also arithmetic operation\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t\tcase \"JSAndNode\":\n\t\t\tcase \"JSOrNode\":\n\t\t\tcase \"JSNotNodeGen\":\n\t\t\t\tif (boolean_op_only_boolean_operands) {\n\t\t\t\t\tif (!JSGuards.isBoolean(value)) {\n\t\t\t\t\t\tlogger.info(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands)\");\n\t\t\t\t\t\tthrow new EscalatedException(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprivate void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {\n\t\tif (division_op_no_zero && input_index == 1) {\n\t\t\tObject num = JSRuntime.toNumeric(value);\n\t\t\tif (num instanceof BigInt) {\n\t\t\t\tBigInt bigint_num = (BigInt) num;\n\t\t\t\tif (bigint_num.equals(BigInt.ZERO)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Integer) {\n\t\t\t\tInteger int_num = (Integer) num;\n\t\t\t\tif (int_num.equals(0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name +\n\t\t\t\t\t\t\t\t\t\", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof SafeInteger) {\n\t\t\t\tSafeInteger safeint_num = (SafeInteger) num;\n\t\t\t\tif (safeint_num.intValue() == 0) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else if (num instanceof Double) {\n\t\t\t\tDouble double_num = (Double) num;\n\t\t\t\tif (double_num.equals(0.0)) {\n\t\t\t\t\tlogger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n\t\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\t\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" +\n\t\t\t\t\t\t\t\t\tline_num + \"]\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.warning(\"CustomError::inspect(): Unexpected value \" + num.toString());\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Central method for inspecting values and firing an {@link EscalatedException}\n\t * depending on the return value.\n\t *\n\t * @param operation_name Operation name\n\t * @param value Value of the value...\n\t * @param line_num Line number for logging\n\t */\n\tpublic void inspectReturnValue(String operation_name, Object value, int line_num) {\n\t\tswitch (operation_name) {\n\t\t\tcase \"JSDivideNodeGen\":\n\t\t\tcase \"JSAddNodeGen\":\n\t\t\tcase \"JSSubtractNodeGen\":\n\t\t\tcase \"JSMultiplyNodeGen\":\n\t\t\tcase \"JSUnaryMinusNodeGen\":\n\t\t\tcase \"JSUnaryPlusNodeGen\":\n\t\t\tcase \"JSModuloNodeGen\":\n\t\t\tcase \"JSAddSubNumericUnitNodeGen\":\n\t\t\tcase \"SqrtNodeGen\":\n\t\t\tcase \"JSExponentiateNodeGen\":\n\t\t\t\tinspectArithmeticValues(operation_name, value, line_num);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprivate void inspectArithmeticValues(String operation_name, Object value, int line_num) {\n\t\tif (arith_op_no_undefined) {\n\t\t\tif (JSGuards.isUndefined(value)) {\n\t\t\t\tlogger.info(\"Detected undefined value for arithmetic operation (arith_op_no_undefined)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected undefined value for arithmetic operation (arith_op_no_undefined). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_null) {\n\t\t\t//if (JSGuards.isJSNull(value)) { //TODO does not work\n\t\t\tif (value.toString().startsWith(\"DynamicObject<null>\")) {\n\t\t\t\tlogger.info(\"Detected null value for arithmetic operation (arith_op_no_null)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected null value for arithmetic operation (arith_op_no_null). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_nan) {\n\t\t\tif (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {\n\t\t\t\tlogger.info(\"Detected NaN value for arithmetic operation (arith_op_no_nan)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected NaN value for arithmetic operation (arith_op_no_nan). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t\tif (arith_op_no_infinity) {\n\t\t\tif (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {\n\t\t\t\tlogger.info(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity)\");\n\t\t\t\tthrow new EscalatedException(\n\t\t\t\t\t\t\"Detected Infinity value for arithmetic operation (arith_op_no_infinity). [\" + operation_name + \", line \" + line_num + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * @return Value of option \"escalate_exceptions\"\n\t */\n\tpublic boolean escalateExceptionsEnabled() {\n\t\treturn escalate_exceptions;\n\t}\n\t/**\n\t * @return Value of option \"equal_is_strict_equal\"\n\t */\n\tpublic boolean equalIsStrictEqualEnabled() {\n\t\treturn equal_is_strict_equal;\n\t}\n\t/**\n\t * @return Value of option \"enforce_existing_properties\"\n\t */\n\tpublic boolean enforceExistingPropertiesEnabled() {\n\t\treturn enforce_existing_properties;\n\t}\n\t/**\n\t * Create a new Exception that cannot be caught.\n\t *\n\t * @param message Message of the exception\n\t * @return Exception of type \"EscalatedException\"\n\t */\n\tpublic static EscalatedException createException(String message) {\n\t\treturn new EscalatedException(message);\n\t}\n\t/**\n\t * This class should be used whenever an error occurs in the programs execution.\n\t * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)\n\t * will be caught by a try-catch-statement in the guest language source code.\n\t * This exception extends RuntimeException directly and therefore will not be caught\n\t * by any safety measures in the guest language. It can only be caught by the Fuzzer\n\t * itself.\n\t */\n\tpublic static class EscalatedException extends RuntimeException {\n\t\tpublic EscalatedException() {\n\t\t\tsuper();\n\t\t}\n\t\tpublic EscalatedException(String message) {\n\t\t\tsuper(message);\n\t\t}\n\t\tpublic EscalatedException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\t\tpublic EscalatedException(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\t\tprotected EscalatedException(String message, Throwable cause,\n\t\t\t\t\t\t\t\t   boolean enableSuppression,\n\t\t\t\t\t\t\t\t   boolean writableStackTrace) {\n\t\t\tsuper(message, cause, enableSuppression, writableStackTrace);\n\t\t}\n\t}\n"]]}
{"hexsha": "63f006d75c343e11e3056f238b16a9c53c97186d", "ext": "java", "lang": "Java", "content": "public class Bounds {\n\n    /**\n     * The position of something.\n     */\n    private final Position position;\n\n    /**\n     * The size of something.\n     */\n    private final Size size;\n\n    public Bounds(Position position, Size size) {\n        this.position = position;\n        this.size = size;\n    }\n\n    /**\n     * Get the position.\n     *\n     * @return position\n     */\n    public Position getPosition() {\n        return position;\n    }\n\n    /**\n     * Get the size.\n     *\n     * @return size\n     */\n    public Size getSize() {\n        return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Bounds bounds = (Bounds) o;\n\n        if (position != null ? !position.equals(bounds.position) : bounds.position != null) return false;\n        return size != null ? size.equals(bounds.size) : bounds.size == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = position != null ? position.hashCode() : 0;\n        result = 31 * result + (size != null ? size.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s at %s\",\n                getSize().toString(),\n                getPosition().toString()\n        );\n    }\n\n}", "class_id": 0, "repo": "badalsarkar/thaw", "file": "util/src/main/java/de/be/thaw/util/Bounds.java", "last_update_at": "2021-12-11T18:05:30+00:00", "question_id": "63f006d75c343e11e3056f238b16a9c53c97186d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Bounds {\n    /**\n     * The position of something.\n     */\n    private final Position position;\n    /**\n     * The size of something.\n     */\n    private final Size size;\n    public Bounds(Position position, Size size) {\n        this.position = position;\n        this.size = size;\n    }\n    /**\n     * Get the position.\n     *\n     * @return position\n     */\n    public Position getPosition() {\n        return position;\n    }\n    /**\n     * Get the size.\n     *\n     * @return size\n     */\n    public Size getSize() {\n        return size;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Bounds bounds = (Bounds) o;\n        if (position != null ? !position.equals(bounds.position) : bounds.position != null) return false;\n        return size != null ? size.equals(bounds.size) : bounds.size == null;\n    }\n    @Override\n    public int hashCode() {\n        int result = position != null ? position.hashCode() : 0;\n        result = 31 * result + (size != null ? size.hashCode() : 0);\n        return result;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%s at %s\",\n                getSize().toString(),\n                getPosition().toString()\n        );\n    }\n"]]}
{"hexsha": "24e81dc3f9999e7393ee6e867168fcebaedb04ae", "ext": "java", "lang": "Java", "content": "public class RefeedActionsTest {\n\n    private String toString(RefeedActions.Entry entry) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(entry.getDocumentType() + \".\" + entry.getClusterName() + \":\");\n        builder.append(entry.getServices().stream().\n                map(ServiceInfo::getServiceName).\n                sorted().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        builder.append(entry.getMessages().stream().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        return builder.toString();\n    }\n\n    @Test\n    public void action_with_multiple_reasons() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz][change,other change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_services() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz,qux][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_document_types() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"book.foo:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_clusters() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"music.bar:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n\n}", "class_id": 0, "repo": "gsmcwhirter/vespa", "file": "configserver/src/test/java/com/yahoo/vespa/config/server/configchange/RefeedActionsTest.java", "last_update_at": "2021-01-11T18:37:46+00:00", "question_id": "24e81dc3f9999e7393ee6e867168fcebaedb04ae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RefeedActionsTest {\n    private String toString(RefeedActions.Entry entry) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(entry.getDocumentType() + \".\" + entry.getClusterName() + \":\");\n        builder.append(entry.getServices().stream().\n                map(ServiceInfo::getServiceName).\n                sorted().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        builder.append(entry.getMessages().stream().\n                collect(Collectors.joining(\",\", \"[\", \"]\")));\n        return builder.toString();\n    }\n    @Test\n    public void action_with_multiple_reasons() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz][change,other change]\"));\n    }\n    @Test\n    public void actions_with_multiple_services() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz,qux][change]\"));\n    }\n    @Test\n    public void actions_with_multiple_document_types() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"book.foo:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n    @Test\n    public void actions_with_multiple_clusters() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).\n                refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).\n                build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"music.bar:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n"]]}
{"hexsha": "3377317aa98200f51a48ce521cfc82e23fc73437", "ext": "java", "lang": "Java", "content": "public class DeleteObject extends CliCommand<DefaultResult> {\n\n    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);\n    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);\n\n    private String bucketName;\n    private String objectName;\n    private String versionId;\n    private boolean allVersions;\n\n    public DeleteObject() {\n    }\n\n    @Override\n    public CliCommand init(final Arguments args) throws Exception {\n        processCommandOptions(requiredArgs, optionalArgs, args);\n\n        this.bucketName = args.getBucket();\n        this.objectName = args.getObjectName();\n        this.versionId = args.getVersionId();\n        this.allVersions = args.isAllVersions();\n        return this;\n    }\n\n    @Override\n    public DefaultResult call() throws Exception {\n\n        if (allVersions) {\n            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request()\n                    .withName(objectName)\n                    .withBucketId(bucketName);\n            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);\n\n            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {\n                deleteObject(bucketName, objectName, objectVersion.getId());\n            }\n\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' and all of it's versions from bucket '\" + this.bucketName + \"'.\");\n        } else {\n            final UUID version;\n            if (versionId != null) {\n                version = UUID.fromString(versionId);\n            } else {\n                version = null;\n            }\n            deleteObject(bucketName, objectName, version);\n\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' from bucket '\" + this.bucketName + \"'.\");\n        }\n    }\n\n    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {\n        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);\n        if (version != null) {\n            deleteObjectRequest.withVersionId(version);\n        }\n        getClient().deleteObject(deleteObjectRequest);\n    }\n}", "class_id": 0, "repo": "RachelTucker/ds3_java_cli", "file": "ds3_java_cli/src/main/java/com/spectralogic/ds3cli/command/DeleteObject.java", "last_update_at": "2021-09-19T19:50:11+00:00", "question_id": "3377317aa98200f51a48ce521cfc82e23fc73437", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DeleteObject extends CliCommand<DefaultResult> {\n    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);\n    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);\n    private String bucketName;\n    private String objectName;\n    private String versionId;\n    private boolean allVersions;\n    public DeleteObject() {\n    }\n    @Override\n    public CliCommand init(final Arguments args) throws Exception {\n        processCommandOptions(requiredArgs, optionalArgs, args);\n        this.bucketName = args.getBucket();\n        this.objectName = args.getObjectName();\n        this.versionId = args.getVersionId();\n        this.allVersions = args.isAllVersions();\n        return this;\n    }\n    @Override\n    public DefaultResult call() throws Exception {\n        if (allVersions) {\n            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request()\n                    .withName(objectName)\n                    .withBucketId(bucketName);\n            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);\n            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {\n                deleteObject(bucketName, objectName, objectVersion.getId());\n            }\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' and all of it's versions from bucket '\" + this.bucketName + \"'.\");\n        } else {\n            final UUID version;\n            if (versionId != null) {\n                version = UUID.fromString(versionId);\n            } else {\n                version = null;\n            }\n            deleteObject(bucketName, objectName, version);\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' from bucket '\" + this.bucketName + \"'.\");\n        }\n    }\n    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {\n        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);\n        if (version != null) {\n            deleteObjectRequest.withVersionId(version);\n        }\n        getClient().deleteObject(deleteObjectRequest);\n    }\n"]]}
{"hexsha": "4e80fb61037a20340836b0ea84f7505d3b249026", "ext": "java", "lang": "Java", "content": "public class Perspective {\n    public static final int LOCAL_COORD_BITS = 7;\n    public static final int LOCAL_HALF_TILE_SIZE = 64;\n    public static final int LOCAL_TILE_SIZE = 128;\n    public static final int SCENE_SIZE = 104;\n    public static final double UNIT = Math.PI / 1024d;\n\n    public static final int[] SINE = new int[2048]; // sine angles for each of the 2048 units, * 65536 and stored as an int\n    public static final int[] COSINE = new int[2048]; // cosine\n\n    static {\n        for (int i = 0; i < 2048; ++i)\n        {\n            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n        }\n    }\n\n    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {\n        if (string == null) {\n            return null;\n        }\n        Point p = Perspective.localToCanvas(client, localPoint, plane, n);\n        if (p == null) {\n            return null;\n        }\n        else\n        {\n            Log.e(\"Perspective\", p.toString());\n        }\n\n        return new Point(p.getX(), p.getY());\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {\n        int n3 = client.getPlane();\n        int n4 = localPoint.getX() - n * 128 / 2;\n        int n5 = localPoint.getY() - n * 128 / 2;\n        int n6 = localPoint.getX() + n * 128 / 2;\n        int n7 = localPoint.getY() + n * 128 / 2;\n        byte[][][] tileSettings = client.getTileSettings();\n        int n8 = localPoint.getSceneX();\n        int n9 = localPoint.getSceneY();\n        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {\n            int n10;\n            n = n10 = n3;\n            if (n3 < 3) {\n                n = n10;\n                if ((tileSettings[1][n8][n9] & 2) == 2) {\n                    n = n3 + 1;\n                }\n            }\n            n10 = Perspective.getHeight(client, n4, n5, n);\n            n8 = Perspective.getHeight(client, n6, n5, n);\n            n3 = Perspective.getHeight(client, n6, n7, n);\n            n = Perspective.getHeight(client, n4, n7, n);\n            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);\n            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);\n            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);\n            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);\n            if (p1 != null && p2 != null && p3 != null && p4 != null) {\n                Path path = new Path();\n                path.moveTo((float)((Point)p1).getX(), (float)((Point)p1).getY());\n                path.lineTo((float)((Point)p2).getX(), (float)((Point)p2).getY());\n                path.lineTo((float)p3.getX(), (float)p3.getY());\n                path.lineTo((float)((Point)p4).getX(), (float)((Point)p4).getY());\n                return path;\n            }\n            return null;\n        }\n        return null;\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);\n    }\n\n    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane)\n    {\n        int sceneX = localX >> LOCAL_COORD_BITS;\n        int sceneY = localY >> LOCAL_COORD_BITS;\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            int[][][] tileHeights = client.getTileHeights();\n\n            int x = localX & (LOCAL_TILE_SIZE - 1);\n            int y = localY & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n\n        return 0;\n    }\n\n    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {\n        int sceneX = point.getSceneX();\n        int sceneY = point.getSceneY();\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            byte[][][] tileSettings = client.getTileSettings();\n            int[][][] tileHeights = client.getTileHeights();\n            if (plane < 0)\n                plane = 0;\n            int z1 = plane;\n            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE)\n            {\n                z1 = plane + 1;\n            }\n\n            int x = point.getX() & (LOCAL_TILE_SIZE - 1);\n            int y = point.getY() & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n\n        return 0;\n    }\n\n    /*\n    public static Point localToCanvas(@Nonnull Client client, int n, int n2, int n3) {\n        if (n >= 128 && n2 >= 128 && n <= 13056 && n2 <= 13056) {\n            int n4;\n            int n5 = n3 - client.getCameraZ();\n            int n6 = client.getCameraPitch();\n            int n7 = client.getCameraYaw();\n            int[] nArray = SINE;\n            n3 = nArray[n6];\n            int[] nArray2 = COSINE;\n            int n8 = (n7 = nArray2[n7]) * (n2 -= client.getCameraY()) - (n4 = nArray[n7]) * (n -= client.getCameraX()) >> 16;\n            int n9 = n5 * n3 + n8 * (n6 = nArray2[n6]) >> 16;\n            if (n9 >= 50) {\n                double d = (double)client.getCameraZoom() * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double d2 = (double)client.getCameraZoom() * (double)client.getOverlayHeight() / (double)client.getViewportHeight();\n                int n10 = client.getOverlayWidth();\n                int n11 = client.getOverlayHeight();\n                return new Point(n10 / 2 + (int)d * (n7 * n + n2 * n4 >> 16) / n9, n11 / 2 + (int)d2 * (n6 * n5 - n8 * n3 >> 16) / n9);\n            }\n        }\n        return null;\n    }\n     */\n\n    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z)\n    {\n        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056)\n        {\n            x -= client.getCameraX();\n            y -= client.getCameraY();\n            z -= client.getCameraZ();\n\n            int cameraPitch = client.getCameraPitch();\n            int cameraYaw = client.getCameraYaw();\n\n            int pitchSin = SINE[cameraPitch];\n            int pitchCos = COSINE[cameraPitch];\n            int yawSin = SINE[cameraYaw];\n            int yawCos = COSINE[cameraYaw];\n\n            int var8 = yawCos * x + y * yawSin >> 16;\n            y = yawCos * y - yawSin * x >> 16;\n            x = var8;\n            var8 = pitchCos * z - y * pitchSin >> 16;\n            y = z * pitchSin + y * pitchCos >> 16;\n\n            if (y >= 50)\n            {\n                Log.e(\"Points\", \"x:\" + x + \" y:\" + y);\n                double pointX = (double)(client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double pointY = (double)(client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                return new Point(\n                        (int)pointX,\n                        (int)pointY);\n            }\n        }\n\n        return null;\n    }\n\n    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {\n        n = Perspective.getTileHeight(clientAPI, localPoint, n);\n        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);\n    }\n}", "class_id": 0, "repo": "Soxs/openosrs-mobile", "file": "runelite-api/src/main/java/net/runelite/api/Perspective.java", "last_update_at": "2021-11-19T15:28:42+00:00", "question_id": "4e80fb61037a20340836b0ea84f7505d3b249026", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Perspective {\n    public static final int LOCAL_COORD_BITS = 7;\n    public static final int LOCAL_HALF_TILE_SIZE = 64;\n    public static final int LOCAL_TILE_SIZE = 128;\n    public static final int SCENE_SIZE = 104;\n    public static final double UNIT = Math.PI / 1024d;\n    public static final int[] SINE = new int[2048]; // sine angles for each of the 2048 units, * 65536 and stored as an int\n    public static final int[] COSINE = new int[2048]; // cosine\n    static {\n        for (int i = 0; i < 2048; ++i)\n        {\n            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n        }\n    }\n    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {\n        if (string == null) {\n            return null;\n        }\n        Point p = Perspective.localToCanvas(client, localPoint, plane, n);\n        if (p == null) {\n            return null;\n        }\n        else\n        {\n            Log.e(\"Perspective\", p.toString());\n        }\n        return new Point(p.getX(), p.getY());\n    }\n    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);\n    }\n    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {\n        int n3 = client.getPlane();\n        int n4 = localPoint.getX() - n * 128 / 2;\n        int n5 = localPoint.getY() - n * 128 / 2;\n        int n6 = localPoint.getX() + n * 128 / 2;\n        int n7 = localPoint.getY() + n * 128 / 2;\n        byte[][][] tileSettings = client.getTileSettings();\n        int n8 = localPoint.getSceneX();\n        int n9 = localPoint.getSceneY();\n        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {\n            int n10;\n            n = n10 = n3;\n            if (n3 < 3) {\n                n = n10;\n                if ((tileSettings[1][n8][n9] & 2) == 2) {\n                    n = n3 + 1;\n                }\n            }\n            n10 = Perspective.getHeight(client, n4, n5, n);\n            n8 = Perspective.getHeight(client, n6, n5, n);\n            n3 = Perspective.getHeight(client, n6, n7, n);\n            n = Perspective.getHeight(client, n4, n7, n);\n            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);\n            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);\n            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);\n            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);\n            if (p1 != null && p2 != null && p3 != null && p4 != null) {\n                Path path = new Path();\n                path.moveTo((float)((Point)p1).getX(), (float)((Point)p1).getY());\n                path.lineTo((float)((Point)p2).getX(), (float)((Point)p2).getY());\n                path.lineTo((float)p3.getX(), (float)p3.getY());\n                path.lineTo((float)((Point)p4).getX(), (float)((Point)p4).getY());\n                return path;\n            }\n            return null;\n        }\n        return null;\n    }\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);\n    }\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);\n    }\n    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane)\n    {\n        int sceneX = localX >> LOCAL_COORD_BITS;\n        int sceneY = localY >> LOCAL_COORD_BITS;\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            int[][][] tileHeights = client.getTileHeights();\n            int x = localX & (LOCAL_TILE_SIZE - 1);\n            int y = localY & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {\n        int sceneX = point.getSceneX();\n        int sceneY = point.getSceneY();\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE)\n        {\n            byte[][][] tileSettings = client.getTileSettings();\n            int[][][] tileHeights = client.getTileHeights();\n            if (plane < 0)\n                plane = 0;\n            int z1 = plane;\n            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE)\n            {\n                z1 = plane + 1;\n            }\n            int x = point.getX() & (LOCAL_TILE_SIZE - 1);\n            int y = point.getY() & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n    /*\n    public static Point localToCanvas(@Nonnull Client client, int n, int n2, int n3) {\n        if (n >= 128 && n2 >= 128 && n <= 13056 && n2 <= 13056) {\n            int n4;\n            int n5 = n3 - client.getCameraZ();\n            int n6 = client.getCameraPitch();\n            int n7 = client.getCameraYaw();\n            int[] nArray = SINE;\n            n3 = nArray[n6];\n            int[] nArray2 = COSINE;\n            int n8 = (n7 = nArray2[n7]) * (n2 -= client.getCameraY()) - (n4 = nArray[n7]) * (n -= client.getCameraX()) >> 16;\n            int n9 = n5 * n3 + n8 * (n6 = nArray2[n6]) >> 16;\n            if (n9 >= 50) {\n                double d = (double)client.getCameraZoom() * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double d2 = (double)client.getCameraZoom() * (double)client.getOverlayHeight() / (double)client.getViewportHeight();\n                int n10 = client.getOverlayWidth();\n                int n11 = client.getOverlayHeight();\n                return new Point(n10 / 2 + (int)d * (n7 * n + n2 * n4 >> 16) / n9, n11 / 2 + (int)d2 * (n6 * n5 - n8 * n3 >> 16) / n9);\n            }\n        }\n        return null;\n    }\n     */\n    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z)\n    {\n        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056)\n        {\n            x -= client.getCameraX();\n            y -= client.getCameraY();\n            z -= client.getCameraZ();\n            int cameraPitch = client.getCameraPitch();\n            int cameraYaw = client.getCameraYaw();\n            int pitchSin = SINE[cameraPitch];\n            int pitchCos = COSINE[cameraPitch];\n            int yawSin = SINE[cameraYaw];\n            int yawCos = COSINE[cameraYaw];\n            int var8 = yawCos * x + y * yawSin >> 16;\n            y = yawCos * y - yawSin * x >> 16;\n            x = var8;\n            var8 = pitchCos * z - y * pitchSin >> 16;\n            y = z * pitchSin + y * pitchCos >> 16;\n            if (y >= 50)\n            {\n                Log.e(\"Points\", \"x:\" + x + \" y:\" + y);\n                double pointX = (double)(client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                double pointY = (double)(client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double)client.getOverlayWidth() / (double)client.getViewportWidth();\n                return new Point(\n                        (int)pointX,\n                        (int)pointY);\n            }\n        }\n        return null;\n    }\n    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {\n        n = Perspective.getTileHeight(clientAPI, localPoint, n);\n        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);\n    }\n"]]}
{"hexsha": "3c9b0668c602f3425aef938ddbcd842b6fc11a32", "ext": "java", "lang": "Java", "content": "@Component\n@ConditionalOnProperty(value = \"datasource-observer.sentinelhub.enabled\", havingValue = \"true\")\npublic class SentinelJobFactory implements JobFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);\n\n    @Autowired\n    private ExecutionIntervalConfig intervalConfig;\n\n    @Override\n    public boolean supportsJobDefinition(WacodisJobDefinition job) {\n        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();\n        return count > 0;\n    }\n\n//    @Override\n//    public JobDetail initializeJob(WacodisJobDefinition job, JobDataMap data) {\n//        LOG.info(\"Preparing SentinelJob JobDetail\");\n//        \n//        Optional<AbstractSubsetDefinition> def = job.getInputs().stream()\n//                .filter((i -> i instanceof CopernicusSubsetDefinition)).findFirst();\n//        \n//        // this should always be the case\n//        if (def.isPresent()) {\n//            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) def.get();\n//            if (copDef.getMaximumCloudCoverage() > 0) {\n//                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n//            }\n//            \n//            switch (copDef.getSatellite()) {\n//                case _1:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n//                    break;\n//                case _2:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n//                    break;\n//                case _3:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n//                    break;\n//            }\n//            \n//            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n//                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n//                int baseDays = period.getDays();\n//                if (period.getHours() > 11) {\n//                    // round to full days\n//                    baseDays++;\n//                }\n//                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n//            }\n//            \n//            data.put(\"executionInterval\", intervalConfig.getSentinel());\n//        }\n//\n//        // create the quartz object\n//        return JobBuilder.newJob(SentinelJob.class)\n//                .withIdentity(job.getId().toString(), job.getName())\n//                .usingJobData(data)\n//                .build();\n//    }\n\n    @Override\n    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data,\n                                           AbstractSubsetDefinition subsetDefinition) {\n        // this should always be the case\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n\n            LOG.info(\"Preparing SentinelJob JobDetail\");\n\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            if (copDef.getMaximumCloudCoverage() > 0) {\n                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n            }\n\n            switch (copDef.getSatellite()) {\n                case _1:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n                    break;\n                case _2:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n                    break;\n                case _3:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n                    break;\n            }\n\n            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n                int baseDays = period.getDays();\n                if (period.getHours() > 11) {\n                    // round to full days\n                    baseDays++;\n                }\n                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n            }\n\n            data.put(\"executionInterval\", intervalConfig.getSentinel());\n\n        }\n\n        // create the quartz object\n        return JobBuilder.newJob(SentinelJob.class)\n                .usingJobData(data);\n\n    }\n\n    @Override\n    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {\n        return job.getInputs().stream()\n                .filter((i -> i instanceof CopernicusSubsetDefinition));\n    }\n\n    @Override\n    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {\n\n        StringBuilder builder = new StringBuilder(\"\");\n\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            builder.append(copDef.getSourceType());\n\n            if (copDef.getSatellite() != null) {\n                builder.append(\"_\" + copDef.getSatellite());\n            }\n        }\n\n        return builder.toString();\n    }\n    \n    @Override\n\tpublic Class getQuartzJobClass() {\n\t\t// TODO Auto-generated method stub\n\t\treturn SentinelJob.class;\n\t}\n    \n    @Override\n\tpublic JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {\n    \t// here we must do nothing as this Job dies not specify BBOX parameter\n    \treturn jobDetail;\n\t}\n\n}", "class_id": 0, "repo": "WaCoDiS/datasource-observer", "file": "sentinel-observer/src/main/java/de/wacodis/sentinel/SentinelJobFactory.java", "last_update_at": "2021-11-15T23:28:04+00:00", "question_id": "3c9b0668c602f3425aef938ddbcd842b6fc11a32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@ConditionalOnProperty(value = \"datasource-observer.sentinelhub.enabled\", havingValue = \"true\")\npublic class SentinelJobFactory implements JobFactory {\n    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);\n    @Autowired\n    private ExecutionIntervalConfig intervalConfig;\n    @Override\n    public boolean supportsJobDefinition(WacodisJobDefinition job) {\n        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();\n        return count > 0;\n    }\n//    @Override\n//    public JobDetail initializeJob(WacodisJobDefinition job, JobDataMap data) {\n//        LOG.info(\"Preparing SentinelJob JobDetail\");\n//        \n//        Optional<AbstractSubsetDefinition> def = job.getInputs().stream()\n//                .filter((i -> i instanceof CopernicusSubsetDefinition)).findFirst();\n//        \n//        // this should always be the case\n//        if (def.isPresent()) {\n//            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) def.get();\n//            if (copDef.getMaximumCloudCoverage() > 0) {\n//                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n//            }\n//            \n//            switch (copDef.getSatellite()) {\n//                case _1:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n//                    break;\n//                case _2:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n//                    break;\n//                case _3:\n//                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n//                    break;\n//            }\n//            \n//            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n//                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n//                int baseDays = period.getDays();\n//                if (period.getHours() > 11) {\n//                    // round to full days\n//                    baseDays++;\n//                }\n//                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n//            }\n//            \n//            data.put(\"executionInterval\", intervalConfig.getSentinel());\n//        }\n//\n//        // create the quartz object\n//        return JobBuilder.newJob(SentinelJob.class)\n//                .withIdentity(job.getId().toString(), job.getName())\n//                .usingJobData(data)\n//                .build();\n//    }\n    @Override\n    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data,\n                                           AbstractSubsetDefinition subsetDefinition) {\n        // this should always be the case\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            LOG.info(\"Preparing SentinelJob JobDetail\");\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            if (copDef.getMaximumCloudCoverage() > 0) {\n                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n            }\n            switch (copDef.getSatellite()) {\n                case _1:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n                    break;\n                case _2:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n                    break;\n                case _3:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n                    break;\n            }\n            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n                int baseDays = period.getDays();\n                if (period.getHours() > 11) {\n                    // round to full days\n                    baseDays++;\n                }\n                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n            }\n            data.put(\"executionInterval\", intervalConfig.getSentinel());\n        }\n        // create the quartz object\n        return JobBuilder.newJob(SentinelJob.class)\n                .usingJobData(data);\n    }\n    @Override\n    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {\n        return job.getInputs().stream()\n                .filter((i -> i instanceof CopernicusSubsetDefinition));\n    }\n    @Override\n    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {\n        StringBuilder builder = new StringBuilder(\"\");\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            builder.append(copDef.getSourceType());\n            if (copDef.getSatellite() != null) {\n                builder.append(\"_\" + copDef.getSatellite());\n            }\n        }\n        return builder.toString();\n    }\n    @Override\n\tpublic Class getQuartzJobClass() {\n\t\t// TODO Auto-generated method stub\n\t\treturn SentinelJob.class;\n\t}\n    @Override\n\tpublic JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {\n    \t// here we must do nothing as this Job dies not specify BBOX parameter\n    \treturn jobDetail;\n\t}\n"]]}
{"hexsha": "1ee98f729518a3ab59cc092fb753ccaf548f8923", "ext": "java", "lang": "Java", "content": "public class SqlPagingStrategy\n{\n   public static SqlPaging buildPaging(String databaseProduct)\n   {\n      SqlPaging paging = new SqlPaging();\n      if (databaseProduct.equals(DatabaseProduct.MYSQL)) { //$NON-NLS-1$\n         MySqlPagingDialect dialect = new MySqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.PGSQL)) { //$NON-NLS-1$\n         PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.H2)) { //$NON-NLS-1$\n         H2PagingDialect dialect = new H2PagingDialect();\n         paging.setDialect(dialect);\n      }\n      return paging;\n   }\n}", "class_id": 0, "repo": "obidea/semantika-core", "file": "src/main/java/com/obidea/semantika/queryanswer/paging/SqlPagingStrategy.java", "last_update_at": "2021-03-01T04:33:21+00:00", "question_id": "1ee98f729518a3ab59cc092fb753ccaf548f8923", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SqlPagingStrategy\n{\n   public static SqlPaging buildPaging(String databaseProduct)\n   {\n      SqlPaging paging = new SqlPaging();\n      if (databaseProduct.equals(DatabaseProduct.MYSQL)) { //$NON-NLS-1$\n         MySqlPagingDialect dialect = new MySqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.PGSQL)) { //$NON-NLS-1$\n         PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();\n         paging.setDialect(dialect);\n      }\n      else if (databaseProduct.equals(DatabaseProduct.H2)) { //$NON-NLS-1$\n         H2PagingDialect dialect = new H2PagingDialect();\n         paging.setDialect(dialect);\n      }\n      return paging;\n   }\n"]]}
{"hexsha": "12958c18f6375a8f2d58b33654f17da5c8df2cff", "ext": "java", "lang": "Java", "content": "public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {\n\n    public static final String ENRICHMENT_ADDED = \"ENRICHMENT_ADDED\";\n\n    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {\n    };\n\n    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);\n\n    /**\n     * Have one of the supplied properties been modified?\n     */\n    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {\n\n        if (props != null) {\n            for (String propName : props) {\n                try {\n                    Property prop = doc.getProperty(propName);\n                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {\n                        return true;\n                    }\n                } catch (PropertyNotFoundException e) {\n                    // Just ignore\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {\n        // TODO: Handle versions here?\n        DocumentModel doc;\n        try {\n            doc = session.getDocument(new IdRef(metadata.context.documentRef));\n        } catch (DocumentNotFoundException e) {\n            log.info(\"Unable to save enrichment data for missing doc \" + metadata.context.documentRef);\n            return null;\n        }\n\n        Map<String, Object> anItem = metadata.toMap();\n        if (anItem != null) {\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(\n                    ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n            if (enrichmentList == null) {\n                enrichmentList = new ArrayList<>(1);\n            }\n            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);\n            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());\n        }\n        return doc;\n    }\n\n    /**\n     * Updates enrichment, ensures we have one enrichment entry per model/version and input\n     */\n    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original,\n            Map<String, Object> item) {\n        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();\n        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));\n        enrichmentByKey.put(uniqueKey(item), item);\n        return enrichmentByKey.values();\n    }\n\n    /**\n     * Generate a unique key for a model/version/input combination\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String uniqueKey(Map<String, Object> suggestion) {\n        String input = \"\";\n        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n        // This is a little big strange, but it adapts to the type and calls the correct join method.\n        if (inputs instanceof Set) {\n            input = String.join(\";\", (Set<String>) inputs);\n        } else if (inputs instanceof String[]) {\n            input = String.join(\";\", (String[]) inputs);\n        }\n        return suggestion.get(ENRICHMENT_MODEL) + input;\n    }\n\n    @Override\n    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model,\n            Serializable oldValue, String comment) {\n        if (!doc.hasFacet(ENRICHMENT_FACET)) {\n            doc.addFacet(ENRICHMENT_FACET);\n        }\n\n        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());\n        HashMap<String, String> prediction = new HashMap<>();\n        prediction.put(\"xpath\", xPath);\n        prediction.put(\"model\", model);\n        autoProps.add(prediction);\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);\n        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n\n        if (oldValue != null) {\n            List<AutoHistory> existingHistory = getAutoHistory(doc);\n            // First remove old history if it exists\n            List<AutoHistory> history = existingHistory.stream()\n                                                       .filter(h -> !xPath.equals(h.getProperty()))\n                                                       .collect(Collectors.toList());\n            history.add(new AutoHistory(xPath, oldValue));\n            setAutoHistory(doc, history);\n        }\n\n        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);\n\n        storeAudit(doc, autoField, model, 1L, comment);\n\n        return doc;\n    }\n\n    @Override\n    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {\n        List<AutoHistory> history = getAutoHistory(doc);\n        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();\n        boolean present = previous.isPresent();\n        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());\n        Set<Map<String, String>> toReset = set.stream()\n                                              .filter(val -> val.get(\"xpath\").equals(xPath))\n                                              .collect(Collectors.toSet());\n        @SuppressWarnings(\"unchecked\")\n        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);\n        Object previousValue = null;\n        if (set.size() > noOldXpath.size()) {\n            if (present) {\n                previousValue = previous.get().getPreviousValue();\n                history.remove(previous.get());\n                setAutoHistory(doc, history);\n            }\n            //Set the value\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);\n            String comment = \"Resetting \" + xPath + \" property\";\n            toReset.forEach(map -> {\n                storeAudit(doc, autoField, map.get(\"model\"), -1L, comment);\n            });\n\n            if (resetValue) {\n                doc.setPropertyValue(xPath, (Serializable) previousValue);\n            }\n        }\n\n        return doc;\n    }\n\n    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {\n        Set<Map<String, String>> autoProps = new HashSet<>(1);\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                autoPropertyName);\n        if (filled != null) {\n            autoProps.addAll(filled);\n        }\n\n        return autoProps;\n    }\n\n    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {\n        AuditLogger audit = Framework.getService(AuditLogger.class);\n        if (audit != null) {\n            LogEntry logEntry = audit.newLogEntry();\n            logEntry.setCategory(\"AI\");\n            logEntry.setEventId(autoField.eventName());\n            logEntry.setComment(comment);\n            logEntry.setDocUUID(doc.getId());\n            logEntry.setDocPath(doc.getPathAsString());\n            logEntry.setEventDate(new Date());\n\n            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);\n            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);\n\n            HashMap<String, ExtendedInfo> infos = new HashMap<>();\n            infos.put(\"model\", modelInfo);\n            infos.put(\"value\", one);\n            logEntry.setExtendedInfos(infos);\n\n            audit.addLogEntries(Collections.singletonList(logEntry));\n        } else {\n            log.warn(\"Audit Logger is not available\");\n        }\n    }\n\n    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {\n        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(),\n                doc);\n        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());\n        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());\n\n        String paths = null;\n        if (xPaths != null && !xPaths.isEmpty()) {\n            paths = String.join(\",\", xPaths);\n        }\n        ctx.setProperty(PATHS, paths);\n        if (StringUtils.isEmpty(comment)) {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);\n        } else {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);\n        }\n        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));\n    }\n\n    @Override\n    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null) {\n            return doc;\n        }\n        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());\n\n        itemsList.forEach(suggestObj -> {\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);\n            List<Map<String, Object>> newSuggestions = suggestions.stream()\n                                                                  .filter(s -> !xPath.equals(\n                                                                          s.get(SUGGESTION_PROPERTY)))\n                                                                  .collect(Collectors.toList());\n            if (!newSuggestions.isEmpty()) {\n                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);\n                newSuggestList.add(suggestObj);\n            }\n        });\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);\n        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);\n        return doc;\n    }\n\n    @Override\n    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null || itemsList.isEmpty()) {\n            return doc;\n        }\n        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());\n        Set<String> removedTargetProperties = new HashSet<>();\n\n        itemsList.forEach(entry -> {\n            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));\n            if (hadBeenModified(doc, inputProperties)) {\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);\n                Set<String> targetProps = suggestions.stream()\n                                                     .map(s -> (String) s.get(SUGGESTION_PROPERTY))\n                                                     .collect(Collectors.toSet());\n                removedTargetProperties.addAll(targetProps);\n            } else {\n                cleanItemsList.add(entry);\n            }\n        });\n        if (cleanItemsList.size() != itemsList.size()) {\n            //We made some changes lets update\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, \"Dirty inputs\");\n        }\n        return doc;\n    }\n\n    @Override\n    public List<AutoHistory> getAutoHistory(DocumentModel doc) {\n        try {\n            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());\n            if (autoBlob != null) {\n                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to read auto history blob\", e);\n        }\n\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {\n        try {\n            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n\n            String autoHistory = AUTO.HISTORY.lowerName();\n            autoBlob.setFilename(autoHistory + \"_\" + doc.getName() + \".json\");\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);\n        } catch (IOException e) {\n            log.warn(\"Failed to set auto history blob\", e);\n        }\n    }\n}", "class_id": 0, "repo": "nuxeo/nuxeo-ai", "file": "nuxeo-ai-core/src/main/java/org/nuxeo/ai/services/DocMetadataServiceImpl.java", "last_update_at": "2021-03-30T03:03:26+00:00", "question_id": "12958c18f6375a8f2d58b33654f17da5c8df2cff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {\n    public static final String ENRICHMENT_ADDED = \"ENRICHMENT_ADDED\";\n    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {\n    };\n    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);\n    /**\n     * Have one of the supplied properties been modified?\n     */\n    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {\n        if (props != null) {\n            for (String propName : props) {\n                try {\n                    Property prop = doc.getProperty(propName);\n                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {\n                        return true;\n                    }\n                } catch (PropertyNotFoundException e) {\n                    // Just ignore\n                }\n            }\n        }\n        return false;\n    }\n    @Override\n    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {\n        // TODO: Handle versions here?\n        DocumentModel doc;\n        try {\n            doc = session.getDocument(new IdRef(metadata.context.documentRef));\n        } catch (DocumentNotFoundException e) {\n            log.info(\"Unable to save enrichment data for missing doc \" + metadata.context.documentRef);\n            return null;\n        }\n        Map<String, Object> anItem = metadata.toMap();\n        if (anItem != null) {\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(\n                    ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n            if (enrichmentList == null) {\n                enrichmentList = new ArrayList<>(1);\n            }\n            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);\n            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());\n        }\n        return doc;\n    }\n    /**\n     * Updates enrichment, ensures we have one enrichment entry per model/version and input\n     */\n    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original,\n            Map<String, Object> item) {\n        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();\n        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));\n        enrichmentByKey.put(uniqueKey(item), item);\n        return enrichmentByKey.values();\n    }\n    /**\n     * Generate a unique key for a model/version/input combination\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String uniqueKey(Map<String, Object> suggestion) {\n        String input = \"\";\n        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n        // This is a little big strange, but it adapts to the type and calls the correct join method.\n        if (inputs instanceof Set) {\n            input = String.join(\";\", (Set<String>) inputs);\n        } else if (inputs instanceof String[]) {\n            input = String.join(\";\", (String[]) inputs);\n        }\n        return suggestion.get(ENRICHMENT_MODEL) + input;\n    }\n    @Override\n    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model,\n            Serializable oldValue, String comment) {\n        if (!doc.hasFacet(ENRICHMENT_FACET)) {\n            doc.addFacet(ENRICHMENT_FACET);\n        }\n        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());\n        HashMap<String, String> prediction = new HashMap<>();\n        prediction.put(\"xpath\", xPath);\n        prediction.put(\"model\", model);\n        autoProps.add(prediction);\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);\n        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n        if (oldValue != null) {\n            List<AutoHistory> existingHistory = getAutoHistory(doc);\n            // First remove old history if it exists\n            List<AutoHistory> history = existingHistory.stream()\n                                                       .filter(h -> !xPath.equals(h.getProperty()))\n                                                       .collect(Collectors.toList());\n            history.add(new AutoHistory(xPath, oldValue));\n            setAutoHistory(doc, history);\n        }\n        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);\n        storeAudit(doc, autoField, model, 1L, comment);\n        return doc;\n    }\n    @Override\n    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {\n        List<AutoHistory> history = getAutoHistory(doc);\n        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();\n        boolean present = previous.isPresent();\n        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());\n        Set<Map<String, String>> toReset = set.stream()\n                                              .filter(val -> val.get(\"xpath\").equals(xPath))\n                                              .collect(Collectors.toSet());\n        @SuppressWarnings(\"unchecked\")\n        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);\n        Object previousValue = null;\n        if (set.size() > noOldXpath.size()) {\n            if (present) {\n                previousValue = previous.get().getPreviousValue();\n                history.remove(previous.get());\n                setAutoHistory(doc, history);\n            }\n            //Set the value\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);\n            String comment = \"Resetting \" + xPath + \" property\";\n            toReset.forEach(map -> {\n                storeAudit(doc, autoField, map.get(\"model\"), -1L, comment);\n            });\n            if (resetValue) {\n                doc.setPropertyValue(xPath, (Serializable) previousValue);\n            }\n        }\n        return doc;\n    }\n    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {\n        Set<Map<String, String>> autoProps = new HashSet<>(1);\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                autoPropertyName);\n        if (filled != null) {\n            autoProps.addAll(filled);\n        }\n        return autoProps;\n    }\n    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {\n        AuditLogger audit = Framework.getService(AuditLogger.class);\n        if (audit != null) {\n            LogEntry logEntry = audit.newLogEntry();\n            logEntry.setCategory(\"AI\");\n            logEntry.setEventId(autoField.eventName());\n            logEntry.setComment(comment);\n            logEntry.setDocUUID(doc.getId());\n            logEntry.setDocPath(doc.getPathAsString());\n            logEntry.setEventDate(new Date());\n            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);\n            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);\n            HashMap<String, ExtendedInfo> infos = new HashMap<>();\n            infos.put(\"model\", modelInfo);\n            infos.put(\"value\", one);\n            logEntry.setExtendedInfos(infos);\n            audit.addLogEntries(Collections.singletonList(logEntry));\n        } else {\n            log.warn(\"Audit Logger is not available\");\n        }\n    }\n    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {\n        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(),\n                doc);\n        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());\n        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());\n        String paths = null;\n        if (xPaths != null && !xPaths.isEmpty()) {\n            paths = String.join(\",\", xPaths);\n        }\n        ctx.setProperty(PATHS, paths);\n        if (StringUtils.isEmpty(comment)) {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);\n        } else {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);\n        }\n        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));\n    }\n    @Override\n    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null) {\n            return doc;\n        }\n        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());\n        itemsList.forEach(suggestObj -> {\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);\n            List<Map<String, Object>> newSuggestions = suggestions.stream()\n                                                                  .filter(s -> !xPath.equals(\n                                                                          s.get(SUGGESTION_PROPERTY)))\n                                                                  .collect(Collectors.toList());\n            if (!newSuggestions.isEmpty()) {\n                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);\n                newSuggestList.add(suggestObj);\n            }\n        });\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);\n        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);\n        return doc;\n    }\n    @Override\n    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME,\n                ENRICHMENT_ITEMS);\n        if (itemsList == null || itemsList.isEmpty()) {\n            return doc;\n        }\n        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());\n        Set<String> removedTargetProperties = new HashSet<>();\n        itemsList.forEach(entry -> {\n            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));\n            if (hadBeenModified(doc, inputProperties)) {\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);\n                Set<String> targetProps = suggestions.stream()\n                                                     .map(s -> (String) s.get(SUGGESTION_PROPERTY))\n                                                     .collect(Collectors.toSet());\n                removedTargetProperties.addAll(targetProps);\n            } else {\n                cleanItemsList.add(entry);\n            }\n        });\n        if (cleanItemsList.size() != itemsList.size()) {\n            //We made some changes lets update\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, \"Dirty inputs\");\n        }\n        return doc;\n    }\n    @Override\n    public List<AutoHistory> getAutoHistory(DocumentModel doc) {\n        try {\n            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());\n            if (autoBlob != null) {\n                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to read auto history blob\", e);\n        }\n        return Collections.emptyList();\n    }\n    @Override\n    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {\n        try {\n            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            String autoHistory = AUTO.HISTORY.lowerName();\n            autoBlob.setFilename(autoHistory + \"_\" + doc.getName() + \".json\");\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);\n        } catch (IOException e) {\n            log.warn(\"Failed to set auto history blob\", e);\n        }\n    }\n"]]}
{"hexsha": "2dc0bd87eab86338ed959af6cf2291c34c7fcd29", "ext": "java", "lang": "Java", "content": "@Getter\npublic class OrientedBox {\n    protected Vector center;\n    protected Vector axisX;\n    protected Vector axisY;\n    protected Vector axisZ;\n    protected float extentX;\n    protected float extentY;\n    protected float extentZ;\n\n    public OrientedBox(final Vector center,\n                       final Vector axisX,\n                       final Vector axisY,\n                       final Vector axisZ,\n                       final float extentX,\n                       final float extentY,\n                       final float extentZ) {\n        this.center = center;\n        this.axisX = axisX;\n        this.axisY = axisY;\n        this.axisZ = axisZ;\n        this.extentX = extentX;\n        this.extentY = extentY;\n        this.extentZ = extentZ;\n    }\n\n    public OrientedBox(final AxialBox box, final Transform transform) {\n        this.center = transform.rotateTranslateLocalToParent(box.getCenter());\n        this.axisX = transform.rotateLocalToParent(box.getAxisX());\n        this.axisY = transform.rotateLocalToParent(box.getAxisY());\n        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final AxialBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final YawedBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public Vector[] getAxes() {\n        return new Vector[]{axisX, axisY, axisZ};\n    }\n\n    public float[] getExtents() {\n        return new float[]{extentX, extentY, extentZ};\n    }\n\n    public Vector getBase() {\n        return getCenter().subtract(getAxisY().multiply(getExtentY()));\n    }\n\n    public Plane3d getFacePlane(final int whichPlane) {\n        switch (whichPlane) {\n            case 0:\n                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);\n            case 1:\n                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);\n            case 2:\n                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);\n            case 3:\n                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());\n            case 4:\n                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());\n            case 5:\n                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());\n            default:\n                return new Plane3d(Vector.ZERO, Vector.ZERO);\n        }\n    }\n\n    public Vector getCorner(final int whichCorner) {\n        final Vector x = axisX.multiply(extentX);\n        final Vector y = axisY.multiply(extentY);\n        final Vector z = axisZ.multiply(extentZ);\n\n        switch (whichCorner) {\n            case 0:\n                return center.subtract(x).subtract(y).subtract(z);\n            case 1:\n                return center.add(x).subtract(y).subtract(z);\n            case 2:\n                return center.subtract(x).subtract(y).add(z);\n            case 3:\n                return center.add(x).subtract(y).add(z);\n            case 4:\n                return center.subtract(x).add(y).subtract(z);\n            case 5:\n                return center.add(x).add(y).subtract(z);\n            case 6:\n                return center.subtract(x).add(y).add(z);\n            case 7:\n                return center.add(x).add(y).add(z);\n            default:\n                return Vector.ZERO;\n        }\n    }\n\n    public AxialBox getLocalShape() {\n        return new AxialBox(\n                new Vector(-extentX, -extentY, -extentZ),\n                new Vector(extentX, extentY, extentZ));\n    }\n\n    public Transform getTransformLocalToParent() {\n        final Transform temp = new Transform();\n        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());\n        temp.moveInParentSpace(center);\n        return temp;\n    }\n\n    public Transform getTransformParentToLocal() {\n        final Transform temp = new Transform();\n        temp.invert(getTransformLocalToParent());\n        return temp;\n    }\n\n    public Vector transformToLocal(final Vector vector) {\n        return rotateToLocal(vector.subtract(center));\n    }\n\n    public Vector transformToWorld(final Vector vector) {\n        return rotateToWorld(vector).add(center);\n    }\n\n    public Vector rotateToLocal(final Vector vector) {\n        return new Vector(\n                vector.dot(getAxisX()),\n                vector.dot(getAxisY()),\n                vector.dot(getAxisZ()));\n    }\n\n    public Vector rotateToWorld(final Vector vector) {\n        return Vector.ZERO\n                .add(getAxisX().multiply(vector.x))\n                .add(getAxisY().multiply(vector.y))\n                .add(getAxisZ().multiply(vector.z));\n    }\n}", "class_id": 0, "repo": "bacta/pre-cu-archive", "file": "src/main/java/com/ocdsoft/bacta/swg/shared/math/OrientedBox.java", "last_update_at": "2021-09-20T23:01:54+00:00", "question_id": "2dc0bd87eab86338ed959af6cf2291c34c7fcd29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\npublic class OrientedBox {\n    protected Vector center;\n    protected Vector axisX;\n    protected Vector axisY;\n    protected Vector axisZ;\n    protected float extentX;\n    protected float extentY;\n    protected float extentZ;\n    public OrientedBox(final Vector center,\n                       final Vector axisX,\n                       final Vector axisY,\n                       final Vector axisZ,\n                       final float extentX,\n                       final float extentY,\n                       final float extentZ) {\n        this.center = center;\n        this.axisX = axisX;\n        this.axisY = axisY;\n        this.axisZ = axisZ;\n        this.extentX = extentX;\n        this.extentY = extentY;\n        this.extentZ = extentZ;\n    }\n    public OrientedBox(final AxialBox box, final Transform transform) {\n        this.center = transform.rotateTranslateLocalToParent(box.getCenter());\n        this.axisX = transform.rotateLocalToParent(box.getAxisX());\n        this.axisY = transform.rotateLocalToParent(box.getAxisY());\n        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n    public OrientedBox(final AxialBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n    public OrientedBox(final YawedBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n    public Vector[] getAxes() {\n        return new Vector[]{axisX, axisY, axisZ};\n    }\n    public float[] getExtents() {\n        return new float[]{extentX, extentY, extentZ};\n    }\n    public Vector getBase() {\n        return getCenter().subtract(getAxisY().multiply(getExtentY()));\n    }\n    public Plane3d getFacePlane(final int whichPlane) {\n        switch (whichPlane) {\n            case 0:\n                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);\n            case 1:\n                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);\n            case 2:\n                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);\n            case 3:\n                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());\n            case 4:\n                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());\n            case 5:\n                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());\n            default:\n                return new Plane3d(Vector.ZERO, Vector.ZERO);\n        }\n    }\n    public Vector getCorner(final int whichCorner) {\n        final Vector x = axisX.multiply(extentX);\n        final Vector y = axisY.multiply(extentY);\n        final Vector z = axisZ.multiply(extentZ);\n        switch (whichCorner) {\n            case 0:\n                return center.subtract(x).subtract(y).subtract(z);\n            case 1:\n                return center.add(x).subtract(y).subtract(z);\n            case 2:\n                return center.subtract(x).subtract(y).add(z);\n            case 3:\n                return center.add(x).subtract(y).add(z);\n            case 4:\n                return center.subtract(x).add(y).subtract(z);\n            case 5:\n                return center.add(x).add(y).subtract(z);\n            case 6:\n                return center.subtract(x).add(y).add(z);\n            case 7:\n                return center.add(x).add(y).add(z);\n            default:\n                return Vector.ZERO;\n        }\n    }\n    public AxialBox getLocalShape() {\n        return new AxialBox(\n                new Vector(-extentX, -extentY, -extentZ),\n                new Vector(extentX, extentY, extentZ));\n    }\n    public Transform getTransformLocalToParent() {\n        final Transform temp = new Transform();\n        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());\n        temp.moveInParentSpace(center);\n        return temp;\n    }\n    public Transform getTransformParentToLocal() {\n        final Transform temp = new Transform();\n        temp.invert(getTransformLocalToParent());\n        return temp;\n    }\n    public Vector transformToLocal(final Vector vector) {\n        return rotateToLocal(vector.subtract(center));\n    }\n    public Vector transformToWorld(final Vector vector) {\n        return rotateToWorld(vector).add(center);\n    }\n    public Vector rotateToLocal(final Vector vector) {\n        return new Vector(\n                vector.dot(getAxisX()),\n                vector.dot(getAxisY()),\n                vector.dot(getAxisZ()));\n    }\n    public Vector rotateToWorld(final Vector vector) {\n        return Vector.ZERO\n                .add(getAxisX().multiply(vector.x))\n                .add(getAxisY().multiply(vector.y))\n                .add(getAxisZ().multiply(vector.z));\n    }\n"]]}
{"hexsha": "cebbdc7523d968d8f24072abc5e1ab3f921ba715", "ext": "java", "lang": "Java", "content": "public class BinaryInput extends AbstractInput {\r\n    private static final long serialVersionUID = -1467422051075776185L;\r\n    \r\n    private final HexEdit hexEdit = new HexEdit(new byte[0]);\r\n    private byte[] buffer;      // model - byte array\r\n    \r\n    /**\r\n     * Constructor\r\n     * \r\n     */\r\n    public BinaryInput() {\r\n        super();\r\n        setLayout(new GridLayout(1,1));\r\n        hexEdit.addAncestorListener(new RequestFocusListener());    // set focus\r\n        add(hexEdit);\r\n    }\r\n    \r\n    /**\r\n     * Sets value to be edited\r\n     * \r\n     * @param buffer \r\n     */\r\n    public void setValue(byte[] buffer) {\r\n        hexEdit.requestFocusInWindow();\r\n        this.buffer = buffer;\r\n        hexEdit.reset(buffer);\r\n    }\r\n    \r\n    /**\r\n     * Get edited data\r\n     * \r\n     * @return \r\n     */\r\n    public byte[] getValue() {\r\n        return(buffer);\r\n    }\r\n    \r\n}", "class_id": 0, "repo": "metalname/regular", "file": "Common/src/InputHelpers/BinaryInput.java", "last_update_at": "2021-09-12T13:33:15+00:00", "question_id": "cebbdc7523d968d8f24072abc5e1ab3f921ba715", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BinaryInput extends AbstractInput {\r\n    private static final long serialVersionUID = -1467422051075776185L;\r\n    \r\n    private final HexEdit hexEdit = new HexEdit(new byte[0]);\r\n    private byte[] buffer;      // model - byte array\r\n    \r\n    /**\r\n     * Constructor\r\n     * \r\n     */\r\n    public BinaryInput() {\r\n        super();\r\n        setLayout(new GridLayout(1,1));\r\n        hexEdit.addAncestorListener(new RequestFocusListener());    // set focus\r\n        add(hexEdit);\r\n    }\r\n    \r\n    /**\r\n     * Sets value to be edited\r\n     * \r\n     * @param buffer \r\n     */\r\n    public void setValue(byte[] buffer) {\r\n        hexEdit.requestFocusInWindow();\r\n        this.buffer = buffer;\r\n        hexEdit.reset(buffer);\r\n    }\r\n    \r\n    /**\r\n     * Get edited data\r\n     * \r\n     * @return \r\n     */\r\n    public byte[] getValue() {\r\n        return(buffer);\r\n    }\r\n    \r\n"]]}
{"hexsha": "fd52101a33b5d14359ea4a2449bf8b531284b2c9", "ext": "java", "lang": "Java", "content": "public class NonStartTest {\n\n    private NonStart fixture;\n\n    @BeforeEach\n    public void setUp() {\n        fixture = new NonStart();\n    }\n\n    @Test\n    public void testcase1() {\n\n        final String strA = \"Hello\";\n        final String strB = \"There\";\n\n        final String expected = \"ellohere\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase2() {\n\n        final String strA = \"java\";\n        final String strB = \"code\";\n\n        final String expected = \"avaode\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase3() {\n\n        final String strA = \"shotl\";\n        final String strB = \"java\";\n\n        final String expected = \"hotlava\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreNull() {\n\n        final String strA = null;\n        final String strB = null;\n\n        final String expected = \"\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreEmpty() {\n\n        final String strA = \"\";\n        final String strB = \"\";\n\n        final String expected = \"\";\n\n        final String actual = fixture.nonStart(strA, strB);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {\n\n        final String strA1 = null;\n        final String strA2 = \"\";\n        final String strB1 = \"\";\n        final String strB2 = null;\n\n        final String expected = \"\";\n\n        final String actual1 = fixture.nonStart(strA1, strB1);\n        final String actual2 = fixture.nonStart(strA2, strB2);\n\n        assertThat(actual1).isEqualTo(expected);\n        assertThat(actual2).isEqualTo(expected);\n    }\n\n}", "class_id": 0, "repo": "the-code-journal/code-challenges-java", "file": "src/test/java/io/codejournal/codingbat/string1/NonStartTest.java", "last_update_at": "2021-06-13T14:03:00+00:00", "question_id": "fd52101a33b5d14359ea4a2449bf8b531284b2c9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NonStartTest {\n    private NonStart fixture;\n    @BeforeEach\n    public void setUp() {\n        fixture = new NonStart();\n    }\n    @Test\n    public void testcase1() {\n        final String strA = \"Hello\";\n        final String strB = \"There\";\n        final String expected = \"ellohere\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void testcase2() {\n        final String strA = \"java\";\n        final String strB = \"code\";\n        final String expected = \"avaode\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void testcase3() {\n        final String strA = \"shotl\";\n        final String strB = \"java\";\n        final String expected = \"hotlava\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnEmptyWhenBothAreNull() {\n        final String strA = null;\n        final String strB = null;\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnEmptyWhenBothAreEmpty() {\n        final String strA = \"\";\n        final String strB = \"\";\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {\n        final String strA1 = null;\n        final String strA2 = \"\";\n        final String strB1 = \"\";\n        final String strB2 = null;\n        final String expected = \"\";\n        final String actual1 = fixture.nonStart(strA1, strB1);\n        final String actual2 = fixture.nonStart(strA2, strB2);\n        assertThat(actual1).isEqualTo(expected);\n        assertThat(actual2).isEqualTo(expected);\n    }\n"]]}
{"hexsha": "495a13909672c96a7ef84b5eadc8a58384dc2c30", "ext": "java", "lang": "Java", "content": "public class DiffAlgorithm\r\n{\r\n    // XXX: Caution, enabling logging significantly impacts performance\r\n    public static final int VERBOSE_LOGGING = 1;\r\n    \r\n    private DocumentModel baseModel, witnessModel;\r\n\r\n    private SymbolTable symbolTable;\r\n    private Correlator correlator;\r\n    private DifferenceCollector collector;\r\n    private DifferenceSet differenceSet;\r\n    \r\n    \r\n    public DifferenceSet diffDocuments( DocumentModel baseModel, DocumentModel witnessModel )\r\n    {\r\n        if( baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false ) \r\n        {\r\n            SimpleLogger.logError(\"Documents must be tokenized the same way to be comparable.\");\r\n            return null;\r\n        }\r\n\r\n        this.baseModel = baseModel;\r\n        this.witnessModel = witnessModel;\r\n\r\n        return performDiff();\r\n    }\r\n\r\n    //  perform the actual diff algorithm \r\n    private DifferenceSet performDiff()\r\n    {\r\n        // create a common symbol table based on the two documents\r\n        symbolTable = new SymbolTable(baseModel,witnessModel);\r\n\r\n        // Correlate the contents of the two documents\r\n        correlator = new Correlator(symbolTable);\r\n\r\n        // Collect difference information from the correlation data\r\n        collector = new DifferenceCollector(correlator);\r\n        differenceSet = collector.getDifferenceSet();\r\n        \r\n        return differenceSet;\r\n    }\r\n    \r\n    public void updateDifferenceSet(DifferenceSet differenceSet)\r\n    {\r\n    \tthis.differenceSet = differenceSet;\r\n    }\r\n    \r\n\t// Given the offset in one document, this finds the offset of that character in the other document.\r\n\t// If there is a perfect match, then it is easy to know what to return.\r\n\t// If it doesn't appear in the other document, then return it's insert point.\r\n\t// If it is part of a change, return -1.\r\n\r\n\tpublic int getCorrespondingWitnessOffset( int baseOffset, boolean getEnd )\r\n\t{\r\n\t\tint baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);\r\n\t\t\r\n\t\tFileInfo witnessFileInfo = correlator.getNewInfo();\r\n\t\t\r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\tbaseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE)+difference.getLength(Difference.BASE)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int witnessIndex=1; witnessIndex < witnessFileInfo.getSymbolCount()+1; witnessIndex++ ) {\r\n\t\t\tif( witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex ) {\r\n\t\t\t\tif(getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS ) + witnessFileInfo.getSymbol(witnessIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tpublic int getCorrespondingBaseOffset( int witnessOffset, boolean getEnd )\r\n\t{\r\n\t\tint witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);\r\n\t\t\r\n\t\tFileInfo baseFileInfo = correlator.getOldInfo();\r\n\t\t \r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\twitnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS)+difference.getLength(Difference.WITNESS)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int baseIndex=1; baseIndex < baseFileInfo.getSymbolCount()+1; baseIndex++ ) {\r\n\t\t\tif( baseFileInfo.getCrossIndex(baseIndex) == witnessIndex ) {\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE ) + baseFileInfo.getSymbol(baseIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\t\r\n\tprivate int convertIndexToOffset(int index, int type) {\r\n\t\t// For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.\r\n\t\tif( type == Difference.BASE ) {\r\n\t\t\treturn symbolTable.getOldInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn symbolTable.getNewInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t}\r\n\r\n\t// Given an offset into the document, we want to scan the token table, seeing which token that falls in.\r\n\t// There is some space that doesn't belong to any token (white space and punctuation when that is ignored),\r\n\t// so in that case we need to know if we're interested in the token before that or the token after that.\r\n\tprivate int convertOffsetToIndex(int offset, int type, boolean useNext) {\r\n\t\tDocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;\r\n\r\n\t\tList<Token> tokenList = targetDocument.getTokenList();\r\n\t\t\r\n\t\tint i=0;\r\n\t\tfor( Token token : tokenList ) {\r\n\t\t\tint tokenEnd = token.getOffset() + token.getToken().length();\r\n\t\t\t// If we are looking earlier, then we don't want to match the offset itself, because that will look to the user as the next token.\r\n\t\t\t// Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=\r\n\t\t\tint fudge = (useNext?0:1);\r\n\t\t\tif((token.getOffset() <= offset-fudge) &&  (offset <= tokenEnd))\r\n\t\t\t\t\treturn i;\t// Exact match\r\n\t\t\tif (token.getOffset() >= offset) // We've passed the spot, so we must be in the crack between tokens\r\n\t\t\t{\r\n\t\t\t\tif (useNext)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i == tokenList.size()-1) return i;\r\n\t\t\t\t\telse return i;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn (i-1 > 0) ? i-1 : 0;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t\r\n\t\treturn (tokenList.size() > 0 ) ? tokenList.size()-1 : 0;\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "performant-software/juxta-desktop", "file": "src/main/java/edu/virginia/speclab/diff/DiffAlgorithm.java", "last_update_at": "2021-07-17T19:42:48+00:00", "question_id": "495a13909672c96a7ef84b5eadc8a58384dc2c30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DiffAlgorithm\r\n{\r\n    // XXX: Caution, enabling logging significantly impacts performance\r\n    public static final int VERBOSE_LOGGING = 1;\r\n    \r\n    private DocumentModel baseModel, witnessModel;\r\n\r\n    private SymbolTable symbolTable;\r\n    private Correlator correlator;\r\n    private DifferenceCollector collector;\r\n    private DifferenceSet differenceSet;\r\n    \r\n    \r\n    public DifferenceSet diffDocuments( DocumentModel baseModel, DocumentModel witnessModel )\r\n    {\r\n        if( baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false ) \r\n        {\r\n            SimpleLogger.logError(\"Documents must be tokenized the same way to be comparable.\");\r\n            return null;\r\n        }\r\n\r\n        this.baseModel = baseModel;\r\n        this.witnessModel = witnessModel;\r\n\r\n        return performDiff();\r\n    }\r\n\r\n    //  perform the actual diff algorithm \r\n    private DifferenceSet performDiff()\r\n    {\r\n        // create a common symbol table based on the two documents\r\n        symbolTable = new SymbolTable(baseModel,witnessModel);\r\n\r\n        // Correlate the contents of the two documents\r\n        correlator = new Correlator(symbolTable);\r\n\r\n        // Collect difference information from the correlation data\r\n        collector = new DifferenceCollector(correlator);\r\n        differenceSet = collector.getDifferenceSet();\r\n        \r\n        return differenceSet;\r\n    }\r\n    \r\n    public void updateDifferenceSet(DifferenceSet differenceSet)\r\n    {\r\n    \tthis.differenceSet = differenceSet;\r\n    }\r\n    \r\n\t// Given the offset in one document, this finds the offset of that character in the other document.\r\n\t// If there is a perfect match, then it is easy to know what to return.\r\n\t// If it doesn't appear in the other document, then return it's insert point.\r\n\t// If it is part of a change, return -1.\r\n\r\n\tpublic int getCorrespondingWitnessOffset( int baseOffset, boolean getEnd )\r\n\t{\r\n\t\tint baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);\r\n\t\t\r\n\t\tFileInfo witnessFileInfo = correlator.getNewInfo();\r\n\t\t\r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\tbaseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE)+difference.getLength(Difference.BASE)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.WITNESS);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int witnessIndex=1; witnessIndex < witnessFileInfo.getSymbolCount()+1; witnessIndex++ ) {\r\n\t\t\tif( witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex ) {\r\n\t\t\t\tif(getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS ) + witnessFileInfo.getSymbol(witnessIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( witnessIndex, Difference.WITNESS );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tpublic int getCorrespondingBaseOffset( int witnessOffset, boolean getEnd )\r\n\t{\r\n\t\tint witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);\r\n\t\t\r\n\t\tFileInfo baseFileInfo = correlator.getOldInfo();\r\n\t\t \r\n\t\t// The token didn't have an exact match, so it must be in the differenceSet. Look for it there.\r\n\t\t// The offset might appear between tokens. In that case, we need to move it a little to be on a token.\r\n\t\t// converting to a token and back will do that.\r\n\t\twitnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);\r\n\t\tfor (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); )\r\n\t\t{\r\n\t\t\tDifference difference = (Difference)i.next();\r\n\t\t\tif ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS)+difference.getLength(Difference.WITNESS)))\r\n\t\t\t{\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);\r\n\t\t\t\telse\r\n\t\t\t\t\treturn difference.getOffset(Difference.BASE);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// First, see if there is an exact match for the token. If so, return it.\r\n\t\tfor( int baseIndex=1; baseIndex < baseFileInfo.getSymbolCount()+1; baseIndex++ ) {\r\n\t\t\tif( baseFileInfo.getCrossIndex(baseIndex) == witnessIndex ) {\r\n\t\t\t\tif (getEnd)\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE ) + baseFileInfo.getSymbol(baseIndex+1).getSymbolLength();\r\n\t\t\t\telse\r\n\t\t\t\t\treturn convertIndexToOffset( baseIndex, Difference.BASE );\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\t\r\n\tprivate int convertIndexToOffset(int index, int type) {\r\n\t\t// For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.\r\n\t\tif( type == Difference.BASE ) {\r\n\t\t\treturn symbolTable.getOldInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn symbolTable.getNewInfo().getDocumentOffset(index+1);\r\n\t\t}\r\n\t}\r\n\r\n\t// Given an offset into the document, we want to scan the token table, seeing which token that falls in.\r\n\t// There is some space that doesn't belong to any token (white space and punctuation when that is ignored),\r\n\t// so in that case we need to know if we're interested in the token before that or the token after that.\r\n\tprivate int convertOffsetToIndex(int offset, int type, boolean useNext) {\r\n\t\tDocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;\r\n\r\n\t\tList<Token> tokenList = targetDocument.getTokenList();\r\n\t\t\r\n\t\tint i=0;\r\n\t\tfor( Token token : tokenList ) {\r\n\t\t\tint tokenEnd = token.getOffset() + token.getToken().length();\r\n\t\t\t// If we are looking earlier, then we don't want to match the offset itself, because that will look to the user as the next token.\r\n\t\t\t// Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=\r\n\t\t\tint fudge = (useNext?0:1);\r\n\t\t\tif((token.getOffset() <= offset-fudge) &&  (offset <= tokenEnd))\r\n\t\t\t\t\treturn i;\t// Exact match\r\n\t\t\tif (token.getOffset() >= offset) // We've passed the spot, so we must be in the crack between tokens\r\n\t\t\t{\r\n\t\t\t\tif (useNext)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i == tokenList.size()-1) return i;\r\n\t\t\t\t\telse return i;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn (i-1 > 0) ? i-1 : 0;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t\r\n\t\treturn (tokenList.size() > 0 ) ? tokenList.size()-1 : 0;\r\n\t}\r\n\r\n"]]}
{"hexsha": "05ef2f68dbf7ba92065c8486bd0b45aff254557c", "ext": "java", "lang": "Java", "content": "public class OrganisationTransformer\n{\n\tpublic static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException\n    {\n        ArrayList<Organization> organizations = new ArrayList<>();\n\n        for (OpenHR001Organisation source: sources)\n            organizations.add(transform(source));\n\n        return organizations;\n    }\n\n\tpublic static Organization transform(OpenHR001Organisation source) throws TransformException\n    {\n\t\tOpenHRHelper.ensureDboNotDelete(source);\n\n\t\tOrganization target = new Organization();\n\n        target.setId(source.getId());\n        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));\n\n        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))\n            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));\n\n        target.setActive(source.getCloseDate() == null);\n\n        if ((source.getOpenDate() != null) || (source.getCloseDate() != null))\n        {\n            Period period = new Period();\n\n            if (source.getOpenDate() != null)\n                period.setStart(DateConverter.toDate(source.getOpenDate()));\n\n            if (source.getCloseDate() != null)\n                period.setEnd(DateConverter.toDate(source.getCloseDate()));\n\n            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));\n        }\n\n        target.setName(source.getName());\n        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));\n\n        if (!StringUtils.isBlank(source.getParentOrganisation()))\n            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));\n\n        if (!StringUtils.isBlank(source.getMainLocation()))\n            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));\n\n\t\treturn target;\n\t}\n}", "class_id": 0, "repo": "endeavourhealth/Transforms", "file": "src/main/java/org/endeavourhealth/transform/emis/openhr/transforms/admin/OrganisationTransformer.java", "last_update_at": "2021-08-17T12:29:48+00:00", "question_id": "05ef2f68dbf7ba92065c8486bd0b45aff254557c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrganisationTransformer\n{\n\tpublic static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException\n    {\n        ArrayList<Organization> organizations = new ArrayList<>();\n        for (OpenHR001Organisation source: sources)\n            organizations.add(transform(source));\n        return organizations;\n    }\n\tpublic static Organization transform(OpenHR001Organisation source) throws TransformException\n    {\n\t\tOpenHRHelper.ensureDboNotDelete(source);\n\t\tOrganization target = new Organization();\n        target.setId(source.getId());\n        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));\n        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))\n            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));\n        target.setActive(source.getCloseDate() == null);\n        if ((source.getOpenDate() != null) || (source.getCloseDate() != null))\n        {\n            Period period = new Period();\n            if (source.getOpenDate() != null)\n                period.setStart(DateConverter.toDate(source.getOpenDate()));\n            if (source.getCloseDate() != null)\n                period.setEnd(DateConverter.toDate(source.getCloseDate()));\n            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));\n        }\n        target.setName(source.getName());\n        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));\n        if (!StringUtils.isBlank(source.getParentOrganisation()))\n            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));\n        if (!StringUtils.isBlank(source.getMainLocation()))\n            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));\n\t\treturn target;\n\t}\n"]]}
{"hexsha": "39d74258dd6a75d4e31c7f001884daaab0356310", "ext": "java", "lang": "Java", "content": "public class Do implements Directive {\n    Directive _prefix;\n\n    @Override\n    public String script() {\n        return String.format(\"%s do\", _prefix.script());\n    }\n\n    @Override\n    public List<Parameter> parameters() {\n        return _prefix.parameters();\n    }\n\n    public Nothing nothing(){\n        Nothing re = new Nothing();\n        re._prefix = this;\n        return re;\n    }\n\n    public Update update(){\n        Update re = new Update();\n        re._prefix = this;\n        return re;\n    }\n\n    public class Update implements Directive {\n        Directive _prefix;\n\n        @Override\n        public String script() {\n            return String.format(\"%s update\", _prefix.script());\n        }\n\n        @Override\n        public List<Parameter> parameters() {\n            return _prefix.parameters();\n        }\n\n        public jaskell.sql.Update.Set set(String field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n\n        public jaskell.sql.Update.Set set(Directive field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n    }\n}", "class_id": 0, "repo": "moonbirdxp/jaskell", "file": "src/main/java/jaskell/sql/Do.java", "last_update_at": "2021-04-29T01:31:42+00:00", "question_id": "39d74258dd6a75d4e31c7f001884daaab0356310", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Do implements Directive {\n    Directive _prefix;\n    @Override\n    public String script() {\n        return String.format(\"%s do\", _prefix.script());\n    }\n    @Override\n    public List<Parameter> parameters() {\n        return _prefix.parameters();\n    }\n    public Nothing nothing(){\n        Nothing re = new Nothing();\n        re._prefix = this;\n        return re;\n    }\n    public Update update(){\n        Update re = new Update();\n        re._prefix = this;\n        return re;\n    }\n    public class Update implements Directive {\n        Directive _prefix;\n        @Override\n        public String script() {\n            return String.format(\"%s update\", _prefix.script());\n        }\n        @Override\n        public List<Parameter> parameters() {\n            return _prefix.parameters();\n        }\n        public jaskell.sql.Update.Set set(String field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n        public jaskell.sql.Update.Set set(Directive field, Directive value){\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n    }\n"]]}
{"hexsha": "8430996939d31d00feb517b1c2345762d39cc91e", "ext": "java", "lang": "Java", "content": "public class PullRequestRescopedActivity extends PullRequestActivity{\n\n    private String fromHash;\n    private String previousFromHash;\n    private String previousToHash;\n    private String toHash;\n\n    private List<Commit> added;\n    private List<Commit> removed;\n\n    protected PullRequestRescopedActivity() {\n    }\n\n    public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {\n        this.id = id;\n        this.createdDate = createdDate;\n        this.user = user;\n        this.pullRequestId = pullRequestId;\n        this.fromHash = fromHash;\n        this.previousFromHash = previousFromHash;\n        this.previousToHash = previousToHash;\n        this.toHash = toHash;\n        this.added = ImmutableList.copyOf(added);\n        this.removed = ImmutableList.copyOf(removed);\n        this.actionType = PullRequestActivityActionType.RESCOPED;\n    }\n\n    public String getFromHash() {\n        return fromHash;\n    }\n\n    public String getPreviousFromHash() {\n        return previousFromHash;\n    }\n\n    public String getPreviousToHash() {\n        return previousToHash;\n    }\n\n    public String getToHash() {\n        return toHash;\n    }\n\n    public List<Commit> getAdded() {\n        return added;\n    }\n\n    public List<Commit> getRemoved() {\n        return removed;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PullRequestRescopedActivity that = (PullRequestRescopedActivity) o;\n\n        if (pullRequestId != that.pullRequestId) return false;\n        if (fromHash != null ? !fromHash.equals(that.fromHash) : that.fromHash != null) return false;\n        if (previousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)\n            return false;\n        if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)\n            return false;\n        if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null) return false;\n        if (added != null ? !added.equals(that.added) : that.added != null) return false;\n        if (removed != null ? !removed.equals(that.removed) : that.removed != null) return false;\n        if (id != null ? !id.equals(that.id) : that.id != null) return false;\n        if (createdDate != null ? !createdDate.equals(that.createdDate) : that.createdDate != null) return false;\n        if (user != null ? !user.equals(that.user) : that.user != null) return false;\n        return actionType == that.actionType;\n\n    }\n\n    @Override\n    public int hashCode() {\n        int result = fromHash != null ? fromHash.hashCode() : 0;\n        result = 31 * result + (previousFromHash != null ? previousFromHash.hashCode() : 0);\n        result = 31 * result + (previousToHash != null ? previousToHash.hashCode() : 0);\n        result = 31 * result + (toHash != null ? toHash.hashCode() : 0);\n        result = 31 * result + (added != null ? added.hashCode() : 0);\n        result = 31 * result + (removed != null ? removed.hashCode() : 0);\n        result = 31 * result + (id != null ? id.hashCode() : 0);\n        result = 31 * result + (createdDate != null ? createdDate.hashCode() : 0);\n        result = 31 * result + (user != null ? user.hashCode() : 0);\n        result = 31 * result + (int) (pullRequestId ^ (pullRequestId >>> 32));\n        result = 31 * result + (actionType != null ? actionType.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"PullRequestRescopedActivity{\" +\n                \"fromHash='\" + fromHash + '\\'' +\n                \", previousFromHash='\" + previousFromHash + '\\'' +\n                \", previousToHash='\" + previousToHash + '\\'' +\n                \", toHash='\" + toHash + '\\'' +\n                \", added=\" + added +\n                \", removed=\" + removed +\n                \", id=\" + id +\n                \", createdDate=\" + createdDate +\n                \", user=\" + user +\n                \", pullRequestId=\" + pullRequestId +\n                \", actionType=\" + actionType +\n                '}';\n    }\n}", "class_id": 0, "repo": "cornelcreanga/bitbucket-rest-client", "file": "src/main/java/com/ccreanga/bitbucket/rest/client/model/pull/activity/PullRequestRescopedActivity.java", "last_update_at": "2021-06-30T06:37:32+00:00", "question_id": "8430996939d31d00feb517b1c2345762d39cc91e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PullRequestRescopedActivity extends PullRequestActivity{\n    private String fromHash;\n    private String previousFromHash;\n    private String previousToHash;\n    private String toHash;\n    private List<Commit> added;\n    private List<Commit> removed;\n    protected PullRequestRescopedActivity() {\n    }\n    public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {\n        this.id = id;\n        this.createdDate = createdDate;\n        this.user = user;\n        this.pullRequestId = pullRequestId;\n        this.fromHash = fromHash;\n        this.previousFromHash = previousFromHash;\n        this.previousToHash = previousToHash;\n        this.toHash = toHash;\n        this.added = ImmutableList.copyOf(added);\n        this.removed = ImmutableList.copyOf(removed);\n        this.actionType = PullRequestActivityActionType.RESCOPED;\n    }\n    public String getFromHash() {\n        return fromHash;\n    }\n    public String getPreviousFromHash() {\n        return previousFromHash;\n    }\n    public String getPreviousToHash() {\n        return previousToHash;\n    }\n    public String getToHash() {\n        return toHash;\n    }\n    public List<Commit> getAdded() {\n        return added;\n    }\n    public List<Commit> getRemoved() {\n        return removed;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        PullRequestRescopedActivity that = (PullRequestRescopedActivity) o;\n        if (pullRequestId != that.pullRequestId) return false;\n        if (fromHash != null ? !fromHash.equals(that.fromHash) : that.fromHash != null) return false;\n        if (previousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)\n            return false;\n        if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)\n            return false;\n        if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null) return false;\n        if (added != null ? !added.equals(that.added) : that.added != null) return false;\n        if (removed != null ? !removed.equals(that.removed) : that.removed != null) return false;\n        if (id != null ? !id.equals(that.id) : that.id != null) return false;\n        if (createdDate != null ? !createdDate.equals(that.createdDate) : that.createdDate != null) return false;\n        if (user != null ? !user.equals(that.user) : that.user != null) return false;\n        return actionType == that.actionType;\n    }\n    @Override\n    public int hashCode() {\n        int result = fromHash != null ? fromHash.hashCode() : 0;\n        result = 31 * result + (previousFromHash != null ? previousFromHash.hashCode() : 0);\n        result = 31 * result + (previousToHash != null ? previousToHash.hashCode() : 0);\n        result = 31 * result + (toHash != null ? toHash.hashCode() : 0);\n        result = 31 * result + (added != null ? added.hashCode() : 0);\n        result = 31 * result + (removed != null ? removed.hashCode() : 0);\n        result = 31 * result + (id != null ? id.hashCode() : 0);\n        result = 31 * result + (createdDate != null ? createdDate.hashCode() : 0);\n        result = 31 * result + (user != null ? user.hashCode() : 0);\n        result = 31 * result + (int) (pullRequestId ^ (pullRequestId >>> 32));\n        result = 31 * result + (actionType != null ? actionType.hashCode() : 0);\n        return result;\n    }\n    @Override\n    public String toString() {\n        return \"PullRequestRescopedActivity{\" +\n                \"fromHash='\" + fromHash + '\\'' +\n                \", previousFromHash='\" + previousFromHash + '\\'' +\n                \", previousToHash='\" + previousToHash + '\\'' +\n                \", toHash='\" + toHash + '\\'' +\n                \", added=\" + added +\n                \", removed=\" + removed +\n                \", id=\" + id +\n                \", createdDate=\" + createdDate +\n                \", user=\" + user +\n                \", pullRequestId=\" + pullRequestId +\n                \", actionType=\" + actionType +\n                '}';\n    }\n"]]}
{"hexsha": "cbdaafcd9298f370a6c6ed63c5358f105f12b3e8", "ext": "java", "lang": "Java", "content": "public final class CookieManager extends CookieHandler {\n\n    private static final Logger logger =\n        Logger.getLogger(CookieManager.class.getName());\n\n\n    private final CookieStore store = new CookieStore();\n\n\n    /**\n     * Creates a new {@code CookieManager}.\n     */\n    public CookieManager() {\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String,List<String>> get(URI uri,\n            Map<String,List<String>> requestHeaders)\n    {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\",\n                    new Object[] {uri, toLogString(requestHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n\n        String cookieString = get(uri);\n\n        Map<String,List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String,List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the cookie string for a given URI.\n     */\n    private String get(URI uri) {\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, returning null\");\n            return null;\n        }\n        host = canonicalize(host);\n\n        String scheme = uri.getScheme();\n        boolean secureProtocol = \"https\".equalsIgnoreCase(scheme)\n                || \"javascripts\".equalsIgnoreCase(scheme);\n        boolean httpApi = \"http\".equalsIgnoreCase(scheme)\n                || \"https\".equalsIgnoreCase(scheme);\n\n        List<Cookie> cookieList;\n        synchronized (store) {\n            cookieList = store.get(host, uri.getPath(),\n                    secureProtocol, httpApi);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (Cookie cookie : cookieList) {\n            if (sb.length() > 0) {\n                sb.append(\"; \");\n            }\n            sb.append(cookie.getName());\n            sb.append('=');\n            sb.append(cookie.getValue());\n        }\n\n        return sb.length() > 0 ? sb.toString() : null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String,List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\",\n                    new Object[] {uri, toLogString(responseHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n\n        for (Map.Entry<String,List<String>> entry : responseHeaders.entrySet())\n        {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // RT-15907: Process the list of headers in reverse order,\n            // effectively restoring the order in which the headers were\n            // received from the server. This is a temporary workaround for\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it =\n                    entry.getValue().listIterator(entry.getValue().size());\n            while (it.hasPrevious()) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }\n\n    /**\n     * Puts an individual cookie.\n     */\n    private void put(URI uri, Cookie cookie) {\n        logger.log(Level.FINEST, \"cookie: {0}\", cookie);\n\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, ignoring cookie\");\n            return;\n        }\n        host = canonicalize(host);\n\n        if (PublicSuffixes.isPublicSuffix(cookie.getDomain())) {\n            if (cookie.getDomain().equals(host)) {\n                cookie.setDomain(\"\");\n            } else {\n                logger.log(Level.FINEST, \"Domain is public suffix, \"\n                        + \"ignoring cookie\");\n                return;\n            }\n        }\n\n        if (cookie.getDomain().length() > 0) {\n            if (!Cookie.domainMatches(host, cookie.getDomain())) {\n                logger.log(Level.FINEST, \"Hostname does not match domain, \"\n                        + \"ignoring cookie\");\n                return;\n            } else {\n                cookie.setHostOnly(false);\n            }\n        } else {\n            cookie.setHostOnly(true);\n            cookie.setDomain(host);\n        }\n\n        if (cookie.getPath() == null) {\n            cookie.setPath(Cookie.defaultPath(uri));\n        }\n\n        boolean httpApi = \"http\".equalsIgnoreCase(uri.getScheme())\n                || \"https\".equalsIgnoreCase(uri.getScheme());\n        if (cookie.getHttpOnly() && !httpApi) {\n            logger.log(Level.FINEST, \"HttpOnly cookie received from non-HTTP \"\n                    + \"API, ignoring cookie\");\n            return;\n        }\n\n        synchronized (store) {\n            Cookie oldCookie = store.get(cookie);\n            if (oldCookie != null) {\n                if (oldCookie.getHttpOnly() && !httpApi) {\n                    logger.log(Level.FINEST, \"Non-HTTP API attempts to \"\n                            + \"overwrite HttpOnly cookie, blocked\");\n                    return;\n                }\n                cookie.setCreationTime(oldCookie.getCreationTime());\n            }\n\n            store.put(cookie);\n        }\n\n        logger.log(Level.FINEST, \"Stored: {0}\", cookie);\n    }\n\n    /**\n     * Converts a map of HTTP headers to a string suitable for displaying\n     * in the log.\n     */\n    private static String toLogString(Map<String,List<String>> headers) {\n        if (headers == null) {\n            return null;\n        }\n        if (headers.isEmpty()) {\n            return \"{}\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String,List<String>> entry : headers.entrySet()) {\n            String key = entry.getKey();\n            for (String value : entry.getValue()) {\n                sb.append(String.format(\"%n    \"));\n                sb.append(key);\n                sb.append(\": \");\n                sb.append(value);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Canonicalizes a hostname as required by RFC 6265.\n     */\n    private static String canonicalize(String hostname) {\n        // The hostname is already all-ASCII at this point\n        return hostname.toLowerCase();\n    }\n}", "class_id": 0, "repo": "likuisuper/Java-Notes", "file": "JavaSourceLearn/javafx-src/com/sun/webkit/network/CookieManager.java", "last_update_at": "2021-01-30T13:44:33+00:00", "question_id": "cbdaafcd9298f370a6c6ed63c5358f105f12b3e8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class CookieManager extends CookieHandler {\n    private static final Logger logger =\n        Logger.getLogger(CookieManager.class.getName());\n    private final CookieStore store = new CookieStore();\n    /**\n     * Creates a new {@code CookieManager}.\n     */\n    public CookieManager() {\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String,List<String>> get(URI uri,\n            Map<String,List<String>> requestHeaders)\n    {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\",\n                    new Object[] {uri, toLogString(requestHeaders)});\n        }\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n        String cookieString = get(uri);\n        Map<String,List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String,List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }\n    /**\n     * Returns the cookie string for a given URI.\n     */\n    private String get(URI uri) {\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, returning null\");\n            return null;\n        }\n        host = canonicalize(host);\n        String scheme = uri.getScheme();\n        boolean secureProtocol = \"https\".equalsIgnoreCase(scheme)\n                || \"javascripts\".equalsIgnoreCase(scheme);\n        boolean httpApi = \"http\".equalsIgnoreCase(scheme)\n                || \"https\".equalsIgnoreCase(scheme);\n        List<Cookie> cookieList;\n        synchronized (store) {\n            cookieList = store.get(host, uri.getPath(),\n                    secureProtocol, httpApi);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Cookie cookie : cookieList) {\n            if (sb.length() > 0) {\n                sb.append(\"; \");\n            }\n            sb.append(cookie.getName());\n            sb.append('=');\n            sb.append(cookie.getValue());\n        }\n        return sb.length() > 0 ? sb.toString() : null;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String,List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\",\n                    new Object[] {uri, toLogString(responseHeaders)});\n        }\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n        for (Map.Entry<String,List<String>> entry : responseHeaders.entrySet())\n        {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // RT-15907: Process the list of headers in reverse order,\n            // effectively restoring the order in which the headers were\n            // received from the server. This is a temporary workaround for\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it =\n                    entry.getValue().listIterator(entry.getValue().size());\n            while (it.hasPrevious()) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }\n    /**\n     * Puts an individual cookie.\n     */\n    private void put(URI uri, Cookie cookie) {\n        logger.log(Level.FINEST, \"cookie: {0}\", cookie);\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, ignoring cookie\");\n            return;\n        }\n        host = canonicalize(host);\n        if (PublicSuffixes.isPublicSuffix(cookie.getDomain())) {\n            if (cookie.getDomain().equals(host)) {\n                cookie.setDomain(\"\");\n            } else {\n                logger.log(Level.FINEST, \"Domain is public suffix, \"\n                        + \"ignoring cookie\");\n                return;\n            }\n        }\n        if (cookie.getDomain().length() > 0) {\n            if (!Cookie.domainMatches(host, cookie.getDomain())) {\n                logger.log(Level.FINEST, \"Hostname does not match domain, \"\n                        + \"ignoring cookie\");\n                return;\n            } else {\n                cookie.setHostOnly(false);\n            }\n        } else {\n            cookie.setHostOnly(true);\n            cookie.setDomain(host);\n        }\n        if (cookie.getPath() == null) {\n            cookie.setPath(Cookie.defaultPath(uri));\n        }\n        boolean httpApi = \"http\".equalsIgnoreCase(uri.getScheme())\n                || \"https\".equalsIgnoreCase(uri.getScheme());\n        if (cookie.getHttpOnly() && !httpApi) {\n            logger.log(Level.FINEST, \"HttpOnly cookie received from non-HTTP \"\n                    + \"API, ignoring cookie\");\n            return;\n        }\n        synchronized (store) {\n            Cookie oldCookie = store.get(cookie);\n            if (oldCookie != null) {\n                if (oldCookie.getHttpOnly() && !httpApi) {\n                    logger.log(Level.FINEST, \"Non-HTTP API attempts to \"\n                            + \"overwrite HttpOnly cookie, blocked\");\n                    return;\n                }\n                cookie.setCreationTime(oldCookie.getCreationTime());\n            }\n            store.put(cookie);\n        }\n        logger.log(Level.FINEST, \"Stored: {0}\", cookie);\n    }\n    /**\n     * Converts a map of HTTP headers to a string suitable for displaying\n     * in the log.\n     */\n    private static String toLogString(Map<String,List<String>> headers) {\n        if (headers == null) {\n            return null;\n        }\n        if (headers.isEmpty()) {\n            return \"{}\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String,List<String>> entry : headers.entrySet()) {\n            String key = entry.getKey();\n            for (String value : entry.getValue()) {\n                sb.append(String.format(\"%n    \"));\n                sb.append(key);\n                sb.append(\": \");\n                sb.append(value);\n            }\n        }\n        return sb.toString();\n    }\n    /**\n     * Canonicalizes a hostname as required by RFC 6265.\n     */\n    private static String canonicalize(String hostname) {\n        // The hostname is already all-ASCII at this point\n        return hostname.toLowerCase();\n    }\n"]]}
{"hexsha": "0652ad2af2a6eb0257e3ffcd905f120ac148e447", "ext": "java", "lang": "Java", "content": "@Component\npublic class PaymentHandler implements PreSubmitCallbackHandler<AsylumCase> {\n\n    private final boolean isfeePaymentEnabled;\n\n    public PaymentHandler(@Value(\"${featureFlag.isfeePaymentEnabled}\") boolean isfeePaymentEnabled) {\n        this.isfeePaymentEnabled = isfeePaymentEnabled;\n    }\n\n    @Override\n    public DispatchPriority getDispatchPriority() {\n        return DispatchPriority.EARLY;\n    }\n\n    public boolean canHandle(\n        PreSubmitCallbackStage callbackStage,\n        Callback<AsylumCase> callback\n    ) {\n\n        requireNonNull(callbackStage, \"callbackStage must not be null\");\n        requireNonNull(callback, \"callback must not be null\");\n\n        return callbackStage == PreSubmitCallbackStage.ABOUT_TO_SUBMIT\n               && (callback.getEvent() == Event.PAY_AND_SUBMIT_APPEAL\n                   || callback.getEvent() == Event.PAY_FOR_APPEAL\n                   || callback.getEvent() == Event.PAYMENT_APPEAL\n               )\n               && isfeePaymentEnabled;\n    }\n\n    public PreSubmitCallbackResponse<AsylumCase> handle(\n        PreSubmitCallbackStage callbackStage,\n        Callback<AsylumCase> callback\n    ) {\n        if (!canHandle(callbackStage, callback)) {\n            throw new IllegalStateException(\"Cannot handle callback\");\n        }\n\n        final AsylumCase asylumCase = callback.getCaseDetails().getCaseData();\n\n        boolean isRepJourney = asylumCase.read(AsylumCaseFieldDefinition.JOURNEY_TYPE, JourneyType.class)\n                .map(j -> j == JourneyType.REP)\n                .orElse(true);\n\n        // we have to set payment success first before do the payment because later we don't have possibility to change that\n        if (isRepJourney) {\n            asylumCase.write(PAYMENT_STATUS, PAID);\n        }\n\n        asylumCase.write(AsylumCaseFieldDefinition.IS_FEE_PAYMENT_ENABLED,\n            isfeePaymentEnabled ? YesOrNo.YES : YesOrNo.NO);\n\n        return new PreSubmitCallbackResponse<>(asylumCase);\n    }\n}", "class_id": 0, "repo": "hmcts/iac-case-api", "file": "src/main/java/uk/gov/hmcts/reform/iacaseapi/domain/handlers/presubmit/payment/PaymentHandler.java", "last_update_at": "2021-12-02T09:37:28+00:00", "question_id": "0652ad2af2a6eb0257e3ffcd905f120ac148e447", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class PaymentHandler implements PreSubmitCallbackHandler<AsylumCase> {\n    private final boolean isfeePaymentEnabled;\n    public PaymentHandler(@Value(\"${featureFlag.isfeePaymentEnabled}\") boolean isfeePaymentEnabled) {\n        this.isfeePaymentEnabled = isfeePaymentEnabled;\n    }\n    @Override\n    public DispatchPriority getDispatchPriority() {\n        return DispatchPriority.EARLY;\n    }\n    public boolean canHandle(\n        PreSubmitCallbackStage callbackStage,\n        Callback<AsylumCase> callback\n    ) {\n        requireNonNull(callbackStage, \"callbackStage must not be null\");\n        requireNonNull(callback, \"callback must not be null\");\n        return callbackStage == PreSubmitCallbackStage.ABOUT_TO_SUBMIT\n               && (callback.getEvent() == Event.PAY_AND_SUBMIT_APPEAL\n                   || callback.getEvent() == Event.PAY_FOR_APPEAL\n                   || callback.getEvent() == Event.PAYMENT_APPEAL\n               )\n               && isfeePaymentEnabled;\n    }\n    public PreSubmitCallbackResponse<AsylumCase> handle(\n        PreSubmitCallbackStage callbackStage,\n        Callback<AsylumCase> callback\n    ) {\n        if (!canHandle(callbackStage, callback)) {\n            throw new IllegalStateException(\"Cannot handle callback\");\n        }\n        final AsylumCase asylumCase = callback.getCaseDetails().getCaseData();\n        boolean isRepJourney = asylumCase.read(AsylumCaseFieldDefinition.JOURNEY_TYPE, JourneyType.class)\n                .map(j -> j == JourneyType.REP)\n                .orElse(true);\n        // we have to set payment success first before do the payment because later we don't have possibility to change that\n        if (isRepJourney) {\n            asylumCase.write(PAYMENT_STATUS, PAID);\n        }\n        asylumCase.write(AsylumCaseFieldDefinition.IS_FEE_PAYMENT_ENABLED,\n            isfeePaymentEnabled ? YesOrNo.YES : YesOrNo.NO);\n        return new PreSubmitCallbackResponse<>(asylumCase);\n    }\n"]]}
{"hexsha": "e1ad45857a9b1ea21e59ac0936bf389b3c285f6b", "ext": "java", "lang": "Java", "content": "public class SegmenterTest {\n\n    public static Segmenter.Data dataEmpty;\n\n    static {\n        try {\n            dataEmpty = new Segmenter.Data(\n                    new JSONObject(\"{}\"),\n                    Collections.emptyList(),\n                    null,\n                    0L\n            );\n        } catch (JSONException ex) {\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static Segmenter.Data dataWithInstallation(Segmenter.Data data, JSONObject installation) {\n        return new Segmenter.Data(\n                installation,\n                data.allEvents,\n                data.presenceInfo,\n                data.lastAppOpenDate\n        );\n    }\n\n    public static Segmenter.Data dataWithAllEvents(Segmenter.Data data, List<JSONObject> allEvents) {\n        return new Segmenter.Data(\n                data.installation,\n                allEvents,\n                data.presenceInfo,\n                data.lastAppOpenDate\n        );\n    }\n\n    public static Segmenter.Data dataWithPresenceInfo(Segmenter.Data data, Segmenter.PresenceInfo presenceInfo) {\n        return new Segmenter.Data(\n                data.installation,\n                data.allEvents,\n                presenceInfo,\n                data.lastAppOpenDate\n        );\n    }\n\n    public static Segmenter.Data dataWithLastAppOpenDate(Segmenter.Data data, long lastAppOpenDate) {\n        return new Segmenter.Data(\n                data.installation,\n                data.allEvents,\n                data.presenceInfo,\n                lastAppOpenDate\n        );\n    }\n\n    public static Segmenter.Data dataWithInstallationDiff(Segmenter.Data data, JSONObject installationDiff, boolean nullFieldRemoves) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONUtil.merge(installation, installationDiff, nullFieldRemoves);\n            return dataWithInstallation(data, installation);\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static Segmenter.Data dataWithNewerEvent(Segmenter.Data data, JSONObject newerEvent) {\n        List<JSONObject> allEvents = new ArrayList<>(data.allEvents.size() + 1);\n        String newerEventType = JSONUtil.getString(newerEvent, \"type\");\n        if (newerEventType == null) throw new RuntimeException(\"missing event type\");\n        for (JSONObject event : data.allEvents) {\n            String eventType = JSONUtil.getString(event, \"type\");\n            if (!newerEventType.equals(eventType)) {\n                allEvents.add(event);\n            }\n        }\n        allEvents.add(newerEvent);\n        return dataWithAllEvents(data, allEvents);\n    }\n\n    public static Segmenter.Data dataWithTags(Segmenter.Data data, Set<String> tags) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONObject custom = installation.optJSONObject(\"custom\");\n            if (custom == null) {\n                custom = new JSONObject();\n                installation.put(\"custom\", custom);\n            }\n            custom.put(\"tags\", new JSONArray(tags));\n            return new Segmenter.Data(\n                    installation,\n                    data.allEvents,\n                    data.presenceInfo,\n                    data.lastAppOpenDate\n            );\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Test\n    public void testItShouldMatchMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        Segmenter s = new Segmenter(dataEmpty);\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{}\"));\n        assertThat(s.matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqNull() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":null}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[null,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqFalse() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqTrue() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq0() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq00() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq1() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq10() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1.5,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":9223372036854775807}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775808}\"))).matchesInstallation(parsedSegment), is(false));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775806e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775807e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":7.000000000000000512e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999487}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999488}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000001}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000512}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000513}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqBigDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1e300}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1e300,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqBar() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqEmptystring() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqNumber() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        // 1577836800000 is 2020-01-01T00:00:00.000Z\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":1577836800000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqDateString() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":{\\\"date\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":9223372036854775806}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854777000e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":9.223372036854775808e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonIntegers() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonFloats() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonStrings() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonMixed() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonBooleans() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchEventTypeTest() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".bar\\\":{\\\".sub\\\":{\\\"eq\\\":\\\"sub\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchEventInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"nope\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchUser() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"user\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAnd() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"},\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"and\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchOr() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"or\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"to\\\":\\\"to\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchNot() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"not\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldNotMatchUnknownCriterion() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"unknown criterion\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchSubscriptionStatus() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"softOptOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optIn\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchLastActivityDate() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":1000000000000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 999999999999L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000000L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000001L)).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, TimeSync.getTime())).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchPresence() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        long now = TimeSync.getTime();\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true)); // not present yet, so not present\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true)); // not present yet, so not present, and it will last 60s, so we pass\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, but leave date is not lte -PT1M\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 120000, now + 180000, 60000))).matchesInstallation(parsedSegment), is(true)); // not present yet, and leave date is gte -PT1M\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, but leave date is gte -PT1M\n    }\n\n    @Test\n    public void testItShouldMatchPrefix() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"fo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"f\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"FOO\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAny() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n}", "class_id": 0, "repo": "Bitoons/wonderpush-android-sdk", "file": "sdk/src/test/java/com/wonderpush/sdk/segmentation/SegmenterTest.java", "last_update_at": "2021-01-20T17:06:02+00:00", "question_id": "e1ad45857a9b1ea21e59ac0936bf389b3c285f6b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SegmenterTest {\n    public static Segmenter.Data dataEmpty;\n    static {\n        try {\n            dataEmpty = new Segmenter.Data(\n                    new JSONObject(\"{}\"),\n                    Collections.emptyList(),\n                    null,\n                    0L\n            );\n        } catch (JSONException ex) {\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n    public static Segmenter.Data dataWithInstallation(Segmenter.Data data, JSONObject installation) {\n        return new Segmenter.Data(\n                installation,\n                data.allEvents,\n                data.presenceInfo,\n                data.lastAppOpenDate\n        );\n    }\n    public static Segmenter.Data dataWithAllEvents(Segmenter.Data data, List<JSONObject> allEvents) {\n        return new Segmenter.Data(\n                data.installation,\n                allEvents,\n                data.presenceInfo,\n                data.lastAppOpenDate\n        );\n    }\n    public static Segmenter.Data dataWithPresenceInfo(Segmenter.Data data, Segmenter.PresenceInfo presenceInfo) {\n        return new Segmenter.Data(\n                data.installation,\n                data.allEvents,\n                presenceInfo,\n                data.lastAppOpenDate\n        );\n    }\n    public static Segmenter.Data dataWithLastAppOpenDate(Segmenter.Data data, long lastAppOpenDate) {\n        return new Segmenter.Data(\n                data.installation,\n                data.allEvents,\n                data.presenceInfo,\n                lastAppOpenDate\n        );\n    }\n    public static Segmenter.Data dataWithInstallationDiff(Segmenter.Data data, JSONObject installationDiff, boolean nullFieldRemoves) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONUtil.merge(installation, installationDiff, nullFieldRemoves);\n            return dataWithInstallation(data, installation);\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    public static Segmenter.Data dataWithNewerEvent(Segmenter.Data data, JSONObject newerEvent) {\n        List<JSONObject> allEvents = new ArrayList<>(data.allEvents.size() + 1);\n        String newerEventType = JSONUtil.getString(newerEvent, \"type\");\n        if (newerEventType == null) throw new RuntimeException(\"missing event type\");\n        for (JSONObject event : data.allEvents) {\n            String eventType = JSONUtil.getString(event, \"type\");\n            if (!newerEventType.equals(eventType)) {\n                allEvents.add(event);\n            }\n        }\n        allEvents.add(newerEvent);\n        return dataWithAllEvents(data, allEvents);\n    }\n    public static Segmenter.Data dataWithTags(Segmenter.Data data, Set<String> tags) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONObject custom = installation.optJSONObject(\"custom\");\n            if (custom == null) {\n                custom = new JSONObject();\n                installation.put(\"custom\", custom);\n            }\n            custom.put(\"tags\", new JSONArray(tags));\n            return new Segmenter.Data(\n                    installation,\n                    data.allEvents,\n                    data.presenceInfo,\n                    data.lastAppOpenDate\n            );\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    @Test\n    public void testItShouldMatchMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        Segmenter s = new Segmenter(dataEmpty);\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{}\"));\n        assertThat(s.matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqNull() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":null}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[null,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqFalse() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqTrue() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEq0() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEq00() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEq1() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEq10() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1.5,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":9223372036854775807}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775808}\"))).matchesInstallation(parsedSegment), is(false));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775806e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775807e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":7.000000000000000512e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999487}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999488}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000001}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000512}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000513}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqBigDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1e300}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1e300,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqBar() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooEqEmptystring() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqNumber() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        // 1577836800000 is 2020-01-01T00:00:00.000Z\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":1577836800000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqDateString() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":{\\\"date\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooComparisonLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":9223372036854775806}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854777000e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":9.223372036854775808e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooComparisonIntegers() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooComparisonFloats() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooComparisonStrings() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchFieldFooComparisonMixed() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchFieldFooComparisonBooleans() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchEventTypeTest() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".bar\\\":{\\\".sub\\\":{\\\"eq\\\":\\\"sub\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchEventInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"nope\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchUser() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"user\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchAnd() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"},\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"and\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchOr() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"or\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"to\\\":\\\"to\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchNot() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"not\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldNotMatchUnknownCriterion() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"unknown criterion\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchSubscriptionStatus() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"softOptOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optIn\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchLastActivityDate() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":1000000000000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 999999999999L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000000L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000001L)).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, TimeSync.getTime())).matchesInstallation(parsedSegment), is(true));\n    }\n    @Test\n    public void testItShouldMatchPresence() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        long now = TimeSync.getTime();\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true)); // not present yet, so not present\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true)); // not present yet, so not present, and it will last 60s, so we pass\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, but leave date is not lte -PT1M\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, so not present\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 120000, now + 180000, 60000))).matchesInstallation(parsedSegment), is(true)); // not present yet, and leave date is gte -PT1M\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true)); // no info is considered present since just about now\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false)); // not present yet, but leave date is gte -PT1M\n    }\n    @Test\n    public void testItShouldMatchPrefix() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"fo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"f\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"FOO\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchAny() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n    @Test\n    public void testItShouldMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n"]]}
{"hexsha": "c69772a5d8aa6e768a714070452503874640f029", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class WxMaServiceHttpClientImpl extends BaseWxMaServiceImpl {\n  private CloseableHttpClient httpClient;\n  private HttpHost httpProxy;\n\n  @Override\n  public void initHttp() {\n    WxMaConfig configStorage = this.getWxMaConfig();\n    ApacheHttpClientBuilder apacheHttpClientBuilder = configStorage.getApacheHttpClientBuilder();\n    if (null == apacheHttpClientBuilder) {\n      apacheHttpClientBuilder = DefaultApacheHttpClientBuilder.get();\n    }\n\n    apacheHttpClientBuilder.httpProxyHost(configStorage.getHttpProxyHost())\n      .httpProxyPort(configStorage.getHttpProxyPort())\n      .httpProxyUsername(configStorage.getHttpProxyUsername())\n      .httpProxyPassword(configStorage.getHttpProxyPassword());\n\n    if (configStorage.getHttpProxyHost() != null && configStorage.getHttpProxyPort() > 0) {\n      this.httpProxy = new HttpHost(configStorage.getHttpProxyHost(), configStorage.getHttpProxyPort());\n    }\n\n    this.httpClient = apacheHttpClientBuilder.build();\n  }\n\n  @Override\n  public CloseableHttpClient getRequestHttpClient() {\n    return httpClient;\n  }\n\n  @Override\n  public HttpHost getRequestHttpProxy() {\n    return httpProxy;\n  }\n\n  @Override\n  public HttpType getRequestType() {\n    return HttpType.APACHE_HTTP;\n  }\n\n  @Override\n  protected String doGetAccessTokenRequest() throws IOException {\n    String url = String.format(WxMaService.GET_ACCESS_TOKEN_URL, this.getWxMaConfig().getAppid(), this.getWxMaConfig().getSecret());\n\n    HttpGet httpGet = null;\n    CloseableHttpResponse response = null;\n    try {\n      httpGet = new HttpGet(url);\n      if (this.getRequestHttpProxy() != null) {\n        RequestConfig config = RequestConfig.custom().setProxy(this.getRequestHttpProxy()).build();\n        httpGet.setConfig(config);\n      }\n      response = getRequestHttpClient().execute(httpGet);\n      return new BasicResponseHandler().handleResponse(response);\n    } finally {\n      if (httpGet != null) {\n        httpGet.releaseConnection();\n      }\n      if (response != null) {\n        try {\n          response.close();\n        } catch (IOException e) {\n        }\n      }\n    }\n  }\n\n}", "class_id": 0, "repo": "hahahaha123567/WxJava", "file": "weixin-java-miniapp/src/main/java/cn/binarywang/wx/miniapp/api/impl/WxMaServiceHttpClientImpl.java", "last_update_at": "2021-01-14T03:49:59+00:00", "question_id": "c69772a5d8aa6e768a714070452503874640f029", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class WxMaServiceHttpClientImpl extends BaseWxMaServiceImpl {\n  private CloseableHttpClient httpClient;\n  private HttpHost httpProxy;\n  @Override\n  public void initHttp() {\n    WxMaConfig configStorage = this.getWxMaConfig();\n    ApacheHttpClientBuilder apacheHttpClientBuilder = configStorage.getApacheHttpClientBuilder();\n    if (null == apacheHttpClientBuilder) {\n      apacheHttpClientBuilder = DefaultApacheHttpClientBuilder.get();\n    }\n    apacheHttpClientBuilder.httpProxyHost(configStorage.getHttpProxyHost())\n      .httpProxyPort(configStorage.getHttpProxyPort())\n      .httpProxyUsername(configStorage.getHttpProxyUsername())\n      .httpProxyPassword(configStorage.getHttpProxyPassword());\n    if (configStorage.getHttpProxyHost() != null && configStorage.getHttpProxyPort() > 0) {\n      this.httpProxy = new HttpHost(configStorage.getHttpProxyHost(), configStorage.getHttpProxyPort());\n    }\n    this.httpClient = apacheHttpClientBuilder.build();\n  }\n  @Override\n  public CloseableHttpClient getRequestHttpClient() {\n    return httpClient;\n  }\n  @Override\n  public HttpHost getRequestHttpProxy() {\n    return httpProxy;\n  }\n  @Override\n  public HttpType getRequestType() {\n    return HttpType.APACHE_HTTP;\n  }\n  @Override\n  protected String doGetAccessTokenRequest() throws IOException {\n    String url = String.format(WxMaService.GET_ACCESS_TOKEN_URL, this.getWxMaConfig().getAppid(), this.getWxMaConfig().getSecret());\n    HttpGet httpGet = null;\n    CloseableHttpResponse response = null;\n    try {\n      httpGet = new HttpGet(url);\n      if (this.getRequestHttpProxy() != null) {\n        RequestConfig config = RequestConfig.custom().setProxy(this.getRequestHttpProxy()).build();\n        httpGet.setConfig(config);\n      }\n      response = getRequestHttpClient().execute(httpGet);\n      return new BasicResponseHandler().handleResponse(response);\n    } finally {\n      if (httpGet != null) {\n        httpGet.releaseConnection();\n      }\n      if (response != null) {\n        try {\n          response.close();\n        } catch (IOException e) {\n        }\n      }\n    }\n  }\n"]]}
{"hexsha": "33fbd2d8697786a75b675ce0f67d67aea1d4dc16", "ext": "java", "lang": "Java", "content": "public class SequenceValueGenerator extends AbstractSequenceValueProducer {\r\n    public static final int DEFAULT_RESERVE_AMOUNT = 100;\r\n    public static final int DEFAULT_INITIAL_VALUE = 1;\r\n    public static final int DEFAULT_INCREMENT = 1;\r\n\r\n    private final Repository mRepository;\r\n    private final Storage<StoredSequence> mStorage;\r\n    private final StoredSequence mStoredSequence;\r\n    private final int mIncrement;\r\n    private final int mReserveAmount;\r\n\r\n    private boolean mHasReservedValues;\r\n    private long mNextValue;\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist. The initial sequence value is one,\r\n     * and the increment is one.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name)\r\n        throws RepositoryException\r\n    {\r\n        this(repo, name, DEFAULT_INITIAL_VALUE, DEFAULT_INCREMENT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment)\r\n        throws RepositoryException\r\n    {\r\n        this(repo, name, initialValue, increment, DEFAULT_RESERVE_AMOUNT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     * @param reserveAmount amount of sequence values to reserve\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name,\r\n                                  long initialValue, int increment, int reserveAmount)\r\n        throws RepositoryException\r\n    {\r\n        if (repo == null || name == null || increment < 1 || reserveAmount < 1) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n\r\n        mRepository = repo;\r\n\r\n        mIncrement = increment;\r\n        mReserveAmount = reserveAmount;\r\n\r\n        mStorage = repo.storageFor(StoredSequence.class);\r\n\r\n        mStoredSequence = mStorage.prepare();\r\n        mStoredSequence.setName(name);\r\n\r\n        Transaction txn = repo.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            if (!mStoredSequence.tryLoad()) {\r\n                // Create a new sequence.\r\n\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n\r\n                // Try to transfer values from a deprecated sequence.\r\n                com.amazon.carbonado.spi.StoredSequence oldSequence;\r\n                try {\r\n                    oldSequence = repo\r\n                        .storageFor(com.amazon.carbonado.spi.StoredSequence.class).prepare();\r\n                    oldSequence.setName(name);\r\n                    if (oldSequence.tryLoad()) {\r\n                        mStoredSequence.setInitialValue(oldSequence.getInitialValue());\r\n                        mStoredSequence.setNextValue(oldSequence.getNextValue());\r\n                    } else {\r\n                        oldSequence = null;\r\n                    }\r\n                } catch (RepositoryException e) {\r\n                    // Okay, perhaps no old sequence.\r\n                    oldSequence = null;\r\n                }\r\n\r\n                if (mStoredSequence.tryInsert()) {\r\n                    if (oldSequence != null) {\r\n                        try {\r\n                            // Get rid of deprecated sequence.\r\n                            oldSequence.tryDelete();\r\n                        } catch (RepositoryException e) {\r\n                            // Oh well.\r\n                        }\r\n                    }\r\n                } else {\r\n                    // A race condition likely. Load again.\r\n                    mStoredSequence.load();\r\n                }\r\n            }\r\n            txn.commit();\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the sequence.\r\n     *\r\n     * @param initialValue first value produced by sequence\r\n     */\r\n    public void reset(int initialValue) throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            Transaction txn = mRepository.enterTopTransaction(null);\r\n            txn.setForUpdate(true);\r\n            try {\r\n                boolean doUpdate = mStoredSequence.tryLoad();\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n                if (doUpdate) {\r\n                    mStoredSequence.update();\r\n                } else {\r\n                    mStoredSequence.insert();\r\n                }\r\n                txn.commit();\r\n                mHasReservedValues = false;\r\n            } finally {\r\n                txn.exit();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is exhausted.\r\n     */\r\n    public long nextLongValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                return nextUnadjustedValue() + Long.MIN_VALUE + mStoredSequence.getInitialValue();\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is\r\n     * exhausted for int values.\r\n     */\r\n    @Override\r\n    public int nextIntValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                long initial = mStoredSequence.getInitialValue();\r\n                if (initial >= 0x100000000L) {\r\n                    throw new PersistException\r\n                        (\"Sequence initial value too large to support 32-bit ints: \" +\r\n                         mStoredSequence.getName() + \", initial: \" + initial);\r\n                }\r\n                long next = nextUnadjustedValue();\r\n                if (next >= Long.MIN_VALUE + 0x100000000L) {\r\n                    // Everytime we throw this exception, a long sequence value\r\n                    // has been lost. This seems fairly benign.\r\n                    throw new PersistException\r\n                        (\"Sequence exhausted for 32-bit ints: \" + mStoredSequence.getName() +\r\n                         \", next: \" + (next + Long.MIN_VALUE + initial));\r\n                }\r\n                return (int) (next + Long.MIN_VALUE + initial);\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allow any unused reserved values to be returned for re-use. If the\r\n     * repository is shared by other processes, then reserved values might not\r\n     * be returnable.\r\n     *\r\n     * <p>This method should be called during the shutdown process of a\r\n     * repository, although calling it does not invalidate this\r\n     * SequenceValueGenerator. If getNextValue is called again, it will reserve\r\n     * values again.\r\n     *\r\n     * @return true if reserved values were returned\r\n     */\r\n    public boolean returnReservedValues() throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            if (mHasReservedValues) {\r\n                Transaction txn = mRepository.enterTopTransaction(null);\r\n                txn.setForUpdate(true);\r\n                try {\r\n                    // Compare known StoredSequence with current persistent\r\n                    // one. If same, then reserved values can be returned.\r\n                    StoredSequence current = mStorage.prepare();\r\n                    current.setName(mStoredSequence.getName());\r\n                    if (current.tryLoad() && current.equals(mStoredSequence)) {\r\n                        mStoredSequence.setNextValue(mNextValue + mIncrement);\r\n                        mStoredSequence.update();\r\n                        txn.commit();\r\n                        mHasReservedValues = false;\r\n                        return true;\r\n                    }\r\n                } finally {\r\n                    txn.exit();\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Assumes caller has synchronized on mStoredSequence\r\n    private long nextUnadjustedValue() throws FetchException, PersistException {\r\n        if (mHasReservedValues) {\r\n            long next = mNextValue + mIncrement;\r\n            mNextValue = next;\r\n            if (next < mStoredSequence.getNextValue()) {\r\n                return next;\r\n            }\r\n            mHasReservedValues = false;\r\n        }\r\n\r\n        Transaction txn = mRepository.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            // Assume that StoredSequence is stale, so reload.\r\n            mStoredSequence.load();\r\n            long next = mStoredSequence.getNextValue();\r\n            long nextStored = next + mReserveAmount * mIncrement;\r\n\r\n            if (next >= 0 && nextStored < 0) {\r\n                // Wrapped around. There might be just a few values left.\r\n                long avail = (Long.MAX_VALUE - next) / mIncrement;\r\n                if (avail > 0) {\r\n                    nextStored = next + avail * mIncrement;\r\n                } else {\r\n                    // Throw a PersistException since sequences are applied during\r\n                    // insert operations, and inserts can only throw PersistExceptions.\r\n                    throw new PersistException\r\n                        (\"Sequence exhausted: \" + mStoredSequence.getName());\r\n                }\r\n            }\r\n\r\n            mStoredSequence.setNextValue(nextStored);\r\n            mStoredSequence.update();\r\n\r\n            txn.commit();\r\n\r\n            mNextValue = next;\r\n            mHasReservedValues = true;\r\n            return next;\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "jesterpm/Carbonado", "file": "src/main/java/com/amazon/carbonado/sequence/SequenceValueGenerator.java", "last_update_at": "2021-08-09T07:19:13+00:00", "question_id": "33fbd2d8697786a75b675ce0f67d67aea1d4dc16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SequenceValueGenerator extends AbstractSequenceValueProducer {\r\n    public static final int DEFAULT_RESERVE_AMOUNT = 100;\r\n    public static final int DEFAULT_INITIAL_VALUE = 1;\r\n    public static final int DEFAULT_INCREMENT = 1;\r\n\r\n    private final Repository mRepository;\r\n    private final Storage<StoredSequence> mStorage;\r\n    private final StoredSequence mStoredSequence;\r\n    private final int mIncrement;\r\n    private final int mReserveAmount;\r\n\r\n    private boolean mHasReservedValues;\r\n    private long mNextValue;\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist. The initial sequence value is one,\r\n     * and the increment is one.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name)\r\n        throws RepositoryException\r\n    {\r\n        this(repo, name, DEFAULT_INITIAL_VALUE, DEFAULT_INCREMENT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment)\r\n        throws RepositoryException\r\n    {\r\n        this(repo, name, initialValue, increment, DEFAULT_RESERVE_AMOUNT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     * @param reserveAmount amount of sequence values to reserve\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name,\r\n                                  long initialValue, int increment, int reserveAmount)\r\n        throws RepositoryException\r\n    {\r\n        if (repo == null || name == null || increment < 1 || reserveAmount < 1) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n\r\n        mRepository = repo;\r\n\r\n        mIncrement = increment;\r\n        mReserveAmount = reserveAmount;\r\n\r\n        mStorage = repo.storageFor(StoredSequence.class);\r\n\r\n        mStoredSequence = mStorage.prepare();\r\n        mStoredSequence.setName(name);\r\n\r\n        Transaction txn = repo.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            if (!mStoredSequence.tryLoad()) {\r\n                // Create a new sequence.\r\n\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n\r\n                // Try to transfer values from a deprecated sequence.\r\n                com.amazon.carbonado.spi.StoredSequence oldSequence;\r\n                try {\r\n                    oldSequence = repo\r\n                        .storageFor(com.amazon.carbonado.spi.StoredSequence.class).prepare();\r\n                    oldSequence.setName(name);\r\n                    if (oldSequence.tryLoad()) {\r\n                        mStoredSequence.setInitialValue(oldSequence.getInitialValue());\r\n                        mStoredSequence.setNextValue(oldSequence.getNextValue());\r\n                    } else {\r\n                        oldSequence = null;\r\n                    }\r\n                } catch (RepositoryException e) {\r\n                    // Okay, perhaps no old sequence.\r\n                    oldSequence = null;\r\n                }\r\n\r\n                if (mStoredSequence.tryInsert()) {\r\n                    if (oldSequence != null) {\r\n                        try {\r\n                            // Get rid of deprecated sequence.\r\n                            oldSequence.tryDelete();\r\n                        } catch (RepositoryException e) {\r\n                            // Oh well.\r\n                        }\r\n                    }\r\n                } else {\r\n                    // A race condition likely. Load again.\r\n                    mStoredSequence.load();\r\n                }\r\n            }\r\n            txn.commit();\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the sequence.\r\n     *\r\n     * @param initialValue first value produced by sequence\r\n     */\r\n    public void reset(int initialValue) throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            Transaction txn = mRepository.enterTopTransaction(null);\r\n            txn.setForUpdate(true);\r\n            try {\r\n                boolean doUpdate = mStoredSequence.tryLoad();\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n                if (doUpdate) {\r\n                    mStoredSequence.update();\r\n                } else {\r\n                    mStoredSequence.insert();\r\n                }\r\n                txn.commit();\r\n                mHasReservedValues = false;\r\n            } finally {\r\n                txn.exit();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is exhausted.\r\n     */\r\n    public long nextLongValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                return nextUnadjustedValue() + Long.MIN_VALUE + mStoredSequence.getInitialValue();\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is\r\n     * exhausted for int values.\r\n     */\r\n    @Override\r\n    public int nextIntValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                long initial = mStoredSequence.getInitialValue();\r\n                if (initial >= 0x100000000L) {\r\n                    throw new PersistException\r\n                        (\"Sequence initial value too large to support 32-bit ints: \" +\r\n                         mStoredSequence.getName() + \", initial: \" + initial);\r\n                }\r\n                long next = nextUnadjustedValue();\r\n                if (next >= Long.MIN_VALUE + 0x100000000L) {\r\n                    // Everytime we throw this exception, a long sequence value\r\n                    // has been lost. This seems fairly benign.\r\n                    throw new PersistException\r\n                        (\"Sequence exhausted for 32-bit ints: \" + mStoredSequence.getName() +\r\n                         \", next: \" + (next + Long.MIN_VALUE + initial));\r\n                }\r\n                return (int) (next + Long.MIN_VALUE + initial);\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allow any unused reserved values to be returned for re-use. If the\r\n     * repository is shared by other processes, then reserved values might not\r\n     * be returnable.\r\n     *\r\n     * <p>This method should be called during the shutdown process of a\r\n     * repository, although calling it does not invalidate this\r\n     * SequenceValueGenerator. If getNextValue is called again, it will reserve\r\n     * values again.\r\n     *\r\n     * @return true if reserved values were returned\r\n     */\r\n    public boolean returnReservedValues() throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            if (mHasReservedValues) {\r\n                Transaction txn = mRepository.enterTopTransaction(null);\r\n                txn.setForUpdate(true);\r\n                try {\r\n                    // Compare known StoredSequence with current persistent\r\n                    // one. If same, then reserved values can be returned.\r\n                    StoredSequence current = mStorage.prepare();\r\n                    current.setName(mStoredSequence.getName());\r\n                    if (current.tryLoad() && current.equals(mStoredSequence)) {\r\n                        mStoredSequence.setNextValue(mNextValue + mIncrement);\r\n                        mStoredSequence.update();\r\n                        txn.commit();\r\n                        mHasReservedValues = false;\r\n                        return true;\r\n                    }\r\n                } finally {\r\n                    txn.exit();\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Assumes caller has synchronized on mStoredSequence\r\n    private long nextUnadjustedValue() throws FetchException, PersistException {\r\n        if (mHasReservedValues) {\r\n            long next = mNextValue + mIncrement;\r\n            mNextValue = next;\r\n            if (next < mStoredSequence.getNextValue()) {\r\n                return next;\r\n            }\r\n            mHasReservedValues = false;\r\n        }\r\n\r\n        Transaction txn = mRepository.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            // Assume that StoredSequence is stale, so reload.\r\n            mStoredSequence.load();\r\n            long next = mStoredSequence.getNextValue();\r\n            long nextStored = next + mReserveAmount * mIncrement;\r\n\r\n            if (next >= 0 && nextStored < 0) {\r\n                // Wrapped around. There might be just a few values left.\r\n                long avail = (Long.MAX_VALUE - next) / mIncrement;\r\n                if (avail > 0) {\r\n                    nextStored = next + avail * mIncrement;\r\n                } else {\r\n                    // Throw a PersistException since sequences are applied during\r\n                    // insert operations, and inserts can only throw PersistExceptions.\r\n                    throw new PersistException\r\n                        (\"Sequence exhausted: \" + mStoredSequence.getName());\r\n                }\r\n            }\r\n\r\n            mStoredSequence.setNextValue(nextStored);\r\n            mStoredSequence.update();\r\n\r\n            txn.commit();\r\n\r\n            mNextValue = next;\r\n            mHasReservedValues = true;\r\n            return next;\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n"]]}
{"hexsha": "2b46d2e3610792acb1ccf25a6d577dfc0881f980", "ext": "java", "lang": "Java", "content": "public class URLClassLoader extends SecureClassLoader{\n\n  URL [] urls;\n  ClassLoaderURLHandler[] handlers;\n\n  private static boolean verbose = false;\n\n  private static void debug(String s) {\n    if (verbose) {\n      System.err.println(s);\n    }\n  }\n\n  private static final Manifest emptyMan = new Manifest();\n\n  private static void permissionCheck() {\n    // Note: we assume that java.net is a restricted package.\n    if (wonka.vm.SecurityConfiguration.ENABLE_SECURITY_CHECKS) {\n      SecurityManager sm = System.getSecurityManager();\n      if (sm != null) {\n        sm.checkPackageAccess(\"java.net\");\n      }\n    }\n  }\n\n  public URLClassLoader(URL[] urls) throws SecurityException {\n    debug(\"Loading: create URL handlers for \" + this);\n    handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n    this.urls = urls;\n  }\n\n  public URLClassLoader(URL[] urls, ClassLoader parent) throws SecurityException {\n    super(parent);\n    debug(\"Loading: create URL handlers for \" + this);\n    handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n    this.urls = urls;\n  }\n\n  public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) throws SecurityException {\n    super(parent);\n    debug(\"Loading: create URL handlers for \" + this);\n    handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n    this.urls = urls;\n  }\n\n  public static URLClassLoader newInstance(final URL[] urls) throws SecurityException{\n    permissionCheck();\n    //TODO: do as a privileged action\n    return new URLClassLoader(urls);\n  }\n\n  public static URLClassLoader newInstance(final URL[] urls, ClassLoader parent) throws SecurityException{\n    permissionCheck();\n    //TODO: do as a privileged action\n    return new URLClassLoader(urls, parent);\n  }\n\n  protected void addURL(URL url){\n    debug(\"Loading: add URL handler to \" + this);\n    ClassLoaderURLHandler handler = ClassLoaderURLHandler.createClassLoaderURLHandler(url);\n    debug(\"Loading: new URL handler = \" + handler);\n    int length = handlers.length;\n    ClassLoaderURLHandler[] newhandlers = new ClassLoaderURLHandler[length+1];\n    System.arraycopy(handlers, 0, newhandlers, 0, length);\n    newhandlers[length] = handler;\n    handlers = newhandlers;\n    URL[] newurls = new URL[urls.length+1];\n    System.arraycopy(urls, 0, newurls, 0, urls.length);\n    newurls[urls.length] = url;\n    urls = newurls;\n  }\n\n  protected Package definePackage(String pname, Manifest man, URL url) throws IllegalArgumentException {\n    Attributes attr = man.getMainAttributes();\n    String specTitle = attr.getValue(\"Specification-Title\");\n    String specVersion  = attr.getValue(\"Specification-Version\");\n    String specVendor = attr.getValue(\"Specification-Vendor\");\n    String implTitle  = attr.getValue(\"Implementation-Title\");\n    String implVersion  = attr.getValue(\"Implementation-Version\");\n    String implVendor   = attr.getValue(\"Implementation-Vendor\");\n    return definePackage(pname, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, url);\n  }\n\n  protected Class findClass(String name) throws ClassNotFoundException {\n    String filename = name.replace('.','/') + \".class\";\n    int l = handlers.length;\n    for(int i = 0 ; i < l ; i++){\n      ClassLoaderURLHandler handler = handlers[i];\n      byte[] bytes = handler.getByteArray(filename);\n      if(bytes != null){\n        URL url = urls[i];\n        int idx = name.lastIndexOf('.');\n        String pname = name.substring(0,idx == -1 ? 0 : idx);\n\n        // TODO: get manifest right\n        if (getPackage(pname) == null){\n          definePackage(pname, handler.getManifest() , url);\n        }\n        if(url.getProtocol().equals(\"jar\")) {\n          String u = (\"\" + url).substring(4);\n          u = u.substring(0, u.indexOf('!'));\n          try {\n            url = new URL(u);\n          }\n          catch(Exception e) {\n          }\n        }\n        return defineClass(name, bytes, 0, bytes.length, new CodeSource(url, (java.security.cert.Certificate[])null));\n      }\n    }\n    throw new ClassNotFoundException(name);\n  }\n\n  public URL findResource(String name){\n    int l = handlers.length;\n    for(int i = 0 ; i < l ; i++){\n      ClassLoaderURLHandler handler = handlers[i];\n\n      URL url = handler.getURL(name);\n      if(url != null){\n        return url;\n      }\n    }\n    return null;\n  }\n\n  public Enumeration findResources(String name) throws IOException{\n  // TODO; wasn't there something about leading slash?\n    int l = handlers.length;\n    Vector v = new Vector(l);\n    for(int i = 0 ; i < l ; i++){\n      ClassLoaderURLHandler handler = handlers[i];\n\n      URL url = handler.getURL(name);\n      if(url != null){\n        v.add(url);\n      }\n    }\n    return v.elements();\n  }\n\n  protected PermissionCollection getPermissions(CodeSource codes){\n        PermissionCollection pc = super.getPermissions(codes);\n        //ToDo add extra permissions to allow usage of the URL's\n        return pc;\n  }\n\n/**\n** returns a clone of the original URL array (for securiry reasons).\n*/\n  public URL[] getURLs(){\n    return (URL[])urls.clone();\n  }\n\n}", "class_id": 0, "repo": "kifferltd/open-mika", "file": "core-vm/java/java/net/URLClassLoader.java", "last_update_at": "2021-11-28T20:18:59+00:00", "question_id": "2b46d2e3610792acb1ccf25a6d577dfc0881f980", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class URLClassLoader extends SecureClassLoader{\n  URL [] urls;\n  ClassLoaderURLHandler[] handlers;\n  private static boolean verbose = false;\n  private static void debug(String s) {\n    if (verbose) {\n      System.err.println(s);\n    }\n  }\n  private static final Manifest emptyMan = new Manifest();\n  private static void permissionCheck() {\n    // Note: we assume that java.net is a restricted package.\n    if (wonka.vm.SecurityConfiguration.ENABLE_SECURITY_CHECKS) {\n      SecurityManager sm = System.getSecurityManager();\n      if (sm != null) {\n        sm.checkPackageAccess(\"java.net\");\n      }\n    }\n  }\n  public URLClassLoader(URL[] urls) throws SecurityException {\n    debug(\"Loading: create URL handlers for \" + this);\n    handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n    this.urls = urls;\n  }\n  public URLClassLoader(URL[] urls, ClassLoader parent) throws SecurityException {\n    super(parent);\n    debug(\"Loading: create URL handlers for \" + this);\n    handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n    this.urls = urls;\n  }\n  public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) throws SecurityException {\n    super(parent);\n    debug(\"Loading: create URL handlers for \" + this);\n    handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n    this.urls = urls;\n  }\n  public static URLClassLoader newInstance(final URL[] urls) throws SecurityException{\n    permissionCheck();\n    //TODO: do as a privileged action\n    return new URLClassLoader(urls);\n  }\n  public static URLClassLoader newInstance(final URL[] urls, ClassLoader parent) throws SecurityException{\n    permissionCheck();\n    //TODO: do as a privileged action\n    return new URLClassLoader(urls, parent);\n  }\n  protected void addURL(URL url){\n    debug(\"Loading: add URL handler to \" + this);\n    ClassLoaderURLHandler handler = ClassLoaderURLHandler.createClassLoaderURLHandler(url);\n    debug(\"Loading: new URL handler = \" + handler);\n    int length = handlers.length;\n    ClassLoaderURLHandler[] newhandlers = new ClassLoaderURLHandler[length+1];\n    System.arraycopy(handlers, 0, newhandlers, 0, length);\n    newhandlers[length] = handler;\n    handlers = newhandlers;\n    URL[] newurls = new URL[urls.length+1];\n    System.arraycopy(urls, 0, newurls, 0, urls.length);\n    newurls[urls.length] = url;\n    urls = newurls;\n  }\n  protected Package definePackage(String pname, Manifest man, URL url) throws IllegalArgumentException {\n    Attributes attr = man.getMainAttributes();\n    String specTitle = attr.getValue(\"Specification-Title\");\n    String specVersion  = attr.getValue(\"Specification-Version\");\n    String specVendor = attr.getValue(\"Specification-Vendor\");\n    String implTitle  = attr.getValue(\"Implementation-Title\");\n    String implVersion  = attr.getValue(\"Implementation-Version\");\n    String implVendor   = attr.getValue(\"Implementation-Vendor\");\n    return definePackage(pname, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, url);\n  }\n  protected Class findClass(String name) throws ClassNotFoundException {\n    String filename = name.replace('.','/') + \".class\";\n    int l = handlers.length;\n    for(int i = 0 ; i < l ; i++){\n      ClassLoaderURLHandler handler = handlers[i];\n      byte[] bytes = handler.getByteArray(filename);\n      if(bytes != null){\n        URL url = urls[i];\n        int idx = name.lastIndexOf('.');\n        String pname = name.substring(0,idx == -1 ? 0 : idx);\n        // TODO: get manifest right\n        if (getPackage(pname) == null){\n          definePackage(pname, handler.getManifest() , url);\n        }\n        if(url.getProtocol().equals(\"jar\")) {\n          String u = (\"\" + url).substring(4);\n          u = u.substring(0, u.indexOf('!'));\n          try {\n            url = new URL(u);\n          }\n          catch(Exception e) {\n          }\n        }\n        return defineClass(name, bytes, 0, bytes.length, new CodeSource(url, (java.security.cert.Certificate[])null));\n      }\n    }\n    throw new ClassNotFoundException(name);\n  }\n  public URL findResource(String name){\n    int l = handlers.length;\n    for(int i = 0 ; i < l ; i++){\n      ClassLoaderURLHandler handler = handlers[i];\n      URL url = handler.getURL(name);\n      if(url != null){\n        return url;\n      }\n    }\n    return null;\n  }\n  public Enumeration findResources(String name) throws IOException{\n  // TODO; wasn't there something about leading slash?\n    int l = handlers.length;\n    Vector v = new Vector(l);\n    for(int i = 0 ; i < l ; i++){\n      ClassLoaderURLHandler handler = handlers[i];\n      URL url = handler.getURL(name);\n      if(url != null){\n        v.add(url);\n      }\n    }\n    return v.elements();\n  }\n  protected PermissionCollection getPermissions(CodeSource codes){\n        PermissionCollection pc = super.getPermissions(codes);\n        //ToDo add extra permissions to allow usage of the URL's\n        return pc;\n  }\n/**\n** returns a clone of the original URL array (for securiry reasons).\n*/\n  public URL[] getURLs(){\n    return (URL[])urls.clone();\n  }\n"]]}
{"hexsha": "226b487adf17fcdc413f042460759648247259d6", "ext": "java", "lang": "Java", "content": "public class PC2LogViewer extends PC2Console {\r\n\r\n\tpublic PC2LogViewer(JScrollPane scroll, PC2TextPane pane) {\r\n\t\tsuper(scroll, pane);\r\n\t\tpane.wrapText = false;\r\n\t}\r\n\t\r\n\tpublic void appendLog(String s) throws IllegalArgumentException {\r\n\t\tboolean error = false;\r\n\t\tboolean fatal = false;\r\n\t\tboolean warn = false;\r\n\t\tboolean info = false;\r\n\t\tboolean debug = false;\r\n\t\tboolean trace = false;\r\n\t\tif (s != null) {\r\n\t\t\tif (s.length() >= 29) {\r\n\r\n\t\t\t\tString level = s.substring(24,29);\r\n\t\t\t\tif (level.equals(\"DEBUG\"))\r\n\t\t\t\t\tdebug = true;\r\n\t\t\t\telse if (level.equals(\"INFO \")) \r\n\t\t\t\t\tinfo = true;\r\n\t\t\t\telse if (level.equals(\"WARN \")) \r\n\t\t\t\t\twarn = true;\r\n\t\t\t\telse if (level.equals(\"ERROR\")) \r\n\t\t\t\t\terror = true;\r\n\t\t\t\telse if (level.equals(\"TRACE\")) \r\n\t\t\t\t\ttrace = true;\r\n\t\t\t\telse if (level.equals(\"FATAL\")) \r\n\t\t\t\t\tfatal = true;\r\n\t\t\t\tif (fatal) \r\n\t\t\t\t\ttextPane.append(s, FATAL, RED);\r\n\t\t\t\telse if (error) {\r\n\t\t\t\t\tif (s.contains(\"ERROR  VERIFY FAILED\"))\r\n\t\t\t\t\t\ttextPane.append(s, VERIFY, RED);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, ERROR, RED);\r\n\t\t\t\t}\r\n\t\t\t\telse if (info){\r\n\t\t\t\t\tif (s.contains(\">>>>> RX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"<<<<< TX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, ORANGE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO   USER:\"))\r\n\t\t\t\t\t\ttextPane.append(s, PROMPT, BLUE);\r\n\t\t\t\t\telse if (s.contains(\"INFO  Test \")) {\r\n\t\t\t\t\t\tif (s.contains(\"Passed.\"))\r\n\t\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t\telse if (s.contains(\"Failed.\"))\r\n\t\t\t\t\t\t\tappendFailedTestResults(s);\r\n\t\t\t\t\t\t// textPane.append(s, FATAL, RED);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO  Commencing test\")) {\r\n\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO  VERIFY PASSED\")) \r\n\t\t\t\t\t\t\ttextPane.append(s, VERIFY, BLUE);\r\n\t\t\t\t\t\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (warn)\r\n\t\t\t\t\ttextPane.append(s, WARN, DK_YELLOW);\r\n\t\t\t\telse if (debug)\r\n\t\t\t\t\ttextPane.append(s, DEBUG, DK_GRAY);\r\n\t\t\t\telse if (trace)\r\n\t\t\t\t\ttextPane.append(s, TRACE, GRAY);\r\n\t\t\t\telse\r\n\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow new IllegalArgumentException(\"LogViewer doesn't allow a null string for an argument.\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tpublic void appendConsole(String s) throws IllegalArgumentException {\r\n\t\tboolean error = false;\r\n\t\tboolean fatal = false;\r\n\t\tboolean warn = false;\r\n\t\tboolean info = false;\r\n\t\tboolean debug = false;\r\n\t\tboolean trace = false;\r\n\t\tif (s != null) {\r\n\t\t\tif (s.length() >= 5) {\r\n\r\n\t\t\t\tString level = s.substring(0,5);\r\n\r\n\t\t\t\tif (level.equals(\"DEBUG\"))\r\n\t\t\t\t\tdebug = true;\r\n\t\t\t\telse if (level.equals(\"INFO \")) \r\n\t\t\t\t\tinfo = true;\r\n\t\t\t\telse if (level.equals(\"WARN \")) \r\n\t\t\t\t\twarn = true;\r\n\t\t\t\telse if (level.equals(\"ERROR\")) \r\n\t\t\t\t\terror = true;\r\n\t\t\t\telse if (level.equals(\"TRACE\")) \r\n\t\t\t\t\ttrace = true;\r\n\t\t\t\telse if (level.equals(\"FATAL\")) \r\n\t\t\t\t\tfatal = true;\r\n\r\n\r\n\t\t\t\tif (fatal) \r\n\t\t\t\t\ttextPane.append(s, FATAL, RED);\r\n\t\t\t\telse if (error)\t{ \r\n\t\t\t\t\tif (s.contains(\"ERROR  VERIFY FAILED\"))\r\n\r\n\t\t\t\t\t\ttextPane.append(s, VERIFY, RED);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, ERROR, RED);\r\n\t\t\t\t}\r\n\t\t\t\telse if (info) {\r\n\t\t\t\t\tif (s.startsWith(\"INFO  >>>>> RX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  <<<<< TX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, ORANGE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO   USER:\"))\r\n\t\t\t\t\t\ttextPane.append(s, PROMPT, BLUE);\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  Test \")) {\r\n\t\t\t\t\t\tif (s.contains(\"Passed.\"))\r\n\t\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t\telse if (s.contains(\"Failed.\"))\r\n\t\t\t\t\t\t\tappendFailedTestResults(s);\r\n\t\t\t\t\t\t//\ttextPane.append(s, FATAL, RED);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  Commencing test\")) {\r\n\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  \\n\\tVendor: \")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, BLUE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO  VERIFY PASSED\")) \r\n\t\t\t\t\t\ttextPane.append(s, VERIFY, BLUE);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (warn)\r\n\t\t\t\t\ttextPane.append(s, WARN, DK_YELLOW);\r\n\t\t\t\telse if (debug)\r\n\t\t\t\t\ttextPane.append(s, DEBUG, DK_GRAY);\r\n\t\t\t\telse if (trace)\r\n\t\t\t\t\ttextPane.append(s, TRACE, GRAY);\r\n\t\t\t\telse\r\n\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void appendFailedTestResults(String s) {\r\n\t\t// For failures we are going to display part of the text\r\n\t\t// red and partially in green if any of the requirements\r\n\t\t// passed.\r\n\t\tStringTokenizer st = new StringTokenizer(s, \"\\n\");\r\n\t\twhile (st.hasMoreTokens()) {\r\n\t\t\tString temp = st.nextToken();\r\n\t\t\tif (temp.contains(\"Passed\"))\r\n\t\t\t\ttextPane.append((temp+\"\\n\"), FATAL, GREEN);\r\n\t\t\telse\r\n\t\t\t\ttextPane.append((temp+\"\\n\"), FATAL, RED);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic boolean isConsoleLog(String msg) {\r\n\t\tif (msg.startsWith(\"DEBUG \") || \r\n\t\t\t\tmsg.startsWith(\"INFO \") || \r\n\t\t\t\tmsg.startsWith(\"WARN \") ||\r\n\t\t\t\tmsg.startsWith(\"ERROR \") ||\r\n\t\t\t\tmsg.startsWith(\"TRACE \") || \r\n\t\t\t\tmsg.startsWith(\"FATAL \")) \r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n}", "class_id": 0, "repo": "tinours/PCSim2", "file": "src/com/cablelabs/gui/PC2LogViewer.java", "last_update_at": "2021-04-30T18:47:15+00:00", "question_id": "226b487adf17fcdc413f042460759648247259d6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PC2LogViewer extends PC2Console {\r\n\r\n\tpublic PC2LogViewer(JScrollPane scroll, PC2TextPane pane) {\r\n\t\tsuper(scroll, pane);\r\n\t\tpane.wrapText = false;\r\n\t}\r\n\t\r\n\tpublic void appendLog(String s) throws IllegalArgumentException {\r\n\t\tboolean error = false;\r\n\t\tboolean fatal = false;\r\n\t\tboolean warn = false;\r\n\t\tboolean info = false;\r\n\t\tboolean debug = false;\r\n\t\tboolean trace = false;\r\n\t\tif (s != null) {\r\n\t\t\tif (s.length() >= 29) {\r\n\r\n\t\t\t\tString level = s.substring(24,29);\r\n\t\t\t\tif (level.equals(\"DEBUG\"))\r\n\t\t\t\t\tdebug = true;\r\n\t\t\t\telse if (level.equals(\"INFO \")) \r\n\t\t\t\t\tinfo = true;\r\n\t\t\t\telse if (level.equals(\"WARN \")) \r\n\t\t\t\t\twarn = true;\r\n\t\t\t\telse if (level.equals(\"ERROR\")) \r\n\t\t\t\t\terror = true;\r\n\t\t\t\telse if (level.equals(\"TRACE\")) \r\n\t\t\t\t\ttrace = true;\r\n\t\t\t\telse if (level.equals(\"FATAL\")) \r\n\t\t\t\t\tfatal = true;\r\n\t\t\t\tif (fatal) \r\n\t\t\t\t\ttextPane.append(s, FATAL, RED);\r\n\t\t\t\telse if (error) {\r\n\t\t\t\t\tif (s.contains(\"ERROR  VERIFY FAILED\"))\r\n\t\t\t\t\t\ttextPane.append(s, VERIFY, RED);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, ERROR, RED);\r\n\t\t\t\t}\r\n\t\t\t\telse if (info){\r\n\t\t\t\t\tif (s.contains(\">>>>> RX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"<<<<< TX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, ORANGE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO   USER:\"))\r\n\t\t\t\t\t\ttextPane.append(s, PROMPT, BLUE);\r\n\t\t\t\t\telse if (s.contains(\"INFO  Test \")) {\r\n\t\t\t\t\t\tif (s.contains(\"Passed.\"))\r\n\t\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t\telse if (s.contains(\"Failed.\"))\r\n\t\t\t\t\t\t\tappendFailedTestResults(s);\r\n\t\t\t\t\t\t// textPane.append(s, FATAL, RED);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO  Commencing test\")) {\r\n\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO  VERIFY PASSED\")) \r\n\t\t\t\t\t\t\ttextPane.append(s, VERIFY, BLUE);\r\n\t\t\t\t\t\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (warn)\r\n\t\t\t\t\ttextPane.append(s, WARN, DK_YELLOW);\r\n\t\t\t\telse if (debug)\r\n\t\t\t\t\ttextPane.append(s, DEBUG, DK_GRAY);\r\n\t\t\t\telse if (trace)\r\n\t\t\t\t\ttextPane.append(s, TRACE, GRAY);\r\n\t\t\t\telse\r\n\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow new IllegalArgumentException(\"LogViewer doesn't allow a null string for an argument.\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tpublic void appendConsole(String s) throws IllegalArgumentException {\r\n\t\tboolean error = false;\r\n\t\tboolean fatal = false;\r\n\t\tboolean warn = false;\r\n\t\tboolean info = false;\r\n\t\tboolean debug = false;\r\n\t\tboolean trace = false;\r\n\t\tif (s != null) {\r\n\t\t\tif (s.length() >= 5) {\r\n\r\n\t\t\t\tString level = s.substring(0,5);\r\n\r\n\t\t\t\tif (level.equals(\"DEBUG\"))\r\n\t\t\t\t\tdebug = true;\r\n\t\t\t\telse if (level.equals(\"INFO \")) \r\n\t\t\t\t\tinfo = true;\r\n\t\t\t\telse if (level.equals(\"WARN \")) \r\n\t\t\t\t\twarn = true;\r\n\t\t\t\telse if (level.equals(\"ERROR\")) \r\n\t\t\t\t\terror = true;\r\n\t\t\t\telse if (level.equals(\"TRACE\")) \r\n\t\t\t\t\ttrace = true;\r\n\t\t\t\telse if (level.equals(\"FATAL\")) \r\n\t\t\t\t\tfatal = true;\r\n\r\n\r\n\t\t\t\tif (fatal) \r\n\t\t\t\t\ttextPane.append(s, FATAL, RED);\r\n\t\t\t\telse if (error)\t{ \r\n\t\t\t\t\tif (s.contains(\"ERROR  VERIFY FAILED\"))\r\n\r\n\t\t\t\t\t\ttextPane.append(s, VERIFY, RED);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, ERROR, RED);\r\n\t\t\t\t}\r\n\t\t\t\telse if (info) {\r\n\t\t\t\t\tif (s.startsWith(\"INFO  >>>>> RX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  <<<<< TX:\")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, ORANGE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO   USER:\"))\r\n\t\t\t\t\t\ttextPane.append(s, PROMPT, BLUE);\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  Test \")) {\r\n\t\t\t\t\t\tif (s.contains(\"Passed.\"))\r\n\t\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t\telse if (s.contains(\"Failed.\"))\r\n\t\t\t\t\t\t\tappendFailedTestResults(s);\r\n\t\t\t\t\t\t//\ttextPane.append(s, FATAL, RED);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  Commencing test\")) {\r\n\t\t\t\t\t\ttextPane.append(s, FATAL, GREEN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.startsWith(\"INFO  \\n\\tVendor: \")) {\r\n\t\t\t\t\t\ttextPane.append(s, MSG, BLUE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (s.contains(\"INFO  VERIFY PASSED\")) \r\n\t\t\t\t\t\ttextPane.append(s, VERIFY, BLUE);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (warn)\r\n\t\t\t\t\ttextPane.append(s, WARN, DK_YELLOW);\r\n\t\t\t\telse if (debug)\r\n\t\t\t\t\ttextPane.append(s, DEBUG, DK_GRAY);\r\n\t\t\t\telse if (trace)\r\n\t\t\t\t\ttextPane.append(s, TRACE, GRAY);\r\n\t\t\t\telse\r\n\t\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\ttextPane.append(s, INFO, NORMAL);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void appendFailedTestResults(String s) {\r\n\t\t// For failures we are going to display part of the text\r\n\t\t// red and partially in green if any of the requirements\r\n\t\t// passed.\r\n\t\tStringTokenizer st = new StringTokenizer(s, \"\\n\");\r\n\t\twhile (st.hasMoreTokens()) {\r\n\t\t\tString temp = st.nextToken();\r\n\t\t\tif (temp.contains(\"Passed\"))\r\n\t\t\t\ttextPane.append((temp+\"\\n\"), FATAL, GREEN);\r\n\t\t\telse\r\n\t\t\t\ttextPane.append((temp+\"\\n\"), FATAL, RED);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic boolean isConsoleLog(String msg) {\r\n\t\tif (msg.startsWith(\"DEBUG \") || \r\n\t\t\t\tmsg.startsWith(\"INFO \") || \r\n\t\t\t\tmsg.startsWith(\"WARN \") ||\r\n\t\t\t\tmsg.startsWith(\"ERROR \") ||\r\n\t\t\t\tmsg.startsWith(\"TRACE \") || \r\n\t\t\t\tmsg.startsWith(\"FATAL \")) \r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n"]]}
{"hexsha": "3e54953c33cebf7c63898e13b7923b8e6bea2173", "ext": "java", "lang": "Java", "content": "class DefinitionYamlParser<T> implements DefinitionParser<Map<String, Map<String, T>>> {\n\n    private final Yaml yaml;\n\n    private DefinitionYamlParser() {\n        yaml = new Yaml();\n    }\n\n    public static <T> DefinitionParser<Map<String, Map<String, T>>> of() {\n        return new DefinitionYamlParser<>();\n    }\n\n    @Override\n    public Map<String, Map<String, T>> parse(InputStream in) {\n        Iterable<Object> iterableYaml = yaml.loadAll(in);\n        Iterator<Object> iterator = iterableYaml.iterator();\n        return (Map<String, Map<String, T>>) iterator.next();\n    }\n}", "class_id": 0, "repo": "wolfmanfp/fackito", "file": "src/main/java/com/fackito/definition/parser/yaml/DefinitionYamlParser.java", "last_update_at": "2021-11-30T11:51:19+00:00", "question_id": "3e54953c33cebf7c63898e13b7923b8e6bea2173", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DefinitionYamlParser<T> implements DefinitionParser<Map<String, Map<String, T>>> {\n    private final Yaml yaml;\n    private DefinitionYamlParser() {\n        yaml = new Yaml();\n    }\n    public static <T> DefinitionParser<Map<String, Map<String, T>>> of() {\n        return new DefinitionYamlParser<>();\n    }\n    @Override\n    public Map<String, Map<String, T>> parse(InputStream in) {\n        Iterable<Object> iterableYaml = yaml.loadAll(in);\n        Iterator<Object> iterator = iterableYaml.iterator();\n        return (Map<String, Map<String, T>>) iterator.next();\n    }\n"]]}
{"hexsha": "be1bff23924fd033faba7e753f5dc995c667f3c0", "ext": "java", "lang": "Java", "content": "class ThreadLocalVersionHolderTest {\r\n\r\n    private final Version version = Version.of(1324, 5);\r\n\r\n    private final Version localVersion = Version.of(345465, 435);\r\n\r\n    @Test\r\n    void testGetVersionInSameThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n\r\n        assertEquals(version, ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInSameThreadWhenNotInitialized() {\r\n        assertEquals(Version.empty(), ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInAnotherThreadWhenInitializedInsideThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n\r\n        CompletableFuture.runAsync(() -> {\r\n            ThreadLocalVersionHolder.initialize(localVersion);\r\n            assertEquals(localVersion, ThreadLocalVersionHolder.get().getVersion());\r\n        }).join();\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionWhenSwitched() {\r\n        Version first = Version.of(123, 123);\r\n        Version second = Version.of(546546, 1);\r\n\r\n        VersionHolder versionHolder = ThreadLocalVersionHolder.get();\r\n\r\n        ThreadLocalVersionHolder.initialize(first);\r\n        assertEquals(first, versionHolder.getVersion());\r\n\r\n        ThreadLocalVersionHolder.initialize(second);\r\n        assertEquals(second, versionHolder.getVersion());\r\n    }\r\n}", "class_id": 0, "repo": "liveisgood8/jackson-versioning-module", "file": "core/src/test/java/io/github/liveisgood8/jacksonversioning/holder/ThreadLocalVersionHolderTest.java", "last_update_at": "2021-11-03T16:43:23+00:00", "question_id": "be1bff23924fd033faba7e753f5dc995c667f3c0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class ThreadLocalVersionHolderTest {\r\n\r\n    private final Version version = Version.of(1324, 5);\r\n\r\n    private final Version localVersion = Version.of(345465, 435);\r\n\r\n    @Test\r\n    void testGetVersionInSameThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n\r\n        assertEquals(version, ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInSameThreadWhenNotInitialized() {\r\n        assertEquals(Version.empty(), ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInAnotherThreadWhenInitializedInsideThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n\r\n        CompletableFuture.runAsync(() -> {\r\n            ThreadLocalVersionHolder.initialize(localVersion);\r\n            assertEquals(localVersion, ThreadLocalVersionHolder.get().getVersion());\r\n        }).join();\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionWhenSwitched() {\r\n        Version first = Version.of(123, 123);\r\n        Version second = Version.of(546546, 1);\r\n\r\n        VersionHolder versionHolder = ThreadLocalVersionHolder.get();\r\n\r\n        ThreadLocalVersionHolder.initialize(first);\r\n        assertEquals(first, versionHolder.getVersion());\r\n\r\n        ThreadLocalVersionHolder.initialize(second);\r\n        assertEquals(second, versionHolder.getVersion());\r\n    }\r\n"]]}
{"hexsha": "c97f14a7bf5ef3debf95529c86f3c6c29665f8e0", "ext": "java", "lang": "Java", "content": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tLinkedList<Integer> linkedList = new LinkedList<Integer>();\n\t\tlinkedList.add(3);\n\t\tlinkedList.add(8);\n\t\tSystem.out.println(\"Integer linked list content: \" + linkedList);\n\n\t\tLinkedList<String> linkedList2 = new LinkedList<String>();\n\t\tlinkedList2.add(\"foo\");\n\t\tlinkedList2.add(\"bar\");\n\t\tlinkedList2.add(\"baz\");\n\t\tlinkedList2.add(\"qux\");\n\t\tSystem.out.println(\"String linked list content: \" + linkedList2);\n\n\t\ttry {\n\t\t\tSystem.out.println(\"The second String contains \" + linkedList2.get(1).length() + \" letters.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage());\n\t\t}\n\n\t\tif (linkedList2.contains(\"baz\")) {\n\t\t\tSystem.out.println(\"The String linked list contains the word 'baz'.\");\n\t\t}\n\n\t\tif (!linkedList2.contains(\"quux\")) {\n\t\t\tSystem.out.println(\"The String linked list does not contain the word 'quux'.\");\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "vscav/java-lab", "file": "TD09/src/fr/umlv/data/main/Main.java", "last_update_at": "2021-02-27T20:20:38+00:00", "question_id": "c97f14a7bf5ef3debf95529c86f3c6c29665f8e0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Main {\n\tpublic static void main(String[] args) {\n\t\tLinkedList<Integer> linkedList = new LinkedList<Integer>();\n\t\tlinkedList.add(3);\n\t\tlinkedList.add(8);\n\t\tSystem.out.println(\"Integer linked list content: \" + linkedList);\n\t\tLinkedList<String> linkedList2 = new LinkedList<String>();\n\t\tlinkedList2.add(\"foo\");\n\t\tlinkedList2.add(\"bar\");\n\t\tlinkedList2.add(\"baz\");\n\t\tlinkedList2.add(\"qux\");\n\t\tSystem.out.println(\"String linked list content: \" + linkedList2);\n\t\ttry {\n\t\t\tSystem.out.println(\"The second String contains \" + linkedList2.get(1).length() + \" letters.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage());\n\t\t}\n\t\tif (linkedList2.contains(\"baz\")) {\n\t\t\tSystem.out.println(\"The String linked list contains the word 'baz'.\");\n\t\t}\n\t\tif (!linkedList2.contains(\"quux\")) {\n\t\t\tSystem.out.println(\"The String linked list does not contain the word 'quux'.\");\n\t\t}\n\t}\n"]]}
{"hexsha": "fe59e73e25558d873a94e9fc5c1225b2bb48a8de", "ext": "java", "lang": "Java", "content": "public class WheelOfFortune extends SubsystemBase {\n\n    //Create necessary objects\n    private static ColorSensorV3 m_colorSensor;\n    private static WPI_VictorSPX m_spinWheel;\n    private static Solenoid m_wheelArm;\n\n    //Create and define all standard data types needed\n//    private SuppliedValueWidget colorWidget =\n//            Shuffleboard.getTab(\"Kyber\").addBoolean(\"Wheel Color\", () -> true);\n\n    private Map<String, String> fieldToTargetColorMap = new HashMap<String, String>();\n\n    private double lastTimestamp;\n    private boolean isChanged;\n    private boolean isCounted;\n\n    private String actualColor;\n\n    private float deg = 0;\n    private float sat = 0;\n    private float brightness = 0;\n\n    private Thread interrogator;\n    private int cachedR = 0;\n    private int cachedG = 0;\n    private int cachedB = 0;\n\n    private class InterrogationLoop implements Runnable {\n\t\tpublic void run() {\n\t\t\ttry {\n                // These three operations can run away waiting for i2c synchronization\n                int r = m_colorSensor.getRed();\n                int g = m_colorSensor.getGreen();\n                int b = m_colorSensor.getBlue();\n                // Now as we are back we can update the cache at once\n                cachedR = r;\n                cachedG = g;\n                cachedB = b;\n\t\t\t\tThread.sleep(20);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tDriverStation.reportError(\n\t\t\t\t\t\t\"Thread \"+Thread.currentThread().getName()+\" got interrupted\",\n\t\t\t\t\t\ttrue);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n    private static final WheelOfFortune instance = new WheelOfFortune();\n\n    public static WheelOfFortune getInstance() {\n        return instance;\n    }\n\n    private WheelOfFortune() {\n        m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);\n\n        m_spinWheel = new WPI_VictorSPX(RobotMap.CAN_WHEELOFFORTUNE);\n        m_spinWheel.configFactoryDefault();\n        m_spinWheel.setNeutralMode(NeutralMode.Brake);\n\n        isChanged = false;\n\n        m_wheelArm = new Solenoid(RobotMap.CAN_PNMMODULE, RobotMap.PNM_WHEELARM);\n\n        m_wheelArm.set(false);\n\n        //This is the Map for converting the fieldColor into targetColor, which can be used to clear a lot of confusion while making the algorithm\n        fieldToTargetColorMap.put(\"Blue\", \"Red\");\n        fieldToTargetColorMap.put(\"Green\", \"Yellow\");\n        fieldToTargetColorMap.put(\"Red\", \"Blue\");\n        fieldToTargetColorMap.put(\"Yellow\", \"Green\");\n\n        actualColor = \"Black\"; // Initialize color tracker to black\n\n        interrogator = new Thread(new InterrogationLoop(), \"WOF interrogator\");\n        interrogator.start();\n\n        DriverStation.reportWarning(\"WOF color sensor Init complete\", false);\n    }\n\n    public String getTargetColor(String sourceColor, WheelOfFortune subsystem) {\n        return subsystem.fieldToTargetColorMap.get(sourceColor);\n    }\n\n    public String determineColor() { //TODO: check with motor\n\n        String possibleColor = this.detectHSB();\n\n        if (!possibleColor.equals(actualColor)) {\n            if (!isChanged) {\n                lastTimestamp = Timer.getFPGATimestamp();\n                isChanged = true;\n                isCounted = false;\n            } else {\n                if (Timer.getFPGATimestamp() - lastTimestamp > .1 && !isCounted) {\n                    isCounted = true;\n                    isChanged = false;\n                    actualColor = possibleColor;\n                }\n            }\n        } else {\n            isChanged = false;\n        }\n        return actualColor;\n    }\n\n    /**\n     * Run the color match algorithm on our detected color\n     *\n     * @return String name of the most likely color\n     */\n    public String detectHSB() {\n        float[] hsb = java.awt.Color.RGBtoHSB(cachedR, cachedG, cachedB, null);\n        deg = hsb[0] * 360;\n        sat = hsb[1];\n        brightness = hsb[2];\n        //Potential algorithm for rgb to hsb\n        if (sat < 0.3 && brightness > 0.9) {\n            return \"White\";\n        } else if (brightness < 40.0) {\n            return \"Black\";\n        } else {\n            if (deg < 60 || deg > 310) {\n                return \"Red\";\n            } else if (deg < 100) {\n                return \"Yellow\";\n            } else if (deg < 130) {\n                return \"Green\";\n            } else if (deg < 250) {\n                return \"Blue\";\n            } else {\n                return \"Bruh\";\n            }\n        }\n    }\n\n\n    /**\n     * Method for toggling wheel of fortune manipulator\n     */\n    public void toggleWheel() {\n//        System.out.println(\"Wheel has toggled\");\n        m_wheelArm.set(!m_wheelArm.get());\n    }\n\n    /**\n     * method for retracting wheel to be called in a command\n     */\n    public void retractWheel() {\n//        System.out.println(\"Wheel has retracted\");\n        m_wheelArm.set(false);\n    }\n\n    public void motorSpin(double spin) {\n        m_spinWheel.set(ControlMode.PercentOutput, spin);\n    }\n\n    public void outputToShuffleboard(WheelOfFortune subsystem) {\n        SmartDashboard.putString(\"HSB Detected color\", subsystem.detectHSB());\n        SmartDashboard.putNumber(\"Hue Degree\", subsystem.deg); //TODO: remove these\n        SmartDashboard.putNumber(\"Saturation\", subsystem.sat);\n        SmartDashboard.putNumber(\"Brightness\", subsystem.brightness);\n    }\n\n    @Override\n    public void periodic() {\n//        colorWidget.withProperties(Map.of(\"colorWhenTrue\", getInstance().determineColor()));\n    }\n\n}", "class_id": 0, "repo": "team3130/Lotus", "file": "src/main/java/frc/team3130/robot/subsystems/WheelOfFortune.java", "last_update_at": "2021-04-08T16:59:07+00:00", "question_id": "fe59e73e25558d873a94e9fc5c1225b2bb48a8de", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WheelOfFortune extends SubsystemBase {\n    //Create necessary objects\n    private static ColorSensorV3 m_colorSensor;\n    private static WPI_VictorSPX m_spinWheel;\n    private static Solenoid m_wheelArm;\n    //Create and define all standard data types needed\n//    private SuppliedValueWidget colorWidget =\n//            Shuffleboard.getTab(\"Kyber\").addBoolean(\"Wheel Color\", () -> true);\n    private Map<String, String> fieldToTargetColorMap = new HashMap<String, String>();\n    private double lastTimestamp;\n    private boolean isChanged;\n    private boolean isCounted;\n    private String actualColor;\n    private float deg = 0;\n    private float sat = 0;\n    private float brightness = 0;\n    private Thread interrogator;\n    private int cachedR = 0;\n    private int cachedG = 0;\n    private int cachedB = 0;\n    private class InterrogationLoop implements Runnable {\n\t\tpublic void run() {\n\t\t\ttry {\n                // These three operations can run away waiting for i2c synchronization\n                int r = m_colorSensor.getRed();\n                int g = m_colorSensor.getGreen();\n                int b = m_colorSensor.getBlue();\n                // Now as we are back we can update the cache at once\n                cachedR = r;\n                cachedG = g;\n                cachedB = b;\n\t\t\t\tThread.sleep(20);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tDriverStation.reportError(\n\t\t\t\t\t\t\"Thread \"+Thread.currentThread().getName()+\" got interrupted\",\n\t\t\t\t\t\ttrue);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n    private static final WheelOfFortune instance = new WheelOfFortune();\n    public static WheelOfFortune getInstance() {\n        return instance;\n    }\n    private WheelOfFortune() {\n        m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);\n        m_spinWheel = new WPI_VictorSPX(RobotMap.CAN_WHEELOFFORTUNE);\n        m_spinWheel.configFactoryDefault();\n        m_spinWheel.setNeutralMode(NeutralMode.Brake);\n        isChanged = false;\n        m_wheelArm = new Solenoid(RobotMap.CAN_PNMMODULE, RobotMap.PNM_WHEELARM);\n        m_wheelArm.set(false);\n        //This is the Map for converting the fieldColor into targetColor, which can be used to clear a lot of confusion while making the algorithm\n        fieldToTargetColorMap.put(\"Blue\", \"Red\");\n        fieldToTargetColorMap.put(\"Green\", \"Yellow\");\n        fieldToTargetColorMap.put(\"Red\", \"Blue\");\n        fieldToTargetColorMap.put(\"Yellow\", \"Green\");\n        actualColor = \"Black\"; // Initialize color tracker to black\n        interrogator = new Thread(new InterrogationLoop(), \"WOF interrogator\");\n        interrogator.start();\n        DriverStation.reportWarning(\"WOF color sensor Init complete\", false);\n    }\n    public String getTargetColor(String sourceColor, WheelOfFortune subsystem) {\n        return subsystem.fieldToTargetColorMap.get(sourceColor);\n    }\n    public String determineColor() { //TODO: check with motor\n        String possibleColor = this.detectHSB();\n        if (!possibleColor.equals(actualColor)) {\n            if (!isChanged) {\n                lastTimestamp = Timer.getFPGATimestamp();\n                isChanged = true;\n                isCounted = false;\n            } else {\n                if (Timer.getFPGATimestamp() - lastTimestamp > .1 && !isCounted) {\n                    isCounted = true;\n                    isChanged = false;\n                    actualColor = possibleColor;\n                }\n            }\n        } else {\n            isChanged = false;\n        }\n        return actualColor;\n    }\n    /**\n     * Run the color match algorithm on our detected color\n     *\n     * @return String name of the most likely color\n     */\n    public String detectHSB() {\n        float[] hsb = java.awt.Color.RGBtoHSB(cachedR, cachedG, cachedB, null);\n        deg = hsb[0] * 360;\n        sat = hsb[1];\n        brightness = hsb[2];\n        //Potential algorithm for rgb to hsb\n        if (sat < 0.3 && brightness > 0.9) {\n            return \"White\";\n        } else if (brightness < 40.0) {\n            return \"Black\";\n        } else {\n            if (deg < 60 || deg > 310) {\n                return \"Red\";\n            } else if (deg < 100) {\n                return \"Yellow\";\n            } else if (deg < 130) {\n                return \"Green\";\n            } else if (deg < 250) {\n                return \"Blue\";\n            } else {\n                return \"Bruh\";\n            }\n        }\n    }\n    /**\n     * Method for toggling wheel of fortune manipulator\n     */\n    public void toggleWheel() {\n//        System.out.println(\"Wheel has toggled\");\n        m_wheelArm.set(!m_wheelArm.get());\n    }\n    /**\n     * method for retracting wheel to be called in a command\n     */\n    public void retractWheel() {\n//        System.out.println(\"Wheel has retracted\");\n        m_wheelArm.set(false);\n    }\n    public void motorSpin(double spin) {\n        m_spinWheel.set(ControlMode.PercentOutput, spin);\n    }\n    public void outputToShuffleboard(WheelOfFortune subsystem) {\n        SmartDashboard.putString(\"HSB Detected color\", subsystem.detectHSB());\n        SmartDashboard.putNumber(\"Hue Degree\", subsystem.deg); //TODO: remove these\n        SmartDashboard.putNumber(\"Saturation\", subsystem.sat);\n        SmartDashboard.putNumber(\"Brightness\", subsystem.brightness);\n    }\n    @Override\n    public void periodic() {\n//        colorWidget.withProperties(Map.of(\"colorWhenTrue\", getInstance().determineColor()));\n    }\n"]]}
{"hexsha": "c7f36a8c5229e6ee24a8be25281e4e42828dbf4e", "ext": "java", "lang": "Java", "content": "@IntentBuilder\npublic class DetailActivity extends AppCompatActivity {\n\n    @Extra\n    String one;\n\n    @Extra\n    String two;\n\n    @Extra @Nullable\n    String three;\n\n    @Extra @Nullable\n    String four;\n\n    @Extra(\"five\") @Nullable\n    String mFive;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        DetailActivityIntentBuilder.inject(getIntent(), this);\n        setContentView(R.layout.activity_detail);\n\n        ((TextView)findViewById(R.id.one)).setText(one);\n        ((TextView)findViewById(R.id.two)).setText(two);\n        ((TextView)findViewById(R.id.three)).setText(three);\n        ((TextView)findViewById(R.id.four)).setText(four);\n        ((TextView)findViewById(R.id.five)).setText(mFive);\n    }\n\n}", "class_id": 0, "repo": "lsjwzh/IntentBuilder", "file": "sample/src/main/java/se/emilsjolander/intentbuilder/sample/DetailActivity.java", "last_update_at": "2021-04-08T20:22:30+00:00", "question_id": "c7f36a8c5229e6ee24a8be25281e4e42828dbf4e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@IntentBuilder\npublic class DetailActivity extends AppCompatActivity {\n    @Extra\n    String one;\n    @Extra\n    String two;\n    @Extra @Nullable\n    String three;\n    @Extra @Nullable\n    String four;\n    @Extra(\"five\") @Nullable\n    String mFive;\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        DetailActivityIntentBuilder.inject(getIntent(), this);\n        setContentView(R.layout.activity_detail);\n        ((TextView)findViewById(R.id.one)).setText(one);\n        ((TextView)findViewById(R.id.two)).setText(two);\n        ((TextView)findViewById(R.id.three)).setText(three);\n        ((TextView)findViewById(R.id.four)).setText(four);\n        ((TextView)findViewById(R.id.five)).setText(mFive);\n    }\n"]]}
{"hexsha": "902dc7a95be7bd3c98d3ff6f7bce99c84d3cd716", "ext": "java", "lang": "Java", "content": "public class ExpirationTimeScriptPlugin extends MockScriptPlugin {\n    @Override\n    public String pluginScriptLang() {\n        return \"painless\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {\n        final String fieldName = \"expiration_time\";\n        final String script =\n            \" if (ctx._source.expiration_time < params.expiration_time) { \" +\n            \"     ctx._source.expiration_time = params.expiration_time; \" +\n            \" } else { \" +\n            \"     ctx.op = \\\"noop\\\"; \" +\n            \" }\";\n        return Map.of(\n            script, vars -> {\n                Map<String, Object> params = (Map<String, Object>) vars.get(\"params\");\n                Assert.assertNotNull(params);\n                Assert.assertThat(params.keySet(), contains(fieldName));\n                long updatingValue = (long) params.get(fieldName);\n\n                Map<String, Object> ctx = (Map<String, Object>) vars.get(\"ctx\");\n                Assert.assertNotNull(ctx);\n                Map<String, Object> source = (Map<String, Object>) ctx.get(\"_source\");\n                long currentValue = (long) source.get(fieldName);\n                if (currentValue < updatingValue) {\n                    source.put(fieldName, updatingValue);\n                } else {\n                    ctx.put(\"op\", \"noop\");\n                }\n                return ctx;\n            }\n        );\n    }\n}", "class_id": 0, "repo": "SaiKai/elasticsearch", "file": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/async/ExpirationTimeScriptPlugin.java", "last_update_at": "2021-02-09T13:44:10+00:00", "question_id": "902dc7a95be7bd3c98d3ff6f7bce99c84d3cd716", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExpirationTimeScriptPlugin extends MockScriptPlugin {\n    @Override\n    public String pluginScriptLang() {\n        return \"painless\";\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {\n        final String fieldName = \"expiration_time\";\n        final String script =\n            \" if (ctx._source.expiration_time < params.expiration_time) { \" +\n            \"     ctx._source.expiration_time = params.expiration_time; \" +\n            \" } else { \" +\n            \"     ctx.op = \\\"noop\\\"; \" +\n            \" }\";\n        return Map.of(\n            script, vars -> {\n                Map<String, Object> params = (Map<String, Object>) vars.get(\"params\");\n                Assert.assertNotNull(params);\n                Assert.assertThat(params.keySet(), contains(fieldName));\n                long updatingValue = (long) params.get(fieldName);\n                Map<String, Object> ctx = (Map<String, Object>) vars.get(\"ctx\");\n                Assert.assertNotNull(ctx);\n                Map<String, Object> source = (Map<String, Object>) ctx.get(\"_source\");\n                long currentValue = (long) source.get(fieldName);\n                if (currentValue < updatingValue) {\n                    source.put(fieldName, updatingValue);\n                } else {\n                    ctx.put(\"op\", \"noop\");\n                }\n                return ctx;\n            }\n        );\n    }\n"]]}
{"hexsha": "91953d73cb626c9bf2be8918e0b871465e2f55ee", "ext": "java", "lang": "Java", "content": "public class DummyProviderTraces {\n\tstatic DummyProviderTraces instance = new DummyProviderTraces();\n\t\n\tpublic static DummyProviderTraces getInstance() { return instance; }\n\n\t/** Flag indicates if test is enabled, so we should trace projects and configs */\n\tpublic volatile boolean enabled;\n\n\tprivate DummyProviderTraces() {}\n\t\n\tMap/*<String, List>*/ id2prjTrace= new HashMap();\n\tMap/*<String, List>*/ id2cfgTrace= new HashMap();\n\t\n\tpublic List getProjectsTrace(Class provider) {\n\t\tString key= provider.getName();\n\t\tif(!id2prjTrace.containsKey(key)) {\n\t\t\tid2prjTrace.put(key, Collections.synchronizedList(new ArrayList()));\n\t\t}\n\t\treturn (List) id2prjTrace.get(key);\n\t}\n\t\n\tpublic List getCfgsTrace(Class provider) {\n\t\tString key= provider.getName();\n\t\tif(!id2cfgTrace.containsKey(key)) {\n\t\t\tid2cfgTrace.put(key, Collections.synchronizedList(new ArrayList()));\n\t\t}\n\t\treturn (List) id2cfgTrace.get(key);\n\t}\n\t\n\tpublic void reset(Class provider) {\n\t\tgetProjectsTrace(provider).clear();\n\t\tgetCfgsTrace(provider).clear();\n\t}\n}", "class_id": 0, "repo": "NiSE-Virginia-Tech/Yuerr14-RepeatedFixes", "file": "RepeatedFixes/misc/org/eclipse/cdt/core/internal/index/provider/test/DummyProviderTraces.java", "last_update_at": "2021-03-29T19:54:05+00:00", "question_id": "91953d73cb626c9bf2be8918e0b871465e2f55ee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DummyProviderTraces {\n\tstatic DummyProviderTraces instance = new DummyProviderTraces();\n\t\n\tpublic static DummyProviderTraces getInstance() { return instance; }\n\t/** Flag indicates if test is enabled, so we should trace projects and configs */\n\tpublic volatile boolean enabled;\n\tprivate DummyProviderTraces() {}\n\t\n\tMap/*<String, List>*/ id2prjTrace= new HashMap();\n\tMap/*<String, List>*/ id2cfgTrace= new HashMap();\n\t\n\tpublic List getProjectsTrace(Class provider) {\n\t\tString key= provider.getName();\n\t\tif(!id2prjTrace.containsKey(key)) {\n\t\t\tid2prjTrace.put(key, Collections.synchronizedList(new ArrayList()));\n\t\t}\n\t\treturn (List) id2prjTrace.get(key);\n\t}\n\t\n\tpublic List getCfgsTrace(Class provider) {\n\t\tString key= provider.getName();\n\t\tif(!id2cfgTrace.containsKey(key)) {\n\t\t\tid2cfgTrace.put(key, Collections.synchronizedList(new ArrayList()));\n\t\t}\n\t\treturn (List) id2cfgTrace.get(key);\n\t}\n\t\n\tpublic void reset(Class provider) {\n\t\tgetProjectsTrace(provider).clear();\n\t\tgetCfgsTrace(provider).clear();\n\t}\n"]]}
{"hexsha": "883288933fee1f2b5717071cb2d9eba2723d9d39", "ext": "java", "lang": "Java", "content": "public class TCRMPhoneNumberBObjType  extends CommonBObjType  implements java.io.Serializable {\n    private java.lang.String objectReferenceId;\n\n    private java.lang.String phoneNumberId;\n\n    private java.lang.String contactMethodId;\n\n    private java.lang.String phoneCountryCode;\n\n    private java.lang.String phoneAreaCode;\n\n    private java.lang.String phoneExchange;\n\n    private java.lang.String phoneNumber;\n\n    private java.lang.String phoneExtension;\n\n    private java.lang.String phoneLastUpdateDate;\n\n    private java.lang.String phoneLastUpdateUser;\n\n    private java.lang.String phoneLastUpdateTxId;\n\n    private TCRMExtension TCRMExtension;\n\n    private PrimaryKeyBObj primaryKeyBObj;\n\n    private java.lang.String phoneHistActionCode;\n\n    private java.lang.String phoneHistCreateDate;\n\n    private java.lang.String phoneHistCreatedBy;\n\n    private java.lang.String phoneHistEndDate;\n\n    private java.lang.String phoneHistoryIdPK;\n\n    private DWLStatus DWLStatus;\n\n    public TCRMPhoneNumberBObjType() {\n    }\n\n    public TCRMPhoneNumberBObjType(\n           java.lang.String objectReferenceId,\n           java.lang.String phoneNumberId,\n           java.lang.String contactMethodId,\n           java.lang.String phoneCountryCode,\n           java.lang.String phoneAreaCode,\n           java.lang.String phoneExchange,\n           java.lang.String phoneNumber,\n           java.lang.String phoneExtension,\n           java.lang.String phoneLastUpdateDate,\n           java.lang.String phoneLastUpdateUser,\n           java.lang.String phoneLastUpdateTxId,\n           TCRMExtension TCRMExtension,\n           PrimaryKeyBObj primaryKeyBObj,\n           java.lang.String phoneHistActionCode,\n           java.lang.String phoneHistCreateDate,\n           java.lang.String phoneHistCreatedBy,\n           java.lang.String phoneHistEndDate,\n           java.lang.String phoneHistoryIdPK,\n           DWLStatus DWLStatus) {\n        this.objectReferenceId = objectReferenceId;\n        this.phoneNumberId = phoneNumberId;\n        this.contactMethodId = contactMethodId;\n        this.phoneCountryCode = phoneCountryCode;\n        this.phoneAreaCode = phoneAreaCode;\n        this.phoneExchange = phoneExchange;\n        this.phoneNumber = phoneNumber;\n        this.phoneExtension = phoneExtension;\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n        this.TCRMExtension = TCRMExtension;\n        this.primaryKeyBObj = primaryKeyBObj;\n        this.phoneHistActionCode = phoneHistActionCode;\n        this.phoneHistCreateDate = phoneHistCreateDate;\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n        this.phoneHistEndDate = phoneHistEndDate;\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n        this.DWLStatus = DWLStatus;\n    }\n\n\n    /**\n     * Gets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return objectReferenceId\n     */\n    public java.lang.String getObjectReferenceId() {\n        return objectReferenceId;\n    }\n\n\n    /**\n     * Sets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param objectReferenceId\n     */\n    public void setObjectReferenceId(java.lang.String objectReferenceId) {\n        this.objectReferenceId = objectReferenceId;\n    }\n\n\n    /**\n     * Gets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneNumberId\n     */\n    public java.lang.String getPhoneNumberId() {\n        return phoneNumberId;\n    }\n\n\n    /**\n     * Sets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneNumberId\n     */\n    public void setPhoneNumberId(java.lang.String phoneNumberId) {\n        this.phoneNumberId = phoneNumberId;\n    }\n\n\n    /**\n     * Gets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return contactMethodId\n     */\n    public java.lang.String getContactMethodId() {\n        return contactMethodId;\n    }\n\n\n    /**\n     * Sets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param contactMethodId\n     */\n    public void setContactMethodId(java.lang.String contactMethodId) {\n        this.contactMethodId = contactMethodId;\n    }\n\n\n    /**\n     * Gets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneCountryCode\n     */\n    public java.lang.String getPhoneCountryCode() {\n        return phoneCountryCode;\n    }\n\n\n    /**\n     * Sets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneCountryCode\n     */\n    public void setPhoneCountryCode(java.lang.String phoneCountryCode) {\n        this.phoneCountryCode = phoneCountryCode;\n    }\n\n\n    /**\n     * Gets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneAreaCode\n     */\n    public java.lang.String getPhoneAreaCode() {\n        return phoneAreaCode;\n    }\n\n\n    /**\n     * Sets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneAreaCode\n     */\n    public void setPhoneAreaCode(java.lang.String phoneAreaCode) {\n        this.phoneAreaCode = phoneAreaCode;\n    }\n\n\n    /**\n     * Gets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneExchange\n     */\n    public java.lang.String getPhoneExchange() {\n        return phoneExchange;\n    }\n\n\n    /**\n     * Sets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneExchange\n     */\n    public void setPhoneExchange(java.lang.String phoneExchange) {\n        this.phoneExchange = phoneExchange;\n    }\n\n\n    /**\n     * Gets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneNumber\n     */\n    public java.lang.String getPhoneNumber() {\n        return phoneNumber;\n    }\n\n\n    /**\n     * Sets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneNumber\n     */\n    public void setPhoneNumber(java.lang.String phoneNumber) {\n        this.phoneNumber = phoneNumber;\n    }\n\n\n    /**\n     * Gets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneExtension\n     */\n    public java.lang.String getPhoneExtension() {\n        return phoneExtension;\n    }\n\n\n    /**\n     * Sets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneExtension\n     */\n    public void setPhoneExtension(java.lang.String phoneExtension) {\n        this.phoneExtension = phoneExtension;\n    }\n\n\n    /**\n     * Gets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneLastUpdateDate\n     */\n    public java.lang.String getPhoneLastUpdateDate() {\n        return phoneLastUpdateDate;\n    }\n\n\n    /**\n     * Sets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneLastUpdateDate\n     */\n    public void setPhoneLastUpdateDate(java.lang.String phoneLastUpdateDate) {\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n    }\n\n\n    /**\n     * Gets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneLastUpdateUser\n     */\n    public java.lang.String getPhoneLastUpdateUser() {\n        return phoneLastUpdateUser;\n    }\n\n\n    /**\n     * Sets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneLastUpdateUser\n     */\n    public void setPhoneLastUpdateUser(java.lang.String phoneLastUpdateUser) {\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n    }\n\n\n    /**\n     * Gets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneLastUpdateTxId\n     */\n    public java.lang.String getPhoneLastUpdateTxId() {\n        return phoneLastUpdateTxId;\n    }\n\n\n    /**\n     * Sets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneLastUpdateTxId\n     */\n    public void setPhoneLastUpdateTxId(java.lang.String phoneLastUpdateTxId) {\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n    }\n\n\n    /**\n     * Gets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @return TCRMExtension\n     */\n    public TCRMExtension getTCRMExtension() {\n        return TCRMExtension;\n    }\n\n\n    /**\n     * Sets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @param TCRMExtension\n     */\n    public void setTCRMExtension(TCRMExtension TCRMExtension) {\n        this.TCRMExtension = TCRMExtension;\n    }\n\n\n    /**\n     * Gets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     * \n     * @return primaryKeyBObj\n     */\n    public PrimaryKeyBObj getPrimaryKeyBObj() {\n        return primaryKeyBObj;\n    }\n\n\n    /**\n     * Sets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     * \n     * @param primaryKeyBObj\n     */\n    public void setPrimaryKeyBObj(PrimaryKeyBObj primaryKeyBObj) {\n        this.primaryKeyBObj = primaryKeyBObj;\n    }\n\n\n    /**\n     * Gets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistActionCode\n     */\n    public java.lang.String getPhoneHistActionCode() {\n        return phoneHistActionCode;\n    }\n\n\n    /**\n     * Sets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistActionCode\n     */\n    public void setPhoneHistActionCode(java.lang.String phoneHistActionCode) {\n        this.phoneHistActionCode = phoneHistActionCode;\n    }\n\n\n    /**\n     * Gets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistCreateDate\n     */\n    public java.lang.String getPhoneHistCreateDate() {\n        return phoneHistCreateDate;\n    }\n\n\n    /**\n     * Sets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistCreateDate\n     */\n    public void setPhoneHistCreateDate(java.lang.String phoneHistCreateDate) {\n        this.phoneHistCreateDate = phoneHistCreateDate;\n    }\n\n\n    /**\n     * Gets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistCreatedBy\n     */\n    public java.lang.String getPhoneHistCreatedBy() {\n        return phoneHistCreatedBy;\n    }\n\n\n    /**\n     * Sets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistCreatedBy\n     */\n    public void setPhoneHistCreatedBy(java.lang.String phoneHistCreatedBy) {\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n    }\n\n\n    /**\n     * Gets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistEndDate\n     */\n    public java.lang.String getPhoneHistEndDate() {\n        return phoneHistEndDate;\n    }\n\n\n    /**\n     * Sets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistEndDate\n     */\n    public void setPhoneHistEndDate(java.lang.String phoneHistEndDate) {\n        this.phoneHistEndDate = phoneHistEndDate;\n    }\n\n\n    /**\n     * Gets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistoryIdPK\n     */\n    public java.lang.String getPhoneHistoryIdPK() {\n        return phoneHistoryIdPK;\n    }\n\n\n    /**\n     * Sets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistoryIdPK\n     */\n    public void setPhoneHistoryIdPK(java.lang.String phoneHistoryIdPK) {\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n    }\n\n\n    /**\n     * Gets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     * \n     * @return DWLStatus\n     */\n    public DWLStatus getDWLStatus() {\n        return DWLStatus;\n    }\n\n\n    /**\n     * Sets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     * \n     * @param DWLStatus\n     */\n    public void setDWLStatus(DWLStatus DWLStatus) {\n        this.DWLStatus = DWLStatus;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof TCRMPhoneNumberBObjType)) return false;\n        TCRMPhoneNumberBObjType other = (TCRMPhoneNumberBObjType) obj;\n        if (obj == null) return false;\n        if (this == obj) return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = super.equals(obj) && \n            ((this.objectReferenceId==null && other.getObjectReferenceId()==null) || \n             (this.objectReferenceId!=null &&\n              this.objectReferenceId.equals(other.getObjectReferenceId()))) &&\n            ((this.phoneNumberId==null && other.getPhoneNumberId()==null) || \n             (this.phoneNumberId!=null &&\n              this.phoneNumberId.equals(other.getPhoneNumberId()))) &&\n            ((this.contactMethodId==null && other.getContactMethodId()==null) || \n             (this.contactMethodId!=null &&\n              this.contactMethodId.equals(other.getContactMethodId()))) &&\n            ((this.phoneCountryCode==null && other.getPhoneCountryCode()==null) || \n             (this.phoneCountryCode!=null &&\n              this.phoneCountryCode.equals(other.getPhoneCountryCode()))) &&\n            ((this.phoneAreaCode==null && other.getPhoneAreaCode()==null) || \n             (this.phoneAreaCode!=null &&\n              this.phoneAreaCode.equals(other.getPhoneAreaCode()))) &&\n            ((this.phoneExchange==null && other.getPhoneExchange()==null) || \n             (this.phoneExchange!=null &&\n              this.phoneExchange.equals(other.getPhoneExchange()))) &&\n            ((this.phoneNumber==null && other.getPhoneNumber()==null) || \n             (this.phoneNumber!=null &&\n              this.phoneNumber.equals(other.getPhoneNumber()))) &&\n            ((this.phoneExtension==null && other.getPhoneExtension()==null) || \n             (this.phoneExtension!=null &&\n              this.phoneExtension.equals(other.getPhoneExtension()))) &&\n            ((this.phoneLastUpdateDate==null && other.getPhoneLastUpdateDate()==null) || \n             (this.phoneLastUpdateDate!=null &&\n              this.phoneLastUpdateDate.equals(other.getPhoneLastUpdateDate()))) &&\n            ((this.phoneLastUpdateUser==null && other.getPhoneLastUpdateUser()==null) || \n             (this.phoneLastUpdateUser!=null &&\n              this.phoneLastUpdateUser.equals(other.getPhoneLastUpdateUser()))) &&\n            ((this.phoneLastUpdateTxId==null && other.getPhoneLastUpdateTxId()==null) || \n             (this.phoneLastUpdateTxId!=null &&\n              this.phoneLastUpdateTxId.equals(other.getPhoneLastUpdateTxId()))) &&\n            ((this.TCRMExtension==null && other.getTCRMExtension()==null) || \n             (this.TCRMExtension!=null &&\n              this.TCRMExtension.equals(other.getTCRMExtension()))) &&\n            ((this.primaryKeyBObj==null && other.getPrimaryKeyBObj()==null) || \n             (this.primaryKeyBObj!=null &&\n              this.primaryKeyBObj.equals(other.getPrimaryKeyBObj()))) &&\n            ((this.phoneHistActionCode==null && other.getPhoneHistActionCode()==null) || \n             (this.phoneHistActionCode!=null &&\n              this.phoneHistActionCode.equals(other.getPhoneHistActionCode()))) &&\n            ((this.phoneHistCreateDate==null && other.getPhoneHistCreateDate()==null) || \n             (this.phoneHistCreateDate!=null &&\n              this.phoneHistCreateDate.equals(other.getPhoneHistCreateDate()))) &&\n            ((this.phoneHistCreatedBy==null && other.getPhoneHistCreatedBy()==null) || \n             (this.phoneHistCreatedBy!=null &&\n              this.phoneHistCreatedBy.equals(other.getPhoneHistCreatedBy()))) &&\n            ((this.phoneHistEndDate==null && other.getPhoneHistEndDate()==null) || \n             (this.phoneHistEndDate!=null &&\n              this.phoneHistEndDate.equals(other.getPhoneHistEndDate()))) &&\n            ((this.phoneHistoryIdPK==null && other.getPhoneHistoryIdPK()==null) || \n             (this.phoneHistoryIdPK!=null &&\n              this.phoneHistoryIdPK.equals(other.getPhoneHistoryIdPK()))) &&\n            ((this.DWLStatus==null && other.getDWLStatus()==null) || \n             (this.DWLStatus!=null &&\n              this.DWLStatus.equals(other.getDWLStatus())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = super.hashCode();\n        if (getObjectReferenceId() != null) {\n            _hashCode += getObjectReferenceId().hashCode();\n        }\n        if (getPhoneNumberId() != null) {\n            _hashCode += getPhoneNumberId().hashCode();\n        }\n        if (getContactMethodId() != null) {\n            _hashCode += getContactMethodId().hashCode();\n        }\n        if (getPhoneCountryCode() != null) {\n            _hashCode += getPhoneCountryCode().hashCode();\n        }\n        if (getPhoneAreaCode() != null) {\n            _hashCode += getPhoneAreaCode().hashCode();\n        }\n        if (getPhoneExchange() != null) {\n            _hashCode += getPhoneExchange().hashCode();\n        }\n        if (getPhoneNumber() != null) {\n            _hashCode += getPhoneNumber().hashCode();\n        }\n        if (getPhoneExtension() != null) {\n            _hashCode += getPhoneExtension().hashCode();\n        }\n        if (getPhoneLastUpdateDate() != null) {\n            _hashCode += getPhoneLastUpdateDate().hashCode();\n        }\n        if (getPhoneLastUpdateUser() != null) {\n            _hashCode += getPhoneLastUpdateUser().hashCode();\n        }\n        if (getPhoneLastUpdateTxId() != null) {\n            _hashCode += getPhoneLastUpdateTxId().hashCode();\n        }\n        if (getTCRMExtension() != null) {\n            _hashCode += getTCRMExtension().hashCode();\n        }\n        if (getPrimaryKeyBObj() != null) {\n            _hashCode += getPrimaryKeyBObj().hashCode();\n        }\n        if (getPhoneHistActionCode() != null) {\n            _hashCode += getPhoneHistActionCode().hashCode();\n        }\n        if (getPhoneHistCreateDate() != null) {\n            _hashCode += getPhoneHistCreateDate().hashCode();\n        }\n        if (getPhoneHistCreatedBy() != null) {\n            _hashCode += getPhoneHistCreatedBy().hashCode();\n        }\n        if (getPhoneHistEndDate() != null) {\n            _hashCode += getPhoneHistEndDate().hashCode();\n        }\n        if (getPhoneHistoryIdPK() != null) {\n            _hashCode += getPhoneHistoryIdPK().hashCode();\n        }\n        if (getDWLStatus() != null) {\n            _hashCode += getDWLStatus().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc =\n        new org.apache.axis.description.TypeDesc(TCRMPhoneNumberBObjType.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMPhoneNumberBObjType\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"objectReferenceId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ObjectReferenceId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumberId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumberId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"contactMethodId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ContactMethodId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneCountryCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneCountryCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneAreaCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneAreaCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExchange\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExchange\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumber\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumber\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateUser\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateUser\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateTxId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateTxId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"TCRMExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">TCRMExtension\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"primaryKeyBObj\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PrimaryKeyBObj\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">PrimaryKeyBObj\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistActionCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistActionCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreatedBy\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreatedBy\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistEndDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistEndDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistoryIdPK\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistoryIdPK\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"DWLStatus\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"DWLStatus\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">DWLStatus\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(\n           java.lang.String mechType, \n           java.lang.Class _javaType,  \n           javax.xml.namespace.QName _xmlType) {\n        return \n          new  org.apache.axis.encoding.ser.BeanSerializer(\n            _javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(\n           java.lang.String mechType, \n           java.lang.Class _javaType,  \n           javax.xml.namespace.QName _xmlType) {\n        return \n          new  org.apache.axis.encoding.ser.BeanDeserializer(\n            _javaType, _xmlType, typeDesc);\n    }\n\n}", "class_id": 0, "repo": "huangzishuo/ace-security", "file": "mdm-api/src/main/java/tongji/domain/oracle/TCRMPhoneNumberBObjType.java", "last_update_at": "2021-07-12T01:22:35+00:00", "question_id": "883288933fee1f2b5717071cb2d9eba2723d9d39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TCRMPhoneNumberBObjType  extends CommonBObjType  implements java.io.Serializable {\n    private java.lang.String objectReferenceId;\n    private java.lang.String phoneNumberId;\n    private java.lang.String contactMethodId;\n    private java.lang.String phoneCountryCode;\n    private java.lang.String phoneAreaCode;\n    private java.lang.String phoneExchange;\n    private java.lang.String phoneNumber;\n    private java.lang.String phoneExtension;\n    private java.lang.String phoneLastUpdateDate;\n    private java.lang.String phoneLastUpdateUser;\n    private java.lang.String phoneLastUpdateTxId;\n    private TCRMExtension TCRMExtension;\n    private PrimaryKeyBObj primaryKeyBObj;\n    private java.lang.String phoneHistActionCode;\n    private java.lang.String phoneHistCreateDate;\n    private java.lang.String phoneHistCreatedBy;\n    private java.lang.String phoneHistEndDate;\n    private java.lang.String phoneHistoryIdPK;\n    private DWLStatus DWLStatus;\n    public TCRMPhoneNumberBObjType() {\n    }\n    public TCRMPhoneNumberBObjType(\n           java.lang.String objectReferenceId,\n           java.lang.String phoneNumberId,\n           java.lang.String contactMethodId,\n           java.lang.String phoneCountryCode,\n           java.lang.String phoneAreaCode,\n           java.lang.String phoneExchange,\n           java.lang.String phoneNumber,\n           java.lang.String phoneExtension,\n           java.lang.String phoneLastUpdateDate,\n           java.lang.String phoneLastUpdateUser,\n           java.lang.String phoneLastUpdateTxId,\n           TCRMExtension TCRMExtension,\n           PrimaryKeyBObj primaryKeyBObj,\n           java.lang.String phoneHistActionCode,\n           java.lang.String phoneHistCreateDate,\n           java.lang.String phoneHistCreatedBy,\n           java.lang.String phoneHistEndDate,\n           java.lang.String phoneHistoryIdPK,\n           DWLStatus DWLStatus) {\n        this.objectReferenceId = objectReferenceId;\n        this.phoneNumberId = phoneNumberId;\n        this.contactMethodId = contactMethodId;\n        this.phoneCountryCode = phoneCountryCode;\n        this.phoneAreaCode = phoneAreaCode;\n        this.phoneExchange = phoneExchange;\n        this.phoneNumber = phoneNumber;\n        this.phoneExtension = phoneExtension;\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n        this.TCRMExtension = TCRMExtension;\n        this.primaryKeyBObj = primaryKeyBObj;\n        this.phoneHistActionCode = phoneHistActionCode;\n        this.phoneHistCreateDate = phoneHistCreateDate;\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n        this.phoneHistEndDate = phoneHistEndDate;\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n        this.DWLStatus = DWLStatus;\n    }\n    /**\n     * Gets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return objectReferenceId\n     */\n    public java.lang.String getObjectReferenceId() {\n        return objectReferenceId;\n    }\n    /**\n     * Sets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param objectReferenceId\n     */\n    public void setObjectReferenceId(java.lang.String objectReferenceId) {\n        this.objectReferenceId = objectReferenceId;\n    }\n    /**\n     * Gets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneNumberId\n     */\n    public java.lang.String getPhoneNumberId() {\n        return phoneNumberId;\n    }\n    /**\n     * Sets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneNumberId\n     */\n    public void setPhoneNumberId(java.lang.String phoneNumberId) {\n        this.phoneNumberId = phoneNumberId;\n    }\n    /**\n     * Gets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return contactMethodId\n     */\n    public java.lang.String getContactMethodId() {\n        return contactMethodId;\n    }\n    /**\n     * Sets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param contactMethodId\n     */\n    public void setContactMethodId(java.lang.String contactMethodId) {\n        this.contactMethodId = contactMethodId;\n    }\n    /**\n     * Gets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneCountryCode\n     */\n    public java.lang.String getPhoneCountryCode() {\n        return phoneCountryCode;\n    }\n    /**\n     * Sets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneCountryCode\n     */\n    public void setPhoneCountryCode(java.lang.String phoneCountryCode) {\n        this.phoneCountryCode = phoneCountryCode;\n    }\n    /**\n     * Gets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneAreaCode\n     */\n    public java.lang.String getPhoneAreaCode() {\n        return phoneAreaCode;\n    }\n    /**\n     * Sets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneAreaCode\n     */\n    public void setPhoneAreaCode(java.lang.String phoneAreaCode) {\n        this.phoneAreaCode = phoneAreaCode;\n    }\n    /**\n     * Gets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneExchange\n     */\n    public java.lang.String getPhoneExchange() {\n        return phoneExchange;\n    }\n    /**\n     * Sets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneExchange\n     */\n    public void setPhoneExchange(java.lang.String phoneExchange) {\n        this.phoneExchange = phoneExchange;\n    }\n    /**\n     * Gets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneNumber\n     */\n    public java.lang.String getPhoneNumber() {\n        return phoneNumber;\n    }\n    /**\n     * Sets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneNumber\n     */\n    public void setPhoneNumber(java.lang.String phoneNumber) {\n        this.phoneNumber = phoneNumber;\n    }\n    /**\n     * Gets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneExtension\n     */\n    public java.lang.String getPhoneExtension() {\n        return phoneExtension;\n    }\n    /**\n     * Sets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneExtension\n     */\n    public void setPhoneExtension(java.lang.String phoneExtension) {\n        this.phoneExtension = phoneExtension;\n    }\n    /**\n     * Gets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneLastUpdateDate\n     */\n    public java.lang.String getPhoneLastUpdateDate() {\n        return phoneLastUpdateDate;\n    }\n    /**\n     * Sets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneLastUpdateDate\n     */\n    public void setPhoneLastUpdateDate(java.lang.String phoneLastUpdateDate) {\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n    }\n    /**\n     * Gets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneLastUpdateUser\n     */\n    public java.lang.String getPhoneLastUpdateUser() {\n        return phoneLastUpdateUser;\n    }\n    /**\n     * Sets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneLastUpdateUser\n     */\n    public void setPhoneLastUpdateUser(java.lang.String phoneLastUpdateUser) {\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n    }\n    /**\n     * Gets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneLastUpdateTxId\n     */\n    public java.lang.String getPhoneLastUpdateTxId() {\n        return phoneLastUpdateTxId;\n    }\n    /**\n     * Sets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneLastUpdateTxId\n     */\n    public void setPhoneLastUpdateTxId(java.lang.String phoneLastUpdateTxId) {\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n    }\n    /**\n     * Gets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @return TCRMExtension\n     */\n    public TCRMExtension getTCRMExtension() {\n        return TCRMExtension;\n    }\n    /**\n     * Sets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     * \n     * @param TCRMExtension\n     */\n    public void setTCRMExtension(TCRMExtension TCRMExtension) {\n        this.TCRMExtension = TCRMExtension;\n    }\n    /**\n     * Gets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     * \n     * @return primaryKeyBObj\n     */\n    public PrimaryKeyBObj getPrimaryKeyBObj() {\n        return primaryKeyBObj;\n    }\n    /**\n     * Sets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     * \n     * @param primaryKeyBObj\n     */\n    public void setPrimaryKeyBObj(PrimaryKeyBObj primaryKeyBObj) {\n        this.primaryKeyBObj = primaryKeyBObj;\n    }\n    /**\n     * Gets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistActionCode\n     */\n    public java.lang.String getPhoneHistActionCode() {\n        return phoneHistActionCode;\n    }\n    /**\n     * Sets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistActionCode\n     */\n    public void setPhoneHistActionCode(java.lang.String phoneHistActionCode) {\n        this.phoneHistActionCode = phoneHistActionCode;\n    }\n    /**\n     * Gets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistCreateDate\n     */\n    public java.lang.String getPhoneHistCreateDate() {\n        return phoneHistCreateDate;\n    }\n    /**\n     * Sets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistCreateDate\n     */\n    public void setPhoneHistCreateDate(java.lang.String phoneHistCreateDate) {\n        this.phoneHistCreateDate = phoneHistCreateDate;\n    }\n    /**\n     * Gets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistCreatedBy\n     */\n    public java.lang.String getPhoneHistCreatedBy() {\n        return phoneHistCreatedBy;\n    }\n    /**\n     * Sets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistCreatedBy\n     */\n    public void setPhoneHistCreatedBy(java.lang.String phoneHistCreatedBy) {\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n    }\n    /**\n     * Gets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistEndDate\n     */\n    public java.lang.String getPhoneHistEndDate() {\n        return phoneHistEndDate;\n    }\n    /**\n     * Sets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistEndDate\n     */\n    public void setPhoneHistEndDate(java.lang.String phoneHistEndDate) {\n        this.phoneHistEndDate = phoneHistEndDate;\n    }\n    /**\n     * Gets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     * \n     * @return phoneHistoryIdPK\n     */\n    public java.lang.String getPhoneHistoryIdPK() {\n        return phoneHistoryIdPK;\n    }\n    /**\n     * Sets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     * \n     * @param phoneHistoryIdPK\n     */\n    public void setPhoneHistoryIdPK(java.lang.String phoneHistoryIdPK) {\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n    }\n    /**\n     * Gets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     * \n     * @return DWLStatus\n     */\n    public DWLStatus getDWLStatus() {\n        return DWLStatus;\n    }\n    /**\n     * Sets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     * \n     * @param DWLStatus\n     */\n    public void setDWLStatus(DWLStatus DWLStatus) {\n        this.DWLStatus = DWLStatus;\n    }\n    private java.lang.Object __equalsCalc = null;\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof TCRMPhoneNumberBObjType)) return false;\n        TCRMPhoneNumberBObjType other = (TCRMPhoneNumberBObjType) obj;\n        if (obj == null) return false;\n        if (this == obj) return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = super.equals(obj) && \n            ((this.objectReferenceId==null && other.getObjectReferenceId()==null) || \n             (this.objectReferenceId!=null &&\n              this.objectReferenceId.equals(other.getObjectReferenceId()))) &&\n            ((this.phoneNumberId==null && other.getPhoneNumberId()==null) || \n             (this.phoneNumberId!=null &&\n              this.phoneNumberId.equals(other.getPhoneNumberId()))) &&\n            ((this.contactMethodId==null && other.getContactMethodId()==null) || \n             (this.contactMethodId!=null &&\n              this.contactMethodId.equals(other.getContactMethodId()))) &&\n            ((this.phoneCountryCode==null && other.getPhoneCountryCode()==null) || \n             (this.phoneCountryCode!=null &&\n              this.phoneCountryCode.equals(other.getPhoneCountryCode()))) &&\n            ((this.phoneAreaCode==null && other.getPhoneAreaCode()==null) || \n             (this.phoneAreaCode!=null &&\n              this.phoneAreaCode.equals(other.getPhoneAreaCode()))) &&\n            ((this.phoneExchange==null && other.getPhoneExchange()==null) || \n             (this.phoneExchange!=null &&\n              this.phoneExchange.equals(other.getPhoneExchange()))) &&\n            ((this.phoneNumber==null && other.getPhoneNumber()==null) || \n             (this.phoneNumber!=null &&\n              this.phoneNumber.equals(other.getPhoneNumber()))) &&\n            ((this.phoneExtension==null && other.getPhoneExtension()==null) || \n             (this.phoneExtension!=null &&\n              this.phoneExtension.equals(other.getPhoneExtension()))) &&\n            ((this.phoneLastUpdateDate==null && other.getPhoneLastUpdateDate()==null) || \n             (this.phoneLastUpdateDate!=null &&\n              this.phoneLastUpdateDate.equals(other.getPhoneLastUpdateDate()))) &&\n            ((this.phoneLastUpdateUser==null && other.getPhoneLastUpdateUser()==null) || \n             (this.phoneLastUpdateUser!=null &&\n              this.phoneLastUpdateUser.equals(other.getPhoneLastUpdateUser()))) &&\n            ((this.phoneLastUpdateTxId==null && other.getPhoneLastUpdateTxId()==null) || \n             (this.phoneLastUpdateTxId!=null &&\n              this.phoneLastUpdateTxId.equals(other.getPhoneLastUpdateTxId()))) &&\n            ((this.TCRMExtension==null && other.getTCRMExtension()==null) || \n             (this.TCRMExtension!=null &&\n              this.TCRMExtension.equals(other.getTCRMExtension()))) &&\n            ((this.primaryKeyBObj==null && other.getPrimaryKeyBObj()==null) || \n             (this.primaryKeyBObj!=null &&\n              this.primaryKeyBObj.equals(other.getPrimaryKeyBObj()))) &&\n            ((this.phoneHistActionCode==null && other.getPhoneHistActionCode()==null) || \n             (this.phoneHistActionCode!=null &&\n              this.phoneHistActionCode.equals(other.getPhoneHistActionCode()))) &&\n            ((this.phoneHistCreateDate==null && other.getPhoneHistCreateDate()==null) || \n             (this.phoneHistCreateDate!=null &&\n              this.phoneHistCreateDate.equals(other.getPhoneHistCreateDate()))) &&\n            ((this.phoneHistCreatedBy==null && other.getPhoneHistCreatedBy()==null) || \n             (this.phoneHistCreatedBy!=null &&\n              this.phoneHistCreatedBy.equals(other.getPhoneHistCreatedBy()))) &&\n            ((this.phoneHistEndDate==null && other.getPhoneHistEndDate()==null) || \n             (this.phoneHistEndDate!=null &&\n              this.phoneHistEndDate.equals(other.getPhoneHistEndDate()))) &&\n            ((this.phoneHistoryIdPK==null && other.getPhoneHistoryIdPK()==null) || \n             (this.phoneHistoryIdPK!=null &&\n              this.phoneHistoryIdPK.equals(other.getPhoneHistoryIdPK()))) &&\n            ((this.DWLStatus==null && other.getDWLStatus()==null) || \n             (this.DWLStatus!=null &&\n              this.DWLStatus.equals(other.getDWLStatus())));\n        __equalsCalc = null;\n        return _equals;\n    }\n    private boolean __hashCodeCalc = false;\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = super.hashCode();\n        if (getObjectReferenceId() != null) {\n            _hashCode += getObjectReferenceId().hashCode();\n        }\n        if (getPhoneNumberId() != null) {\n            _hashCode += getPhoneNumberId().hashCode();\n        }\n        if (getContactMethodId() != null) {\n            _hashCode += getContactMethodId().hashCode();\n        }\n        if (getPhoneCountryCode() != null) {\n            _hashCode += getPhoneCountryCode().hashCode();\n        }\n        if (getPhoneAreaCode() != null) {\n            _hashCode += getPhoneAreaCode().hashCode();\n        }\n        if (getPhoneExchange() != null) {\n            _hashCode += getPhoneExchange().hashCode();\n        }\n        if (getPhoneNumber() != null) {\n            _hashCode += getPhoneNumber().hashCode();\n        }\n        if (getPhoneExtension() != null) {\n            _hashCode += getPhoneExtension().hashCode();\n        }\n        if (getPhoneLastUpdateDate() != null) {\n            _hashCode += getPhoneLastUpdateDate().hashCode();\n        }\n        if (getPhoneLastUpdateUser() != null) {\n            _hashCode += getPhoneLastUpdateUser().hashCode();\n        }\n        if (getPhoneLastUpdateTxId() != null) {\n            _hashCode += getPhoneLastUpdateTxId().hashCode();\n        }\n        if (getTCRMExtension() != null) {\n            _hashCode += getTCRMExtension().hashCode();\n        }\n        if (getPrimaryKeyBObj() != null) {\n            _hashCode += getPrimaryKeyBObj().hashCode();\n        }\n        if (getPhoneHistActionCode() != null) {\n            _hashCode += getPhoneHistActionCode().hashCode();\n        }\n        if (getPhoneHistCreateDate() != null) {\n            _hashCode += getPhoneHistCreateDate().hashCode();\n        }\n        if (getPhoneHistCreatedBy() != null) {\n            _hashCode += getPhoneHistCreatedBy().hashCode();\n        }\n        if (getPhoneHistEndDate() != null) {\n            _hashCode += getPhoneHistEndDate().hashCode();\n        }\n        if (getPhoneHistoryIdPK() != null) {\n            _hashCode += getPhoneHistoryIdPK().hashCode();\n        }\n        if (getDWLStatus() != null) {\n            _hashCode += getDWLStatus().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc =\n        new org.apache.axis.description.TypeDesc(TCRMPhoneNumberBObjType.class, true);\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMPhoneNumberBObjType\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"objectReferenceId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ObjectReferenceId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumberId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumberId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"contactMethodId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ContactMethodId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneCountryCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneCountryCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneAreaCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneAreaCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExchange\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExchange\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumber\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumber\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateUser\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateUser\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateTxId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateTxId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"TCRMExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">TCRMExtension\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"primaryKeyBObj\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PrimaryKeyBObj\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">PrimaryKeyBObj\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistActionCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistActionCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreatedBy\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreatedBy\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistEndDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistEndDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistoryIdPK\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistoryIdPK\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"DWLStatus\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"DWLStatus\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">DWLStatus\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(\n           java.lang.String mechType, \n           java.lang.Class _javaType,  \n           javax.xml.namespace.QName _xmlType) {\n        return \n          new  org.apache.axis.encoding.ser.BeanSerializer(\n            _javaType, _xmlType, typeDesc);\n    }\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(\n           java.lang.String mechType, \n           java.lang.Class _javaType,  \n           javax.xml.namespace.QName _xmlType) {\n        return \n          new  org.apache.axis.encoding.ser.BeanDeserializer(\n            _javaType, _xmlType, typeDesc);\n    }\n"]]}
{"hexsha": "691009fba7ccb50b017dca2a77a8604c2a1e3792", "ext": "java", "lang": "Java", "content": "public class ExecSQL extends AbstractStep {\n\n\t@Override\n\tpublic void decode(StepMetaInterface stepMetaInterface, mxCell cell, List<DatabaseMeta> databases, IMetaStore metaStore) throws Exception {\n            ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n\n            String con = cell.getAttribute( \"connection\" );\n            execSQLMeta.setDatabaseMeta(DatabaseMeta.findDatabase( databases, con ));\n            execSQLMeta.setSql(StringEscapeHelper.decode(cell.getAttribute( \"sql\" )));\n\n            execSQLMeta.setExecutedEachInputRow(\"true\".equalsIgnoreCase(cell.getAttribute( \"executedEachInputRow\" )));\n            execSQLMeta.setSingleStatement(\"true\".equalsIgnoreCase(cell.getAttribute( \"singleStatement\" )));\n            execSQLMeta.setVariableReplacementActive(\"true\".equalsIgnoreCase(cell.getAttribute( \"replaceVariables\" )));\n            execSQLMeta.setParams(\"true\".equalsIgnoreCase(cell.getAttribute( \"setParams\" )));\n            execSQLMeta.setQuoteString(\"true\".equalsIgnoreCase(cell.getAttribute( \"quoteString\" )));\n                \n//\t      insertField = cell.getAttribute( \"insert_field\" );\n//\t      updateField = cell.getAttribute( \"update_field\" );\n//\t      deleteField = cell.getAttribute( \"delete_field\" );\n//\t      readField = cell.getAttribute( \"read_field\" );\n\t\t\n            JSONArray jsonArray = JSONArray.fromObject(cell.getAttribute( \"arguments\" ));\n            execSQLMeta.allocate( jsonArray.size() );\n            for(int i=0; i<jsonArray.size(); i++) {\n                JSONObject jsonObject = jsonArray.getJSONObject(i);\n                execSQLMeta.getArguments()[i] = jsonObject.optString(\"name\");\n            }\n\t}\n\n\t@Override\n\tpublic Element encode(StepMetaInterface stepMetaInterface) throws Exception {\n            ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n\n            Document doc = mxUtils.createDocument();\n            Element e = doc.createElement(\"Step\");\n\n            e.setAttribute(\"connection\", execSQLMeta.getDatabaseMeta() == null ? \"\" : execSQLMeta.getDatabaseMeta().getName());\n            e.setAttribute(\"sql\", StringEscapeHelper.encode(execSQLMeta.getSql()));\n            e.setAttribute(\"executedEachInputRow\", Boolean.toString(execSQLMeta.isExecutedEachInputRow()));\n            e.setAttribute(\"singleStatement\", Boolean.toString(execSQLMeta.isSingleStatement()));\n            e.setAttribute(\"replaceVariables\", Boolean.toString(execSQLMeta.isReplaceVariables()));\n            e.setAttribute(\"setParams\", Boolean.toString(execSQLMeta.isParams()));\n            e.setAttribute(\"quoteString\", Boolean.toString(execSQLMeta.isQuoteString()));\n\n            JSONArray arguments = new JSONArray();\n            for ( int i = 0; i < execSQLMeta.getArguments().length; i++ ) {\n                String name = execSQLMeta.getArguments()[i];\n                JSONObject jsonObject = new JSONObject();\n                jsonObject.put(\"name\", name);\n                arguments.add(jsonObject);\n            }\n            e.setAttribute(\"arguments\", arguments.toString());\n\n            return e;\n\t}\n\n}", "class_id": 0, "repo": "bioinformatics-ua/BIcenter", "file": "app/kettleExt/trans/steps/ExecSQL.java", "last_update_at": "2021-08-16T06:42:55+00:00", "question_id": "691009fba7ccb50b017dca2a77a8604c2a1e3792", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExecSQL extends AbstractStep {\n\t@Override\n\tpublic void decode(StepMetaInterface stepMetaInterface, mxCell cell, List<DatabaseMeta> databases, IMetaStore metaStore) throws Exception {\n            ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n            String con = cell.getAttribute( \"connection\" );\n            execSQLMeta.setDatabaseMeta(DatabaseMeta.findDatabase( databases, con ));\n            execSQLMeta.setSql(StringEscapeHelper.decode(cell.getAttribute( \"sql\" )));\n            execSQLMeta.setExecutedEachInputRow(\"true\".equalsIgnoreCase(cell.getAttribute( \"executedEachInputRow\" )));\n            execSQLMeta.setSingleStatement(\"true\".equalsIgnoreCase(cell.getAttribute( \"singleStatement\" )));\n            execSQLMeta.setVariableReplacementActive(\"true\".equalsIgnoreCase(cell.getAttribute( \"replaceVariables\" )));\n            execSQLMeta.setParams(\"true\".equalsIgnoreCase(cell.getAttribute( \"setParams\" )));\n            execSQLMeta.setQuoteString(\"true\".equalsIgnoreCase(cell.getAttribute( \"quoteString\" )));\n//\t      insertField = cell.getAttribute( \"insert_field\" );\n//\t      updateField = cell.getAttribute( \"update_field\" );\n//\t      deleteField = cell.getAttribute( \"delete_field\" );\n//\t      readField = cell.getAttribute( \"read_field\" );\n\t\t\n            JSONArray jsonArray = JSONArray.fromObject(cell.getAttribute( \"arguments\" ));\n            execSQLMeta.allocate( jsonArray.size() );\n            for(int i=0; i<jsonArray.size(); i++) {\n                JSONObject jsonObject = jsonArray.getJSONObject(i);\n                execSQLMeta.getArguments()[i] = jsonObject.optString(\"name\");\n            }\n\t}\n\t@Override\n\tpublic Element encode(StepMetaInterface stepMetaInterface) throws Exception {\n            ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n            Document doc = mxUtils.createDocument();\n            Element e = doc.createElement(\"Step\");\n            e.setAttribute(\"connection\", execSQLMeta.getDatabaseMeta() == null ? \"\" : execSQLMeta.getDatabaseMeta().getName());\n            e.setAttribute(\"sql\", StringEscapeHelper.encode(execSQLMeta.getSql()));\n            e.setAttribute(\"executedEachInputRow\", Boolean.toString(execSQLMeta.isExecutedEachInputRow()));\n            e.setAttribute(\"singleStatement\", Boolean.toString(execSQLMeta.isSingleStatement()));\n            e.setAttribute(\"replaceVariables\", Boolean.toString(execSQLMeta.isReplaceVariables()));\n            e.setAttribute(\"setParams\", Boolean.toString(execSQLMeta.isParams()));\n            e.setAttribute(\"quoteString\", Boolean.toString(execSQLMeta.isQuoteString()));\n            JSONArray arguments = new JSONArray();\n            for ( int i = 0; i < execSQLMeta.getArguments().length; i++ ) {\n                String name = execSQLMeta.getArguments()[i];\n                JSONObject jsonObject = new JSONObject();\n                jsonObject.put(\"name\", name);\n                arguments.add(jsonObject);\n            }\n            e.setAttribute(\"arguments\", arguments.toString());\n            return e;\n\t}\n"]]}
{"hexsha": "5241f583035803403a5ac7cfdbb3662fe1b799f8", "ext": "java", "lang": "Java", "content": "public class MainActivity extends AppCompatActivity implements MessageSignatureResultReceiver.Receiver {\n\n    private static final String TAG_FRAGMENT_MAIN = \"TAG_FRAGMENT_MAIN\";\n    public static final String TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS = \"TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS\";\n\n    private MessageSignatureResultReceiver resultReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        pullMainFragment();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // register the result receiver to get the Message Signature back from the server\n        registerResultReceiver();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void pullMainFragment(){\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        MainFragment mainFragment = (MainFragment)\n                fragmentManager.findFragmentByTag(TAG_FRAGMENT_MAIN);\n        if(mainFragment == null) {\n            mainFragment = new MainFragment();\n            fragmentManager.beginTransaction()\n                    .replace(R.id.web_checkout_fragment_container, mainFragment, TAG_FRAGMENT_MAIN)\n                    .commit();\n        }\n    }\n\n    private void registerResultReceiver() {\n        if(resultReceiver != null)\n            return;\n        resultReceiver = new MessageSignatureResultReceiver(new Handler());\n        resultReceiver.setReceiver(this);\n    }\n\n    @Override\n    public void onReceiveResult(int resultCode, Bundle resultData) {\n/*        switch (resultCode){\n            case MessageSignatureService.SERVICE_RESULT_CODE_SDK_RESPONSE:\n                SDKGatewayResponse response = (SDKGatewayResponse) resultData\n                        .getParcelable(MessageSignatureService.SERVICE_RESULT_RESPONSE_KEY);\n                break;\n            case MessageSignatureService.SERVICE_RESULT_CODE_SDK_ERROR:\n                SDKError error = (SDKError) resultData\n                        .getSerializable(MessageSignatureService.SERVICE_RESULT_ERROR_KEY);\n                break;\n        }*/\n    }\n\n    //send the result to OnActivityResult defined in the fragments attached to the Activity\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        for (Fragment fragment : getSupportFragmentManager().getFragments()) {\n            fragment.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n}", "class_id": 0, "repo": "samerzmd/cybersource-android-samples", "file": "app/src/main/java/com/cybersource/webcheckout/MainActivity.java", "last_update_at": "2021-11-09T21:07:11+00:00", "question_id": "5241f583035803403a5ac7cfdbb3662fe1b799f8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainActivity extends AppCompatActivity implements MessageSignatureResultReceiver.Receiver {\n    private static final String TAG_FRAGMENT_MAIN = \"TAG_FRAGMENT_MAIN\";\n    public static final String TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS = \"TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS\";\n    private MessageSignatureResultReceiver resultReceiver;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        pullMainFragment();\n    }\n    @Override\n    public void onResume() {\n        super.onResume();\n        // register the result receiver to get the Message Signature back from the server\n        registerResultReceiver();\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        return true;\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    private void pullMainFragment(){\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        MainFragment mainFragment = (MainFragment)\n                fragmentManager.findFragmentByTag(TAG_FRAGMENT_MAIN);\n        if(mainFragment == null) {\n            mainFragment = new MainFragment();\n            fragmentManager.beginTransaction()\n                    .replace(R.id.web_checkout_fragment_container, mainFragment, TAG_FRAGMENT_MAIN)\n                    .commit();\n        }\n    }\n    private void registerResultReceiver() {\n        if(resultReceiver != null)\n            return;\n        resultReceiver = new MessageSignatureResultReceiver(new Handler());\n        resultReceiver.setReceiver(this);\n    }\n    @Override\n    public void onReceiveResult(int resultCode, Bundle resultData) {\n/*        switch (resultCode){\n            case MessageSignatureService.SERVICE_RESULT_CODE_SDK_RESPONSE:\n                SDKGatewayResponse response = (SDKGatewayResponse) resultData\n                        .getParcelable(MessageSignatureService.SERVICE_RESULT_RESPONSE_KEY);\n                break;\n            case MessageSignatureService.SERVICE_RESULT_CODE_SDK_ERROR:\n                SDKError error = (SDKError) resultData\n                        .getSerializable(MessageSignatureService.SERVICE_RESULT_ERROR_KEY);\n                break;\n        }*/\n    }\n    //send the result to OnActivityResult defined in the fragments attached to the Activity\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        for (Fragment fragment : getSupportFragmentManager().getFragments()) {\n            fragment.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n"]]}
{"hexsha": "276f9bf06fd9cdddd7881eec84d2337ed1845efa", "ext": "java", "lang": "Java", "content": "public abstract class Commands {\r\n\r\n\tprivate static final Command ROOT = new RootCommand();\r\n\tprivate static final Command[] SUB = new Command[] {\r\n\t\tnew HelpCommand(),\r\n\t\tnew SplitCommand(),\r\n\t\tnew JoinCommand(),\r\n\t};\r\n\r\n\tpublic static Command rootCommand() {\r\n\t\treturn ROOT;\r\n\t}\r\n\r\n\tpublic static Command[] subCommands() {\r\n\t\treturn SUB;\r\n\t}\r\n\r\n\tpublic static List<String> names() {\r\n\t\tList<String> n = new ArrayList<String>();\r\n\t\tfor(Command c : subCommands())\r\n\t\t\tn.add(c.getName());\r\n\t\treturn n;\r\n\t}\r\n\r\n\tpublic static Command forName(String name) {\r\n\t\tfor(Command c : subCommands())\r\n\t\t\tif(name.equals(c.getName()))\r\n\t\t\t\treturn c;\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate Commands() {}\r\n}", "class_id": 0, "repo": "cristicmf/secretsharing", "file": "secret-sharing-cli/src/main/java/org/mitre/secretsharing/cli/cmd/Commands.java", "last_update_at": "2021-09-17T01:47:44+00:00", "question_id": "276f9bf06fd9cdddd7881eec84d2337ed1845efa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class Commands {\r\n\r\n\tprivate static final Command ROOT = new RootCommand();\r\n\tprivate static final Command[] SUB = new Command[] {\r\n\t\tnew HelpCommand(),\r\n\t\tnew SplitCommand(),\r\n\t\tnew JoinCommand(),\r\n\t};\r\n\r\n\tpublic static Command rootCommand() {\r\n\t\treturn ROOT;\r\n\t}\r\n\r\n\tpublic static Command[] subCommands() {\r\n\t\treturn SUB;\r\n\t}\r\n\r\n\tpublic static List<String> names() {\r\n\t\tList<String> n = new ArrayList<String>();\r\n\t\tfor(Command c : subCommands())\r\n\t\t\tn.add(c.getName());\r\n\t\treturn n;\r\n\t}\r\n\r\n\tpublic static Command forName(String name) {\r\n\t\tfor(Command c : subCommands())\r\n\t\t\tif(name.equals(c.getName()))\r\n\t\t\t\treturn c;\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate Commands() {}\r\n"]]}
{"hexsha": "a0b3fec9ca0c28a20691df8528413edb7042e26c", "ext": "java", "lang": "Java", "content": "public class MainApp {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tApplicationContext appContext = new ClassPathXmlApplicationContext(\"Spring-Customer.xml\");\n\t\t\n\t\tCustomer customer = (Customer) appContext.getBean(\"custom\");\n\t\t\n\t\tcustomer.addCustomer();\n\t\t\n\t\tcustomer.addCustomerReturnValue();\n\t\t\n\t\tcustomer.addCustomerThrowException();\n\t\t\n\t\tcustomer.addCustomerAround(\"mkyong\");\n\n\t}\n\n}", "class_id": 0, "repo": "jasonwee/videoOnCloud", "file": "src/java/play/learn/java/aspectj/core/MainApp.java", "last_update_at": "2021-12-07T03:39:58+00:00", "question_id": "a0b3fec9ca0c28a20691df8528413edb7042e26c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainApp {\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tApplicationContext appContext = new ClassPathXmlApplicationContext(\"Spring-Customer.xml\");\n\t\t\n\t\tCustomer customer = (Customer) appContext.getBean(\"custom\");\n\t\t\n\t\tcustomer.addCustomer();\n\t\t\n\t\tcustomer.addCustomerReturnValue();\n\t\t\n\t\tcustomer.addCustomerThrowException();\n\t\t\n\t\tcustomer.addCustomerAround(\"mkyong\");\n\t}\n"]]}
{"hexsha": "e8e3c4b4e355e51e7e75ddb9456fe63248f39294", "ext": "java", "lang": "Java", "content": "public class ModifiableHToolbar extends BasicHToolbar {\n\n  protected final HBox modifyMLeftSection = new HBox();\n  protected final HBox modifyMCenterSection = new HBox();\n  protected final HBox modifyMRightSection = new HBox();\n  protected final HBox modifyingActionsWrapper = new HBox();\n\n  protected final Button modifyButton = new Button();\n  protected final Button doneButton = new Button();\n\n\n  /**\n   * Constructor\n   */\n  public ModifiableHToolbar() {\n    super();\n    NodeHelper.setHgrow(allOverWrapper);\n\n    modifyingActionsWrapper.getStyleClass().add(\"ep-modifying-toolbar\");\n    rootContainer.getStyleClass().add(\"ep-modifiable-toolbar\");\n    modifyMLeftSection.getStyleClass().add(\"ep-modifying-toolbar-left\");\n    modifyMCenterSection.getStyleClass().add(\"ep-modifying-toolbar-center\");\n    modifyMRightSection.getStyleClass().add(\"ep-modifying-toolbar-right\");\n  }\n\n\n  /**\n   * @{inheritedDoc}\n   */\n  @Override\n  public void buildFrom(AbstractViewController controller, IToolbarHolder toolbarHolder) {\n    super.buildFrom(controller, toolbarHolder);\n    buildModifyActions();\n\n    final String styleClass = configuration.getPropertyValue(\"modifyingActionsStyleClass\");\n    if (io.github.jsoagger.core.utils.StringUtils.isNotBlank(styleClass)) {\n      modifyingActionsWrapper.getStyleClass().addAll(styleClass.split(\",\"));\n    }\n  }\n\n\n  /**\n   * Modify menu configuration is menu displayed when the user clicked on modify button on the\n   * displayed toolbar.\n   * <p>\n   * If no modify menu is provided, the modify button is not displayed.\n   * <p>\n   */\n  private void buildModifyActions() {\n    if (modifyMenuConfiguration != null) {\n\n      // build left side actions\n      final VLViewComponentXML leftActions = modifyMenuConfiguration.getComponentById(\"LeftActions\").orElse(null);\n      if (leftActions != null) {\n        final List<IBuildable> buildables = buildActionGroup(leftActions);\n        for(IBuildable node: buildables) {\n          modifyMLeftSection.getChildren().add(node.getDisplay());\n        }\n        modifyingActionsWrapper.getChildren().addAll(modifyMLeftSection);\n      }\n\n      // build center actions\n      final VLViewComponentXML centerActions = modifyMenuConfiguration.getComponentById(\"CenterActions\").orElse(null);\n      if (centerActions != null) {\n        final List<IBuildable> buildables = buildActionGroup(centerActions);\n        for(IBuildable node: buildables) {\n          modifyMCenterSection.getChildren().add(node.getDisplay());\n        }\n\n        if (modifyingActionsWrapper.getChildren().size() > 0) {\n          modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n        }\n\n        modifyingActionsWrapper.getChildren().addAll(modifyMCenterSection);\n      }\n\n      final VLViewComponentXML rightActions = modifyMenuConfiguration.getComponentById(\"RightActions\").orElse(null);\n      if (rightActions != null) {\n        final List<IBuildable> buildables = buildActionGroup(rightActions);\n        for(IBuildable node: buildables) {\n          modifyMRightSection.getChildren().add(node.getDisplay());\n        }\n\n        if (modifyingActionsWrapper.getChildren().size() > 0) {\n          modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n        }\n\n        modifyingActionsWrapper.getChildren().addAll(modifyMRightSection);\n      }\n    }\n\n    allOverWrapper.visibleProperty().bind(Bindings.not(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty()));\n    allOverWrapper.managedProperty().bind(allOverWrapper.visibleProperty());\n\n    buildModifyButton();\n    buildDoneButton();\n  }\n\n\n  /**\n   * Build the modify button.\n   */\n  private void buildModifyButton() {\n    modifyButton.getStyleClass().addAll(\"table-toolbar-action\", \"ep-button\");\n    modifyButton.setOnAction(e -> modifyClicked(controller));\n    modifyButton.setText(controller.getGLocalised(\"EDIT_LABEL\").toUpperCase());\n    IconUtils.setFontIcon(\"gmi-more-horiz:18\", modifyButton);\n\n    allOverWrapper.getChildren().add(modifyButton);\n    if (selectable.get()) {\n      //thickButton.setOnAction(e -> thickClicked());\n      //modifyingActionsWrapper.getChildren().add(0, thickButton);\n    }\n\n    NodeHelper.setHgrow(modifyingActionsWrapper);\n    modifyingActionsWrapper.visibleProperty().bind(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty());\n    modifyingActionsWrapper.managedProperty().bind(modifyingActionsWrapper.visibleProperty());\n    rootContainer.getChildren().add(modifyingActionsWrapper);\n  }\n\n\n  /**\n   * Build done button\n   */\n  private void buildDoneButton() {\n    doneButton.getStyleClass().addAll(\"button-small\", \"table-toolbar-action\", \"ep-button\");\n    doneButton.setOnAction(e -> modifyClicked(controller));\n    doneButton.setText(controller.getGLocalised(\"DONE_LABEL\").toUpperCase());\n    IconUtils.setFontIcon(\"fa-check:16\", doneButton);\n    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer(), doneButton);\n  }\n\n\n  /**\n   * @param controller\n   */\n  protected void modifyClicked(AbstractViewController controller) {\n    if (!((IModifiableToolbarHolder) toolbarHolder).isModifying()) {\n      thickButton.setSelected(false);\n      ((IModifiableToolbarHolder) toolbarHolder).setModifying(true);\n      //modifyButton.setText(controller.getLocalised(\"Done\"));\n\n      // show all selectors\n      ((IModifiableToolbarHolder) toolbarHolder).modify();\n\n      // reinit thick button\n      isThicked = true;\n      thickClicked();\n    }\n\n    else {\n      ((IModifiableToolbarHolder) toolbarHolder).setModifying(false);\n      // modifyButton.setText(null);\n\n      // hide all selectors\n      ((IModifiableToolbarHolder) toolbarHolder).cancelModify();\n    }\n  }\n\n\n  /**\n   * Called when a checkbox or a listcell is clicked.\n   */\n  public void listCellSelected() {\n    isThicked = false;\n    thickButton.setSelected(false);\n  }\n}", "class_id": 0, "repo": "jsoagger/jsoagger-fx", "file": "jsoagger-jfxcore-engine/src/main/java/io/github/jsoagger/jfxcore/engine/components/toolbar/htoolbar/ModifiableHToolbar.java", "last_update_at": "2021-09-26T10:22:13+00:00", "question_id": "e8e3c4b4e355e51e7e75ddb9456fe63248f39294", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModifiableHToolbar extends BasicHToolbar {\n  protected final HBox modifyMLeftSection = new HBox();\n  protected final HBox modifyMCenterSection = new HBox();\n  protected final HBox modifyMRightSection = new HBox();\n  protected final HBox modifyingActionsWrapper = new HBox();\n  protected final Button modifyButton = new Button();\n  protected final Button doneButton = new Button();\n  /**\n   * Constructor\n   */\n  public ModifiableHToolbar() {\n    super();\n    NodeHelper.setHgrow(allOverWrapper);\n    modifyingActionsWrapper.getStyleClass().add(\"ep-modifying-toolbar\");\n    rootContainer.getStyleClass().add(\"ep-modifiable-toolbar\");\n    modifyMLeftSection.getStyleClass().add(\"ep-modifying-toolbar-left\");\n    modifyMCenterSection.getStyleClass().add(\"ep-modifying-toolbar-center\");\n    modifyMRightSection.getStyleClass().add(\"ep-modifying-toolbar-right\");\n  }\n  /**\n   * @{inheritedDoc}\n   */\n  @Override\n  public void buildFrom(AbstractViewController controller, IToolbarHolder toolbarHolder) {\n    super.buildFrom(controller, toolbarHolder);\n    buildModifyActions();\n    final String styleClass = configuration.getPropertyValue(\"modifyingActionsStyleClass\");\n    if (io.github.jsoagger.core.utils.StringUtils.isNotBlank(styleClass)) {\n      modifyingActionsWrapper.getStyleClass().addAll(styleClass.split(\",\"));\n    }\n  }\n  /**\n   * Modify menu configuration is menu displayed when the user clicked on modify button on the\n   * displayed toolbar.\n   * <p>\n   * If no modify menu is provided, the modify button is not displayed.\n   * <p>\n   */\n  private void buildModifyActions() {\n    if (modifyMenuConfiguration != null) {\n      // build left side actions\n      final VLViewComponentXML leftActions = modifyMenuConfiguration.getComponentById(\"LeftActions\").orElse(null);\n      if (leftActions != null) {\n        final List<IBuildable> buildables = buildActionGroup(leftActions);\n        for(IBuildable node: buildables) {\n          modifyMLeftSection.getChildren().add(node.getDisplay());\n        }\n        modifyingActionsWrapper.getChildren().addAll(modifyMLeftSection);\n      }\n      // build center actions\n      final VLViewComponentXML centerActions = modifyMenuConfiguration.getComponentById(\"CenterActions\").orElse(null);\n      if (centerActions != null) {\n        final List<IBuildable> buildables = buildActionGroup(centerActions);\n        for(IBuildable node: buildables) {\n          modifyMCenterSection.getChildren().add(node.getDisplay());\n        }\n        if (modifyingActionsWrapper.getChildren().size() > 0) {\n          modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n        }\n        modifyingActionsWrapper.getChildren().addAll(modifyMCenterSection);\n      }\n      final VLViewComponentXML rightActions = modifyMenuConfiguration.getComponentById(\"RightActions\").orElse(null);\n      if (rightActions != null) {\n        final List<IBuildable> buildables = buildActionGroup(rightActions);\n        for(IBuildable node: buildables) {\n          modifyMRightSection.getChildren().add(node.getDisplay());\n        }\n        if (modifyingActionsWrapper.getChildren().size() > 0) {\n          modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n        }\n        modifyingActionsWrapper.getChildren().addAll(modifyMRightSection);\n      }\n    }\n    allOverWrapper.visibleProperty().bind(Bindings.not(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty()));\n    allOverWrapper.managedProperty().bind(allOverWrapper.visibleProperty());\n    buildModifyButton();\n    buildDoneButton();\n  }\n  /**\n   * Build the modify button.\n   */\n  private void buildModifyButton() {\n    modifyButton.getStyleClass().addAll(\"table-toolbar-action\", \"ep-button\");\n    modifyButton.setOnAction(e -> modifyClicked(controller));\n    modifyButton.setText(controller.getGLocalised(\"EDIT_LABEL\").toUpperCase());\n    IconUtils.setFontIcon(\"gmi-more-horiz:18\", modifyButton);\n    allOverWrapper.getChildren().add(modifyButton);\n    if (selectable.get()) {\n      //thickButton.setOnAction(e -> thickClicked());\n      //modifyingActionsWrapper.getChildren().add(0, thickButton);\n    }\n    NodeHelper.setHgrow(modifyingActionsWrapper);\n    modifyingActionsWrapper.visibleProperty().bind(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty());\n    modifyingActionsWrapper.managedProperty().bind(modifyingActionsWrapper.visibleProperty());\n    rootContainer.getChildren().add(modifyingActionsWrapper);\n  }\n  /**\n   * Build done button\n   */\n  private void buildDoneButton() {\n    doneButton.getStyleClass().addAll(\"button-small\", \"table-toolbar-action\", \"ep-button\");\n    doneButton.setOnAction(e -> modifyClicked(controller));\n    doneButton.setText(controller.getGLocalised(\"DONE_LABEL\").toUpperCase());\n    IconUtils.setFontIcon(\"fa-check:16\", doneButton);\n    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer(), doneButton);\n  }\n  /**\n   * @param controller\n   */\n  protected void modifyClicked(AbstractViewController controller) {\n    if (!((IModifiableToolbarHolder) toolbarHolder).isModifying()) {\n      thickButton.setSelected(false);\n      ((IModifiableToolbarHolder) toolbarHolder).setModifying(true);\n      //modifyButton.setText(controller.getLocalised(\"Done\"));\n      // show all selectors\n      ((IModifiableToolbarHolder) toolbarHolder).modify();\n      // reinit thick button\n      isThicked = true;\n      thickClicked();\n    }\n    else {\n      ((IModifiableToolbarHolder) toolbarHolder).setModifying(false);\n      // modifyButton.setText(null);\n      // hide all selectors\n      ((IModifiableToolbarHolder) toolbarHolder).cancelModify();\n    }\n  }\n  /**\n   * Called when a checkbox or a listcell is clicked.\n   */\n  public void listCellSelected() {\n    isThicked = false;\n    thickButton.setSelected(false);\n  }\n"]]}
{"hexsha": "e040e3b45ccd4ca8119c5d2712b3808c26c479df", "ext": "java", "lang": "Java", "content": "public class UI {\n\n    public static float windowWidth;\n    public static float windowHeight;\n\n    private static float newWindowHeight = -1;\n    private static float newWindowWidth = -1;\n\n    protected static CopyOnWriteArrayList<Widget> components = new CopyOnWriteArrayList<>();\n\n    private static Queue<Runnable> imguiThread = new ConcurrentLinkedQueue<>();\n\n    private static boolean async;\n    private static WindowResizeEvent resizeEvent;\n    protected static LongAdder globalCounter = new LongAdder();\n    protected static float tabBottomBorderOffset = 7.1f;\n    private static Application app;\n    protected static JImFontAtlas fonts;\n\n    private static ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<>();\n\n    private static SerializableConsumer<WindowResizeEvent> resizeEventSerializableConsumer;\n\n    private static boolean readyCalledFlag;\n    private static String windowTitle;\n\n    private static void init(Application app, Runnable r) {\n        JniLoader.load();\n        JImGuiUtil.cacheStringToBytes();\n        try (JImGui jimgui = new JImGui(app.getWidth(), app.getHeight(), app.getTitle())) {\n\n            UI.windowHeight = app.getHeight();\n            UI.windowWidth = app.getWidth();\n\n            windowTitle = app.getTitle();\n            resizeEvent = new WindowResizeEvent(windowWidth, windowHeight, windowWidth, windowHeight);\n\n            app.setupTheme(jimgui);\n            Window.globalXPadding = jimgui.getStyle().getWindowPaddingX();\n            Window.globalYPadding = jimgui.getStyle().getWindowPaddingY();\n\n            fonts = jimgui.getIO().getFonts();\n            fonts.addDefaultFont();\n            app.loadFonts(fonts);\n            r.run();\n\n            while (!jimgui.windowShouldClose()) {\n\n                if (!app.getTitle().equals(windowTitle)) {\n                    jimgui.setWindowTitle(new JImStr(app.getTitle()));\n                    windowTitle = app.getTitle();\n                }\n\n                float newY = jimgui.getPlatformWindowSizeY();\n                float newX = jimgui.getPlatformWindowSizeX();\n\n                //window resize event\n                if (newY != windowHeight || newX != windowWidth) {\n\n                    resizeEvent.setOldHeight(windowHeight);\n                    resizeEvent.setOldWidth(windowWidth);\n                    resizeEvent.setNewHeight(newY);\n                    resizeEvent.setNewWidth(newX);\n\n                    UI.windowHeight = jimgui.getPlatformWindowSizeY();\n                    UI.windowWidth = jimgui.getPlatformWindowSizeX();\n                    Window.reApplyRelativeSize();\n                    Popup.reApplyRelativeSize();\n                    Notification.reApplyAlignmenToAll();\n                    if (resizeEventSerializableConsumer != null) {\n\n                        resizeEventSerializableConsumer.accept(resizeEvent);\n                    }\n                }\n                //window size programatically changed\n                if (newWindowHeight > -1 || newWindowWidth > -1) {\n\n                    jimgui.setPlatformWindowSize(newWindowWidth, newWindowHeight);\n                    newWindowHeight = -1;\n                    newWindowWidth = -1;\n                }\n                jimgui.initNewFrame();\n\n                process(jimgui);\n\n                jimgui.render();\n                if (!readyCalledFlag) {\n                    if (app.getReady() != null) {\n                        app.getReady().run();\n                    }\n                    readyCalledFlag = true;\n                }\n            }\n        }\n    }\n\n    public static void render(Runnable r) {\n        app = new Application(\"flui\", 1200, 700);\n        init(app, r);\n    }\n\n    public static void render(Application app, Runnable r) {\n        init(app, r);\n    }\n\n    public static void renderAsync(Runnable r) {\n        async = true;\n        app = new Application(\"flui\", 1200, 700);\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n\n    }\n\n    public static void renderAsync(Application app, Runnable r) {\n        async = true;\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n\n    }\n\n    public static void setWindowSize(float w, float h) {\n        if (async) {\n            runLater(() -> {\n                newWindowHeight = h;\n                newWindowWidth = w;\n            });\n        } else {\n            newWindowHeight = h;\n            newWindowWidth = w;\n        }\n    }\n\n    public static void setWindowWidth(float w) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(w, windowHeight);\n            });\n        } else {\n            setWindowSize(w, windowHeight);\n        }\n    }\n\n    public static void setWindowHeight(float h) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(windowWidth, h);\n            });\n        } else {\n            setWindowSize(windowWidth, h);\n        }\n    }\n\n    public static void onWindowResize(SerializableConsumer<WindowResizeEvent> e) {\n        resizeEventSerializableConsumer = e;\n\n    }\n\n    protected static void addID(String id) {\n        ids.add(id);\n    }\n\n    protected static boolean idExists(String id) {\n        return (ids.contains(id));\n    }\n\n    protected static void add(Widget w) {\n        if (idExists(w.id)) {\n            System.err.println(\"ERROR: '\" + w.id + \"' has already been used as an identifier, ID's must be unique!\");\n            throw new RuntimeException(\"Duplicate ID : \" + w.id);\n        }\n        addID(w.id);\n        components.add(w);\n    }\n\n    public static void runLater(Runnable r) {\n        imguiThread.add(r);\n    }\n\n    protected static void process(JImGui imgui) {\n\n        for (int i = 0; i < components.size(); i++) {\n            components.get(i).render(imgui);\n        }\n        Iterator<Runnable> it = imguiThread.iterator();\n        while (it.hasNext()) {\n            Runnable r = it.next();\n\n            try {\n                r.run();\n            } catch (Exception e) {\n            }\n            it.remove();\n        }\n    }\n}", "class_id": 0, "repo": "newk5/flui", "file": "src/main/java/com/github/newk5/flui/widgets/UI.java", "last_update_at": "2021-11-09T11:10:17+00:00", "question_id": "e040e3b45ccd4ca8119c5d2712b3808c26c479df", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UI {\n    public static float windowWidth;\n    public static float windowHeight;\n    private static float newWindowHeight = -1;\n    private static float newWindowWidth = -1;\n    protected static CopyOnWriteArrayList<Widget> components = new CopyOnWriteArrayList<>();\n    private static Queue<Runnable> imguiThread = new ConcurrentLinkedQueue<>();\n    private static boolean async;\n    private static WindowResizeEvent resizeEvent;\n    protected static LongAdder globalCounter = new LongAdder();\n    protected static float tabBottomBorderOffset = 7.1f;\n    private static Application app;\n    protected static JImFontAtlas fonts;\n    private static ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<>();\n    private static SerializableConsumer<WindowResizeEvent> resizeEventSerializableConsumer;\n    private static boolean readyCalledFlag;\n    private static String windowTitle;\n    private static void init(Application app, Runnable r) {\n        JniLoader.load();\n        JImGuiUtil.cacheStringToBytes();\n        try (JImGui jimgui = new JImGui(app.getWidth(), app.getHeight(), app.getTitle())) {\n            UI.windowHeight = app.getHeight();\n            UI.windowWidth = app.getWidth();\n            windowTitle = app.getTitle();\n            resizeEvent = new WindowResizeEvent(windowWidth, windowHeight, windowWidth, windowHeight);\n            app.setupTheme(jimgui);\n            Window.globalXPadding = jimgui.getStyle().getWindowPaddingX();\n            Window.globalYPadding = jimgui.getStyle().getWindowPaddingY();\n            fonts = jimgui.getIO().getFonts();\n            fonts.addDefaultFont();\n            app.loadFonts(fonts);\n            r.run();\n            while (!jimgui.windowShouldClose()) {\n                if (!app.getTitle().equals(windowTitle)) {\n                    jimgui.setWindowTitle(new JImStr(app.getTitle()));\n                    windowTitle = app.getTitle();\n                }\n                float newY = jimgui.getPlatformWindowSizeY();\n                float newX = jimgui.getPlatformWindowSizeX();\n                //window resize event\n                if (newY != windowHeight || newX != windowWidth) {\n                    resizeEvent.setOldHeight(windowHeight);\n                    resizeEvent.setOldWidth(windowWidth);\n                    resizeEvent.setNewHeight(newY);\n                    resizeEvent.setNewWidth(newX);\n                    UI.windowHeight = jimgui.getPlatformWindowSizeY();\n                    UI.windowWidth = jimgui.getPlatformWindowSizeX();\n                    Window.reApplyRelativeSize();\n                    Popup.reApplyRelativeSize();\n                    Notification.reApplyAlignmenToAll();\n                    if (resizeEventSerializableConsumer != null) {\n                        resizeEventSerializableConsumer.accept(resizeEvent);\n                    }\n                }\n                //window size programatically changed\n                if (newWindowHeight > -1 || newWindowWidth > -1) {\n                    jimgui.setPlatformWindowSize(newWindowWidth, newWindowHeight);\n                    newWindowHeight = -1;\n                    newWindowWidth = -1;\n                }\n                jimgui.initNewFrame();\n                process(jimgui);\n                jimgui.render();\n                if (!readyCalledFlag) {\n                    if (app.getReady() != null) {\n                        app.getReady().run();\n                    }\n                    readyCalledFlag = true;\n                }\n            }\n        }\n    }\n    public static void render(Runnable r) {\n        app = new Application(\"flui\", 1200, 700);\n        init(app, r);\n    }\n    public static void render(Application app, Runnable r) {\n        init(app, r);\n    }\n    public static void renderAsync(Runnable r) {\n        async = true;\n        app = new Application(\"flui\", 1200, 700);\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n    }\n    public static void renderAsync(Application app, Runnable r) {\n        async = true;\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n    }\n    public static void setWindowSize(float w, float h) {\n        if (async) {\n            runLater(() -> {\n                newWindowHeight = h;\n                newWindowWidth = w;\n            });\n        } else {\n            newWindowHeight = h;\n            newWindowWidth = w;\n        }\n    }\n    public static void setWindowWidth(float w) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(w, windowHeight);\n            });\n        } else {\n            setWindowSize(w, windowHeight);\n        }\n    }\n    public static void setWindowHeight(float h) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(windowWidth, h);\n            });\n        } else {\n            setWindowSize(windowWidth, h);\n        }\n    }\n    public static void onWindowResize(SerializableConsumer<WindowResizeEvent> e) {\n        resizeEventSerializableConsumer = e;\n    }\n    protected static void addID(String id) {\n        ids.add(id);\n    }\n    protected static boolean idExists(String id) {\n        return (ids.contains(id));\n    }\n    protected static void add(Widget w) {\n        if (idExists(w.id)) {\n            System.err.println(\"ERROR: '\" + w.id + \"' has already been used as an identifier, ID's must be unique!\");\n            throw new RuntimeException(\"Duplicate ID : \" + w.id);\n        }\n        addID(w.id);\n        components.add(w);\n    }\n    public static void runLater(Runnable r) {\n        imguiThread.add(r);\n    }\n    protected static void process(JImGui imgui) {\n        for (int i = 0; i < components.size(); i++) {\n            components.get(i).render(imgui);\n        }\n        Iterator<Runnable> it = imguiThread.iterator();\n        while (it.hasNext()) {\n            Runnable r = it.next();\n            try {\n                r.run();\n            } catch (Exception e) {\n            }\n            it.remove();\n        }\n    }\n"]]}
{"hexsha": "f56c1a6cd5b055c9b2e29a48257b31e8faab04f5", "ext": "java", "lang": "Java", "content": "class Main {\n  public static void main(String[] args) {\n    ArrayList<String> input = new ArrayList<String>();\n    input.add(\"Hello\");\n    input.add(\"World!\");\n    Executor<String> executor = new Executor<String>(new Day0Solution(), input);\n    executor.run(args);\n  }\n}", "class_id": 0, "repo": "tcollier/aoc_solver", "file": "2000/01/Main.java", "last_update_at": "2021-12-14T18:42:45+00:00", "question_id": "f56c1a6cd5b055c9b2e29a48257b31e8faab04f5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Main {\n  public static void main(String[] args) {\n    ArrayList<String> input = new ArrayList<String>();\n    input.add(\"Hello\");\n    input.add(\"World!\");\n    Executor<String> executor = new Executor<String>(new Day0Solution(), input);\n    executor.run(args);\n  }\n"]]}
{"hexsha": "43bc2c085e6a2cac1f9ce49766096d0942154236", "ext": "java", "lang": "Java", "content": "public class ExclusiveFilterSetTest {\n    @Test\n    public void constructor_null_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> new ExclusiveFilterSet<String>(null));\n    }\n\n    @Test\n    public void hasAny() {\n        // EP 1: Fully contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n\n        // EP 2: Partially contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n\n    @Test\n    public void hasAll() {\n        // EP 1: Has All\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_ABC));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n\n        // EP 2: Has Some\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AC));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n\n    @Test\n    public void add() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n\n        // EP 1: Empty\n        filterSet.add(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n\n        // EP 2: Not Empty\n        filterSet.add(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n\n        // EP 3: Duplicate\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.add(null));\n    }\n\n    @Test\n    public void remove() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(\n                TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n\n        // EP 1: Has Multiple\n        filterSet.remove(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n\n        filterSet.remove(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n\n        // EP 2: Has One\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n\n        // EP 3: Empty\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n\n        // EP 4: null\n        filterSet.remove(null);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n    }\n\n    @Test\n    public void addAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n\n        // EP 1: Empty\n        filterSet.addAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n\n        // EP 2: Not Empty\n        filterSet.addAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n\n        // EP 3: Duplicate\n        filterSet.addAll(TypicalFilters.SET_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.addAll((FilterSet<String>) null));\n    }\n\n    @Test\n    public void removeAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(\n                TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n\n        // EP 1: Has Multiple\n        filterSet.removeAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n\n        // EP 2: Has One\n        filterSet.removeAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n\n        // EP 3: Empty\n        filterSet.removeAll(TypicalFilters.SET_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.removeAll((FilterSet<String>) null));\n    }\n\n    @Test\n    public void test() {\n        // EP 1: One filter match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_A));\n\n        // EP 2: Multiple filters match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(\n                TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(\n                    TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B + TypicalFilters.FILTERABLE_C));\n\n        // EP 3: One filter no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_B));\n\n        // EP 4: Multiple filters no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.test(\n                TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_C));\n\n        // EP 5: null\n        assertThrows(NullPointerException.class, () -> TypicalFilters.EXCLUSIVE_FILTERSET_A.test(null));\n    }\n}", "class_id": 0, "repo": "yutingzou/tp", "file": "src/test/java/seedu/address/model/filter/ExclusiveFilterSetTest.java", "last_update_at": "2021-03-17T11:02:52+00:00", "question_id": "43bc2c085e6a2cac1f9ce49766096d0942154236", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExclusiveFilterSetTest {\n    @Test\n    public void constructor_null_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> new ExclusiveFilterSet<String>(null));\n    }\n    @Test\n    public void hasAny() {\n        // EP 1: Fully contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        // EP 2: Partially contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n    @Test\n    public void hasAll() {\n        // EP 1: Has All\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_ABC));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        // EP 2: Has Some\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AC));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n    @Test\n    public void add() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n        // EP 1: Empty\n        filterSet.add(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n        // EP 2: Not Empty\n        filterSet.add(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 3: Duplicate\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.add(null));\n    }\n    @Test\n    public void remove() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(\n                TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n        // EP 1: Has Multiple\n        filterSet.remove(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n        filterSet.remove(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n        // EP 2: Has One\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 3: Empty\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 4: null\n        filterSet.remove(null);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n    }\n    @Test\n    public void addAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n        // EP 1: Empty\n        filterSet.addAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n        // EP 2: Not Empty\n        filterSet.addAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 3: Duplicate\n        filterSet.addAll(TypicalFilters.SET_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.addAll((FilterSet<String>) null));\n    }\n    @Test\n    public void removeAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(\n                TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n        // EP 1: Has Multiple\n        filterSet.removeAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n        // EP 2: Has One\n        filterSet.removeAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 3: Empty\n        filterSet.removeAll(TypicalFilters.SET_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.removeAll((FilterSet<String>) null));\n    }\n    @Test\n    public void test() {\n        // EP 1: One filter match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_A));\n        // EP 2: Multiple filters match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(\n                TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(\n                    TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B + TypicalFilters.FILTERABLE_C));\n        // EP 3: One filter no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_B));\n        // EP 4: Multiple filters no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.test(\n                TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_C));\n        // EP 5: null\n        assertThrows(NullPointerException.class, () -> TypicalFilters.EXCLUSIVE_FILTERSET_A.test(null));\n    }\n"]]}
{"hexsha": "39f6b8b791c2a8605663251577fe1f85e00a7a2a", "ext": "java", "lang": "Java", "content": "public class ExprTimeRemainingUntilBorderStabilize extends SimpleExpression<Timespan>{\n\tprivate Expression<World> worldExpression;\n\n\t@Override\n\tpublic Class<? extends Timespan> getReturnType() {\n\t\treturn Timespan.class;\n\t}\n\n\t@Override\n\tpublic boolean isSingle() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean init(Expression<?>[] expr, int matchedPattern, Kleenean arg2, ParseResult arg3) {\n\t\tworldExpression = (Expression<World>) expr[0];\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString(Event event, boolean arg1) {\n\t\treturn \"remaining time until border stabilize in \" + worldExpression;\n\t}\n\n\t@Override\n\tprotected Timespan[] get(Event event) {\n\t\tWorld world = worldExpression.getSingle(event);\n\t\tif (world.getWorldBorder() instanceof WorldBorderImpl) {\n\t\t    WorldBorderImpl border = (WorldBorderImpl) world.getWorldBorder();\n\t\t    Double timeInSeconds = border.remainingTimeInSeconds();\n\t\t    Timespan result = new Timespan((long) (timeInSeconds * 1000));\n\t\t    return new Timespan[]{result};\n        }\n\t\treturn new Timespan[0];\n\t}\n\n}", "class_id": 0, "repo": "TlatoaniHJ/Kosmos", "file": "src/us/tlatoani/kosmos/border/event/ExprTimeRemainingUntilBorderStabilize.java", "last_update_at": "2021-12-14T19:23:54+00:00", "question_id": "39f6b8b791c2a8605663251577fe1f85e00a7a2a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExprTimeRemainingUntilBorderStabilize extends SimpleExpression<Timespan>{\n\tprivate Expression<World> worldExpression;\n\t@Override\n\tpublic Class<? extends Timespan> getReturnType() {\n\t\treturn Timespan.class;\n\t}\n\t@Override\n\tpublic boolean isSingle() {\n\t\treturn true;\n\t}\n\t@Override\n\tpublic boolean init(Expression<?>[] expr, int matchedPattern, Kleenean arg2, ParseResult arg3) {\n\t\tworldExpression = (Expression<World>) expr[0];\n\t\treturn true;\n\t}\n\t@Override\n\tpublic String toString(Event event, boolean arg1) {\n\t\treturn \"remaining time until border stabilize in \" + worldExpression;\n\t}\n\t@Override\n\tprotected Timespan[] get(Event event) {\n\t\tWorld world = worldExpression.getSingle(event);\n\t\tif (world.getWorldBorder() instanceof WorldBorderImpl) {\n\t\t    WorldBorderImpl border = (WorldBorderImpl) world.getWorldBorder();\n\t\t    Double timeInSeconds = border.remainingTimeInSeconds();\n\t\t    Timespan result = new Timespan((long) (timeInSeconds * 1000));\n\t\t    return new Timespan[]{result};\n        }\n\t\treturn new Timespan[0];\n\t}\n"]]}
{"hexsha": "234a5116347665188acce37b81c61d47cf6eb7ba", "ext": "java", "lang": "Java", "content": "public class PurityAnnotator extends Annotator<PurityAnnotator.Purity> {\n    PurityAnnotator() {\n        super(\"purity\", Purity.HEAP_MOD);\n    }\n\n    public static enum Purity {\n        /**\n         * Does not modify program state and always produces the same (or practically indistinguishable) result.\n         */\n        CONST,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if local variables directly involved into expression don't change.\n         */\n        LOCAL_DEP,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if heap does not change.\n         */\n        HEAP_DEP, \n        /**\n         * Does not modify program state.\n         */\n        SIDE_EFFECT_FREE,\n        /**\n         * May modify heap.\n         */\n        HEAP_MOD, \n        /**\n         * May modify heap and/or local variables.\n         */\n        LOCAL_MOD;\n        \n        Purity merge(Purity other) {\n            return this.ordinal() > other.ordinal() ? this : other;\n        }\n        \n        public boolean atLeast(Purity other) {\n            return this.ordinal() <= other.ordinal();\n        }\n    }\n\n    void annotate(Node node, FrameContext fc) {\n        forExpressions(node, expr -> annotatePurity(expr, fc));\n    }\n    \n    private Purity getOwnPurity(Expression expr, FrameContext fc) {\n        switch (expr.getCode()) {\n            case Inc:\n            case PreIncrement:\n            case PostIncrement:\n            case Store:\n            case CompoundAssignment:\n                return Purity.LOCAL_MOD;\n            case InvokeDynamic:\n            case StoreElement:\n            case PutField:\n            case PutStatic:\n                return Purity.HEAP_MOD;\n            case InitObject: {\n                MethodReference mr = (MethodReference) expr.getOperand();\n                if (!fc.cf.isSideEffectFree(mr, true))\n                    return Purity.HEAP_MOD;\n                if (Types.isImmutable(mr.getDeclaringType()))\n                    return Purity.CONST;\n                return Purity.SIDE_EFFECT_FREE;\n            }\n            case NewArray:\n            case InitArray:\n                return Purity.SIDE_EFFECT_FREE;\n            case GetField:\n                if(fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand()))\n                        && !fc.md.isConstructor()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case GetStatic:\n                if(fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand()))\n                        && !fc.md.isTypeInitializer()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case LoadElement:\n                return Purity.HEAP_DEP;\n            case InvokeSpecial:\n            case InvokeStatic:\n            case InvokeVirtual:\n            case InvokeInterface: {\n                MethodReference mr = (MethodReference) expr.getOperand();\n                if (Methods.isPure(mr)) {\n                    boolean indistinguishable = mr.getReturnType().isVoid() || mr.getReturnType().isPrimitive() || Types.isImmutable(mr.getReturnType());\n                    if(indistinguishable) {\n                        return Purity.CONST;\n                    }\n                    return Purity.SIDE_EFFECT_FREE;\n                }\n                if (fc.cf.isSideEffectFree(mr, expr.getCode() == AstCode.InvokeSpecial)) {\n                    return Purity.SIDE_EFFECT_FREE;\n                }\n                return Purity.HEAP_MOD;\n            }\n            case Load:\n                return Purity.LOCAL_DEP;\n            default:\n                return Purity.CONST;\n        }\n    }\n\n    private Purity annotatePurity(Expression expr, FrameContext fc) {\n        Purity purity = Purity.CONST;\n        for(Expression child : expr.getArguments()) {\n            purity = purity.merge(annotatePurity(child, fc));\n        }\n        if(Inf.CONST.getValue(expr) != null) {\n            // statically known constant\n            purity = Purity.CONST;\n        } else {\n            purity = purity.merge(getOwnPurity(expr, fc));\n        }\n        putIfAbsent(expr, purity);\n        return purity;\n    }\n    \n    @Override\n    public Purity get(Expression expr) {\n        return super.get(expr);\n    }\n    \n    public boolean isPure(Expression expr) {\n        return get(expr).atLeast(Purity.LOCAL_DEP);\n    }\n    \n    public boolean isSideEffectFree(Expression expr) {\n        return get(expr).atLeast(Purity.SIDE_EFFECT_FREE);\n    }\n}", "class_id": 0, "repo": "amaembo/huntbugs", "file": "huntbugs/src/main/java/one/util/huntbugs/flow/PurityAnnotator.java", "last_update_at": "2021-11-09T09:36:36+00:00", "question_id": "234a5116347665188acce37b81c61d47cf6eb7ba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PurityAnnotator extends Annotator<PurityAnnotator.Purity> {\n    PurityAnnotator() {\n        super(\"purity\", Purity.HEAP_MOD);\n    }\n    public static enum Purity {\n        /**\n         * Does not modify program state and always produces the same (or practically indistinguishable) result.\n         */\n        CONST,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if local variables directly involved into expression don't change.\n         */\n        LOCAL_DEP,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if heap does not change.\n         */\n        HEAP_DEP, \n        /**\n         * Does not modify program state.\n         */\n        SIDE_EFFECT_FREE,\n        /**\n         * May modify heap.\n         */\n        HEAP_MOD, \n        /**\n         * May modify heap and/or local variables.\n         */\n        LOCAL_MOD;\n        Purity merge(Purity other) {\n            return this.ordinal() > other.ordinal() ? this : other;\n        }\n        public boolean atLeast(Purity other) {\n            return this.ordinal() <= other.ordinal();\n        }\n    }\n    void annotate(Node node, FrameContext fc) {\n        forExpressions(node, expr -> annotatePurity(expr, fc));\n    }\n    private Purity getOwnPurity(Expression expr, FrameContext fc) {\n        switch (expr.getCode()) {\n            case Inc:\n            case PreIncrement:\n            case PostIncrement:\n            case Store:\n            case CompoundAssignment:\n                return Purity.LOCAL_MOD;\n            case InvokeDynamic:\n            case StoreElement:\n            case PutField:\n            case PutStatic:\n                return Purity.HEAP_MOD;\n            case InitObject: {\n                MethodReference mr = (MethodReference) expr.getOperand();\n                if (!fc.cf.isSideEffectFree(mr, true))\n                    return Purity.HEAP_MOD;\n                if (Types.isImmutable(mr.getDeclaringType()))\n                    return Purity.CONST;\n                return Purity.SIDE_EFFECT_FREE;\n            }\n            case NewArray:\n            case InitArray:\n                return Purity.SIDE_EFFECT_FREE;\n            case GetField:\n                if(fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand()))\n                        && !fc.md.isConstructor()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case GetStatic:\n                if(fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand()))\n                        && !fc.md.isTypeInitializer()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case LoadElement:\n                return Purity.HEAP_DEP;\n            case InvokeSpecial:\n            case InvokeStatic:\n            case InvokeVirtual:\n            case InvokeInterface: {\n                MethodReference mr = (MethodReference) expr.getOperand();\n                if (Methods.isPure(mr)) {\n                    boolean indistinguishable = mr.getReturnType().isVoid() || mr.getReturnType().isPrimitive() || Types.isImmutable(mr.getReturnType());\n                    if(indistinguishable) {\n                        return Purity.CONST;\n                    }\n                    return Purity.SIDE_EFFECT_FREE;\n                }\n                if (fc.cf.isSideEffectFree(mr, expr.getCode() == AstCode.InvokeSpecial)) {\n                    return Purity.SIDE_EFFECT_FREE;\n                }\n                return Purity.HEAP_MOD;\n            }\n            case Load:\n                return Purity.LOCAL_DEP;\n            default:\n                return Purity.CONST;\n        }\n    }\n    private Purity annotatePurity(Expression expr, FrameContext fc) {\n        Purity purity = Purity.CONST;\n        for(Expression child : expr.getArguments()) {\n            purity = purity.merge(annotatePurity(child, fc));\n        }\n        if(Inf.CONST.getValue(expr) != null) {\n            // statically known constant\n            purity = Purity.CONST;\n        } else {\n            purity = purity.merge(getOwnPurity(expr, fc));\n        }\n        putIfAbsent(expr, purity);\n        return purity;\n    }\n    @Override\n    public Purity get(Expression expr) {\n        return super.get(expr);\n    }\n    public boolean isPure(Expression expr) {\n        return get(expr).atLeast(Purity.LOCAL_DEP);\n    }\n    public boolean isSideEffectFree(Expression expr) {\n        return get(expr).atLeast(Purity.SIDE_EFFECT_FREE);\n    }\n"]]}
{"hexsha": "4145e4ff9250cae0f2320ca43bb45cac1e8eae61", "ext": "java", "lang": "Java", "content": "public class Log4JRuleHelper extends RuleHelper {\n\n  private static final LogEventTracker tracker = new LogEventTracker();\n\n\n  public Log4JRuleHelper(Rule rule) {\n    super(rule);\n  }\n\n  public void appendersCalled(LoggingEvent event) {\n    ThrowableInformation throwableInfo = event.getThrowableInformation();\n    String throwableName = null;\n    ErrorFingerprint fingerprint = null;\n    if (throwableInfo != null) {\n      Throwable throwable = throwableInfo.getThrowable();\n      throwableName = (throwable != null) ? throwable.getClass().getName() : null;\n      fingerprint = ErrorFingerprint.fromThrowable(throwableInfo.getThrowable());\n    }\n    LogEventTracker.LogLevel level = LogEventTracker.LogLevel.valueOf(event.getLevel().toString());\n    tracker.track(level, (throwableInfo != null), throwableName, fingerprint);\n    if (fingerprint != null && event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME) == null) {\n      event.setProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME, fingerprint.getChecksum());\n    }\n  }\n\n  public String convertMessage(LoggingEvent event, String origMessage) {\n    String fingerprint = event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME);\n    if (fingerprint == null) {\n      return origMessage;\n    }\n    return \"[error:\" + fingerprint + \"] \" + origMessage;\n  }\n\n}", "class_id": 0, "repo": "uditsharma/JInsight", "file": "src/main/java/ai/apptuit/metrics/jinsight/modules/log4j/Log4JRuleHelper.java", "last_update_at": "2021-06-05T13:08:36+00:00", "question_id": "4145e4ff9250cae0f2320ca43bb45cac1e8eae61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Log4JRuleHelper extends RuleHelper {\n  private static final LogEventTracker tracker = new LogEventTracker();\n  public Log4JRuleHelper(Rule rule) {\n    super(rule);\n  }\n  public void appendersCalled(LoggingEvent event) {\n    ThrowableInformation throwableInfo = event.getThrowableInformation();\n    String throwableName = null;\n    ErrorFingerprint fingerprint = null;\n    if (throwableInfo != null) {\n      Throwable throwable = throwableInfo.getThrowable();\n      throwableName = (throwable != null) ? throwable.getClass().getName() : null;\n      fingerprint = ErrorFingerprint.fromThrowable(throwableInfo.getThrowable());\n    }\n    LogEventTracker.LogLevel level = LogEventTracker.LogLevel.valueOf(event.getLevel().toString());\n    tracker.track(level, (throwableInfo != null), throwableName, fingerprint);\n    if (fingerprint != null && event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME) == null) {\n      event.setProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME, fingerprint.getChecksum());\n    }\n  }\n  public String convertMessage(LoggingEvent event, String origMessage) {\n    String fingerprint = event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME);\n    if (fingerprint == null) {\n      return origMessage;\n    }\n    return \"[error:\" + fingerprint + \"] \" + origMessage;\n  }\n"]]}
{"hexsha": "e81b5f345b921f4750ec25a2ac2076deb78ae3c4", "ext": "java", "lang": "Java", "content": "public class HtdfTransferTest {\n\n    @Test\n    public void sign() throws Exception {\n\n        String hexPrivateKey = \"25E9F2EDAAF9464E9FA0EFDB896835741EBE0F5E34F97CFB88457818B6681C32\";\n        byte [] privateKey = Hex.decode(hexPrivateKey);\n\n        MessageDigest sh256Digest = MessageDigest.getInstance(\"SHA-256\");\n        sh256Digest.update(\"hello\".getBytes(StandardCharsets.UTF_8));\n        byte[] sha256Bytes =  sh256Digest.digest();\n\n        byte[] sigRS = HtdfTransfer.sign(sha256Bytes, privateKey);\n\n        // test vector\n        //r:5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6\n        //s:6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\n        final String RIGHT_RS = \"5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6\" +\n                        \"6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\";\n\n        System.out.println( Hex.toHexString(sigRS) );\n\n        assertTrue( RIGHT_RS.compareTo( Hex.toHexString(sigRS) ) == 0 );\n    }\n\n\n    @Test\n    public void htdfToSatoshi1() {\n        assertTrue(0 == HtdfToSatoshi(BigDecimal.valueOf(0.1234)).compareTo(BigInteger.valueOf(12340000)));\n    }\n\n    @Test\n    public void doHttpGet() throws Exception {\n        String ret = HtdfTransfer.doHttpGet(\"http://www.htdfscan.com\");\n        assertTrue(ret.length() > 0);\n    }\n\n    @Test\n    public void doHttpPost() {\n        /*\n        JSONObject reqData = new JSONObject();\n        reqData.put(\"tx\", \"24234829482394829342389482394823948234\");\n        String url = String.format(\"http://%s/hs/broadcast\" , gNodeIpPort);\n        String  ret = HtdfTransfer.doHttpPost(url, reqData).toString();\n        assertTrue(ret.length() > 0);\n        */\n    }\n\n\n\n    @Test\n    public void transfer() throws Exception {\n        String dstAddress = \"htdf1jrh6kxrcr0fd8gfgdwna8yyr9tkt99ggmz9ja2\";\n        String memo = \"htdf transaction demo in java\";\n        BigInteger amountSatoshi = HtdfToSatoshi( BigDecimal.valueOf(0.12345678));\n        HtdfTransfer.transfer( dstAddress, amountSatoshi , memo );\n    }\n}", "class_id": 0, "repo": "youngqqcn/htdfdocs", "file": "demos/java_demos/src/test/java/com/orientwalt/demos/HtdfTransferTest.java", "last_update_at": "2021-03-10T06:28:27+00:00", "question_id": "e81b5f345b921f4750ec25a2ac2076deb78ae3c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HtdfTransferTest {\n    @Test\n    public void sign() throws Exception {\n        String hexPrivateKey = \"25E9F2EDAAF9464E9FA0EFDB896835741EBE0F5E34F97CFB88457818B6681C32\";\n        byte [] privateKey = Hex.decode(hexPrivateKey);\n        MessageDigest sh256Digest = MessageDigest.getInstance(\"SHA-256\");\n        sh256Digest.update(\"hello\".getBytes(StandardCharsets.UTF_8));\n        byte[] sha256Bytes =  sh256Digest.digest();\n        byte[] sigRS = HtdfTransfer.sign(sha256Bytes, privateKey);\n        // test vector\n        //r:5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6\n        //s:6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\n        final String RIGHT_RS = \"5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6\" +\n                        \"6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\";\n        System.out.println( Hex.toHexString(sigRS) );\n        assertTrue( RIGHT_RS.compareTo( Hex.toHexString(sigRS) ) == 0 );\n    }\n    @Test\n    public void htdfToSatoshi1() {\n        assertTrue(0 == HtdfToSatoshi(BigDecimal.valueOf(0.1234)).compareTo(BigInteger.valueOf(12340000)));\n    }\n    @Test\n    public void doHttpGet() throws Exception {\n        String ret = HtdfTransfer.doHttpGet(\"http://www.htdfscan.com\");\n        assertTrue(ret.length() > 0);\n    }\n    @Test\n    public void doHttpPost() {\n        /*\n        JSONObject reqData = new JSONObject();\n        reqData.put(\"tx\", \"24234829482394829342389482394823948234\");\n        String url = String.format(\"http://%s/hs/broadcast\" , gNodeIpPort);\n        String  ret = HtdfTransfer.doHttpPost(url, reqData).toString();\n        assertTrue(ret.length() > 0);\n        */\n    }\n    @Test\n    public void transfer() throws Exception {\n        String dstAddress = \"htdf1jrh6kxrcr0fd8gfgdwna8yyr9tkt99ggmz9ja2\";\n        String memo = \"htdf transaction demo in java\";\n        BigInteger amountSatoshi = HtdfToSatoshi( BigDecimal.valueOf(0.12345678));\n        HtdfTransfer.transfer( dstAddress, amountSatoshi , memo );\n    }\n"]]}
{"hexsha": "f416cf9485d12f7d7cc768a7e123b492cfdebc32", "ext": "java", "lang": "Java", "content": "public class S3AReadOpContext extends S3AOpContext {\n\n  /**\n   * Path of read.\n   */\n  private final Path path;\n\n  /**\n   * Initial input policy of the stream.\n   */\n  private S3AInputPolicy inputPolicy;\n\n  /**\n   * How to detect and deal with the object being updated during read.\n   */\n  private ChangeDetectionPolicy changeDetectionPolicy;\n\n  /**\n   * Readahead for GET operations/skip, etc.\n   */\n  private long readahead;\n\n  private AuditSpan auditSpan;\n\n  /**\n   * Threshold for stream reads to switch to\n   * asynchronous draining.\n   */\n  private long asyncDrainThreshold;\n\n  /**\n   * Instantiate.\n   * @param path path of read\n   * @param invoker invoker for normal retries.\n   * @param stats Fileystem statistics (may be null)\n   * @param instrumentation statistics context\n   * @param dstFileStatus target file status\n   */\n  public S3AReadOpContext(\n      final Path path,\n      Invoker invoker,\n      @Nullable FileSystem.Statistics stats,\n      S3AStatisticsContext instrumentation,\n      FileStatus dstFileStatus) {\n\n    super(invoker, stats, instrumentation,\n        dstFileStatus);\n    this.path = requireNonNull(path);\n  }\n\n  /**\n   * validate the context.\n   * @return a read operation context ready for use.\n   */\n  public S3AReadOpContext build() {\n    requireNonNull(inputPolicy, \"inputPolicy\");\n    requireNonNull(changeDetectionPolicy, \"changeDetectionPolicy\");\n    requireNonNull(auditSpan, \"auditSpan\");\n    requireNonNull(inputPolicy, \"inputPolicy\");\n    Preconditions.checkArgument(readahead >= 0,\n        \"invalid readahead %d\", readahead);\n    Preconditions.checkArgument(asyncDrainThreshold >= 0,\n        \"invalid drainThreshold %d\", asyncDrainThreshold);\n    return this;\n  }\n\n  /**\n   * Get invoker to use for read operations.\n   * @return invoker to use for read codepaths\n   */\n  public Invoker getReadInvoker() {\n    return invoker;\n  }\n\n  /**\n   * Get the path of this read.\n   * @return path.\n   */\n  public Path getPath() {\n    return path;\n  }\n\n  /**\n   * Get the IO policy.\n   * @return the initial input policy.\n   */\n  public S3AInputPolicy getInputPolicy() {\n    return inputPolicy;\n  }\n\n  public ChangeDetectionPolicy getChangeDetectionPolicy() {\n    return changeDetectionPolicy;\n  }\n\n  /**\n   * Get the readahead for this operation.\n   * @return a value {@literal >=} 0\n   */\n  public long getReadahead() {\n    return readahead;\n  }\n\n  /**\n   * Get the audit which was active when the file was opened.\n   * @return active span\n   */\n  public AuditSpan getAuditSpan() {\n    return auditSpan;\n  }\n\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withInputPolicy(final S3AInputPolicy value) {\n    inputPolicy = value;\n    return this;\n  }\n\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withChangeDetectionPolicy(\n      final ChangeDetectionPolicy value) {\n    changeDetectionPolicy = value;\n    return this;\n  }\n\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withReadahead(final long value) {\n    readahead = value;\n    return this;\n  }\n\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withAuditSpan(final AuditSpan value) {\n    auditSpan = value;\n    return this;\n  }\n\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withAsyncDrainThreshold(final long value) {\n    asyncDrainThreshold = value;\n    return this;\n  }\n\n  public long getAsyncDrainThreshold() {\n    return asyncDrainThreshold;\n  }\n\n  @Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder(\n        \"S3AReadOpContext{\");\n    sb.append(\"path=\").append(path);\n    sb.append(\", inputPolicy=\").append(inputPolicy);\n    sb.append(\", readahead=\").append(readahead);\n    sb.append(\", changeDetectionPolicy=\").append(changeDetectionPolicy);\n    sb.append('}');\n    return sb.toString();\n  }\n}", "class_id": 0, "repo": "MingXiangLi/hadoop", "file": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AReadOpContext.java", "last_update_at": "2021-12-23T03:23:44+00:00", "question_id": "f416cf9485d12f7d7cc768a7e123b492cfdebc32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class S3AReadOpContext extends S3AOpContext {\n  /**\n   * Path of read.\n   */\n  private final Path path;\n  /**\n   * Initial input policy of the stream.\n   */\n  private S3AInputPolicy inputPolicy;\n  /**\n   * How to detect and deal with the object being updated during read.\n   */\n  private ChangeDetectionPolicy changeDetectionPolicy;\n  /**\n   * Readahead for GET operations/skip, etc.\n   */\n  private long readahead;\n  private AuditSpan auditSpan;\n  /**\n   * Threshold for stream reads to switch to\n   * asynchronous draining.\n   */\n  private long asyncDrainThreshold;\n  /**\n   * Instantiate.\n   * @param path path of read\n   * @param invoker invoker for normal retries.\n   * @param stats Fileystem statistics (may be null)\n   * @param instrumentation statistics context\n   * @param dstFileStatus target file status\n   */\n  public S3AReadOpContext(\n      final Path path,\n      Invoker invoker,\n      @Nullable FileSystem.Statistics stats,\n      S3AStatisticsContext instrumentation,\n      FileStatus dstFileStatus) {\n    super(invoker, stats, instrumentation,\n        dstFileStatus);\n    this.path = requireNonNull(path);\n  }\n  /**\n   * validate the context.\n   * @return a read operation context ready for use.\n   */\n  public S3AReadOpContext build() {\n    requireNonNull(inputPolicy, \"inputPolicy\");\n    requireNonNull(changeDetectionPolicy, \"changeDetectionPolicy\");\n    requireNonNull(auditSpan, \"auditSpan\");\n    requireNonNull(inputPolicy, \"inputPolicy\");\n    Preconditions.checkArgument(readahead >= 0,\n        \"invalid readahead %d\", readahead);\n    Preconditions.checkArgument(asyncDrainThreshold >= 0,\n        \"invalid drainThreshold %d\", asyncDrainThreshold);\n    return this;\n  }\n  /**\n   * Get invoker to use for read operations.\n   * @return invoker to use for read codepaths\n   */\n  public Invoker getReadInvoker() {\n    return invoker;\n  }\n  /**\n   * Get the path of this read.\n   * @return path.\n   */\n  public Path getPath() {\n    return path;\n  }\n  /**\n   * Get the IO policy.\n   * @return the initial input policy.\n   */\n  public S3AInputPolicy getInputPolicy() {\n    return inputPolicy;\n  }\n  public ChangeDetectionPolicy getChangeDetectionPolicy() {\n    return changeDetectionPolicy;\n  }\n  /**\n   * Get the readahead for this operation.\n   * @return a value {@literal >=} 0\n   */\n  public long getReadahead() {\n    return readahead;\n  }\n  /**\n   * Get the audit which was active when the file was opened.\n   * @return active span\n   */\n  public AuditSpan getAuditSpan() {\n    return auditSpan;\n  }\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withInputPolicy(final S3AInputPolicy value) {\n    inputPolicy = value;\n    return this;\n  }\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withChangeDetectionPolicy(\n      final ChangeDetectionPolicy value) {\n    changeDetectionPolicy = value;\n    return this;\n  }\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withReadahead(final long value) {\n    readahead = value;\n    return this;\n  }\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withAuditSpan(final AuditSpan value) {\n    auditSpan = value;\n    return this;\n  }\n  /**\n   * Set builder value.\n   * @param value new value\n   * @return the builder\n   */\n  public S3AReadOpContext withAsyncDrainThreshold(final long value) {\n    asyncDrainThreshold = value;\n    return this;\n  }\n  public long getAsyncDrainThreshold() {\n    return asyncDrainThreshold;\n  }\n  @Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder(\n        \"S3AReadOpContext{\");\n    sb.append(\"path=\").append(path);\n    sb.append(\", inputPolicy=\").append(inputPolicy);\n    sb.append(\", readahead=\").append(readahead);\n    sb.append(\", changeDetectionPolicy=\").append(changeDetectionPolicy);\n    sb.append('}');\n    return sb.toString();\n  }\n"]]}
{"hexsha": "613edc207594fb66f34f7fbd0a1d1f3fc371a4e9", "ext": "java", "lang": "Java", "content": "public final class LargestRowInTreeTestCase {\n\n    private LargestRowInTree alg;\n\n    /**\n     * Init.\n     */\n    @Before\n    public void init(){\n        this.alg = new LargestRowInTree();\n    }\n\n    @Test\n    public void test(){\n        final PlainTree tree = new PlainTree(1);\n        tree.left = new PlainTree(3);\n        tree.left.left = new PlainTree(5);\n        tree.left.right = new PlainTree(3);\n        tree.right = new PlainTree(2);\n        tree.right.right = new PlainTree(9);\n        Assert.assertEquals(\n            Arrays.asList(1,3,9),\n            this.alg.largestValues(tree)\n        );\n    }\n}", "class_id": 0, "repo": "strogiyotec/leetcode-oo", "file": "src/test/java/leetcode/oo/tree/LargestRowInTreeTestCase.java", "last_update_at": "2021-05-03T16:51:47+00:00", "question_id": "613edc207594fb66f34f7fbd0a1d1f3fc371a4e9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class LargestRowInTreeTestCase {\n    private LargestRowInTree alg;\n    /**\n     * Init.\n     */\n    @Before\n    public void init(){\n        this.alg = new LargestRowInTree();\n    }\n    @Test\n    public void test(){\n        final PlainTree tree = new PlainTree(1);\n        tree.left = new PlainTree(3);\n        tree.left.left = new PlainTree(5);\n        tree.left.right = new PlainTree(3);\n        tree.right = new PlainTree(2);\n        tree.right.right = new PlainTree(9);\n        Assert.assertEquals(\n            Arrays.asList(1,3,9),\n            this.alg.largestValues(tree)\n        );\n    }\n"]]}
{"hexsha": "d9ecb15e843577b711bc488b0ff3800761dceffb", "ext": "java", "lang": "Java", "content": "@Controller\npublic class ModelController {\n\n\t\n    @ModelAttribute(\"girl\")\n    public Girl init(Model model){\n        Girl g  = new Girl();\n        g.setAge(28);\n        g.setName(\"\u83f2\u83f2\");\n        return g;\n    }\n\n\n    @RequestMapping(\"/m1\")\n    public String m1(Model model) {\n        System.out.println(model.containsAttribute(\"girl\"));\n        return \"msg\";\n    }\n    \n    @RequestMapping(\"/m2/{name}/{age}\")\n    public String m1(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName()+girl.getAge());\n        return \"msg\";\n    }\n    \n    @RequestMapping(value=\"m3\",method=RequestMethod.POST)\n    public String m3(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName()+girl.getAge());\n        return \"msg\";\n    }\n    \n    \n    \n}", "class_id": 0, "repo": "djwangweijie/springmvc001", "file": "src/com/wwj/controller/ModelController.java", "last_update_at": "2021-07-14T14:36:52+00:00", "question_id": "d9ecb15e843577b711bc488b0ff3800761dceffb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\npublic class ModelController {\n\t\n    @ModelAttribute(\"girl\")\n    public Girl init(Model model){\n        Girl g  = new Girl();\n        g.setAge(28);\n        g.setName(\"\u83f2\u83f2\");\n        return g;\n    }\n    @RequestMapping(\"/m1\")\n    public String m1(Model model) {\n        System.out.println(model.containsAttribute(\"girl\"));\n        return \"msg\";\n    }\n    @RequestMapping(\"/m2/{name}/{age}\")\n    public String m1(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName()+girl.getAge());\n        return \"msg\";\n    }\n    @RequestMapping(value=\"m3\",method=RequestMethod.POST)\n    public String m3(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName()+girl.getAge());\n        return \"msg\";\n    }\n"]]}
{"hexsha": "93ee8390b37253340129ea65b53a309a0aac8927", "ext": "java", "lang": "Java", "content": "public class SequenceTest {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newFixedThreadPool(100);\n        ExecutorService exec1 = Executors.newFixedThreadPool(100);\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"\u5f00\u59cb\u65f6\u95f4:\"+System.currentTimeMillis());\n        Runnable runnable = new SequenceRunnable();\n        for (int i = 0; i < 100; i++) {\n            exec.submit(runnable);\n            exec1.submit(runnable);\n        }\n        System.out.println(\"\u603b\u8017\u65f6:\"+(System.currentTimeMillis()-startTime));\n        //\u7ed3\u675f\u7ebf\u7a0b\u6c60\n        exec.shutdown();\n        exec1.shutdown();\n    }\n}", "class_id": 0, "repo": "XWxiaowei/TempCode", "file": "java-thread-demo/src/test/com/jay/thread/SequenceTest.java", "last_update_at": "2021-12-29T12:11:37+00:00", "question_id": "93ee8390b37253340129ea65b53a309a0aac8927", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SequenceTest {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newFixedThreadPool(100);\n        ExecutorService exec1 = Executors.newFixedThreadPool(100);\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"\u5f00\u59cb\u65f6\u95f4:\"+System.currentTimeMillis());\n        Runnable runnable = new SequenceRunnable();\n        for (int i = 0; i < 100; i++) {\n            exec.submit(runnable);\n            exec1.submit(runnable);\n        }\n        System.out.println(\"\u603b\u8017\u65f6:\"+(System.currentTimeMillis()-startTime));\n        //\u7ed3\u675f\u7ebf\u7a0b\u6c60\n        exec.shutdown();\n        exec1.shutdown();\n    }\n"]]}
{"hexsha": "6571a406fc36a6fca11c11117b7c8d3178aa31e8", "ext": "java", "lang": "Java", "content": "@Service\npublic class DocumentoService {\n\n    @Autowired\n    private DocumentoRepository documentoRepository;\n\n    @Autowired\n    private MilitarRepository militarRepository;\n\n    @Autowired\n    private MilitarService militarService;\n\n    /**\n     * Cria um novo documento\n     * \n     * @param documento DTO do documento a ser salvo\n     * @return retorna um response file do documento salvo\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFDocumento criar(DocumentoDTO documentodto) throws IOException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"validation failed\");\n\n        RFDocumento rfdoc;\n        Documento doc = DocumentoMapper.toModel(documentodto);\n        doc.setMilitares(null);\n\n        List<Militar> militares = new ArrayList<Militar>();\n\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n\n                }\n            });\n        }\n\n        doc.setMilitares(militares);\n        rfdoc = new RFDocumento(documentoRepository.save(doc));\n\n        return rfdoc;\n    }\n\n    /**\n     * Edita um documento e salva no banco\n     * \n     * @param id           id do documento a ser editado\n     * @param documentodto dto com documento atualizado\n     * @return\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFEditarDocumento editar(long id, DocumentoDTO documentodto)\n            throws IOException, ValidationException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"erro\");\n\n        Documento doc = documentoRepository.findById(id).get();\n\n        doc.setTipo(documentodto.getTipo());\n        doc.setNumeracao(documentodto.getNumeracao());\n        doc.setNome(documentodto.getNome());\n        doc.setDescricao(documentodto.getDescricao());\n        doc.setData(documentodto.getData());\n        doc.setPublico(documentodto.getPublico());\n\n        List<Militar> militares = new ArrayList<Militar>();\n\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n\n                }\n            });\n        }\n\n        doc.setMilitares(militares);\n        documentoRepository.save(doc);\n        return new RFEditarDocumento(doc);\n    }\n\n    /**\n     * Busca um documento pelo id\n     * \n     * @param id id do documento a ser procurado\n     * @return retorna um response file do documento\n     * @throws IOException\n     */\n    public RFDocumento getDocumento(Long id) throws IOException {\n        Documento doc = documentoRepository.findById(id).get();\n        RFDocumento rfdoc = new RFDocumento(doc);\n        return rfdoc;\n    }\n\n    /**\n     * Busca um documento utilizando multiplos campos e uma specification\n     * \n     * @param docJson jsonNode gerada com os campos de busca\n     * @return uma lista de responsefiles de documentos\n     * @throws IOException\n     */\n    public List<RFBuscaDocumentos> getDocumento(Map<String, Object> map) throws IOException {\n        DocumentoSpecification ds = new DocumentoSpecification(map);\n\n        List<RFBuscaDocumentos> rfDocList = documentoRepository.findAll(ds).stream().map(documento -> {\n            RFBuscaDocumentos newRFDoc = new RFBuscaDocumentos(documento);\n            return newRFDoc;\n        }).collect(Collectors.toList());\n        /*\n         * List<RFBuscaDocumentos> rfDocList =\n         * documentoRepository.findAll().stream().map(documento -> { RFBuscaDocumentos\n         * newRFDoc = new RFBuscaDocumentos(documento); return newRFDoc;\n         * }).collect(Collectors.toList());\n         */\n        return rfDocList;\n    }\n}", "class_id": 0, "repo": "digitalse-bomb/back", "file": "src/main/java/com/digitalse/cbm/back/services/DocumentoService.java", "last_update_at": "2021-07-17T17:08:41+00:00", "question_id": "6571a406fc36a6fca11c11117b7c8d3178aa31e8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class DocumentoService {\n    @Autowired\n    private DocumentoRepository documentoRepository;\n    @Autowired\n    private MilitarRepository militarRepository;\n    @Autowired\n    private MilitarService militarService;\n    /**\n     * Cria um novo documento\n     * \n     * @param documento DTO do documento a ser salvo\n     * @return retorna um response file do documento salvo\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFDocumento criar(DocumentoDTO documentodto) throws IOException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"validation failed\");\n        RFDocumento rfdoc;\n        Documento doc = DocumentoMapper.toModel(documentodto);\n        doc.setMilitares(null);\n        List<Militar> militares = new ArrayList<Militar>();\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n                }\n            });\n        }\n        doc.setMilitares(militares);\n        rfdoc = new RFDocumento(documentoRepository.save(doc));\n        return rfdoc;\n    }\n    /**\n     * Edita um documento e salva no banco\n     * \n     * @param id           id do documento a ser editado\n     * @param documentodto dto com documento atualizado\n     * @return\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFEditarDocumento editar(long id, DocumentoDTO documentodto)\n            throws IOException, ValidationException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"erro\");\n        Documento doc = documentoRepository.findById(id).get();\n        doc.setTipo(documentodto.getTipo());\n        doc.setNumeracao(documentodto.getNumeracao());\n        doc.setNome(documentodto.getNome());\n        doc.setDescricao(documentodto.getDescricao());\n        doc.setData(documentodto.getData());\n        doc.setPublico(documentodto.getPublico());\n        List<Militar> militares = new ArrayList<Militar>();\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n                }\n            });\n        }\n        doc.setMilitares(militares);\n        documentoRepository.save(doc);\n        return new RFEditarDocumento(doc);\n    }\n    /**\n     * Busca um documento pelo id\n     * \n     * @param id id do documento a ser procurado\n     * @return retorna um response file do documento\n     * @throws IOException\n     */\n    public RFDocumento getDocumento(Long id) throws IOException {\n        Documento doc = documentoRepository.findById(id).get();\n        RFDocumento rfdoc = new RFDocumento(doc);\n        return rfdoc;\n    }\n    /**\n     * Busca um documento utilizando multiplos campos e uma specification\n     * \n     * @param docJson jsonNode gerada com os campos de busca\n     * @return uma lista de responsefiles de documentos\n     * @throws IOException\n     */\n    public List<RFBuscaDocumentos> getDocumento(Map<String, Object> map) throws IOException {\n        DocumentoSpecification ds = new DocumentoSpecification(map);\n        List<RFBuscaDocumentos> rfDocList = documentoRepository.findAll(ds).stream().map(documento -> {\n            RFBuscaDocumentos newRFDoc = new RFBuscaDocumentos(documento);\n            return newRFDoc;\n        }).collect(Collectors.toList());\n        /*\n         * List<RFBuscaDocumentos> rfDocList =\n         * documentoRepository.findAll().stream().map(documento -> { RFBuscaDocumentos\n         * newRFDoc = new RFBuscaDocumentos(documento); return newRFDoc;\n         * }).collect(Collectors.toList());\n         */\n        return rfDocList;\n    }\n"]]}
{"hexsha": "0497272e2b6a1d4fbfc2a7ce34c849fbfbcb0d9d", "ext": "java", "lang": "Java", "content": "@SpringBootTest(classes = {\n    Application.class,\n    TestIdamConfiguration.class\n})\n@AutoConfigureMockMvc\n@AutoConfigureWireMock(port = 0, stubs = \"classpath:/wiremock-stubs\")\n@ActiveProfiles(\"itest\")\npublic class BaseTest {\n\n    public static final long AUTH_TOKEN_TTL = 14400000;\n\n    public static final String IDAM_MOCK_USER_ID = \"445\";\n    private static final String EXAMPLE_REQUEST_ID = \"TEST REQUEST ID\";\n\n    @SpyBean\n    @Autowired\n    protected AuditRepository auditRepository;\n\n    public static HttpHeaders createHttpHeaders(String serviceName) throws JOSEException {\n        return createHttpHeaders(AUTH_TOKEN_TTL, serviceName, AUTH_TOKEN_TTL);\n    }\n\n    protected static HttpHeaders createHttpHeaders(long authTtlMillis,\n                                            String serviceName,\n                                            long s2sAuthTtlMillis)  throws JOSEException {\n        HttpHeaders headers = new HttpHeaders();\n        String authToken = BEARER + generateAuthToken(authTtlMillis);\n        headers.add(AUTHORIZATION, authToken);\n        String s2SToken = generateS2SToken(serviceName, s2sAuthTtlMillis);\n        headers.add(SERVICE_AUTHORIZATION, s2SToken);\n        headers.add(AuditConfiguration.REQUEST_ID, EXAMPLE_REQUEST_ID);\n        return headers;\n    }\n\n    protected ResultMatcher hasGeneratedLogAudit(AuditOperationType operationType,\n                                                 String invokingService,\n                                                 List<String> documentIds,\n                                                 String caseId,\n                                                 String jurisdiction,\n                                                 String caseType) {\n        return result -> verifyLogAuditValues(result,\n                                              operationType,\n                                              invokingService,\n                                              documentIds,\n                                              caseId,\n                                              jurisdiction,\n                                              caseType);\n    }\n\n    protected void verifyLogAuditValues(MvcResult result,\n                                        AuditOperationType operationType,\n                                        String invokingService,\n                                        List<String> documentIds,\n                                        String caseId,\n                                        String jurisdiction,\n                                        String caseType) {\n        ArgumentCaptor<AuditEntry> captor = ArgumentCaptor.forClass(AuditEntry.class);\n        verify(auditRepository).save(captor.capture());\n\n        AuditEntry auditEntry = captor.getValue();\n\n        assertNotNull(\"DateTime\", auditEntry.getDateTime());\n\n        assertEquals(\"Operation Type\", operationType.getLabel(), auditEntry.getOperationType());\n\n        assertEquals(\"Idam ID\", IDAM_MOCK_USER_ID, auditEntry.getIdamId());\n        assertEquals(\"Invoking Service\", invokingService, auditEntry.getInvokingService());\n\n        assertEquals(\"HTTP Status\", result.getResponse().getStatus(), auditEntry.getHttpStatus());\n        assertEquals(\"HTTP Method\", result.getRequest().getMethod(), auditEntry.getHttpMethod());\n        assertEquals(\"Request Path\", result.getRequest().getRequestURI(), auditEntry.getRequestPath());\n        assertEquals(\"Request ID\", EXAMPLE_REQUEST_ID, auditEntry.getRequestId());\n\n        // NB: skip validation of inputs for BAD_REQUEST as some may not have been populated\n        if (result.getResponse().getStatus() != HttpStatus.BAD_REQUEST.value()) {\n            if (documentIds != null && !documentIds.isEmpty()) {\n                assertThat(auditEntry.getDocumentIds())\n                    .isNotNull()\n                    .hasSize(documentIds.size())\n                    .containsAll(documentIds);\n            } else {\n                assertThat(auditEntry.getDocumentIds()).isNullOrEmpty();\n            }\n\n            if (caseId != null && !caseId.equals(\"\")) {\n                assertThat(auditEntry.getCaseId())\n                    .isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseId()).isNullOrEmpty();\n            }\n\n            if (jurisdiction != null && !jurisdiction.equals(\"\")) {\n                assertThat(auditEntry.getJurisdiction())\n                    .isNotNull();\n            } else {\n                assertThat(auditEntry.getJurisdiction()).isNullOrEmpty();\n            }\n\n            if (caseType != null && !caseType.equals(\"\")) {\n                assertThat(auditEntry.getCaseType())\n                    .isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseType()).isNullOrEmpty();\n            }\n        }\n    }\n\n    private static String generateAuthToken(long ttlMillis) throws JOSEException {\n\n        JWTClaimsSet.Builder builder = new JWTClaimsSet.Builder()\n            .subject(\"API_Stub\")\n            .issueTime(new Date())\n            .claim(TOKEN_NAME, ACCESS_TOKEN)\n            .expirationTime(new Date(System.currentTimeMillis() + ttlMillis));\n\n        SignedJWT signedJWT = new SignedJWT(\n            new JWSHeader.Builder(JWSAlgorithm.RS256)\n                .keyID(KeyGenUtil.getRsaJWK().getKeyID()).build(),\n            builder.build()\n        );\n        signedJWT.sign(new RSASSASigner(KeyGenUtil.getRsaJWK()));\n\n        return signedJWT.serialize();\n    }\n\n    private static String generateS2SToken(String serviceName, long ttlMillis) {\n        return Jwts.builder()\n            .setSubject(serviceName)\n            .setExpiration(new Date(System.currentTimeMillis() + ttlMillis))\n            .signWith(SignatureAlgorithm.HS256, TextCodec.BASE64.encode(\"AA\"))\n            .compact();\n    }\n\n}", "class_id": 0, "repo": "duranfatih/ccd-case-document-am-api", "file": "src/integrationTest/java/uk/gov/hmcts/reform/ccd/documentam/BaseTest.java", "last_update_at": "2021-04-13T07:06:18+00:00", "question_id": "0497272e2b6a1d4fbfc2a7ce34c849fbfbcb0d9d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootTest(classes = {\n    Application.class,\n    TestIdamConfiguration.class\n})\n@AutoConfigureMockMvc\n@AutoConfigureWireMock(port = 0, stubs = \"classpath:/wiremock-stubs\")\n@ActiveProfiles(\"itest\")\npublic class BaseTest {\n    public static final long AUTH_TOKEN_TTL = 14400000;\n    public static final String IDAM_MOCK_USER_ID = \"445\";\n    private static final String EXAMPLE_REQUEST_ID = \"TEST REQUEST ID\";\n    @SpyBean\n    @Autowired\n    protected AuditRepository auditRepository;\n    public static HttpHeaders createHttpHeaders(String serviceName) throws JOSEException {\n        return createHttpHeaders(AUTH_TOKEN_TTL, serviceName, AUTH_TOKEN_TTL);\n    }\n    protected static HttpHeaders createHttpHeaders(long authTtlMillis,\n                                            String serviceName,\n                                            long s2sAuthTtlMillis)  throws JOSEException {\n        HttpHeaders headers = new HttpHeaders();\n        String authToken = BEARER + generateAuthToken(authTtlMillis);\n        headers.add(AUTHORIZATION, authToken);\n        String s2SToken = generateS2SToken(serviceName, s2sAuthTtlMillis);\n        headers.add(SERVICE_AUTHORIZATION, s2SToken);\n        headers.add(AuditConfiguration.REQUEST_ID, EXAMPLE_REQUEST_ID);\n        return headers;\n    }\n    protected ResultMatcher hasGeneratedLogAudit(AuditOperationType operationType,\n                                                 String invokingService,\n                                                 List<String> documentIds,\n                                                 String caseId,\n                                                 String jurisdiction,\n                                                 String caseType) {\n        return result -> verifyLogAuditValues(result,\n                                              operationType,\n                                              invokingService,\n                                              documentIds,\n                                              caseId,\n                                              jurisdiction,\n                                              caseType);\n    }\n    protected void verifyLogAuditValues(MvcResult result,\n                                        AuditOperationType operationType,\n                                        String invokingService,\n                                        List<String> documentIds,\n                                        String caseId,\n                                        String jurisdiction,\n                                        String caseType) {\n        ArgumentCaptor<AuditEntry> captor = ArgumentCaptor.forClass(AuditEntry.class);\n        verify(auditRepository).save(captor.capture());\n        AuditEntry auditEntry = captor.getValue();\n        assertNotNull(\"DateTime\", auditEntry.getDateTime());\n        assertEquals(\"Operation Type\", operationType.getLabel(), auditEntry.getOperationType());\n        assertEquals(\"Idam ID\", IDAM_MOCK_USER_ID, auditEntry.getIdamId());\n        assertEquals(\"Invoking Service\", invokingService, auditEntry.getInvokingService());\n        assertEquals(\"HTTP Status\", result.getResponse().getStatus(), auditEntry.getHttpStatus());\n        assertEquals(\"HTTP Method\", result.getRequest().getMethod(), auditEntry.getHttpMethod());\n        assertEquals(\"Request Path\", result.getRequest().getRequestURI(), auditEntry.getRequestPath());\n        assertEquals(\"Request ID\", EXAMPLE_REQUEST_ID, auditEntry.getRequestId());\n        // NB: skip validation of inputs for BAD_REQUEST as some may not have been populated\n        if (result.getResponse().getStatus() != HttpStatus.BAD_REQUEST.value()) {\n            if (documentIds != null && !documentIds.isEmpty()) {\n                assertThat(auditEntry.getDocumentIds())\n                    .isNotNull()\n                    .hasSize(documentIds.size())\n                    .containsAll(documentIds);\n            } else {\n                assertThat(auditEntry.getDocumentIds()).isNullOrEmpty();\n            }\n            if (caseId != null && !caseId.equals(\"\")) {\n                assertThat(auditEntry.getCaseId())\n                    .isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseId()).isNullOrEmpty();\n            }\n            if (jurisdiction != null && !jurisdiction.equals(\"\")) {\n                assertThat(auditEntry.getJurisdiction())\n                    .isNotNull();\n            } else {\n                assertThat(auditEntry.getJurisdiction()).isNullOrEmpty();\n            }\n            if (caseType != null && !caseType.equals(\"\")) {\n                assertThat(auditEntry.getCaseType())\n                    .isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseType()).isNullOrEmpty();\n            }\n        }\n    }\n    private static String generateAuthToken(long ttlMillis) throws JOSEException {\n        JWTClaimsSet.Builder builder = new JWTClaimsSet.Builder()\n            .subject(\"API_Stub\")\n            .issueTime(new Date())\n            .claim(TOKEN_NAME, ACCESS_TOKEN)\n            .expirationTime(new Date(System.currentTimeMillis() + ttlMillis));\n        SignedJWT signedJWT = new SignedJWT(\n            new JWSHeader.Builder(JWSAlgorithm.RS256)\n                .keyID(KeyGenUtil.getRsaJWK().getKeyID()).build(),\n            builder.build()\n        );\n        signedJWT.sign(new RSASSASigner(KeyGenUtil.getRsaJWK()));\n        return signedJWT.serialize();\n    }\n    private static String generateS2SToken(String serviceName, long ttlMillis) {\n        return Jwts.builder()\n            .setSubject(serviceName)\n            .setExpiration(new Date(System.currentTimeMillis() + ttlMillis))\n            .signWith(SignatureAlgorithm.HS256, TextCodec.BASE64.encode(\"AA\"))\n            .compact();\n    }\n"]]}
{"hexsha": "1962c85665f13d6ae1a31bdf9bcc8be6c9e4f9ee", "ext": "java", "lang": "Java", "content": "public class TopMetricFilter implements ISetWiseProcessingStrategy {\r\n\r\n\t/**\r\n     * Reference to the logger\r\n     */\r\n    private static final Logger LOGGER = LogManager.getLogger(\"main\");\r\n\t\r\n    /**\r\n     * Internally used correlation threshold.\r\n     */\r\n    double correlationThreshold = 0.5;\r\n\r\n    /*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see de.ugoe.cs.cpdp.IParameterizable#setParameter(java.lang.String)\r\n     */\r\n    @Override\r\n    public void setParameter(String parameters) {\r\n        if (parameters != null && !parameters.equals(\"\")) {\r\n            this.correlationThreshold = Double.parseDouble(parameters);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void apply(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) {\r\n        try {\r\n            determineTopKAttributes(testversion, trainversionSet);\r\n        }\r\n        catch (Exception e) {\r\n            LOGGER.error(\"Failure during metric selection: \" + e.getMessage());\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private void determineTopKAttributes(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet)\r\n        throws Exception\r\n    {   \r\n        Instances testdata = testversion.getInstances();\r\n        Integer[] counts = new Integer[trainversionSet.get(0).getInstances().get(0).numAttributes() - 1];\r\n        IntStream.range(0, counts.length).forEach(val -> counts[val] = 0);\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            J48 decisionTree = new J48();\r\n            decisionTree.buildClassifier(traindata);\r\n            int k = 0;\r\n            for (int j = 0; j < traindata.numAttributes(); j++) {\r\n                if (j != traindata.classIndex()) {\r\n                    if (decisionTree.toString().contains(traindata.attribute(j).name())) {\r\n                        counts[k] = counts[k] + 1;\r\n                    }\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n        int[] topkIndex = new int[counts.length];\r\n        IntStream.range(0, counts.length).forEach(val -> topkIndex[val] = val);\r\n        SortUtils.quicksort(counts, topkIndex, true);\r\n\r\n        // get CFSs for each training set\r\n        List<Set<Integer>> cfsSets = new LinkedList<>();\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            boolean selectionSuccessful = false;\r\n            boolean secondAttempt = false;\r\n            Instances traindataCopy = null;\r\n            do {\r\n                try {\r\n                    if (secondAttempt) {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindataCopy);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    }\r\n                    else {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindata);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    }\r\n                }\r\n                catch (IllegalArgumentException e) {\r\n                    String regex = \"A nominal attribute \\\\((.*)\\\\) cannot have duplicate labels.*\";\r\n                    Pattern p = Pattern.compile(regex);\r\n                    Matcher m = p.matcher(e.getMessage());\r\n                    if (!m.find()) {\r\n                        // cannot treat problem, rethrow exception\r\n                        throw e;\r\n                    }\r\n                    String attributeName = m.group(1);\r\n                    int attrIndex = traindata.attribute(attributeName).index();\r\n                    if (secondAttempt) {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindataCopy, attrIndex);\r\n                    }\r\n                    else {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindata, attrIndex);\r\n                    }\r\n                    LOGGER.info(\"upscaled attribute \" + attributeName + \"; restarting training\");\r\n                    secondAttempt = true;\r\n                    continue;\r\n                }\r\n            }\r\n            while (!selectionSuccessful); // dummy loop for internal continue\r\n        }\r\n\r\n        double[] coverages = new double[topkIndex.length];\r\n        for (Set<Integer> cfsSet : cfsSets) {\r\n            Set<Integer> topkSet = new HashSet<>();\r\n            for (int k = 0; k < topkIndex.length; k++) {\r\n                topkSet.add(topkIndex[k]);\r\n                coverages[k] += (coverage(topkSet, cfsSet) / trainversionSet.size());\r\n            }\r\n        }\r\n        double bestCoverageValue = Double.MIN_VALUE;\r\n        int bestCoverageIndex = 0;\r\n        for (int i = 0; i < coverages.length; i++) {\r\n            if (coverages[i] > bestCoverageValue) {\r\n                bestCoverageValue = coverages[i];\r\n                bestCoverageIndex = i;\r\n            }\r\n        }\r\n        // build correlation matrix\r\n        SpearmansCorrelation corr = new SpearmansCorrelation();\r\n        double[][] correlationMatrix = new double[bestCoverageIndex][bestCoverageIndex];\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            double[][] vectors = new double[bestCoverageIndex][traindata.size()];\r\n            for (int i = 0; i < traindata.size(); i++) {\r\n                for (int j = 0; j < bestCoverageIndex; j++) {\r\n                    vectors[j][i] = traindata.get(i).value(topkIndex[j]);\r\n                }\r\n            }\r\n            for (int j = 0; j < bestCoverageIndex; j++) {\r\n                for (int k = j + 1; k < bestCoverageIndex; k++) {\r\n                    correlationMatrix[j][k] = Math.abs(corr.correlation(vectors[j], vectors[k]));\r\n                }\r\n            }\r\n        }\r\n        Set<Integer> topkSetIndexSet = new TreeSet<>();\r\n        // j<30 ensures that the computational time does not explode since the powerset is 2^n in\r\n        // complexity\r\n        for (int j = 0; j < bestCoverageIndex && j < 30; j++) {\r\n            topkSetIndexSet.add(j);\r\n        }\r\n        Set<Set<Integer>> allCombinations = Sets.powerSet(topkSetIndexSet);\r\n        double bestOptCoverage = Double.MIN_VALUE;\r\n        Set<Integer> opttopkSetIndexSet = null;\r\n        for (Set<Integer> combination : allCombinations) {\r\n            if (isUncorrelated(correlationMatrix, combination)) {\r\n                double currentCoverage = 0.0;\r\n                Set<Integer> topkCombination = new TreeSet<>();\r\n                for (Integer index : combination) {\r\n                    topkCombination.add(topkIndex[index]);\r\n                }\r\n                for (Set<Integer> cfsSet : cfsSets) {\r\n                    currentCoverage += (coverage(topkCombination, cfsSet) / trainversionSet.size());\r\n                }\r\n                if (currentCoverage > bestOptCoverage) {\r\n                    bestOptCoverage = currentCoverage;\r\n                    opttopkSetIndexSet = combination;\r\n                }\r\n            }\r\n        }\r\n        if( opttopkSetIndexSet==null ) {\r\n            throw new RuntimeException(\"Could not determine a best top-k set with optimal coverage. This means that the top-k set and the subset determined by CFS are disjunctive.\");\r\n        }\r\n        \r\n        Set<Integer> opttopkIndex = new TreeSet<>();\r\n        for (Integer index : opttopkSetIndexSet) {\r\n            opttopkIndex.add(topkIndex[index]);\r\n        }\r\n        LOGGER.debug(\"selected the following metrics:\");\r\n        for (Integer index : opttopkIndex) {\r\n            LOGGER.debug(trainversionSet.get(0).getInstances().get(0).attribute(index).name());\r\n        }\r\n        // finally remove attributes\r\n        for (int j = testdata.numAttributes() - 1; j >= 0; j--) {\r\n            if (j != testdata.classIndex() && !opttopkIndex.contains(j)) {\r\n                testdata.deleteAttributeAt(j);\r\n                for (SoftwareVersion trainversion : trainversionSet) {\r\n                    Instances traindata = trainversion.getInstances();\r\n                    traindata.deleteAttributeAt(j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private boolean isUncorrelated(double[][] correlationMatrix, Set<Integer> combination) {\r\n        Integer[] intCombination = combination.toArray(new Integer[0]);\r\n        boolean areUncorrelated = true;\r\n        for (int i = 0; areUncorrelated && i < intCombination.length; i++) {\r\n            for (int j = i + 1; areUncorrelated && j < intCombination.length; j++) {\r\n                areUncorrelated &=\r\n                    correlationMatrix[intCombination[i]][intCombination[j]] > this.correlationThreshold;\r\n            }\r\n        }\r\n        return areUncorrelated;\r\n    }\r\n\r\n    private static double coverage(Set<Integer> topkSet, Set<Integer> cfsSet) {\r\n        Set<Integer> topkSetCopy1 = new HashSet<>(topkSet);\r\n        topkSetCopy1.retainAll(cfsSet);\r\n        Set<Integer> topkSetCopy2 = new HashSet<>(topkSet);\r\n        topkSetCopy2.addAll(cfsSet);\r\n        return ((double) topkSetCopy1.size()) / topkSetCopy2.size();\r\n    }\r\n}", "class_id": 0, "repo": "SteffenTunkel/CrossPare", "file": "CrossPare/src/main/java/de/ugoe/cs/cpdp/dataprocessing/TopMetricFilter.java", "last_update_at": "2021-12-01T06:46:04+00:00", "question_id": "1962c85665f13d6ae1a31bdf9bcc8be6c9e4f9ee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TopMetricFilter implements ISetWiseProcessingStrategy {\r\n\r\n\t/**\r\n     * Reference to the logger\r\n     */\r\n    private static final Logger LOGGER = LogManager.getLogger(\"main\");\r\n\t\r\n    /**\r\n     * Internally used correlation threshold.\r\n     */\r\n    double correlationThreshold = 0.5;\r\n\r\n    /*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see de.ugoe.cs.cpdp.IParameterizable#setParameter(java.lang.String)\r\n     */\r\n    @Override\r\n    public void setParameter(String parameters) {\r\n        if (parameters != null && !parameters.equals(\"\")) {\r\n            this.correlationThreshold = Double.parseDouble(parameters);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void apply(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) {\r\n        try {\r\n            determineTopKAttributes(testversion, trainversionSet);\r\n        }\r\n        catch (Exception e) {\r\n            LOGGER.error(\"Failure during metric selection: \" + e.getMessage());\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private void determineTopKAttributes(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet)\r\n        throws Exception\r\n    {   \r\n        Instances testdata = testversion.getInstances();\r\n        Integer[] counts = new Integer[trainversionSet.get(0).getInstances().get(0).numAttributes() - 1];\r\n        IntStream.range(0, counts.length).forEach(val -> counts[val] = 0);\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            J48 decisionTree = new J48();\r\n            decisionTree.buildClassifier(traindata);\r\n            int k = 0;\r\n            for (int j = 0; j < traindata.numAttributes(); j++) {\r\n                if (j != traindata.classIndex()) {\r\n                    if (decisionTree.toString().contains(traindata.attribute(j).name())) {\r\n                        counts[k] = counts[k] + 1;\r\n                    }\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n        int[] topkIndex = new int[counts.length];\r\n        IntStream.range(0, counts.length).forEach(val -> topkIndex[val] = val);\r\n        SortUtils.quicksort(counts, topkIndex, true);\r\n\r\n        // get CFSs for each training set\r\n        List<Set<Integer>> cfsSets = new LinkedList<>();\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            boolean selectionSuccessful = false;\r\n            boolean secondAttempt = false;\r\n            Instances traindataCopy = null;\r\n            do {\r\n                try {\r\n                    if (secondAttempt) {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindataCopy);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    }\r\n                    else {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindata);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    }\r\n                }\r\n                catch (IllegalArgumentException e) {\r\n                    String regex = \"A nominal attribute \\\\((.*)\\\\) cannot have duplicate labels.*\";\r\n                    Pattern p = Pattern.compile(regex);\r\n                    Matcher m = p.matcher(e.getMessage());\r\n                    if (!m.find()) {\r\n                        // cannot treat problem, rethrow exception\r\n                        throw e;\r\n                    }\r\n                    String attributeName = m.group(1);\r\n                    int attrIndex = traindata.attribute(attributeName).index();\r\n                    if (secondAttempt) {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindataCopy, attrIndex);\r\n                    }\r\n                    else {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindata, attrIndex);\r\n                    }\r\n                    LOGGER.info(\"upscaled attribute \" + attributeName + \"; restarting training\");\r\n                    secondAttempt = true;\r\n                    continue;\r\n                }\r\n            }\r\n            while (!selectionSuccessful); // dummy loop for internal continue\r\n        }\r\n\r\n        double[] coverages = new double[topkIndex.length];\r\n        for (Set<Integer> cfsSet : cfsSets) {\r\n            Set<Integer> topkSet = new HashSet<>();\r\n            for (int k = 0; k < topkIndex.length; k++) {\r\n                topkSet.add(topkIndex[k]);\r\n                coverages[k] += (coverage(topkSet, cfsSet) / trainversionSet.size());\r\n            }\r\n        }\r\n        double bestCoverageValue = Double.MIN_VALUE;\r\n        int bestCoverageIndex = 0;\r\n        for (int i = 0; i < coverages.length; i++) {\r\n            if (coverages[i] > bestCoverageValue) {\r\n                bestCoverageValue = coverages[i];\r\n                bestCoverageIndex = i;\r\n            }\r\n        }\r\n        // build correlation matrix\r\n        SpearmansCorrelation corr = new SpearmansCorrelation();\r\n        double[][] correlationMatrix = new double[bestCoverageIndex][bestCoverageIndex];\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            double[][] vectors = new double[bestCoverageIndex][traindata.size()];\r\n            for (int i = 0; i < traindata.size(); i++) {\r\n                for (int j = 0; j < bestCoverageIndex; j++) {\r\n                    vectors[j][i] = traindata.get(i).value(topkIndex[j]);\r\n                }\r\n            }\r\n            for (int j = 0; j < bestCoverageIndex; j++) {\r\n                for (int k = j + 1; k < bestCoverageIndex; k++) {\r\n                    correlationMatrix[j][k] = Math.abs(corr.correlation(vectors[j], vectors[k]));\r\n                }\r\n            }\r\n        }\r\n        Set<Integer> topkSetIndexSet = new TreeSet<>();\r\n        // j<30 ensures that the computational time does not explode since the powerset is 2^n in\r\n        // complexity\r\n        for (int j = 0; j < bestCoverageIndex && j < 30; j++) {\r\n            topkSetIndexSet.add(j);\r\n        }\r\n        Set<Set<Integer>> allCombinations = Sets.powerSet(topkSetIndexSet);\r\n        double bestOptCoverage = Double.MIN_VALUE;\r\n        Set<Integer> opttopkSetIndexSet = null;\r\n        for (Set<Integer> combination : allCombinations) {\r\n            if (isUncorrelated(correlationMatrix, combination)) {\r\n                double currentCoverage = 0.0;\r\n                Set<Integer> topkCombination = new TreeSet<>();\r\n                for (Integer index : combination) {\r\n                    topkCombination.add(topkIndex[index]);\r\n                }\r\n                for (Set<Integer> cfsSet : cfsSets) {\r\n                    currentCoverage += (coverage(topkCombination, cfsSet) / trainversionSet.size());\r\n                }\r\n                if (currentCoverage > bestOptCoverage) {\r\n                    bestOptCoverage = currentCoverage;\r\n                    opttopkSetIndexSet = combination;\r\n                }\r\n            }\r\n        }\r\n        if( opttopkSetIndexSet==null ) {\r\n            throw new RuntimeException(\"Could not determine a best top-k set with optimal coverage. This means that the top-k set and the subset determined by CFS are disjunctive.\");\r\n        }\r\n        \r\n        Set<Integer> opttopkIndex = new TreeSet<>();\r\n        for (Integer index : opttopkSetIndexSet) {\r\n            opttopkIndex.add(topkIndex[index]);\r\n        }\r\n        LOGGER.debug(\"selected the following metrics:\");\r\n        for (Integer index : opttopkIndex) {\r\n            LOGGER.debug(trainversionSet.get(0).getInstances().get(0).attribute(index).name());\r\n        }\r\n        // finally remove attributes\r\n        for (int j = testdata.numAttributes() - 1; j >= 0; j--) {\r\n            if (j != testdata.classIndex() && !opttopkIndex.contains(j)) {\r\n                testdata.deleteAttributeAt(j);\r\n                for (SoftwareVersion trainversion : trainversionSet) {\r\n                    Instances traindata = trainversion.getInstances();\r\n                    traindata.deleteAttributeAt(j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private boolean isUncorrelated(double[][] correlationMatrix, Set<Integer> combination) {\r\n        Integer[] intCombination = combination.toArray(new Integer[0]);\r\n        boolean areUncorrelated = true;\r\n        for (int i = 0; areUncorrelated && i < intCombination.length; i++) {\r\n            for (int j = i + 1; areUncorrelated && j < intCombination.length; j++) {\r\n                areUncorrelated &=\r\n                    correlationMatrix[intCombination[i]][intCombination[j]] > this.correlationThreshold;\r\n            }\r\n        }\r\n        return areUncorrelated;\r\n    }\r\n\r\n    private static double coverage(Set<Integer> topkSet, Set<Integer> cfsSet) {\r\n        Set<Integer> topkSetCopy1 = new HashSet<>(topkSet);\r\n        topkSetCopy1.retainAll(cfsSet);\r\n        Set<Integer> topkSetCopy2 = new HashSet<>(topkSet);\r\n        topkSetCopy2.addAll(cfsSet);\r\n        return ((double) topkSetCopy1.size()) / topkSetCopy2.size();\r\n    }\r\n"]]}
{"hexsha": "c96c4ecc65c9873bc3aeb3bef98ea74ea5e3c409", "ext": "java", "lang": "Java", "content": "public class CryptUtilsTest {\n\n    private static final Logger LOG = LoggerFactory.getLogger(CryptUtilsTest.class);\n\n    @Test\n    public void testPositive() throws Exception {\n\n        CryptUtils cu = new CryptUtils();\n        \n        long encStartTime = System.currentTimeMillis();\n\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        String result1b = cu.encrypt(\"msg\", \"pwd\");\n        String result2 = cu.encrypt(\"msg\", \"pwd2\");\n\n        long encEndTime = System.currentTimeMillis();\n\n        LOG.info(result1a);\n        LOG.info(result1b);\n        LOG.info(result2);\n        \n        assertNotEquals(result1a, result1b);\n        assertNotEquals(result1a, result2);\n        \n        long decStartTime = System.currentTimeMillis();\n\n        assertEquals(\"msg\", cu.decrypt(result1a, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result1b, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result2, \"pwd2\"));\n\n        long decEndTime = System.currentTimeMillis();\n\n        LOG.info(String.format(\"encryption speed: %.2f msgs/second, decryption speed: %.2f msgs/second\",\n                3000.0 / (encEndTime - encStartTime), 3000.0 / (decEndTime - decStartTime)));\n    }\n    \n    @Test(expected = AEADBadTagException.class)\n    public void testWrongPwd() throws Exception {\n\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.decrypt(result1a, \"wrongpwd\");\n    }\n    \n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams() throws Exception {\n\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setGcmTagLength(12);\n        cu.decrypt(result1a, \"pwd\");\n    }\n    \n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams2() throws Exception {\n\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setKeySize(192);\n        cu.decrypt(result1a, \"pwd\");\n    }\n}", "class_id": 0, "repo": "jjYBdx4IL/misc", "file": "encryption-utils/src/test/java/com/github/jjYBdx4IL/utils/encryption/CryptUtilsTest.java", "last_update_at": "2021-09-18T07:42:23+00:00", "question_id": "c96c4ecc65c9873bc3aeb3bef98ea74ea5e3c409", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CryptUtilsTest {\n    private static final Logger LOG = LoggerFactory.getLogger(CryptUtilsTest.class);\n    @Test\n    public void testPositive() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        long encStartTime = System.currentTimeMillis();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        String result1b = cu.encrypt(\"msg\", \"pwd\");\n        String result2 = cu.encrypt(\"msg\", \"pwd2\");\n        long encEndTime = System.currentTimeMillis();\n        LOG.info(result1a);\n        LOG.info(result1b);\n        LOG.info(result2);\n        assertNotEquals(result1a, result1b);\n        assertNotEquals(result1a, result2);\n        long decStartTime = System.currentTimeMillis();\n        assertEquals(\"msg\", cu.decrypt(result1a, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result1b, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result2, \"pwd2\"));\n        long decEndTime = System.currentTimeMillis();\n        LOG.info(String.format(\"encryption speed: %.2f msgs/second, decryption speed: %.2f msgs/second\",\n                3000.0 / (encEndTime - encStartTime), 3000.0 / (decEndTime - decStartTime)));\n    }\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongPwd() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.decrypt(result1a, \"wrongpwd\");\n    }\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setGcmTagLength(12);\n        cu.decrypt(result1a, \"pwd\");\n    }\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams2() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setKeySize(192);\n        cu.decrypt(result1a, \"pwd\");\n    }\n"]]}
{"hexsha": "75e7aff9329d69de6955705804c709b35b64974f", "ext": "java", "lang": "Java", "content": "public class ZookeeperWatcher {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZookeeperWatcher.class);\n\n    private static final String yuzhouwan4 = \"yuzhouwan04:2181\";\n    private static final String zNode = \"/yuzhouwan\";\n\n    {\n        init();\n    }\n\n    public void init() {\n\n        RetryPolicy retrypolicy = new ExponentialBackoffRetry(3000, 60);\n        CuratorFramework curatorClient;\n//        curatorClient = CuratorFrameworkFactory.newClient(yuzhouwan4, 5000, 3000, retrypolicy);\n\n        /**\n         * using fluent api\n         */\n        curatorClient = CuratorFrameworkFactory.builder()\n                .connectString(yuzhouwan4)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(3000)\n                .retryPolicy(retrypolicy)\n                .namespace(\"watcher\")       // root path: /watcher\n                .build();\n        curatorClient.start();\n\n        final PathChildrenCache cached = new PathChildrenCache(curatorClient, zNode, true);\n        cached.getListenable().addListener((client, event) -> {\n            PathChildrenCacheEvent.Type childrenEventType = event.getType();\n            if (childrenEventType != null) {\n                switch (childrenEventType) {\n                    case CONNECTION_RECONNECTED:\n                        cached.rebuild();\n                        break;\n                    case CONNECTION_SUSPENDED:\n                    case CONNECTION_LOST:\n                        LOG.error(\"Connection error, waiting...\");\n                        break;\n                    default:\n                        LOG.info(\"PathChildrenCache changed : {path:\" + event.getData().getPath() + \" data:\"\n                                + new String(event.getData().getData()) + \"}\");\n                }\n            }\n        });\n        try {\n            cached.start();\n        } catch (Exception e) {\n            LOG.error(\"Can not start PathChildrenCache!!\");\n            throw new RuntimeException(e);\n        }\n    }\n}", "class_id": 0, "repo": "Celebrate-future/yuzhouwan", "file": "yuzhouwan-bigdata/yuzhouwan-bigdata-zookeeper/src/main/java/com/yuzhouwan/bigdata/zookeeper/ZookeeperWatcher.java", "last_update_at": "2021-12-19T11:01:31+00:00", "question_id": "75e7aff9329d69de6955705804c709b35b64974f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ZookeeperWatcher {\n    private static final Logger LOG = LoggerFactory.getLogger(ZookeeperWatcher.class);\n    private static final String yuzhouwan4 = \"yuzhouwan04:2181\";\n    private static final String zNode = \"/yuzhouwan\";\n    {\n        init();\n    }\n    public void init() {\n        RetryPolicy retrypolicy = new ExponentialBackoffRetry(3000, 60);\n        CuratorFramework curatorClient;\n//        curatorClient = CuratorFrameworkFactory.newClient(yuzhouwan4, 5000, 3000, retrypolicy);\n        /**\n         * using fluent api\n         */\n        curatorClient = CuratorFrameworkFactory.builder()\n                .connectString(yuzhouwan4)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(3000)\n                .retryPolicy(retrypolicy)\n                .namespace(\"watcher\")       // root path: /watcher\n                .build();\n        curatorClient.start();\n        final PathChildrenCache cached = new PathChildrenCache(curatorClient, zNode, true);\n        cached.getListenable().addListener((client, event) -> {\n            PathChildrenCacheEvent.Type childrenEventType = event.getType();\n            if (childrenEventType != null) {\n                switch (childrenEventType) {\n                    case CONNECTION_RECONNECTED:\n                        cached.rebuild();\n                        break;\n                    case CONNECTION_SUSPENDED:\n                    case CONNECTION_LOST:\n                        LOG.error(\"Connection error, waiting...\");\n                        break;\n                    default:\n                        LOG.info(\"PathChildrenCache changed : {path:\" + event.getData().getPath() + \" data:\"\n                                + new String(event.getData().getData()) + \"}\");\n                }\n            }\n        });\n        try {\n            cached.start();\n        } catch (Exception e) {\n            LOG.error(\"Can not start PathChildrenCache!!\");\n            throw new RuntimeException(e);\n        }\n    }\n"]]}
{"hexsha": "ac822e94033f3255263e66325468841e95569ce2", "ext": "java", "lang": "Java", "content": "public class ForLab2 {\r\n    public static void main(String[] args) {\r\n\r\n        int[][] x = { {1,2,3} ,{4,5,6} ,{7,8,9} };\r\n        int sum = 0;\r\n        for (int i=0 ; i < x.length ; i++ ){\r\n            for (int j=0 ; j < x[i].length ; j++){\r\n                sum = sum + x[i][j];\r\n            }\r\n        }\r\n\r\n        for ( int[] y : x ){\r\n            for ( int a : y ) {\r\n                System.out.println(a);\r\n            }\r\n        }\r\n\r\n//        System.out.println(\"sum = \"+sum);\r\n    }\r\n}", "class_id": 0, "repo": "chaoannricardo/StudyNotes", "file": "III_DataEngineer_BDSE10/1902_Java/JavaWorkspace/Sample/src/array/ForLab2.java", "last_update_at": "2021-05-18T06:09:25+00:00", "question_id": "ac822e94033f3255263e66325468841e95569ce2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ForLab2 {\r\n    public static void main(String[] args) {\r\n\r\n        int[][] x = { {1,2,3} ,{4,5,6} ,{7,8,9} };\r\n        int sum = 0;\r\n        for (int i=0 ; i < x.length ; i++ ){\r\n            for (int j=0 ; j < x[i].length ; j++){\r\n                sum = sum + x[i][j];\r\n            }\r\n        }\r\n\r\n        for ( int[] y : x ){\r\n            for ( int a : y ) {\r\n                System.out.println(a);\r\n            }\r\n        }\r\n\r\n//        System.out.println(\"sum = \"+sum);\r\n    }\r\n"]]}
{"hexsha": "423faf3c08720e4a86a03cf520bae2cb7efce200", "ext": "java", "lang": "Java", "content": "@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP_PREFIX})\npublic class AnimationUtilsCompat {\n    private AnimationUtilsCompat() {\n    }\n\n    private static Interpolator createInterpolatorFromXml(Context context, Resources resources, Resources.Theme theme, XmlPullParser xmlPullParser) {\n        Interpolator pathInterpolatorCompat;\n        int depth = xmlPullParser.getDepth();\n        Interpolator interpolator = null;\n        while (true) {\n            int next = xmlPullParser.next();\n            if ((next != 3 || xmlPullParser.getDepth() > depth) && next != 1) {\n                if (next == 2) {\n                    AttributeSet asAttributeSet = Xml.asAttributeSet(xmlPullParser);\n                    String name = xmlPullParser.getName();\n                    if (name.equals(\"linearInterpolator\")) {\n                        interpolator = new LinearInterpolator();\n                    } else {\n                        if (name.equals(\"accelerateInterpolator\")) {\n                            pathInterpolatorCompat = new AccelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"decelerateInterpolator\")) {\n                            pathInterpolatorCompat = new DecelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"accelerateDecelerateInterpolator\")) {\n                            interpolator = new AccelerateDecelerateInterpolator();\n                        } else if (name.equals(\"cycleInterpolator\")) {\n                            pathInterpolatorCompat = new CycleInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"overshootInterpolator\")) {\n                            pathInterpolatorCompat = new OvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateOvershootInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateOvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"bounceInterpolator\")) {\n                            interpolator = new BounceInterpolator();\n                        } else if (name.equals(\"pathInterpolator\")) {\n                            pathInterpolatorCompat = new PathInterpolatorCompat(context, asAttributeSet, xmlPullParser);\n                        } else {\n                            throw new RuntimeException(\"Unknown interpolator name: \" + xmlPullParser.getName());\n                        }\n                        interpolator = pathInterpolatorCompat;\n                    }\n                }\n            }\n        }\n        return interpolator;\n    }\n\n    public static Interpolator loadInterpolator(Context context, int i) {\n        if (Build.VERSION.SDK_INT >= 21) {\n            return AnimationUtils.loadInterpolator(context, i);\n        }\n        XmlResourceParser xmlResourceParser = null;\n        if (i == 17563663) {\n            try {\n                return new FastOutLinearInInterpolator();\n            } catch (XmlPullParserException e) {\n                Resources.NotFoundException notFoundException = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException.initCause(e);\n                throw notFoundException;\n            } catch (IOException e2) {\n                Resources.NotFoundException notFoundException2 = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException2.initCause(e2);\n                throw notFoundException2;\n            } catch (Throwable th) {\n                if (xmlResourceParser != null) {\n                    xmlResourceParser.close();\n                }\n                throw th;\n            }\n        } else if (i == 17563661) {\n            return new FastOutSlowInInterpolator();\n        } else {\n            if (i == 17563662) {\n                return new LinearOutSlowInInterpolator();\n            }\n            XmlResourceParser animation = context.getResources().getAnimation(i);\n            Interpolator createInterpolatorFromXml = createInterpolatorFromXml(context, context.getResources(), context.getTheme(), animation);\n            if (animation != null) {\n                animation.close();\n            }\n            return createInterpolatorFromXml;\n        }\n    }\n}", "class_id": 0, "repo": "abhiManyuSingh59/Track-And-Trail", "file": "vectordrawable/graphics/drawable/AnimationUtilsCompat.java", "last_update_at": "2021-07-18T09:35:51+00:00", "question_id": "423faf3c08720e4a86a03cf520bae2cb7efce200", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP_PREFIX})\npublic class AnimationUtilsCompat {\n    private AnimationUtilsCompat() {\n    }\n    private static Interpolator createInterpolatorFromXml(Context context, Resources resources, Resources.Theme theme, XmlPullParser xmlPullParser) {\n        Interpolator pathInterpolatorCompat;\n        int depth = xmlPullParser.getDepth();\n        Interpolator interpolator = null;\n        while (true) {\n            int next = xmlPullParser.next();\n            if ((next != 3 || xmlPullParser.getDepth() > depth) && next != 1) {\n                if (next == 2) {\n                    AttributeSet asAttributeSet = Xml.asAttributeSet(xmlPullParser);\n                    String name = xmlPullParser.getName();\n                    if (name.equals(\"linearInterpolator\")) {\n                        interpolator = new LinearInterpolator();\n                    } else {\n                        if (name.equals(\"accelerateInterpolator\")) {\n                            pathInterpolatorCompat = new AccelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"decelerateInterpolator\")) {\n                            pathInterpolatorCompat = new DecelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"accelerateDecelerateInterpolator\")) {\n                            interpolator = new AccelerateDecelerateInterpolator();\n                        } else if (name.equals(\"cycleInterpolator\")) {\n                            pathInterpolatorCompat = new CycleInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"overshootInterpolator\")) {\n                            pathInterpolatorCompat = new OvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateOvershootInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateOvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"bounceInterpolator\")) {\n                            interpolator = new BounceInterpolator();\n                        } else if (name.equals(\"pathInterpolator\")) {\n                            pathInterpolatorCompat = new PathInterpolatorCompat(context, asAttributeSet, xmlPullParser);\n                        } else {\n                            throw new RuntimeException(\"Unknown interpolator name: \" + xmlPullParser.getName());\n                        }\n                        interpolator = pathInterpolatorCompat;\n                    }\n                }\n            }\n        }\n        return interpolator;\n    }\n    public static Interpolator loadInterpolator(Context context, int i) {\n        if (Build.VERSION.SDK_INT >= 21) {\n            return AnimationUtils.loadInterpolator(context, i);\n        }\n        XmlResourceParser xmlResourceParser = null;\n        if (i == 17563663) {\n            try {\n                return new FastOutLinearInInterpolator();\n            } catch (XmlPullParserException e) {\n                Resources.NotFoundException notFoundException = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException.initCause(e);\n                throw notFoundException;\n            } catch (IOException e2) {\n                Resources.NotFoundException notFoundException2 = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException2.initCause(e2);\n                throw notFoundException2;\n            } catch (Throwable th) {\n                if (xmlResourceParser != null) {\n                    xmlResourceParser.close();\n                }\n                throw th;\n            }\n        } else if (i == 17563661) {\n            return new FastOutSlowInInterpolator();\n        } else {\n            if (i == 17563662) {\n                return new LinearOutSlowInInterpolator();\n            }\n            XmlResourceParser animation = context.getResources().getAnimation(i);\n            Interpolator createInterpolatorFromXml = createInterpolatorFromXml(context, context.getResources(), context.getTheme(), animation);\n            if (animation != null) {\n                animation.close();\n            }\n            return createInterpolatorFromXml;\n        }\n    }\n"]]}
{"hexsha": "d5ac6617927f4b4b7426323e7423cf1ef9f5dad1", "ext": "java", "lang": "Java", "content": "public class ComputationPipeline {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ComputationPipeline.class);\n    private static final long DEFAULT_WAIT_TIME_IN_SECONDS = 30;\n    private final List<PipelineStreamSource> sources = Lists.newArrayList();\n    private final List<PipelineStage> stages = Lists.newArrayList();\n\n    private NotificationBus notificationBus;\n    private long waitTimeInSeconds;\n    private String computationName;\n\n    public static ComputationPipeline builder() {\n        return new ComputationPipeline();\n    }\n\n    public ComputationPipeline notificationBus(NotificationBus notificationBusArg) {\n        this.notificationBus = notificationBusArg;\n        return this;\n    }\n\n    public ComputationPipeline computationName(String computationNameArg) {\n        this.computationName = computationNameArg;\n        return this;\n    }\n\n    public ComputationPipeline addSource(PipelineStreamSource streamSource) {\n        this.sources.add(streamSource);\n        return this;\n    }\n\n    public ComputationPipeline addPipelineStage(PipelineStage pipelineStage) {\n        this.stages.add(pipelineStage);\n        return this;\n    }\n\n    public ComputationPipeline connect(MessageSource to, PipelineStage... pipelineStages) {\n        notificationBus.connect(to, pipelineStages);\n        return this;\n    }\n\n    public ComputationPipeline initialize(Properties properties) {\n        properties.put(\"computation.name\", computationName);\n        waitTimeInSeconds = PropertyReader.readLong(properties, properties, \"computation.shutdown.wait_time_in_seconds\",\n            DEFAULT_WAIT_TIME_IN_SECONDS);\n\n        sources.forEach(streamSource -> {\n            try {\n                streamSource.initialize(properties);\n                ComponentMetadata componentMetadata = streamSource.getSourceMetadata();\n                LOGGER.info(\"Initialized source: {}:{}:{}->{}\", componentMetadata.getNamespace(),\n                        componentMetadata.getName(), componentMetadata.getVersion(), streamSource.getInstanceId());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Error initializing source: %s\", streamSource.getInstanceId()),\n                        e);\n            }\n        });\n        stages.forEach(stage -> {\n            try {\n                stage.initialize(properties);\n                ComponentMetadata componentMetadata = stage.getProcessorMetadata();\n                LOGGER.info(\"Initialized processor: {}:{}:{}->{}\",\n                    componentMetadata.getNamespace(),\n                    componentMetadata.getName(),\n                    componentMetadata.getVersion(),\n                    stage.getInstanceId());\n            } catch (InitializationException e) {\n                throw new RuntimeException(String.format(\"Error initializing processor: %s\", stage.getInstanceId()), e);\n            }\n        });\n        return this;\n    }\n\n    public boolean healthcheck() {\n        boolean a = true;\n        try {\n            for (PipelineStreamSource source : sources) {\n                a = a & source.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n            for (PipelineStage stage : stages) {\n                a = a & stage.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n        } catch (Throwable t) {\n            a = false;\n            LOGGER.error(\"Error when calling healthcheck on one of the components: \", t);\n        }\n        return a;\n    }\n\n    public ComputationPipeline start() {\n        LOGGER.info(\"Starting pipeline...\");\n        notificationBus.start();\n        stages.forEach(PipelineStage::start);\n        sources.forEach(PipelineStreamSource::start);\n        return this;\n    }\n\n    public void stop() {\n        LOGGER.info(\"Stopping pipeline...\");\n        sources.forEach(PipelineStreamSource::stop);\n        // adding sufficient sleep time for a graceful stop, allowing enough time for events in transit to be processed\n        try {\n            Thread.sleep(waitTimeInSeconds * 1000);\n        } catch (InterruptedException iEx) {\n            LOGGER.warn(\"Sleep was interrupted: \" + iEx.getMessage());\n        }\n        stages.forEach(PipelineStage::stop);\n        notificationBus.stop();\n    }\n}", "class_id": 0, "repo": "apsingh12/fabric", "file": "fabric-compute-framework/src/main/java/com/olacabs/fabric/compute/pipeline/ComputationPipeline.java", "last_update_at": "2021-05-30T10:24:48+00:00", "question_id": "d5ac6617927f4b4b7426323e7423cf1ef9f5dad1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ComputationPipeline {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ComputationPipeline.class);\n    private static final long DEFAULT_WAIT_TIME_IN_SECONDS = 30;\n    private final List<PipelineStreamSource> sources = Lists.newArrayList();\n    private final List<PipelineStage> stages = Lists.newArrayList();\n    private NotificationBus notificationBus;\n    private long waitTimeInSeconds;\n    private String computationName;\n    public static ComputationPipeline builder() {\n        return new ComputationPipeline();\n    }\n    public ComputationPipeline notificationBus(NotificationBus notificationBusArg) {\n        this.notificationBus = notificationBusArg;\n        return this;\n    }\n    public ComputationPipeline computationName(String computationNameArg) {\n        this.computationName = computationNameArg;\n        return this;\n    }\n    public ComputationPipeline addSource(PipelineStreamSource streamSource) {\n        this.sources.add(streamSource);\n        return this;\n    }\n    public ComputationPipeline addPipelineStage(PipelineStage pipelineStage) {\n        this.stages.add(pipelineStage);\n        return this;\n    }\n    public ComputationPipeline connect(MessageSource to, PipelineStage... pipelineStages) {\n        notificationBus.connect(to, pipelineStages);\n        return this;\n    }\n    public ComputationPipeline initialize(Properties properties) {\n        properties.put(\"computation.name\", computationName);\n        waitTimeInSeconds = PropertyReader.readLong(properties, properties, \"computation.shutdown.wait_time_in_seconds\",\n            DEFAULT_WAIT_TIME_IN_SECONDS);\n        sources.forEach(streamSource -> {\n            try {\n                streamSource.initialize(properties);\n                ComponentMetadata componentMetadata = streamSource.getSourceMetadata();\n                LOGGER.info(\"Initialized source: {}:{}:{}->{}\", componentMetadata.getNamespace(),\n                        componentMetadata.getName(), componentMetadata.getVersion(), streamSource.getInstanceId());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Error initializing source: %s\", streamSource.getInstanceId()),\n                        e);\n            }\n        });\n        stages.forEach(stage -> {\n            try {\n                stage.initialize(properties);\n                ComponentMetadata componentMetadata = stage.getProcessorMetadata();\n                LOGGER.info(\"Initialized processor: {}:{}:{}->{}\",\n                    componentMetadata.getNamespace(),\n                    componentMetadata.getName(),\n                    componentMetadata.getVersion(),\n                    stage.getInstanceId());\n            } catch (InitializationException e) {\n                throw new RuntimeException(String.format(\"Error initializing processor: %s\", stage.getInstanceId()), e);\n            }\n        });\n        return this;\n    }\n    public boolean healthcheck() {\n        boolean a = true;\n        try {\n            for (PipelineStreamSource source : sources) {\n                a = a & source.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n            for (PipelineStage stage : stages) {\n                a = a & stage.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n        } catch (Throwable t) {\n            a = false;\n            LOGGER.error(\"Error when calling healthcheck on one of the components: \", t);\n        }\n        return a;\n    }\n    public ComputationPipeline start() {\n        LOGGER.info(\"Starting pipeline...\");\n        notificationBus.start();\n        stages.forEach(PipelineStage::start);\n        sources.forEach(PipelineStreamSource::start);\n        return this;\n    }\n    public void stop() {\n        LOGGER.info(\"Stopping pipeline...\");\n        sources.forEach(PipelineStreamSource::stop);\n        // adding sufficient sleep time for a graceful stop, allowing enough time for events in transit to be processed\n        try {\n            Thread.sleep(waitTimeInSeconds * 1000);\n        } catch (InterruptedException iEx) {\n            LOGGER.warn(\"Sleep was interrupted: \" + iEx.getMessage());\n        }\n        stages.forEach(PipelineStage::stop);\n        notificationBus.stop();\n    }\n"]]}
{"hexsha": "67e1a9532bb4ba1630a30e9b874e7bee7caead7c", "ext": "java", "lang": "Java", "content": "class PersonNameField extends ValueFieldTest {\r\n\r\n    public void clearAssociation(final NakedObject inObject) {\r\n        getPerson(inObject).setName(\"\");\r\n    }\r\n\r\n    public String debugData() {\r\n        return \"\";\r\n    }\r\n\r\n    public NakedObject get(final NakedObject fromObject) {\r\n        final TestProxyNakedObject nakedObject = new TestProxyNakedObject();\r\n        nakedObject.setupObject(getPerson(fromObject).getName());\r\n        return nakedObject;\r\n    }\r\n\r\n    public String getId() {\r\n        return \"name\";\r\n    }\r\n\r\n    public String getName() {\r\n        return \"Name\";\r\n    }\r\n\r\n    private Person getPerson(final NakedObject inObject) {\r\n        return (Person) inObject.getObject();\r\n    }\r\n\r\n    public NakedObjectSpecification getSpecification() {\r\n        return new TestSpecification(\"java.lang.String\");\r\n    }\r\n\r\n    public void initAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public Consent isAssociationValid(final NakedObject inObject, final NakedObject association) {\r\n        return Allow.DEFAULT;\r\n    }\r\n\r\n    public void setAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public void set(NakedObject owner, NakedObject newValue) {\r\n        setAssociation(owner, newValue);\r\n    }\r\n\r\n}", "class_id": 0, "repo": "Corpus-2021/nakedobjects-4.0.0", "file": "core/runtime/src/test/java/org/nakedobjects/runtime/testspec/PersonSpecification.java", "last_update_at": "2021-02-22T15:40:05+00:00", "question_id": "67e1a9532bb4ba1630a30e9b874e7bee7caead7c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class PersonNameField extends ValueFieldTest {\r\n\r\n    public void clearAssociation(final NakedObject inObject) {\r\n        getPerson(inObject).setName(\"\");\r\n    }\r\n\r\n    public String debugData() {\r\n        return \"\";\r\n    }\r\n\r\n    public NakedObject get(final NakedObject fromObject) {\r\n        final TestProxyNakedObject nakedObject = new TestProxyNakedObject();\r\n        nakedObject.setupObject(getPerson(fromObject).getName());\r\n        return nakedObject;\r\n    }\r\n\r\n    public String getId() {\r\n        return \"name\";\r\n    }\r\n\r\n    public String getName() {\r\n        return \"Name\";\r\n    }\r\n\r\n    private Person getPerson(final NakedObject inObject) {\r\n        return (Person) inObject.getObject();\r\n    }\r\n\r\n    public NakedObjectSpecification getSpecification() {\r\n        return new TestSpecification(\"java.lang.String\");\r\n    }\r\n\r\n    public void initAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public Consent isAssociationValid(final NakedObject inObject, final NakedObject association) {\r\n        return Allow.DEFAULT;\r\n    }\r\n\r\n    public void setAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public void set(NakedObject owner, NakedObject newValue) {\r\n        setAssociation(owner, newValue);\r\n    }\r\n\r\n"]]}
{"hexsha": "0a4a4369ec3b6de4d86e3c5f2ecc32c64dac30a0", "ext": "java", "lang": "Java", "content": "public class Identifieds {\n\n    private Identifieds() {\n    }\n    \n    public static Function<Identified, Description> TO_DESCRIPTION = new Function<Identified, Description>() {\n        @Override\n        public Description apply(Identified input) {\n            return (Description) input;\n        }\n    };\n    \n    public static Predicate<Identified> IS_DESCRIPTION = new Predicate<Identified>() {\n        @Override\n        public boolean apply(Identified input) {\n            return input instanceof Description;\n        }\n    };\n    \n    public static List<Description> getDescriptions(Iterable<? extends Identified> identifieds) {\n        return ImmutableList.copyOf(Iterables.transform(Iterables.filter(identifieds, IS_DESCRIPTION), TO_DESCRIPTION));\n    }\n    \n    private static Iterable<Person> getEmbeddedPeople(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_PEOPLE));\n    }\n    \n    private static Iterable<Identified> getEmbeddedBrandsAndSeries(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_BRAND_AND_SERIES_SUMMARIES));\n    }\n    \n    public static Iterable<Identified> getFlattenedIdentifieds(Iterable<? extends Identified> identifieds) {\n        \n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        Iterable<Description> allDescriptions = Iterables.filter(identifieds, Description.class);\n        \n        List<Item> allItems = Descriptions.getItems(allDescriptions);\n        Iterable<Identified> embeddedBrandsAndSeries = getEmbeddedBrandsAndSeries(allItems);\n        Iterable<Person> embeddedPeople = getEmbeddedPeople(allItems);\n        \n        return Iterables.concat(allDescriptions, embeddedBrandsAndSeries, people, embeddedPeople);\n    }\n    \n    public static Iterable<ContentIdentifier> getContentIdentifiers(Iterable<? extends Identified> identifieds) {\n        Builder<ContentIdentifier> builder = ImmutableList.builder();\n        \n        Iterable<Playlist> playlists = Iterables.filter(identifieds, Playlist.class);\n        for (Playlist playlist : playlists) {\n            builder.addAll(playlist.getContent());\n            builder.addAll(playlist.getSeriesList());\n            if (playlist.getAvailableContent() != null) {\n                builder.addAll(playlist.getAvailableContent());\n            }\n            if (playlist.getUpcomingContent() != null) {\n                builder.addAll(playlist.getUpcomingContent());\n            }\n        }\n        \n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        for (Person person : people) {\n           // people embedded in items/brands don't have content attached\n           if (person.getContent() != null) {\n               builder.addAll(person.getContent());\n           }\n        }\n        \n        return builder.build();\n    }\n    \n    private static final Function<Item, Iterable<Identified>> TO_BRAND_AND_SERIES_SUMMARIES = new Function<Item, Iterable<Identified>>() {\n        @Override\n        public Iterable<Identified> apply(Item input) {\n            \n            Builder<Identified> builder = ImmutableList.builder();\n            if (input.getSeriesSummary() != null) {\n                builder.add(input.getSeriesSummary());\n            }\n            if (input.getBrandSummary() != null) {\n                builder.add(input.getBrandSummary());\n            }\n            return builder.build();\n        }\n    };\n}", "class_id": 0, "repo": "atlasapi/atlas-model", "file": "src/main/java/org/atlasapi/media/util/Identifieds.java", "last_update_at": "2021-11-08T08:35:28+00:00", "question_id": "0a4a4369ec3b6de4d86e3c5f2ecc32c64dac30a0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Identifieds {\n    private Identifieds() {\n    }\n    public static Function<Identified, Description> TO_DESCRIPTION = new Function<Identified, Description>() {\n        @Override\n        public Description apply(Identified input) {\n            return (Description) input;\n        }\n    };\n    public static Predicate<Identified> IS_DESCRIPTION = new Predicate<Identified>() {\n        @Override\n        public boolean apply(Identified input) {\n            return input instanceof Description;\n        }\n    };\n    public static List<Description> getDescriptions(Iterable<? extends Identified> identifieds) {\n        return ImmutableList.copyOf(Iterables.transform(Iterables.filter(identifieds, IS_DESCRIPTION), TO_DESCRIPTION));\n    }\n    private static Iterable<Person> getEmbeddedPeople(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_PEOPLE));\n    }\n    private static Iterable<Identified> getEmbeddedBrandsAndSeries(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_BRAND_AND_SERIES_SUMMARIES));\n    }\n    public static Iterable<Identified> getFlattenedIdentifieds(Iterable<? extends Identified> identifieds) {\n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        Iterable<Description> allDescriptions = Iterables.filter(identifieds, Description.class);\n        List<Item> allItems = Descriptions.getItems(allDescriptions);\n        Iterable<Identified> embeddedBrandsAndSeries = getEmbeddedBrandsAndSeries(allItems);\n        Iterable<Person> embeddedPeople = getEmbeddedPeople(allItems);\n        return Iterables.concat(allDescriptions, embeddedBrandsAndSeries, people, embeddedPeople);\n    }\n    public static Iterable<ContentIdentifier> getContentIdentifiers(Iterable<? extends Identified> identifieds) {\n        Builder<ContentIdentifier> builder = ImmutableList.builder();\n        Iterable<Playlist> playlists = Iterables.filter(identifieds, Playlist.class);\n        for (Playlist playlist : playlists) {\n            builder.addAll(playlist.getContent());\n            builder.addAll(playlist.getSeriesList());\n            if (playlist.getAvailableContent() != null) {\n                builder.addAll(playlist.getAvailableContent());\n            }\n            if (playlist.getUpcomingContent() != null) {\n                builder.addAll(playlist.getUpcomingContent());\n            }\n        }\n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        for (Person person : people) {\n           // people embedded in items/brands don't have content attached\n           if (person.getContent() != null) {\n               builder.addAll(person.getContent());\n           }\n        }\n        return builder.build();\n    }\n    private static final Function<Item, Iterable<Identified>> TO_BRAND_AND_SERIES_SUMMARIES = new Function<Item, Iterable<Identified>>() {\n        @Override\n        public Iterable<Identified> apply(Item input) {\n            Builder<Identified> builder = ImmutableList.builder();\n            if (input.getSeriesSummary() != null) {\n                builder.add(input.getSeriesSummary());\n            }\n            if (input.getBrandSummary() != null) {\n                builder.add(input.getBrandSummary());\n            }\n            return builder.build();\n        }\n    };\n"]]}
{"hexsha": "dd665ca0160a69141e541d7df9ca35966420c029", "ext": "java", "lang": "Java", "content": "class FilesystemSource extends AbstractSource\n        implements StreamSource, FileSource {\n\n    private static final Logger LOGGER =\n            LoggerFactory.getLogger(FilesystemSource.class);\n\n    private static final String UNIX_PATH_SEPARATOR = \"/\";\n    private static final String WINDOWS_PATH_SEPARATOR = \"\\\\\";\n\n    /**\n     * Lazy-loaded by {@link #getPath}.\n     */\n    private Path path;\n\n    @Override\n    public void checkAccess() throws IOException {\n        final Path path = getPath();\n        if (!Files.exists(path)) {\n            throw new NoSuchFileException(\"Failed to resolve \" +\n                    identifier + \" to \" + path);\n        } else if (!Files.isReadable(path)) {\n            throw new AccessDeniedException(\"File is not readable: \" + path);\n        }\n    }\n\n    /**\n     * @return Path corresponding to the given identifier according to the\n     *         current lookup strategy\n     *         ({@link Key#FILESYSTEMSOURCE_LOOKUP_STRATEGY}). The result is\n     *         cached.\n     */\n    @Override\n    public Path getPath() throws IOException {\n        if (path == null) {\n            final LookupStrategy strategy =\n                    LookupStrategy.from(Key.FILESYSTEMSOURCE_LOOKUP_STRATEGY);\n            switch (strategy) {\n                case DELEGATE_SCRIPT:\n                    try {\n                        path = getPathWithScriptStrategy();\n                    } catch (ScriptException e) {\n                        LOGGER.error(e.getMessage(), e);\n                        throw new IOException(e);\n                    }\n                    break;\n                default:\n                    path = getPathWithBasicStrategy();\n                    break;\n            }\n            LOGGER.debug(\"Resolved {} to {}\", identifier, path);\n        }\n        return path;\n    }\n\n    private Path getPathWithBasicStrategy() {\n        final Configuration config = Configuration.getInstance();\n        final String prefix =\n                config.getString(Key.FILESYSTEMSOURCE_PATH_PREFIX, \"\");\n        final String suffix =\n                config.getString(Key.FILESYSTEMSOURCE_PATH_SUFFIX, \"\");\n        final Identifier sanitizedId = sanitizedIdentifier();\n        return Paths.get(prefix + sanitizedId.toString() + suffix);\n    }\n\n    /**\n     * @return Pathname of the file corresponding to the identifier passed to\n     *         {@link #setIdentifier(Identifier)}.\n     * @throws NoSuchFileException if the delegate method indicated that there\n     *                             is no file corresponding to the given\n     *                             identifier.\n     * @throws ScriptException     if the method invocation failed.\n     */\n    private Path getPathWithScriptStrategy() throws NoSuchFileException,\n            ScriptException {\n        String pathname = getDelegateProxy().getFilesystemSourcePathname();\n\n        if (pathname == null) {\n            throw new NoSuchFileException(\n                    DelegateMethod.FILESYSTEMSOURCE_PATHMAME +\n                    \" returned nil for \" + identifier);\n        }\n        return Paths.get(pathname);\n    }\n\n    /**\n     * <ol>\n     *     <li>If the file's filename contains an extension, the format is\n     *     inferred from that.</li>\n     *     <li>If unsuccessful, and the identifier contains an extension, the\n     *     format is inferred from that.</li>\n     *     <li>If unsuccessful, the format is inferred from the file's magic\n     *     bytes.</li>\n     * </ol>\n     *\n     * @return Best attempt at determining the file format.\n     * @throws IOException if the magic byte check fails.\n     */\n    @Override\n    public Format getFormat() throws IOException {\n        if (format == null) {\n            // Try to infer a format from the filename.\n            format = Format.inferFormat(getPath().getFileName().toString());\n\n            if (Format.UNKNOWN.equals(format)) {\n                // Try to infer a format from the identifier.\n                format = Format.inferFormat(identifier);\n            }\n\n            if (Format.UNKNOWN.equals(format)) {\n                // Fall back to reading the magic bytes.\n                format = detectFormat();\n            }\n        }\n        return format;\n    }\n\n    /**\n     * Detects the format of a file by reading its header.\n     *\n     * @return Detected format, or {@link Format#UNKNOWN}.\n     */\n    private Format detectFormat() throws IOException {\n        Format format = Format.UNKNOWN;\n        final Path path = getPath();\n        List<MediaType> detectedTypes = MediaType.detectMediaTypes(path);\n        if (!detectedTypes.isEmpty()) {\n            format = detectedTypes.get(0).toFormat();\n        }\n        return format;\n    }\n\n    @Override\n    public StreamFactory newStreamFactory() throws IOException {\n        return new PathStreamFactory(getPath());\n    }\n\n    /**\n     * Recursively filters out {@literal fileseparator..} and\n     * {@literal ..fileseparator} to prevent moving up a directory tree.\n     *\n     * @return Sanitized identifier.\n     */\n    private Identifier sanitizedIdentifier() {\n        final String sanitized = StringUtils.sanitize(\n                identifier.toString(),\n                UNIX_PATH_SEPARATOR + \"..\",\n                \"..\" + UNIX_PATH_SEPARATOR,\n                WINDOWS_PATH_SEPARATOR + \"..\",\n                \"..\" + WINDOWS_PATH_SEPARATOR);\n        return new Identifier(sanitized);\n    }\n\n    @Override\n    public void setIdentifier(Identifier identifier) {\n        path = null;\n        format = null;\n        this.identifier = identifier;\n    }\n\n}", "class_id": 0, "repo": "BossaNova/cantaloupe", "file": "src/main/java/edu/illinois/library/cantaloupe/source/FilesystemSource.java", "last_update_at": "2021-01-21T21:23:09+00:00", "question_id": "dd665ca0160a69141e541d7df9ca35966420c029", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class FilesystemSource extends AbstractSource\n        implements StreamSource, FileSource {\n    private static final Logger LOGGER =\n            LoggerFactory.getLogger(FilesystemSource.class);\n    private static final String UNIX_PATH_SEPARATOR = \"/\";\n    private static final String WINDOWS_PATH_SEPARATOR = \"\\\\\";\n    /**\n     * Lazy-loaded by {@link #getPath}.\n     */\n    private Path path;\n    @Override\n    public void checkAccess() throws IOException {\n        final Path path = getPath();\n        if (!Files.exists(path)) {\n            throw new NoSuchFileException(\"Failed to resolve \" +\n                    identifier + \" to \" + path);\n        } else if (!Files.isReadable(path)) {\n            throw new AccessDeniedException(\"File is not readable: \" + path);\n        }\n    }\n    /**\n     * @return Path corresponding to the given identifier according to the\n     *         current lookup strategy\n     *         ({@link Key#FILESYSTEMSOURCE_LOOKUP_STRATEGY}). The result is\n     *         cached.\n     */\n    @Override\n    public Path getPath() throws IOException {\n        if (path == null) {\n            final LookupStrategy strategy =\n                    LookupStrategy.from(Key.FILESYSTEMSOURCE_LOOKUP_STRATEGY);\n            switch (strategy) {\n                case DELEGATE_SCRIPT:\n                    try {\n                        path = getPathWithScriptStrategy();\n                    } catch (ScriptException e) {\n                        LOGGER.error(e.getMessage(), e);\n                        throw new IOException(e);\n                    }\n                    break;\n                default:\n                    path = getPathWithBasicStrategy();\n                    break;\n            }\n            LOGGER.debug(\"Resolved {} to {}\", identifier, path);\n        }\n        return path;\n    }\n    private Path getPathWithBasicStrategy() {\n        final Configuration config = Configuration.getInstance();\n        final String prefix =\n                config.getString(Key.FILESYSTEMSOURCE_PATH_PREFIX, \"\");\n        final String suffix =\n                config.getString(Key.FILESYSTEMSOURCE_PATH_SUFFIX, \"\");\n        final Identifier sanitizedId = sanitizedIdentifier();\n        return Paths.get(prefix + sanitizedId.toString() + suffix);\n    }\n    /**\n     * @return Pathname of the file corresponding to the identifier passed to\n     *         {@link #setIdentifier(Identifier)}.\n     * @throws NoSuchFileException if the delegate method indicated that there\n     *                             is no file corresponding to the given\n     *                             identifier.\n     * @throws ScriptException     if the method invocation failed.\n     */\n    private Path getPathWithScriptStrategy() throws NoSuchFileException,\n            ScriptException {\n        String pathname = getDelegateProxy().getFilesystemSourcePathname();\n        if (pathname == null) {\n            throw new NoSuchFileException(\n                    DelegateMethod.FILESYSTEMSOURCE_PATHMAME +\n                    \" returned nil for \" + identifier);\n        }\n        return Paths.get(pathname);\n    }\n    /**\n     * <ol>\n     *     <li>If the file's filename contains an extension, the format is\n     *     inferred from that.</li>\n     *     <li>If unsuccessful, and the identifier contains an extension, the\n     *     format is inferred from that.</li>\n     *     <li>If unsuccessful, the format is inferred from the file's magic\n     *     bytes.</li>\n     * </ol>\n     *\n     * @return Best attempt at determining the file format.\n     * @throws IOException if the magic byte check fails.\n     */\n    @Override\n    public Format getFormat() throws IOException {\n        if (format == null) {\n            // Try to infer a format from the filename.\n            format = Format.inferFormat(getPath().getFileName().toString());\n            if (Format.UNKNOWN.equals(format)) {\n                // Try to infer a format from the identifier.\n                format = Format.inferFormat(identifier);\n            }\n            if (Format.UNKNOWN.equals(format)) {\n                // Fall back to reading the magic bytes.\n                format = detectFormat();\n            }\n        }\n        return format;\n    }\n    /**\n     * Detects the format of a file by reading its header.\n     *\n     * @return Detected format, or {@link Format#UNKNOWN}.\n     */\n    private Format detectFormat() throws IOException {\n        Format format = Format.UNKNOWN;\n        final Path path = getPath();\n        List<MediaType> detectedTypes = MediaType.detectMediaTypes(path);\n        if (!detectedTypes.isEmpty()) {\n            format = detectedTypes.get(0).toFormat();\n        }\n        return format;\n    }\n    @Override\n    public StreamFactory newStreamFactory() throws IOException {\n        return new PathStreamFactory(getPath());\n    }\n    /**\n     * Recursively filters out {@literal fileseparator..} and\n     * {@literal ..fileseparator} to prevent moving up a directory tree.\n     *\n     * @return Sanitized identifier.\n     */\n    private Identifier sanitizedIdentifier() {\n        final String sanitized = StringUtils.sanitize(\n                identifier.toString(),\n                UNIX_PATH_SEPARATOR + \"..\",\n                \"..\" + UNIX_PATH_SEPARATOR,\n                WINDOWS_PATH_SEPARATOR + \"..\",\n                \"..\" + WINDOWS_PATH_SEPARATOR);\n        return new Identifier(sanitized);\n    }\n    @Override\n    public void setIdentifier(Identifier identifier) {\n        path = null;\n        format = null;\n        this.identifier = identifier;\n    }\n"]]}
{"hexsha": "bec0e15270d0c37da3353799049257d5d218b2d9", "ext": "java", "lang": "Java", "content": "@Service\npublic class TableServiceImpl implements TableService {\n\t@Autowired\n\tprivate ClusterService clusterService;\n\t\n\t@Override\n\tpublic List<Table> listTableByClusterName(String clusterName, boolean isContainMetrics) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(),\n\t\t\t\tcluster.getZookeeperAddress(), cluster.getZnodeParent());\n\t\tList<Table> tableList = hbaseFacade.listTables();\n\t\tString hdfsRootpath = cluster.getHdfsRootPath();\n\t\tHDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n\t\tString tableDataPath = hdfsRootpath + \"/data/\";\n\t\t// \u5305\u542b\u7edf\u8ba1\u4fe1\u606f\n\t\tif(isContainMetrics) {\n\t\t\tfor (Table table : tableList) {\n\t\t\t\ttable.setSpaceSize(\n\t\t\t\t\t\thdfsFacade.getPathSpaceSize(tableDataPath + table.getNamespace() + \"/\" + table.getTableName()));\n\t\t\t}\n\t\t}\n\t\treturn tableList;\n\t}\n\n\t@Override\n\tpublic List<String> listTableNameByClusterName(String clusterName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(),\n\t\t\t\tcluster.getZookeeperAddress(), cluster.getZnodeParent());\n\t\treturn hbaseFacade.listTableNames();\n\t}\n\n\t@Override\n\tpublic Table getTableByName(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\tTable table = hbaseFacade.getTableByName(tableName);\n\t\treturn table;\n\t}\n\n\t@Override\n\tpublic int save(String clusterName, String ddlStr) {\n\t\tTable table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n\t\tif (null != table) {\n\t\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\t\tcluster.getZnodeParent());\n\t\t\thbaseFacade.createTable(table);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int update(String clusterName, String ddlStr) {\n\t\tTable table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n\t\tif (null != table) {\n\t\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\t\tcluster.getZnodeParent());\n\t\t\thbaseFacade.alterTable(table);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic void enableTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.ENABLE);\n\t}\n\n\t@Override\n\tpublic void disableTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.DISABLE);\n\t}\n\n\t@Override\n\tpublic void deleteTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.DELETE);\n\t}\n\n\t@Override\n\tpublic void compactTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.COMPACT);\n\t}\n\n\t@Override\n\tpublic Long getTableSpaceSize(String clusterName, String namespace, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tString hdfsRootpath = cluster.getHdfsRootPath();\n\t\tHDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n\t\tString tableDataPath = new StringBuilder(hdfsRootpath).append(\"/data/\").append(namespace).append(\"/\").append(tableName).toString();\n\t\tlong spaceSize = hdfsFacade.getPathSpaceSize(tableDataPath);\n\t\treturn spaceSize;\n\t}\n\n}", "class_id": 0, "repo": "MeetYouDevs/hbase-manager", "file": "src/main/java/com/meiyou/hbase/manager/service/impl/TableServiceImpl.java", "last_update_at": "2021-08-17T16:13:14+00:00", "question_id": "bec0e15270d0c37da3353799049257d5d218b2d9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class TableServiceImpl implements TableService {\n\t@Autowired\n\tprivate ClusterService clusterService;\n\t\n\t@Override\n\tpublic List<Table> listTableByClusterName(String clusterName, boolean isContainMetrics) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(),\n\t\t\t\tcluster.getZookeeperAddress(), cluster.getZnodeParent());\n\t\tList<Table> tableList = hbaseFacade.listTables();\n\t\tString hdfsRootpath = cluster.getHdfsRootPath();\n\t\tHDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n\t\tString tableDataPath = hdfsRootpath + \"/data/\";\n\t\t// \u5305\u542b\u7edf\u8ba1\u4fe1\u606f\n\t\tif(isContainMetrics) {\n\t\t\tfor (Table table : tableList) {\n\t\t\t\ttable.setSpaceSize(\n\t\t\t\t\t\thdfsFacade.getPathSpaceSize(tableDataPath + table.getNamespace() + \"/\" + table.getTableName()));\n\t\t\t}\n\t\t}\n\t\treturn tableList;\n\t}\n\t@Override\n\tpublic List<String> listTableNameByClusterName(String clusterName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(),\n\t\t\t\tcluster.getZookeeperAddress(), cluster.getZnodeParent());\n\t\treturn hbaseFacade.listTableNames();\n\t}\n\t@Override\n\tpublic Table getTableByName(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\tTable table = hbaseFacade.getTableByName(tableName);\n\t\treturn table;\n\t}\n\t@Override\n\tpublic int save(String clusterName, String ddlStr) {\n\t\tTable table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n\t\tif (null != table) {\n\t\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\t\tcluster.getZnodeParent());\n\t\t\thbaseFacade.createTable(table);\n\t\t}\n\t\treturn 0;\n\t}\n\t@Override\n\tpublic int update(String clusterName, String ddlStr) {\n\t\tTable table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n\t\tif (null != table) {\n\t\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\t\tcluster.getZnodeParent());\n\t\t\thbaseFacade.alterTable(table);\n\t\t}\n\t\treturn 0;\n\t}\n\t@Override\n\tpublic void enableTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.ENABLE);\n\t}\n\t@Override\n\tpublic void disableTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.DISABLE);\n\t}\n\t@Override\n\tpublic void deleteTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.DELETE);\n\t}\n\t@Override\n\tpublic void compactTable(String clusterName, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tHBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(),\n\t\t\t\tcluster.getZnodeParent());\n\t\thbaseFacade.operateTable(tableName, HTableOpEnum.COMPACT);\n\t}\n\t@Override\n\tpublic Long getTableSpaceSize(String clusterName, String namespace, String tableName) {\n\t\tCluster cluster = clusterService.getClusterByName(clusterName);\n\t\tString hdfsRootpath = cluster.getHdfsRootPath();\n\t\tHDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n\t\tString tableDataPath = new StringBuilder(hdfsRootpath).append(\"/data/\").append(namespace).append(\"/\").append(tableName).toString();\n\t\tlong spaceSize = hdfsFacade.getPathSpaceSize(tableDataPath);\n\t\treturn spaceSize;\n\t}\n"]]}
{"hexsha": "2242cfb0f4039ef1dd1986bcfd3655b2f3ae6feb", "ext": "java", "lang": "Java", "content": "public class MD\n{\n\t/**\n\t * \n\t * @param obj the object to create the check sum\n\t * @return the numeric checksum for an object\n\t */\n\tpublic static BigInteger checksum(Object obj) \n\t{\n\t    if (obj == null) {\n\t      return BigInteger.ZERO;   \n\t    }\n\t    \n\t    Class<?> clz = obj.getClass();\n\t    \n\t    if(!(Serializable.class.isAssignableFrom(clz)))\n \t    {\n\t\t    String tostring = obj.toString();\n\t\t    \n\t\t    if(tostring.contains(clz.getName()) && tostring.contains(\"@\"))\n\t\t    {\n\t\t \t      \t//use hash code\n\t\t \t    \treturn BigInteger.valueOf(obj.hashCode());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t    \t//try to use toString\n\t\t    \tobj = tostring;\n\t\t    }\n\t\t }\n\n\t    try(\n\t    \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t    \t\tObjectOutputStream oos = new ObjectOutputStream(baos);)\n\t    {\n\t\t    oos.writeObject(obj);\n\n\t\t    MessageDigest m = MessageDigest.getInstance(\"MD5\");\n\t\t    m.update(baos.toByteArray());\n\n\t\t    return new BigInteger(1, m.digest());\t    \t\n\t    }\n\t    catch(IOException e)\n\t    {\n\t    \tthrow new RuntimeException(\"Unable to write to object output stream ERROR:\"+e.getMessage(),e);\n\t    }\n\t    catch(NoSuchAlgorithmException e)\n\t    {\n\t    \tthrow new RuntimeException(\"Unable to get message digest MD5 ERROR:\"+e.getMessage());\n\t    }\n\t    \n\t}\n\t\n\n}", "class_id": 0, "repo": "vaquarkhan/nyla", "file": "src/main/java/nyla/solutions/core/security/MD.java", "last_update_at": "2021-09-20T13:20:21+00:00", "question_id": "2242cfb0f4039ef1dd1986bcfd3655b2f3ae6feb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MD\n{\n\t/**\n\t * \n\t * @param obj the object to create the check sum\n\t * @return the numeric checksum for an object\n\t */\n\tpublic static BigInteger checksum(Object obj) \n\t{\n\t    if (obj == null) {\n\t      return BigInteger.ZERO;   \n\t    }\n\t    \n\t    Class<?> clz = obj.getClass();\n\t    \n\t    if(!(Serializable.class.isAssignableFrom(clz)))\n \t    {\n\t\t    String tostring = obj.toString();\n\t\t    \n\t\t    if(tostring.contains(clz.getName()) && tostring.contains(\"@\"))\n\t\t    {\n\t\t \t      \t//use hash code\n\t\t \t    \treturn BigInteger.valueOf(obj.hashCode());\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t    \t//try to use toString\n\t\t    \tobj = tostring;\n\t\t    }\n\t\t }\n\t    try(\n\t    \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t    \t\tObjectOutputStream oos = new ObjectOutputStream(baos);)\n\t    {\n\t\t    oos.writeObject(obj);\n\t\t    MessageDigest m = MessageDigest.getInstance(\"MD5\");\n\t\t    m.update(baos.toByteArray());\n\t\t    return new BigInteger(1, m.digest());\t    \t\n\t    }\n\t    catch(IOException e)\n\t    {\n\t    \tthrow new RuntimeException(\"Unable to write to object output stream ERROR:\"+e.getMessage(),e);\n\t    }\n\t    catch(NoSuchAlgorithmException e)\n\t    {\n\t    \tthrow new RuntimeException(\"Unable to get message digest MD5 ERROR:\"+e.getMessage());\n\t    }\n\t    \n\t}\n\t\n"]]}
{"hexsha": "0a1e9bd38adebe2351975cd89a116d8cc06a6a3a", "ext": "java", "lang": "Java", "content": "public class BlockRail extends BlockRailBase\n{\n    public static final PropertyEnum<BlockRailBase.EnumRailDirection> SHAPE = PropertyEnum.<BlockRailBase.EnumRailDirection>create(\"shape\", BlockRailBase.EnumRailDirection.class);\n\n    protected BlockRail()\n    {\n        super(false);\n        this.setDefaultState(this.blockState.getBaseState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH));\n    }\n\n    protected void updateState(IBlockState state, World worldIn, BlockPos pos, Block blockIn)\n    {\n        if (blockIn.getDefaultState().canProvidePower() && (new BlockRailBase.Rail(worldIn, pos, state)).countAdjacentRails() == 3)\n        {\n            this.updateDir(worldIn, pos, state, false);\n        }\n    }\n\n    public IProperty<BlockRailBase.EnumRailDirection> getShapeProperty()\n    {\n        return SHAPE;\n    }\n\n    /**\n     * Convert the given metadata into a BlockState for this Block\n     */\n    public IBlockState getStateFromMeta(int meta)\n    {\n        return this.getDefaultState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.byMetadata(meta));\n    }\n\n    /**\n     * Convert the BlockState into the correct metadata value\n     */\n    public int getMetaFromState(IBlockState state)\n    {\n        return ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE)).getMetadata();\n    }\n\n    /**\n     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withRotation(Rotation)} whenever possible. Implementing/overriding is\n     * fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withRotation(IBlockState state, Rotation rot)\n    {\n        switch (rot)\n        {\n            case CLOCKWISE_180:\n\n                switch ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE))\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                }\n\n            case COUNTERCLOCKWISE_90:\n\n                switch ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE))\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n\n            case CLOCKWISE_90:\n\n                switch ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE))\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n\n            default:\n                return state;\n        }\n    }\n\n    /**\n     * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withMirror(Mirror)} whenever possible. Implementing/overriding is fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withMirror(IBlockState state, Mirror mirrorIn)\n    {\n        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = (BlockRailBase.EnumRailDirection)state.getValue(SHAPE);\n\n        switch (mirrorIn)\n        {\n            case LEFT_RIGHT:\n\n                switch (blockrailbase$enumraildirection)\n                {\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    default:\n                        return super.withMirror(state, mirrorIn);\n                }\n\n            case FRONT_BACK:\n\n                switch (blockrailbase$enumraildirection)\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                    case ASCENDING_SOUTH:\n                    default:\n                        break;\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                }\n        }\n\n        return super.withMirror(state, mirrorIn);\n    }\n\n    protected BlockStateContainer createBlockState()\n    {\n        return new BlockStateContainer(this, new IProperty[] {SHAPE});\n    }\n}", "class_id": 0, "repo": "KubecraftServer/addon", "file": "build/tmp/recompileMc/sources/net/minecraft/block/BlockRail.java", "last_update_at": "2021-12-19T18:11:35+00:00", "question_id": "0a1e9bd38adebe2351975cd89a116d8cc06a6a3a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlockRail extends BlockRailBase\n{\n    public static final PropertyEnum<BlockRailBase.EnumRailDirection> SHAPE = PropertyEnum.<BlockRailBase.EnumRailDirection>create(\"shape\", BlockRailBase.EnumRailDirection.class);\n    protected BlockRail()\n    {\n        super(false);\n        this.setDefaultState(this.blockState.getBaseState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH));\n    }\n    protected void updateState(IBlockState state, World worldIn, BlockPos pos, Block blockIn)\n    {\n        if (blockIn.getDefaultState().canProvidePower() && (new BlockRailBase.Rail(worldIn, pos, state)).countAdjacentRails() == 3)\n        {\n            this.updateDir(worldIn, pos, state, false);\n        }\n    }\n    public IProperty<BlockRailBase.EnumRailDirection> getShapeProperty()\n    {\n        return SHAPE;\n    }\n    /**\n     * Convert the given metadata into a BlockState for this Block\n     */\n    public IBlockState getStateFromMeta(int meta)\n    {\n        return this.getDefaultState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.byMetadata(meta));\n    }\n    /**\n     * Convert the BlockState into the correct metadata value\n     */\n    public int getMetaFromState(IBlockState state)\n    {\n        return ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE)).getMetadata();\n    }\n    /**\n     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withRotation(Rotation)} whenever possible. Implementing/overriding is\n     * fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withRotation(IBlockState state, Rotation rot)\n    {\n        switch (rot)\n        {\n            case CLOCKWISE_180:\n                switch ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE))\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                }\n            case COUNTERCLOCKWISE_90:\n                switch ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE))\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n            case CLOCKWISE_90:\n                switch ((BlockRailBase.EnumRailDirection)state.getValue(SHAPE))\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n            default:\n                return state;\n        }\n    }\n    /**\n     * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withMirror(Mirror)} whenever possible. Implementing/overriding is fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withMirror(IBlockState state, Mirror mirrorIn)\n    {\n        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = (BlockRailBase.EnumRailDirection)state.getValue(SHAPE);\n        switch (mirrorIn)\n        {\n            case LEFT_RIGHT:\n                switch (blockrailbase$enumraildirection)\n                {\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    default:\n                        return super.withMirror(state, mirrorIn);\n                }\n            case FRONT_BACK:\n                switch (blockrailbase$enumraildirection)\n                {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                    case ASCENDING_SOUTH:\n                    default:\n                        break;\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                }\n        }\n        return super.withMirror(state, mirrorIn);\n    }\n    protected BlockStateContainer createBlockState()\n    {\n        return new BlockStateContainer(this, new IProperty[] {SHAPE});\n    }\n"]]}
{"hexsha": "0a90942c9de76f337b39b5c7475c993ad265d6d6", "ext": "java", "lang": "Java", "content": "public class QueryRunner {\n\tprivate  Tokenizer tokenizer;\n\tprivate  Parser parser;\n\tprivate  Interpreter interpreter;\n\n\tpublic QueryRunner() {\n\t\ttokenizer = new SimpleTokenizer();\n\t\tparser = new Parser();\n\t\tinterpreter = new Interpreter();\n\t}\n\t\n\tpublic QueryRunner(Tokenizer tokenizer, Parser parser, Interpreter interpreter) {\n\t\tthis.tokenizer = tokenizer;\n\t\tthis.parser = parser;\n\t\tthis.interpreter = interpreter;\n\t}\n\n\tpublic Boolean runQuery(String query, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n\t\tList<Token> tokens = tokenizer.tokenize(query);\n\t\tAbstractSyntaxTree ast = parser.generateAst(tokens);\n\n\t\treturn interpreter.interpretAst(ast, valueMap);\n\t}\n\t\n\tpublic Boolean runQuery(AbstractSyntaxTree ast, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n\t\treturn interpreter.interpretAst(ast, valueMap);\n\t}\n\n\tpublic AbstractSyntaxTree generateAst(String query) {\n\t\tList<Token> tokens = tokenizer.tokenize(query);\n\t\treturn parser.generateAst(tokens);\n\t}\n\n}", "class_id": 0, "repo": "stargarth-enterprise/BooleanQueryParser", "file": "src/main/java/stargarth/interpreter/QueryRunner.java", "last_update_at": "2021-09-16T09:37:41+00:00", "question_id": "0a90942c9de76f337b39b5c7475c993ad265d6d6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class QueryRunner {\n\tprivate  Tokenizer tokenizer;\n\tprivate  Parser parser;\n\tprivate  Interpreter interpreter;\n\tpublic QueryRunner() {\n\t\ttokenizer = new SimpleTokenizer();\n\t\tparser = new Parser();\n\t\tinterpreter = new Interpreter();\n\t}\n\t\n\tpublic QueryRunner(Tokenizer tokenizer, Parser parser, Interpreter interpreter) {\n\t\tthis.tokenizer = tokenizer;\n\t\tthis.parser = parser;\n\t\tthis.interpreter = interpreter;\n\t}\n\tpublic Boolean runQuery(String query, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n\t\tList<Token> tokens = tokenizer.tokenize(query);\n\t\tAbstractSyntaxTree ast = parser.generateAst(tokens);\n\t\treturn interpreter.interpretAst(ast, valueMap);\n\t}\n\t\n\tpublic Boolean runQuery(AbstractSyntaxTree ast, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n\t\treturn interpreter.interpretAst(ast, valueMap);\n\t}\n\tpublic AbstractSyntaxTree generateAst(String query) {\n\t\tList<Token> tokens = tokenizer.tokenize(query);\n\t\treturn parser.generateAst(tokens);\n\t}\n"]]}
{"hexsha": "e2f527d42211782844bffcb67f211f4aac0df984", "ext": "java", "lang": "Java", "content": "public class SignupIntegrationTest extends ApiGatewayHandlerIntegrationTest {\n\n    @BeforeEach\n    void setup() {\n        handler = new SignUpHandler(TEST_CONFIGURATION_SERVICE);\n    }\n\n    @Test\n    void shouldReturn200WhenValidSignUpRequest() throws IOException {\n        String sessionId = redis.createSession();\n\n        redis.setSessionState(sessionId, EMAIL_CODE_VERIFIED);\n\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Session-Id\", sessionId);\n        headers.put(\"X-API-Key\", FRONTEND_API_KEY);\n\n        var response =\n                makeRequest(\n                        Optional.of(\n                                new SignupRequest(\n                                        \"joe.bloggs+5@digital.cabinet-office.gov.uk\",\n                                        \"password-1\")),\n                        headers,\n                        Map.of());\n\n        assertThat(response, hasStatus(200));\n\n        BaseAPIResponse BaseAPIResponse =\n                objectMapper.readValue(response.getBody(), BaseAPIResponse.class);\n        assertThat(BaseAPIResponse.getSessionState(), equalTo(TWO_FACTOR_REQUIRED));\n        assertTrue(userStore.userExists(\"joe.bloggs+5@digital.cabinet-office.gov.uk\"));\n    }\n}", "class_id": 0, "repo": "alphagov/di-authentication-api", "file": "integration-tests/src/test/java/uk/gov/di/authentication/api/SignupIntegrationTest.java", "last_update_at": "2021-11-15T12:55:55+00:00", "question_id": "e2f527d42211782844bffcb67f211f4aac0df984", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SignupIntegrationTest extends ApiGatewayHandlerIntegrationTest {\n    @BeforeEach\n    void setup() {\n        handler = new SignUpHandler(TEST_CONFIGURATION_SERVICE);\n    }\n    @Test\n    void shouldReturn200WhenValidSignUpRequest() throws IOException {\n        String sessionId = redis.createSession();\n        redis.setSessionState(sessionId, EMAIL_CODE_VERIFIED);\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Session-Id\", sessionId);\n        headers.put(\"X-API-Key\", FRONTEND_API_KEY);\n        var response =\n                makeRequest(\n                        Optional.of(\n                                new SignupRequest(\n                                        \"joe.bloggs+5@digital.cabinet-office.gov.uk\",\n                                        \"password-1\")),\n                        headers,\n                        Map.of());\n        assertThat(response, hasStatus(200));\n        BaseAPIResponse BaseAPIResponse =\n                objectMapper.readValue(response.getBody(), BaseAPIResponse.class);\n        assertThat(BaseAPIResponse.getSessionState(), equalTo(TWO_FACTOR_REQUIRED));\n        assertTrue(userStore.userExists(\"joe.bloggs+5@digital.cabinet-office.gov.uk\"));\n    }\n"]]}
{"hexsha": "d55baea88f5220601a1f7762d2dc42a9e59e67e8", "ext": "java", "lang": "Java", "content": "public class SendMessageTransaction {\n\n    private IconService iconService;\n    private Wallet wallet;\n\n    private SendMessageTransaction() {\n        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();\n        logging.setLevel(HttpLoggingInterceptor.Level.BODY);\n        OkHttpClient httpClient = new OkHttpClient.Builder()\n                .addInterceptor(logging)\n                .build();\n        iconService = new IconService(new HttpProvider(httpClient, Constants.SERVER_URL, 3));\n        wallet = KeyWallet.load(Constants.privateKey);\n    }\n\n    private void sendTransaction() throws IOException {\n        BigInteger networkId = BigInteger.valueOf(3);\n        Address fromAddress = wallet.getAddress();\n        Address toAddress = Constants.testAddress1;\n        BigInteger nonce = BigInteger.valueOf(1);\n        String message = \"Hello World\";\n\n        // make a raw transaction without the stepLimit\n        Transaction transaction = TransactionBuilder.newBuilder()\n                .nid(networkId)\n                .from(fromAddress)\n                .to(toAddress)\n                .nonce(nonce)\n                .message(message)\n                .build();\n\n        // get an estimated step value\n        BigInteger estimatedStep = iconService.estimateStep(transaction).execute();\n\n        // make a signed transaction with the same raw transaction and the estimated step\n        SignedTransaction signedTransaction = new SignedTransaction(transaction, wallet, estimatedStep);\n        Bytes hash = iconService.sendTransaction(signedTransaction).execute();\n        System.out.println(\"txHash: \" + hash);\n        TransactionResult result = Utils.getTransactionResult(iconService, hash);\n        System.out.println(\"status: \" + result.getStatus());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new SendMessageTransaction().sendTransaction();\n    }\n}", "class_id": 0, "repo": "ICONationDevTeam/icon-sdk-java", "file": "samples/src/main/java/foundation/icon/icx/SendMessageTransaction.java", "last_update_at": "2021-09-17T20:34:21+00:00", "question_id": "d55baea88f5220601a1f7762d2dc42a9e59e67e8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SendMessageTransaction {\n    private IconService iconService;\n    private Wallet wallet;\n    private SendMessageTransaction() {\n        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();\n        logging.setLevel(HttpLoggingInterceptor.Level.BODY);\n        OkHttpClient httpClient = new OkHttpClient.Builder()\n                .addInterceptor(logging)\n                .build();\n        iconService = new IconService(new HttpProvider(httpClient, Constants.SERVER_URL, 3));\n        wallet = KeyWallet.load(Constants.privateKey);\n    }\n    private void sendTransaction() throws IOException {\n        BigInteger networkId = BigInteger.valueOf(3);\n        Address fromAddress = wallet.getAddress();\n        Address toAddress = Constants.testAddress1;\n        BigInteger nonce = BigInteger.valueOf(1);\n        String message = \"Hello World\";\n        // make a raw transaction without the stepLimit\n        Transaction transaction = TransactionBuilder.newBuilder()\n                .nid(networkId)\n                .from(fromAddress)\n                .to(toAddress)\n                .nonce(nonce)\n                .message(message)\n                .build();\n        // get an estimated step value\n        BigInteger estimatedStep = iconService.estimateStep(transaction).execute();\n        // make a signed transaction with the same raw transaction and the estimated step\n        SignedTransaction signedTransaction = new SignedTransaction(transaction, wallet, estimatedStep);\n        Bytes hash = iconService.sendTransaction(signedTransaction).execute();\n        System.out.println(\"txHash: \" + hash);\n        TransactionResult result = Utils.getTransactionResult(iconService, hash);\n        System.out.println(\"status: \" + result.getStatus());\n    }\n    public static void main(String[] args) throws IOException {\n        new SendMessageTransaction().sendTransaction();\n    }\n"]]}
{"hexsha": "45059a9352250ed2493baa512f6df38fe9ceaa67", "ext": "java", "lang": "Java", "content": "public class IO {\n    private final PrintStream out;\n    private final Scanner scanner;\n    private final String consolePrefix;\n\n    enum MessageType {INFO, WARNING, ERROR}\n    public IO(PrintStream out, InputStream in, String consolePrefix) {\n        this.out = out;\n        this.scanner = new Scanner(in);\n        this.consolePrefix = consolePrefix;\n    }\n\n    public IO(PrintStream out, InputStream in) {\n        this(out, in, \">>> \");\n    }\n    public IO() {\n        this(System.out, System.in);\n    }\n    public void printString(String string) {\n        out.print(string);\n    }\n    private void printConsolePrefix() {\n        printString(consolePrefix);\n    }\n    public void printMessage(MessageType type, String message) {\n        printLine(String.format(\"%s: %s\", type.name(), message));\n    }\n    public void printError(String errorMessage) {\n        printMessage(MessageType.ERROR, errorMessage);\n    }\n    public void printConditionError(Object value, String condition) {\n        printError(String.format(\"The value (%s) is mismatching next condition: %s\", value.toString(), condition));\n    }\n    public void printLine(String string) {\n        printString(String.format(\"%s\\n\", string));\n    }\n    public String readString() {\n        printConsolePrefix();\n        return scanner.next();\n    }\n    public String readString(Predicate<String> predicate, String predicateCondition) {\n        String string;\n\n        while (true) {\n            string = readString();\n            if (predicate.test(string)) {\n                break;\n            } else {\n                printConditionError(string, predicateCondition);\n            }\n        }\n\n        return string;\n    }\n    public int readInt() throws InputMismatchException {\n        printConsolePrefix();\n        return scanner.nextInt();\n    }\n    public int readInt(String errorMessage) {\n        Integer number = null;\n\n        while (number == null) {\n            try {\n                number = readInt();\n            } catch (InputMismatchException e) {\n                readString();\n                printError(errorMessage);\n            }\n        }\n\n        return number;\n    }\n\n    public int readInt(String errorMessage, Predicate<Integer> predicate, String predicateCondition) {\n        int number;\n\n        while (true) {\n            number = readInt(errorMessage);\n            if (predicate.test(number)) {\n                break;\n            } else {\n                printConditionError(number, predicateCondition);\n            }\n        }\n\n        return number;\n    }\n}", "class_id": 0, "repo": "leonidpodriz/Flights-booking", "file": "src/main/java/Console/IO.java", "last_update_at": "2021-03-28T13:28:02+00:00", "question_id": "45059a9352250ed2493baa512f6df38fe9ceaa67", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IO {\n    private final PrintStream out;\n    private final Scanner scanner;\n    private final String consolePrefix;\n    enum MessageType {INFO, WARNING, ERROR}\n    public IO(PrintStream out, InputStream in, String consolePrefix) {\n        this.out = out;\n        this.scanner = new Scanner(in);\n        this.consolePrefix = consolePrefix;\n    }\n    public IO(PrintStream out, InputStream in) {\n        this(out, in, \">>> \");\n    }\n    public IO() {\n        this(System.out, System.in);\n    }\n    public void printString(String string) {\n        out.print(string);\n    }\n    private void printConsolePrefix() {\n        printString(consolePrefix);\n    }\n    public void printMessage(MessageType type, String message) {\n        printLine(String.format(\"%s: %s\", type.name(), message));\n    }\n    public void printError(String errorMessage) {\n        printMessage(MessageType.ERROR, errorMessage);\n    }\n    public void printConditionError(Object value, String condition) {\n        printError(String.format(\"The value (%s) is mismatching next condition: %s\", value.toString(), condition));\n    }\n    public void printLine(String string) {\n        printString(String.format(\"%s\\n\", string));\n    }\n    public String readString() {\n        printConsolePrefix();\n        return scanner.next();\n    }\n    public String readString(Predicate<String> predicate, String predicateCondition) {\n        String string;\n        while (true) {\n            string = readString();\n            if (predicate.test(string)) {\n                break;\n            } else {\n                printConditionError(string, predicateCondition);\n            }\n        }\n        return string;\n    }\n    public int readInt() throws InputMismatchException {\n        printConsolePrefix();\n        return scanner.nextInt();\n    }\n    public int readInt(String errorMessage) {\n        Integer number = null;\n        while (number == null) {\n            try {\n                number = readInt();\n            } catch (InputMismatchException e) {\n                readString();\n                printError(errorMessage);\n            }\n        }\n        return number;\n    }\n    public int readInt(String errorMessage, Predicate<Integer> predicate, String predicateCondition) {\n        int number;\n        while (true) {\n            number = readInt(errorMessage);\n            if (predicate.test(number)) {\n                break;\n            } else {\n                printConditionError(number, predicateCondition);\n            }\n        }\n        return number;\n    }\n"]]}
{"hexsha": "4dae9c1547b458a35477b0baee243af818ee49fc", "ext": "java", "lang": "Java", "content": "public class Pair<T, U> {\n\n    /** The first value. */\n    public final T first;\n\n    /** The second value. */\n    public final U second;\n\n    /**\n     * Create a new pair.\n     *\n     * @param first The first value.\n     * @param second The second value.\n     */\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n\n        if (other == null || getClass() != other.getClass()) {\n            return false;\n        }\n\n        Pair<?, ?> pair = (Pair<?, ?>) other;\n        return Objects.equals(first, pair.first) &&\n                Objects.equals(second, pair.second);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        return Objects.hash(first, second);\n    }\n\n}", "class_id": 0, "repo": "chrsan/css-selectors", "file": "src/main/java/se/fishtank/css/selectors/util/Pair.java", "last_update_at": "2021-11-30T08:26:04+00:00", "question_id": "4dae9c1547b458a35477b0baee243af818ee49fc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Pair<T, U> {\n    /** The first value. */\n    public final T first;\n    /** The second value. */\n    public final U second;\n    /**\n     * Create a new pair.\n     *\n     * @param first The first value.\n     * @param second The second value.\n     */\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null || getClass() != other.getClass()) {\n            return false;\n        }\n        Pair<?, ?> pair = (Pair<?, ?>) other;\n        return Objects.equals(first, pair.first) &&\n                Objects.equals(second, pair.second);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        return Objects.hash(first, second);\n    }\n"]]}
{"hexsha": "56fb1f9c5d91901b20d488ac07ac5c45430043f7", "ext": "java", "lang": "Java", "content": "public class U3_L6_Activity_One{\n  public static void main(String[] args){\n\n    Scanner scan = new Scanner(System.in);\n    System.out.println(\"Enter a number in the twenties\");\n    int num = scan.nextInt();\n\n    if(!((num >= 20) && (num < 30))){\n      System.out.println(\"That's not in the twenties!\");\n      num = 25;\n    }\n    System.out.println(\"Your number is \" + num);\n\n  }\n}", "class_id": 0, "repo": "courtneybooker/apcsa2020", "file": "unit3/lesson6/U3L6Q1.java", "last_update_at": "2021-04-26T19:40:09+00:00", "question_id": "56fb1f9c5d91901b20d488ac07ac5c45430043f7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class U3_L6_Activity_One{\n  public static void main(String[] args){\n    Scanner scan = new Scanner(System.in);\n    System.out.println(\"Enter a number in the twenties\");\n    int num = scan.nextInt();\n    if(!((num >= 20) && (num < 30))){\n      System.out.println(\"That's not in the twenties!\");\n      num = 25;\n    }\n    System.out.println(\"Your number is \" + num);\n  }\n"]]}
{"hexsha": "6830f69e5781fcb99df09fa5dae7e7634139394b", "ext": "java", "lang": "Java", "content": "public class OffscreenView implements IView, IWindow {\n\tprivate static final Log log = Log.create();\n\t\n\tprivate boolean           enabled = true;\n\tprivate final Config      config;\n\tprivate final IController controller;\n\tprivate final Viewport    viewport;\n\tprivate FrameBuffer       frameBuffer;\n\tprivate String            title;\n\tprivate IGPUImage         colorTexture;\n\tprivate Texture           depthTexture;\n\tprivate IContext          context;\n\n\tpublic OffscreenView(IController controller, int w, int h, Config config) {\n\t\tthis.config     = config;\n\t\tthis.controller = controller;\n\t\tthis.viewport   = new Viewport(0, 0, w, h);\n\t\tsetSize(new Vec2(w, h));\n\t\trunOnSceneThread(t -> controller.viewCreated(this));\n\t}\n\t\n\tprivate void runOnSceneThread(IAction action) {\n\t\tif (controller.isSceneThread())\n\t\t\taction.run(controller.getScheduler().getTime());\n\t\telse\n\t\t\tcontroller.run(action);\n\t}\n\t\n\t@Override\n\tpublic void dispose() {\n\t\tframeBuffer = null;\n\t}\n\n\t@Override\n\tpublic boolean isEnabled() {\n\t\treturn enabled;\n\t}\n\n\t@Override\n\tpublic void setEnabled(boolean enabled) {\n\t\tthis.enabled = enabled;\n\t}\n\n\t@Override\n\tpublic Config getConfig() {\n\t\treturn config;\n\t}\n\n\t@Override\n\tpublic IController getController() {\n\t\treturn controller;\n\t}\n\n\t@Override\n\tpublic Viewport getViewport() {\n\t\treturn viewport;\n\t}\n\n\t@Override\n\tpublic IWindow getWindow() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean isDisposed() {\n\t\treturn frameBuffer == null;\n\t}\n\n\tclass Context implements IContext {\n\t\tprivate final IContext  ctx;\n\n\t\tpublic Context() {\n\t\t\tctx = GLContextManager.acquireContext();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void close() throws Exception {\n\t\t\tGL11.glFinish();\n\t\t\tFrameBuffer.unbind();\n\t\t\ttry {\n\t\t\t\tctx.close();\n\t\t\t} catch (Throwable t) {log.severe(t);}\n\t\t\tcontext = null;\n\t\t}\t\t\n\t}\n\t\n\t@Override\n\tpublic IContext acquireContext() {\n\t\tcontext = new Context();\n\t\t\n\t\tif (frameBuffer == null || viewport.w != colorTexture.getWidth() || viewport.h != colorTexture.getHeight()) {\n\t\t\tif (frameBuffer == null)\n\t\t\t\tframeBuffer = new FrameBuffer();\n\t\t\t\n\t\t\tframeBuffer.bind();\n\t\t\t\n\t\t\tint width = (int)viewport.w;\n\t\t\tint height = (int)viewport.h;\n\t\t\t\n\t\t\tcolorTexture = IGPUImage.create(width, height, ComponentType.BYTE, ComponentFormat.RGBA);\n\t\t\tframeBuffer.attach(GL30.GL_COLOR_ATTACHMENT0, colorTexture);\n\t\t\tdepthTexture = new Texture(new GLObject(Type.TEXTURE), width, height);\n\t\t\tGL11.glBindTexture(GL11.GL_TEXTURE_2D, (int)depthTexture.getGPUHandle());\n\t\t\tGL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_DEPTH_COMPONENT, width, height, 0, GL11.GL_DEPTH_COMPONENT, GL11.GL_UNSIGNED_INT, (ByteBuffer)null);\n\t\t\tGL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);\n\t\t\tGL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);\n\t\t\tframeBuffer.attach(GL30.GL_DEPTH_ATTACHMENT, depthTexture);\n\t\t\t\n\t\t\tGL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);\n\t\t\t\n\t\t\tGL20.glDrawBuffers(GL30.GL_COLOR_ATTACHMENT0);\n\n\t\t\tif(!frameBuffer.isComplete())\n\t\t\t\tlog.severe(\"Status: \" + FrameBuffer.toString(frameBuffer.getStatus()));\n\t\t} else\n\t\t\tframeBuffer.bind();\n\t\t\n\t\treturn context;\n\t}\n\n\t@Override\n\tpublic void releaseContext() {\n\t\ttry {\n\t\t\tcontext.close();\n\t\t} catch (Throwable t) {log.severe(t);}\n\t\tcontext = null;\n\t}\n\n\t@Override\n\tpublic void swapBuffers() {\n\t}\n\n\t@Override\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\n\t@Override\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\n\t@Override\n\tpublic boolean isVisible() {\n\t\treturn !(isDisposed());\n\t}\n\n\t@Override\n\tpublic void setVisible(boolean visible) {\n\t}\n\n\t@Override\n\tpublic Vec2 getPosition() {\n\t\treturn Vec2.ZERO;\n\t}\n\n\t@Override\n\tpublic void setPosition(Vec2 position) {}\n\n\t@Override\n\tpublic Vec2 getSize() {\n\t\treturn new Vec2(colorTexture.getWidth(), colorTexture.getHeight());\n\t}\n\n\t@Override\n\tpublic void setSize(Vec2 size) {\n\t\tcolorTexture = IGPUImage.create((int)size.x, (int)size.y, ComponentType.BYTE, ComponentFormat.RGBA);\n\t}\n\n\t@Override\n\tpublic Vec2 getFramebufferSize() {\n\t\treturn getSize();\n\t}\n\n\tpublic IHostImage getImage() {\n\t\treturn colorTexture.createHostImage();\n\t}\n\n\t@Override public void setFullscreen(IMonitor monitor) {}\n\t@Override public void setPointerMode(PointerMode mode) {}\n\t@Override public void setPointerPosition(float x, float y) {}\n\t@Override public void setWindowListener(IWindowListener windowListener) {}\n\t@Override public void setKeyListener(IKeyListener keyListener) {}\n\t@Override public void setPointerListener(IPointerListener pointerListener) {}\n\n\t@Override\n\tpublic void setPointerIcon(File file, int hotX, int hotY) {}\n}", "class_id": 0, "repo": "bhzunami/TronGame", "file": "ether-core/src/main/java/ch/fhnw/ether/view/OffscreenView.java", "last_update_at": "2021-08-04T07:17:00+00:00", "question_id": "6830f69e5781fcb99df09fa5dae7e7634139394b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OffscreenView implements IView, IWindow {\n\tprivate static final Log log = Log.create();\n\t\n\tprivate boolean           enabled = true;\n\tprivate final Config      config;\n\tprivate final IController controller;\n\tprivate final Viewport    viewport;\n\tprivate FrameBuffer       frameBuffer;\n\tprivate String            title;\n\tprivate IGPUImage         colorTexture;\n\tprivate Texture           depthTexture;\n\tprivate IContext          context;\n\tpublic OffscreenView(IController controller, int w, int h, Config config) {\n\t\tthis.config     = config;\n\t\tthis.controller = controller;\n\t\tthis.viewport   = new Viewport(0, 0, w, h);\n\t\tsetSize(new Vec2(w, h));\n\t\trunOnSceneThread(t -> controller.viewCreated(this));\n\t}\n\t\n\tprivate void runOnSceneThread(IAction action) {\n\t\tif (controller.isSceneThread())\n\t\t\taction.run(controller.getScheduler().getTime());\n\t\telse\n\t\t\tcontroller.run(action);\n\t}\n\t\n\t@Override\n\tpublic void dispose() {\n\t\tframeBuffer = null;\n\t}\n\t@Override\n\tpublic boolean isEnabled() {\n\t\treturn enabled;\n\t}\n\t@Override\n\tpublic void setEnabled(boolean enabled) {\n\t\tthis.enabled = enabled;\n\t}\n\t@Override\n\tpublic Config getConfig() {\n\t\treturn config;\n\t}\n\t@Override\n\tpublic IController getController() {\n\t\treturn controller;\n\t}\n\t@Override\n\tpublic Viewport getViewport() {\n\t\treturn viewport;\n\t}\n\t@Override\n\tpublic IWindow getWindow() {\n\t\treturn this;\n\t}\n\t@Override\n\tpublic boolean isDisposed() {\n\t\treturn frameBuffer == null;\n\t}\n\tclass Context implements IContext {\n\t\tprivate final IContext  ctx;\n\t\tpublic Context() {\n\t\t\tctx = GLContextManager.acquireContext();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void close() throws Exception {\n\t\t\tGL11.glFinish();\n\t\t\tFrameBuffer.unbind();\n\t\t\ttry {\n\t\t\t\tctx.close();\n\t\t\t} catch (Throwable t) {log.severe(t);}\n\t\t\tcontext = null;\n\t\t}\t\t\n\t}\n\t\n\t@Override\n\tpublic IContext acquireContext() {\n\t\tcontext = new Context();\n\t\t\n\t\tif (frameBuffer == null || viewport.w != colorTexture.getWidth() || viewport.h != colorTexture.getHeight()) {\n\t\t\tif (frameBuffer == null)\n\t\t\t\tframeBuffer = new FrameBuffer();\n\t\t\t\n\t\t\tframeBuffer.bind();\n\t\t\t\n\t\t\tint width = (int)viewport.w;\n\t\t\tint height = (int)viewport.h;\n\t\t\t\n\t\t\tcolorTexture = IGPUImage.create(width, height, ComponentType.BYTE, ComponentFormat.RGBA);\n\t\t\tframeBuffer.attach(GL30.GL_COLOR_ATTACHMENT0, colorTexture);\n\t\t\tdepthTexture = new Texture(new GLObject(Type.TEXTURE), width, height);\n\t\t\tGL11.glBindTexture(GL11.GL_TEXTURE_2D, (int)depthTexture.getGPUHandle());\n\t\t\tGL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_DEPTH_COMPONENT, width, height, 0, GL11.GL_DEPTH_COMPONENT, GL11.GL_UNSIGNED_INT, (ByteBuffer)null);\n\t\t\tGL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);\n\t\t\tGL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);\n\t\t\tframeBuffer.attach(GL30.GL_DEPTH_ATTACHMENT, depthTexture);\n\t\t\t\n\t\t\tGL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);\n\t\t\t\n\t\t\tGL20.glDrawBuffers(GL30.GL_COLOR_ATTACHMENT0);\n\t\t\tif(!frameBuffer.isComplete())\n\t\t\t\tlog.severe(\"Status: \" + FrameBuffer.toString(frameBuffer.getStatus()));\n\t\t} else\n\t\t\tframeBuffer.bind();\n\t\t\n\t\treturn context;\n\t}\n\t@Override\n\tpublic void releaseContext() {\n\t\ttry {\n\t\t\tcontext.close();\n\t\t} catch (Throwable t) {log.severe(t);}\n\t\tcontext = null;\n\t}\n\t@Override\n\tpublic void swapBuffers() {\n\t}\n\t@Override\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\t@Override\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\t@Override\n\tpublic boolean isVisible() {\n\t\treturn !(isDisposed());\n\t}\n\t@Override\n\tpublic void setVisible(boolean visible) {\n\t}\n\t@Override\n\tpublic Vec2 getPosition() {\n\t\treturn Vec2.ZERO;\n\t}\n\t@Override\n\tpublic void setPosition(Vec2 position) {}\n\t@Override\n\tpublic Vec2 getSize() {\n\t\treturn new Vec2(colorTexture.getWidth(), colorTexture.getHeight());\n\t}\n\t@Override\n\tpublic void setSize(Vec2 size) {\n\t\tcolorTexture = IGPUImage.create((int)size.x, (int)size.y, ComponentType.BYTE, ComponentFormat.RGBA);\n\t}\n\t@Override\n\tpublic Vec2 getFramebufferSize() {\n\t\treturn getSize();\n\t}\n\tpublic IHostImage getImage() {\n\t\treturn colorTexture.createHostImage();\n\t}\n\t@Override public void setFullscreen(IMonitor monitor) {}\n\t@Override public void setPointerMode(PointerMode mode) {}\n\t@Override public void setPointerPosition(float x, float y) {}\n\t@Override public void setWindowListener(IWindowListener windowListener) {}\n\t@Override public void setKeyListener(IKeyListener keyListener) {}\n\t@Override public void setPointerListener(IPointerListener pointerListener) {}\n\t@Override\n\tpublic void setPointerIcon(File file, int hotX, int hotY) {}\n"]]}
{"hexsha": "d01caa778c358af05e7c9ced3072245899fa3392", "ext": "java", "lang": "Java", "content": "@Mojo( defaultPhase = LifecyclePhase.VALIDATE, name = \"check-format\", threadSafe = true )\npublic class CheckFormatMojo\n    extends AbstractXmlMojo\n{\n\n    private class ViolationCollector\n        implements XmlFormatViolationHandler\n    {\n        private final Map<String, List<XmlFormatViolation>> violations =\n            new LinkedHashMap<String, List<XmlFormatViolation>>();\n\n        @Override\n        public void handle( XmlFormatViolation violation )\n        {\n            List<XmlFormatViolation> list = violations.get( violation.getFile().getAbsolutePath() );\n            if ( list == null )\n            {\n                list = new ArrayList<XmlFormatViolation>();\n                violations.put( violation.getFile().getAbsolutePath(), list );\n            }\n            list.add( violation );\n            if ( failOnFormatViolation )\n            {\n                getLog().error( violation.toString() );\n            }\n            else\n            {\n                getLog().warn( violation.toString() );\n            }\n        }\n\n        public boolean hasViolations()\n        {\n            return !violations.isEmpty();\n        }\n\n        public boolean hasViolations( File file )\n        {\n            List<XmlFormatViolation> list = violations.get( file.getAbsolutePath() );\n            return list != null && !list.isEmpty();\n        }\n\n    }\n\n    /**\n     * The encoding of files included in {@link #formatFileSets}. Note that the\n     * {@code encoding can be set also per FormatFileSet}.\n     */\n    @Parameter( property = \"xml.encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n\n    /**\n     * Tells the mojo what to do in case XML formatting violations are found. if {@code true}, all violations will be\n     * reported on the console as ERRORs and the build will fail. if {@code false}, all violations will be reported on\n     * the console as WARNs and the build will proceed further.\n     */\n    @Parameter( property = \"xml.failOnFormatViolation\", defaultValue = \"true\" )\n    private boolean failOnFormatViolation;\n\n    /**\n     * File patterns to include. The patterns are relative to the current project's {@code baseDir}.\n     */\n    @Parameter\n    private List<FormatFileSet> formatFileSets = new ArrayList<FormatFileSet>();\n\n    /**\n     * The number of spaces expected for indentation. Note that {@code indentSize} can be configuread also per\n     * {@link FormatFileSet}.\n     */\n    @Parameter( property = \"xml.indentSize\", defaultValue = \"2\" )\n    private int indentSize;\n\n    /** A {@link SAXParserFactory} */\n    private SAXParserFactory saxParserFactory;\n\n    /**\n     * If set to {@code true}, the result of {@link FormatFileSet#getDefault(String, int)} will be appended to\n     * {@link #formatFileSets} before the processing.\n     */\n    @Parameter( property = \"xml.useDefaultFormatFileSet\", defaultValue = \"true\" )\n    private boolean useDefaultFormatFileSet;\n\n    /**\n     * Creates a new {@link CheckFormatMojo} instance.\n     */\n    public CheckFormatMojo()\n    {\n        super();\n        this.saxParserFactory = SAXParserFactory.newInstance();\n        this.saxParserFactory.setValidating( false );\n    }\n\n    /**\n     * Checks the formatting of the given {@code file}. The file is read using the given {@code encoding} and the\n     * violations are reported to the given {@code violationHandler}.\n     *\n     * @param file the file to check\n     * @param encoding the encoding to use for reading the {@code file}\n     * @param violationHandler the {@link XmlFormatViolationHandler} to report violations\n     * @throws MojoExecutionException if there is any lover level exception reading or parsing the file.\n     */\n    private void check( File file, String encoding, XmlFormatViolationHandler violationHandler )\n        throws MojoExecutionException\n    {\n\n        Reader in = null;\n        try\n        {\n            in = new InputStreamReader( new FileInputStream( file ), encoding );\n            SAXParser saxParser = saxParserFactory.newSAXParser();\n            IndentCheckSaxHandler handler = new IndentCheckSaxHandler( file, indentSize, violationHandler );\n            saxParser.parse( new InputSource( in ), handler );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Could not process file \" + file.getAbsolutePath(), e );\n        }\n        finally\n        {\n            if ( in != null )\n            {\n                try\n                {\n                    in.close();\n                }\n                catch ( IOException e )\n                {\n                    getLog().error( \"Could not close Reader for \" + file.getAbsolutePath(), e );\n                }\n            }\n        }\n    }\n\n    /**\n     * Called by Maven for executing the Mojo.\n     *\n     * @throws MojoExecutionException Running the Mojo failed.\n     * @throws MojoFailureException A configuration error was detected.\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( isSkipping() )\n        {\n            getLog().debug( \"Skipping execution, as demanded by user.\" );\n            return;\n        }\n\n        if ( useDefaultFormatFileSet )\n        {\n            formatFileSets.add( FormatFileSet.getDefault( getBasedir(), encoding, indentSize ) );\n        }\n        if ( formatFileSets == null || formatFileSets.isEmpty() )\n        {\n            /* nothing to do */\n            return;\n        }\n\n        ViolationCollector violationCollector = new ViolationCollector();\n\n        int processedFileCount = 0;\n\n        for ( FormatFileSet formatFileSet : formatFileSets )\n        {\n            String effectiveEncoding = formatFileSet.getEncoding();\n            if ( effectiveEncoding == null )\n            {\n                effectiveEncoding = this.encoding;\n            }\n            String[] includedFiles = scan( formatFileSet );\n            for ( String includedPath : includedFiles )\n            {\n                processedFileCount++;\n                File file = new File( formatFileSet.getDirectory(), includedPath );\n                check( file, effectiveEncoding, violationCollector );\n                if ( getLog().isDebugEnabled() && !violationCollector.hasViolations( file ) )\n                {\n                    getLog().debug( \"No XML formatting violations found in file \" + file.getAbsolutePath() );\n                }\n            }\n        }\n        getLog().debug( \"Checked the formatting of \" + processedFileCount + \" files\" );\n\n        if ( failOnFormatViolation && violationCollector.hasViolations() )\n        {\n            throw new MojoFailureException( \"There are XML formatting violations. Check the above log for details.\" );\n        }\n\n    }\n\n    /**\n     * A {@link DirectoryScanner} boiler plate.\n     *\n     * @param fileSet {@link FileSet} to scan\n     * @return the included paths\n     */\n    private String[] scan( FileSet fileSet )\n    {\n        File basedir = new File( fileSet.getDirectory() );\n        if ( !basedir.exists() || !basedir.isDirectory() )\n        {\n            return null;\n        }\n\n        DirectoryScanner scanner = new DirectoryScanner();\n\n        List<String> includes = fileSet.getIncludes();\n        List<String> excludes = fileSet.getExcludes();\n\n        if ( includes != null && includes.size() > 0 )\n        {\n            scanner.setIncludes( includes.toArray( new String[0] ) );\n        }\n\n        if ( excludes != null && excludes.size() > 0 )\n        {\n            scanner.setExcludes( excludes.toArray( new String[0] ) );\n        }\n\n        scanner.setBasedir( basedir );\n\n        scanner.scan();\n        return scanner.getIncludedFiles();\n    }\n\n    /**\n     * Sets the number of spaces for indentation.\n     *\n     * @param indentSize the number of spaces\n     */\n    public void setIndentSize( int indentSize )\n    {\n        this.indentSize = indentSize;\n    }\n\n}", "class_id": 0, "repo": "srinivas32/xml-maven-plugin", "file": "src/main/java/org/codehaus/mojo/xml/CheckFormatMojo.java", "last_update_at": "2021-09-11T04:38:42+00:00", "question_id": "d01caa778c358af05e7c9ced3072245899fa3392", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Mojo( defaultPhase = LifecyclePhase.VALIDATE, name = \"check-format\", threadSafe = true )\npublic class CheckFormatMojo\n    extends AbstractXmlMojo\n{\n    private class ViolationCollector\n        implements XmlFormatViolationHandler\n    {\n        private final Map<String, List<XmlFormatViolation>> violations =\n            new LinkedHashMap<String, List<XmlFormatViolation>>();\n        @Override\n        public void handle( XmlFormatViolation violation )\n        {\n            List<XmlFormatViolation> list = violations.get( violation.getFile().getAbsolutePath() );\n            if ( list == null )\n            {\n                list = new ArrayList<XmlFormatViolation>();\n                violations.put( violation.getFile().getAbsolutePath(), list );\n            }\n            list.add( violation );\n            if ( failOnFormatViolation )\n            {\n                getLog().error( violation.toString() );\n            }\n            else\n            {\n                getLog().warn( violation.toString() );\n            }\n        }\n        public boolean hasViolations()\n        {\n            return !violations.isEmpty();\n        }\n        public boolean hasViolations( File file )\n        {\n            List<XmlFormatViolation> list = violations.get( file.getAbsolutePath() );\n            return list != null && !list.isEmpty();\n        }\n    }\n    /**\n     * The encoding of files included in {@link #formatFileSets}. Note that the\n     * {@code encoding can be set also per FormatFileSet}.\n     */\n    @Parameter( property = \"xml.encoding\", defaultValue = \"${project.build.sourceEncoding}\" )\n    private String encoding;\n    /**\n     * Tells the mojo what to do in case XML formatting violations are found. if {@code true}, all violations will be\n     * reported on the console as ERRORs and the build will fail. if {@code false}, all violations will be reported on\n     * the console as WARNs and the build will proceed further.\n     */\n    @Parameter( property = \"xml.failOnFormatViolation\", defaultValue = \"true\" )\n    private boolean failOnFormatViolation;\n    /**\n     * File patterns to include. The patterns are relative to the current project's {@code baseDir}.\n     */\n    @Parameter\n    private List<FormatFileSet> formatFileSets = new ArrayList<FormatFileSet>();\n    /**\n     * The number of spaces expected for indentation. Note that {@code indentSize} can be configuread also per\n     * {@link FormatFileSet}.\n     */\n    @Parameter( property = \"xml.indentSize\", defaultValue = \"2\" )\n    private int indentSize;\n    /** A {@link SAXParserFactory} */\n    private SAXParserFactory saxParserFactory;\n    /**\n     * If set to {@code true}, the result of {@link FormatFileSet#getDefault(String, int)} will be appended to\n     * {@link #formatFileSets} before the processing.\n     */\n    @Parameter( property = \"xml.useDefaultFormatFileSet\", defaultValue = \"true\" )\n    private boolean useDefaultFormatFileSet;\n    /**\n     * Creates a new {@link CheckFormatMojo} instance.\n     */\n    public CheckFormatMojo()\n    {\n        super();\n        this.saxParserFactory = SAXParserFactory.newInstance();\n        this.saxParserFactory.setValidating( false );\n    }\n    /**\n     * Checks the formatting of the given {@code file}. The file is read using the given {@code encoding} and the\n     * violations are reported to the given {@code violationHandler}.\n     *\n     * @param file the file to check\n     * @param encoding the encoding to use for reading the {@code file}\n     * @param violationHandler the {@link XmlFormatViolationHandler} to report violations\n     * @throws MojoExecutionException if there is any lover level exception reading or parsing the file.\n     */\n    private void check( File file, String encoding, XmlFormatViolationHandler violationHandler )\n        throws MojoExecutionException\n    {\n        Reader in = null;\n        try\n        {\n            in = new InputStreamReader( new FileInputStream( file ), encoding );\n            SAXParser saxParser = saxParserFactory.newSAXParser();\n            IndentCheckSaxHandler handler = new IndentCheckSaxHandler( file, indentSize, violationHandler );\n            saxParser.parse( new InputSource( in ), handler );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Could not process file \" + file.getAbsolutePath(), e );\n        }\n        finally\n        {\n            if ( in != null )\n            {\n                try\n                {\n                    in.close();\n                }\n                catch ( IOException e )\n                {\n                    getLog().error( \"Could not close Reader for \" + file.getAbsolutePath(), e );\n                }\n            }\n        }\n    }\n    /**\n     * Called by Maven for executing the Mojo.\n     *\n     * @throws MojoExecutionException Running the Mojo failed.\n     * @throws MojoFailureException A configuration error was detected.\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( isSkipping() )\n        {\n            getLog().debug( \"Skipping execution, as demanded by user.\" );\n            return;\n        }\n        if ( useDefaultFormatFileSet )\n        {\n            formatFileSets.add( FormatFileSet.getDefault( getBasedir(), encoding, indentSize ) );\n        }\n        if ( formatFileSets == null || formatFileSets.isEmpty() )\n        {\n            /* nothing to do */\n            return;\n        }\n        ViolationCollector violationCollector = new ViolationCollector();\n        int processedFileCount = 0;\n        for ( FormatFileSet formatFileSet : formatFileSets )\n        {\n            String effectiveEncoding = formatFileSet.getEncoding();\n            if ( effectiveEncoding == null )\n            {\n                effectiveEncoding = this.encoding;\n            }\n            String[] includedFiles = scan( formatFileSet );\n            for ( String includedPath : includedFiles )\n            {\n                processedFileCount++;\n                File file = new File( formatFileSet.getDirectory(), includedPath );\n                check( file, effectiveEncoding, violationCollector );\n                if ( getLog().isDebugEnabled() && !violationCollector.hasViolations( file ) )\n                {\n                    getLog().debug( \"No XML formatting violations found in file \" + file.getAbsolutePath() );\n                }\n            }\n        }\n        getLog().debug( \"Checked the formatting of \" + processedFileCount + \" files\" );\n        if ( failOnFormatViolation && violationCollector.hasViolations() )\n        {\n            throw new MojoFailureException( \"There are XML formatting violations. Check the above log for details.\" );\n        }\n    }\n    /**\n     * A {@link DirectoryScanner} boiler plate.\n     *\n     * @param fileSet {@link FileSet} to scan\n     * @return the included paths\n     */\n    private String[] scan( FileSet fileSet )\n    {\n        File basedir = new File( fileSet.getDirectory() );\n        if ( !basedir.exists() || !basedir.isDirectory() )\n        {\n            return null;\n        }\n        DirectoryScanner scanner = new DirectoryScanner();\n        List<String> includes = fileSet.getIncludes();\n        List<String> excludes = fileSet.getExcludes();\n        if ( includes != null && includes.size() > 0 )\n        {\n            scanner.setIncludes( includes.toArray( new String[0] ) );\n        }\n        if ( excludes != null && excludes.size() > 0 )\n        {\n            scanner.setExcludes( excludes.toArray( new String[0] ) );\n        }\n        scanner.setBasedir( basedir );\n        scanner.scan();\n        return scanner.getIncludedFiles();\n    }\n    /**\n     * Sets the number of spaces for indentation.\n     *\n     * @param indentSize the number of spaces\n     */\n    public void setIndentSize( int indentSize )\n    {\n        this.indentSize = indentSize;\n    }\n"]]}
{"hexsha": "29468b6a959b45f1ec1410e8277b26109e673596", "ext": "java", "lang": "Java", "content": "public final class SHA1Util {\n\n\tprivate static final ThreadLocal<MessageDigest> SHA1 = ThreadLocal.withInitial(() -> {\n\t\ttry {\n\t\t\treturn MessageDigest.getInstance(\"SHA1\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new InternalError(\"SHA-1 not supported on this platform - Outdated?\");\n\t\t}\n\t});\n\n\n\t/**\n\t * Performs a SHA-1 hash on the specified data\n\t *\n\t * @param data The data to hash\n\t * @return The hashed data\n\t */\n\tprivate static byte[] sha1(byte[] data) {\n\t\tMessageDigest digest = SHA1.get();\n\t\tdigest.reset();\n\t\treturn digest.digest(data);\n\t}\n\n\tpublic static String sha1(File file) throws IOException {\n\t\treturn SecretUtil.byteArrayToHexString(Files.readAllBytes(file.toPath()));\n\t}\n\n\tpublic static String sha1(String source) {\n\t\treturn sha1(source, StandardCharsets.UTF_8);\n\t}\n\n\tpublic static String sha1(String source, Charset charset) {\n\t\tbyte[] bytes = source.getBytes(charset);\n\t\treturn SecretUtil.byteArrayToHexString(sha1(bytes));\n\t}\n}", "class_id": 0, "repo": "qiunet/DuoDuo", "file": "QiunetUtils/src/main/java/org/qiunet/utils/secret/SHA1Util.java", "last_update_at": "2021-11-19T01:51:27+00:00", "question_id": "29468b6a959b45f1ec1410e8277b26109e673596", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SHA1Util {\n\tprivate static final ThreadLocal<MessageDigest> SHA1 = ThreadLocal.withInitial(() -> {\n\t\ttry {\n\t\t\treturn MessageDigest.getInstance(\"SHA1\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new InternalError(\"SHA-1 not supported on this platform - Outdated?\");\n\t\t}\n\t});\n\t/**\n\t * Performs a SHA-1 hash on the specified data\n\t *\n\t * @param data The data to hash\n\t * @return The hashed data\n\t */\n\tprivate static byte[] sha1(byte[] data) {\n\t\tMessageDigest digest = SHA1.get();\n\t\tdigest.reset();\n\t\treturn digest.digest(data);\n\t}\n\tpublic static String sha1(File file) throws IOException {\n\t\treturn SecretUtil.byteArrayToHexString(Files.readAllBytes(file.toPath()));\n\t}\n\tpublic static String sha1(String source) {\n\t\treturn sha1(source, StandardCharsets.UTF_8);\n\t}\n\tpublic static String sha1(String source, Charset charset) {\n\t\tbyte[] bytes = source.getBytes(charset);\n\t\treturn SecretUtil.byteArrayToHexString(sha1(bytes));\n\t}\n"]]}
{"hexsha": "21bf6ff3974912f326f07e60b655d83815cf8d49", "ext": "java", "lang": "Java", "content": "public class CertificateBuilderTest {\n\n    @Test\n    public void SelfSignCertificateBuilder(){\n        KeyPair keyPair = new KeyPairBuilder()\n                .setAlgorithm(\"RSA\")\n                .setLength(2048)\n                .setProvider(\"bc\")\n                .setSecureRandom(new SecureRandom())\n                .build();\n        PKCS10CertificationRequest pkcs10CertificationRequest = new CertificateRequestBuilder()\n                .setSubject(\"C=CN,L=nanjing,O=koal,OU=develop,CN=robert\")\n                .setPublicKey(keyPair.getPublic())\n                .setPrivateKey(keyPair.getPrivate())\n                .setProvider(\"BC\")\n                .build();\n        try {\n            X509Certificate signCertificate = Converter.file2Cert(new FileInputStream(\"/Users/robert/client.crt\"));\n            X509Certificate x509Certificate = new CertificateBuilder()\n                    .setSignCertificate(signCertificate)\n                    .setCA(true)\n                    .setPathLen(10)\n                    .setRequest(pkcs10CertificationRequest)\n                    .setSerialNumber(new BigInteger(\"1\"))\n                    .setSignKey(keyPair.getPrivate())\n                    .build();\n            Converter.cert2File(x509Certificate,new FileOutputStream(\"/Users/robert/test.crt\"));\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n\n    }\n}", "class_id": 0, "repo": "mr-tan4/openca", "file": "commonlang/src/test/java/com/common/cert/CertificateBuilderTest.java", "last_update_at": "2021-01-19T02:00:49+00:00", "question_id": "21bf6ff3974912f326f07e60b655d83815cf8d49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CertificateBuilderTest {\n    @Test\n    public void SelfSignCertificateBuilder(){\n        KeyPair keyPair = new KeyPairBuilder()\n                .setAlgorithm(\"RSA\")\n                .setLength(2048)\n                .setProvider(\"bc\")\n                .setSecureRandom(new SecureRandom())\n                .build();\n        PKCS10CertificationRequest pkcs10CertificationRequest = new CertificateRequestBuilder()\n                .setSubject(\"C=CN,L=nanjing,O=koal,OU=develop,CN=robert\")\n                .setPublicKey(keyPair.getPublic())\n                .setPrivateKey(keyPair.getPrivate())\n                .setProvider(\"BC\")\n                .build();\n        try {\n            X509Certificate signCertificate = Converter.file2Cert(new FileInputStream(\"/Users/robert/client.crt\"));\n            X509Certificate x509Certificate = new CertificateBuilder()\n                    .setSignCertificate(signCertificate)\n                    .setCA(true)\n                    .setPathLen(10)\n                    .setRequest(pkcs10CertificationRequest)\n                    .setSerialNumber(new BigInteger(\"1\"))\n                    .setSignKey(keyPair.getPrivate())\n                    .build();\n            Converter.cert2File(x509Certificate,new FileOutputStream(\"/Users/robert/test.crt\"));\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n"]]}
{"hexsha": "979d1de477d5676a88d93695c18feea4c16e195d", "ext": "java", "lang": "Java", "content": "class Coordinate {\n    private final int x;\n    private final int y;\n    private final int manhattanDistance;\n\n    Coordinate(final int x, final int y) {\n        this.x = x;\n        this.y = y;\n        this.manhattanDistance = Math.abs(x) + Math.abs(y);\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        final Coordinate that = (Coordinate) o;\n        return x == that.x &&\n               y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n\n    @Override\n    public String toString() {\n        return \"Coordinate{\" +\n               \"x=\" + x +\n               \", y=\" + y +\n               '}';\n    }\n\n    public boolean horizontallyBetween(final Coordinate start, final Coordinate end) {\n        return start.x <= x && x <= end.x\n               ||\n               end.x <= x && x <= start.x\n                ;\n    }\n\n    public boolean verticallyBetween(final Coordinate start, final Coordinate end) {\n        return start.y <= y && y <= end.y\n               ||\n               end.y <= y && y <= start.y\n                ;\n    }\n\n    public boolean horizontalWith(final Coordinate other) {\n        return y == other.y;\n    }\n\n    public boolean verticalWith(final Coordinate other) {\n        return x == other.x;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public int manhattanDistance() {\n        return manhattanDistance;\n    }\n\n    public int lengthTo(final Coordinate other) {\n        if(x == other.x) {\n            return Math.abs(y - other.y);\n        } else {\n            return Math.abs(x - other.x);\n        }\n    }\n}", "class_id": 0, "repo": "clssn/aoc-2019", "file": "day03/java/jensnerche/src/main/java/Coordinate.java", "last_update_at": "2021-04-27T05:37:08+00:00", "question_id": "979d1de477d5676a88d93695c18feea4c16e195d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Coordinate {\n    private final int x;\n    private final int y;\n    private final int manhattanDistance;\n    Coordinate(final int x, final int y) {\n        this.x = x;\n        this.y = y;\n        this.manhattanDistance = Math.abs(x) + Math.abs(y);\n    }\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        final Coordinate that = (Coordinate) o;\n        return x == that.x &&\n               y == that.y;\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n    @Override\n    public String toString() {\n        return \"Coordinate{\" +\n               \"x=\" + x +\n               \", y=\" + y +\n               '}';\n    }\n    public boolean horizontallyBetween(final Coordinate start, final Coordinate end) {\n        return start.x <= x && x <= end.x\n               ||\n               end.x <= x && x <= start.x\n                ;\n    }\n    public boolean verticallyBetween(final Coordinate start, final Coordinate end) {\n        return start.y <= y && y <= end.y\n               ||\n               end.y <= y && y <= start.y\n                ;\n    }\n    public boolean horizontalWith(final Coordinate other) {\n        return y == other.y;\n    }\n    public boolean verticalWith(final Coordinate other) {\n        return x == other.x;\n    }\n    public int getX() {\n        return x;\n    }\n    public int getY() {\n        return y;\n    }\n    public int manhattanDistance() {\n        return manhattanDistance;\n    }\n    public int lengthTo(final Coordinate other) {\n        if(x == other.x) {\n            return Math.abs(y - other.y);\n        } else {\n            return Math.abs(x - other.x);\n        }\n    }\n"]]}
{"hexsha": "9fe15468b8a7ba983a58726361f89a67189c0327", "ext": "java", "lang": "Java", "content": "public class VivecraftTransformationService implements ITransformationService\n{\n    private static final Logger LOGGER = LogManager.getLogger();\n    public static URL ZipFileUrl;\n    private static ZipFile ZipFile;\n    private static VivecraftTransformer transformer;\n\n    @Override\n    public String name()\n    {\n        return \"Vivecraft\";\n    }\n\n    @Override\n    public void initialize(IEnvironment environment)\n    {\n        LOGGER.info(\"VivecraftTransformationService.initialize\");\n    }\n\n    @Override\n    public void beginScanning(IEnvironment environment)\n    {\n    }\n\n    @Override\n    public void onLoad(IEnvironment env, Set<String> otherServices) throws IncompatibleEnvironmentException\n    {\n        LOGGER.info(\"VivecraftTransformationService.onLoad\");\n\n        try {\n            ZipFileUrl = Utils.getVivecraftZipLocation().toURL();\n            ZipFile = Utils.getVivecraftZip();\n            transformer = new VivecraftTransformer(ZipFile);\n        }\n        catch (Exception exception)\n        {\n            LOGGER.error(\"Error loading ZIP file: \" + ZipFileUrl, (Throwable)exception);\n            throw new IncompatibleEnvironmentException(\"Error loading ZIP file: \" + ZipFileUrl);\n        }\n    }\n\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalResourcesLocator()\n    {\n        return ITransformationService.super.additionalResourcesLocator();\n    }\n\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalClassesLocator()\n    {\n        Set<String> set = new HashSet<>();\n        set.add(\"org.vivecraft.\");\n        Supplier<Function<String, Optional<URL>>> supplier = () ->\n        {\n            return this::getResourceUrl;\n        };\n        Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> entry = new SimpleEntry<>(set, supplier);\n        LOGGER.info(\"additionalClassesLocator: \" + set);\n        return entry;\n    }\n\n    public Optional<URL> getResourceUrl(String name)\n    {\n        if (name.endsWith(\".class\") && !name.startsWith(\"optifine/\"))\n        {\n            name = \"srg/\" + name;\n        }\n\n        if (transformer == null)\n        {\n            return Optional.empty();\n        }\n        else\n        {\n            ZipEntry zipentry = ZipFile.getEntry(name);\n\n            if (zipentry == null)\n            {\n                return Optional.empty();\n            }\n            else\n            {\n                try\n                {\n                    String s = ZipFileUrl.toExternalForm();\n                    URL url = new URL(\"jar:\" + s + \"!/\" + name);\n                    return Optional.of(url);\n                }\n                catch (IOException ioexception)\n                {\n                    LOGGER.error(ioexception);\n                    return Optional.empty();\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<ITransformer> transformers()\n    {\n        LOGGER.info(\"VivecraftTransformationService.transformers\");\n        List<ITransformer> list = new ArrayList<>();\n\n        if (transformer != null)\n        {\n            list.add(transformer);\n        }\n\n        list.add(new VivecraftASMTransformer());\n\n//\t\ttry {\n//\t        Object transformationServicesHandler;\n//\t\t\ttransformationServicesHandler = FieldUtils.readDeclaredField(Launcher.INSTANCE, \"transformationServicesHandler\", true);\n//\t        TransformStore transformStore = (TransformStore) FieldUtils.readDeclaredField(transformationServicesHandler, \"transformStore\", true);\n//\t        EnumMap<TransformTargetLabel.LabelType, TransformList<?>> transformers = (EnumMap<TransformTargetLabel.LabelType, TransformList<?>>) FieldUtils.readDeclaredField(transformStore, \"transformers\", true);\n//        \n//\t        Map<TransformTargetLabel, List<ITransformer<?>>> classTransformers = (Map<TransformTargetLabel, List<ITransformer<?>>>) FieldUtils.readDeclaredField(transformers.get(TransformTargetLabel.LabelType.CLASS), \"transformers\", true);\n//\t        for(List<ITransformer<?>> c: classTransformers.values()) {\n//\t        \tfor(ITransformer ct:c) {\n//\t        \t\tTransformerHolder it = (TransformerHolder) ct;\n//\t        \t\tif(transformer.ofTargets == null && it.owner().name().equals((\"OptiFine\"))) \n//\t        \t\t\ttransformer.ofTargets = it.targets();\n//\t        \t\telse\n//\t        \t\t\ttransformer.undeadClassTransformers.add(ct);\n//\t        \t}\n//\t        }\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy: Reviving \" + transformer.undeadClassTransformers.size() + \" classTransformers \");\n//\n//\t        Map<TransformTargetLabel, List<ITransformer<?>>> methodTransformers = (Map<TransformTargetLabel, List<ITransformer<?>>>) FieldUtils.readDeclaredField(transformers.get(TransformTargetLabel.LabelType.METHOD), \"transformers\", true);\n//\t        for(List c: methodTransformers.values())\n//\t        \ttransformer.lostMethodTransformers.addAll(c);\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy: Finding \" + transformer.lostMethodTransformers.size() + \" methodTransformers \");\n//\n//\t        Map<TransformTargetLabel, List<ITransformer<?>>> FieldTransformers = (Map<TransformTargetLabel, List<ITransformer<?>>>) FieldUtils.readDeclaredField(transformers.get(TransformTargetLabel.LabelType.FIELD), \"transformers\", true);\n//\t        for(List c: FieldTransformers.values())\n//\t        \ttransformer.fieldTransformersOftheDamned.addAll(c);\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy: De-cursing \" + transformer.fieldTransformersOftheDamned.size() + \" fieldTransformers \");\n//\t                    \n//\t\t} catch (Exception e) {\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy Trans-necromancy has failed, sire! \" + e.getLocalizedMessage());\n//\t\t}\n\n        \n        return list;\n    }\n\n    public static VivecraftTransformer getTransformer()\n    {\n        return transformer;\n    }\n}", "class_id": 0, "repo": "ElijahZAwesome/Vivecraft_116", "file": "src/org/vivecraft/tweaker/VivecraftTransformationService.java", "last_update_at": "2021-12-11T15:44:55+00:00", "question_id": "9fe15468b8a7ba983a58726361f89a67189c0327", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VivecraftTransformationService implements ITransformationService\n{\n    private static final Logger LOGGER = LogManager.getLogger();\n    public static URL ZipFileUrl;\n    private static ZipFile ZipFile;\n    private static VivecraftTransformer transformer;\n    @Override\n    public String name()\n    {\n        return \"Vivecraft\";\n    }\n    @Override\n    public void initialize(IEnvironment environment)\n    {\n        LOGGER.info(\"VivecraftTransformationService.initialize\");\n    }\n    @Override\n    public void beginScanning(IEnvironment environment)\n    {\n    }\n    @Override\n    public void onLoad(IEnvironment env, Set<String> otherServices) throws IncompatibleEnvironmentException\n    {\n        LOGGER.info(\"VivecraftTransformationService.onLoad\");\n        try {\n            ZipFileUrl = Utils.getVivecraftZipLocation().toURL();\n            ZipFile = Utils.getVivecraftZip();\n            transformer = new VivecraftTransformer(ZipFile);\n        }\n        catch (Exception exception)\n        {\n            LOGGER.error(\"Error loading ZIP file: \" + ZipFileUrl, (Throwable)exception);\n            throw new IncompatibleEnvironmentException(\"Error loading ZIP file: \" + ZipFileUrl);\n        }\n    }\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalResourcesLocator()\n    {\n        return ITransformationService.super.additionalResourcesLocator();\n    }\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalClassesLocator()\n    {\n        Set<String> set = new HashSet<>();\n        set.add(\"org.vivecraft.\");\n        Supplier<Function<String, Optional<URL>>> supplier = () ->\n        {\n            return this::getResourceUrl;\n        };\n        Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> entry = new SimpleEntry<>(set, supplier);\n        LOGGER.info(\"additionalClassesLocator: \" + set);\n        return entry;\n    }\n    public Optional<URL> getResourceUrl(String name)\n    {\n        if (name.endsWith(\".class\") && !name.startsWith(\"optifine/\"))\n        {\n            name = \"srg/\" + name;\n        }\n        if (transformer == null)\n        {\n            return Optional.empty();\n        }\n        else\n        {\n            ZipEntry zipentry = ZipFile.getEntry(name);\n            if (zipentry == null)\n            {\n                return Optional.empty();\n            }\n            else\n            {\n                try\n                {\n                    String s = ZipFileUrl.toExternalForm();\n                    URL url = new URL(\"jar:\" + s + \"!/\" + name);\n                    return Optional.of(url);\n                }\n                catch (IOException ioexception)\n                {\n                    LOGGER.error(ioexception);\n                    return Optional.empty();\n                }\n            }\n        }\n    }\n    @Override\n    public List<ITransformer> transformers()\n    {\n        LOGGER.info(\"VivecraftTransformationService.transformers\");\n        List<ITransformer> list = new ArrayList<>();\n        if (transformer != null)\n        {\n            list.add(transformer);\n        }\n        list.add(new VivecraftASMTransformer());\n//\t\ttry {\n//\t        Object transformationServicesHandler;\n//\t\t\ttransformationServicesHandler = FieldUtils.readDeclaredField(Launcher.INSTANCE, \"transformationServicesHandler\", true);\n//\t        TransformStore transformStore = (TransformStore) FieldUtils.readDeclaredField(transformationServicesHandler, \"transformStore\", true);\n//\t        EnumMap<TransformTargetLabel.LabelType, TransformList<?>> transformers = (EnumMap<TransformTargetLabel.LabelType, TransformList<?>>) FieldUtils.readDeclaredField(transformStore, \"transformers\", true);\n//        \n//\t        Map<TransformTargetLabel, List<ITransformer<?>>> classTransformers = (Map<TransformTargetLabel, List<ITransformer<?>>>) FieldUtils.readDeclaredField(transformers.get(TransformTargetLabel.LabelType.CLASS), \"transformers\", true);\n//\t        for(List<ITransformer<?>> c: classTransformers.values()) {\n//\t        \tfor(ITransformer ct:c) {\n//\t        \t\tTransformerHolder it = (TransformerHolder) ct;\n//\t        \t\tif(transformer.ofTargets == null && it.owner().name().equals((\"OptiFine\"))) \n//\t        \t\t\ttransformer.ofTargets = it.targets();\n//\t        \t\telse\n//\t        \t\t\ttransformer.undeadClassTransformers.add(ct);\n//\t        \t}\n//\t        }\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy: Reviving \" + transformer.undeadClassTransformers.size() + \" classTransformers \");\n//\n//\t        Map<TransformTargetLabel, List<ITransformer<?>>> methodTransformers = (Map<TransformTargetLabel, List<ITransformer<?>>>) FieldUtils.readDeclaredField(transformers.get(TransformTargetLabel.LabelType.METHOD), \"transformers\", true);\n//\t        for(List c: methodTransformers.values())\n//\t        \ttransformer.lostMethodTransformers.addAll(c);\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy: Finding \" + transformer.lostMethodTransformers.size() + \" methodTransformers \");\n//\n//\t        Map<TransformTargetLabel, List<ITransformer<?>>> FieldTransformers = (Map<TransformTargetLabel, List<ITransformer<?>>>) FieldUtils.readDeclaredField(transformers.get(TransformTargetLabel.LabelType.FIELD), \"transformers\", true);\n//\t        for(List c: FieldTransformers.values())\n//\t        \ttransformer.fieldTransformersOftheDamned.addAll(c);\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy: De-cursing \" + transformer.fieldTransformersOftheDamned.size() + \" fieldTransformers \");\n//\t                    \n//\t\t} catch (Exception e) {\n//\t        LOGGER.info(\"VivecraftTransformationService.necromancy Trans-necromancy has failed, sire! \" + e.getLocalizedMessage());\n//\t\t}\n        return list;\n    }\n    public static VivecraftTransformer getTransformer()\n    {\n        return transformer;\n    }\n"]]}
{"hexsha": "3bc37aa206b127ec430864edd59b331b4f994f0e", "ext": "java", "lang": "Java", "content": "public class NobleIntegersInArray {\n\n    public int nobleInteger(int[] arr) {\n        Arrays.sort(arr);\n        for (int i = 0; i < arr.length; i++) {\n            if ((arr.length - 1 - i) == arr[i]) {\n                return arr[i];\n            }\n        }\n\n        return -1;\n    }\n}", "class_id": 0, "repo": "NEWBEE108/java_algos", "file": "geeks-for-geeks/src/array/NobleIntegersInArray.java", "last_update_at": "2021-12-27T23:50:12+00:00", "question_id": "3bc37aa206b127ec430864edd59b331b4f994f0e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NobleIntegersInArray {\n    public int nobleInteger(int[] arr) {\n        Arrays.sort(arr);\n        for (int i = 0; i < arr.length; i++) {\n            if ((arr.length - 1 - i) == arr[i]) {\n                return arr[i];\n            }\n        }\n        return -1;\n    }\n"]]}
{"hexsha": "fbcf75319c426de85274374bae423ac2f8e3f1f1", "ext": "java", "lang": "Java", "content": "@Controller\npublic class SaleController {\n    @Autowired\n    SaleService service;\n\n    @RequestMapping(value = \"/sales\")\n    public String getAllSales(Model model) {\n        List<Sale> list = service.getAllSales();\n        model.addAttribute(\"sales\", list);\n        return \"sale-list\";\n    }\n}", "class_id": 0, "repo": "imran110219/Medical-Inventory", "file": "src/main/java/com/sadman/medicalinventory/controller/SaleController.java", "last_update_at": "2021-06-14T14:11:58+00:00", "question_id": "fbcf75319c426de85274374bae423ac2f8e3f1f1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\npublic class SaleController {\n    @Autowired\n    SaleService service;\n    @RequestMapping(value = \"/sales\")\n    public String getAllSales(Model model) {\n        List<Sale> list = service.getAllSales();\n        model.addAttribute(\"sales\", list);\n        return \"sale-list\";\n    }\n"]]}
{"hexsha": "2e0431d1a4cadc7c4b4e0c230f216ea1e08fe83d", "ext": "java", "lang": "Java", "content": "public class Library {\n// roll a dice n times and return an array of rolls\npublic static int[] roll(int n) {\nint [] rollArray = new int[n];\n    for (int i = 0; i < rollArray.length; i++) {\n        rollArray[i] = (int) (Math.random() * 6) + 1;\n\n    }\n    return rollArray;\n}\n\npublic static boolean containsDuplicates (int [] array){\n\n}\n// calculate the average of an array\npublic static float calculatingAverages (int[] inputArray){\n    int sum = 0;\n    for (int i = 0; i < inputArray.length; i++) {\n        sum += inputArray[i];\n\n    }\n    float average = (float) sum/ inputArray.length;\n    return average;\n}\n// take in a 2d array and return the array with the lowest average\npublic static int [] arrayOfArrays (int [][] inputArray){\n    int outputArray[] = new int[inputArray[0].length];\n    float averagedArray [] = new float[inputArray.length];\n    System.out.println(inputArray.length);\n    for (int i = 0; i < inputArray.length; i++) {\n        averagedArray[i] = calculatingAverages(inputArray[i]);\n    }\n\n    float lowest = 9999;\n    for (int i = 0; i < averagedArray.length; i++) {\n        if(averagedArray[i] < lowest){\n            lowest = averagedArray[i];\n            for (int j = 0; j < inputArray[0].length; j++) {\n                outputArray[j] = inputArray[i][j];\n            }\n        }\n    }\n    return outputArray;\n}\n\n\n}", "class_id": 0, "repo": "shaybrow/java-basics", "file": "basiclibrary/lib/src/main/java/basiclibrary/Library.java", "last_update_at": "2021-03-23T16:17:18+00:00", "question_id": "2e0431d1a4cadc7c4b4e0c230f216ea1e08fe83d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Library {\n// roll a dice n times and return an array of rolls\npublic static int[] roll(int n) {\nint [] rollArray = new int[n];\n    for (int i = 0; i < rollArray.length; i++) {\n        rollArray[i] = (int) (Math.random() * 6) + 1;\n    }\n    return rollArray;\n}\npublic static boolean containsDuplicates (int [] array){\n}\n// calculate the average of an array\npublic static float calculatingAverages (int[] inputArray){\n    int sum = 0;\n    for (int i = 0; i < inputArray.length; i++) {\n        sum += inputArray[i];\n    }\n    float average = (float) sum/ inputArray.length;\n    return average;\n}\n// take in a 2d array and return the array with the lowest average\npublic static int [] arrayOfArrays (int [][] inputArray){\n    int outputArray[] = new int[inputArray[0].length];\n    float averagedArray [] = new float[inputArray.length];\n    System.out.println(inputArray.length);\n    for (int i = 0; i < inputArray.length; i++) {\n        averagedArray[i] = calculatingAverages(inputArray[i]);\n    }\n    float lowest = 9999;\n    for (int i = 0; i < averagedArray.length; i++) {\n        if(averagedArray[i] < lowest){\n            lowest = averagedArray[i];\n            for (int j = 0; j < inputArray[0].length; j++) {\n                outputArray[j] = inputArray[i][j];\n            }\n        }\n    }\n    return outputArray;\n}\n"]]}
{"hexsha": "4a17c9b5e055a50b149cdea259f2165215f2fe4d", "ext": "java", "lang": "Java", "content": "@ApplicationScoped\npublic class RtppmFeed\n        implements Consumer<String>\n{\n\n    private static final Logger LOG = Logger.getLogger( RtppmFeed.class.getName() );\n    private static final String ROUTING_KEY = \"nr.rtppm\";\n\n    @Inject\n    private NetworkRailConnection networkRailFeed;\n\n    @Inject\n    private Rabbit rabbit;\n\n    @Inject\n    private RtppmLogger rtppmLogger;\n\n    @Inject\n    private RtppmArchiver rtppmArchiver;\n\n    private Consumer<String> publisher;\n    private Consumer<String> monitor;\n\n    @PostConstruct\n    public void start()\n    {\n        publisher = rabbit.publishString( ROUTING_KEY );\n\n        monitor = RateMonitor.log( LOG, ROUTING_KEY );\n\n        networkRailFeed.registerTopicConsumer( \"RTPPM_ALL\", JMS.toText, this );\n\n        rtppmArchiver.start();\n        rtppmLogger.start();\n    }\n\n    @Override\n    public void accept( String t )\n    {\n        if( t != null ) {\n            monitor.accept( t );\n            publisher.accept( t );\n        }\n    }\n\n}", "class_id": 0, "repo": "peter-mount/opendata", "file": "applications/networkrail/src/main/java/uk/trainwatch/nrod/feed/rtppm/RtppmFeed.java", "last_update_at": "2021-12-21T13:34:54+00:00", "question_id": "4a17c9b5e055a50b149cdea259f2165215f2fe4d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApplicationScoped\npublic class RtppmFeed\n        implements Consumer<String>\n{\n    private static final Logger LOG = Logger.getLogger( RtppmFeed.class.getName() );\n    private static final String ROUTING_KEY = \"nr.rtppm\";\n    @Inject\n    private NetworkRailConnection networkRailFeed;\n    @Inject\n    private Rabbit rabbit;\n    @Inject\n    private RtppmLogger rtppmLogger;\n    @Inject\n    private RtppmArchiver rtppmArchiver;\n    private Consumer<String> publisher;\n    private Consumer<String> monitor;\n    @PostConstruct\n    public void start()\n    {\n        publisher = rabbit.publishString( ROUTING_KEY );\n        monitor = RateMonitor.log( LOG, ROUTING_KEY );\n        networkRailFeed.registerTopicConsumer( \"RTPPM_ALL\", JMS.toText, this );\n        rtppmArchiver.start();\n        rtppmLogger.start();\n    }\n    @Override\n    public void accept( String t )\n    {\n        if( t != null ) {\n            monitor.accept( t );\n            publisher.accept( t );\n        }\n    }\n"]]}
{"hexsha": "6f4c2c53552e653c27c8464de45584da3459e70a", "ext": "java", "lang": "Java", "content": "public class FastMarchingMethodMovementStrategy extends DefaultMovementStrategy {\n\n    /**\n     * The default radius to respect other people in the neighbourhood in.l\n     */\n    public static final int DEFAULT_RADIUS = 3;\n\n    /**\n     * Name of the strategy.\n     */\n    public static final String NAME = \"Fast marching method\";\n\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public FastMarchingMethodMovementStrategy(\n            @JsonProperty(\"mollifierConfiguration\") MollifierConfiguration mollifierConfiguration,\n            @JsonProperty(\"radius\") int radius\n    ) {\n        super(mollifierConfiguration, radius);\n    }\n\n    @Override\n    public String getName() {\n        return FastMarchingMethodMovementStrategy.NAME;\n    }\n\n    /**\n     * Calculate the utility function using the fast marching method.\n     *\n     * @param state  to calculate on\n     * @param target to calculate from\n     * @return the utility function in a discrete matrix form\n     */\n    @Override\n    public double[][] calculateBasePotential(State state, Location target) {\n        FastMarchingMethod fmm = new FastMarchingMethod(\n                state.getRows(),\n                state.getColumns(),\n                (location) -> {\n                    Optional<SimObject> occupant = state.getCellOccupant(location);\n                    if (occupant.isPresent() && occupant.get().getType() == SimObjectType.OBSTACLE) {\n                        return Double.MAX_VALUE; // Avoid obstacles!\n                    }\n\n                    return null;\n                },\n                (location) -> 1.0\n        );\n\n        fmm.calculate(target);\n\n        return fmm.getResult();\n    }\n\n}", "class_id": 0, "repo": "bennyboer/stream-sim", "file": "sim/src/main/java/edu/hm/cs/bess/streamsim/sim/logic/move/FastMarchingMethodMovementStrategy.java", "last_update_at": "2021-06-15T07:08:47+00:00", "question_id": "6f4c2c53552e653c27c8464de45584da3459e70a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FastMarchingMethodMovementStrategy extends DefaultMovementStrategy {\n    /**\n     * The default radius to respect other people in the neighbourhood in.l\n     */\n    public static final int DEFAULT_RADIUS = 3;\n    /**\n     * Name of the strategy.\n     */\n    public static final String NAME = \"Fast marching method\";\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public FastMarchingMethodMovementStrategy(\n            @JsonProperty(\"mollifierConfiguration\") MollifierConfiguration mollifierConfiguration,\n            @JsonProperty(\"radius\") int radius\n    ) {\n        super(mollifierConfiguration, radius);\n    }\n    @Override\n    public String getName() {\n        return FastMarchingMethodMovementStrategy.NAME;\n    }\n    /**\n     * Calculate the utility function using the fast marching method.\n     *\n     * @param state  to calculate on\n     * @param target to calculate from\n     * @return the utility function in a discrete matrix form\n     */\n    @Override\n    public double[][] calculateBasePotential(State state, Location target) {\n        FastMarchingMethod fmm = new FastMarchingMethod(\n                state.getRows(),\n                state.getColumns(),\n                (location) -> {\n                    Optional<SimObject> occupant = state.getCellOccupant(location);\n                    if (occupant.isPresent() && occupant.get().getType() == SimObjectType.OBSTACLE) {\n                        return Double.MAX_VALUE; // Avoid obstacles!\n                    }\n                    return null;\n                },\n                (location) -> 1.0\n        );\n        fmm.calculate(target);\n        return fmm.getResult();\n    }\n"]]}
{"hexsha": "04487734330501eece391abc11eeabec9bbaa619", "ext": "java", "lang": "Java", "content": "class LayerRulesTest {\n\n  @Test\n  void layerControllerMayNotBeAccessed() {\n    getLayeredArchitectur()\n        .whereLayer(\"Controller\")\n        .mayNotBeAccessedByAnyLayer()\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  void layerBoundaryMayOnlyBeAccessedFromController() {\n    getLayeredArchitectur()\n        .whereLayer(\"Boundary\")\n        .mayOnlyBeAccessedByLayers(\"Controller\")\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  void layerRepositoryMayOnlyBeAccessedFromBoundary() {\n    getLayeredArchitectur()\n        .whereLayer(\"Repository\")\n        .mayOnlyBeAccessedByLayers(\"Boundary\")\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  void layerEntityMayNotAccessOtherLayers() {\n    noClasses()\n        .that()\n        .resideInAnyPackage(\"..entity..\")\n        .should()\n        .accessClassesThat()\n        .resideInAnyPackage(\"..controller..\", \"..services..\", \"respository..\")\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  void noUnwantedNewPackages() {\n    noClasses()\n        .that()\n        .areNotAnnotatedWith(SpringBootApplication.class)\n        .should()\n        .resideOutsideOfPackages(\n            \"..controller\",\n            \"..boundary\",\n            \"..repository\",\n            \"..entity\",\n            \"..dto\",\n            \"..common\",\n            \"..architecture\")\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  void freeOfCycles() {\n    // sort classes by the first package after 'myapp'\n    // then check those slices for cyclic dependencies\n    SlicesRuleDefinition.slices()\n        .matching(\"..benjamineckstein.(*)..\")\n        .should()\n        .beFreeOfCycles()\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  @Disabled\n  void testThatTopTierPackagesAreIndependend() {\n    // checks all subpackages of 'myapp' for cycles\n    SlicesRuleDefinition.slices()\n        .matching(\"..benjamineckstein.(**)\")\n        .should()\n        .notDependOnEachOther()\n        .check(SHOWCASECLASSES);\n  }\n\n  @Test\n  void freeOfCycles3() {\n\n    // sort classes by packages between 'myapp' and 'service'\n    // then check those slices for not having any dependencies on each other\n    SlicesRuleDefinition.slices()\n        .matching(\"..benjamineckstein.(**).service..\")\n        .should()\n        .notDependOnEachOther()\n        .check(SHOWCASECLASSES);\n  }\n\n  private Architectures.LayeredArchitecture getLayeredArchitectur() {\n    return layeredArchitecture()\n        .layer(\"Controller\")\n        .definedBy(\"..controller..\")\n        .layer(\"Boundary\")\n        .definedBy(\"..boundary..\")\n        .layer(\"Entity\")\n        .definedBy(\"..entity..\")\n        .layer(\"Repository\")\n        .definedBy(\"..repository..\");\n  }\n}", "class_id": 0, "repo": "benjamineckstein/showcase_tests", "file": "src/test/java/com/github/benjamineckstein/showcase/archunit/LayerRulesTest.java", "last_update_at": "2021-09-16T05:55:05+00:00", "question_id": "04487734330501eece391abc11eeabec9bbaa619", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class LayerRulesTest {\n  @Test\n  void layerControllerMayNotBeAccessed() {\n    getLayeredArchitectur()\n        .whereLayer(\"Controller\")\n        .mayNotBeAccessedByAnyLayer()\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  void layerBoundaryMayOnlyBeAccessedFromController() {\n    getLayeredArchitectur()\n        .whereLayer(\"Boundary\")\n        .mayOnlyBeAccessedByLayers(\"Controller\")\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  void layerRepositoryMayOnlyBeAccessedFromBoundary() {\n    getLayeredArchitectur()\n        .whereLayer(\"Repository\")\n        .mayOnlyBeAccessedByLayers(\"Boundary\")\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  void layerEntityMayNotAccessOtherLayers() {\n    noClasses()\n        .that()\n        .resideInAnyPackage(\"..entity..\")\n        .should()\n        .accessClassesThat()\n        .resideInAnyPackage(\"..controller..\", \"..services..\", \"respository..\")\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  void noUnwantedNewPackages() {\n    noClasses()\n        .that()\n        .areNotAnnotatedWith(SpringBootApplication.class)\n        .should()\n        .resideOutsideOfPackages(\n            \"..controller\",\n            \"..boundary\",\n            \"..repository\",\n            \"..entity\",\n            \"..dto\",\n            \"..common\",\n            \"..architecture\")\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  void freeOfCycles() {\n    // sort classes by the first package after 'myapp'\n    // then check those slices for cyclic dependencies\n    SlicesRuleDefinition.slices()\n        .matching(\"..benjamineckstein.(*)..\")\n        .should()\n        .beFreeOfCycles()\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  @Disabled\n  void testThatTopTierPackagesAreIndependend() {\n    // checks all subpackages of 'myapp' for cycles\n    SlicesRuleDefinition.slices()\n        .matching(\"..benjamineckstein.(**)\")\n        .should()\n        .notDependOnEachOther()\n        .check(SHOWCASECLASSES);\n  }\n  @Test\n  void freeOfCycles3() {\n    // sort classes by packages between 'myapp' and 'service'\n    // then check those slices for not having any dependencies on each other\n    SlicesRuleDefinition.slices()\n        .matching(\"..benjamineckstein.(**).service..\")\n        .should()\n        .notDependOnEachOther()\n        .check(SHOWCASECLASSES);\n  }\n  private Architectures.LayeredArchitecture getLayeredArchitectur() {\n    return layeredArchitecture()\n        .layer(\"Controller\")\n        .definedBy(\"..controller..\")\n        .layer(\"Boundary\")\n        .definedBy(\"..boundary..\")\n        .layer(\"Entity\")\n        .definedBy(\"..entity..\")\n        .layer(\"Repository\")\n        .definedBy(\"..repository..\");\n  }\n"]]}
{"hexsha": "f7522f424ae92b2a0db7550cedd1e41327b08448", "ext": "java", "lang": "Java", "content": "public class Pokemon {\n    //atributos\n    private String nome;\n    private String tipo;\n    private float peso;     //n\u00e3o esquecer de colocar o f (0.5f, 14.6f)\n    private float altura;\n    private int felicidade;\n    private int chanceDeCaptura;\n    private boolean capturado;\n\n    //metodo status atual\n    public void statusAtual() {\n        System.out.println(\"------------------------\");\n        System.out.println(\"Nome: \" + this.getNome());\n        System.out.println(\"Tipo: \" + this.getTipo());\n        System.out.println(\"Peso \" + this.getPeso());\n        System.out.println(\"Altura: \" + this.getAltura());\n        System.out.println(\"Felicidade: \" + this.getFelicidade());\n        System.out.println(\"Chance de captura: \" + this.getChanceDeCaptura());\n        System.out.println(\"Foi capturado? \" + this.isCapturado());\n        System.out.println();\n    }\n\n    //contruct\n    public Pokemon() {\n        this.setCapturado(false);\n        this.setFelicidade(0);\n    }\n\n    //metodos personalizados\n    public void capturar() {\n        Random random = new Random();\n        int aleatorio = random.nextInt(100);\n         if (this.isCapturado()) {\n             System.out.println(this.nome + \" j\u00e1 foi capturado\");\n         }\n         else {\n             if (this.chanceDeCaptura <= aleatorio) {\n                 System.out.println(\"Foi capturado\");\n                 System.out.println(aleatorio);\n                 this.setCapturado(true);\n             }\n             else {\n                 System.out.println(\"N\u00e3o foi capturado\");\n                 System.out.println(aleatorio);\n             }\n         }\n\n    }\n    public void libertar() {\n        if (this.isCapturado()) {\n            this.setCapturado(false);\n            System.out.println(this.getNome() + \" foi libertado\");\n        }\n        else {\n            System.out.println(\"N\u00e3o h\u00e1 como libertar, pois n foi capturado\");\n        }\n\n    }\n\n    public void brincar() {\n        this.setFelicidade(getFelicidade() + 20);\n\n    }\n\n    public void alimentar() {\n        this.setFelicidade(getFelicidade() + 35);\n    }\n\n    public void falar() {\n        System.out.println(\"Ol\u00e1, sou o \" + this.getNome());\n\n    }\n\n    public void evoluir(String nome, String tipo , int captura) {\n        if (this.getFelicidade() > 100) {\n            System.out.println(\"Pokemon evolu\u00eddo com sucesso\");\n            this.setFelicidade(getFelicidade() - 100);\n            this.setNome(nome);\n            this.setTipo(tipo);\n            this.setChanceDeCaptura(captura);\n        }\n        else {\n            System.out.printf(\"Sua felicidade \u00e9 de %d, espere chegar at\u00e9 100\\n\", this.getFelicidade());\n\n        }\n    }\n\n\n    //metodos especiais\n    public String getNome() {\n        return nome;\n    }\n\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n\n    public String getTipo() {\n        return tipo;\n    }\n\n    public void setTipo(String tipo) {\n        this.tipo = tipo;\n    }\n\n    public float getPeso() {\n        return peso;\n    }\n\n    public void setPeso(float peso) {\n        this.peso = peso;\n    }\n\n    public float getAltura() {\n        return altura;\n    }\n\n    public void setAltura(float altura) {\n        this.altura = altura;\n    }\n\n    public int getFelicidade() {\n        return felicidade;\n    }\n\n    public void setFelicidade(int felicidade) {\n        this.felicidade = felicidade;\n    }\n\n    public float getChanceDeCaptura() {\n        return chanceDeCaptura;\n    }\n\n    public void setChanceDeCaptura(int chanceDeCaptura) {\n        this.chanceDeCaptura = chanceDeCaptura;\n    }\n\n    public boolean isCapturado() {\n        return capturado;\n    }\n\n    public void setCapturado(boolean capturado) {\n        this.capturado = capturado;\n    }\n}", "class_id": 0, "repo": "marianamtd/Java", "file": "unirio/src/dojo/Dojo2/Pokemon.java", "last_update_at": "2021-09-22T13:27:57+00:00", "question_id": "f7522f424ae92b2a0db7550cedd1e41327b08448", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Pokemon {\n    //atributos\n    private String nome;\n    private String tipo;\n    private float peso;     //n\u00e3o esquecer de colocar o f (0.5f, 14.6f)\n    private float altura;\n    private int felicidade;\n    private int chanceDeCaptura;\n    private boolean capturado;\n    //metodo status atual\n    public void statusAtual() {\n        System.out.println(\"------------------------\");\n        System.out.println(\"Nome: \" + this.getNome());\n        System.out.println(\"Tipo: \" + this.getTipo());\n        System.out.println(\"Peso \" + this.getPeso());\n        System.out.println(\"Altura: \" + this.getAltura());\n        System.out.println(\"Felicidade: \" + this.getFelicidade());\n        System.out.println(\"Chance de captura: \" + this.getChanceDeCaptura());\n        System.out.println(\"Foi capturado? \" + this.isCapturado());\n        System.out.println();\n    }\n    //contruct\n    public Pokemon() {\n        this.setCapturado(false);\n        this.setFelicidade(0);\n    }\n    //metodos personalizados\n    public void capturar() {\n        Random random = new Random();\n        int aleatorio = random.nextInt(100);\n         if (this.isCapturado()) {\n             System.out.println(this.nome + \" j\u00e1 foi capturado\");\n         }\n         else {\n             if (this.chanceDeCaptura <= aleatorio) {\n                 System.out.println(\"Foi capturado\");\n                 System.out.println(aleatorio);\n                 this.setCapturado(true);\n             }\n             else {\n                 System.out.println(\"N\u00e3o foi capturado\");\n                 System.out.println(aleatorio);\n             }\n         }\n    }\n    public void libertar() {\n        if (this.isCapturado()) {\n            this.setCapturado(false);\n            System.out.println(this.getNome() + \" foi libertado\");\n        }\n        else {\n            System.out.println(\"N\u00e3o h\u00e1 como libertar, pois n foi capturado\");\n        }\n    }\n    public void brincar() {\n        this.setFelicidade(getFelicidade() + 20);\n    }\n    public void alimentar() {\n        this.setFelicidade(getFelicidade() + 35);\n    }\n    public void falar() {\n        System.out.println(\"Ol\u00e1, sou o \" + this.getNome());\n    }\n    public void evoluir(String nome, String tipo , int captura) {\n        if (this.getFelicidade() > 100) {\n            System.out.println(\"Pokemon evolu\u00eddo com sucesso\");\n            this.setFelicidade(getFelicidade() - 100);\n            this.setNome(nome);\n            this.setTipo(tipo);\n            this.setChanceDeCaptura(captura);\n        }\n        else {\n            System.out.printf(\"Sua felicidade \u00e9 de %d, espere chegar at\u00e9 100\\n\", this.getFelicidade());\n        }\n    }\n    //metodos especiais\n    public String getNome() {\n        return nome;\n    }\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n    public String getTipo() {\n        return tipo;\n    }\n    public void setTipo(String tipo) {\n        this.tipo = tipo;\n    }\n    public float getPeso() {\n        return peso;\n    }\n    public void setPeso(float peso) {\n        this.peso = peso;\n    }\n    public float getAltura() {\n        return altura;\n    }\n    public void setAltura(float altura) {\n        this.altura = altura;\n    }\n    public int getFelicidade() {\n        return felicidade;\n    }\n    public void setFelicidade(int felicidade) {\n        this.felicidade = felicidade;\n    }\n    public float getChanceDeCaptura() {\n        return chanceDeCaptura;\n    }\n    public void setChanceDeCaptura(int chanceDeCaptura) {\n        this.chanceDeCaptura = chanceDeCaptura;\n    }\n    public boolean isCapturado() {\n        return capturado;\n    }\n    public void setCapturado(boolean capturado) {\n        this.capturado = capturado;\n    }\n"]]}
{"hexsha": "640175d1e067155b22c70f2b34c608f3002f0f9f", "ext": "java", "lang": "Java", "content": "public class ByteSizeUnitTests extends ElasticsearchTestCase {\n\n    @Test\n    public void testBytes() {\n        assertThat(BYTES.toBytes(1), equalTo(1l));\n        assertThat(BYTES.toKB(1024), equalTo(1l));\n        assertThat(BYTES.toMB(1024 * 1024), equalTo(1l));\n        assertThat(BYTES.toGB(1024 * 1024 * 1024), equalTo(1l));\n    }\n\n    @Test\n    public void testKB() {\n        assertThat(KB.toBytes(1), equalTo(1024l));\n        assertThat(KB.toKB(1), equalTo(1l));\n        assertThat(KB.toMB(1024), equalTo(1l));\n        assertThat(KB.toGB(1024 * 1024), equalTo(1l));\n    }\n\n    @Test\n    public void testMB() {\n        assertThat(MB.toBytes(1), equalTo(1024l * 1024));\n        assertThat(MB.toKB(1), equalTo(1024l));\n        assertThat(MB.toMB(1), equalTo(1l));\n        assertThat(MB.toGB(1024), equalTo(1l));\n    }\n\n    @Test\n    public void testGB() {\n        assertThat(GB.toBytes(1), equalTo(1024l * 1024 * 1024));\n        assertThat(GB.toKB(1), equalTo(1024l * 1024));\n        assertThat(GB.toMB(1), equalTo(1024l));\n        assertThat(GB.toGB(1), equalTo(1l));\n    }\n}", "class_id": 0, "repo": "liatrio/elasticsearch", "file": "src/test/java/org/elasticsearch/common/unit/ByteSizeUnitTests.java", "last_update_at": "2021-02-21T21:58:27+00:00", "question_id": "640175d1e067155b22c70f2b34c608f3002f0f9f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ByteSizeUnitTests extends ElasticsearchTestCase {\n    @Test\n    public void testBytes() {\n        assertThat(BYTES.toBytes(1), equalTo(1l));\n        assertThat(BYTES.toKB(1024), equalTo(1l));\n        assertThat(BYTES.toMB(1024 * 1024), equalTo(1l));\n        assertThat(BYTES.toGB(1024 * 1024 * 1024), equalTo(1l));\n    }\n    @Test\n    public void testKB() {\n        assertThat(KB.toBytes(1), equalTo(1024l));\n        assertThat(KB.toKB(1), equalTo(1l));\n        assertThat(KB.toMB(1024), equalTo(1l));\n        assertThat(KB.toGB(1024 * 1024), equalTo(1l));\n    }\n    @Test\n    public void testMB() {\n        assertThat(MB.toBytes(1), equalTo(1024l * 1024));\n        assertThat(MB.toKB(1), equalTo(1024l));\n        assertThat(MB.toMB(1), equalTo(1l));\n        assertThat(MB.toGB(1024), equalTo(1l));\n    }\n    @Test\n    public void testGB() {\n        assertThat(GB.toBytes(1), equalTo(1024l * 1024 * 1024));\n        assertThat(GB.toKB(1), equalTo(1024l * 1024));\n        assertThat(GB.toMB(1), equalTo(1024l));\n        assertThat(GB.toGB(1), equalTo(1l));\n    }\n"]]}
{"hexsha": "0194d4049752064a887d1e9fe16575075c992aa7", "ext": "java", "lang": "Java", "content": "public final class SpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {\n    public SpscLinkedAtomicQueue() {\n        LinkedQueueNode<E> node = new LinkedQueueNode();\n        spProducerNode(node);\n        spConsumerNode(node);\n        node.soNext(null);\n    }\n\n    public boolean offer(E nextValue) {\n        if (nextValue == null) {\n            throw new NullPointerException(\"null elements not allowed\");\n        }\n        LinkedQueueNode<E> nextNode = new LinkedQueueNode(nextValue);\n        lpProducerNode().soNext(nextNode);\n        spProducerNode(nextNode);\n        return true;\n    }\n\n    public E poll() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode == null) {\n            return null;\n        }\n        E nextValue = nextNode.getAndNullValue();\n        spConsumerNode(nextNode);\n        return nextValue;\n    }\n\n    public E peek() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "JackChan1999/boohee_v5.6", "file": "src/main/java/rx/internal/util/atomic/SpscLinkedAtomicQueue.java", "last_update_at": "2021-04-22T12:22:39+00:00", "question_id": "0194d4049752064a887d1e9fe16575075c992aa7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {\n    public SpscLinkedAtomicQueue() {\n        LinkedQueueNode<E> node = new LinkedQueueNode();\n        spProducerNode(node);\n        spConsumerNode(node);\n        node.soNext(null);\n    }\n    public boolean offer(E nextValue) {\n        if (nextValue == null) {\n            throw new NullPointerException(\"null elements not allowed\");\n        }\n        LinkedQueueNode<E> nextNode = new LinkedQueueNode(nextValue);\n        lpProducerNode().soNext(nextNode);\n        spProducerNode(nextNode);\n        return true;\n    }\n    public E poll() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode == null) {\n            return null;\n        }\n        E nextValue = nextNode.getAndNullValue();\n        spConsumerNode(nextNode);\n        return nextValue;\n    }\n    public E peek() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }\n"]]}
{"hexsha": "df24fff179af2f6b34da1640e8cdc9a0ebf2b74e", "ext": "java", "lang": "Java", "content": "public class GenericFontMapper implements org.jpedal.render.output.FontMapper {\n\n    private static final String DEFAULT_FONT = \"DEFAULT_FONT\";\n\n    //weight\n    String style=\"normal\";\n    String weight=\"normal\";\n    String family;\n\n    private String fontID;\n\n    private int fontMode=DEFAULT_ON_UNMAPPED;\n\n    private boolean isFontEmbedded;\n    private boolean isFontSubstituted;\n\n    //list of font mappings to substitute fonts\n    public static final Map<String, String> fontMappings = new HashMap<String,String>();\n    public static final Map<String, Integer> fontSizeAdjustments = new HashMap<String, Integer>();\n    private static final Map<String, String> fontStyle = new HashMap<String,String>();\n    private static final Map<String, String> fontWeight = new HashMap<String,String>();\n\n    //original name in PDF\n    private String rawFont;\n\n    //<link><a name=\"fonts\" />\n\n    //setup font substitutions once\n    static{\n\n        //Mappings reference: http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html\n        final String arialType = \"Arial, Helvetica, sans-serif\";\n        final String arialBlackType = \"'Arial Black', Gadget, sans-serif\";\n        final String comicSansType = \"'Comic Sans MS', Textile, cursive\";\n        final String courierNewType = \"'Courier New', Courier, monospace\";\n        final String georgiaType = \"Georgia, 'Times New Roman', Times, serif\";\n        final String impactType = \"Impact, Charcoal, sans-serif\";\n        final String lucidaConsoleType = \"'Lucida Console', Monaco, monospace\";\n        final String lucidaSansType = \"'Lucida Sans Unicode', 'Lucida Grande', sans-serif\";\n        final String palatinoType = \"'Palatino Linotype', 'Book Antiqua', Palatino, serif\";\n        final String tahomaType = \"Tahoma, Geneva, sans-serif\";\n        final String romanType = \"'Times New Roman', Times, serif\";\n        final String trebuchetType = \"'Trebuchet MS', Helvetica, sans-serif\";\n        final String verdanaType = \"Verdana, Geneva, sans-serif\";\n        final String symbolType = \"Symbol\";\n        final String webdingsType = \"Webdings\";\n        final String wingdingsType = \"Wingdings, 'Zapf Dingbats'\";\n        final String msSansSerifType = \"'MS Sans Serif', Geneva, sans-serif\";\n        final String msSerifType = \"'MS Serif', 'New York', serif\";\n        final String helveticaType =  \"Helvetica, Arial, sans-serif\";\n\n        if(fontMappings.keySet().isEmpty()){\n            //Default fonts\n            fontMappings.put(\"Arial\", arialType);\n            fontMappings.put(\"ArialMT\", arialType);\n            fontMappings.put(\"ArialBlack\", arialBlackType);\n            fontMappings.put(\"ComicSansMS\", comicSansType);\n            fontMappings.put(\"CourierNew\", courierNewType);\n            fontMappings.put(\"Georgia\", georgiaType);\n            fontMappings.put(\"Impact\", impactType);\n            fontMappings.put(\"LucidaConsole\", lucidaConsoleType);\n            fontMappings.put(\"LucidaSansUnicode\", lucidaSansType);\n            fontMappings.put(\"PalatinoLinotype\", palatinoType);\n            fontMappings.put(\"Tahoma\", tahomaType);\n            fontMappings.put(\"TimesNewRoman\", romanType);\n            fontMappings.put(\"Times\", romanType);\n            fontMappings.put(\"Trebuchet\", trebuchetType);\n            fontMappings.put(\"Verdana\", verdanaType);\n            fontMappings.put(\"Symbol\", symbolType);\n            fontMappings.put(\"Webdings\", webdingsType);\n            fontMappings.put(\"Wingdings\", wingdingsType);\n            fontMappings.put(\"MSSansSerif\", msSansSerifType);\n            fontMappings.put(\"MSSerif\", msSerifType);\n            fontMappings.put(\"Helvetica\", helveticaType);\n            fontMappings.put(\"ZapfDingbats\", wingdingsType);\n\n            fontMappings.put(DEFAULT_FONT, romanType);\n            fontSizeAdjustments.put(DEFAULT_FONT, -1); //Err on the side of caution for default fonts.\n        }\n    }\n\n    public GenericFontMapper(final String rawFont)\n    {\n        init(rawFont);\n\n        this.rawFont=rawFont;\n    }\n\n    public GenericFontMapper(final String rawFont, final int fontMode, final boolean isFontEmbedded, final boolean isFontSubstituted) {\n\n        this.fontMode = fontMode;\n        this.isFontEmbedded = isFontEmbedded;\n        this.isFontSubstituted = isFontSubstituted;\n        this.rawFont = rawFont;\n\n        init(rawFont);\n\n    }\n\n    private void init(final String rawFont)\n    {\n\n        if(fontMode==EMBED_ALL || fontMode==EMBED_ALL_EXCEPT_BASE_FAMILIES){  //Arial-Bold or Arial,bold need splitting into family and weight\n\n            fontID=rawFont;\n\n            //limit to nonn-emebedded of Standard (ie TNR, Arial)\n            if(!isFontEmbedded || StandardFonts.isStandardFont(rawFont,true)){\n\n                int ptr=rawFont.indexOf(',');\n                if(ptr==-1){\n                    ptr=rawFont.indexOf('-');\n                }\n\n                if(ptr==-1) {\n\n                    //Split at the last number\n                    for(int i = (rawFont.length() - 1); i >= 0; i--) {\n                        final int pt = rawFont.codePointAt(i);\n                        if(pt >= 0x30 && pt <= 0x39) {\n                            if(i < (rawFont.length() - 1)) {\n                                ptr = i - 1;\n                            }\n                            break;\n                        }\n                    }\n                }\n\n                if(ptr>0){\n                    findAttributes(rawFont);\n                }\n           }\n\n            //Font exists as it is in mappings\n        }else if(!directMapFont(rawFont)) {\n            final String fontLessAttributes = findAttributes(rawFont);\n\n            //Does the font name minus attributes exist in mappings?\n            if(!mapFont(fontLessAttributes)) {\n\n                //If there isnt a similiar one use the default.\n                if(!hasSimiliarMapping(fontLessAttributes)) {\n                    switch(this.fontMode) {\n                        case DEFAULT_ON_UNMAPPED:\n                            fontID = DEFAULT_FONT;\n                            break;\n\n                        case FontMapper.FAIL_ON_UNMAPPED:\n                            throw new RuntimeException(\"Font \" + rawFont + \" not mapped\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Strip out and set font attributes returning the font name\n     * @param rawFont\n     * @return String contains the name of the font\n     */\n    private String findAttributes(final String rawFont)\n    {\n        String result = rawFont;\n\n        int ptr = rawFont.indexOf(',');\n\n        if(ptr==-1) {\n            ptr = rawFont.indexOf('-');\n        }\n\n        if(ptr==-1) {\n            ptr = rawFont.lastIndexOf(' ');\n        }\n        \n        if(ptr==-1) {\n\n            //Split at the last number\n            for(int i = (rawFont.length() - 1); i >= 0; i--) {\n                final int pt = rawFont.codePointAt(i);\n                if(pt >= 0x30 && pt <= 0x39) {\n                    if(i < (rawFont.length() - 1)) {\n                        ptr = i - 1;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if(ptr != -1) {\n            final String fontAttributes = rawFont.substring(ptr+1, rawFont.length()).toLowerCase();\n            result = rawFont.substring(0, ptr);\n            family=result; //font less any -, or number\n           \n            boolean isFontExists=false;\n            \n            for(final String k : fontMappings.keySet()){\n            \tif(k.startsWith(family)){\n            \t\tisFontExists = true;\n            \t}\n            }\n            \n            if(isFontExists || !isFontEmbedded){\n\n            \tif(fontAttributes.contains(\"heavy\")) {\n            \t\tweight = \"900\";\n            \t}\n            \telse if(fontAttributes.endsWith(\"black\")) {\n            \t\tweight = \"bolder\";\n            \t}\n            \telse if(fontAttributes.contains(\"light\")) {\n            \t\tweight = \"lighter\";\n            \t}\n            \telse if(fontAttributes.contains(\"condensed\")) {\n            \t\tweight = \"100\";\n            \t}\n            \telse if(fontAttributes.contains(\"bold\")) {\n            \t\tweight = \"bold\";\n            \t}\n\n            \t/**\n            \t * and style\n            \t */\n            \tif(fontAttributes.equals(\"it\") || fontAttributes.contains(\"italic\") || fontAttributes.contains(\"kursiv\") || fontAttributes.contains(\"oblique\")) {\n            \t\tstyle = \"italic\";\n            \t}\n\n            }\n\n        }\n        \n        return result;\n    }\n\n    /**\n     * See if font is in mappings and set the font ID.  Return false if its not.\n     * @param s String to check\n     * @return true if it maps\n     */\n    private boolean mapFont(final String s)\n    {\n        if(fontMappings.get(s) != null) {\n            fontID = s;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find out if there is a direct mapping to the given font\n     */\n    private boolean directMapFont(final String s)\n    {\n        final boolean result = mapFont(s);\n\n        if(!result) {\n            return false;\n        }\n\n        if(fontStyle.containsKey(s)) {\n            style = fontStyle.get(s);\n        }\n\n        if(fontWeight.containsKey(s)) {\n            weight = fontWeight.get(s);\n        }\n\n        return true;\n    }\n\n\n    /**\n     * Search mappings for a one that sounds close.\n     * @param fontName\n     * @return\n     */\n    private boolean hasSimiliarMapping(final String fontName)\n    {\n        final Set<String> keySet = fontMappings.keySet();\n        final Set<String> candidates = new HashSet<String>();\n\n        for(final String key : keySet) {\n            final String lcKey = key.toLowerCase();\n            final String lcFont = fontName.toLowerCase();\n\n            if(lcKey.equals(lcFont)) {\n                fontID = key;\n                return true;\n            }\n\n            if(lcKey.contains(lcFont) || lcFont.contains(lcKey)) {\n                candidates.add(key);\n            }\n        }\n\n        if(!candidates.isEmpty()) {\n            String result[] = new String[candidates.size()];\n            result = candidates.toArray(result);\n            fontID = result[0];\n\n            //@TODO Just get the shortest one for the time being.\n            if(candidates.size()>1) {\n                for(int i = 1; i < result.length; i++) {\n                    if(result[i].length() < fontID.length()) {\n                        fontID = result[i];\n                    }\n                }\n            }\n            return true;\n        }\n\n        return false;\n    }\n    \n    @Override\n    public String getFont() {\n\n        String result = fontMappings.get(fontID);\n\n        if(result == null && family != null && !isFontEmbedded){\n            result = fontMappings.get(family);\n        }\n        \n        if (result == null && (fontMode==EMBED_ALL || fontMode==EMBED_ALL_EXCEPT_BASE_FAMILIES)){ //just pass through\n            rawFont = rawFont.replaceAll(\"[.,@*#]\", \"-\");\n            result = rawFont;\n        } else if (result != null && isFontEmbedded && fontMode == EMBED_ALL){//if embedded font called WingDings we want to pass pack font name not generic mappings\n            //for general discussion should make it live for all values\n          //  System.out.println(fontID+\" \"+result);\n            result = fontID;\n        }\n\n        return (result == null) ? \"\" : result;\n    }\n\n\n    @Override\n    public String getStyle() {\n        if (isFontEmbedded) {\n            style = \"normal\";\n        }\n        return style;\n    }\n\n    @Override\n    public String getWeight() {\n        if (isFontEmbedded) {\n            weight = \"normal\";\n        }\n        return weight;\n    }\n\n    @Override\n    public boolean isFontEmbedded() {\n        return isFontEmbedded;\n    }\n\n    @Override\n    public boolean isFontSubstituted() {\n        return isFontSubstituted;\n    }\n\n    @Override\n    public boolean equals(FontMapper fontMapper) {\n        return this.getStyle().equals(fontMapper.getStyle()) &&\n                this.getFont().equals(fontMapper.getFont()) &&\n                this.getWeight().equals(fontMapper.getWeight()) &&\n                this.isFontEmbedded() == fontMapper.isFontEmbedded();\n    }\n\n}", "class_id": 0, "repo": "UprootStaging/maven-OpenViewerFX-src", "file": "OpenViewerFX/src/main/java/org/jpedal/render/output/GenericFontMapper.java", "last_update_at": "2021-09-03T08:51:14+00:00", "question_id": "df24fff179af2f6b34da1640e8cdc9a0ebf2b74e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GenericFontMapper implements org.jpedal.render.output.FontMapper {\n    private static final String DEFAULT_FONT = \"DEFAULT_FONT\";\n    //weight\n    String style=\"normal\";\n    String weight=\"normal\";\n    String family;\n    private String fontID;\n    private int fontMode=DEFAULT_ON_UNMAPPED;\n    private boolean isFontEmbedded;\n    private boolean isFontSubstituted;\n    //list of font mappings to substitute fonts\n    public static final Map<String, String> fontMappings = new HashMap<String,String>();\n    public static final Map<String, Integer> fontSizeAdjustments = new HashMap<String, Integer>();\n    private static final Map<String, String> fontStyle = new HashMap<String,String>();\n    private static final Map<String, String> fontWeight = new HashMap<String,String>();\n    //original name in PDF\n    private String rawFont;\n    //<link><a name=\"fonts\" />\n    //setup font substitutions once\n    static{\n        //Mappings reference: http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html\n        final String arialType = \"Arial, Helvetica, sans-serif\";\n        final String arialBlackType = \"'Arial Black', Gadget, sans-serif\";\n        final String comicSansType = \"'Comic Sans MS', Textile, cursive\";\n        final String courierNewType = \"'Courier New', Courier, monospace\";\n        final String georgiaType = \"Georgia, 'Times New Roman', Times, serif\";\n        final String impactType = \"Impact, Charcoal, sans-serif\";\n        final String lucidaConsoleType = \"'Lucida Console', Monaco, monospace\";\n        final String lucidaSansType = \"'Lucida Sans Unicode', 'Lucida Grande', sans-serif\";\n        final String palatinoType = \"'Palatino Linotype', 'Book Antiqua', Palatino, serif\";\n        final String tahomaType = \"Tahoma, Geneva, sans-serif\";\n        final String romanType = \"'Times New Roman', Times, serif\";\n        final String trebuchetType = \"'Trebuchet MS', Helvetica, sans-serif\";\n        final String verdanaType = \"Verdana, Geneva, sans-serif\";\n        final String symbolType = \"Symbol\";\n        final String webdingsType = \"Webdings\";\n        final String wingdingsType = \"Wingdings, 'Zapf Dingbats'\";\n        final String msSansSerifType = \"'MS Sans Serif', Geneva, sans-serif\";\n        final String msSerifType = \"'MS Serif', 'New York', serif\";\n        final String helveticaType =  \"Helvetica, Arial, sans-serif\";\n        if(fontMappings.keySet().isEmpty()){\n            //Default fonts\n            fontMappings.put(\"Arial\", arialType);\n            fontMappings.put(\"ArialMT\", arialType);\n            fontMappings.put(\"ArialBlack\", arialBlackType);\n            fontMappings.put(\"ComicSansMS\", comicSansType);\n            fontMappings.put(\"CourierNew\", courierNewType);\n            fontMappings.put(\"Georgia\", georgiaType);\n            fontMappings.put(\"Impact\", impactType);\n            fontMappings.put(\"LucidaConsole\", lucidaConsoleType);\n            fontMappings.put(\"LucidaSansUnicode\", lucidaSansType);\n            fontMappings.put(\"PalatinoLinotype\", palatinoType);\n            fontMappings.put(\"Tahoma\", tahomaType);\n            fontMappings.put(\"TimesNewRoman\", romanType);\n            fontMappings.put(\"Times\", romanType);\n            fontMappings.put(\"Trebuchet\", trebuchetType);\n            fontMappings.put(\"Verdana\", verdanaType);\n            fontMappings.put(\"Symbol\", symbolType);\n            fontMappings.put(\"Webdings\", webdingsType);\n            fontMappings.put(\"Wingdings\", wingdingsType);\n            fontMappings.put(\"MSSansSerif\", msSansSerifType);\n            fontMappings.put(\"MSSerif\", msSerifType);\n            fontMappings.put(\"Helvetica\", helveticaType);\n            fontMappings.put(\"ZapfDingbats\", wingdingsType);\n            fontMappings.put(DEFAULT_FONT, romanType);\n            fontSizeAdjustments.put(DEFAULT_FONT, -1); //Err on the side of caution for default fonts.\n        }\n    }\n    public GenericFontMapper(final String rawFont)\n    {\n        init(rawFont);\n        this.rawFont=rawFont;\n    }\n    public GenericFontMapper(final String rawFont, final int fontMode, final boolean isFontEmbedded, final boolean isFontSubstituted) {\n        this.fontMode = fontMode;\n        this.isFontEmbedded = isFontEmbedded;\n        this.isFontSubstituted = isFontSubstituted;\n        this.rawFont = rawFont;\n        init(rawFont);\n    }\n    private void init(final String rawFont)\n    {\n        if(fontMode==EMBED_ALL || fontMode==EMBED_ALL_EXCEPT_BASE_FAMILIES){  //Arial-Bold or Arial,bold need splitting into family and weight\n            fontID=rawFont;\n            //limit to nonn-emebedded of Standard (ie TNR, Arial)\n            if(!isFontEmbedded || StandardFonts.isStandardFont(rawFont,true)){\n                int ptr=rawFont.indexOf(',');\n                if(ptr==-1){\n                    ptr=rawFont.indexOf('-');\n                }\n                if(ptr==-1) {\n                    //Split at the last number\n                    for(int i = (rawFont.length() - 1); i >= 0; i--) {\n                        final int pt = rawFont.codePointAt(i);\n                        if(pt >= 0x30 && pt <= 0x39) {\n                            if(i < (rawFont.length() - 1)) {\n                                ptr = i - 1;\n                            }\n                            break;\n                        }\n                    }\n                }\n                if(ptr>0){\n                    findAttributes(rawFont);\n                }\n           }\n            //Font exists as it is in mappings\n        }else if(!directMapFont(rawFont)) {\n            final String fontLessAttributes = findAttributes(rawFont);\n            //Does the font name minus attributes exist in mappings?\n            if(!mapFont(fontLessAttributes)) {\n                //If there isnt a similiar one use the default.\n                if(!hasSimiliarMapping(fontLessAttributes)) {\n                    switch(this.fontMode) {\n                        case DEFAULT_ON_UNMAPPED:\n                            fontID = DEFAULT_FONT;\n                            break;\n                        case FontMapper.FAIL_ON_UNMAPPED:\n                            throw new RuntimeException(\"Font \" + rawFont + \" not mapped\");\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Strip out and set font attributes returning the font name\n     * @param rawFont\n     * @return String contains the name of the font\n     */\n    private String findAttributes(final String rawFont)\n    {\n        String result = rawFont;\n        int ptr = rawFont.indexOf(',');\n        if(ptr==-1) {\n            ptr = rawFont.indexOf('-');\n        }\n        if(ptr==-1) {\n            ptr = rawFont.lastIndexOf(' ');\n        }\n        if(ptr==-1) {\n            //Split at the last number\n            for(int i = (rawFont.length() - 1); i >= 0; i--) {\n                final int pt = rawFont.codePointAt(i);\n                if(pt >= 0x30 && pt <= 0x39) {\n                    if(i < (rawFont.length() - 1)) {\n                        ptr = i - 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if(ptr != -1) {\n            final String fontAttributes = rawFont.substring(ptr+1, rawFont.length()).toLowerCase();\n            result = rawFont.substring(0, ptr);\n            family=result; //font less any -, or number\n            boolean isFontExists=false;\n            for(final String k : fontMappings.keySet()){\n            \tif(k.startsWith(family)){\n            \t\tisFontExists = true;\n            \t}\n            }\n            if(isFontExists || !isFontEmbedded){\n            \tif(fontAttributes.contains(\"heavy\")) {\n            \t\tweight = \"900\";\n            \t}\n            \telse if(fontAttributes.endsWith(\"black\")) {\n            \t\tweight = \"bolder\";\n            \t}\n            \telse if(fontAttributes.contains(\"light\")) {\n            \t\tweight = \"lighter\";\n            \t}\n            \telse if(fontAttributes.contains(\"condensed\")) {\n            \t\tweight = \"100\";\n            \t}\n            \telse if(fontAttributes.contains(\"bold\")) {\n            \t\tweight = \"bold\";\n            \t}\n            \t/**\n            \t * and style\n            \t */\n            \tif(fontAttributes.equals(\"it\") || fontAttributes.contains(\"italic\") || fontAttributes.contains(\"kursiv\") || fontAttributes.contains(\"oblique\")) {\n            \t\tstyle = \"italic\";\n            \t}\n            }\n        }\n        return result;\n    }\n    /**\n     * See if font is in mappings and set the font ID.  Return false if its not.\n     * @param s String to check\n     * @return true if it maps\n     */\n    private boolean mapFont(final String s)\n    {\n        if(fontMappings.get(s) != null) {\n            fontID = s;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Find out if there is a direct mapping to the given font\n     */\n    private boolean directMapFont(final String s)\n    {\n        final boolean result = mapFont(s);\n        if(!result) {\n            return false;\n        }\n        if(fontStyle.containsKey(s)) {\n            style = fontStyle.get(s);\n        }\n        if(fontWeight.containsKey(s)) {\n            weight = fontWeight.get(s);\n        }\n        return true;\n    }\n    /**\n     * Search mappings for a one that sounds close.\n     * @param fontName\n     * @return\n     */\n    private boolean hasSimiliarMapping(final String fontName)\n    {\n        final Set<String> keySet = fontMappings.keySet();\n        final Set<String> candidates = new HashSet<String>();\n        for(final String key : keySet) {\n            final String lcKey = key.toLowerCase();\n            final String lcFont = fontName.toLowerCase();\n            if(lcKey.equals(lcFont)) {\n                fontID = key;\n                return true;\n            }\n            if(lcKey.contains(lcFont) || lcFont.contains(lcKey)) {\n                candidates.add(key);\n            }\n        }\n        if(!candidates.isEmpty()) {\n            String result[] = new String[candidates.size()];\n            result = candidates.toArray(result);\n            fontID = result[0];\n            //@TODO Just get the shortest one for the time being.\n            if(candidates.size()>1) {\n                for(int i = 1; i < result.length; i++) {\n                    if(result[i].length() < fontID.length()) {\n                        fontID = result[i];\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    @Override\n    public String getFont() {\n        String result = fontMappings.get(fontID);\n        if(result == null && family != null && !isFontEmbedded){\n            result = fontMappings.get(family);\n        }\n        if (result == null && (fontMode==EMBED_ALL || fontMode==EMBED_ALL_EXCEPT_BASE_FAMILIES)){ //just pass through\n            rawFont = rawFont.replaceAll(\"[.,@*#]\", \"-\");\n            result = rawFont;\n        } else if (result != null && isFontEmbedded && fontMode == EMBED_ALL){//if embedded font called WingDings we want to pass pack font name not generic mappings\n            //for general discussion should make it live for all values\n          //  System.out.println(fontID+\" \"+result);\n            result = fontID;\n        }\n        return (result == null) ? \"\" : result;\n    }\n    @Override\n    public String getStyle() {\n        if (isFontEmbedded) {\n            style = \"normal\";\n        }\n        return style;\n    }\n    @Override\n    public String getWeight() {\n        if (isFontEmbedded) {\n            weight = \"normal\";\n        }\n        return weight;\n    }\n    @Override\n    public boolean isFontEmbedded() {\n        return isFontEmbedded;\n    }\n    @Override\n    public boolean isFontSubstituted() {\n        return isFontSubstituted;\n    }\n    @Override\n    public boolean equals(FontMapper fontMapper) {\n        return this.getStyle().equals(fontMapper.getStyle()) &&\n                this.getFont().equals(fontMapper.getFont()) &&\n                this.getWeight().equals(fontMapper.getWeight()) &&\n                this.isFontEmbedded() == fontMapper.isFontEmbedded();\n    }\n"]]}
{"hexsha": "9cedeea0468199cd3b728e960a264b645131c05c", "ext": "java", "lang": "Java", "content": "final class ExpandedRow {\n    private final List<ExpandedPair> pairs;\n    private final int rowNumber;\n    private final boolean wasReversed;\n\n    ExpandedRow(List<ExpandedPair> list, int i, boolean z) {\n        this.pairs = new ArrayList(list);\n        this.rowNumber = i;\n        this.wasReversed = z;\n    }\n\n    /* access modifiers changed from: package-private */\n    public List<ExpandedPair> getPairs() {\n        return this.pairs;\n    }\n\n    /* access modifiers changed from: package-private */\n    public int getRowNumber() {\n        return this.rowNumber;\n    }\n\n    /* access modifiers changed from: package-private */\n    public boolean isReversed() {\n        return this.wasReversed;\n    }\n\n    /* access modifiers changed from: package-private */\n    public boolean isEquivalent(List<ExpandedPair> list) {\n        return this.pairs.equals(list);\n    }\n\n    public String toString() {\n        return \"{ \" + this.pairs + \" }\";\n    }\n\n    public boolean equals(Object obj) {\n        if (!(obj instanceof ExpandedRow)) {\n            return false;\n        }\n        ExpandedRow expandedRow = (ExpandedRow) obj;\n        if (!this.pairs.equals(expandedRow.getPairs()) || this.wasReversed != expandedRow.wasReversed) {\n            return false;\n        }\n        return true;\n    }\n\n    public int hashCode() {\n        return this.pairs.hashCode() ^ Boolean.valueOf(this.wasReversed).hashCode();\n    }\n}", "class_id": 0, "repo": "atul-vyshnav/2021_IBM_Code_Challenge_StockIT", "file": "src/StockIT-v1-release_source_from_JADX/sources/com/google/zxing/oned/rss/expanded/ExpandedRow.java", "last_update_at": "2021-11-23T10:12:35+00:00", "question_id": "9cedeea0468199cd3b728e960a264b645131c05c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class ExpandedRow {\n    private final List<ExpandedPair> pairs;\n    private final int rowNumber;\n    private final boolean wasReversed;\n    ExpandedRow(List<ExpandedPair> list, int i, boolean z) {\n        this.pairs = new ArrayList(list);\n        this.rowNumber = i;\n        this.wasReversed = z;\n    }\n    /* access modifiers changed from: package-private */\n    public List<ExpandedPair> getPairs() {\n        return this.pairs;\n    }\n    /* access modifiers changed from: package-private */\n    public int getRowNumber() {\n        return this.rowNumber;\n    }\n    /* access modifiers changed from: package-private */\n    public boolean isReversed() {\n        return this.wasReversed;\n    }\n    /* access modifiers changed from: package-private */\n    public boolean isEquivalent(List<ExpandedPair> list) {\n        return this.pairs.equals(list);\n    }\n    public String toString() {\n        return \"{ \" + this.pairs + \" }\";\n    }\n    public boolean equals(Object obj) {\n        if (!(obj instanceof ExpandedRow)) {\n            return false;\n        }\n        ExpandedRow expandedRow = (ExpandedRow) obj;\n        if (!this.pairs.equals(expandedRow.getPairs()) || this.wasReversed != expandedRow.wasReversed) {\n            return false;\n        }\n        return true;\n    }\n    public int hashCode() {\n        return this.pairs.hashCode() ^ Boolean.valueOf(this.wasReversed).hashCode();\n    }\n"]]}
{"hexsha": "fb95d0d1f84c992bbf15971afd687b13538188f4", "ext": "java", "lang": "Java", "content": "public abstract class AbstractCrawlerService {\n    private static final Logger logger = LoggerFactory.getLogger(AbstractCrawlerService.class);\n\n    private static final String ID_SEPARATOR = \".\";\n\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    protected static final String ID = \"id\";\n\n    protected static final String SESSION_ID = \"sessionId\";\n\n    protected static final String URL = \"url\";\n\n    protected static final String LAST_MODIFIED = \"lastModified\";\n\n    protected static final String CREATE_TIME = \"createTime\";\n\n    protected static final String _DOC = \"_doc\";\n\n    protected static final String[] timestampFields = { LAST_MODIFIED, CREATE_TIME };\n\n    protected static final HashFunction murmur3Hash = Hashing.murmur3_128(0);\n\n    @Resource\n    protected volatile FesenClient fesenClient;\n\n    protected String index;\n\n    protected int scrollTimeout = 60000;\n\n    protected int scrollSize = 100;\n\n    protected int bulkBufferSize = 10;\n\n    protected int numberOfShards = 5;\n\n    protected int numberOfReplicas = 1;\n\n    protected int idPrefixLength = 445;\n\n    protected FesenClient getClient() {\n        if (!fesenClient.connected()) {\n            synchronized (fesenClient) {\n                if (!fesenClient.connected()) {\n                    fesenClient.connect();\n                }\n            }\n        }\n        return fesenClient;\n    }\n\n    protected void createMapping(final String mappingName) {\n        boolean exists = false;\n        try {\n            final IndicesExistsResponse response = fesenClient.get(c -> c.admin().indices().prepareExists(index).execute());\n            exists = response.isExists();\n        } catch (final IndexNotFoundException e) {\n            // ignore\n        }\n        if (!exists) {\n            final CreateIndexResponse indexResponse = fesenClient.get(c -> {\n                final String source;\n                if (numberOfReplicas > 0) {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards\n                            + \",\\\"number_of_replicas\\\":0,\\\"auto_expand_replicas\\\":\\\"0-\" + numberOfReplicas + \"\\\"}}}\";\n                } else {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards + \",\\\"number_of_replicas\\\":\"\n                            + numberOfReplicas + \"}}}\";\n                }\n                return c.admin().indices().prepareCreate(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (indexResponse.isAcknowledged()) {\n                logger.info(\"Created {} index.\", index);\n            } else if (logger.isDebugEnabled()) {\n                logger.debug(\"Failed to create {} index.\", index);\n            }\n        }\n\n        final GetMappingsResponse getMappingsResponse = fesenClient.get(c -> c.admin().indices().prepareGetMappings(index).execute());\n        final ImmutableOpenMap<String, MappingMetadata> indexMappings = getMappingsResponse.mappings().get(index);\n        if (indexMappings == null || !indexMappings.containsKey(\"properties\")) {\n            final AcknowledgedResponse putMappingResponse = fesenClient.get(c -> {\n                final String source = FileUtil.readText(\"mapping/\" + mappingName + \".json\");\n                return c.admin().indices().preparePutMapping(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (putMappingResponse.isAcknowledged()) {\n                logger.info(\"Created {} mapping.\", index);\n            } else {\n                logger.warn(\"Failed to create {} mapping.\", index);\n            }\n        } else if (logger.isDebugEnabled()) {\n            logger.debug(\"{} mapping exists.\", index);\n        }\n    }\n\n    protected Date getDateFromSource(final Map<String, Object> sourceMap, final String name) {\n        final Object obj = sourceMap.get(name);\n        if (obj instanceof Date) {\n            return (Date) obj;\n        }\n        if (obj instanceof Number) {\n            return new Date(((Number) obj).longValue());\n        }\n        if (obj instanceof String) {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            try {\n                return sdf.parse(obj.toString());\n            } catch (final ParseException e) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to parse {}\", obj, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected XContentBuilder getXContentBuilder(final Object target) {\n        try {\n            final XContentBuilder builder = jsonBuilder().value(target);\n            builder.flush();\n            return builder;\n        } catch (final IOException e) {\n            throw new EsAccessException(\"Failed to convert \" + target + \" to JSON.\", e);\n        }\n    }\n\n    protected RefreshResponse refresh() {\n        try {\n            return getClient().get(c -> c.admin().indices().prepareRefresh(index).execute());\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to refresh.\", e);\n        }\n    }\n\n    protected IndexResponse insert(final Object target, final OpType opType) {\n        final String url = getUrl(target);\n        if (url == null) {\n            throw new EsAccessException(\"url is null.\");\n        }\n        final String id = getId(getSessionId(target), url);\n        try (final XContentBuilder source = getXContentBuilder(target)) {\n            final IndexResponse response = getClient().get(c -> c.prepareIndex().setIndex(index).setId(id).setSource(source)\n                    .setOpType(opType).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            setId(target, id);\n            return response;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + id, e);\n        }\n    }\n\n    protected <T> void insertAll(final List<T> list, final OpType opType) {\n        insertAll(list, opType, false);\n    }\n\n    protected <T> void insertAll(final List<T> list, final OpType opType, final boolean ignoreAlreadyExists) {\n        final List<T> bufferedList = new ArrayList<>(bulkBufferSize);\n        final StringBuilder failureBuf = new StringBuilder(100);\n        list.stream().forEach(target -> {\n            bufferedList.add(target);\n            if (bufferedList.size() >= bulkBufferSize) {\n                final BulkResponse response = doInsertAll(bufferedList, opType);\n                if (response.hasFailures()) {\n                    final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                    if (failureMessage.length() > 0) {\n                        failureBuf.append(response.buildFailureMessage()).append('\\n');\n                    }\n                }\n                bufferedList.clear();\n            }\n        });\n        if (!bufferedList.isEmpty()) {\n            final BulkResponse response = doInsertAll(bufferedList, opType);\n            if (response.hasFailures()) {\n                final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                if (failureMessage.length() > 0) {\n                    failureBuf.append(response.buildFailureMessage()).append('\\n');\n                }\n            }\n        }\n        if (failureBuf.length() > 0) {\n            throw new EsAccessException(failureBuf.toString());\n        }\n    }\n\n    protected String buildFailureMessage(final BulkResponse bulkResponse, final boolean ignoreAlreadyExists) {\n        final StringBuilder sb = new StringBuilder(100);\n        final BulkItemResponse[] responses = bulkResponse.getItems();\n        for (int i = 0; i < responses.length; i++) {\n            final BulkItemResponse response = responses[i];\n            if (response.isFailed()) {\n                if (ignoreAlreadyExists) {\n                    continue;\n                }\n                sb.append(\"\\n[\").append(i).append(\"]: index [\").append(response.getIndex()).append(\"], type [\").append(response.getType())\n                        .append(\"], id [\").append(response.getId()).append(\"], message [\").append(response.getFailureMessage()).append(\"]\");\n            }\n        }\n        if (sb.length() > 0) {\n            return \"failure in bulk execution:\" + sb.toString();\n        }\n        return StringUtil.EMPTY;\n    }\n\n    protected <T> BulkResponse doInsertAll(final List<T> list, final OpType opType) {\n        try {\n            return getClient().get(c -> {\n                final BulkRequestBuilder bulkRequest = c.prepareBulk();\n                for (final T target : list) {\n                    final String id = getId(getSessionId(target), getUrl(target));\n                    try (final XContentBuilder source = getXContentBuilder(target)) {\n                        bulkRequest.add(c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType));\n                    }\n                    setId(target, id);\n                }\n\n                return bulkRequest.setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute();\n            });\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + list, e);\n        }\n    }\n\n    protected boolean exists(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final GetResponse response = getClient().get(c -> c.prepareGet(index, null, id).execute());\n            return response.isExists();\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to check if \" + sessionId + \":\" + url + \" exists.\", e);\n        }\n    }\n\n    public int getCount(final Consumer<SearchRequestBuilder> callback) {\n        return (int) getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setSize(0).setTrackTotalHits(true);\n            callback.accept(builder);\n            return builder.execute();\n        }).getHits().getTotalHits().value;\n    }\n\n    protected <T> T get(final Class<T> clazz, final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        final GetResponse response = getClient().get(c -> c.prepareGet().setIndex(index).setId(id).execute());\n        if (response.isExists()) {\n            final Map<String, Object> source = response.getSource();\n            final T bean = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n            });\n            @SuppressWarnings(\"unchecked\")\n            final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n            if (data != null) {\n                ((EsAccessResult) bean).setAccessResultData(new EsAccessResultData(data));\n            }\n            setId(bean, id);\n            return bean;\n        }\n        return null;\n    }\n\n    protected <T> List<T> getList(final Class<T> clazz, final String sessionId, final QueryBuilder queryBuilder, final Integer from,\n            final Integer size, final SortBuilder<?> sortBuilder) {\n        return getList(clazz, builder -> {\n            if (StringUtil.isNotBlank(sessionId)) {\n                if (queryBuilder instanceof BoolQueryBuilder) {\n                    ((BoolQueryBuilder) queryBuilder).filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                } else {\n                    final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                    if (queryBuilder != null) {\n                        boolQuery.must(queryBuilder);\n                    }\n                    builder.setQuery(boolQuery);\n                }\n            } else if (queryBuilder != null) {\n                builder.setQuery(queryBuilder);\n            } else {\n                builder.setQuery(QueryBuilders.matchAllQuery());\n            }\n            if (sortBuilder != null) {\n                builder.addSort(sortBuilder);\n            }\n            if (from != null) {\n                builder.setFrom(from);\n            }\n            if (size != null) {\n                builder.setSize(size);\n            }\n        });\n    }\n\n    protected <T> List<T> getList(final Class<T> clazz, final Consumer<SearchRequestBuilder> callback) {\n        final SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        final EsResultList<T> targetList = new EsResultList<>();\n        final SearchHits hits = response.getHits();\n        targetList.setTotalHits(hits.getTotalHits().value);\n        targetList.setTookInMillis(response.getTook().getMillis());\n        if (hits.getTotalHits().value != 0) {\n            try {\n                for (final SearchHit searchHit : hits.getHits()) {\n                    final Map<String, Object> source = searchHit.getSourceAsMap();\n                    final T target = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                        option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                        option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n                    });\n                    @SuppressWarnings(\"unchecked\")\n                    final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n                    if (data != null) {\n                        ((EsAccessResult) target).setAccessResultData(new EsAccessResultData(data));\n                    }\n                    setId(target, searchHit.getId());\n                    targetList.add(target);\n                }\n            } catch (final Exception e) {\n                throw new EsAccessException(\"response: \" + response, e);\n            }\n        }\n        return targetList;\n    }\n\n    protected boolean delete(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final DeleteResponse response =\n                    getClient().get(c -> c.prepareDelete().setIndex(index).setId(id).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            return response.getResult() == Result.DELETED;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to delete \" + sessionId + \":\" + url, e);\n        }\n    }\n\n    protected void deleteBySessionId(final String sessionId) {\n        delete(builder -> builder.setQuery(QueryBuilders.termQuery(SESSION_ID, sessionId)));\n    }\n\n    public void deleteAll() {\n        delete(builder -> builder.setQuery(QueryBuilders.matchAllQuery()));\n    }\n\n    public void delete(final Consumer<SearchRequestBuilder> callback) {\n        SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setScroll(new TimeValue(scrollTimeout)).setSize(scrollSize);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        String scrollId = response.getScrollId();\n        try {\n            while (scrollId != null) {\n                final SearchHits searchHits = response.getHits();\n                if (searchHits.getHits().length == 0) {\n                    break;\n                }\n\n                final BulkResponse bulkResponse = getClient().get(c -> {\n                    final BulkRequestBuilder bulkBuilder = c.prepareBulk();\n                    for (final SearchHit searchHit : searchHits) {\n                        bulkBuilder.add(c.prepareDelete().setIndex(index).setId(searchHit.getId()));\n                    }\n\n                    return bulkBuilder.execute();\n                });\n                if (bulkResponse.hasFailures()) {\n                    throw new EsAccessException(bulkResponse.buildFailureMessage());\n                }\n\n                final String sid = scrollId;\n                response = getClient().get(c -> c.prepareSearchScroll(sid).setScroll(new TimeValue(scrollTimeout)).execute());\n                if (!scrollId.equals(response.getScrollId())) {\n                    getClient().clearScroll(scrollId);\n                }\n                scrollId = response.getScrollId();\n            }\n        } finally {\n            getClient().clearScroll(scrollId);\n        }\n\n        refresh();\n    }\n\n    private String getId(final String sessionId, final String url) {\n        final String id = sessionId + ID_SEPARATOR + new String(Base64.getUrlEncoder().withoutPadding().encode(url.getBytes(UTF_8)), UTF_8);\n        if (id.length() <= idPrefixLength) {\n            return id;\n        }\n        return id.substring(0, idPrefixLength) + MessageDigestUtil.digest(\"SHA-256\", id.substring(idPrefixLength));\n    }\n\n    private String getUrl(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(URL);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n\n    private String getSessionId(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(SESSION_ID);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n\n    protected void setId(final Object target, final String id) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc idProp = beanDesc.getPropertyDesc(ID);\n        idProp.setValue(target, id);\n    }\n\n    public String getIndex() {\n        return index;\n    }\n\n    public void setIndex(final String index) {\n        this.index = index;\n    }\n\n    public int getScrollTimeout() {\n        return scrollTimeout;\n    }\n\n    public void setScrollTimeout(final int scrollTimeout) {\n        this.scrollTimeout = scrollTimeout;\n    }\n\n    public int getScrollSize() {\n        return scrollSize;\n    }\n\n    public void setScrollSize(final int scrollSize) {\n        this.scrollSize = scrollSize;\n    }\n\n    protected static class EsTimestampConverter implements Converter {\n        public static final DateTimeFormatter DEFAULT_DATE_PRINTER = ISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC);\n\n        @Override\n        public String getAsString(final Object value) {\n            if (value instanceof Date) {\n                return DEFAULT_DATE_PRINTER.print(((Date) value).getTime());\n            }\n            return null;\n        }\n\n        @Override\n        public Object getAsObject(final String value) {\n            if (StringUtil.isEmpty(value)) {\n                return null;\n            }\n            return new Timestamp(DEFAULT_DATE_PRINTER.parseMillis(value));\n        }\n\n        @Override\n        public boolean isTarget(@SuppressWarnings(\"rawtypes\") final Class clazz) {\n            return clazz == Date.class;\n        }\n\n    }\n\n    public int getBulkBufferSize() {\n        return bulkBufferSize;\n    }\n\n    public void setBulkBufferSize(final int bulkBufferSize) {\n        this.bulkBufferSize = bulkBufferSize;\n    }\n\n    public void setNumberOfShards(final int numberOfShards) {\n        this.numberOfShards = numberOfShards;\n    }\n\n    public void setNumberOfReplicas(final int numberOfReplicas) {\n        this.numberOfReplicas = numberOfReplicas;\n    }\n\n    public void setIdPrefixLength(final int idPrefixLength) {\n        this.idPrefixLength = idPrefixLength;\n    }\n\n}", "class_id": 0, "repo": "codelibs/fess-crawler", "file": "fess-crawler-es/src/main/java/org/codelibs/fess/crawler/service/impl/AbstractCrawlerService.java", "last_update_at": "2021-04-08T07:26:05+00:00", "question_id": "fb95d0d1f84c992bbf15971afd687b13538188f4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractCrawlerService {\n    private static final Logger logger = LoggerFactory.getLogger(AbstractCrawlerService.class);\n    private static final String ID_SEPARATOR = \".\";\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n    protected static final String ID = \"id\";\n    protected static final String SESSION_ID = \"sessionId\";\n    protected static final String URL = \"url\";\n    protected static final String LAST_MODIFIED = \"lastModified\";\n    protected static final String CREATE_TIME = \"createTime\";\n    protected static final String _DOC = \"_doc\";\n    protected static final String[] timestampFields = { LAST_MODIFIED, CREATE_TIME };\n    protected static final HashFunction murmur3Hash = Hashing.murmur3_128(0);\n    @Resource\n    protected volatile FesenClient fesenClient;\n    protected String index;\n    protected int scrollTimeout = 60000;\n    protected int scrollSize = 100;\n    protected int bulkBufferSize = 10;\n    protected int numberOfShards = 5;\n    protected int numberOfReplicas = 1;\n    protected int idPrefixLength = 445;\n    protected FesenClient getClient() {\n        if (!fesenClient.connected()) {\n            synchronized (fesenClient) {\n                if (!fesenClient.connected()) {\n                    fesenClient.connect();\n                }\n            }\n        }\n        return fesenClient;\n    }\n    protected void createMapping(final String mappingName) {\n        boolean exists = false;\n        try {\n            final IndicesExistsResponse response = fesenClient.get(c -> c.admin().indices().prepareExists(index).execute());\n            exists = response.isExists();\n        } catch (final IndexNotFoundException e) {\n            // ignore\n        }\n        if (!exists) {\n            final CreateIndexResponse indexResponse = fesenClient.get(c -> {\n                final String source;\n                if (numberOfReplicas > 0) {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards\n                            + \",\\\"number_of_replicas\\\":0,\\\"auto_expand_replicas\\\":\\\"0-\" + numberOfReplicas + \"\\\"}}}\";\n                } else {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards + \",\\\"number_of_replicas\\\":\"\n                            + numberOfReplicas + \"}}}\";\n                }\n                return c.admin().indices().prepareCreate(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (indexResponse.isAcknowledged()) {\n                logger.info(\"Created {} index.\", index);\n            } else if (logger.isDebugEnabled()) {\n                logger.debug(\"Failed to create {} index.\", index);\n            }\n        }\n        final GetMappingsResponse getMappingsResponse = fesenClient.get(c -> c.admin().indices().prepareGetMappings(index).execute());\n        final ImmutableOpenMap<String, MappingMetadata> indexMappings = getMappingsResponse.mappings().get(index);\n        if (indexMappings == null || !indexMappings.containsKey(\"properties\")) {\n            final AcknowledgedResponse putMappingResponse = fesenClient.get(c -> {\n                final String source = FileUtil.readText(\"mapping/\" + mappingName + \".json\");\n                return c.admin().indices().preparePutMapping(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (putMappingResponse.isAcknowledged()) {\n                logger.info(\"Created {} mapping.\", index);\n            } else {\n                logger.warn(\"Failed to create {} mapping.\", index);\n            }\n        } else if (logger.isDebugEnabled()) {\n            logger.debug(\"{} mapping exists.\", index);\n        }\n    }\n    protected Date getDateFromSource(final Map<String, Object> sourceMap, final String name) {\n        final Object obj = sourceMap.get(name);\n        if (obj instanceof Date) {\n            return (Date) obj;\n        }\n        if (obj instanceof Number) {\n            return new Date(((Number) obj).longValue());\n        }\n        if (obj instanceof String) {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            try {\n                return sdf.parse(obj.toString());\n            } catch (final ParseException e) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to parse {}\", obj, e);\n                }\n            }\n        }\n        return null;\n    }\n    protected XContentBuilder getXContentBuilder(final Object target) {\n        try {\n            final XContentBuilder builder = jsonBuilder().value(target);\n            builder.flush();\n            return builder;\n        } catch (final IOException e) {\n            throw new EsAccessException(\"Failed to convert \" + target + \" to JSON.\", e);\n        }\n    }\n    protected RefreshResponse refresh() {\n        try {\n            return getClient().get(c -> c.admin().indices().prepareRefresh(index).execute());\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to refresh.\", e);\n        }\n    }\n    protected IndexResponse insert(final Object target, final OpType opType) {\n        final String url = getUrl(target);\n        if (url == null) {\n            throw new EsAccessException(\"url is null.\");\n        }\n        final String id = getId(getSessionId(target), url);\n        try (final XContentBuilder source = getXContentBuilder(target)) {\n            final IndexResponse response = getClient().get(c -> c.prepareIndex().setIndex(index).setId(id).setSource(source)\n                    .setOpType(opType).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            setId(target, id);\n            return response;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + id, e);\n        }\n    }\n    protected <T> void insertAll(final List<T> list, final OpType opType) {\n        insertAll(list, opType, false);\n    }\n    protected <T> void insertAll(final List<T> list, final OpType opType, final boolean ignoreAlreadyExists) {\n        final List<T> bufferedList = new ArrayList<>(bulkBufferSize);\n        final StringBuilder failureBuf = new StringBuilder(100);\n        list.stream().forEach(target -> {\n            bufferedList.add(target);\n            if (bufferedList.size() >= bulkBufferSize) {\n                final BulkResponse response = doInsertAll(bufferedList, opType);\n                if (response.hasFailures()) {\n                    final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                    if (failureMessage.length() > 0) {\n                        failureBuf.append(response.buildFailureMessage()).append('\\n');\n                    }\n                }\n                bufferedList.clear();\n            }\n        });\n        if (!bufferedList.isEmpty()) {\n            final BulkResponse response = doInsertAll(bufferedList, opType);\n            if (response.hasFailures()) {\n                final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                if (failureMessage.length() > 0) {\n                    failureBuf.append(response.buildFailureMessage()).append('\\n');\n                }\n            }\n        }\n        if (failureBuf.length() > 0) {\n            throw new EsAccessException(failureBuf.toString());\n        }\n    }\n    protected String buildFailureMessage(final BulkResponse bulkResponse, final boolean ignoreAlreadyExists) {\n        final StringBuilder sb = new StringBuilder(100);\n        final BulkItemResponse[] responses = bulkResponse.getItems();\n        for (int i = 0; i < responses.length; i++) {\n            final BulkItemResponse response = responses[i];\n            if (response.isFailed()) {\n                if (ignoreAlreadyExists) {\n                    continue;\n                }\n                sb.append(\"\\n[\").append(i).append(\"]: index [\").append(response.getIndex()).append(\"], type [\").append(response.getType())\n                        .append(\"], id [\").append(response.getId()).append(\"], message [\").append(response.getFailureMessage()).append(\"]\");\n            }\n        }\n        if (sb.length() > 0) {\n            return \"failure in bulk execution:\" + sb.toString();\n        }\n        return StringUtil.EMPTY;\n    }\n    protected <T> BulkResponse doInsertAll(final List<T> list, final OpType opType) {\n        try {\n            return getClient().get(c -> {\n                final BulkRequestBuilder bulkRequest = c.prepareBulk();\n                for (final T target : list) {\n                    final String id = getId(getSessionId(target), getUrl(target));\n                    try (final XContentBuilder source = getXContentBuilder(target)) {\n                        bulkRequest.add(c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType));\n                    }\n                    setId(target, id);\n                }\n                return bulkRequest.setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute();\n            });\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + list, e);\n        }\n    }\n    protected boolean exists(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final GetResponse response = getClient().get(c -> c.prepareGet(index, null, id).execute());\n            return response.isExists();\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to check if \" + sessionId + \":\" + url + \" exists.\", e);\n        }\n    }\n    public int getCount(final Consumer<SearchRequestBuilder> callback) {\n        return (int) getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setSize(0).setTrackTotalHits(true);\n            callback.accept(builder);\n            return builder.execute();\n        }).getHits().getTotalHits().value;\n    }\n    protected <T> T get(final Class<T> clazz, final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        final GetResponse response = getClient().get(c -> c.prepareGet().setIndex(index).setId(id).execute());\n        if (response.isExists()) {\n            final Map<String, Object> source = response.getSource();\n            final T bean = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n            });\n            @SuppressWarnings(\"unchecked\")\n            final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n            if (data != null) {\n                ((EsAccessResult) bean).setAccessResultData(new EsAccessResultData(data));\n            }\n            setId(bean, id);\n            return bean;\n        }\n        return null;\n    }\n    protected <T> List<T> getList(final Class<T> clazz, final String sessionId, final QueryBuilder queryBuilder, final Integer from,\n            final Integer size, final SortBuilder<?> sortBuilder) {\n        return getList(clazz, builder -> {\n            if (StringUtil.isNotBlank(sessionId)) {\n                if (queryBuilder instanceof BoolQueryBuilder) {\n                    ((BoolQueryBuilder) queryBuilder).filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                } else {\n                    final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                    if (queryBuilder != null) {\n                        boolQuery.must(queryBuilder);\n                    }\n                    builder.setQuery(boolQuery);\n                }\n            } else if (queryBuilder != null) {\n                builder.setQuery(queryBuilder);\n            } else {\n                builder.setQuery(QueryBuilders.matchAllQuery());\n            }\n            if (sortBuilder != null) {\n                builder.addSort(sortBuilder);\n            }\n            if (from != null) {\n                builder.setFrom(from);\n            }\n            if (size != null) {\n                builder.setSize(size);\n            }\n        });\n    }\n    protected <T> List<T> getList(final Class<T> clazz, final Consumer<SearchRequestBuilder> callback) {\n        final SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        final EsResultList<T> targetList = new EsResultList<>();\n        final SearchHits hits = response.getHits();\n        targetList.setTotalHits(hits.getTotalHits().value);\n        targetList.setTookInMillis(response.getTook().getMillis());\n        if (hits.getTotalHits().value != 0) {\n            try {\n                for (final SearchHit searchHit : hits.getHits()) {\n                    final Map<String, Object> source = searchHit.getSourceAsMap();\n                    final T target = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                        option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                        option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n                    });\n                    @SuppressWarnings(\"unchecked\")\n                    final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n                    if (data != null) {\n                        ((EsAccessResult) target).setAccessResultData(new EsAccessResultData(data));\n                    }\n                    setId(target, searchHit.getId());\n                    targetList.add(target);\n                }\n            } catch (final Exception e) {\n                throw new EsAccessException(\"response: \" + response, e);\n            }\n        }\n        return targetList;\n    }\n    protected boolean delete(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final DeleteResponse response =\n                    getClient().get(c -> c.prepareDelete().setIndex(index).setId(id).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            return response.getResult() == Result.DELETED;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to delete \" + sessionId + \":\" + url, e);\n        }\n    }\n    protected void deleteBySessionId(final String sessionId) {\n        delete(builder -> builder.setQuery(QueryBuilders.termQuery(SESSION_ID, sessionId)));\n    }\n    public void deleteAll() {\n        delete(builder -> builder.setQuery(QueryBuilders.matchAllQuery()));\n    }\n    public void delete(final Consumer<SearchRequestBuilder> callback) {\n        SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setScroll(new TimeValue(scrollTimeout)).setSize(scrollSize);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        String scrollId = response.getScrollId();\n        try {\n            while (scrollId != null) {\n                final SearchHits searchHits = response.getHits();\n                if (searchHits.getHits().length == 0) {\n                    break;\n                }\n                final BulkResponse bulkResponse = getClient().get(c -> {\n                    final BulkRequestBuilder bulkBuilder = c.prepareBulk();\n                    for (final SearchHit searchHit : searchHits) {\n                        bulkBuilder.add(c.prepareDelete().setIndex(index).setId(searchHit.getId()));\n                    }\n                    return bulkBuilder.execute();\n                });\n                if (bulkResponse.hasFailures()) {\n                    throw new EsAccessException(bulkResponse.buildFailureMessage());\n                }\n                final String sid = scrollId;\n                response = getClient().get(c -> c.prepareSearchScroll(sid).setScroll(new TimeValue(scrollTimeout)).execute());\n                if (!scrollId.equals(response.getScrollId())) {\n                    getClient().clearScroll(scrollId);\n                }\n                scrollId = response.getScrollId();\n            }\n        } finally {\n            getClient().clearScroll(scrollId);\n        }\n        refresh();\n    }\n    private String getId(final String sessionId, final String url) {\n        final String id = sessionId + ID_SEPARATOR + new String(Base64.getUrlEncoder().withoutPadding().encode(url.getBytes(UTF_8)), UTF_8);\n        if (id.length() <= idPrefixLength) {\n            return id;\n        }\n        return id.substring(0, idPrefixLength) + MessageDigestUtil.digest(\"SHA-256\", id.substring(idPrefixLength));\n    }\n    private String getUrl(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(URL);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n    private String getSessionId(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(SESSION_ID);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n    protected void setId(final Object target, final String id) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc idProp = beanDesc.getPropertyDesc(ID);\n        idProp.setValue(target, id);\n    }\n    public String getIndex() {\n        return index;\n    }\n    public void setIndex(final String index) {\n        this.index = index;\n    }\n    public int getScrollTimeout() {\n        return scrollTimeout;\n    }\n    public void setScrollTimeout(final int scrollTimeout) {\n        this.scrollTimeout = scrollTimeout;\n    }\n    public int getScrollSize() {\n        return scrollSize;\n    }\n    public void setScrollSize(final int scrollSize) {\n        this.scrollSize = scrollSize;\n    }\n    protected static class EsTimestampConverter implements Converter {\n        public static final DateTimeFormatter DEFAULT_DATE_PRINTER = ISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC);\n        @Override\n        public String getAsString(final Object value) {\n            if (value instanceof Date) {\n                return DEFAULT_DATE_PRINTER.print(((Date) value).getTime());\n            }\n            return null;\n        }\n        @Override\n        public Object getAsObject(final String value) {\n            if (StringUtil.isEmpty(value)) {\n                return null;\n            }\n            return new Timestamp(DEFAULT_DATE_PRINTER.parseMillis(value));\n        }\n        @Override\n        public boolean isTarget(@SuppressWarnings(\"rawtypes\") final Class clazz) {\n            return clazz == Date.class;\n        }\n    }\n    public int getBulkBufferSize() {\n        return bulkBufferSize;\n    }\n    public void setBulkBufferSize(final int bulkBufferSize) {\n        this.bulkBufferSize = bulkBufferSize;\n    }\n    public void setNumberOfShards(final int numberOfShards) {\n        this.numberOfShards = numberOfShards;\n    }\n    public void setNumberOfReplicas(final int numberOfReplicas) {\n        this.numberOfReplicas = numberOfReplicas;\n    }\n    public void setIdPrefixLength(final int idPrefixLength) {\n        this.idPrefixLength = idPrefixLength;\n    }\n"]]}
{"hexsha": "856bafe9197904c12be321e8dde1820862f17070", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({\"unused\"})\npublic class StaffCoreAPI {\n    private static main plugin;\n    \n    public StaffCoreAPI( main plugin ){\n        StaffCoreAPI.plugin = plugin;\n    }\n    \n    public static String getIP( String player ){\n        if ( utils.mysqlEnabled( ) )\n            return AltsQuery.getIp( player );\n        try {\n            return Bukkit.getPlayer( player ).getAddress( ).getAddress( ).toString( );\n        } catch ( NullPointerException error ) {\n            return \"\";\n        }\n    }\n    \n    public static int getPing( String player ){\n        try {\n            return utils.getPing( Bukkit.getPlayer( player ) );\n        } catch ( NullPointerException error ) {\n            return 0;\n        }\n    }\n    \n    public static ArrayList < String > getSavedPlayerList( ){\n        return utils.getUsers( );\n    }\n    \n    public static List < String > getPlayerAlts( String player ){\n        return CheckAlts.alts( player );\n    }\n    \n    public static void clearPlayerChat( Player player ){\n        utils.ccPlayer( player );\n    }\n    \n    public static void clearAllPlayersChat( ){\n        utils.ccAll( );\n    }\n    \n    public static boolean isRegistered( String player ){\n        return utils.isRegistered( player );\n    }\n    \n    public static boolean mysqlEnabled( ){\n        return utils.mysqlEnabled( );\n    }\n    \n    public static boolean getFrozenStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return FreezeQuery.isFrozen( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"frozen\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    \n    public static boolean getVanishedStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return VanishQuery.isVanished( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"vanished\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    \n    public static boolean getStaffStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return StaffQuery.isStaff( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"staff\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    \n    public static boolean getStaffChatStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return StaffChatQuery.isStaffChat( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"staffchat\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    \n    public static boolean getFlyingStatus( String player ){\n        return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"flying\" ) , PersistentDataType.STRING );\n    }\n    \n    public static boolean getTrollStatus( String player ){\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"troll\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    \n    public static boolean isBanned( String player ){\n        if ( mysqlEnabled( ) )\n            return BansQuery.getBannedPlayers( ).contains( player );\n        List < String > bannedPlayers = new ArrayList <>( );\n        ConfigurationSection bans = plugin.bans.getConfig( ).getConfigurationSection( \"bans\" );\n        for ( String s : bans.getKeys( false ) )\n            bannedPlayers.add( plugin.bans.getConfig( ).getString( \"bans.\" + s + \".name\" ) );\n        return bannedPlayers.contains( player );\n    }\n    \n    public static boolean isWarned( String player ){\n        if ( mysqlEnabled( ) )\n            return WarnsQuery.getWarnedPlayers( ).contains( player );\n        List < String > warnedPlayers = new ArrayList <>( );\n        ConfigurationSection warns = plugin.warns.getConfig( ).getConfigurationSection( \"warns\" );\n        for ( String s : warns.getKeys( false ) )\n            warnedPlayers.add( plugin.warns.getConfig( ).getString( \"warns.\" + s + \".name\" ) );\n        return warnedPlayers.contains( player );\n    }\n    \n    public static void setFrozenStatus( Player target , String sender , boolean status ){\n        FreezePlayer.FreezePlayer( target , sender , status );\n    }\n    \n    public static void setVanishStatus( Player target , boolean status ){\n        SetVanish.setVanish( target , status );\n    }\n    \n    public static void setStaffStatus( Player target , boolean status ){\n        if ( status ) {\n            SetStaffItems.On( target );\n        } else {\n            SetStaffItems.Off( target );\n        }\n    }\n    \n    public static void setStaffChatStatus( Player target , boolean status ){\n        if ( mysqlEnabled( ) ) {\n            if ( status ) {\n                StaffChatQuery.enable( target.getName( ) );\n            } else {\n                StaffChatQuery.disable( target.getName( ) );\n            }\n        } else if ( status ) {\n            target.getPersistentDataContainer( ).set( new NamespacedKey( plugin , \"staffchat\" ) , PersistentDataType.STRING , \"staffchat\" );\n        } else {\n            target.getPersistentDataContainer( ).remove( new NamespacedKey( plugin , \"staffchat\" ) );\n        }\n    }\n    \n    public static void setFlyingStatus( Player target , boolean status ){\n        new SetFly( target , status );\n    }\n    \n    public static ArrayList < String > getBannedPlayers( ){\n        ArrayList < String > bannedPlayers = new ArrayList <>( );\n        if ( utils.mysqlEnabled( ) ) {\n            bannedPlayers.addAll( BansQuery.getBannedPlayers( ) );\n        } else {\n            try {\n                ConfigurationSection inventorySection = plugin.bans.getConfig( ).getConfigurationSection( \"bans\" );\n                for ( String key : inventorySection.getKeys( false ) ) {\n                    String name = plugin.bans.getConfig( ).getString( \"bans.\" + key + \".name\" );\n                    if ( !bannedPlayers.contains( name ) )\n                        bannedPlayers.add( name );\n                }\n            } catch ( NullPointerException ignored ) {\n            }\n        }\n        return bannedPlayers;\n    }\n    \n    public static ArrayList < String > getReportedPlayers( ){\n        ArrayList < String > reportedPlayers = new ArrayList <>( );\n        if ( utils.mysqlEnabled( ) ) {\n            reportedPlayers.addAll( ReportsQuery.getReportedPlayers( ) );\n        } else {\n            ConfigurationSection inventorySection = plugin.reports.getConfig( ).getConfigurationSection( \"reports\" );\n            for ( String key : inventorySection.getKeys( false ) ) {\n                String name = plugin.reports.getConfig( ).getString( \"reports.\" + key + \".name\" );\n                if ( !reportedPlayers.contains( name ) )\n                    reportedPlayers.add( name );\n            }\n        }\n        return reportedPlayers;\n    }\n    \n    public static void setTrollMode( Player p , Boolean bol ){\n        PersistentDataContainer PlayerData = p.getPersistentDataContainer( );\n        if ( bol ) {\n            PlayerData.set( new NamespacedKey( plugin , \"troll\" ) , PersistentDataType.STRING , \"troll\" );\n        } else {\n            PlayerData.remove( new NamespacedKey( plugin , \"troll\" ) );\n        }\n    }\n    \n    public static ArrayList < String > getWarnedPlayers( ){\n        return utils.getWarnedPlayers( );\n    }\n    \n    public static Boolean isStillBanned( int Id ){\n        if ( utils.mysqlEnabled( ) )\n            return BansQuery.isStillBanned( Id );\n        try {\n            Date now = new Date( );\n            Date exp_date = new SimpleDateFormat( \"dd-MM-yyyy HH:mm:ss\" ).parse( plugin.bans.getConfig( ).getString( \"bans.\" + Id + \".expdate\" ) );\n            if ( now.after( exp_date ) ) {\n                plugin.bans.getConfig( ).set( \"bans.\" + Id + \".status\" , \"closed\" );\n                plugin.bans.saveConfig( );\n                plugin.bans.reloadConfig( );\n                return false;\n            }\n            return true;\n        } catch ( ParseException | NullPointerException ignored ) {\n            ignored.printStackTrace( );\n            plugin.bans.getConfig( ).set( \"bans.\" + Id + \".status\" , \"closed\" );\n            plugin.bans.saveConfig( );\n            plugin.bans.reloadConfig( );\n            return false;\n        }\n    }\n    \n    public static Boolean isStillWarned( int Id ){\n        if ( utils.mysqlEnabled( ) ) {\n            return WarnsQuery.isStillWarned( Id );\n        }\n        try {\n            Date now = new Date( );\n            Date exp_date = new SimpleDateFormat( \"dd-MM-yyyy HH:mm:ss\" ).parse( plugin.warns.getConfig( ).getString( \"warns.\" + Id + \".expdate\" ) );\n            if ( now.after( exp_date ) ) {\n                plugin.warns.getConfig( ).set( \"warns.\" + Id + \".status\" , \"closed\" );\n                plugin.warns.saveConfig( );\n                plugin.warns.reloadConfig( );\n                return false;\n            }\n            return true;\n        } catch ( ParseException | NullPointerException ignored ) {\n            plugin.warns.getConfig( ).set( \"warns.\" + Id + \".status\" , \"closed\" );\n            plugin.warns.saveConfig( );\n            plugin.warns.reloadConfig( );\n            return false;\n        }\n    }\n    \n    public static void banPlayer( CommandSender sender , String banned , String reason , Long amount , String time ){\n        BanPlayer.BanCooldown( sender , banned , reason , amount , time );\n    }\n    \n    public static void banPlayer( CommandSender sender , String banned , String reason ){\n        BanPlayer.BanPlayer( sender , banned , reason );\n    }\n    \n    public static void warnPlayer( Player player , String warned , String reason , Long amount , String time ){\n        WarnPlayer.createWarn( player , warned , reason , amount , time );\n    }\n    \n    public static void warnPlayer( Player player , String warned , String reason ){\n        WarnPlayer.createWarn( player , warned , reason , utils.getInt( \"warns.expire_after\" , null ) , utils.getString( \"warns.expire_after_quantity\" ) );\n    }\n    \n    public static void muteGlobalChat( ){\n        main.plugin.chatMuted = true;\n    }\n    \n    public static void unMuteGlobalChat( ){\n        main.plugin.chatMuted = false;\n    }\n    \n    public static void mutePlayerChat( CommandSender sender , Player muted ){\n        ToggleChat.MutePlayer( sender , muted );\n    }\n    \n    public static void unMutePlayerChat( CommandSender sender , Player muted ){\n        ToggleChat.unMute( sender , muted );\n    }\n    \n    public static List < String > getVanishedPlayers( ){\n        if ( mysqlEnabled( ) ) {\n            return VanishQuery.getVanishedPlayers( );\n        } else {\n            List < String > vanishedPlayer = new ArrayList <>( );\n            for ( Player p : Bukkit.getOnlinePlayers( ) ) {\n                if ( p.getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"vanished\" ) , PersistentDataType.STRING ) ) {\n                    vanishedPlayer.add( p.getName( ) );\n                }\n            }\n            return vanishedPlayer;\n        }\n    }\n    \n    public static List < String > getStaffPlayers( ){\n        if ( mysqlEnabled( ) ) {\n            return StaffQuery.getStaffPlayers( );\n        } else {\n            List < String > staffPlayer = new ArrayList <>( );\n            for ( Player p : Bukkit.getOnlinePlayers( ) ) {\n                if ( p.getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"staff\" ) , PersistentDataType.STRING ) ) {\n                    staffPlayer.add( p.getName( ) );\n                }\n            }\n            return staffPlayer;\n        }\n    }\n    \n    public static Boolean isOlderVersion( ){\n        return utils.isOlderVersion( );\n    }\n    \n    public static double getTPS( ){\n        return TPS.getTPS( );\n    }\n    \n    public static String getServerVersion( ){\n        return Bukkit.getServer( ).getClass( ).getPackage( ).getName( ).substring( 23 );\n    }\n    \n    public static int getCurrentBans( ){\n        return BanPlayer.currentBans( );\n    }\n    \n    public static int getCurrentWarns( ){\n        if ( mysqlEnabled( ) ) {\n            return WarnsQuery.getCurrentWarns( );\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.warns.getConfig( ).getConfigurationSection( \"warns\" );\n                for ( String key : inventorySection.getKeys( false ) )\n                    current++;\n            } catch ( NullPointerException ignored ) {\n            }\n            return current;\n        }\n    }\n    \n    public static int getCurrentReports( ){\n        if ( mysqlEnabled( ) ) {\n            return ReportsQuery.getCurrentReports( );\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.reports.getConfig( ).getConfigurationSection( \"reports\" );\n                for ( String key : inventorySection.getKeys( false ) )\n                    current++;\n            } catch ( NullPointerException ignored ) {\n            }\n            return current;\n        }\n    }\n    \n    public static String getIp( Player p ){\n        InetAddress address = p.getAddress( ).getAddress( );\n        String ip = address.toString( );\n        ip = ip.replace( \"/\" , \"\" );\n        return ip;\n    }\n    \n    \n}", "class_id": 0, "repo": "TheNumberOne/StaffCore", "file": "src/main/java/cl/bebt/staffcore/API/StaffCoreAPI.java", "last_update_at": "2021-05-02T11:05:13+00:00", "question_id": "856bafe9197904c12be321e8dde1820862f17070", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings({\"unused\"})\npublic class StaffCoreAPI {\n    private static main plugin;\n    public StaffCoreAPI( main plugin ){\n        StaffCoreAPI.plugin = plugin;\n    }\n    public static String getIP( String player ){\n        if ( utils.mysqlEnabled( ) )\n            return AltsQuery.getIp( player );\n        try {\n            return Bukkit.getPlayer( player ).getAddress( ).getAddress( ).toString( );\n        } catch ( NullPointerException error ) {\n            return \"\";\n        }\n    }\n    public static int getPing( String player ){\n        try {\n            return utils.getPing( Bukkit.getPlayer( player ) );\n        } catch ( NullPointerException error ) {\n            return 0;\n        }\n    }\n    public static ArrayList < String > getSavedPlayerList( ){\n        return utils.getUsers( );\n    }\n    public static List < String > getPlayerAlts( String player ){\n        return CheckAlts.alts( player );\n    }\n    public static void clearPlayerChat( Player player ){\n        utils.ccPlayer( player );\n    }\n    public static void clearAllPlayersChat( ){\n        utils.ccAll( );\n    }\n    public static boolean isRegistered( String player ){\n        return utils.isRegistered( player );\n    }\n    public static boolean mysqlEnabled( ){\n        return utils.mysqlEnabled( );\n    }\n    public static boolean getFrozenStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return FreezeQuery.isFrozen( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"frozen\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    public static boolean getVanishedStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return VanishQuery.isVanished( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"vanished\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    public static boolean getStaffStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return StaffQuery.isStaff( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"staff\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    public static boolean getStaffChatStatus( String player ){\n        if ( mysqlEnabled( ) )\n            return StaffChatQuery.isStaffChat( player ).equalsIgnoreCase( \"true\" );\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"staffchat\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    public static boolean getFlyingStatus( String player ){\n        return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"flying\" ) , PersistentDataType.STRING );\n    }\n    public static boolean getTrollStatus( String player ){\n        try {\n            return Bukkit.getPlayer( player ).getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"troll\" ) , PersistentDataType.STRING );\n        } catch ( NullPointerException error ) {\n            return false;\n        }\n    }\n    public static boolean isBanned( String player ){\n        if ( mysqlEnabled( ) )\n            return BansQuery.getBannedPlayers( ).contains( player );\n        List < String > bannedPlayers = new ArrayList <>( );\n        ConfigurationSection bans = plugin.bans.getConfig( ).getConfigurationSection( \"bans\" );\n        for ( String s : bans.getKeys( false ) )\n            bannedPlayers.add( plugin.bans.getConfig( ).getString( \"bans.\" + s + \".name\" ) );\n        return bannedPlayers.contains( player );\n    }\n    public static boolean isWarned( String player ){\n        if ( mysqlEnabled( ) )\n            return WarnsQuery.getWarnedPlayers( ).contains( player );\n        List < String > warnedPlayers = new ArrayList <>( );\n        ConfigurationSection warns = plugin.warns.getConfig( ).getConfigurationSection( \"warns\" );\n        for ( String s : warns.getKeys( false ) )\n            warnedPlayers.add( plugin.warns.getConfig( ).getString( \"warns.\" + s + \".name\" ) );\n        return warnedPlayers.contains( player );\n    }\n    public static void setFrozenStatus( Player target , String sender , boolean status ){\n        FreezePlayer.FreezePlayer( target , sender , status );\n    }\n    public static void setVanishStatus( Player target , boolean status ){\n        SetVanish.setVanish( target , status );\n    }\n    public static void setStaffStatus( Player target , boolean status ){\n        if ( status ) {\n            SetStaffItems.On( target );\n        } else {\n            SetStaffItems.Off( target );\n        }\n    }\n    public static void setStaffChatStatus( Player target , boolean status ){\n        if ( mysqlEnabled( ) ) {\n            if ( status ) {\n                StaffChatQuery.enable( target.getName( ) );\n            } else {\n                StaffChatQuery.disable( target.getName( ) );\n            }\n        } else if ( status ) {\n            target.getPersistentDataContainer( ).set( new NamespacedKey( plugin , \"staffchat\" ) , PersistentDataType.STRING , \"staffchat\" );\n        } else {\n            target.getPersistentDataContainer( ).remove( new NamespacedKey( plugin , \"staffchat\" ) );\n        }\n    }\n    public static void setFlyingStatus( Player target , boolean status ){\n        new SetFly( target , status );\n    }\n    public static ArrayList < String > getBannedPlayers( ){\n        ArrayList < String > bannedPlayers = new ArrayList <>( );\n        if ( utils.mysqlEnabled( ) ) {\n            bannedPlayers.addAll( BansQuery.getBannedPlayers( ) );\n        } else {\n            try {\n                ConfigurationSection inventorySection = plugin.bans.getConfig( ).getConfigurationSection( \"bans\" );\n                for ( String key : inventorySection.getKeys( false ) ) {\n                    String name = plugin.bans.getConfig( ).getString( \"bans.\" + key + \".name\" );\n                    if ( !bannedPlayers.contains( name ) )\n                        bannedPlayers.add( name );\n                }\n            } catch ( NullPointerException ignored ) {\n            }\n        }\n        return bannedPlayers;\n    }\n    public static ArrayList < String > getReportedPlayers( ){\n        ArrayList < String > reportedPlayers = new ArrayList <>( );\n        if ( utils.mysqlEnabled( ) ) {\n            reportedPlayers.addAll( ReportsQuery.getReportedPlayers( ) );\n        } else {\n            ConfigurationSection inventorySection = plugin.reports.getConfig( ).getConfigurationSection( \"reports\" );\n            for ( String key : inventorySection.getKeys( false ) ) {\n                String name = plugin.reports.getConfig( ).getString( \"reports.\" + key + \".name\" );\n                if ( !reportedPlayers.contains( name ) )\n                    reportedPlayers.add( name );\n            }\n        }\n        return reportedPlayers;\n    }\n    public static void setTrollMode( Player p , Boolean bol ){\n        PersistentDataContainer PlayerData = p.getPersistentDataContainer( );\n        if ( bol ) {\n            PlayerData.set( new NamespacedKey( plugin , \"troll\" ) , PersistentDataType.STRING , \"troll\" );\n        } else {\n            PlayerData.remove( new NamespacedKey( plugin , \"troll\" ) );\n        }\n    }\n    public static ArrayList < String > getWarnedPlayers( ){\n        return utils.getWarnedPlayers( );\n    }\n    public static Boolean isStillBanned( int Id ){\n        if ( utils.mysqlEnabled( ) )\n            return BansQuery.isStillBanned( Id );\n        try {\n            Date now = new Date( );\n            Date exp_date = new SimpleDateFormat( \"dd-MM-yyyy HH:mm:ss\" ).parse( plugin.bans.getConfig( ).getString( \"bans.\" + Id + \".expdate\" ) );\n            if ( now.after( exp_date ) ) {\n                plugin.bans.getConfig( ).set( \"bans.\" + Id + \".status\" , \"closed\" );\n                plugin.bans.saveConfig( );\n                plugin.bans.reloadConfig( );\n                return false;\n            }\n            return true;\n        } catch ( ParseException | NullPointerException ignored ) {\n            ignored.printStackTrace( );\n            plugin.bans.getConfig( ).set( \"bans.\" + Id + \".status\" , \"closed\" );\n            plugin.bans.saveConfig( );\n            plugin.bans.reloadConfig( );\n            return false;\n        }\n    }\n    public static Boolean isStillWarned( int Id ){\n        if ( utils.mysqlEnabled( ) ) {\n            return WarnsQuery.isStillWarned( Id );\n        }\n        try {\n            Date now = new Date( );\n            Date exp_date = new SimpleDateFormat( \"dd-MM-yyyy HH:mm:ss\" ).parse( plugin.warns.getConfig( ).getString( \"warns.\" + Id + \".expdate\" ) );\n            if ( now.after( exp_date ) ) {\n                plugin.warns.getConfig( ).set( \"warns.\" + Id + \".status\" , \"closed\" );\n                plugin.warns.saveConfig( );\n                plugin.warns.reloadConfig( );\n                return false;\n            }\n            return true;\n        } catch ( ParseException | NullPointerException ignored ) {\n            plugin.warns.getConfig( ).set( \"warns.\" + Id + \".status\" , \"closed\" );\n            plugin.warns.saveConfig( );\n            plugin.warns.reloadConfig( );\n            return false;\n        }\n    }\n    public static void banPlayer( CommandSender sender , String banned , String reason , Long amount , String time ){\n        BanPlayer.BanCooldown( sender , banned , reason , amount , time );\n    }\n    public static void banPlayer( CommandSender sender , String banned , String reason ){\n        BanPlayer.BanPlayer( sender , banned , reason );\n    }\n    public static void warnPlayer( Player player , String warned , String reason , Long amount , String time ){\n        WarnPlayer.createWarn( player , warned , reason , amount , time );\n    }\n    public static void warnPlayer( Player player , String warned , String reason ){\n        WarnPlayer.createWarn( player , warned , reason , utils.getInt( \"warns.expire_after\" , null ) , utils.getString( \"warns.expire_after_quantity\" ) );\n    }\n    public static void muteGlobalChat( ){\n        main.plugin.chatMuted = true;\n    }\n    public static void unMuteGlobalChat( ){\n        main.plugin.chatMuted = false;\n    }\n    public static void mutePlayerChat( CommandSender sender , Player muted ){\n        ToggleChat.MutePlayer( sender , muted );\n    }\n    public static void unMutePlayerChat( CommandSender sender , Player muted ){\n        ToggleChat.unMute( sender , muted );\n    }\n    public static List < String > getVanishedPlayers( ){\n        if ( mysqlEnabled( ) ) {\n            return VanishQuery.getVanishedPlayers( );\n        } else {\n            List < String > vanishedPlayer = new ArrayList <>( );\n            for ( Player p : Bukkit.getOnlinePlayers( ) ) {\n                if ( p.getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"vanished\" ) , PersistentDataType.STRING ) ) {\n                    vanishedPlayer.add( p.getName( ) );\n                }\n            }\n            return vanishedPlayer;\n        }\n    }\n    public static List < String > getStaffPlayers( ){\n        if ( mysqlEnabled( ) ) {\n            return StaffQuery.getStaffPlayers( );\n        } else {\n            List < String > staffPlayer = new ArrayList <>( );\n            for ( Player p : Bukkit.getOnlinePlayers( ) ) {\n                if ( p.getPersistentDataContainer( ).has( new NamespacedKey( plugin , \"staff\" ) , PersistentDataType.STRING ) ) {\n                    staffPlayer.add( p.getName( ) );\n                }\n            }\n            return staffPlayer;\n        }\n    }\n    public static Boolean isOlderVersion( ){\n        return utils.isOlderVersion( );\n    }\n    public static double getTPS( ){\n        return TPS.getTPS( );\n    }\n    public static String getServerVersion( ){\n        return Bukkit.getServer( ).getClass( ).getPackage( ).getName( ).substring( 23 );\n    }\n    public static int getCurrentBans( ){\n        return BanPlayer.currentBans( );\n    }\n    public static int getCurrentWarns( ){\n        if ( mysqlEnabled( ) ) {\n            return WarnsQuery.getCurrentWarns( );\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.warns.getConfig( ).getConfigurationSection( \"warns\" );\n                for ( String key : inventorySection.getKeys( false ) )\n                    current++;\n            } catch ( NullPointerException ignored ) {\n            }\n            return current;\n        }\n    }\n    public static int getCurrentReports( ){\n        if ( mysqlEnabled( ) ) {\n            return ReportsQuery.getCurrentReports( );\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.reports.getConfig( ).getConfigurationSection( \"reports\" );\n                for ( String key : inventorySection.getKeys( false ) )\n                    current++;\n            } catch ( NullPointerException ignored ) {\n            }\n            return current;\n        }\n    }\n    public static String getIp( Player p ){\n        InetAddress address = p.getAddress( ).getAddress( );\n        String ip = address.toString( );\n        ip = ip.replace( \"/\" , \"\" );\n        return ip;\n    }\n"]]}
{"hexsha": "3aeba7a2e5875d961c7b615ed7f977845a528c34", "ext": "java", "lang": "Java", "content": "@SpringBootApplication\npublic class AgendabotApplication {\n\n  private final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n  private final List<String> SCOPES = Collections.singletonList(CalendarScopes.CALENDAR_READONLY);\n\n  public static void main(String[] args) {\n    SpringApplication.run(AgendabotApplication.class, args);\n  }\n\n  private Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT) throws IOException {\n    String CREDENTIALS_FILE_PATH = \"/credentials.json\";\n    InputStream in = AgendabotApplication.class.getResourceAsStream(CREDENTIALS_FILE_PATH);\n    GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));\n\n    String TOKENS_DIRECTORY_PATH = \"tokens\";\n    GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(\n      HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)\n      .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))\n      .setAccessType(\"offline\")\n      .build();\n    return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize(\"user\");\n  }\n\n  @Bean\n  Calendar getCalendar() throws GeneralSecurityException, IOException {\n    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();\n    String APPLICATION_NAME = \"MyEvent\";\n    return new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))\n      .setApplicationName(APPLICATION_NAME)\n      .build();\n  }\n}", "class_id": 0, "repo": "matfurrier/AgendaBot", "file": "src/main/java/com/zenvia/newhorizon/agendabot/AgendabotApplication.java", "last_update_at": "2021-08-07T00:38:06+00:00", "question_id": "3aeba7a2e5875d961c7b615ed7f977845a528c34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SpringBootApplication\npublic class AgendabotApplication {\n  private final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n  private final List<String> SCOPES = Collections.singletonList(CalendarScopes.CALENDAR_READONLY);\n  public static void main(String[] args) {\n    SpringApplication.run(AgendabotApplication.class, args);\n  }\n  private Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT) throws IOException {\n    String CREDENTIALS_FILE_PATH = \"/credentials.json\";\n    InputStream in = AgendabotApplication.class.getResourceAsStream(CREDENTIALS_FILE_PATH);\n    GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));\n    String TOKENS_DIRECTORY_PATH = \"tokens\";\n    GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(\n      HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)\n      .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))\n      .setAccessType(\"offline\")\n      .build();\n    return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize(\"user\");\n  }\n  @Bean\n  Calendar getCalendar() throws GeneralSecurityException, IOException {\n    NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();\n    String APPLICATION_NAME = \"MyEvent\";\n    return new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT))\n      .setApplicationName(APPLICATION_NAME)\n      .build();\n  }\n"]]}
{"hexsha": "6e26950490701ecf5a24f45ce57289a210764de4", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"unused\")\r\npublic class RawFilesCopier extends BasePagesGenerator {\r\n\r\n    public RawFilesCopier(FoldersConfig foldersConfig) {\r\n        super(foldersConfig);\r\n    }\r\n\r\n    @Override\r\n    protected void generateData() throws IOException {\r\n        var rawFolder = foldersConfig.getTemplateFolder() + \"RAW\";\r\n\r\n        //\u043a\u043e\u0440\u0435\u043d\u044c \u043f\u0430\u043f\u043a\u0438\r\n        var rootFiles = FileHelper.getFilesList(rawFolder);\r\n        for (var file : rootFiles) {\r\n            var outputFolder = foldersConfig.getOutputFolder();\r\n            FileHelper.createFolder(outputFolder);\r\n            FileHelper.copyFile(rawFolder + \"/\" + file,\r\n                    outputFolder + file);\r\n        }\r\n\r\n        //\u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\r\n\r\n        String[] gameDirs = FileHelper.getDirsList(rawFolder);\r\n        for (var dir : gameDirs) {\r\n            var filePath = rawFolder + \"/\" + dir;\r\n            var files = FileHelper.getFilesList(filePath);\r\n            for (var file : files) {\r\n                var outputFolder = foldersConfig.getOutputFolder();\r\n                FileHelper.createFolder(outputFolder + dir);\r\n                FileHelper.copyFile(filePath + \"/\" + file,\r\n                        outputFolder + dir + \"/\" + file);\r\n            }\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "saiks24/GamesRevivalSiteGenerator", "file": "src/main/java/newbilius/GamesRevival/Generators/RawFilesCopier.java", "last_update_at": "2021-11-14T08:04:35+00:00", "question_id": "6e26950490701ecf5a24f45ce57289a210764de4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"unused\")\r\npublic class RawFilesCopier extends BasePagesGenerator {\r\n\r\n    public RawFilesCopier(FoldersConfig foldersConfig) {\r\n        super(foldersConfig);\r\n    }\r\n\r\n    @Override\r\n    protected void generateData() throws IOException {\r\n        var rawFolder = foldersConfig.getTemplateFolder() + \"RAW\";\r\n\r\n        //\u043a\u043e\u0440\u0435\u043d\u044c \u043f\u0430\u043f\u043a\u0438\r\n        var rootFiles = FileHelper.getFilesList(rawFolder);\r\n        for (var file : rootFiles) {\r\n            var outputFolder = foldersConfig.getOutputFolder();\r\n            FileHelper.createFolder(outputFolder);\r\n            FileHelper.copyFile(rawFolder + \"/\" + file,\r\n                    outputFolder + file);\r\n        }\r\n\r\n        //\u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\r\n\r\n        String[] gameDirs = FileHelper.getDirsList(rawFolder);\r\n        for (var dir : gameDirs) {\r\n            var filePath = rawFolder + \"/\" + dir;\r\n            var files = FileHelper.getFilesList(filePath);\r\n            for (var file : files) {\r\n                var outputFolder = foldersConfig.getOutputFolder();\r\n                FileHelper.createFolder(outputFolder + dir);\r\n                FileHelper.copyFile(filePath + \"/\" + file,\r\n                        outputFolder + dir + \"/\" + file);\r\n            }\r\n        }\r\n    }\r\n"]]}
{"hexsha": "e0ea20945f697123219e25bb900d86a4b8cb0fbb", "ext": "java", "lang": "Java", "content": "public class Facade {\n\tprivate SubSystemOne subSystemOne;\n\tprivate SubSystemTwo subSystemTwo;\n\tprivate SubSystemThree subSystemThree;\n\tprivate SubSystemFour subSystemFour;\n\n\tpublic Facade() {\n\t\tsubSystemOne = new SubSystemOne();\n\t\tsubSystemTwo = new SubSystemTwo();\n\t\tsubSystemThree = new SubSystemThree();\n\t\tsubSystemFour = new SubSystemFour();\n\t}\n\n\tpublic void methodA() {\n\t\tsubSystemOne.methodOne();\n\t\tsubSystemTwo.methodOne();\n\t\tsubSystemThree.methodOne();\n\t}\n\n\tpublic void methodB() {\n\t\tsubSystemTwo.methodOne();\n\t\tsubSystemThree.methodOne();\n\t\tsubSystemFour.methodOne();\n\t}\n}", "class_id": 0, "repo": "DongjianPeng/PatternDesign", "file": "src/main/java/structure/facade/structure/Facade.java", "last_update_at": "2021-05-26T06:51:53+00:00", "question_id": "e0ea20945f697123219e25bb900d86a4b8cb0fbb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Facade {\n\tprivate SubSystemOne subSystemOne;\n\tprivate SubSystemTwo subSystemTwo;\n\tprivate SubSystemThree subSystemThree;\n\tprivate SubSystemFour subSystemFour;\n\tpublic Facade() {\n\t\tsubSystemOne = new SubSystemOne();\n\t\tsubSystemTwo = new SubSystemTwo();\n\t\tsubSystemThree = new SubSystemThree();\n\t\tsubSystemFour = new SubSystemFour();\n\t}\n\tpublic void methodA() {\n\t\tsubSystemOne.methodOne();\n\t\tsubSystemTwo.methodOne();\n\t\tsubSystemThree.methodOne();\n\t}\n\tpublic void methodB() {\n\t\tsubSystemTwo.methodOne();\n\t\tsubSystemThree.methodOne();\n\t\tsubSystemFour.methodOne();\n\t}\n"]]}
{"hexsha": "d0e08467a50a8d3f84bbbe7b3bd74b5a35347772", "ext": "java", "lang": "Java", "content": "public class ManageProjectFeatures extends SecureScreen {\r\n\t@Override\r\n\tprotected void doBuildTemplate(RunData data, Context context) throws Exception {\r\n        final Object projects = TurbineUtils.GetPassedParameter(\"projects\", data);\r\n        if (projects != null) {\r\n            context.put(\"project\", projects);\r\n        } else {\r\n            context.put(\"project\", TurbineUtils.GetPassedParameter(\"project\", data));\r\n        }\r\n        context.put(\"features\", Features.getAllFeatures());\r\n\t}\r\n}", "class_id": 0, "repo": "student-t/Xnat", "file": "src/main/java/org/nrg/xnat/turbine/modules/screens/ManageProjectFeatures.java", "last_update_at": "2021-01-19T19:55:55+00:00", "question_id": "d0e08467a50a8d3f84bbbe7b3bd74b5a35347772", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ManageProjectFeatures extends SecureScreen {\r\n\t@Override\r\n\tprotected void doBuildTemplate(RunData data, Context context) throws Exception {\r\n        final Object projects = TurbineUtils.GetPassedParameter(\"projects\", data);\r\n        if (projects != null) {\r\n            context.put(\"project\", projects);\r\n        } else {\r\n            context.put(\"project\", TurbineUtils.GetPassedParameter(\"project\", data));\r\n        }\r\n        context.put(\"features\", Features.getAllFeatures());\r\n\t}\r\n"]]}
{"hexsha": "4df8a27f0598864bd98f434816cd53ecd56f674f", "ext": "java", "lang": "Java", "content": "public final class EndpointId {\n\n\tprivate static final Log logger = LogFactory.getLog(EndpointId.class);\n\n\tprivate static final Set<String> loggedWarnings = new HashSet<>();\n\n\tprivate static final Pattern VALID_PATTERN = Pattern.compile(\"[a-zA-Z0-9\\\\.\\\\-]+\");\n\n\tprivate static final Pattern WARNING_PATTERN = Pattern.compile(\"[\\\\.\\\\-]+\");\n\n\tprivate static final String MIGRATE_LEGACY_NAMES_PROPRTY = \"management.endpoints.migrate-legacy-ids\";\n\n\tprivate final String value;\n\n\tprivate final String lowerCaseValue;\n\n\tprivate final String lowerCaseAlphaNumeric;\n\n\tprivate EndpointId(String value) {\n\t\tAssert.hasText(value, \"Value must not be empty\");\n\t\tAssert.isTrue(VALID_PATTERN.matcher(value).matches(), \"Value must only contain valid chars\");\n\t\tAssert.isTrue(!Character.isDigit(value.charAt(0)), \"Value must not start with a number\");\n\t\tAssert.isTrue(!Character.isUpperCase(value.charAt(0)), \"Value must not start with an uppercase letter\");\n\t\tif (WARNING_PATTERN.matcher(value).find()) {\n\t\t\tlogWarning(value);\n\t\t}\n\t\tthis.value = value;\n\t\tthis.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);\n\t\tthis.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);\n\t}\n\n\tprivate String getAlphaNumerics(String value) {\n\t\tStringBuilder result = new StringBuilder(value.length());\n\t\tfor (int i = 0; i < value.length(); i++) {\n\t\t\tchar ch = value.charAt(i);\n\t\t\tif (ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9') {\n\t\t\t\tresult.append(ch);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null || getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.lowerCaseAlphaNumeric.hashCode();\n\t}\n\n\t/**\n\t * Return a lower-case version of the endpoint ID.\n\t * @return the lower-case endpoint ID\n\t */\n\tpublic String toLowerCaseString() {\n\t\treturn this.lowerCaseValue;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.value;\n\t}\n\n\t/**\n\t * Factory method to create a new {@link EndpointId} of the specified value.\n\t * @param value the endpoint ID value\n\t * @return an {@link EndpointId} instance\n\t */\n\tpublic static EndpointId of(String value) {\n\t\treturn new EndpointId(value);\n\t}\n\n\t/**\n\t * Factory method to create a new {@link EndpointId} of the specified value. This\n\t * variant will respect the {@code management.endpoints.migrate-legacy-names} property\n\t * if it has been set in the {@link Environment}.\n\t * @param environment the Spring environment\n\t * @param value the endpoint ID value\n\t * @return an {@link EndpointId} instance\n\t * @since 2.2.0\n\t */\n\tpublic static EndpointId of(Environment environment, String value) {\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\treturn new EndpointId(migrateLegacyId(environment, value));\n\t}\n\n\tprivate static String migrateLegacyId(Environment environment, String value) {\n\t\tif (environment.getProperty(MIGRATE_LEGACY_NAMES_PROPRTY, Boolean.class, false)) {\n\t\t\treturn value.replace(\".\", \"\");\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Factory method to create a new {@link EndpointId} from a property value. More\n\t * lenient than {@link #of(String)} to allow for common \"relaxed\" property variants.\n\t * @param value the property value to convert\n\t * @return an {@link EndpointId} instance\n\t */\n\tpublic static EndpointId fromPropertyValue(String value) {\n\t\treturn new EndpointId(value.replace(\"-\", \"\"));\n\t}\n\n\tstatic void resetLoggedWarnings() {\n\t\tloggedWarnings.clear();\n\t}\n\n\tprivate static void logWarning(String value) {\n\t\tif (logger.isWarnEnabled() && loggedWarnings.add(value)) {\n\t\t\tlogger.warn(\"Endpoint ID '\" + value + \"' contains invalid characters, please migrate to a valid format.\");\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "clove506/spring-boot", "file": "spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/EndpointId.java", "last_update_at": "2021-03-02T12:02:19+00:00", "question_id": "4df8a27f0598864bd98f434816cd53ecd56f674f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class EndpointId {\n\tprivate static final Log logger = LogFactory.getLog(EndpointId.class);\n\tprivate static final Set<String> loggedWarnings = new HashSet<>();\n\tprivate static final Pattern VALID_PATTERN = Pattern.compile(\"[a-zA-Z0-9\\\\.\\\\-]+\");\n\tprivate static final Pattern WARNING_PATTERN = Pattern.compile(\"[\\\\.\\\\-]+\");\n\tprivate static final String MIGRATE_LEGACY_NAMES_PROPRTY = \"management.endpoints.migrate-legacy-ids\";\n\tprivate final String value;\n\tprivate final String lowerCaseValue;\n\tprivate final String lowerCaseAlphaNumeric;\n\tprivate EndpointId(String value) {\n\t\tAssert.hasText(value, \"Value must not be empty\");\n\t\tAssert.isTrue(VALID_PATTERN.matcher(value).matches(), \"Value must only contain valid chars\");\n\t\tAssert.isTrue(!Character.isDigit(value.charAt(0)), \"Value must not start with a number\");\n\t\tAssert.isTrue(!Character.isUpperCase(value.charAt(0)), \"Value must not start with an uppercase letter\");\n\t\tif (WARNING_PATTERN.matcher(value).find()) {\n\t\t\tlogWarning(value);\n\t\t}\n\t\tthis.value = value;\n\t\tthis.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);\n\t\tthis.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);\n\t}\n\tprivate String getAlphaNumerics(String value) {\n\t\tStringBuilder result = new StringBuilder(value.length());\n\t\tfor (int i = 0; i < value.length(); i++) {\n\t\t\tchar ch = value.charAt(i);\n\t\t\tif (ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9') {\n\t\t\t\tresult.append(ch);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null || getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.lowerCaseAlphaNumeric.hashCode();\n\t}\n\t/**\n\t * Return a lower-case version of the endpoint ID.\n\t * @return the lower-case endpoint ID\n\t */\n\tpublic String toLowerCaseString() {\n\t\treturn this.lowerCaseValue;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn this.value;\n\t}\n\t/**\n\t * Factory method to create a new {@link EndpointId} of the specified value.\n\t * @param value the endpoint ID value\n\t * @return an {@link EndpointId} instance\n\t */\n\tpublic static EndpointId of(String value) {\n\t\treturn new EndpointId(value);\n\t}\n\t/**\n\t * Factory method to create a new {@link EndpointId} of the specified value. This\n\t * variant will respect the {@code management.endpoints.migrate-legacy-names} property\n\t * if it has been set in the {@link Environment}.\n\t * @param environment the Spring environment\n\t * @param value the endpoint ID value\n\t * @return an {@link EndpointId} instance\n\t * @since 2.2.0\n\t */\n\tpublic static EndpointId of(Environment environment, String value) {\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\treturn new EndpointId(migrateLegacyId(environment, value));\n\t}\n\tprivate static String migrateLegacyId(Environment environment, String value) {\n\t\tif (environment.getProperty(MIGRATE_LEGACY_NAMES_PROPRTY, Boolean.class, false)) {\n\t\t\treturn value.replace(\".\", \"\");\n\t\t}\n\t\treturn value;\n\t}\n\t/**\n\t * Factory method to create a new {@link EndpointId} from a property value. More\n\t * lenient than {@link #of(String)} to allow for common \"relaxed\" property variants.\n\t * @param value the property value to convert\n\t * @return an {@link EndpointId} instance\n\t */\n\tpublic static EndpointId fromPropertyValue(String value) {\n\t\treturn new EndpointId(value.replace(\"-\", \"\"));\n\t}\n\tstatic void resetLoggedWarnings() {\n\t\tloggedWarnings.clear();\n\t}\n\tprivate static void logWarning(String value) {\n\t\tif (logger.isWarnEnabled() && loggedWarnings.add(value)) {\n\t\t\tlogger.warn(\"Endpoint ID '\" + value + \"' contains invalid characters, please migrate to a valid format.\");\n\t\t}\n\t}\n"]]}
{"hexsha": "02ba5c430b56fa53c25a4d0f7607776b7d2fa8fe", "ext": "java", "lang": "Java", "content": "@RunWith(ConcurrentJunitRunner.class)\n@Concurrent()\npublic class CheckPasswordPolicyTest\n{\n    private static final int passwordLength = 6;\n    private static final int categoryCount = 3;\n    private static final int tokenSize = 3;\n\n    private static final CheckPasswordPolicy policy = new CheckPasswordPolicy();\n\n\n    /**\n     * Tests that a good password is valid according to all policy checks.\n     */\n    @Test\n    public void testGoodPassword()\n    {\n        String username = \"Enrique Rodriguez\";\n        String password = \"d1r3ct0rY\";\n        assertTrue( policy.isValidPasswordLength( password, passwordLength ) );\n        assertTrue( policy.isValidCategoryCount( password, categoryCount ) );\n        assertTrue( policy.isValidUsernameSubstring( username, password, tokenSize ) );\n        assertTrue( policy.isValid( username, password, passwordLength, categoryCount, tokenSize ) );\n    }\n\n\n    /**\n     * Tests that a bad password fails all validity checks.\n     */\n    @Test\n    public void testBadPassword()\n    {\n        String username = \"Erin Randall\";\n        String password = \"erin1\";\n        assertFalse( policy.isValidPasswordLength( password, passwordLength ) );\n        assertFalse( policy.isValidCategoryCount( password, categoryCount ) );\n        assertFalse( policy.isValidUsernameSubstring( username, password, tokenSize ) );\n        assertFalse( policy.isValid( username, password, passwordLength, categoryCount, tokenSize ) );\n    }\n\n\n    /**\n     * Tests variations of a password where the password includes tokens of the username.\n     */\n    @Test\n    public void testPrincipalAsUsername()\n    {\n        String username = new KerberosPrincipal( \"erodriguez@EXAMPLE.COM\" ).getName();\n        String password1 = \"d1r3ct0rY\";\n        String password2 = \"ERodriguez@d1r3ct0rY\";\n        String password3 = \"Example@d1r3ct0rY\";\n\n        assertTrue( policy.isValidUsernameSubstring( username, password1, tokenSize ) );\n\n        assertFalse( policy.isValidUsernameSubstring( username, password2, tokenSize ) );\n        assertFalse( policy.isValidUsernameSubstring( username, password3, tokenSize ) );\n    }\n}", "class_id": 0, "repo": "senthalan/directory-server", "file": "protocol-changepw/src/test/java/org/apache/directory/server/changepw/service/CheckPasswordPolicyTest.java", "last_update_at": "2021-02-23T13:28:38+00:00", "question_id": "02ba5c430b56fa53c25a4d0f7607776b7d2fa8fe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(ConcurrentJunitRunner.class)\n@Concurrent()\npublic class CheckPasswordPolicyTest\n{\n    private static final int passwordLength = 6;\n    private static final int categoryCount = 3;\n    private static final int tokenSize = 3;\n    private static final CheckPasswordPolicy policy = new CheckPasswordPolicy();\n    /**\n     * Tests that a good password is valid according to all policy checks.\n     */\n    @Test\n    public void testGoodPassword()\n    {\n        String username = \"Enrique Rodriguez\";\n        String password = \"d1r3ct0rY\";\n        assertTrue( policy.isValidPasswordLength( password, passwordLength ) );\n        assertTrue( policy.isValidCategoryCount( password, categoryCount ) );\n        assertTrue( policy.isValidUsernameSubstring( username, password, tokenSize ) );\n        assertTrue( policy.isValid( username, password, passwordLength, categoryCount, tokenSize ) );\n    }\n    /**\n     * Tests that a bad password fails all validity checks.\n     */\n    @Test\n    public void testBadPassword()\n    {\n        String username = \"Erin Randall\";\n        String password = \"erin1\";\n        assertFalse( policy.isValidPasswordLength( password, passwordLength ) );\n        assertFalse( policy.isValidCategoryCount( password, categoryCount ) );\n        assertFalse( policy.isValidUsernameSubstring( username, password, tokenSize ) );\n        assertFalse( policy.isValid( username, password, passwordLength, categoryCount, tokenSize ) );\n    }\n    /**\n     * Tests variations of a password where the password includes tokens of the username.\n     */\n    @Test\n    public void testPrincipalAsUsername()\n    {\n        String username = new KerberosPrincipal( \"erodriguez@EXAMPLE.COM\" ).getName();\n        String password1 = \"d1r3ct0rY\";\n        String password2 = \"ERodriguez@d1r3ct0rY\";\n        String password3 = \"Example@d1r3ct0rY\";\n        assertTrue( policy.isValidUsernameSubstring( username, password1, tokenSize ) );\n        assertFalse( policy.isValidUsernameSubstring( username, password2, tokenSize ) );\n        assertFalse( policy.isValidUsernameSubstring( username, password3, tokenSize ) );\n    }\n"]]}
{"hexsha": "72ae39170a00e26a90f4a2eecfcf893492a74a15", "ext": "java", "lang": "Java", "content": "@OnStop\n@Messages({\n    \"# {0} - autosave id\",\n    \"MSG_CleanedUp=Cleaned up autosave {0}\"\n})\npublic final class AutosaveStop implements Runnable {\n\n    private static final Logger LOGGER = Logger.getLogger(AutosaveStop.class.getName());\n\n    @Override\n    public void run() {\n        final Map<String, Graph> graphs = GraphNode.getAllGraphs();\n        for (final Map.Entry<String, Graph> entry : graphs.entrySet()) {\n            final Graph graph = entry.getValue();\n            AutosaveUtilities.deleteAutosave(graph.getId());\n            LOGGER.info(Bundle.MSG_CleanedUp(graph.getId()));\n        }\n\n        AutosaveUtilities.cleanup();\n    }\n}", "class_id": 0, "repo": "aldebaran30701/constellation", "file": "CoreInteractiveGraph/src/au/gov/asd/tac/constellation/graph/interaction/plugins/io/AutosaveStop.java", "last_update_at": "2021-03-22T04:32:17+00:00", "question_id": "72ae39170a00e26a90f4a2eecfcf893492a74a15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@OnStop\n@Messages({\n    \"# {0} - autosave id\",\n    \"MSG_CleanedUp=Cleaned up autosave {0}\"\n})\npublic final class AutosaveStop implements Runnable {\n    private static final Logger LOGGER = Logger.getLogger(AutosaveStop.class.getName());\n    @Override\n    public void run() {\n        final Map<String, Graph> graphs = GraphNode.getAllGraphs();\n        for (final Map.Entry<String, Graph> entry : graphs.entrySet()) {\n            final Graph graph = entry.getValue();\n            AutosaveUtilities.deleteAutosave(graph.getId());\n            LOGGER.info(Bundle.MSG_CleanedUp(graph.getId()));\n        }\n        AutosaveUtilities.cleanup();\n    }\n"]]}
{"hexsha": "60102b23cb71fa0a9064c2d93835462b9f29e26f", "ext": "java", "lang": "Java", "content": "public class ZipHelper {\r\n\r\n    /**\r\n     * To zip a set of files or directories to an archive:\r\n     */\r\n    public static void zipit(String sourcePath, String targetPath) throws IOException {\r\n\r\n        FileOutputStream fos = new FileOutputStream(targetPath);\r\n        ZipOutputStream zipOut = new ZipOutputStream(fos);\r\n\r\n        File fileToZip = new File(sourcePath);\r\n\r\n        zip(fileToZip, fileToZip.getName(), zipOut);\r\n        zipOut.close();\r\n        fos.close();\r\n    }\r\n\r\n    /**\r\n     * To unzip an archive to a target directory\r\n     */\r\n    public static void unzipit(String sourcePath, String targetPath) throws IOException {\r\n\r\n        File dir = new File(targetPath);\r\n        if (!dir.exists()) dir.mkdirs();\r\n\r\n        FileInputStream fis = new FileInputStream(sourcePath);\r\n        ZipInputStream zipIn = new ZipInputStream(fis);\r\n\r\n        unzip(targetPath, zipIn);\r\n        zipIn.close();\r\n        fis.close();\r\n    }\r\n\r\n    private static void zip(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {\r\n\r\n        if (fileToZip.isHidden()) {\r\n            return;\r\n        }\r\n        if (fileToZip.isDirectory()) {\r\n            File[] files = fileToZip.listFiles();\r\n            for (File file : files) {\r\n                zip(file, fileName + \"/\" + file.getName(), zipOut);\r\n            }\r\n            return;\r\n        }\r\n        FileInputStream fis = new FileInputStream(fileToZip);\r\n        ZipEntry zipEntry = new ZipEntry(fileName);\r\n        zipOut.putNextEntry(zipEntry);\r\n        byte[] bytes = new byte[1024];\r\n        int length;\r\n        while ((length = fis.read(bytes)) >= 0) {\r\n            zipOut.write(bytes, 0, length);\r\n        }\r\n        fis.close();\r\n    }\r\n\r\n    private static void unzip(String targetPath, ZipInputStream zipIn) {\r\n\r\n        //buffer for read and write data to file\r\n        byte[] buffer = new byte[1024];\r\n        try {\r\n            ZipEntry ze = zipIn.getNextEntry();\r\n            while (ze != null) {\r\n                String fileName = ze.getName();\r\n                File newFile = new File(targetPath + File.separator + fileName);\r\n                new File(newFile.getParent()).mkdirs();\r\n                FileOutputStream fos = new FileOutputStream(newFile);\r\n                int len;\r\n                while ((len = zipIn.read(buffer)) > 0) {\r\n                    fos.write(buffer, 0, len);\r\n                }\r\n                fos.close();\r\n                //close this ZipEntry\r\n                zipIn.closeEntry();\r\n                ze = zipIn.getNextEntry();\r\n            }\r\n            //close last ZipEntry\r\n            zipIn.closeEntry();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n}", "class_id": 0, "repo": "yash-rustagi/atom", "file": "sample-selenium/src/test/java/automation/library/common/ZipHelper.java", "last_update_at": "2021-12-30T18:09:01+00:00", "question_id": "60102b23cb71fa0a9064c2d93835462b9f29e26f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ZipHelper {\r\n\r\n    /**\r\n     * To zip a set of files or directories to an archive:\r\n     */\r\n    public static void zipit(String sourcePath, String targetPath) throws IOException {\r\n\r\n        FileOutputStream fos = new FileOutputStream(targetPath);\r\n        ZipOutputStream zipOut = new ZipOutputStream(fos);\r\n\r\n        File fileToZip = new File(sourcePath);\r\n\r\n        zip(fileToZip, fileToZip.getName(), zipOut);\r\n        zipOut.close();\r\n        fos.close();\r\n    }\r\n\r\n    /**\r\n     * To unzip an archive to a target directory\r\n     */\r\n    public static void unzipit(String sourcePath, String targetPath) throws IOException {\r\n\r\n        File dir = new File(targetPath);\r\n        if (!dir.exists()) dir.mkdirs();\r\n\r\n        FileInputStream fis = new FileInputStream(sourcePath);\r\n        ZipInputStream zipIn = new ZipInputStream(fis);\r\n\r\n        unzip(targetPath, zipIn);\r\n        zipIn.close();\r\n        fis.close();\r\n    }\r\n\r\n    private static void zip(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {\r\n\r\n        if (fileToZip.isHidden()) {\r\n            return;\r\n        }\r\n        if (fileToZip.isDirectory()) {\r\n            File[] files = fileToZip.listFiles();\r\n            for (File file : files) {\r\n                zip(file, fileName + \"/\" + file.getName(), zipOut);\r\n            }\r\n            return;\r\n        }\r\n        FileInputStream fis = new FileInputStream(fileToZip);\r\n        ZipEntry zipEntry = new ZipEntry(fileName);\r\n        zipOut.putNextEntry(zipEntry);\r\n        byte[] bytes = new byte[1024];\r\n        int length;\r\n        while ((length = fis.read(bytes)) >= 0) {\r\n            zipOut.write(bytes, 0, length);\r\n        }\r\n        fis.close();\r\n    }\r\n\r\n    private static void unzip(String targetPath, ZipInputStream zipIn) {\r\n\r\n        //buffer for read and write data to file\r\n        byte[] buffer = new byte[1024];\r\n        try {\r\n            ZipEntry ze = zipIn.getNextEntry();\r\n            while (ze != null) {\r\n                String fileName = ze.getName();\r\n                File newFile = new File(targetPath + File.separator + fileName);\r\n                new File(newFile.getParent()).mkdirs();\r\n                FileOutputStream fos = new FileOutputStream(newFile);\r\n                int len;\r\n                while ((len = zipIn.read(buffer)) > 0) {\r\n                    fos.write(buffer, 0, len);\r\n                }\r\n                fos.close();\r\n                //close this ZipEntry\r\n                zipIn.closeEntry();\r\n                ze = zipIn.getNextEntry();\r\n            }\r\n            //close last ZipEntry\r\n            zipIn.closeEntry();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n"]]}
{"hexsha": "673ab9412635a6e9d321e08447e1e08c0938e832", "ext": "java", "lang": "Java", "content": "public class DistributorModule extends SenderModule2 {\n\n    private static final TintColor TINT_COLOR = new TintColor(240, 240, 60);\n\n    public DistributorModule() {\n        super(CompiledDistributorModule::new);\n    }\n\n    @Override\n    public void addSettingsInformation(ItemStack itemstack, List<ITextComponent> list) {\n        super.addSettingsInformation(itemstack, list);\n\n        CompiledDistributorModule cdm = new CompiledDistributorModule(null, itemstack);\n        list.add(ClientUtil.xlate(\"modularrouters.guiText.tooltip.distributor.strategy\").append(\": \").withStyle(TextFormatting.YELLOW)\n                .append(ClientUtil.xlate(cdm.getDistributionStrategy().getTranslationKey())).withStyle(TextFormatting.AQUA));\n        list.add(ClientUtil.xlate(\"modularrouters.itemText.fluid.direction.\" + (cdm.isPulling() ? \"IN\" : \"OUT\")).withStyle(TextFormatting.YELLOW));\n    }\n\n    @Override\n    public ContainerType<? extends ContainerModule> getContainerType() {\n        return ModContainerTypes.CONTAINER_MODULE_DISTRIBUTOR.get();\n    }\n\n    @Override\n    public List<ModuleTarget> getStoredPositions(@Nonnull ItemStack stack) {\n        return ImmutableList.copyOf(TargetedModule.getTargets(stack, false));\n    }\n\n    @Override\n    public TintColor getItemTint() {\n        return TINT_COLOR;\n    }\n\n    @Override\n    protected int getMaxTargets() {\n        return 8;\n    }\n\n    @Override\n    public int getRenderColor(int index) {\n        return 0x80B0FF90;\n    }\n\n    @Override\n    public int getEnergyCost(ItemStack stack) {\n        return MRConfig.Common.EnergyCosts.distributorModuleEnergyCost;\n    }\n}", "class_id": 0, "repo": "misny/ModularRouters", "file": "src/main/java/me/desht/modularrouters/item/module/DistributorModule.java", "last_update_at": "2021-10-17T13:37:38+00:00", "question_id": "673ab9412635a6e9d321e08447e1e08c0938e832", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DistributorModule extends SenderModule2 {\n    private static final TintColor TINT_COLOR = new TintColor(240, 240, 60);\n    public DistributorModule() {\n        super(CompiledDistributorModule::new);\n    }\n    @Override\n    public void addSettingsInformation(ItemStack itemstack, List<ITextComponent> list) {\n        super.addSettingsInformation(itemstack, list);\n        CompiledDistributorModule cdm = new CompiledDistributorModule(null, itemstack);\n        list.add(ClientUtil.xlate(\"modularrouters.guiText.tooltip.distributor.strategy\").append(\": \").withStyle(TextFormatting.YELLOW)\n                .append(ClientUtil.xlate(cdm.getDistributionStrategy().getTranslationKey())).withStyle(TextFormatting.AQUA));\n        list.add(ClientUtil.xlate(\"modularrouters.itemText.fluid.direction.\" + (cdm.isPulling() ? \"IN\" : \"OUT\")).withStyle(TextFormatting.YELLOW));\n    }\n    @Override\n    public ContainerType<? extends ContainerModule> getContainerType() {\n        return ModContainerTypes.CONTAINER_MODULE_DISTRIBUTOR.get();\n    }\n    @Override\n    public List<ModuleTarget> getStoredPositions(@Nonnull ItemStack stack) {\n        return ImmutableList.copyOf(TargetedModule.getTargets(stack, false));\n    }\n    @Override\n    public TintColor getItemTint() {\n        return TINT_COLOR;\n    }\n    @Override\n    protected int getMaxTargets() {\n        return 8;\n    }\n    @Override\n    public int getRenderColor(int index) {\n        return 0x80B0FF90;\n    }\n    @Override\n    public int getEnergyCost(ItemStack stack) {\n        return MRConfig.Common.EnergyCosts.distributorModuleEnergyCost;\n    }\n"]]}
{"hexsha": "2015410f2622e7d62890cc961ff627e53cdbb9db", "ext": "java", "lang": "Java", "content": "public class AlertRuleRequest {\n  @JsonProperty(\"aggregationPeriod\")\n  private String aggregationPeriod = null;\n\n  /**\n   * Gets or Sets aggregationType\n   */\n  public enum AggregationTypeEnum {\n    COUNT(\"COUNT\"),\n    \n    AVG(\"AVG\"),\n    \n    SUM(\"SUM\"),\n    \n    MAX(\"MAX\"),\n    \n    MIN(\"MIN\");\n\n    private String value;\n\n    AggregationTypeEnum(String value) {\n      this.value = value;\n    }\n\n    @JsonValue\n    public String getValue() {\n      return value;\n    }\n\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n\n    @JsonCreator\n    public static AggregationTypeEnum fromValue(String text) {\n      for (AggregationTypeEnum b : AggregationTypeEnum.values()) {\n        if (String.valueOf(b.value).equals(text)) {\n          return b;\n        }\n      }\n      return null;\n    }\n  }\n\n  @JsonProperty(\"aggregationType\")\n  private AggregationTypeEnum aggregationType = null;\n\n  @JsonProperty(\"alertDestinationIds\")\n  private List<UUID> alertDestinationIds = null;\n\n  @JsonProperty(\"applicationIds\")\n  private List<UUID> applicationIds = null;\n\n  @JsonProperty(\"enabled\")\n  private Boolean enabled = null;\n\n  @JsonProperty(\"filterBy\")\n  private String filterBy = null;\n\n  @JsonProperty(\"groupByField\")\n  private String groupByField = null;\n\n  @JsonProperty(\"name\")\n  private String name = null;\n\n  @JsonProperty(\"riskLevel\")\n  private Integer riskLevel = null;\n\n  @JsonProperty(\"searchPeriod\")\n  private String searchPeriod = null;\n\n  @JsonProperty(\"tags\")\n  private List<String> tags = null;\n\n  /**\n   * Gets or Sets thresholdType\n   */\n  public enum ThresholdTypeEnum {\n    ABOVE(\"ABOVE\"),\n    \n    BELOW(\"BELOW\"),\n    \n    BOTH(\"BOTH\");\n\n    private String value;\n\n    ThresholdTypeEnum(String value) {\n      this.value = value;\n    }\n\n    @JsonValue\n    public String getValue() {\n      return value;\n    }\n\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n\n    @JsonCreator\n    public static ThresholdTypeEnum fromValue(String text) {\n      for (ThresholdTypeEnum b : ThresholdTypeEnum.values()) {\n        if (String.valueOf(b.value).equals(text)) {\n          return b;\n        }\n      }\n      return null;\n    }\n  }\n\n  @JsonProperty(\"thresholdType\")\n  private ThresholdTypeEnum thresholdType = null;\n\n  @JsonProperty(\"thresholdValue\")\n  private Double thresholdValue = null;\n\n  /**\n   * Gets or Sets type\n   */\n  public enum TypeEnum {\n    ST_DEV(\"ST_DEV\"),\n    \n    MEAN(\"MEAN\"),\n    \n    FIXED(\"FIXED\");\n\n    private String value;\n\n    TypeEnum(String value) {\n      this.value = value;\n    }\n\n    @JsonValue\n    public String getValue() {\n      return value;\n    }\n\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n\n    @JsonCreator\n    public static TypeEnum fromValue(String text) {\n      for (TypeEnum b : TypeEnum.values()) {\n        if (String.valueOf(b.value).equals(text)) {\n          return b;\n        }\n      }\n      return null;\n    }\n  }\n\n  @JsonProperty(\"type\")\n  private TypeEnum type = null;\n\n  public AlertRuleRequest aggregationPeriod(String aggregationPeriod) {\n    this.aggregationPeriod = aggregationPeriod;\n    return this;\n  }\n\n   /**\n   * Get aggregationPeriod\n   * @return aggregationPeriod\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getAggregationPeriod() {\n    return aggregationPeriod;\n  }\n\n  public void setAggregationPeriod(String aggregationPeriod) {\n    this.aggregationPeriod = aggregationPeriod;\n  }\n\n  public AlertRuleRequest aggregationType(AggregationTypeEnum aggregationType) {\n    this.aggregationType = aggregationType;\n    return this;\n  }\n\n   /**\n   * Get aggregationType\n   * @return aggregationType\n  **/\n  @ApiModelProperty(value = \"\")\n  public AggregationTypeEnum getAggregationType() {\n    return aggregationType;\n  }\n\n  public void setAggregationType(AggregationTypeEnum aggregationType) {\n    this.aggregationType = aggregationType;\n  }\n\n  public AlertRuleRequest alertDestinationIds(List<UUID> alertDestinationIds) {\n    this.alertDestinationIds = alertDestinationIds;\n    return this;\n  }\n\n  public AlertRuleRequest addAlertDestinationIdsItem(UUID alertDestinationIdsItem) {\n    if (this.alertDestinationIds == null) {\n      this.alertDestinationIds = new ArrayList<>();\n    }\n    this.alertDestinationIds.add(alertDestinationIdsItem);\n    return this;\n  }\n\n   /**\n   * Get alertDestinationIds\n   * @return alertDestinationIds\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<UUID> getAlertDestinationIds() {\n    return alertDestinationIds;\n  }\n\n  public void setAlertDestinationIds(List<UUID> alertDestinationIds) {\n    this.alertDestinationIds = alertDestinationIds;\n  }\n\n  public AlertRuleRequest applicationIds(List<UUID> applicationIds) {\n    this.applicationIds = applicationIds;\n    return this;\n  }\n\n  public AlertRuleRequest addApplicationIdsItem(UUID applicationIdsItem) {\n    if (this.applicationIds == null) {\n      this.applicationIds = new ArrayList<>();\n    }\n    this.applicationIds.add(applicationIdsItem);\n    return this;\n  }\n\n   /**\n   * Get applicationIds\n   * @return applicationIds\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<UUID> getApplicationIds() {\n    return applicationIds;\n  }\n\n  public void setApplicationIds(List<UUID> applicationIds) {\n    this.applicationIds = applicationIds;\n  }\n\n  public AlertRuleRequest enabled(Boolean enabled) {\n    this.enabled = enabled;\n    return this;\n  }\n\n   /**\n   * Get enabled\n   * @return enabled\n  **/\n  @ApiModelProperty(value = \"\")\n  public Boolean isEnabled() {\n    return enabled;\n  }\n\n  public void setEnabled(Boolean enabled) {\n    this.enabled = enabled;\n  }\n\n  public AlertRuleRequest filterBy(String filterBy) {\n    this.filterBy = filterBy;\n    return this;\n  }\n\n   /**\n   * Get filterBy\n   * @return filterBy\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getFilterBy() {\n    return filterBy;\n  }\n\n  public void setFilterBy(String filterBy) {\n    this.filterBy = filterBy;\n  }\n\n  public AlertRuleRequest groupByField(String groupByField) {\n    this.groupByField = groupByField;\n    return this;\n  }\n\n   /**\n   * Get groupByField\n   * @return groupByField\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getGroupByField() {\n    return groupByField;\n  }\n\n  public void setGroupByField(String groupByField) {\n    this.groupByField = groupByField;\n  }\n\n  public AlertRuleRequest name(String name) {\n    this.name = name;\n    return this;\n  }\n\n   /**\n   * Get name\n   * @return name\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public AlertRuleRequest riskLevel(Integer riskLevel) {\n    this.riskLevel = riskLevel;\n    return this;\n  }\n\n   /**\n   * Get riskLevel\n   * @return riskLevel\n  **/\n  @ApiModelProperty(value = \"\")\n  public Integer getRiskLevel() {\n    return riskLevel;\n  }\n\n  public void setRiskLevel(Integer riskLevel) {\n    this.riskLevel = riskLevel;\n  }\n\n  public AlertRuleRequest searchPeriod(String searchPeriod) {\n    this.searchPeriod = searchPeriod;\n    return this;\n  }\n\n   /**\n   * Get searchPeriod\n   * @return searchPeriod\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getSearchPeriod() {\n    return searchPeriod;\n  }\n\n  public void setSearchPeriod(String searchPeriod) {\n    this.searchPeriod = searchPeriod;\n  }\n\n  public AlertRuleRequest tags(List<String> tags) {\n    this.tags = tags;\n    return this;\n  }\n\n  public AlertRuleRequest addTagsItem(String tagsItem) {\n    if (this.tags == null) {\n      this.tags = new ArrayList<>();\n    }\n    this.tags.add(tagsItem);\n    return this;\n  }\n\n   /**\n   * Get tags\n   * @return tags\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<String> getTags() {\n    return tags;\n  }\n\n  public void setTags(List<String> tags) {\n    this.tags = tags;\n  }\n\n  public AlertRuleRequest thresholdType(ThresholdTypeEnum thresholdType) {\n    this.thresholdType = thresholdType;\n    return this;\n  }\n\n   /**\n   * Get thresholdType\n   * @return thresholdType\n  **/\n  @ApiModelProperty(value = \"\")\n  public ThresholdTypeEnum getThresholdType() {\n    return thresholdType;\n  }\n\n  public void setThresholdType(ThresholdTypeEnum thresholdType) {\n    this.thresholdType = thresholdType;\n  }\n\n  public AlertRuleRequest thresholdValue(Double thresholdValue) {\n    this.thresholdValue = thresholdValue;\n    return this;\n  }\n\n   /**\n   * Get thresholdValue\n   * @return thresholdValue\n  **/\n  @ApiModelProperty(value = \"\")\n  public Double getThresholdValue() {\n    return thresholdValue;\n  }\n\n  public void setThresholdValue(Double thresholdValue) {\n    this.thresholdValue = thresholdValue;\n  }\n\n  public AlertRuleRequest type(TypeEnum type) {\n    this.type = type;\n    return this;\n  }\n\n   /**\n   * Get type\n   * @return type\n  **/\n  @ApiModelProperty(value = \"\")\n  public TypeEnum getType() {\n    return type;\n  }\n\n  public void setType(TypeEnum type) {\n    this.type = type;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    AlertRuleRequest alertRuleRequest = (AlertRuleRequest) o;\n    return Objects.equals(this.aggregationPeriod, alertRuleRequest.aggregationPeriod) &&\n        Objects.equals(this.aggregationType, alertRuleRequest.aggregationType) &&\n        Objects.equals(this.alertDestinationIds, alertRuleRequest.alertDestinationIds) &&\n        Objects.equals(this.applicationIds, alertRuleRequest.applicationIds) &&\n        Objects.equals(this.enabled, alertRuleRequest.enabled) &&\n        Objects.equals(this.filterBy, alertRuleRequest.filterBy) &&\n        Objects.equals(this.groupByField, alertRuleRequest.groupByField) &&\n        Objects.equals(this.name, alertRuleRequest.name) &&\n        Objects.equals(this.riskLevel, alertRuleRequest.riskLevel) &&\n        Objects.equals(this.searchPeriod, alertRuleRequest.searchPeriod) &&\n        Objects.equals(this.tags, alertRuleRequest.tags) &&\n        Objects.equals(this.thresholdType, alertRuleRequest.thresholdType) &&\n        Objects.equals(this.thresholdValue, alertRuleRequest.thresholdValue) &&\n        Objects.equals(this.type, alertRuleRequest.type);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(aggregationPeriod, aggregationType, alertDestinationIds, applicationIds, enabled, filterBy, groupByField, name, riskLevel, searchPeriod, tags, thresholdType, thresholdValue, type);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class AlertRuleRequest {\\n\");\n    \n    sb.append(\"    aggregationPeriod: \").append(toIndentedString(aggregationPeriod)).append(\"\\n\");\n    sb.append(\"    aggregationType: \").append(toIndentedString(aggregationType)).append(\"\\n\");\n    sb.append(\"    alertDestinationIds: \").append(toIndentedString(alertDestinationIds)).append(\"\\n\");\n    sb.append(\"    applicationIds: \").append(toIndentedString(applicationIds)).append(\"\\n\");\n    sb.append(\"    enabled: \").append(toIndentedString(enabled)).append(\"\\n\");\n    sb.append(\"    filterBy: \").append(toIndentedString(filterBy)).append(\"\\n\");\n    sb.append(\"    groupByField: \").append(toIndentedString(groupByField)).append(\"\\n\");\n    sb.append(\"    name: \").append(toIndentedString(name)).append(\"\\n\");\n    sb.append(\"    riskLevel: \").append(toIndentedString(riskLevel)).append(\"\\n\");\n    sb.append(\"    searchPeriod: \").append(toIndentedString(searchPeriod)).append(\"\\n\");\n    sb.append(\"    tags: \").append(toIndentedString(tags)).append(\"\\n\");\n    sb.append(\"    thresholdType: \").append(toIndentedString(thresholdType)).append(\"\\n\");\n    sb.append(\"    thresholdValue: \").append(toIndentedString(thresholdValue)).append(\"\\n\");\n    sb.append(\"    type: \").append(toIndentedString(type)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "LogSentinel/logsentinel-java-api", "file": "src/main/java/com/logsentinel/model/AlertRuleRequest.java", "last_update_at": "2021-05-14T10:05:46+00:00", "question_id": "2015410f2622e7d62890cc961ff627e53cdbb9db", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AlertRuleRequest {\n  @JsonProperty(\"aggregationPeriod\")\n  private String aggregationPeriod = null;\n  /**\n   * Gets or Sets aggregationType\n   */\n  public enum AggregationTypeEnum {\n    COUNT(\"COUNT\"),\n    AVG(\"AVG\"),\n    SUM(\"SUM\"),\n    MAX(\"MAX\"),\n    MIN(\"MIN\");\n    private String value;\n    AggregationTypeEnum(String value) {\n      this.value = value;\n    }\n    @JsonValue\n    public String getValue() {\n      return value;\n    }\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n    @JsonCreator\n    public static AggregationTypeEnum fromValue(String text) {\n      for (AggregationTypeEnum b : AggregationTypeEnum.values()) {\n        if (String.valueOf(b.value).equals(text)) {\n          return b;\n        }\n      }\n      return null;\n    }\n  }\n  @JsonProperty(\"aggregationType\")\n  private AggregationTypeEnum aggregationType = null;\n  @JsonProperty(\"alertDestinationIds\")\n  private List<UUID> alertDestinationIds = null;\n  @JsonProperty(\"applicationIds\")\n  private List<UUID> applicationIds = null;\n  @JsonProperty(\"enabled\")\n  private Boolean enabled = null;\n  @JsonProperty(\"filterBy\")\n  private String filterBy = null;\n  @JsonProperty(\"groupByField\")\n  private String groupByField = null;\n  @JsonProperty(\"name\")\n  private String name = null;\n  @JsonProperty(\"riskLevel\")\n  private Integer riskLevel = null;\n  @JsonProperty(\"searchPeriod\")\n  private String searchPeriod = null;\n  @JsonProperty(\"tags\")\n  private List<String> tags = null;\n  /**\n   * Gets or Sets thresholdType\n   */\n  public enum ThresholdTypeEnum {\n    ABOVE(\"ABOVE\"),\n    BELOW(\"BELOW\"),\n    BOTH(\"BOTH\");\n    private String value;\n    ThresholdTypeEnum(String value) {\n      this.value = value;\n    }\n    @JsonValue\n    public String getValue() {\n      return value;\n    }\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n    @JsonCreator\n    public static ThresholdTypeEnum fromValue(String text) {\n      for (ThresholdTypeEnum b : ThresholdTypeEnum.values()) {\n        if (String.valueOf(b.value).equals(text)) {\n          return b;\n        }\n      }\n      return null;\n    }\n  }\n  @JsonProperty(\"thresholdType\")\n  private ThresholdTypeEnum thresholdType = null;\n  @JsonProperty(\"thresholdValue\")\n  private Double thresholdValue = null;\n  /**\n   * Gets or Sets type\n   */\n  public enum TypeEnum {\n    ST_DEV(\"ST_DEV\"),\n    MEAN(\"MEAN\"),\n    FIXED(\"FIXED\");\n    private String value;\n    TypeEnum(String value) {\n      this.value = value;\n    }\n    @JsonValue\n    public String getValue() {\n      return value;\n    }\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n    @JsonCreator\n    public static TypeEnum fromValue(String text) {\n      for (TypeEnum b : TypeEnum.values()) {\n        if (String.valueOf(b.value).equals(text)) {\n          return b;\n        }\n      }\n      return null;\n    }\n  }\n  @JsonProperty(\"type\")\n  private TypeEnum type = null;\n  public AlertRuleRequest aggregationPeriod(String aggregationPeriod) {\n    this.aggregationPeriod = aggregationPeriod;\n    return this;\n  }\n   /**\n   * Get aggregationPeriod\n   * @return aggregationPeriod\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getAggregationPeriod() {\n    return aggregationPeriod;\n  }\n  public void setAggregationPeriod(String aggregationPeriod) {\n    this.aggregationPeriod = aggregationPeriod;\n  }\n  public AlertRuleRequest aggregationType(AggregationTypeEnum aggregationType) {\n    this.aggregationType = aggregationType;\n    return this;\n  }\n   /**\n   * Get aggregationType\n   * @return aggregationType\n  **/\n  @ApiModelProperty(value = \"\")\n  public AggregationTypeEnum getAggregationType() {\n    return aggregationType;\n  }\n  public void setAggregationType(AggregationTypeEnum aggregationType) {\n    this.aggregationType = aggregationType;\n  }\n  public AlertRuleRequest alertDestinationIds(List<UUID> alertDestinationIds) {\n    this.alertDestinationIds = alertDestinationIds;\n    return this;\n  }\n  public AlertRuleRequest addAlertDestinationIdsItem(UUID alertDestinationIdsItem) {\n    if (this.alertDestinationIds == null) {\n      this.alertDestinationIds = new ArrayList<>();\n    }\n    this.alertDestinationIds.add(alertDestinationIdsItem);\n    return this;\n  }\n   /**\n   * Get alertDestinationIds\n   * @return alertDestinationIds\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<UUID> getAlertDestinationIds() {\n    return alertDestinationIds;\n  }\n  public void setAlertDestinationIds(List<UUID> alertDestinationIds) {\n    this.alertDestinationIds = alertDestinationIds;\n  }\n  public AlertRuleRequest applicationIds(List<UUID> applicationIds) {\n    this.applicationIds = applicationIds;\n    return this;\n  }\n  public AlertRuleRequest addApplicationIdsItem(UUID applicationIdsItem) {\n    if (this.applicationIds == null) {\n      this.applicationIds = new ArrayList<>();\n    }\n    this.applicationIds.add(applicationIdsItem);\n    return this;\n  }\n   /**\n   * Get applicationIds\n   * @return applicationIds\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<UUID> getApplicationIds() {\n    return applicationIds;\n  }\n  public void setApplicationIds(List<UUID> applicationIds) {\n    this.applicationIds = applicationIds;\n  }\n  public AlertRuleRequest enabled(Boolean enabled) {\n    this.enabled = enabled;\n    return this;\n  }\n   /**\n   * Get enabled\n   * @return enabled\n  **/\n  @ApiModelProperty(value = \"\")\n  public Boolean isEnabled() {\n    return enabled;\n  }\n  public void setEnabled(Boolean enabled) {\n    this.enabled = enabled;\n  }\n  public AlertRuleRequest filterBy(String filterBy) {\n    this.filterBy = filterBy;\n    return this;\n  }\n   /**\n   * Get filterBy\n   * @return filterBy\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getFilterBy() {\n    return filterBy;\n  }\n  public void setFilterBy(String filterBy) {\n    this.filterBy = filterBy;\n  }\n  public AlertRuleRequest groupByField(String groupByField) {\n    this.groupByField = groupByField;\n    return this;\n  }\n   /**\n   * Get groupByField\n   * @return groupByField\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getGroupByField() {\n    return groupByField;\n  }\n  public void setGroupByField(String groupByField) {\n    this.groupByField = groupByField;\n  }\n  public AlertRuleRequest name(String name) {\n    this.name = name;\n    return this;\n  }\n   /**\n   * Get name\n   * @return name\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getName() {\n    return name;\n  }\n  public void setName(String name) {\n    this.name = name;\n  }\n  public AlertRuleRequest riskLevel(Integer riskLevel) {\n    this.riskLevel = riskLevel;\n    return this;\n  }\n   /**\n   * Get riskLevel\n   * @return riskLevel\n  **/\n  @ApiModelProperty(value = \"\")\n  public Integer getRiskLevel() {\n    return riskLevel;\n  }\n  public void setRiskLevel(Integer riskLevel) {\n    this.riskLevel = riskLevel;\n  }\n  public AlertRuleRequest searchPeriod(String searchPeriod) {\n    this.searchPeriod = searchPeriod;\n    return this;\n  }\n   /**\n   * Get searchPeriod\n   * @return searchPeriod\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getSearchPeriod() {\n    return searchPeriod;\n  }\n  public void setSearchPeriod(String searchPeriod) {\n    this.searchPeriod = searchPeriod;\n  }\n  public AlertRuleRequest tags(List<String> tags) {\n    this.tags = tags;\n    return this;\n  }\n  public AlertRuleRequest addTagsItem(String tagsItem) {\n    if (this.tags == null) {\n      this.tags = new ArrayList<>();\n    }\n    this.tags.add(tagsItem);\n    return this;\n  }\n   /**\n   * Get tags\n   * @return tags\n  **/\n  @ApiModelProperty(value = \"\")\n  public List<String> getTags() {\n    return tags;\n  }\n  public void setTags(List<String> tags) {\n    this.tags = tags;\n  }\n  public AlertRuleRequest thresholdType(ThresholdTypeEnum thresholdType) {\n    this.thresholdType = thresholdType;\n    return this;\n  }\n   /**\n   * Get thresholdType\n   * @return thresholdType\n  **/\n  @ApiModelProperty(value = \"\")\n  public ThresholdTypeEnum getThresholdType() {\n    return thresholdType;\n  }\n  public void setThresholdType(ThresholdTypeEnum thresholdType) {\n    this.thresholdType = thresholdType;\n  }\n  public AlertRuleRequest thresholdValue(Double thresholdValue) {\n    this.thresholdValue = thresholdValue;\n    return this;\n  }\n   /**\n   * Get thresholdValue\n   * @return thresholdValue\n  **/\n  @ApiModelProperty(value = \"\")\n  public Double getThresholdValue() {\n    return thresholdValue;\n  }\n  public void setThresholdValue(Double thresholdValue) {\n    this.thresholdValue = thresholdValue;\n  }\n  public AlertRuleRequest type(TypeEnum type) {\n    this.type = type;\n    return this;\n  }\n   /**\n   * Get type\n   * @return type\n  **/\n  @ApiModelProperty(value = \"\")\n  public TypeEnum getType() {\n    return type;\n  }\n  public void setType(TypeEnum type) {\n    this.type = type;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    AlertRuleRequest alertRuleRequest = (AlertRuleRequest) o;\n    return Objects.equals(this.aggregationPeriod, alertRuleRequest.aggregationPeriod) &&\n        Objects.equals(this.aggregationType, alertRuleRequest.aggregationType) &&\n        Objects.equals(this.alertDestinationIds, alertRuleRequest.alertDestinationIds) &&\n        Objects.equals(this.applicationIds, alertRuleRequest.applicationIds) &&\n        Objects.equals(this.enabled, alertRuleRequest.enabled) &&\n        Objects.equals(this.filterBy, alertRuleRequest.filterBy) &&\n        Objects.equals(this.groupByField, alertRuleRequest.groupByField) &&\n        Objects.equals(this.name, alertRuleRequest.name) &&\n        Objects.equals(this.riskLevel, alertRuleRequest.riskLevel) &&\n        Objects.equals(this.searchPeriod, alertRuleRequest.searchPeriod) &&\n        Objects.equals(this.tags, alertRuleRequest.tags) &&\n        Objects.equals(this.thresholdType, alertRuleRequest.thresholdType) &&\n        Objects.equals(this.thresholdValue, alertRuleRequest.thresholdValue) &&\n        Objects.equals(this.type, alertRuleRequest.type);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(aggregationPeriod, aggregationType, alertDestinationIds, applicationIds, enabled, filterBy, groupByField, name, riskLevel, searchPeriod, tags, thresholdType, thresholdValue, type);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class AlertRuleRequest {\\n\");\n    sb.append(\"    aggregationPeriod: \").append(toIndentedString(aggregationPeriod)).append(\"\\n\");\n    sb.append(\"    aggregationType: \").append(toIndentedString(aggregationType)).append(\"\\n\");\n    sb.append(\"    alertDestinationIds: \").append(toIndentedString(alertDestinationIds)).append(\"\\n\");\n    sb.append(\"    applicationIds: \").append(toIndentedString(applicationIds)).append(\"\\n\");\n    sb.append(\"    enabled: \").append(toIndentedString(enabled)).append(\"\\n\");\n    sb.append(\"    filterBy: \").append(toIndentedString(filterBy)).append(\"\\n\");\n    sb.append(\"    groupByField: \").append(toIndentedString(groupByField)).append(\"\\n\");\n    sb.append(\"    name: \").append(toIndentedString(name)).append(\"\\n\");\n    sb.append(\"    riskLevel: \").append(toIndentedString(riskLevel)).append(\"\\n\");\n    sb.append(\"    searchPeriod: \").append(toIndentedString(searchPeriod)).append(\"\\n\");\n    sb.append(\"    tags: \").append(toIndentedString(tags)).append(\"\\n\");\n    sb.append(\"    thresholdType: \").append(toIndentedString(thresholdType)).append(\"\\n\");\n    sb.append(\"    thresholdValue: \").append(toIndentedString(thresholdValue)).append(\"\\n\");\n    sb.append(\"    type: \").append(toIndentedString(type)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "086569103dfc31b2649c3f12a6338fcfe2ef52d3", "ext": "java", "lang": "Java", "content": "public class LogModule extends PrivateModule {\n\n  private final File logDirectory;\n  private final StateMachine stateMachine;\n  private final Executor executor;\n\n  public LogModule(@Nonnull File logDirectory, @Nonnull StateMachine stateMachine, @Nonnull Executor executor) {\n    this.logDirectory = checkNotNull(logDirectory);\n    this.stateMachine = checkNotNull(stateMachine);\n    this.executor = checkNotNull(executor);\n  }\n\n  @Override\n  protected void configure() {\n\n    bind(StateMachine.class).toInstance(stateMachine);\n    bind(StateMachineProxy.class);\n    bind(Executor.class)\n        .annotatedWith(StateExecutor.class)\n        .toInstance(executor);\n    bind(RaftLog.class).asEagerSingleton();\n    expose(RaftLog.class);\n\n  }\n\n  @Nonnull\n  @Provides\n  @Singleton\n  Journal getJournal() {\n\n    try {\n\n      final Journal journal = JournalBuilder.of(logDirectory).setPhysicalSync(true).open();\n\n      Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n        //noinspection EmptyCatchBlock\n        try {\n          journal.close();\n        } catch (IOException e) {\n          //TODO log it\n        }\n      }));\n\n      return journal;\n\n    } catch (IOException e) {\n\n      throw new RuntimeException(e);\n\n    }\n\n  }\n\n\n}", "class_id": 0, "repo": "mgodave/barge", "file": "barge-core/src/main/java/org/robotninjas/barge/log/LogModule.java", "last_update_at": "2021-11-06T08:38:03+00:00", "question_id": "086569103dfc31b2649c3f12a6338fcfe2ef52d3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LogModule extends PrivateModule {\n  private final File logDirectory;\n  private final StateMachine stateMachine;\n  private final Executor executor;\n  public LogModule(@Nonnull File logDirectory, @Nonnull StateMachine stateMachine, @Nonnull Executor executor) {\n    this.logDirectory = checkNotNull(logDirectory);\n    this.stateMachine = checkNotNull(stateMachine);\n    this.executor = checkNotNull(executor);\n  }\n  @Override\n  protected void configure() {\n    bind(StateMachine.class).toInstance(stateMachine);\n    bind(StateMachineProxy.class);\n    bind(Executor.class)\n        .annotatedWith(StateExecutor.class)\n        .toInstance(executor);\n    bind(RaftLog.class).asEagerSingleton();\n    expose(RaftLog.class);\n  }\n  @Nonnull\n  @Provides\n  @Singleton\n  Journal getJournal() {\n    try {\n      final Journal journal = JournalBuilder.of(logDirectory).setPhysicalSync(true).open();\n      Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n        //noinspection EmptyCatchBlock\n        try {\n          journal.close();\n        } catch (IOException e) {\n          //TODO log it\n        }\n      }));\n      return journal;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"]]}
{"hexsha": "d11a112c80b51a47725f96971f69f14f8a4af6d6", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"service_info\")\npublic class ServiceInfo implements Serializable {\n\n    private static final long serialVersionUID = 768026109321305392L;\n\n    @Id\n    @BusinessKey\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\")\n    private Integer id;\n\n    @Column(name = \"SERVICE_INPUT\")\n    private String serviceInput;\n\n    @Column(name = \"SERVICE_PROPERTIES\")\n    private String serviceProperties;\n\n    @ManyToOne(cascade = CascadeType.ALL)\n    @JoinColumn(name = \"SERVICE_MODEL_UUID\")\n    private Service service;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer serviceInfoId) {\n        this.id = serviceInfoId;\n    }\n\n    public String getServiceInput() {\n        return serviceInput;\n    }\n\n    public void setServiceInput(String serviceInput) {\n        this.serviceInput = serviceInput;\n    }\n\n    public String getServiceProperties() {\n        return serviceProperties;\n    }\n\n    public void setServiceProperties(String serviceProperties) {\n        this.serviceProperties = serviceProperties;\n    }\n\n    @LinkedResource\n    public Service getService() {\n        return service;\n    }\n\n    public void setService(Service service) {\n        this.service = service;\n    }\n\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this).append(\"id\", id).append(\"serviceProperties\", serviceProperties)\n                .append(\"serviceInput\", serviceInput).toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ServiceInfo that = (ServiceInfo) o;\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}", "class_id": 0, "repo": "sharmajiii/so", "file": "mso-catalog-db/src/main/java/org/onap/so/db/catalog/beans/ServiceInfo.java", "last_update_at": "2021-10-15T15:01:14+00:00", "question_id": "d11a112c80b51a47725f96971f69f14f8a4af6d6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"service_info\")\npublic class ServiceInfo implements Serializable {\n    private static final long serialVersionUID = 768026109321305392L;\n    @Id\n    @BusinessKey\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\")\n    private Integer id;\n    @Column(name = \"SERVICE_INPUT\")\n    private String serviceInput;\n    @Column(name = \"SERVICE_PROPERTIES\")\n    private String serviceProperties;\n    @ManyToOne(cascade = CascadeType.ALL)\n    @JoinColumn(name = \"SERVICE_MODEL_UUID\")\n    private Service service;\n    public Integer getId() {\n        return id;\n    }\n    public void setId(Integer serviceInfoId) {\n        this.id = serviceInfoId;\n    }\n    public String getServiceInput() {\n        return serviceInput;\n    }\n    public void setServiceInput(String serviceInput) {\n        this.serviceInput = serviceInput;\n    }\n    public String getServiceProperties() {\n        return serviceProperties;\n    }\n    public void setServiceProperties(String serviceProperties) {\n        this.serviceProperties = serviceProperties;\n    }\n    @LinkedResource\n    public Service getService() {\n        return service;\n    }\n    public void setService(Service service) {\n        this.service = service;\n    }\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this).append(\"id\", id).append(\"serviceProperties\", serviceProperties)\n                .append(\"serviceInput\", serviceInput).toString();\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ServiceInfo that = (ServiceInfo) o;\n        return id.equals(that.id);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n"]]}
{"hexsha": "e622e9d58ce211f568a1cb75a3cb263859d636e1", "ext": "java", "lang": "Java", "content": "@Name(\"pythonpaths\")\n@Summary(\"A utility command to manage system installed and manually registered python binaries.\")\n@Description(\"A utility command to manage system installed and manually registered python binaries. Python binaries \" +\n        \"could be from either a regular python install, through a conda environment, javacpp cpython or a virtual \" +\n        \"environment through 'venv' package. Each python installation has been assigned a particular id and a \" +\n        \"specific type which ultimately identifies which python installation is going to be used with a particular \" +\n        \"PythonStep configuration. You can also register a python binary if it's not listed through 'pythonpaths add' \" +\n        \"subcommand. \\n\\n\" +\n        \"Example usages:\\n\" +\n        \"--------------\\n\" +\n        \"- Lists all the installed and registered python binaries:\\n\" +\n        \"$ konduit pythonpaths list \\n\\n\" +\n        \"- Lists python installs with their included packages:\\n\" +\n        \"$ konduit pythonpaths -wip \\n\\n\" +\n        \"- Register a custom python installation:\\n\" +\n        \"$ konduit pythonpaths add -t=python -p=E:\\\\python37\\\\python.exe \\n\" +\n        \"--------------\")\n@Slf4j\npublic class PythonPathsCommand extends DefaultCommand {\n\n    private SubCommand subCommand;\n    private Object type;\n    private String path;\n    private boolean withInstalledPackages;\n\n    @Argument(index = 0, argName = \"sub_command\", required = false)\n    @DefaultValue(\"LIST\")\n    @Description(\"Sub command to be used with the pythonpaths command. Sub commands are: [add, list, config]. \" +\n            \"Defaults to 'LIST'\")\n    public void setSubCommand(String subCommand) {\n        try {\n            this.subCommand = PythonPathsCommand.SubCommand.valueOf(subCommand.toUpperCase());\n        } catch (Exception e) {\n            System.out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                    subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n            System.exit(1);\n        }\n    }\n\n    @Option(shortName = \"t\", longName = \"type\", argName = \"type\", required = true)\n    @Description(\"Name of the python type. For the 'add' subcommand, accepted values are: [python, conda, venv]. \" +\n            \"For the 'list' subcommand, accepted values are: [all, javacpp, python, conda, venv]. \" +\n            \"For 'config' subcommand the accepted values are: [custom, javacpp, python, conda, venv]\")\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    @Option(shortName = \"p\", longName = \"path\", argName = \"install_path\")\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" +\n            \"of the root installation folder.\")\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    @Option(shortName = \"wip\", longName = \"with-installed-packages\", flag = true)\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" +\n            \"of the root installation folder.\")\n    public void setPath(boolean withInstalledPackages) {\n        this.withInstalledPackages = withInstalledPackages;\n    }\n\n    private enum SubCommand {\n        ADD, LIST, CONFIG\n    }\n\n    public enum ListInstallationType {\n        ALL, JAVACPP, PYTHON, CONDA, VENV\n    }\n\n    @Override\n    public void run() {\n        switch (this.subCommand) {\n            case ADD:\n                try {\n                    this.type = PythonType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                            type, Arrays.toString(PythonType.values()));\n                    System.exit(1);\n                }\n                break;\n            case CONFIG:\n                try {\n                    this.type = PythonConfigType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                            type, Arrays.toString(PythonConfigType.values()));\n                    System.exit(1);\n                }\n                break;\n            case LIST:\n                try {\n                    this.type = PythonPathsCommand.ListInstallationType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                            type, Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n                    System.exit(1);\n                }\n                break;\n            default:\n                out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                        subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n\n        switch (this.subCommand) {\n            case ADD:\n                registerInstallation((PythonType) type, path);\n                break;\n            case LIST:\n                listInstallations((ListInstallationType) type, withInstalledPackages);\n                break;\n            case CONFIG:\n                createConfig((PythonConfigType) type);\n                break;\n            default:\n                log.error(\"Invalid sub command name: {}. Allowed values are: {} -> (case insensitive).\",\n                        subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n    }\n\n    private void createConfig(PythonConfigType pythonConfigType) {\n        throw new UnsupportedOperationException(\"This will be implemented in a continuation PR\");\n        // add logic here\n    }\n\n\n    public static void listInstallations(ListInstallationType type, boolean withInstalledPackages) {\n        switch (type) {\n            case ALL:\n                listJavacppInstallations(withInstalledPackages);\n                listPythonInstallations(withInstalledPackages);\n                listCondaInstallations(withInstalledPackages);\n                listVenvInstallations(withInstalledPackages);\n                break;\n            case JAVACPP:\n                listJavacppInstallations(withInstalledPackages);\n                break;\n            case PYTHON:\n                listPythonInstallations(withInstalledPackages);\n                break;\n            case CONDA:\n                listCondaInstallations(withInstalledPackages);\n                break;\n            case VENV:\n                listVenvInstallations(withInstalledPackages);\n                break;\n            default:\n                System.out.format(\"Invalid installation type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                        type.name(), Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n        }\n    }\n\n    private static void listJavacppInstallations(boolean withInstalledPackages) {\n        JavaCppDetails javaCppDetails = getJavaCppDetails();\n\n        System.out.println(\"\\n----------------------------JAVACPP INSTALLS---------------------------\");\n        System.out.print(\n                formatPythonInstallation(new PythonDetails(javaCppDetails.id(), javaCppDetails.path(), javaCppDetails.version()),\n                        false)\n        );\n        if(!withInstalledPackages) {\n            System.out.println(\"\\n-----------------------------------------------------------------------\");\n        } else {\n            System.out.println(\"\\t--------Installed Modules--------\");\n            printJavaCppInstalledModules();\n            System.out.println(\"\\t---------------------------------\");\n            System.out.println(\"-----------------------------------------------------------------------\");\n        }\n    }\n\n    public static JavaCppDetails getJavaCppDetails() {\n        try {\n            Py_AddPath(cachePackages());\n\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);  /* optional but recommended */\n            Py_Initialize();\n\n            PyObject globals = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n\n            PyRun_StringFlags(\n                    \"import os, sys; \" +\n                            \"executable = os.path.abspath(os.path.join(os.__file__, '..', '..')) + ' (embedded python)'; \" +\n                            \"version = sys.version.split(' ')[0]\",\n                    Py_single_input,\n                    globals,\n                    null,\n                    null);\n\n            JavaCppDetails javaCppDetails = new JavaCppDetails(\"0\",\n                    getStringFromPythonObject(PyDict_GetItemString(globals, \"executable\")),\n                    getStringFromPythonObject(PyDict_GetItemString(globals, \"version\")) + System.lineSeparator());\n\n            PyMem_RawFree(program);\n\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n\n            return javaCppDetails;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n            return null;\n        }\n    }\n\n    private static void listPythonInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------PYTHON INSTALLS----------------------------\");\n        System.out.print(\n                findPythonInstallations().stream()\n                        .map(pythonDetails -> formatPythonInstallation(pythonDetails, withInstalledPackages))\n                        .collect(Collectors.joining(System.lineSeparator()))\n        );\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n\n    private static void listCondaInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------CONDA INSTALLS-----------------------------\");\n        System.out.print(\n                findCondaInstallations().stream()\n                        .map(condaDetails -> formatCondaInstallation(condaDetails, withInstalledPackages))\n                        .collect(Collectors.joining(System.lineSeparator()))\n        );\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static String formatPythonInstallation(PythonDetails pythonDetails, boolean withInstalledPackages) {\n        return formatPythonInstallation(pythonDetails, 1, withInstalledPackages);\n    }\n\n    private static String formatPythonInstallation(PythonDetails pythonDetails, int numberOfTabs, boolean withInstalledPackages) {\n        String tabs = IntStream.range(0, numberOfTabs).mapToObj(index -> \"\\t\").collect(Collectors.joining(\"\"));\n\n        return String.format(\" -%s%s: %s%n%spath: %s%n%sversion: %s%s\",\n                \"\\t\",\n                numberOfTabs > 1 ? \"name\" : \"id\",\n                pythonDetails.id(),\n                tabs,\n                pythonDetails.path(),\n                tabs,\n                pythonDetails.version(),\n                withInstalledPackages ?\n                        String.format(\"%s--------Installed Modules--------%n%s%n%s---------------------------------%n\",\n                                tabs,\n                                Arrays.stream(ProcessUtils.runAndGetOutput(pythonDetails.path(), \"-c\", \"from pip import _internal; _internal.main(['list'])\")\n                                        .split(System.lineSeparator()))\n                                        .map(line -> String.format(\"%s- %s\", tabs, line))\n                                        .collect(Collectors.joining(System.lineSeparator())),\n                                tabs) :\n                        \"\");\n    }\n\n    private static void printJavaCppInstalledModules() {\n        try {\n            Py_AddPath(cachePackages());\n\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);  /* optional but recommended */\n            Py_Initialize();\n\n            PyRun_SimpleStringFlags(\n                \"from pip import _internal\\n\" +\n                    \"import warnings\\n\" +\n                    \"warnings.filterwarnings(action='ignore')\\n\" +\n\n                    \"class writer :\\n\" +\n                            \"    def __init__(self, *writers) :\\n\" +\n                            \"        self.writers = writers\\n\" +\n                            \"\\n\" +\n                            \"    def write(self, text) :\\n\" +\n                            \"        for w in self.writers :\\n\" +\n                            \"            w.write('\\t- ' + text)\\n\" +\n                            \"\\n\" +\n                            \"    def flush(self):\\n\" +\n                            \"        pass\\n\" +\n\n                            \"import sys\\n\" +\n\n                            \"sys.stdout = writer(sys.stdout)\\n\" +\n                            \"installed_modules = _internal.main(['list'])\",\n                    null);\n\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n\n            PyMem_RawFree(program);\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n        }\n    }\n\n    private static String formatCondaInstallation(CondaDetails condaDetails, boolean withInstalledPackages) {\n        List<String> formattedCondaEnvironments = new ArrayList<>();\n\n        condaDetails.environments().forEach(pythonDetails ->\n                formattedCondaEnvironments.add(formatPythonInstallation(pythonDetails, 2, withInstalledPackages)));\n\n        return String.format(\" -\\tid: %s%n\\tpath: %s%n\\tversion: %s%s\",\n                condaDetails.id(),\n                condaDetails.path(),\n                condaDetails.version(),\n                String.format(\n                                \"\\t--------------------------ENVIRONMENTS-------------------------%n\" +\n                                \"\\t%s\" +\n                                \"\\t---------------------------------------------------------------%n\",\n                        String.join(System.lineSeparator() + \"\\t\", formattedCondaEnvironments)\n                )\n        );\n    }\n\n    private static void listVenvInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n-----------------------------VENV INSTALLS-----------------------------\");\n        System.out.print(\n                findVenvInstallations().stream()\n                        .map(venvDetails -> formatPythonInstallation(new PythonDetails(venvDetails.id(),\n                                        venvDetails.path(),\n                                        venvDetails.version()),\n                                withInstalledPackages))\n                        .collect(Collectors.joining(System.lineSeparator()))\n        );\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static String getStringFromPythonObject(PyObject pythonObject) {\n        PyObject pythonEncodedString = PyUnicode_AsEncodedString(pythonObject, \"utf-8\", \"~E~\");\n        String javaString = PyBytes_AsString(pythonEncodedString).getString();\n        Py_DecRef(pythonEncodedString);\n        return javaString;\n    }\n}", "class_id": 0, "repo": "KonduitAI/konduit-serving", "file": "konduit-serving-cli/src/main/java/ai/konduit/serving/cli/launcher/command/build/extension/PythonPathsCommand.java", "last_update_at": "2021-12-16T08:27:01+00:00", "question_id": "e622e9d58ce211f568a1cb75a3cb263859d636e1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Name(\"pythonpaths\")\n@Summary(\"A utility command to manage system installed and manually registered python binaries.\")\n@Description(\"A utility command to manage system installed and manually registered python binaries. Python binaries \" +\n        \"could be from either a regular python install, through a conda environment, javacpp cpython or a virtual \" +\n        \"environment through 'venv' package. Each python installation has been assigned a particular id and a \" +\n        \"specific type which ultimately identifies which python installation is going to be used with a particular \" +\n        \"PythonStep configuration. You can also register a python binary if it's not listed through 'pythonpaths add' \" +\n        \"subcommand. \\n\\n\" +\n        \"Example usages:\\n\" +\n        \"--------------\\n\" +\n        \"- Lists all the installed and registered python binaries:\\n\" +\n        \"$ konduit pythonpaths list \\n\\n\" +\n        \"- Lists python installs with their included packages:\\n\" +\n        \"$ konduit pythonpaths -wip \\n\\n\" +\n        \"- Register a custom python installation:\\n\" +\n        \"$ konduit pythonpaths add -t=python -p=E:\\\\python37\\\\python.exe \\n\" +\n        \"--------------\")\n@Slf4j\npublic class PythonPathsCommand extends DefaultCommand {\n    private SubCommand subCommand;\n    private Object type;\n    private String path;\n    private boolean withInstalledPackages;\n    @Argument(index = 0, argName = \"sub_command\", required = false)\n    @DefaultValue(\"LIST\")\n    @Description(\"Sub command to be used with the pythonpaths command. Sub commands are: [add, list, config]. \" +\n            \"Defaults to 'LIST'\")\n    public void setSubCommand(String subCommand) {\n        try {\n            this.subCommand = PythonPathsCommand.SubCommand.valueOf(subCommand.toUpperCase());\n        } catch (Exception e) {\n            System.out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                    subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n            System.exit(1);\n        }\n    }\n    @Option(shortName = \"t\", longName = \"type\", argName = \"type\", required = true)\n    @Description(\"Name of the python type. For the 'add' subcommand, accepted values are: [python, conda, venv]. \" +\n            \"For the 'list' subcommand, accepted values are: [all, javacpp, python, conda, venv]. \" +\n            \"For 'config' subcommand the accepted values are: [custom, javacpp, python, conda, venv]\")\n    public void setType(String type) {\n        this.type = type;\n    }\n    @Option(shortName = \"p\", longName = \"path\", argName = \"install_path\")\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" +\n            \"of the root installation folder.\")\n    public void setPath(String path) {\n        this.path = path;\n    }\n    @Option(shortName = \"wip\", longName = \"with-installed-packages\", flag = true)\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" +\n            \"of the root installation folder.\")\n    public void setPath(boolean withInstalledPackages) {\n        this.withInstalledPackages = withInstalledPackages;\n    }\n    private enum SubCommand {\n        ADD, LIST, CONFIG\n    }\n    public enum ListInstallationType {\n        ALL, JAVACPP, PYTHON, CONDA, VENV\n    }\n    @Override\n    public void run() {\n        switch (this.subCommand) {\n            case ADD:\n                try {\n                    this.type = PythonType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                            type, Arrays.toString(PythonType.values()));\n                    System.exit(1);\n                }\n                break;\n            case CONFIG:\n                try {\n                    this.type = PythonConfigType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                            type, Arrays.toString(PythonConfigType.values()));\n                    System.exit(1);\n                }\n                break;\n            case LIST:\n                try {\n                    this.type = PythonPathsCommand.ListInstallationType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                            type, Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n                    System.exit(1);\n                }\n                break;\n            default:\n                out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                        subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n        switch (this.subCommand) {\n            case ADD:\n                registerInstallation((PythonType) type, path);\n                break;\n            case LIST:\n                listInstallations((ListInstallationType) type, withInstalledPackages);\n                break;\n            case CONFIG:\n                createConfig((PythonConfigType) type);\n                break;\n            default:\n                log.error(\"Invalid sub command name: {}. Allowed values are: {} -> (case insensitive).\",\n                        subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n    }\n    private void createConfig(PythonConfigType pythonConfigType) {\n        throw new UnsupportedOperationException(\"This will be implemented in a continuation PR\");\n        // add logic here\n    }\n    public static void listInstallations(ListInstallationType type, boolean withInstalledPackages) {\n        switch (type) {\n            case ALL:\n                listJavacppInstallations(withInstalledPackages);\n                listPythonInstallations(withInstalledPackages);\n                listCondaInstallations(withInstalledPackages);\n                listVenvInstallations(withInstalledPackages);\n                break;\n            case JAVACPP:\n                listJavacppInstallations(withInstalledPackages);\n                break;\n            case PYTHON:\n                listPythonInstallations(withInstalledPackages);\n                break;\n            case CONDA:\n                listCondaInstallations(withInstalledPackages);\n                break;\n            case VENV:\n                listVenvInstallations(withInstalledPackages);\n                break;\n            default:\n                System.out.format(\"Invalid installation type name: '%s'. Allowed values are: %s -> (case insensitive).\",\n                        type.name(), Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n        }\n    }\n    private static void listJavacppInstallations(boolean withInstalledPackages) {\n        JavaCppDetails javaCppDetails = getJavaCppDetails();\n        System.out.println(\"\\n----------------------------JAVACPP INSTALLS---------------------------\");\n        System.out.print(\n                formatPythonInstallation(new PythonDetails(javaCppDetails.id(), javaCppDetails.path(), javaCppDetails.version()),\n                        false)\n        );\n        if(!withInstalledPackages) {\n            System.out.println(\"\\n-----------------------------------------------------------------------\");\n        } else {\n            System.out.println(\"\\t--------Installed Modules--------\");\n            printJavaCppInstalledModules();\n            System.out.println(\"\\t---------------------------------\");\n            System.out.println(\"-----------------------------------------------------------------------\");\n        }\n    }\n    public static JavaCppDetails getJavaCppDetails() {\n        try {\n            Py_AddPath(cachePackages());\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);  /* optional but recommended */\n            Py_Initialize();\n            PyObject globals = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n            PyRun_StringFlags(\n                    \"import os, sys; \" +\n                            \"executable = os.path.abspath(os.path.join(os.__file__, '..', '..')) + ' (embedded python)'; \" +\n                            \"version = sys.version.split(' ')[0]\",\n                    Py_single_input,\n                    globals,\n                    null,\n                    null);\n            JavaCppDetails javaCppDetails = new JavaCppDetails(\"0\",\n                    getStringFromPythonObject(PyDict_GetItemString(globals, \"executable\")),\n                    getStringFromPythonObject(PyDict_GetItemString(globals, \"version\")) + System.lineSeparator());\n            PyMem_RawFree(program);\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n            return javaCppDetails;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n            return null;\n        }\n    }\n    private static void listPythonInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------PYTHON INSTALLS----------------------------\");\n        System.out.print(\n                findPythonInstallations().stream()\n                        .map(pythonDetails -> formatPythonInstallation(pythonDetails, withInstalledPackages))\n                        .collect(Collectors.joining(System.lineSeparator()))\n        );\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n    private static void listCondaInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------CONDA INSTALLS-----------------------------\");\n        System.out.print(\n                findCondaInstallations().stream()\n                        .map(condaDetails -> formatCondaInstallation(condaDetails, withInstalledPackages))\n                        .collect(Collectors.joining(System.lineSeparator()))\n        );\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n    private static String formatPythonInstallation(PythonDetails pythonDetails, boolean withInstalledPackages) {\n        return formatPythonInstallation(pythonDetails, 1, withInstalledPackages);\n    }\n    private static String formatPythonInstallation(PythonDetails pythonDetails, int numberOfTabs, boolean withInstalledPackages) {\n        String tabs = IntStream.range(0, numberOfTabs).mapToObj(index -> \"\\t\").collect(Collectors.joining(\"\"));\n        return String.format(\" -%s%s: %s%n%spath: %s%n%sversion: %s%s\",\n                \"\\t\",\n                numberOfTabs > 1 ? \"name\" : \"id\",\n                pythonDetails.id(),\n                tabs,\n                pythonDetails.path(),\n                tabs,\n                pythonDetails.version(),\n                withInstalledPackages ?\n                        String.format(\"%s--------Installed Modules--------%n%s%n%s---------------------------------%n\",\n                                tabs,\n                                Arrays.stream(ProcessUtils.runAndGetOutput(pythonDetails.path(), \"-c\", \"from pip import _internal; _internal.main(['list'])\")\n                                        .split(System.lineSeparator()))\n                                        .map(line -> String.format(\"%s- %s\", tabs, line))\n                                        .collect(Collectors.joining(System.lineSeparator())),\n                                tabs) :\n                        \"\");\n    }\n    private static void printJavaCppInstalledModules() {\n        try {\n            Py_AddPath(cachePackages());\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);  /* optional but recommended */\n            Py_Initialize();\n            PyRun_SimpleStringFlags(\n                \"from pip import _internal\\n\" +\n                    \"import warnings\\n\" +\n                    \"warnings.filterwarnings(action='ignore')\\n\" +\n                    \"class writer :\\n\" +\n                            \"    def __init__(self, *writers) :\\n\" +\n                            \"        self.writers = writers\\n\" +\n                            \"\\n\" +\n                            \"    def write(self, text) :\\n\" +\n                            \"        for w in self.writers :\\n\" +\n                            \"            w.write('\\t- ' + text)\\n\" +\n                            \"\\n\" +\n                            \"    def flush(self):\\n\" +\n                            \"        pass\\n\" +\n                            \"import sys\\n\" +\n                            \"sys.stdout = writer(sys.stdout)\\n\" +\n                            \"installed_modules = _internal.main(['list'])\",\n                    null);\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n            PyMem_RawFree(program);\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n        }\n    }\n    private static String formatCondaInstallation(CondaDetails condaDetails, boolean withInstalledPackages) {\n        List<String> formattedCondaEnvironments = new ArrayList<>();\n        condaDetails.environments().forEach(pythonDetails ->\n                formattedCondaEnvironments.add(formatPythonInstallation(pythonDetails, 2, withInstalledPackages)));\n        return String.format(\" -\\tid: %s%n\\tpath: %s%n\\tversion: %s%s\",\n                condaDetails.id(),\n                condaDetails.path(),\n                condaDetails.version(),\n                String.format(\n                                \"\\t--------------------------ENVIRONMENTS-------------------------%n\" +\n                                \"\\t%s\" +\n                                \"\\t---------------------------------------------------------------%n\",\n                        String.join(System.lineSeparator() + \"\\t\", formattedCondaEnvironments)\n                )\n        );\n    }\n    private static void listVenvInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n-----------------------------VENV INSTALLS-----------------------------\");\n        System.out.print(\n                findVenvInstallations().stream()\n                        .map(venvDetails -> formatPythonInstallation(new PythonDetails(venvDetails.id(),\n                                        venvDetails.path(),\n                                        venvDetails.version()),\n                                withInstalledPackages))\n                        .collect(Collectors.joining(System.lineSeparator()))\n        );\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n    private static String getStringFromPythonObject(PyObject pythonObject) {\n        PyObject pythonEncodedString = PyUnicode_AsEncodedString(pythonObject, \"utf-8\", \"~E~\");\n        String javaString = PyBytes_AsString(pythonEncodedString).getString();\n        Py_DecRef(pythonEncodedString);\n        return javaString;\n    }\n"]]}
{"hexsha": "165be4ad837d4dc31731102269d03b8d9ccf05db", "ext": "java", "lang": "Java", "content": "public class SimpleSpider {\n\t//The page number at which the program is trying to start.\n\tprivate static final int page =2376 ;\n\tpublic static void main(String[] args) {\n\t\t//HttpClient Comfigurations for time out\n\t\tRequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).setConnectionRequestTimeout(6000).setConnectTimeout(6000).build();\n\t\tCloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(globalConfig).build();\n\t\tSystem.out.println(\"Begin searching in 5 seconds\u2026\u2026\");\n\t\tfor (int i = page; i > 0; i--) {\n\t\t\t//Creating a GET request\n\t\t\tHttpGet httpGet = new HttpGet(\"http://jandan.net/ooxx/page-\" + i);\n\t\t\thttpGet.addHeader(\"User-Agent\",\"Chrome/56.0.2924.87\");\n\t\t\thttpGet.addHeader(\"Cookie\",\"_gat=1; nsfw-click-load=off; gif-click-load=on; _ga=GA1.2.1861846600.1423061484\");\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tThread.sleep(5000);\n\t\t\t\t//Sending the request\n\t\t\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\t\t\tInputStream in = response.getEntity().getContent();\n\t\t\t\tString html = Utils.convertStreamToString(in);\n\t\t\t\t//Analyzing the web contents\n\t\t\t\tnew Thread(new JianDanHtmlParser(html, i)).start();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}", "class_id": 0, "repo": "rickypeng99/Hot-girlrs-pics-seacher", "file": "SimpleSpider.java", "last_update_at": "2021-03-29T02:44:06+00:00", "question_id": "165be4ad837d4dc31731102269d03b8d9ccf05db", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SimpleSpider {\n\t//The page number at which the program is trying to start.\n\tprivate static final int page =2376 ;\n\tpublic static void main(String[] args) {\n\t\t//HttpClient Comfigurations for time out\n\t\tRequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).setConnectionRequestTimeout(6000).setConnectTimeout(6000).build();\n\t\tCloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(globalConfig).build();\n\t\tSystem.out.println(\"Begin searching in 5 seconds\u2026\u2026\");\n\t\tfor (int i = page; i > 0; i--) {\n\t\t\t//Creating a GET request\n\t\t\tHttpGet httpGet = new HttpGet(\"http://jandan.net/ooxx/page-\" + i);\n\t\t\thttpGet.addHeader(\"User-Agent\",\"Chrome/56.0.2924.87\");\n\t\t\thttpGet.addHeader(\"Cookie\",\"_gat=1; nsfw-click-load=off; gif-click-load=on; _ga=GA1.2.1861846600.1423061484\");\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tThread.sleep(5000);\n\t\t\t\t//Sending the request\n\t\t\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\t\t\tInputStream in = response.getEntity().getContent();\n\t\t\t\tString html = Utils.convertStreamToString(in);\n\t\t\t\t//Analyzing the web contents\n\t\t\t\tnew Thread(new JianDanHtmlParser(html, i)).start();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "a95d8fe653bfdab75d936ec05cd4ea7fa852d3e6", "ext": "java", "lang": "Java", "content": "public class d {\n\n    /* renamed from: a  reason: collision with root package name */\n    private String f691a;\n    private String b;\n    private Map<String, String> c;\n\n    public String a() {\n        return this.f691a;\n    }\n\n    public void a(String str) {\n        this.f691a = str;\n    }\n\n    public String b() {\n        return this.b;\n    }\n\n    public void b(String str) {\n        this.b = str;\n    }\n\n    public Map<String, String> c() {\n        return this.c;\n    }\n\n    public void a(Map<String, String> map) {\n        this.c = map;\n    }\n\n    public boolean equals(Object obj) {\n        if (!(obj instanceof d)) {\n            return false;\n        }\n        d dVar = (d) obj;\n        if (!TextUtils.equals(this.f691a, dVar.f691a) || !TextUtils.equals(this.b, dVar.b)) {\n            return false;\n        }\n        Map<String, String> map = this.c;\n        Map<String, String> map2 = dVar.c;\n        if (map == map2 || map == null || map.equals(map2)) {\n            return true;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        String str = this.f691a;\n        int i = 0;\n        int hashCode = (str != null ? str.hashCode() : 0) * 31;\n        String str2 = this.b;\n        int hashCode2 = (hashCode + (str2 != null ? str2.hashCode() : 0)) * 31;\n        Map<String, String> map = this.c;\n        if (map != null) {\n            i = map.hashCode();\n        }\n        return hashCode2 + i;\n    }\n}", "class_id": 0, "repo": "Minionguyjpro/Ghostly-Skills", "file": "sources/com/yandex/metrica/d.java", "last_update_at": "2021-11-03T14:24:37+00:00", "question_id": "a95d8fe653bfdab75d936ec05cd4ea7fa852d3e6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class d {\n    /* renamed from: a  reason: collision with root package name */\n    private String f691a;\n    private String b;\n    private Map<String, String> c;\n    public String a() {\n        return this.f691a;\n    }\n    public void a(String str) {\n        this.f691a = str;\n    }\n    public String b() {\n        return this.b;\n    }\n    public void b(String str) {\n        this.b = str;\n    }\n    public Map<String, String> c() {\n        return this.c;\n    }\n    public void a(Map<String, String> map) {\n        this.c = map;\n    }\n    public boolean equals(Object obj) {\n        if (!(obj instanceof d)) {\n            return false;\n        }\n        d dVar = (d) obj;\n        if (!TextUtils.equals(this.f691a, dVar.f691a) || !TextUtils.equals(this.b, dVar.b)) {\n            return false;\n        }\n        Map<String, String> map = this.c;\n        Map<String, String> map2 = dVar.c;\n        if (map == map2 || map == null || map.equals(map2)) {\n            return true;\n        }\n        return false;\n    }\n    public int hashCode() {\n        String str = this.f691a;\n        int i = 0;\n        int hashCode = (str != null ? str.hashCode() : 0) * 31;\n        String str2 = this.b;\n        int hashCode2 = (hashCode + (str2 != null ? str2.hashCode() : 0)) * 31;\n        Map<String, String> map = this.c;\n        if (map != null) {\n            i = map.hashCode();\n        }\n        return hashCode2 + i;\n    }\n"]]}
{"hexsha": "808dd88a9f7ffc10968ef98a648fd4967d60303d", "ext": "java", "lang": "Java", "content": "public class assembly_Task_auto \n{\n\t@Inject\n\tprivate LBR kuka_Iiwa;\n\t\n\t@Inject\n\tprivate MediaFlangeIOGroup media_Flange;\n\n\t@Inject\n\tprivate FlexFellow kuka_Ffellow;\n\t\n\t@Inject\n\tprivate Gripper gripper_1;\n\t\n\t@Inject\n\tprivate ITaskLogger logger;\n\t\n\t// Very important:\n\t@Inject\n\tprivate IApplicationData app_Data; //call the frame\n\t\n\t@Inject\n\tprivate IApplicationUI user_I; // call the diag\n\t\n\t@Inject\n\tprivate Frame frame_Kuka;\n\t\n\t@Inject\n\tprivate Robot_application_humza robo;\n\t\n\t\n\tpublic void main_App()\n\t\n\t\n\t{\n\t\t//Initialise the speed for automatic mode\n\t\t\n\t\trobo.getApplicationControl().setApplicationOverride(0.2); //Speed\n\t\tgripper_1.open_M();\n\t\tgripper_1.attachTo(kuka_Iiwa.getFlange());\n\t\t\n\t\t//Execution\n\t\t\n\t\tauto_Assem_Seq();\n\t\t\n\t\t\n\t}\n\t\n\tprivate void auto_Assem_Seq()\n\t\n\t{\n\t\tkuka_Iiwa.move(ptpHome());\n\t\thrc_Pos();\n\t\tidle_Rob();\n\t\tfh202_Assem();\n\t\thrc_Pos();\n\t\tc6_Assem();\n\t\thrc_Pos();\n\t\td6_Assem();\n\t\thrc_Pos();\n\t\td2_Assem();\n\t\thrc_Pos();\n\t\tidle_Rob();\n\t\tb6_Assem();\n\t\thrc_Pos();\n\t\tb10_Assem();\n\t\thrc_Pos();\n\t\te256_Assem();\n\t\thrc_Pos();\n\t\tm1174_Assem();\n\t\thrc_Pos();\n\t\te215_Assem();\n\t\thrc_Pos();\n\t\tidle_Rob();\n\t}\n\t\n\n\n\n\t\n\n\tpublic void fastening(ICondition start_Screw_2) {\n\t\t// TODO Auto-generated method stub\n\t\tCartesianImpedanceControlMode fastening = new CartesianImpedanceControlMode();\n\t\tfastening.parametrize(CartDOF.X).setStiffness(800.0);\n\t\tfastening.parametrize(CartDOF.Z).setStiffness(100.0);\n\t\tfastening.parametrize(CartDOF.Y).setStiffness(100.0);\n\t\tFrame fastening_Pos= app_Data.getFrame(\"/fastening_Pos\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fastening_Pos));\n\t\t\n\t\tForceCondition start_Screw = ForceCondition.createNormalForceCondition(gripper_1.getDefaultMotionFrame(),CoordinateAxis.X,60);\n\t\tIMotionContainer hand_Mani = gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n\t\tif(hand_Mani.hasFired(start_Screw))\n\t\t\n\t\t{\t\n\t\tlogger.info(\"its broken\");\n\t\tmedia_Flange.setLEDBlue(true);\n\t\t}\n\t\t\n\t\tCartesianImpedanceControlMode fastening_Op = new CartesianImpedanceControlMode();\n\t\tfastening_Op.parametrize(CartDOF.X).setStiffness(5000);\n\t\tfastening_Op.parametrize(CartDOF.Z).setStiffness(5000);\n\t\tfastening_Op.parametrize(CartDOF.Y).setStiffness(5000);\n\t\tfastening_Op.parametrize(CartDOF.C).setDamping(0.7);\n\t\tIMotionContainer fast_Screw = gripper_1.move(positionHold(fastening_Op, 50, TimeUnit.SECONDS).breakWhen(start_Screw_2));\n\t\tif(fast_Screw.hasFired(start_Screw_2))\n\t\t{\t\n\t\tlogger.info(\"it is soft again\");\n\t\tmedia_Flange.setLEDBlue(false);\n\t\t}\n\t\t\n\t\tgripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\tprivate void push_Comp()\n\t\n\t{\n\t\tCartesianImpedanceControlMode softrob_Push = new CartesianImpedanceControlMode();\n\t\tsoftrob_Push.parametrize(CartDOF.X).setStiffness(500.0);\n\t\tsoftrob_Push.parametrize(CartDOF.Y).setStiffness(500.0);\n\t\tsoftrob_Push.parametrize(CartDOF.Z).setStiffness(500.0);\n\t\tFrame safelyto_Comp_Orient= app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n\t\tFrame push_Comp_Orient= app_Data.getFrame(\"/Assembly_Table/push_Orient\").copyWithRedundancy();\n\t\tFrame push_Comp= app_Data.getFrame(\"/Assembly_Table/push_Comp\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n\t\tgripper_1.move(ptp(push_Comp_Orient));\n\t\tgripper_1.move(lin(push_Comp));\n\t\tFrame push_Comp_Child= app_Data.getFrame(\"/Assembly_Table/push_Comp/push_Lin\").copyWithRedundancy();\n\t\tgripper_1.move(lin(push_Comp_Child).setCartVelocity(100).setMode(softrob_Push));\n\t\tgripper_1.move(lin(push_Comp));\n\t\tgripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n\t\t\n\t}\n\t\n\t\n\n\t\n\tprivate void zdu_grn_Assem() {\n\n\t\tlogger.info(\"Starting Assembly task for ZDU 2.5/4AN GREEN\");\n\t\tzdu_grn_Pick();\n\t\tzdugrn_rail_Assem();\n\t}\n\t\n\t\n\n\n\tprivate void zdu_grn_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_ZPE_GRN_P = app_Data.getFrame(\"/Rack/ZPE_GRN_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_ZPE_GRN_P));\n\t\tFrame Tray_ZPE_GRN_P_1 = app_Data.getFrame(\"/Rack/ZPE_GRN_P/ZPE_GRN_P_1\").copyWithRedundancy();\n\t\t//Tray_ZPE_GRN_P.setX(Tray_ZPE_GRN_P.getX()+50);\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_ZPE_GRN_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_ZPE_GRN_P).setCartVelocity(100));\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\n\tprivate void zdugrn_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n\t\tFrame Green =orient_Assem_Pos.setX(orient_Assem_Pos.getX()-50);\n\t\tgripper_1.move(ptp(Green));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl/P1\").copyWithRedundancy();\n\t\tFrame green_Fix =fix_Assem_Pos.setX(fix_Assem_Pos.getX()-50);\n\t\tgripper_1.move(ptp(green_Fix ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\t\n\tprivate void zdu_bl_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for ZDU 2.5/4AN Blue\");\n\t\tzdu_Bl_Pick();\n\t\tzdubl_rail_Assem();\n\t}\n\t\n\t\n\t\n\t\n\n\n\tprivate void zdu_Bl_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_ZDU_BL_P = app_Data.getFrame(\"/Rack/ZDU_BL_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_ZDU_BL_P));\n\t\tFrame Tray_ZDU_BL_P_1 = app_Data.getFrame(\"/Rack/ZDU_BL_P/ZDU_BL_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_ZDU_BL_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_ZDU_BL_P).setCartVelocity(100));\n\t}\n\n\tprivate void zdubl_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_fix_zdubl\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\n\t}\n\t\n\t\n\t\n\tprivate void d6_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for D6\");\n\t\td6_Pick();\n\t\tm1174_rail_Assem();\n\t}\n\n\t\n\t\n\tprivate void d6_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_D6_P = app_Data.getFrame(\"/Rack/D6_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_D6_P));\n\t\tFrame Tray_D6_P_1 = app_Data.getFrame(\"/Rack/D6_P/D6_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_D6_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_D6_P).setCartVelocity(100));\n\t}\n\n\tprivate void b6_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for B6\");\n\t\tb6_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\t\n\t\n\tprivate void b6_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_B6_P = app_Data.getFrame(\"/Rack/B6_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_B6_P));\n\t\tFrame Tray_B6_P_1 = app_Data.getFrame(\"/Rack/B6_P/B6_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_B6_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_B6_P).setCartVelocity(100));\n\t}\n\n\tprivate void b10_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for B10\");\n\t\tb10_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\t\n\tprivate void b10_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_B10_P = app_Data.getFrame(\"/Rack/B10_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_B10_P));\n\t\tFrame Tray_B10_P_1 = app_Data.getFrame(\"/Rack/B10_P/B10_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_B10_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_B10_P).setCartVelocity(100));\n\t}\n\n\tprivate void c6_Assem() {\n\t\tlogger.info(\"Starting Assembly task for C6\");\n\t\tc6_Pick();\n\t\tm1174_rail_Assem();\n\t\t\n\t}\n\t\n\tprivate void c6_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_C6_P = app_Data.getFrame(\"/Rack/C6_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_C6_P));\n\t\tFrame Tray_C6_P_1 = app_Data.getFrame(\"/Rack/C6_P/C6_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_C6_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_C6_P).setCartVelocity(100));\n\t}\n\n\tprivate void e215_Assem() {\n\t\tlogger.info(\"Starting Assembly task for E215\");\n\t\te215_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\t\n\tprivate void e215_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_E215_P = app_Data.getFrame(\"/Rack/E215_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_E215_P));\n\t\tFrame Tray_E215_P_1 = app_Data.getFrame(\"/Rack/E215_P/E215_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\t//softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\t//softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_E215_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_E215_P).setCartVelocity(100));\n\t}\n\t\n\tprivate void e215_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\t\n\n\tprivate void e290_Assem() {\n\t\tlogger.info(\"Starting Assembly task for E290\");\n\t\te290_Pick();\n\t}\n\t\n\t\n\t\n\t\n\tprivate void e290_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_E290_P = app_Data.getFrame(\"/Rack/E290_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_E290_P));\n\t\tFrame Tray_E290_P_1 = app_Data.getFrame(\"/Rack/E290_P/E290_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_E290_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_E290_P).setCartVelocity(100));\n\t}\n\n\tprivate void e256_Assem() {\n\n\t\tlogger.info(\"Starting Assembly task for E256\");\n\t\te256_Pick();\n\t\tm1174_rail_Assem_3();\n\t\t\n\t}\n\t\n\tprivate void e256_Pick() {\n\t\n\t\tFrame Tray_E256_P = app_Data.getFrame(\"/Rack/E256_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_E256_P));\n\t\tFrame Tray_E256_P_1 = app_Data.getFrame(\"/Rack/E256_P/E256_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_E256_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_E256_P).setCartVelocity(100));\n\t}\n\n\tprivate void d2_Assem() \n\t{\n\t\tlogger.info(\"Starting Assembly task for D2\");\n\t\td2_Pick();\n\t\tm1174_rail_Assem();\n\t\t\n\t}\n\t\n\t\n\tprivate void d2_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_d2_P = app_Data.getFrame(\"/Rack/D2_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_d2_P));\n\t\tFrame Tray_d2_P_1 = app_Data.getFrame(\"/Rack/D2_P/D2_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_d2_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_d2_P).setCartVelocity(100));\n\t}\n\n\tprivate void m1174_Assem() \n\t{\n\t\tlogger.info(\"Starting Assembly task for M1174\");\n\t\tm1174_Pick();\n\t\tm1174_rail_Assem_3();\n\n\t}\n\t\n\tprivate void m1174_Pick() \n\t{\n\t\tFrame Tray_M1174_P = app_Data.getFrame(\"/Rack/M1174_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_M1174_P));\n\t\tFrame Tray_M1174_P_1 = app_Data.getFrame(\"/Rack/M1174_P/M1174_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_M1174_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_M1174_P).setCartVelocity(100));\n\t}\n\tprivate void m1174_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2\").copyWithRedundancy();\n\t\tgripper_1.move(lin(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2/rail_Orient_Large2_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\tprivate void m1174_rail_Assem_3() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n\t\tgripper_1.move(lin(orient_Assem_Pos));\n\t\tlinear_Force_3();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\tprivate void fh202_Assem() \n\t{\n\t\tlogger.info(\"Starting Assembly task for FH202A\");\n\t\tfh202_Pick();\n\t\tm1174_rail_Assem();\n\n\t}\n\tprivate void fh202_Pick()\n\t{\n\t\tFrame Tray_FH202_P = app_Data.getFrame(\"/Rack/FH202_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_FH202_P));\n\t\tFrame Tray_FH202_P_1 = app_Data.getFrame(\"/Rack/FH202_P/FH202_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_FH202_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_FH202_P).setCartVelocity(100).setMode(softMode));\n\t}\n\t\n\tpublic void shelf_position()\n\t\n\t{\n\t\tFrame Shelf_Pos= app_Data.getFrame(\"/Rack/Shelf_Pos_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Shelf_Pos));\n\t}\n\t\n\tpublic void idle_Rob()\n\t\n\t{\n\t\tlogger.info(\"Tap the robot to start the task\");\n\t\tForceCondition contact_Start = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 15);\n\t\t\n\t\tfor(;;)\n\t\t{\n\t\tmedia_Flange.setLEDBlue(true);\n\t\tIMotionContainer contactMotion_1 = gripper_1.move(linRel(0, 0, 10).setCartVelocity(100).breakWhen(contact_Start));\n\t\tIMotionContainer contactMotion_2 = gripper_1.move(linRel(0, 0, -10).setCartVelocity(100).breakWhen(contact_Start));\n\t\tif (contactMotion_1.hasFired(contact_Start)||contactMotion_2.hasFired(contact_Start))\n\t\t{\n\t\t\tmedia_Flange.setLEDBlue(false);\n\t\t\tlogger.info(\"The assembly task starts now\");\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tpublic void hrc_Pos()\n\t\n\t{\n\t\t\n\t\t\n\t\tFrame hrc_Pos= app_Data.getFrame(\"/hrc_Pos\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(hrc_Pos));\n\t}\n\t\n\tpublic void linear_Force_Shelf()\n\t\n\t{\n\t\tlogger.info(\"linear motion with force control\");\n\t\t\n\t\tForceCondition contact_Start_Pick_tr2 = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tIMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(100).breakWhen(contact_Start_Pick_tr2));\n\t\tif (contactMotion_Pick.hasFired(contact_Start_Pick_tr2))\n\t\t{\n\t\t\tlogger.info(\"The contact has occured!\");\n\t\t}\n\t}\n\t\n\tpublic void linear_Force()\n\t\n\t{\n\t\tlogger.info(\"linear motion with force control\");\n\t\t\n\t\tForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n\t\tIMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(450).breakWhen(contact_Start_Pick));\n\t\tif (contactMotion_Pick.hasFired(contact_Start_Pick))\n\t\t{\n\t\t\tlogger.info(\"The contact has occured!\");\n\t\t}\n\t}\n\tpublic void linear_Force_3()\n\t\n\t{\n\t\tlogger.info(\"linear motion with force control\");\n\t\t\n\t\tForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n\t\tIMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 800).setCartVelocity(450).breakWhen(contact_Start_Pick));\n\t\tif (contactMotion_Pick.hasFired(contact_Start_Pick))\n\t\t{\n\t\t\tlogger.info(\"The contact has occured!\");\n\t\t}\n\t}\n\tpublic void assem_Rail_ABB_M1174()\n\t{\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_M1174\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\tgripper_1.open_M();\n\t}\n\tpublic void assem_Rail_Fh202a()\n\t{\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a/fix_Pos\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\tgripper_1.open_M();\n\t}\n\t\n\t\n\tprivate void assem_Rail_mag() \n\t\n\t{\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Assem_T\").copyWithRedundancy();\n\t\t\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\t\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.ALL).setStiffness(100.0);\n\t\t\n\t\tFrame fix_Assem_Pos_mag = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_Mag\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos_mag));\n\t\t\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\t\n\t\tgripper_1.move(ptp(fix_Assem_Pos_mag).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.move(ptp(orient_Assem_Pos_A7_orient).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\tgripper_1.open_M();\n\n\n\n\t\t\n\t}\n\t\n\tpublic void p_grip_h()\n\t\n\t{\n\t\tCartesianSineImpedanceControlMode ctrl = new CartesianSineImpedanceControlMode();\n\t\tctrl.parametrize(CartDOF.X).setStiffness(300).setDamping(0.5);\n\t\tctrl.parametrize(CartDOF.Y).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(2);\n\t\tctrl.parametrize(CartDOF.Z).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(3);\n\t\t// X,Y,Z Translations 0-300\n\t\tctrl.parametrize(CartDOF.A).setStiffness(200).setDamping(0.5);\n\t\tctrl.parametrize(CartDOF.B).setStiffness(200).setDamping(0.5);\n\t\tctrl.parametrize(CartDOF.C).setStiffness(20).setDamping(0.5).setFrequency(4).setAmplitude(3);\n\t\t\n\t\tIMotionContainer positionHoldMotion=gripper_1.move(positionHold(ctrl, 2, TimeUnit.SECONDS));\n\t}\n\t\n\t\n}", "class_id": 0, "repo": "Mohammad-Shahzaib/Labyrinth-Solver-Kuka-iiwa", "file": "src/application/assembly_Task_auto.java", "last_update_at": "2021-01-22T10:12:32+00:00", "question_id": "808dd88a9f7ffc10968ef98a648fd4967d60303d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class assembly_Task_auto \n{\n\t@Inject\n\tprivate LBR kuka_Iiwa;\n\t\n\t@Inject\n\tprivate MediaFlangeIOGroup media_Flange;\n\t@Inject\n\tprivate FlexFellow kuka_Ffellow;\n\t\n\t@Inject\n\tprivate Gripper gripper_1;\n\t\n\t@Inject\n\tprivate ITaskLogger logger;\n\t\n\t// Very important:\n\t@Inject\n\tprivate IApplicationData app_Data; //call the frame\n\t\n\t@Inject\n\tprivate IApplicationUI user_I; // call the diag\n\t\n\t@Inject\n\tprivate Frame frame_Kuka;\n\t\n\t@Inject\n\tprivate Robot_application_humza robo;\n\t\n\t\n\tpublic void main_App()\n\t\n\t\n\t{\n\t\t//Initialise the speed for automatic mode\n\t\t\n\t\trobo.getApplicationControl().setApplicationOverride(0.2); //Speed\n\t\tgripper_1.open_M();\n\t\tgripper_1.attachTo(kuka_Iiwa.getFlange());\n\t\t\n\t\t//Execution\n\t\t\n\t\tauto_Assem_Seq();\n\t\t\n\t\t\n\t}\n\t\n\tprivate void auto_Assem_Seq()\n\t\n\t{\n\t\tkuka_Iiwa.move(ptpHome());\n\t\thrc_Pos();\n\t\tidle_Rob();\n\t\tfh202_Assem();\n\t\thrc_Pos();\n\t\tc6_Assem();\n\t\thrc_Pos();\n\t\td6_Assem();\n\t\thrc_Pos();\n\t\td2_Assem();\n\t\thrc_Pos();\n\t\tidle_Rob();\n\t\tb6_Assem();\n\t\thrc_Pos();\n\t\tb10_Assem();\n\t\thrc_Pos();\n\t\te256_Assem();\n\t\thrc_Pos();\n\t\tm1174_Assem();\n\t\thrc_Pos();\n\t\te215_Assem();\n\t\thrc_Pos();\n\t\tidle_Rob();\n\t}\n\t\n\t\n\tpublic void fastening(ICondition start_Screw_2) {\n\t\t// TODO Auto-generated method stub\n\t\tCartesianImpedanceControlMode fastening = new CartesianImpedanceControlMode();\n\t\tfastening.parametrize(CartDOF.X).setStiffness(800.0);\n\t\tfastening.parametrize(CartDOF.Z).setStiffness(100.0);\n\t\tfastening.parametrize(CartDOF.Y).setStiffness(100.0);\n\t\tFrame fastening_Pos= app_Data.getFrame(\"/fastening_Pos\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fastening_Pos));\n\t\t\n\t\tForceCondition start_Screw = ForceCondition.createNormalForceCondition(gripper_1.getDefaultMotionFrame(),CoordinateAxis.X,60);\n\t\tIMotionContainer hand_Mani = gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n\t\tif(hand_Mani.hasFired(start_Screw))\n\t\t\n\t\t{\t\n\t\tlogger.info(\"its broken\");\n\t\tmedia_Flange.setLEDBlue(true);\n\t\t}\n\t\t\n\t\tCartesianImpedanceControlMode fastening_Op = new CartesianImpedanceControlMode();\n\t\tfastening_Op.parametrize(CartDOF.X).setStiffness(5000);\n\t\tfastening_Op.parametrize(CartDOF.Z).setStiffness(5000);\n\t\tfastening_Op.parametrize(CartDOF.Y).setStiffness(5000);\n\t\tfastening_Op.parametrize(CartDOF.C).setDamping(0.7);\n\t\tIMotionContainer fast_Screw = gripper_1.move(positionHold(fastening_Op, 50, TimeUnit.SECONDS).breakWhen(start_Screw_2));\n\t\tif(fast_Screw.hasFired(start_Screw_2))\n\t\t{\t\n\t\tlogger.info(\"it is soft again\");\n\t\tmedia_Flange.setLEDBlue(false);\n\t\t}\n\t\t\n\t\tgripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n\t}\n\t\n\t\n\t\n\t\n\t\n\tprivate void push_Comp()\n\t\n\t{\n\t\tCartesianImpedanceControlMode softrob_Push = new CartesianImpedanceControlMode();\n\t\tsoftrob_Push.parametrize(CartDOF.X).setStiffness(500.0);\n\t\tsoftrob_Push.parametrize(CartDOF.Y).setStiffness(500.0);\n\t\tsoftrob_Push.parametrize(CartDOF.Z).setStiffness(500.0);\n\t\tFrame safelyto_Comp_Orient= app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n\t\tFrame push_Comp_Orient= app_Data.getFrame(\"/Assembly_Table/push_Orient\").copyWithRedundancy();\n\t\tFrame push_Comp= app_Data.getFrame(\"/Assembly_Table/push_Comp\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n\t\tgripper_1.move(ptp(push_Comp_Orient));\n\t\tgripper_1.move(lin(push_Comp));\n\t\tFrame push_Comp_Child= app_Data.getFrame(\"/Assembly_Table/push_Comp/push_Lin\").copyWithRedundancy();\n\t\tgripper_1.move(lin(push_Comp_Child).setCartVelocity(100).setMode(softrob_Push));\n\t\tgripper_1.move(lin(push_Comp));\n\t\tgripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n\t\t\n\t}\n\t\n\t\n\t\n\tprivate void zdu_grn_Assem() {\n\t\tlogger.info(\"Starting Assembly task for ZDU 2.5/4AN GREEN\");\n\t\tzdu_grn_Pick();\n\t\tzdugrn_rail_Assem();\n\t}\n\t\n\t\n\tprivate void zdu_grn_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_ZPE_GRN_P = app_Data.getFrame(\"/Rack/ZPE_GRN_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_ZPE_GRN_P));\n\t\tFrame Tray_ZPE_GRN_P_1 = app_Data.getFrame(\"/Rack/ZPE_GRN_P/ZPE_GRN_P_1\").copyWithRedundancy();\n\t\t//Tray_ZPE_GRN_P.setX(Tray_ZPE_GRN_P.getX()+50);\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_ZPE_GRN_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_ZPE_GRN_P).setCartVelocity(100));\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tprivate void zdugrn_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n\t\tFrame Green =orient_Assem_Pos.setX(orient_Assem_Pos.getX()-50);\n\t\tgripper_1.move(ptp(Green));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl/P1\").copyWithRedundancy();\n\t\tFrame green_Fix =fix_Assem_Pos.setX(fix_Assem_Pos.getX()-50);\n\t\tgripper_1.move(ptp(green_Fix ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\t\n\tprivate void zdu_bl_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for ZDU 2.5/4AN Blue\");\n\t\tzdu_Bl_Pick();\n\t\tzdubl_rail_Assem();\n\t}\n\t\n\t\n\t\n\t\n\tprivate void zdu_Bl_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_ZDU_BL_P = app_Data.getFrame(\"/Rack/ZDU_BL_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_ZDU_BL_P));\n\t\tFrame Tray_ZDU_BL_P_1 = app_Data.getFrame(\"/Rack/ZDU_BL_P/ZDU_BL_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_ZDU_BL_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_ZDU_BL_P).setCartVelocity(100));\n\t}\n\tprivate void zdubl_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_fix_zdubl\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\n\t}\n\t\n\t\n\t\n\tprivate void d6_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for D6\");\n\t\td6_Pick();\n\t\tm1174_rail_Assem();\n\t}\n\t\n\t\n\tprivate void d6_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_D6_P = app_Data.getFrame(\"/Rack/D6_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_D6_P));\n\t\tFrame Tray_D6_P_1 = app_Data.getFrame(\"/Rack/D6_P/D6_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_D6_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_D6_P).setCartVelocity(100));\n\t}\n\tprivate void b6_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for B6\");\n\t\tb6_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\t\n\t\n\tprivate void b6_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_B6_P = app_Data.getFrame(\"/Rack/B6_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_B6_P));\n\t\tFrame Tray_B6_P_1 = app_Data.getFrame(\"/Rack/B6_P/B6_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_B6_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_B6_P).setCartVelocity(100));\n\t}\n\tprivate void b10_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tlogger.info(\"Starting Assembly task for B10\");\n\t\tb10_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\t\n\tprivate void b10_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_B10_P = app_Data.getFrame(\"/Rack/B10_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_B10_P));\n\t\tFrame Tray_B10_P_1 = app_Data.getFrame(\"/Rack/B10_P/B10_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_B10_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_B10_P).setCartVelocity(100));\n\t}\n\tprivate void c6_Assem() {\n\t\tlogger.info(\"Starting Assembly task for C6\");\n\t\tc6_Pick();\n\t\tm1174_rail_Assem();\n\t\t\n\t}\n\t\n\tprivate void c6_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_C6_P = app_Data.getFrame(\"/Rack/C6_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_C6_P));\n\t\tFrame Tray_C6_P_1 = app_Data.getFrame(\"/Rack/C6_P/C6_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_C6_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_C6_P).setCartVelocity(100));\n\t}\n\tprivate void e215_Assem() {\n\t\tlogger.info(\"Starting Assembly task for E215\");\n\t\te215_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\t\n\tprivate void e215_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_E215_P = app_Data.getFrame(\"/Rack/E215_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_E215_P));\n\t\tFrame Tray_E215_P_1 = app_Data.getFrame(\"/Rack/E215_P/E215_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\t//softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\t//softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_E215_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_E215_P).setCartVelocity(100));\n\t}\n\t\n\tprivate void e215_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\t\n\tprivate void e290_Assem() {\n\t\tlogger.info(\"Starting Assembly task for E290\");\n\t\te290_Pick();\n\t}\n\t\n\t\n\t\n\t\n\tprivate void e290_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_E290_P = app_Data.getFrame(\"/Rack/E290_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_E290_P));\n\t\tFrame Tray_E290_P_1 = app_Data.getFrame(\"/Rack/E290_P/E290_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_E290_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_E290_P).setCartVelocity(100));\n\t}\n\tprivate void e256_Assem() {\n\t\tlogger.info(\"Starting Assembly task for E256\");\n\t\te256_Pick();\n\t\tm1174_rail_Assem_3();\n\t\t\n\t}\n\t\n\tprivate void e256_Pick() {\n\t\n\t\tFrame Tray_E256_P = app_Data.getFrame(\"/Rack/E256_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_E256_P));\n\t\tFrame Tray_E256_P_1 = app_Data.getFrame(\"/Rack/E256_P/E256_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_E256_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_E256_P).setCartVelocity(100));\n\t}\n\tprivate void d2_Assem() \n\t{\n\t\tlogger.info(\"Starting Assembly task for D2\");\n\t\td2_Pick();\n\t\tm1174_rail_Assem();\n\t\t\n\t}\n\t\n\t\n\tprivate void d2_Pick() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame Tray_d2_P = app_Data.getFrame(\"/Rack/D2_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_d2_P));\n\t\tFrame Tray_d2_P_1 = app_Data.getFrame(\"/Rack/D2_P/D2_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_d2_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_d2_P).setCartVelocity(100));\n\t}\n\tprivate void m1174_Assem() \n\t{\n\t\tlogger.info(\"Starting Assembly task for M1174\");\n\t\tm1174_Pick();\n\t\tm1174_rail_Assem_3();\n\t}\n\t\n\tprivate void m1174_Pick() \n\t{\n\t\tFrame Tray_M1174_P = app_Data.getFrame(\"/Rack/M1174_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_M1174_P));\n\t\tFrame Tray_M1174_P_1 = app_Data.getFrame(\"/Rack/M1174_P/M1174_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_M1174_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_M1174_P).setCartVelocity(100));\n\t}\n\tprivate void m1174_rail_Assem() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2\").copyWithRedundancy();\n\t\tgripper_1.move(lin(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2/rail_Orient_Large2_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\tprivate void m1174_rail_Assem_3() {\n\t\t// TODO Auto-generated method stub\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n\t\tgripper_1.move(lin(orient_Assem_Pos));\n\t\tlinear_Force_3();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tgripper_1.open_M();\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.open_M();\t\t\n\t}\n\t\n\tprivate void fh202_Assem() \n\t{\n\t\tlogger.info(\"Starting Assembly task for FH202A\");\n\t\tfh202_Pick();\n\t\tm1174_rail_Assem();\n\t}\n\tprivate void fh202_Pick()\n\t{\n\t\tFrame Tray_FH202_P = app_Data.getFrame(\"/Rack/FH202_P\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Tray_FH202_P));\n\t\tFrame Tray_FH202_P_1 = app_Data.getFrame(\"/Rack/FH202_P/FH202_P_1\").copyWithRedundancy();\n\t\t\n\t\tint stiff_Fh202 = 1000;\n\t\t\n\t\tCartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n\t\tsoftMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n\t\tsoftMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n\t\tgripper_1.move(lin(Tray_FH202_P_1).setCartVelocity(100).setMode(softMode));\n\t\tgripper_1.close_M();\n\t\tgripper_1.move(lin(Tray_FH202_P).setCartVelocity(100).setMode(softMode));\n\t}\n\t\n\tpublic void shelf_position()\n\t\n\t{\n\t\tFrame Shelf_Pos= app_Data.getFrame(\"/Rack/Shelf_Pos_1\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(Shelf_Pos));\n\t}\n\t\n\tpublic void idle_Rob()\n\t\n\t{\n\t\tlogger.info(\"Tap the robot to start the task\");\n\t\tForceCondition contact_Start = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 15);\n\t\t\n\t\tfor(;;)\n\t\t{\n\t\tmedia_Flange.setLEDBlue(true);\n\t\tIMotionContainer contactMotion_1 = gripper_1.move(linRel(0, 0, 10).setCartVelocity(100).breakWhen(contact_Start));\n\t\tIMotionContainer contactMotion_2 = gripper_1.move(linRel(0, 0, -10).setCartVelocity(100).breakWhen(contact_Start));\n\t\tif (contactMotion_1.hasFired(contact_Start)||contactMotion_2.hasFired(contact_Start))\n\t\t{\n\t\t\tmedia_Flange.setLEDBlue(false);\n\t\t\tlogger.info(\"The assembly task starts now\");\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tpublic void hrc_Pos()\n\t\n\t{\n\t\t\n\t\t\n\t\tFrame hrc_Pos= app_Data.getFrame(\"/hrc_Pos\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(hrc_Pos));\n\t}\n\t\n\tpublic void linear_Force_Shelf()\n\t\n\t{\n\t\tlogger.info(\"linear motion with force control\");\n\t\t\n\t\tForceCondition contact_Start_Pick_tr2 = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tIMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(100).breakWhen(contact_Start_Pick_tr2));\n\t\tif (contactMotion_Pick.hasFired(contact_Start_Pick_tr2))\n\t\t{\n\t\t\tlogger.info(\"The contact has occured!\");\n\t\t}\n\t}\n\t\n\tpublic void linear_Force()\n\t\n\t{\n\t\tlogger.info(\"linear motion with force control\");\n\t\t\n\t\tForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n\t\tIMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(450).breakWhen(contact_Start_Pick));\n\t\tif (contactMotion_Pick.hasFired(contact_Start_Pick))\n\t\t{\n\t\t\tlogger.info(\"The contact has occured!\");\n\t\t}\n\t}\n\tpublic void linear_Force_3()\n\t\n\t{\n\t\tlogger.info(\"linear motion with force control\");\n\t\t\n\t\tForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n\t\tIMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 800).setCartVelocity(450).breakWhen(contact_Start_Pick));\n\t\tif (contactMotion_Pick.hasFired(contact_Start_Pick))\n\t\t{\n\t\t\tlogger.info(\"The contact has occured!\");\n\t\t}\n\t}\n\tpublic void assem_Rail_ABB_M1174()\n\t{\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_M1174\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\tgripper_1.open_M();\n\t}\n\tpublic void assem_Rail_Fh202a()\n\t{\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\tint stiff_assembrail = 100;\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n\t\tsoftrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n\t\t\n\t\tFrame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a/fix_Pos\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos ));\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\tgripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\tgripper_1.open_M();\n\t}\n\t\n\t\n\tprivate void assem_Rail_mag() \n\t\n\t{\n\t\tFrame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Assem_T\").copyWithRedundancy();\n\t\t\n\t\tgripper_1.move(ptp(orient_Assem_Pos));\n\t\tlinear_Force();\n\t\t\n\t\tCartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n\t\tsoftrob.parametrize(CartDOF.ALL).setStiffness(100.0);\n\t\t\n\t\tFrame fix_Assem_Pos_mag = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_Mag\").copyWithRedundancy();\n\t\tgripper_1.move(ptp(fix_Assem_Pos_mag));\n\t\t\n\t\tForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n\t\t\n\t\tgripper_1.move(ptp(fix_Assem_Pos_mag).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\t//gripper_1.move(ptp(orient_Assem_Pos_A7_orient).setMode(softrob).breakWhen(contact_Assem_Mag));\n\t\tgripper_1.open_M();\n\t\t\n\t}\n\t\n\tpublic void p_grip_h()\n\t\n\t{\n\t\tCartesianSineImpedanceControlMode ctrl = new CartesianSineImpedanceControlMode();\n\t\tctrl.parametrize(CartDOF.X).setStiffness(300).setDamping(0.5);\n\t\tctrl.parametrize(CartDOF.Y).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(2);\n\t\tctrl.parametrize(CartDOF.Z).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(3);\n\t\t// X,Y,Z Translations 0-300\n\t\tctrl.parametrize(CartDOF.A).setStiffness(200).setDamping(0.5);\n\t\tctrl.parametrize(CartDOF.B).setStiffness(200).setDamping(0.5);\n\t\tctrl.parametrize(CartDOF.C).setStiffness(20).setDamping(0.5).setFrequency(4).setAmplitude(3);\n\t\t\n\t\tIMotionContainer positionHoldMotion=gripper_1.move(positionHold(ctrl, 2, TimeUnit.SECONDS));\n\t}\n\t\n\t\n"]]}
{"hexsha": "05c8c395b91c6ea8a0b51f65d49c4ecd0e41e210", "ext": "java", "lang": "Java", "content": "@Internal\nfinal class CurrentRowEvaluationSheet implements EvaluationSheet {\n  private final Sheet _xs;\n  private final Row _row;\n\n  CurrentRowEvaluationSheet(Sheet sheet, Row row) {\n    _xs = sheet;\n    _row = row;\n  }\n\n  Sheet getSheet() {\n    return _xs;\n  }\n\n  /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#getlastRowNum()\n   * @since POI 4.0.0\n   */\n  @Override\n  public int getLastRowNum() {\n    return _xs.getLastRowNum();\n  }\n\n  /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#isRowHidden(int)\n   * @since POI 4.1.0\n   */\n  @Override\n  public boolean isRowHidden(int rowIndex) {\n    if (_row == null) return false;\n    return _row.getZeroHeight();\n  }\n\n  @Override\n  public EvaluationCell getCell(int rowIndex, int columnIndex) {\n    if (_row == null) {\n      return null;\n    }\n    Cell cell = _row.getCell(columnIndex);\n    if (cell == null) {\n      return null;\n    }\n    return new OoxmlEvaluationCell(cell, this);\n  }\n\n  /* (non-JavaDoc), inherit JavaDoc from EvaluationSheet\n   * @since POI 3.15 beta 3\n   */\n  @Override\n  public void clearAllCachedResultValues() {\n  }\n}", "class_id": 0, "repo": "mirahbo/excel-streaming-reader", "file": "src/main/java/com/github/pjfanning/xlsx/impl/CurrentRowEvaluationSheet.java", "last_update_at": "2021-12-13T14:01:59+00:00", "question_id": "05c8c395b91c6ea8a0b51f65d49c4ecd0e41e210", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Internal\nfinal class CurrentRowEvaluationSheet implements EvaluationSheet {\n  private final Sheet _xs;\n  private final Row _row;\n  CurrentRowEvaluationSheet(Sheet sheet, Row row) {\n    _xs = sheet;\n    _row = row;\n  }\n  Sheet getSheet() {\n    return _xs;\n  }\n  /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#getlastRowNum()\n   * @since POI 4.0.0\n   */\n  @Override\n  public int getLastRowNum() {\n    return _xs.getLastRowNum();\n  }\n  /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#isRowHidden(int)\n   * @since POI 4.1.0\n   */\n  @Override\n  public boolean isRowHidden(int rowIndex) {\n    if (_row == null) return false;\n    return _row.getZeroHeight();\n  }\n  @Override\n  public EvaluationCell getCell(int rowIndex, int columnIndex) {\n    if (_row == null) {\n      return null;\n    }\n    Cell cell = _row.getCell(columnIndex);\n    if (cell == null) {\n      return null;\n    }\n    return new OoxmlEvaluationCell(cell, this);\n  }\n  /* (non-JavaDoc), inherit JavaDoc from EvaluationSheet\n   * @since POI 3.15 beta 3\n   */\n  @Override\n  public void clearAllCachedResultValues() {\n  }\n"]]}
{"hexsha": "f8859217700a688c3b89f361bb816019b9456d26", "ext": "java", "lang": "Java", "content": "public final class JoinUtils\n{\n    private JoinUtils() {}\n\n    public static List<Page> channelsToPages(List<List<Block>> channels)\n    {\n        if (channels.isEmpty()) {\n            return ImmutableList.of();\n        }\n\n        int pagesCount = channels.get(0).size();\n        ImmutableList.Builder<Page> pagesBuilder = ImmutableList.builderWithExpectedSize(pagesCount);\n        for (int pageIndex = 0; pageIndex < pagesCount; ++pageIndex) {\n            Block[] blocks = new Block[channels.size()];\n            for (int channelIndex = 0; channelIndex < blocks.length; ++channelIndex) {\n                blocks[channelIndex] = channels.get(channelIndex).get(pageIndex);\n            }\n            pagesBuilder.add(new Page(blocks));\n        }\n        return pagesBuilder.build();\n    }\n\n    public static boolean isBuildSideReplicated(JoinNode joinNode)\n    {\n        return PlanNodeSearcher.searchFrom(joinNode.getRight())\n                .recurseOnlyWhen(\n                        MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class)\n                                .or(JoinUtils::isLocalRepartitionExchange))\n                .where(JoinUtils::isRemoteReplicatedExchange)\n                .matches();\n    }\n\n    private static boolean isRemoteReplicatedExchange(PlanNode node)\n    {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == REMOTE && exchangeNode.getType() == REPLICATE;\n    }\n\n    private static boolean isLocalRepartitionExchange(PlanNode node)\n    {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == LOCAL && exchangeNode.getType() == REPARTITION;\n    }\n}", "class_id": 0, "repo": "YituHealthcare/presto", "file": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "last_update_at": "2021-09-15T06:54:35+00:00", "question_id": "f8859217700a688c3b89f361bb816019b9456d26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class JoinUtils\n{\n    private JoinUtils() {}\n    public static List<Page> channelsToPages(List<List<Block>> channels)\n    {\n        if (channels.isEmpty()) {\n            return ImmutableList.of();\n        }\n        int pagesCount = channels.get(0).size();\n        ImmutableList.Builder<Page> pagesBuilder = ImmutableList.builderWithExpectedSize(pagesCount);\n        for (int pageIndex = 0; pageIndex < pagesCount; ++pageIndex) {\n            Block[] blocks = new Block[channels.size()];\n            for (int channelIndex = 0; channelIndex < blocks.length; ++channelIndex) {\n                blocks[channelIndex] = channels.get(channelIndex).get(pageIndex);\n            }\n            pagesBuilder.add(new Page(blocks));\n        }\n        return pagesBuilder.build();\n    }\n    public static boolean isBuildSideReplicated(JoinNode joinNode)\n    {\n        return PlanNodeSearcher.searchFrom(joinNode.getRight())\n                .recurseOnlyWhen(\n                        MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class)\n                                .or(JoinUtils::isLocalRepartitionExchange))\n                .where(JoinUtils::isRemoteReplicatedExchange)\n                .matches();\n    }\n    private static boolean isRemoteReplicatedExchange(PlanNode node)\n    {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == REMOTE && exchangeNode.getType() == REPLICATE;\n    }\n    private static boolean isLocalRepartitionExchange(PlanNode node)\n    {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == LOCAL && exchangeNode.getType() == REPARTITION;\n    }\n"]]}
{"hexsha": "3467de5b9dd69d853da9674e47652781da6c0a68", "ext": "java", "lang": "Java", "content": "public class ExpressionMultiNashProb extends ExpressionQuant {\n\t\n\tprotected Expression expr;\n\n\tpublic ExpressionMultiNashProb() {\n\t\t\n\t}\n\t\n\tpublic void setExpression(Expression e) {\n\t\tthis.expr = e;\n\t}\n\t\n\tpublic Expression getExpression() {\n\t\treturn this.expr;\n\t}\n\n\t@Override\n\tpublic OpRelOpBound getRelopBoundInfo(Values constantValues) throws PrismException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isConstant() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isProposition() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Object evaluate(EvaluateContext ec) throws PrismLangException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic BigRational evaluateExact(EvaluateContext ec) throws PrismLangException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean returnsSingleValue() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Expression deepCopy() {\n\t\tExpressionMultiNashProb expr = new ExpressionMultiNashProb();\n\t\texpr.setExpression(getExpression() == null ? null : getExpression().deepCopy());\n\t\texpr.setType(type);\n\t\texpr.setPosition(this);\n\t\treturn expr;\n\t}\n\n\t@Override\n\tpublic Object accept(ASTVisitor v) throws PrismLangException {\n\t\treturn v.visit(this);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t// TODO Auto-generated method stub\n\t\tString s = \"P[\" + expr.toString() + \"]\";\n\t\treturn s;\n\t}\n\t\n}", "class_id": 0, "repo": "kushgrover/apt-vs-dift", "file": "src/prism-games/prism/src/parser/ast/ExpressionMultiNashProb.java", "last_update_at": "2021-09-08T08:42:42+00:00", "question_id": "3467de5b9dd69d853da9674e47652781da6c0a68", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExpressionMultiNashProb extends ExpressionQuant {\n\t\n\tprotected Expression expr;\n\tpublic ExpressionMultiNashProb() {\n\t\t\n\t}\n\t\n\tpublic void setExpression(Expression e) {\n\t\tthis.expr = e;\n\t}\n\t\n\tpublic Expression getExpression() {\n\t\treturn this.expr;\n\t}\n\t@Override\n\tpublic OpRelOpBound getRelopBoundInfo(Values constantValues) throws PrismException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\t@Override\n\tpublic boolean isConstant() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t@Override\n\tpublic boolean isProposition() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t@Override\n\tpublic Object evaluate(EvaluateContext ec) throws PrismLangException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\t@Override\n\tpublic BigRational evaluateExact(EvaluateContext ec) throws PrismLangException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\t@Override\n\tpublic boolean returnsSingleValue() {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n\t@Override\n\tpublic Expression deepCopy() {\n\t\tExpressionMultiNashProb expr = new ExpressionMultiNashProb();\n\t\texpr.setExpression(getExpression() == null ? null : getExpression().deepCopy());\n\t\texpr.setType(type);\n\t\texpr.setPosition(this);\n\t\treturn expr;\n\t}\n\t@Override\n\tpublic Object accept(ASTVisitor v) throws PrismLangException {\n\t\treturn v.visit(this);\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\t// TODO Auto-generated method stub\n\t\tString s = \"P[\" + expr.toString() + \"]\";\n\t\treturn s;\n\t}\n\t\n"]]}
{"hexsha": "669e310d22d7a1c8173c0b5886391f9475cf7bc7", "ext": "java", "lang": "Java", "content": "public class ConColDemoApp {\n\n\tprivate CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n\n\tpublic static void main(String[] args) {\n\n\t\tConColDemoApp obj = new ConColDemoApp();\n\t\tobj.list.add(10);\n\t\tobj.list.add(20);\n\t\tobj.list.add(30);\n\t\tSystem.out.println(obj.list);\n\n\t}\n\n}", "class_id": 0, "repo": "vamandeshmukh/cg-java-project", "file": "src/com/cg/demo/concdemo/ConColDemoApp.java", "last_update_at": "2021-03-10T08:20:41+00:00", "question_id": "669e310d22d7a1c8173c0b5886391f9475cf7bc7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConColDemoApp {\n\tprivate CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n\tpublic static void main(String[] args) {\n\t\tConColDemoApp obj = new ConColDemoApp();\n\t\tobj.list.add(10);\n\t\tobj.list.add(20);\n\t\tobj.list.add(30);\n\t\tSystem.out.println(obj.list);\n\t}\n"]]}
{"hexsha": "396fe0097ad6ee2717cc47e6dc55b22f44414219", "ext": "java", "lang": "Java", "content": "public abstract class GeometryBase extends Geometry {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private AltitudeModeEnumType altitudeMode; // default (clampToGround)\r\n\r\n    private Boolean extrude; // default (false)\r\n\r\n    private Boolean tessellate; // default (false)\r\n\r\n    private Integer drawOrder; // indicates gx:drawOrder (default = 0) for non-point geometries (line, ring, polygon)\r\n\r\n    /**\r\n     * Altitude Mode ([clampToGround], relativeToGround, absolute). If value is null\r\n     * then the default clampToGround is assumed and altitude can be ignored.\r\n     *\r\n     * @return the altitudeMode\r\n     */\r\n    @CheckForNull\r\n    public AltitudeModeEnumType getAltitudeMode() {\r\n        return altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     */\r\n    public void setAltitudeMode(AltitudeModeEnumType altitudeMode) {\r\n        this.altitudeMode = altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode to normalized AltitudeModeEnumType value or null if invalid.\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     *                     also includes gx:extensions (clampToSeaFloor and relativeToSeaFloor)\r\n     */\r\n    public void setAltitudeMode(String altitudeMode) {\r\n        this.altitudeMode = AltitudeModeEnumType.getNormalizedMode(altitudeMode);\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getExtrude() {\r\n        return extrude;\r\n    }\r\n\r\n    public void setExtrude(Boolean extrude) {\r\n        this.extrude = extrude;\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getTessellate() {\r\n        return tessellate;\r\n    }\r\n\r\n    public void setTessellate(Boolean tessellate) {\r\n        this.tessellate = tessellate;\r\n    }\r\n\r\n    public Integer getDrawOrder() {\r\n        return drawOrder;\r\n    }\r\n\r\n    public void setDrawOrder(Integer drawOrder) {\r\n        this.drawOrder = drawOrder;\r\n    }\r\n\r\n    /**\r\n     * Read data from SimpleObjectInputStream\r\n     *\r\n     * @param in SimpleObjectInputStream\r\n     * @throws IOException              if an I/O error occurs or if this input stream has reached the end.\r\n     * @throws ClassNotFoundException   if the class cannot be located\r\n     * @throws IllegalAccessException   if the class or its nullary\r\n     *                                  constructor is not accessible.\r\n     * @throws InstantiationException   if this <code>Class</code> represents an abstract class,\r\n     *                                  an interface, an array class, a primitive type, or void;\r\n     *                                  or if the class has no nullary constructor;\r\n     *                                  or if the instantiation fails for some other reason.\r\n     * @throws IllegalArgumentException if enumerated AltitudeMode value is invalid\r\n     * @see org.mitre.giscore.utils.SimpleObjectInputStream#readObject()\r\n     */\r\n    @Override\r\n    public void readData(SimpleObjectInputStream in) throws IOException,\r\n            ClassNotFoundException, InstantiationException,\r\n            IllegalAccessException {\r\n        super.readData(in);\r\n        String val = in.readString();\r\n        altitudeMode = val != null && val.length() != 0 ? AltitudeModeEnumType.valueOf(val) : null;\r\n        int mask = in.readByte();\r\n        int exMask = mask & 0x3; // extrude: 2 = null, 1 = true, 0 = false\r\n        extrude = (exMask == 0 || exMask == 0x1) ? Boolean.valueOf(exMask == 0x1) : null;\r\n        int tessMask = mask & 0x30; // tessellate: 2x = null, 1x = true, 0x = false\r\n        tessellate = (tessMask == 0 || tessMask == 0x10) ? Boolean.valueOf(tessMask == 0x10) : null;\r\n        this.drawOrder = (mask & 0x80) != 0 ? null : in.readInt();\r\n    }\r\n\r\n    /*\r\n      * (non-Javadoc)\r\n      * @see SimpleObjectOutputStream#writeObject(org.mitre.giscore.utils.IDataSerializable)\r\n      */\r\n    @Override\r\n    public void writeData(SimpleObjectOutputStream out) throws IOException {\r\n        super.writeData(out);\r\n        out.writeString(altitudeMode == null ? \"\" : altitudeMode.toString());\r\n        // write out extrude and tessellate into same byte mask field since both are Boolean fields\r\n        // with values: 0,1,null\r\n        int mask = extrude == null ? 0x2 : extrude ? 0x1 : 0;\r\n        if (tessellate == null) mask |= 0x20;\r\n        else if (tessellate) mask |= 0x10;\r\n        if (drawOrder == null) mask |= 0x80;\r\n        out.writeByte(mask);\r\n        if (drawOrder != null) {\r\n            out.writeInt(drawOrder);\r\n        }\r\n    }\r\n\r\n}", "class_id": 0, "repo": "OpenSextant/giscore", "file": "src/main/java/org/opensextant/giscore/geometry/GeometryBase.java", "last_update_at": "2021-12-08T16:19:37+00:00", "question_id": "396fe0097ad6ee2717cc47e6dc55b22f44414219", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class GeometryBase extends Geometry {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private AltitudeModeEnumType altitudeMode; // default (clampToGround)\r\n\r\n    private Boolean extrude; // default (false)\r\n\r\n    private Boolean tessellate; // default (false)\r\n\r\n    private Integer drawOrder; // indicates gx:drawOrder (default = 0) for non-point geometries (line, ring, polygon)\r\n\r\n    /**\r\n     * Altitude Mode ([clampToGround], relativeToGround, absolute). If value is null\r\n     * then the default clampToGround is assumed and altitude can be ignored.\r\n     *\r\n     * @return the altitudeMode\r\n     */\r\n    @CheckForNull\r\n    public AltitudeModeEnumType getAltitudeMode() {\r\n        return altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     */\r\n    public void setAltitudeMode(AltitudeModeEnumType altitudeMode) {\r\n        this.altitudeMode = altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode to normalized AltitudeModeEnumType value or null if invalid.\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     *                     also includes gx:extensions (clampToSeaFloor and relativeToSeaFloor)\r\n     */\r\n    public void setAltitudeMode(String altitudeMode) {\r\n        this.altitudeMode = AltitudeModeEnumType.getNormalizedMode(altitudeMode);\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getExtrude() {\r\n        return extrude;\r\n    }\r\n\r\n    public void setExtrude(Boolean extrude) {\r\n        this.extrude = extrude;\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getTessellate() {\r\n        return tessellate;\r\n    }\r\n\r\n    public void setTessellate(Boolean tessellate) {\r\n        this.tessellate = tessellate;\r\n    }\r\n\r\n    public Integer getDrawOrder() {\r\n        return drawOrder;\r\n    }\r\n\r\n    public void setDrawOrder(Integer drawOrder) {\r\n        this.drawOrder = drawOrder;\r\n    }\r\n\r\n    /**\r\n     * Read data from SimpleObjectInputStream\r\n     *\r\n     * @param in SimpleObjectInputStream\r\n     * @throws IOException              if an I/O error occurs or if this input stream has reached the end.\r\n     * @throws ClassNotFoundException   if the class cannot be located\r\n     * @throws IllegalAccessException   if the class or its nullary\r\n     *                                  constructor is not accessible.\r\n     * @throws InstantiationException   if this <code>Class</code> represents an abstract class,\r\n     *                                  an interface, an array class, a primitive type, or void;\r\n     *                                  or if the class has no nullary constructor;\r\n     *                                  or if the instantiation fails for some other reason.\r\n     * @throws IllegalArgumentException if enumerated AltitudeMode value is invalid\r\n     * @see org.mitre.giscore.utils.SimpleObjectInputStream#readObject()\r\n     */\r\n    @Override\r\n    public void readData(SimpleObjectInputStream in) throws IOException,\r\n            ClassNotFoundException, InstantiationException,\r\n            IllegalAccessException {\r\n        super.readData(in);\r\n        String val = in.readString();\r\n        altitudeMode = val != null && val.length() != 0 ? AltitudeModeEnumType.valueOf(val) : null;\r\n        int mask = in.readByte();\r\n        int exMask = mask & 0x3; // extrude: 2 = null, 1 = true, 0 = false\r\n        extrude = (exMask == 0 || exMask == 0x1) ? Boolean.valueOf(exMask == 0x1) : null;\r\n        int tessMask = mask & 0x30; // tessellate: 2x = null, 1x = true, 0x = false\r\n        tessellate = (tessMask == 0 || tessMask == 0x10) ? Boolean.valueOf(tessMask == 0x10) : null;\r\n        this.drawOrder = (mask & 0x80) != 0 ? null : in.readInt();\r\n    }\r\n\r\n    /*\r\n      * (non-Javadoc)\r\n      * @see SimpleObjectOutputStream#writeObject(org.mitre.giscore.utils.IDataSerializable)\r\n      */\r\n    @Override\r\n    public void writeData(SimpleObjectOutputStream out) throws IOException {\r\n        super.writeData(out);\r\n        out.writeString(altitudeMode == null ? \"\" : altitudeMode.toString());\r\n        // write out extrude and tessellate into same byte mask field since both are Boolean fields\r\n        // with values: 0,1,null\r\n        int mask = extrude == null ? 0x2 : extrude ? 0x1 : 0;\r\n        if (tessellate == null) mask |= 0x20;\r\n        else if (tessellate) mask |= 0x10;\r\n        if (drawOrder == null) mask |= 0x80;\r\n        out.writeByte(mask);\r\n        if (drawOrder != null) {\r\n            out.writeInt(drawOrder);\r\n        }\r\n    }\r\n\r\n"]]}
{"hexsha": "5d472b5f1430329360203403faee99d7d06a9a9e", "ext": "java", "lang": "Java", "content": "public class SupportedPointFormatsExtension extends HelloExtension {\n\n\t// DTLS-specific constants ////////////////////////////////////////\n\t\n\tprivate static final int LIST_LENGTH_BITS = 8;\n\n\tprivate static final int POINT_FORMAT_BITS = 8;\n\n\t// Members ////////////////////////////////////////////////////////\n\n\t/**\n\t * Items in here are ordered according to the client's preferences (favorite\n\t * choice first).\n\t */\n\tList<ECPointFormat> ecPointFormatList;\n\n\t// Constructors ///////////////////////////////////////////////////\n\n\tpublic SupportedPointFormatsExtension(List<ECPointFormat> ecPointFormatList) {\n\t\tsuper(ExtensionType.EC_POINT_FORMATS);\n\t\tthis.ecPointFormatList = ecPointFormatList;\n\t}\n\t\n\t// Methods ////////////////////////////////////////////////////////\n\t\n\tpublic void addECPointFormat(ECPointFormat format) {\n\t\tecPointFormatList.add(format);\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\t// fixed: type (2 bytes), length (2 bytes), list length (1 byte)\n\t\t// variable: number of point formats\n\t\treturn 5 + ecPointFormatList.size();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(super.toString());\n\t\tsb.append(\"\\t\\t\\t\\tLength: \" + (getLength() - 4) + \"\\n\");\n\t\tsb.append(\"\\t\\t\\t\\tEC point formats length: \" + (getLength() - 5) + \"\\n\");\n\t\tsb.append(\"\\t\\t\\t\\tElliptic Curves Point Formats (\" + ecPointFormatList.size() + \"):\\n\");\n\n\t\tfor (ECPointFormat format : ecPointFormatList) {\n\t\t\tsb.append(\"\\t\\t\\t\\t\\tEC point format: \" + format.toString() + \"\\n\");\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\t\n\t// Serialization //////////////////////////////////////////////////\n\t\n\t@Override\n\tpublic byte[] toByteArray() {\n\t\tDatagramWriter writer = new DatagramWriter();\n\t\twriter.writeBytes(super.toByteArray());\n\n\t\tint listLength = ecPointFormatList.size();\n\t\t// list length + list length field (1 byte)\n\t\twriter.write(listLength + 1, LENGTH_BITS);\n\t\twriter.write(listLength, LIST_LENGTH_BITS);\n\n\t\tfor (ECPointFormat format : ecPointFormatList) {\n\t\t\twriter.write(format.getId(), POINT_FORMAT_BITS);\n\t\t}\n\n\t\treturn writer.toByteArray();\n\t}\n\n\tpublic static HelloExtension fromByteArray(byte[] byteArray) {\n\t\tDatagramReader reader = new DatagramReader(byteArray);\n\n\t\tint listLength = reader.read(LIST_LENGTH_BITS);\n\n\t\tList<ECPointFormat> ecPointFormatList = new ArrayList<ECPointFormat>();\n\t\twhile (listLength > 0) {\n\t\t\tECPointFormat format = ECPointFormat.getECPointFormatById(reader.read(POINT_FORMAT_BITS));\n\t\t\tecPointFormatList.add(format);\n\t\t\t\n\t\t\t// one point format uses 1 byte\n\t\t\tlistLength -= 1;\n\t\t}\n\n\t\treturn new SupportedPointFormatsExtension(ecPointFormatList);\n\t}\n\t\n\t// EC point format Enum ///////////////////////////////////////////\n\n\t/**\n\t * See <a href=\"http://tools.ietf.org/html/rfc4492#section-5.1.2\">RFC 4492,\n\t * 5.1.2. Supported Point Formats Extension</a>.\n\t * \n\t * @author Stefan Jucker\n\t * \n\t */\n\tpublic enum ECPointFormat {\n\t\tUNCOMPRESSED(0), ANSIX962_COMPRESSED_PRIME(1), ANSIX962_COMPRESSED_CHAR2(2);\n\n\t\tprivate int id;\n\n\t\tprivate ECPointFormat(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic int getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tswitch (id) {\n\t\t\tcase 0:\n\t\t\t\treturn \"uncompressed (\" + id + \")\";\n\t\t\tcase 1:\n\t\t\t\treturn \"ansiX962_compressed_prime (\" + id + \")\";\n\t\t\tcase 2:\n\t\t\t\treturn \"ansiX962_compressed_char2 (\" + id + \")\";\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static ECPointFormat getECPointFormatById(int id) {\n\t\t\tswitch (id) {\n\t\t\tcase 0:\n\t\t\t\treturn ECPointFormat.UNCOMPRESSED;\n\t\t\tcase 1:\n\t\t\t\treturn ECPointFormat.ANSIX962_COMPRESSED_PRIME;\n\t\t\tcase 2:\n\t\t\t\treturn ECPointFormat.ANSIX962_COMPRESSED_CHAR2;\n\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t}\n\n}", "class_id": 0, "repo": "Orange-OpenSource/holico", "file": "sds/Californium/src/main/java/ch/ethz/inf/vs/californium/dtls/SupportedPointFormatsExtension.java", "last_update_at": "2021-06-22T08:52:33+00:00", "question_id": "5d472b5f1430329360203403faee99d7d06a9a9e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SupportedPointFormatsExtension extends HelloExtension {\n\t// DTLS-specific constants ////////////////////////////////////////\n\t\n\tprivate static final int LIST_LENGTH_BITS = 8;\n\tprivate static final int POINT_FORMAT_BITS = 8;\n\t// Members ////////////////////////////////////////////////////////\n\t/**\n\t * Items in here are ordered according to the client's preferences (favorite\n\t * choice first).\n\t */\n\tList<ECPointFormat> ecPointFormatList;\n\t// Constructors ///////////////////////////////////////////////////\n\tpublic SupportedPointFormatsExtension(List<ECPointFormat> ecPointFormatList) {\n\t\tsuper(ExtensionType.EC_POINT_FORMATS);\n\t\tthis.ecPointFormatList = ecPointFormatList;\n\t}\n\t\n\t// Methods ////////////////////////////////////////////////////////\n\t\n\tpublic void addECPointFormat(ECPointFormat format) {\n\t\tecPointFormatList.add(format);\n\t}\n\t@Override\n\tpublic int getLength() {\n\t\t// fixed: type (2 bytes), length (2 bytes), list length (1 byte)\n\t\t// variable: number of point formats\n\t\treturn 5 + ecPointFormatList.size();\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(super.toString());\n\t\tsb.append(\"\\t\\t\\t\\tLength: \" + (getLength() - 4) + \"\\n\");\n\t\tsb.append(\"\\t\\t\\t\\tEC point formats length: \" + (getLength() - 5) + \"\\n\");\n\t\tsb.append(\"\\t\\t\\t\\tElliptic Curves Point Formats (\" + ecPointFormatList.size() + \"):\\n\");\n\t\tfor (ECPointFormat format : ecPointFormatList) {\n\t\t\tsb.append(\"\\t\\t\\t\\t\\tEC point format: \" + format.toString() + \"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\t// Serialization //////////////////////////////////////////////////\n\t\n\t@Override\n\tpublic byte[] toByteArray() {\n\t\tDatagramWriter writer = new DatagramWriter();\n\t\twriter.writeBytes(super.toByteArray());\n\t\tint listLength = ecPointFormatList.size();\n\t\t// list length + list length field (1 byte)\n\t\twriter.write(listLength + 1, LENGTH_BITS);\n\t\twriter.write(listLength, LIST_LENGTH_BITS);\n\t\tfor (ECPointFormat format : ecPointFormatList) {\n\t\t\twriter.write(format.getId(), POINT_FORMAT_BITS);\n\t\t}\n\t\treturn writer.toByteArray();\n\t}\n\tpublic static HelloExtension fromByteArray(byte[] byteArray) {\n\t\tDatagramReader reader = new DatagramReader(byteArray);\n\t\tint listLength = reader.read(LIST_LENGTH_BITS);\n\t\tList<ECPointFormat> ecPointFormatList = new ArrayList<ECPointFormat>();\n\t\twhile (listLength > 0) {\n\t\t\tECPointFormat format = ECPointFormat.getECPointFormatById(reader.read(POINT_FORMAT_BITS));\n\t\t\tecPointFormatList.add(format);\n\t\t\t\n\t\t\t// one point format uses 1 byte\n\t\t\tlistLength -= 1;\n\t\t}\n\t\treturn new SupportedPointFormatsExtension(ecPointFormatList);\n\t}\n\t\n\t// EC point format Enum ///////////////////////////////////////////\n\t/**\n\t * See <a href=\"http://tools.ietf.org/html/rfc4492#section-5.1.2\">RFC 4492,\n\t * 5.1.2. Supported Point Formats Extension</a>.\n\t * \n\t * @author Stefan Jucker\n\t * \n\t */\n\tpublic enum ECPointFormat {\n\t\tUNCOMPRESSED(0), ANSIX962_COMPRESSED_PRIME(1), ANSIX962_COMPRESSED_CHAR2(2);\n\t\tprivate int id;\n\t\tprivate ECPointFormat(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic int getId() {\n\t\t\treturn id;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tswitch (id) {\n\t\t\tcase 0:\n\t\t\t\treturn \"uncompressed (\" + id + \")\";\n\t\t\tcase 1:\n\t\t\t\treturn \"ansiX962_compressed_prime (\" + id + \")\";\n\t\t\tcase 2:\n\t\t\t\treturn \"ansiX962_compressed_char2 (\" + id + \")\";\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static ECPointFormat getECPointFormatById(int id) {\n\t\t\tswitch (id) {\n\t\t\tcase 0:\n\t\t\t\treturn ECPointFormat.UNCOMPRESSED;\n\t\t\tcase 1:\n\t\t\t\treturn ECPointFormat.ANSIX962_COMPRESSED_PRIME;\n\t\t\tcase 2:\n\t\t\t\treturn ECPointFormat.ANSIX962_COMPRESSED_CHAR2;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "148008a50c8bbbb2285f3a440bc17c14279086c3", "ext": "java", "lang": "Java", "content": "@RunWith(JUnit4.class)\npublic class InheritanceHelperTest\n{\n\n    @Test\n    public void testEmptyChildList()\n    {\n        // If the child list is empty, all resources in the parent list must\n        // be copied to the child.\n        List<Resource> parentList = Arrays.asList(\n                Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30),\n                Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60)\n                );\n        List<Resource> childList = Collections.emptyList();\n\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(parentList, result);\n    }\n\n    @Test\n    public void testOverrides()\n    {\n        // The resource in the parent list shouldn't be added to the child\n        // list, as the child already got a similar resource\n\n        List<Resource> parentList = Arrays.asList(\n                Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30));\n\n        List<Resource> childList = Arrays.asList(\n                Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));\n\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(childList, result);\n    }\n}", "class_id": 0, "repo": "7kasper/TerrainControl", "file": "common/src/test/java/com/khorn/terraincontrol/util/helpers/InheritanceHelperTest.java", "last_update_at": "2021-06-26T00:14:52+00:00", "question_id": "148008a50c8bbbb2285f3a440bc17c14279086c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(JUnit4.class)\npublic class InheritanceHelperTest\n{\n    @Test\n    public void testEmptyChildList()\n    {\n        // If the child list is empty, all resources in the parent list must\n        // be copied to the child.\n        List<Resource> parentList = Arrays.asList(\n                Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30),\n                Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60)\n                );\n        List<Resource> childList = Collections.emptyList();\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(parentList, result);\n    }\n    @Test\n    public void testOverrides()\n    {\n        // The resource in the parent list shouldn't be added to the child\n        // list, as the child already got a similar resource\n        List<Resource> parentList = Arrays.asList(\n                Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30));\n        List<Resource> childList = Arrays.asList(\n                Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(childList, result);\n    }\n"]]}
{"hexsha": "d89d093a9df3cb37c4585f397e20182e3baca772", "ext": "java", "lang": "Java", "content": "public class Quini6Test {\n\n    @Test\n    public void testJugadorAlPasarPorPrimeraVezRecibe50000ASuCapital(){\n\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 150000);\n    }\n\n    @Test\n    public void testJugadorAlPasarPorSegundaVezRecibe30000ASuCapital(){\n\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n\n    @Test\n    public void testJugadorAlPasarPorTerceraVezNoRecibeIngresoASuCapital(){\n\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n}", "class_id": 0, "repo": "FdelMazo/TP-AlgoPoly", "file": "test/Modelo/Casilleros/Quini6Test.java", "last_update_at": "2021-11-20T18:41:38+00:00", "question_id": "d89d093a9df3cb37c4585f397e20182e3baca772", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Quini6Test {\n    @Test\n    public void testJugadorAlPasarPorPrimeraVezRecibe50000ASuCapital(){\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 150000);\n    }\n    @Test\n    public void testJugadorAlPasarPorSegundaVezRecibe30000ASuCapital(){\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n    @Test\n    public void testJugadorAlPasarPorTerceraVezNoRecibeIngresoASuCapital(){\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n"]]}
{"hexsha": "48a9c953325d8eadddafc395f69d25eaf7e14bb5", "ext": "java", "lang": "Java", "content": "public class QuadTreePool extends Pool<QuadTree> {\n\n    private QuadTreeContainer container;\n\n    public QuadTreePool(QuadTreeContainer container) {\n        super(50);\n        this.container = container;\n    }\n\n    public void freeSub(QuadTree quadTree) {\n        free(quadTree.ne);\n        free(quadTree.nw);\n        free(quadTree.se);\n        free(quadTree.sw);\n        quadTree.ne = quadTree.nw = quadTree.se = quadTree.sw = null;\n    }\n\n    public void initSubs(QuadTree quadTree) {\n        quadTree.ne = container.poolQuads.obtain();\n        quadTree.nw = container.poolQuads.obtain();\n        quadTree.se = container.poolQuads.obtain();\n        quadTree.sw = container.poolQuads.obtain();\n    }\n\n    @Override\n    protected QuadTree newObject() {\n        return new QuadTree(container);\n    }\n}", "class_id": 0, "repo": "fabiitch/NztBox", "file": "src/main/java/com/nzt/box/math/quadtree/pools/QuadTreePool.java", "last_update_at": "2021-12-10T11:26:19+00:00", "question_id": "48a9c953325d8eadddafc395f69d25eaf7e14bb5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class QuadTreePool extends Pool<QuadTree> {\n    private QuadTreeContainer container;\n    public QuadTreePool(QuadTreeContainer container) {\n        super(50);\n        this.container = container;\n    }\n    public void freeSub(QuadTree quadTree) {\n        free(quadTree.ne);\n        free(quadTree.nw);\n        free(quadTree.se);\n        free(quadTree.sw);\n        quadTree.ne = quadTree.nw = quadTree.se = quadTree.sw = null;\n    }\n    public void initSubs(QuadTree quadTree) {\n        quadTree.ne = container.poolQuads.obtain();\n        quadTree.nw = container.poolQuads.obtain();\n        quadTree.se = container.poolQuads.obtain();\n        quadTree.sw = container.poolQuads.obtain();\n    }\n    @Override\n    protected QuadTree newObject() {\n        return new QuadTree(container);\n    }\n"]]}
{"hexsha": "2ec0e02382de9a93dd698a861f3d7345f8e857b8", "ext": "java", "lang": "Java", "content": "public class LeetCode0387FirstUniqueCharacterTest {\n\n    private final static Logger logger = LoggerFactory.getLogger(LeetCode0387FirstUniqueCharacterTest.class);\n\n    /**\n     *\n     */\n    @Test\n    public void testMain() {\n        logger.debug(\"BEGIN\");\n        String data = \"lovelycomossez\";\n\n        System.out.println(firstUniqChar(data));\n        System.out.println(firstUniqCharString(data));\n\n    }\n\n    /**\n     * Return the first Uniq Char String index\n     *\n     * @param data\n     * @return\n     */\n    private int firstUniqChar(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return -1;\n        }\n\n        int retVal = -1;\n        LinkedHashMap<Character, String> retMap = new LinkedHashMap<Character, String>();\n        char[] chStr = data.toCharArray();\n\n\n        for (int i = 0; i < chStr.length; i++) {\n            if (retMap.get(chStr[i]) != null) {\n                retMap.put(chStr[i], retMap.get(chStr[i]) + \"#\" + String.valueOf(i));\n            } else {\n                retMap.put(chStr[i], String.valueOf(i));\n            }\n        }\n\n        for (Map.Entry me : retMap.entrySet()) {\n            String val = \"\" + me.getValue();\n            if (!val.contains(\"#\")) {\n                retVal = Integer.valueOf(val);\n                break;\n            }\n        }\n\n\n        return retVal;\n\n    }\n\n    /**\n     * Return the first Uniq Char String without using Map\n     * @param data\n     * @return\n     */\n    private String firstUniqCharString(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return \"\";\n        }\n\n        char[] strArray = data.toCharArray();\n        String retStr = \"\";\n\n        if (data.length() == 1) {\n            retStr = data;\n        }\n\n        for (int i = 0; i < strArray.length; i++) {\n            String valStr = Character.toString(strArray[i]);\n            String rData = data;\n            rData = data.replace(valStr, \"\");\n            rData = rData.replace(valStr.toUpperCase(Locale.ROOT), \"\");\n            rData = rData.replace(valStr.toLowerCase(Locale.ROOT), \"\");\n\n            if (rData.length() == 0) {\n                retStr = \"\";\n            } else if (rData.length() + 1 == data.length()) {\n                retStr = valStr;\n                break;\n            }\n        }\n        return retStr;\n    }\n\n}", "class_id": 0, "repo": "cwiki-us/Java-Tutorial", "file": "toolkits/codebank/src/test/java/com/ossez/toolkits/codebank/tests/leetcode/LeetCode0387FirstUniqueCharacterTest.java", "last_update_at": "2021-04-26T04:18:19+00:00", "question_id": "2ec0e02382de9a93dd698a861f3d7345f8e857b8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LeetCode0387FirstUniqueCharacterTest {\n    private final static Logger logger = LoggerFactory.getLogger(LeetCode0387FirstUniqueCharacterTest.class);\n    /**\n     *\n     */\n    @Test\n    public void testMain() {\n        logger.debug(\"BEGIN\");\n        String data = \"lovelycomossez\";\n        System.out.println(firstUniqChar(data));\n        System.out.println(firstUniqCharString(data));\n    }\n    /**\n     * Return the first Uniq Char String index\n     *\n     * @param data\n     * @return\n     */\n    private int firstUniqChar(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return -1;\n        }\n        int retVal = -1;\n        LinkedHashMap<Character, String> retMap = new LinkedHashMap<Character, String>();\n        char[] chStr = data.toCharArray();\n        for (int i = 0; i < chStr.length; i++) {\n            if (retMap.get(chStr[i]) != null) {\n                retMap.put(chStr[i], retMap.get(chStr[i]) + \"#\" + String.valueOf(i));\n            } else {\n                retMap.put(chStr[i], String.valueOf(i));\n            }\n        }\n        for (Map.Entry me : retMap.entrySet()) {\n            String val = \"\" + me.getValue();\n            if (!val.contains(\"#\")) {\n                retVal = Integer.valueOf(val);\n                break;\n            }\n        }\n        return retVal;\n    }\n    /**\n     * Return the first Uniq Char String without using Map\n     * @param data\n     * @return\n     */\n    private String firstUniqCharString(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return \"\";\n        }\n        char[] strArray = data.toCharArray();\n        String retStr = \"\";\n        if (data.length() == 1) {\n            retStr = data;\n        }\n        for (int i = 0; i < strArray.length; i++) {\n            String valStr = Character.toString(strArray[i]);\n            String rData = data;\n            rData = data.replace(valStr, \"\");\n            rData = rData.replace(valStr.toUpperCase(Locale.ROOT), \"\");\n            rData = rData.replace(valStr.toLowerCase(Locale.ROOT), \"\");\n            if (rData.length() == 0) {\n                retStr = \"\";\n            } else if (rData.length() + 1 == data.length()) {\n                retStr = valStr;\n                break;\n            }\n        }\n        return retStr;\n    }\n"]]}
{"hexsha": "c841148268d578f4c981485c7835479bf60d2d61", "ext": "java", "lang": "Java", "content": "public class CertificateExtensionAppAuthenticator implements ExtensionAppAuthenticator {\n\n  private final TokensRepository tokensRepository;\n  private final SymExtensionAppAuth symExtensionAppAuth;\n\n  public CertificateExtensionAppAuthenticator(SymConfig symConfig, TokensRepository tokensRepository) {\n    symExtensionAppAuth = new SymExtensionAppAuth(symConfig);\n    this.tokensRepository = tokensRepository;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public AppAuthResponse appAuthenticate() {\n    AppAuthResponse appAuthResponse = symExtensionAppAuth.sessionAppAuthenticate(generateAppToken());\n    if (appAuthResponse != null) {\n      tokensRepository.save(appAuthResponse);\n    }\n    return appAuthResponse;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public boolean validateTokens(String appToken, String symphonyToken) {\n    return tokensRepository.get(appToken)\n        .filter(token -> token.getSymphonyToken().equals(symphonyToken))\n        .isPresent();\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public UserInfo verifyJWT(String jwt) {\n    return symExtensionAppAuth.verifyJWT(jwt, new String[0]);\n  }\n\n  private String generateAppToken() {\n    byte[] randBytes = new byte[64];\n    new SecureRandom().nextBytes(randBytes);\n    return Hex.encodeHexString(randBytes);\n  }\n\n}", "class_id": 0, "repo": "micaste/symphony-api-client-java", "file": "symphony-bdk-legacy/symphony-bdk-bot-sdk-java/src/main/java/com/symphony/bdk/bot/sdk/symphony/authentication/CertificateExtensionAppAuthenticator.java", "last_update_at": "2021-04-22T10:57:49+00:00", "question_id": "c841148268d578f4c981485c7835479bf60d2d61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CertificateExtensionAppAuthenticator implements ExtensionAppAuthenticator {\n  private final TokensRepository tokensRepository;\n  private final SymExtensionAppAuth symExtensionAppAuth;\n  public CertificateExtensionAppAuthenticator(SymConfig symConfig, TokensRepository tokensRepository) {\n    symExtensionAppAuth = new SymExtensionAppAuth(symConfig);\n    this.tokensRepository = tokensRepository;\n  }\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public AppAuthResponse appAuthenticate() {\n    AppAuthResponse appAuthResponse = symExtensionAppAuth.sessionAppAuthenticate(generateAppToken());\n    if (appAuthResponse != null) {\n      tokensRepository.save(appAuthResponse);\n    }\n    return appAuthResponse;\n  }\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public boolean validateTokens(String appToken, String symphonyToken) {\n    return tokensRepository.get(appToken)\n        .filter(token -> token.getSymphonyToken().equals(symphonyToken))\n        .isPresent();\n  }\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public UserInfo verifyJWT(String jwt) {\n    return symExtensionAppAuth.verifyJWT(jwt, new String[0]);\n  }\n  private String generateAppToken() {\n    byte[] randBytes = new byte[64];\n    new SecureRandom().nextBytes(randBytes);\n    return Hex.encodeHexString(randBytes);\n  }\n"]]}
{"hexsha": "1818ef99173a05fb9a278b65c8a3ba47949352bd", "ext": "java", "lang": "Java", "content": "public class Timetable {\n    /**\n     * The core information of the timetable\n     */\n\n    private final String group;\n    private final String semiGroup;\n    private final int semester;\n    private List<Activity> allActivities;\n\n    /**\n     * Constructor for the timetable. It parses all the lines, storing the necessary information for the given group.\n     *\n     * @param website - a ParseURL object containing the HTML source code lines\n     * @param group   - the group number\n     * @throws IOException\n     */\n    public Timetable(ParseURL website, final String group, final String semiGroup) throws IOException {\n        this.group = group;\n        this.semiGroup = semiGroup;\n        allActivities = new ArrayList<>();\n        semester = website.getSemester();\n\n        List<String> htmlCode = website.getLines();\n\n        if (!tableExists(htmlCode, group)) {\n            throw new InvalidParameterException(\"The given URL does not contain the timetable for group \" + group);\n        }\n\n        List<String> tableOfGroup = getTableOfGroup(htmlCode, group);\n        List<List<String>> rows = divideIntoRows(tableOfGroup);\n        rows.forEach(row -> allActivities.add(processRow(row)));\n        filterActivities();\n    }\n\n    public Timetable(ParseURL website, final String group, final String semiGroup, List<String> filteredActivities)\n            throws IOException {\n        this(website, group, semiGroup);\n\n        allActivities = allActivities.stream()\n               .filter(activity -> filteredActivities.contains(activity.getNameOfActivity()))\n               .collect(Collectors.toList());\n    }\n\n    private List<String> getTableOfGroup(List<String> htmlCode, final String group) {\n        Pattern beginningOfTable = Pattern.compile(\"<table .*>\");\n        Pattern endOfTable = Pattern.compile(\"</table>\");\n\n        int wantedTable = group.charAt(group.length() - 1) - '0';\n        int indexOfBeginning = -1, indexOfEnd = -1;\n\n        for (int i = 0, foundTable = 0; i < htmlCode.size(); i++) {\n            if (foundTable < wantedTable) {\n                Matcher matcherTable = beginningOfTable.matcher(htmlCode.get(i));\n                if (matcherTable.matches()) {\n                    foundTable++;\n                    if (wantedTable == foundTable) {\n                        indexOfBeginning = i + 1;\n                    }\n                }\n            }\n\n            if (foundTable == wantedTable) {\n                Matcher matcherEndTable = endOfTable.matcher(htmlCode.get(i));\n                if (matcherEndTable.matches()) {\n                    indexOfEnd = i;\n                    break;\n                }\n            }\n        }\n\n        return htmlCode.subList(indexOfBeginning, indexOfEnd);\n    }\n\n    private List<List<String>> divideIntoRows(List<String> table) {\n        Pattern beginningOfRow = Pattern.compile(\"<tr .*>\");\n        Pattern endOfRow = Pattern.compile(\"</tr>\");\n\n        List<List<String>> rows = new ArrayList<>();\n        List<String> currentRow = new ArrayList<>();\n\n        boolean inRow = false;\n        for (String line : table) {\n            Matcher endOfRowMatcher = endOfRow.matcher(line);\n            if (endOfRowMatcher.matches()) {\n                rows.add(currentRow);\n                currentRow = new ArrayList<>();\n                inRow = false;\n            }\n\n            if (inRow) {\n                currentRow.add(line);\n            } else {\n                Matcher beginningOfRowMatcher = beginningOfRow.matcher(line);\n                if (beginningOfRowMatcher.matches()) {\n                    inRow = true;\n                }\n            }\n        }\n\n        //The first row is the header of the table. Given that it does not contain any useful\n        //information, it should be ignored\n        return rows.subList(1, rows.size());\n    }\n\n    private boolean tableExists(List<String> htmlCode, String group) {\n        Pattern groupPattern = Pattern.compile(\".*Grupa \" + group + \".*\");\n        return htmlCode.stream()\n                .anyMatch(line -> groupPattern.matcher(line).matches());\n    }\n\n    private Activity processRow(List<String> row) {\n        Activity activity = new Activity();\n        int currentColumn = 0;\n\n        for (String column : row) {\n            Pattern informationPattern = Pattern.compile(\".*>([^<]+)<.*\");\n            Matcher matcher = informationPattern.matcher(column);\n            if (matcher.find()) {\n                String information = matcher.group(1);\n                activity.setInformation(currentColumn, information);\n            }\n            currentColumn++;\n        }\n\n        return activity;\n    }\n\n    private void filterActivities() {\n        allActivities = allActivities.stream()\n                .filter(activity -> activity.isForSemiGroup(semiGroup))\n                .collect(Collectors.toList());\n    }\n\n    public List<Activity> getAllActivities() {\n        return allActivities;\n    }\n\n    public String getGroup() {\n        return group;\n    }\n\n    public String getSemiGroup() {\n        return semiGroup;\n    }\n\n    public int getSemester() {\n        return semester;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n        for (Activity activity : allActivities) {\n            output.append(activity);\n        }\n        return output.toString();\n    }\n}", "class_id": 0, "repo": "harababurel/timetable-builder", "file": "src/main/java/model/Timetable.java", "last_update_at": "2021-02-25T16:40:10+00:00", "question_id": "1818ef99173a05fb9a278b65c8a3ba47949352bd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Timetable {\n    /**\n     * The core information of the timetable\n     */\n    private final String group;\n    private final String semiGroup;\n    private final int semester;\n    private List<Activity> allActivities;\n    /**\n     * Constructor for the timetable. It parses all the lines, storing the necessary information for the given group.\n     *\n     * @param website - a ParseURL object containing the HTML source code lines\n     * @param group   - the group number\n     * @throws IOException\n     */\n    public Timetable(ParseURL website, final String group, final String semiGroup) throws IOException {\n        this.group = group;\n        this.semiGroup = semiGroup;\n        allActivities = new ArrayList<>();\n        semester = website.getSemester();\n        List<String> htmlCode = website.getLines();\n        if (!tableExists(htmlCode, group)) {\n            throw new InvalidParameterException(\"The given URL does not contain the timetable for group \" + group);\n        }\n        List<String> tableOfGroup = getTableOfGroup(htmlCode, group);\n        List<List<String>> rows = divideIntoRows(tableOfGroup);\n        rows.forEach(row -> allActivities.add(processRow(row)));\n        filterActivities();\n    }\n    public Timetable(ParseURL website, final String group, final String semiGroup, List<String> filteredActivities)\n            throws IOException {\n        this(website, group, semiGroup);\n        allActivities = allActivities.stream()\n               .filter(activity -> filteredActivities.contains(activity.getNameOfActivity()))\n               .collect(Collectors.toList());\n    }\n    private List<String> getTableOfGroup(List<String> htmlCode, final String group) {\n        Pattern beginningOfTable = Pattern.compile(\"<table .*>\");\n        Pattern endOfTable = Pattern.compile(\"</table>\");\n        int wantedTable = group.charAt(group.length() - 1) - '0';\n        int indexOfBeginning = -1, indexOfEnd = -1;\n        for (int i = 0, foundTable = 0; i < htmlCode.size(); i++) {\n            if (foundTable < wantedTable) {\n                Matcher matcherTable = beginningOfTable.matcher(htmlCode.get(i));\n                if (matcherTable.matches()) {\n                    foundTable++;\n                    if (wantedTable == foundTable) {\n                        indexOfBeginning = i + 1;\n                    }\n                }\n            }\n            if (foundTable == wantedTable) {\n                Matcher matcherEndTable = endOfTable.matcher(htmlCode.get(i));\n                if (matcherEndTable.matches()) {\n                    indexOfEnd = i;\n                    break;\n                }\n            }\n        }\n        return htmlCode.subList(indexOfBeginning, indexOfEnd);\n    }\n    private List<List<String>> divideIntoRows(List<String> table) {\n        Pattern beginningOfRow = Pattern.compile(\"<tr .*>\");\n        Pattern endOfRow = Pattern.compile(\"</tr>\");\n        List<List<String>> rows = new ArrayList<>();\n        List<String> currentRow = new ArrayList<>();\n        boolean inRow = false;\n        for (String line : table) {\n            Matcher endOfRowMatcher = endOfRow.matcher(line);\n            if (endOfRowMatcher.matches()) {\n                rows.add(currentRow);\n                currentRow = new ArrayList<>();\n                inRow = false;\n            }\n            if (inRow) {\n                currentRow.add(line);\n            } else {\n                Matcher beginningOfRowMatcher = beginningOfRow.matcher(line);\n                if (beginningOfRowMatcher.matches()) {\n                    inRow = true;\n                }\n            }\n        }\n        //The first row is the header of the table. Given that it does not contain any useful\n        //information, it should be ignored\n        return rows.subList(1, rows.size());\n    }\n    private boolean tableExists(List<String> htmlCode, String group) {\n        Pattern groupPattern = Pattern.compile(\".*Grupa \" + group + \".*\");\n        return htmlCode.stream()\n                .anyMatch(line -> groupPattern.matcher(line).matches());\n    }\n    private Activity processRow(List<String> row) {\n        Activity activity = new Activity();\n        int currentColumn = 0;\n        for (String column : row) {\n            Pattern informationPattern = Pattern.compile(\".*>([^<]+)<.*\");\n            Matcher matcher = informationPattern.matcher(column);\n            if (matcher.find()) {\n                String information = matcher.group(1);\n                activity.setInformation(currentColumn, information);\n            }\n            currentColumn++;\n        }\n        return activity;\n    }\n    private void filterActivities() {\n        allActivities = allActivities.stream()\n                .filter(activity -> activity.isForSemiGroup(semiGroup))\n                .collect(Collectors.toList());\n    }\n    public List<Activity> getAllActivities() {\n        return allActivities;\n    }\n    public String getGroup() {\n        return group;\n    }\n    public String getSemiGroup() {\n        return semiGroup;\n    }\n    public int getSemester() {\n        return semester;\n    }\n    @Override\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n        for (Activity activity : allActivities) {\n            output.append(activity);\n        }\n        return output.toString();\n    }\n"]]}
{"hexsha": "48385fa6bc6bfb5933e597d776cf834b02f5dee2", "ext": "java", "lang": "Java", "content": "public class HandsVisualization extends GenericWindow implements Visualization {\n\n    HandsRenderer renderer;\n\n    @Override\n    public void show() {\n        renderer.setSize(640, 480);\n        viewFrame.add(\"Center\", renderer);\n        viewFrame.setSize(renderer.getWidth(), renderer.getHeight());\n        viewFrame.setVisible(true);\n        new Thread(this).start();\n    }\n\n    public HandsVisualization(NiTETracker tracker, String name) {\n        super(name);\n        renderer = new HandsRenderer(tracker.getHandTracker());\n        tracker.addHandsListener(renderer);\n    }\n\n}", "class_id": 0, "repo": "isabella232/screenful-gestures", "file": "server/Screenful-GestureServer/src/screenful/gui/visualization/HandsVisualization.java", "last_update_at": "2021-11-03T17:04:01+00:00", "question_id": "48385fa6bc6bfb5933e597d776cf834b02f5dee2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HandsVisualization extends GenericWindow implements Visualization {\n    HandsRenderer renderer;\n    @Override\n    public void show() {\n        renderer.setSize(640, 480);\n        viewFrame.add(\"Center\", renderer);\n        viewFrame.setSize(renderer.getWidth(), renderer.getHeight());\n        viewFrame.setVisible(true);\n        new Thread(this).start();\n    }\n    public HandsVisualization(NiTETracker tracker, String name) {\n        super(name);\n        renderer = new HandsRenderer(tracker.getHandTracker());\n        tracker.addHandsListener(renderer);\n    }\n"]]}
{"hexsha": "e4b942f15ea71c6bd3c05404bc0adeed6fb51639", "ext": "java", "lang": "Java", "content": "public final class JobConfGenDriver {\r\n\tprivate static final Log logger = LogFactory.getLog(JobConfGenDriver.class.getName());\r\n\t\r\n\tprivate static final String METHOD_DECLARATION = \"(/\\\\*(.+?)\\\\*/)([^;]+;)\";\r\n\tprivate static final String COMMENT_PATTERN = \"(\\\\w+\\\\s*)(:)([^\\\\r\\\\n]+)\";\r\n\tprivate static final String MEMBER_PATTERN = \"([^=]=\\\\s*)(\\\"[^\\\"]+\\\")\";\r\n\t\r\n\tpublic enum PluginType {\r\n\t\tReader, Writer;\r\n\t}\r\n\t\r\n\t// Suppress default constructor for non-instantiability\r\n\tprivate JobConfGenDriver(){\r\n\t\tthrow new AssertionError();\r\n\t}\r\n\t\r\n\tpublic static void showCopyRight() {\r\n\t\tSystem.out.println(\"Welcome to using DianPing WormHole Version 0.1\");\r\n\t}\r\n\t\r\n\tpublic static List<String> getPluginDirAsList(String pluginsDirName) {\r\n\t\tList<String> pluginsList = new ArrayList<String>();\r\n\t\tString lastNameOfPluginsDirName = pluginsDirName.substring(pluginsDirName.lastIndexOf(File.separator) + 1);\r\n\t\tfor (File file : new File(pluginsDirName).listFiles()) {\r\n\t\t\tif (file.isDirectory() && file.getName().endsWith(lastNameOfPluginsDirName)) {\r\n\t\t\t\tpluginsList.add(file.getName());\r\n\t\t\t}\r\n\t\t}\r\n\t\tCollections.sort(pluginsList);\r\n\t\treturn pluginsList;\r\n\t}\r\n\t\r\n\tpublic static int showPluginsInfo(String prefixInfo, List<String> pluginsList) {\r\n\t\tint pluginsSize = pluginsList.size();\r\n\t\tint choice = -1;\r\n\t\twhile(choice  < 0 || choice > pluginsSize - 1) {\r\n\t\t\tSystem.out.println(prefixInfo);\r\n\t\t\t\r\n\t\t\tfor (int idx = 0; idx < pluginsSize; idx++) {\r\n\t\t\t\tSystem.out\r\n\t\t\t\t\t.println(String.format(\"%d\\t%s\",\r\n\t\t\t\t\t\tidx,\r\n\t\t\t\t\t\tpluginsList.get(idx).toLowerCase().replace(\"reader\", \"\")\r\n\t\t\t\t\t\t\t\t.replace(\"writer\", \"\")));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.print(String.format(\"Please choose [%d-%d]: \", 0,\r\n\t\t\t\t\tpluginsSize - 1));\r\n\t\t\ttry {\r\n\t\t\t\tchoice = Integer.parseInt(new Scanner(System.in).nextLine());\r\n\t\t\t}catch (NumberFormatException e) {\r\n\t\t\t\tSystem.out.println(\"Your chosen number is not correct. Please choose it again.\");\r\n\t\t\t\tchoice = -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn choice;\r\n\t}\r\n\t\r\n\tpublic static void generateJobConfXml() throws IOException {\r\n\t\tshowCopyRight();\r\n\t\t\r\n\t\tMap<PluginType, List<String>> pluginMap = new HashMap<PluginType, List<String>>();\r\n\t\t\r\n\t\tpluginMap.put(PluginType.Reader, getPluginDirAsList(Environment.READER_PLUGINS_DIR));\r\n\t\tpluginMap.put(PluginType.Writer, getPluginDirAsList(Environment.WRITER_PLUGINS_DIR));\r\n\t\t\r\n\t\tint readerPluginIndex = showPluginsInfo(\"WormHole Data Source: \", pluginMap.get(PluginType.Reader));\r\n\t\tint writerPluginIndex = showPluginsInfo(\"WormHole Data Destination: \", pluginMap.get(PluginType.Writer));\r\n\t\t\r\n\t\tString readerPluginName = pluginMap.get(PluginType.Reader).get(readerPluginIndex);\r\n\t\tString writerPluginName = pluginMap.get(PluginType.Writer).get(writerPluginIndex);\r\n\t\tString readerPluginPath = String.format(\"%s/%s/ParamKey.java\", \r\n\t\t\t\tEnvironment.READER_PLUGINS_DIR, readerPluginName);\r\n\t\tString writerPluginPath = String.format(\"%s/%s/ParamKey.java\", \r\n\t\t\t\tEnvironment.WRITER_PLUGINS_DIR, writerPluginName);\r\n\t\t\r\n\t\tClassNode readerClassNode = parse(readerPluginName, readerPluginPath);\r\n\t\tClassNode writerClassNode = parse(writerPluginName, writerPluginPath);\r\n\t\t\r\n\t\tString jobFileName = MessageFormat.format(\"wormhole_{0}_to_{1}_{2}.xml\", \r\n\t\t\t\treaderClassNode.getName(),\r\n\t\t\t\t\twriterClassNode.getName(),\r\n\t\t\t\t\t\tSystem.currentTimeMillis());\r\n\t\tint retStatus = generateXmlFile(readerClassNode, writerClassNode, jobFileName);\r\n\t\tif (0 == retStatus) {\r\n\t\t\tSystem.out.println(String.format(\"Create jobfile %s completed.\", jobFileName));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int generateXmlFile(ClassNode readerClassNode, ClassNode writerClassNode, String fileName) \r\n\t\t\tthrows IOException {\r\n\t\tDocument doc = DocumentHelper.createDocument();\r\n\t\tElement jobE = doc.addElement(\"job\");\r\n\t\tString jobId = readerClassNode.getName() + \"_to_\" + writerClassNode.getName() + \"_job\";\r\n\t\tjobE.addAttribute(\"id\", jobId);\r\n\t\t\r\n\t\t/* add reader part */\r\n\t\tElement readerE = jobE.addElement(\"reader\");\r\n\t\tElement pluginE = readerE.addElement(\"plugin\");\r\n\t\tpluginE.setText(readerClassNode.getName());\r\n\t\t\r\n\t\tElement tempElement = null;\r\n\r\n\t\tList<ClassMember> members = readerClassNode.getAllMembers();\r\n\t\tfor (ClassMember member : members) {\r\n\t\t\tStringBuilder command = new StringBuilder(\"\\n\");\r\n\r\n\t\t\tSet<String> set = member.getAllKeys();\r\n\t\t\tString value = \"\";\r\n\t\t\tfor (String key : set) {\r\n\t\t\t\tvalue = member.getAttr(\"default\");\r\n\t\t\t\tcommand.append(key)\r\n\t\t\t\t\t\t.append(\":\")\r\n\t\t\t\t\t\t\t.append(member.getAttr(key))\r\n\t\t\t\t\t\t\t\t.append(\"\\n\");\r\n\t\t\t}\r\n\t\t\treaderE.addComment(command.toString());\r\n\r\n\t\t\tString keyName = member.getName();\r\n\t\t\tkeyName = keyName.substring(1, keyName.length() - 1);\r\n\t\t\ttempElement = readerE.addElement(keyName);\r\n\r\n\t\t\tif (StringUtils.isEmpty(value)) {\r\n\t\t\t\tvalue = \"\";\r\n\t\t\t}\r\n\t\t\ttempElement.setText(value);\r\n\t\t}\r\n\t\t\r\n\t\t/* add writer part */\r\n\t\tElement writerE = jobE.addElement(\"writer\");\r\n\t\tpluginE = writerE.addElement(\"plugin\");\r\n\t\tpluginE.setText(writerClassNode.getName());\r\n\t\t\r\n\t\tmembers = writerClassNode.getAllMembers();\r\n\t\tfor (ClassMember member : members) {\r\n\t\t\tStringBuilder command = new StringBuilder(\"\\n\");\r\n\t\t\t\r\n\t\t\tSet<String> set = member.getAllKeys();\r\n\t\t\tString value = \"\";\r\n\t\t\tfor (String key : set) {\r\n\t\t\t\tvalue = member.getAttr(\"default\");\r\n\t\t\t\tcommand.append(key)\r\n\t\t\t\t\t\t.append(\":\").\r\n\t\t\t\t\t\t\tappend(member.getAttr(key))\r\n\t\t\t\t\t\t\t\t.append(\"\\n\");\r\n\t\t\t}\r\n\t\t\twriterE.addComment(command.toString());\r\n\r\n\t\t\tString keyName = member.getName();\r\n\t\t\tkeyName = keyName.substring(1, keyName.length() - 1);\r\n\t\t\ttempElement = writerE.addElement(keyName);\r\n\r\n\t\t\tif (!StringUtils.isBlank(value)) {\r\n\t\t\t\ttempElement.addText(value);\r\n\t\t\t}else{\r\n\t\t\t\ttempElement.addText(\"\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tXMLWriter output;\r\n        OutputFormat format = OutputFormat.createPrettyPrint();\r\n        format.setEncoding(\"UTF-8\");\r\n        output = new XMLWriter(new FileWriter(fileName), format);\r\n        output.write(doc);\r\n        output.close();\r\n        \r\n        return 0;\r\n\t}\r\n\t\r\n\tpublic static ClassNode parse(String name, String path) {\r\n\t\tString source = \"\";\r\n\t\ttry {\r\n\t\t\tsource = FileUtils.readFileToString(new File(path));\r\n\t\t} catch (IOException e) {\r\n\t\t\tlogger.error(org.apache.hadoop.util.StringUtils.stringifyException(e));\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tsource = source.substring(source.indexOf('{') + 1);\r\n\t\tsource = source.substring(0, source.lastIndexOf('}'));\r\n\t\t\r\n\t\tClassNode node = ClassNode.newInstance();\r\n\t\tnode.setName(name);\r\n\r\n\t\tPattern pattern = Pattern.compile(METHOD_DECLARATION, Pattern.DOTALL);\r\n\t\tMatcher matcher = pattern.matcher(source);\r\n\r\n\t\twhile (matcher.find()) {\r\n\t\t\t/* parse comment */\r\n\t\t\tPattern commentPattern = Pattern.compile(COMMENT_PATTERN);\r\n\t\t\tMatcher commentMatcher = commentPattern.matcher(matcher.group(1));\r\n\t\t\tif (!commentMatcher.find()) {\r\n\t\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\t\"File format error: class declaration without comment @\"\r\n\t\t\t\t\t\t\t\t+ matcher.group(1));\r\n\t\t\t}\r\n\r\n\t\t\tMap<String, String> attributes = new HashMap<String, String>();\r\n\t\t\tdo {\r\n\t\t\t\tattributes.put(commentMatcher.group(1), commentMatcher.group(3)\r\n\t\t\t\t\t\t.trim());\r\n\t\t\t} while (commentMatcher.find());\r\n\r\n\t\t\t/* add key */\r\n\t\t\tPattern memberPattern = Pattern.compile(MEMBER_PATTERN);\r\n\t\t\tMatcher memberMatcher = memberPattern.matcher(matcher.group(3));\r\n\r\n\t\t\tif (!memberMatcher.find()) {\r\n\t\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\t\"File format error: comment without member declaration @\"\r\n\t\t\t\t\t\t\t\t+ matcher.group(3));\r\n\t\t\t}\r\n\t\t\tnode.addMember(ClassNode.createMember(memberMatcher.group(2), attributes));\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n}", "class_id": 0, "repo": "kangzhenkang/wormhole", "file": "src/main/java/com/dp/nebula/wormhole/common/utils/JobConfGenDriver.java", "last_update_at": "2021-04-11T05:29:02+00:00", "question_id": "e4b942f15ea71c6bd3c05404bc0adeed6fb51639", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class JobConfGenDriver {\r\n\tprivate static final Log logger = LogFactory.getLog(JobConfGenDriver.class.getName());\r\n\t\r\n\tprivate static final String METHOD_DECLARATION = \"(/\\\\*(.+?)\\\\*/)([^;]+;)\";\r\n\tprivate static final String COMMENT_PATTERN = \"(\\\\w+\\\\s*)(:)([^\\\\r\\\\n]+)\";\r\n\tprivate static final String MEMBER_PATTERN = \"([^=]=\\\\s*)(\\\"[^\\\"]+\\\")\";\r\n\t\r\n\tpublic enum PluginType {\r\n\t\tReader, Writer;\r\n\t}\r\n\t\r\n\t// Suppress default constructor for non-instantiability\r\n\tprivate JobConfGenDriver(){\r\n\t\tthrow new AssertionError();\r\n\t}\r\n\t\r\n\tpublic static void showCopyRight() {\r\n\t\tSystem.out.println(\"Welcome to using DianPing WormHole Version 0.1\");\r\n\t}\r\n\t\r\n\tpublic static List<String> getPluginDirAsList(String pluginsDirName) {\r\n\t\tList<String> pluginsList = new ArrayList<String>();\r\n\t\tString lastNameOfPluginsDirName = pluginsDirName.substring(pluginsDirName.lastIndexOf(File.separator) + 1);\r\n\t\tfor (File file : new File(pluginsDirName).listFiles()) {\r\n\t\t\tif (file.isDirectory() && file.getName().endsWith(lastNameOfPluginsDirName)) {\r\n\t\t\t\tpluginsList.add(file.getName());\r\n\t\t\t}\r\n\t\t}\r\n\t\tCollections.sort(pluginsList);\r\n\t\treturn pluginsList;\r\n\t}\r\n\t\r\n\tpublic static int showPluginsInfo(String prefixInfo, List<String> pluginsList) {\r\n\t\tint pluginsSize = pluginsList.size();\r\n\t\tint choice = -1;\r\n\t\twhile(choice  < 0 || choice > pluginsSize - 1) {\r\n\t\t\tSystem.out.println(prefixInfo);\r\n\t\t\t\r\n\t\t\tfor (int idx = 0; idx < pluginsSize; idx++) {\r\n\t\t\t\tSystem.out\r\n\t\t\t\t\t.println(String.format(\"%d\\t%s\",\r\n\t\t\t\t\t\tidx,\r\n\t\t\t\t\t\tpluginsList.get(idx).toLowerCase().replace(\"reader\", \"\")\r\n\t\t\t\t\t\t\t\t.replace(\"writer\", \"\")));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSystem.out.print(String.format(\"Please choose [%d-%d]: \", 0,\r\n\t\t\t\t\tpluginsSize - 1));\r\n\t\t\ttry {\r\n\t\t\t\tchoice = Integer.parseInt(new Scanner(System.in).nextLine());\r\n\t\t\t}catch (NumberFormatException e) {\r\n\t\t\t\tSystem.out.println(\"Your chosen number is not correct. Please choose it again.\");\r\n\t\t\t\tchoice = -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn choice;\r\n\t}\r\n\t\r\n\tpublic static void generateJobConfXml() throws IOException {\r\n\t\tshowCopyRight();\r\n\t\t\r\n\t\tMap<PluginType, List<String>> pluginMap = new HashMap<PluginType, List<String>>();\r\n\t\t\r\n\t\tpluginMap.put(PluginType.Reader, getPluginDirAsList(Environment.READER_PLUGINS_DIR));\r\n\t\tpluginMap.put(PluginType.Writer, getPluginDirAsList(Environment.WRITER_PLUGINS_DIR));\r\n\t\t\r\n\t\tint readerPluginIndex = showPluginsInfo(\"WormHole Data Source: \", pluginMap.get(PluginType.Reader));\r\n\t\tint writerPluginIndex = showPluginsInfo(\"WormHole Data Destination: \", pluginMap.get(PluginType.Writer));\r\n\t\t\r\n\t\tString readerPluginName = pluginMap.get(PluginType.Reader).get(readerPluginIndex);\r\n\t\tString writerPluginName = pluginMap.get(PluginType.Writer).get(writerPluginIndex);\r\n\t\tString readerPluginPath = String.format(\"%s/%s/ParamKey.java\", \r\n\t\t\t\tEnvironment.READER_PLUGINS_DIR, readerPluginName);\r\n\t\tString writerPluginPath = String.format(\"%s/%s/ParamKey.java\", \r\n\t\t\t\tEnvironment.WRITER_PLUGINS_DIR, writerPluginName);\r\n\t\t\r\n\t\tClassNode readerClassNode = parse(readerPluginName, readerPluginPath);\r\n\t\tClassNode writerClassNode = parse(writerPluginName, writerPluginPath);\r\n\t\t\r\n\t\tString jobFileName = MessageFormat.format(\"wormhole_{0}_to_{1}_{2}.xml\", \r\n\t\t\t\treaderClassNode.getName(),\r\n\t\t\t\t\twriterClassNode.getName(),\r\n\t\t\t\t\t\tSystem.currentTimeMillis());\r\n\t\tint retStatus = generateXmlFile(readerClassNode, writerClassNode, jobFileName);\r\n\t\tif (0 == retStatus) {\r\n\t\t\tSystem.out.println(String.format(\"Create jobfile %s completed.\", jobFileName));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static int generateXmlFile(ClassNode readerClassNode, ClassNode writerClassNode, String fileName) \r\n\t\t\tthrows IOException {\r\n\t\tDocument doc = DocumentHelper.createDocument();\r\n\t\tElement jobE = doc.addElement(\"job\");\r\n\t\tString jobId = readerClassNode.getName() + \"_to_\" + writerClassNode.getName() + \"_job\";\r\n\t\tjobE.addAttribute(\"id\", jobId);\r\n\t\t\r\n\t\t/* add reader part */\r\n\t\tElement readerE = jobE.addElement(\"reader\");\r\n\t\tElement pluginE = readerE.addElement(\"plugin\");\r\n\t\tpluginE.setText(readerClassNode.getName());\r\n\t\t\r\n\t\tElement tempElement = null;\r\n\r\n\t\tList<ClassMember> members = readerClassNode.getAllMembers();\r\n\t\tfor (ClassMember member : members) {\r\n\t\t\tStringBuilder command = new StringBuilder(\"\\n\");\r\n\r\n\t\t\tSet<String> set = member.getAllKeys();\r\n\t\t\tString value = \"\";\r\n\t\t\tfor (String key : set) {\r\n\t\t\t\tvalue = member.getAttr(\"default\");\r\n\t\t\t\tcommand.append(key)\r\n\t\t\t\t\t\t.append(\":\")\r\n\t\t\t\t\t\t\t.append(member.getAttr(key))\r\n\t\t\t\t\t\t\t\t.append(\"\\n\");\r\n\t\t\t}\r\n\t\t\treaderE.addComment(command.toString());\r\n\r\n\t\t\tString keyName = member.getName();\r\n\t\t\tkeyName = keyName.substring(1, keyName.length() - 1);\r\n\t\t\ttempElement = readerE.addElement(keyName);\r\n\r\n\t\t\tif (StringUtils.isEmpty(value)) {\r\n\t\t\t\tvalue = \"\";\r\n\t\t\t}\r\n\t\t\ttempElement.setText(value);\r\n\t\t}\r\n\t\t\r\n\t\t/* add writer part */\r\n\t\tElement writerE = jobE.addElement(\"writer\");\r\n\t\tpluginE = writerE.addElement(\"plugin\");\r\n\t\tpluginE.setText(writerClassNode.getName());\r\n\t\t\r\n\t\tmembers = writerClassNode.getAllMembers();\r\n\t\tfor (ClassMember member : members) {\r\n\t\t\tStringBuilder command = new StringBuilder(\"\\n\");\r\n\t\t\t\r\n\t\t\tSet<String> set = member.getAllKeys();\r\n\t\t\tString value = \"\";\r\n\t\t\tfor (String key : set) {\r\n\t\t\t\tvalue = member.getAttr(\"default\");\r\n\t\t\t\tcommand.append(key)\r\n\t\t\t\t\t\t.append(\":\").\r\n\t\t\t\t\t\t\tappend(member.getAttr(key))\r\n\t\t\t\t\t\t\t\t.append(\"\\n\");\r\n\t\t\t}\r\n\t\t\twriterE.addComment(command.toString());\r\n\r\n\t\t\tString keyName = member.getName();\r\n\t\t\tkeyName = keyName.substring(1, keyName.length() - 1);\r\n\t\t\ttempElement = writerE.addElement(keyName);\r\n\r\n\t\t\tif (!StringUtils.isBlank(value)) {\r\n\t\t\t\ttempElement.addText(value);\r\n\t\t\t}else{\r\n\t\t\t\ttempElement.addText(\"\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tXMLWriter output;\r\n        OutputFormat format = OutputFormat.createPrettyPrint();\r\n        format.setEncoding(\"UTF-8\");\r\n        output = new XMLWriter(new FileWriter(fileName), format);\r\n        output.write(doc);\r\n        output.close();\r\n        \r\n        return 0;\r\n\t}\r\n\t\r\n\tpublic static ClassNode parse(String name, String path) {\r\n\t\tString source = \"\";\r\n\t\ttry {\r\n\t\t\tsource = FileUtils.readFileToString(new File(path));\r\n\t\t} catch (IOException e) {\r\n\t\t\tlogger.error(org.apache.hadoop.util.StringUtils.stringifyException(e));\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\tsource = source.substring(source.indexOf('{') + 1);\r\n\t\tsource = source.substring(0, source.lastIndexOf('}'));\r\n\t\t\r\n\t\tClassNode node = ClassNode.newInstance();\r\n\t\tnode.setName(name);\r\n\r\n\t\tPattern pattern = Pattern.compile(METHOD_DECLARATION, Pattern.DOTALL);\r\n\t\tMatcher matcher = pattern.matcher(source);\r\n\r\n\t\twhile (matcher.find()) {\r\n\t\t\t/* parse comment */\r\n\t\t\tPattern commentPattern = Pattern.compile(COMMENT_PATTERN);\r\n\t\t\tMatcher commentMatcher = commentPattern.matcher(matcher.group(1));\r\n\t\t\tif (!commentMatcher.find()) {\r\n\t\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\t\"File format error: class declaration without comment @\"\r\n\t\t\t\t\t\t\t\t+ matcher.group(1));\r\n\t\t\t}\r\n\r\n\t\t\tMap<String, String> attributes = new HashMap<String, String>();\r\n\t\t\tdo {\r\n\t\t\t\tattributes.put(commentMatcher.group(1), commentMatcher.group(3)\r\n\t\t\t\t\t\t.trim());\r\n\t\t\t} while (commentMatcher.find());\r\n\r\n\t\t\t/* add key */\r\n\t\t\tPattern memberPattern = Pattern.compile(MEMBER_PATTERN);\r\n\t\t\tMatcher memberMatcher = memberPattern.matcher(matcher.group(3));\r\n\r\n\t\t\tif (!memberMatcher.find()) {\r\n\t\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\t\"File format error: comment without member declaration @\"\r\n\t\t\t\t\t\t\t\t+ matcher.group(3));\r\n\t\t\t}\r\n\t\t\tnode.addMember(ClassNode.createMember(memberMatcher.group(2), attributes));\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n"]]}
{"hexsha": "11bd2a32cfcc0fc4457dad773f0af7c018a9725c", "ext": "java", "lang": "Java", "content": "public class h_svRenderer implements GLSurfaceView.Renderer {\n    private boolean circleShowing = false;\n\n    private int circleXstart = 0;\n    private int circleYstart = 0;\n    private int circleX = 0;\n    private int circleY = 0;\n    private float circleSize = 0;\n\n    private int width;\n    private int height;\n\n    private float onePixelWidth = 0f;\n    private float onePixelHeight = 0f;\n\n    private sv_2d_gradient sv_2d_gradient;\n    private hueBar hueBar;\n\n    private circle circle;\n    private circle selected_sv_circle;\n\n    private rect hueRect;\n    private float hueRectWidth;\n\n    private int dpi;\n\n    private float hue; public float getHue(){return hue;}\n    private float _saturation; public float getSaturation(){return _saturation;}\n    private float _value; public float getValue(){return _value;}\n\n\n    // color change task that gets ran in onSurfaceChanged\n    private boolean doSetColorJob = false;\n    private float colorJobHue;\n    private float colorJobSaturation;\n    private float colorJobValue;\n\n    public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n\tgl.glEnableClientState(GL10.GL_VERTEX_ARRAY); // enable vertex arrays\n\tgl.glEnableClientState(GL10.GL_COLOR_ARRAY); // enable color arrays\n\tgl.glShadeModel(GL10.GL_SMOOTH);\n\n        gl.glClearColor(0,0,0,0);\n    }\n\n    public void setColor(float[] color) {\n        colorJobHue = color[0];\n\tcolorJobSaturation = color[1];\n        colorJobValue = color[2];       \n\n\tdoSetColorJob = true;\n    }\n\n    public void showCircle() {\n\tcircleShowing = true;\n    }\n    public void hideCircle() {\n\tcircleShowing = false;\n    }\n\n    private boolean pointInsideMainGradient (int x, int y) {\n\tif (sv_2d_gradient == null) { \n\t    return false;\n\t}\n\n\t// left\n\tfloat left = (sv_2d_gradient.getLeft())/onePixelWidth;\n\tint leftmargin = (int)(left+(width/2))+1;\n\n\tboolean result = true;\n\n\tif ((x < leftmargin)) {\n\t    result = false;\n\t}\n\n\t\n\t// right\n\tfloat right = (sv_2d_gradient.getRight())/onePixelWidth;\n\tint rightmargin = (int) (right+(width/2));\n\n\tif ((x > rightmargin)) {\n\t    result = false;\n\t}\n\n\t// top\n\tfloat top = (sv_2d_gradient.getTop())/onePixelHeight;\n\tint topmargin = (int) Math.abs((top-(height/2)));\n\n\tif ((y < topmargin)) {\n\t    result = false;\n\t}\n\n\t// bottom \n\tfloat bottom = (sv_2d_gradient.getBottom())/onePixelHeight;\n\tint bottommargin = (int) Math.abs((bottom-(height/2)));\n\t\n\t\n\tif ((y > bottommargin)) {\n\t    result = false;\n\t}\n\t\n\treturn result;\n    }\n\n    public boolean pointInsideHueSlider (int x, int y) {\n\tif (hueRect == null) {\n\t    return false;\n\t}\n\n\t// left\n\tfloat left = (hueBar.getLeft())/onePixelWidth;\n\tint leftmargin = (int)(left+(width/2))+1;\n\n\tboolean result = true;\n\n\tif ((x < leftmargin)) {\n\t    result = false;\n\t}\n\n\t// right\n\tfloat right = (hueBar.getRight())/onePixelWidth;\n\tint rightmargin = (int) (right+(width/2));\n\n\tif ((x > rightmargin)) {\n\t    result = false;\n\t}\n\n\t// top\n\tfloat top = (hueBar.getTop())/onePixelHeight;\n\tint topmargin = (int) (top-(height/2));\n\n\tif ((y < topmargin)) {\n\t    result = false;\n\t}\n\n\t// // bottom \n\t// float bottom = (hueRect.getBottom())/onePixelHeight;\n\t// int bottommargin = (int) Math.abs((bottom-(height/2)));\n\t\n\t\n\t// if ((y > bottommargin)) {\n\t//     result = false;\n\t// }\n\t\n\treturn result;\n    } \n\n    public void startMoveCircle(float x, float y) {\n\tcircleXstart = (int) x;\n\tcircleYstart = (int) y;\n    }    \n\n    public void moveCircle(float x, float y, float size) {\n\tif (pointInsideMainGradient(circleXstart, circleYstart)) {\n\t    \n\t    circleX = (int) x;\n\t    circleY = (int) y;\n\t    circleSize =  size;\n\n\t    if (sv_2d_gradient != null) {\n\t\t// handle edges\n\n\t\t// left\n\t\tfloat left = (sv_2d_gradient.getLeft())/onePixelWidth;\n\t\tint leftmargin = (int)(left+(width/2))+1;\n\t\n\t\tif (circleX < leftmargin) {\n\t\t    circleX = (int) leftmargin;\n\t\t}\n\n\n\t\t// right\n\t\tfloat right = (sv_2d_gradient.getRight())/onePixelWidth;\n\t\tint rightmargin = (int) (right+(width/2));\n\n\t\tif (circleX > rightmargin) {\n\t\t    circleX = (int) rightmargin;\n\t\t}\n\n\t\t// top\n\t\tfloat top = (sv_2d_gradient.getTop())/onePixelHeight;\n\t\tint topmargin = (int) Math.abs((top-(height/2)));\n\n\t\tif (circleY < topmargin) {\n\t\t    circleY = (int) topmargin;\n\t\t}\n\n\t\t// bottom \n\t\tfloat bottom = (sv_2d_gradient.getBottom())/onePixelHeight;\n\t\tint bottommargin = (int) Math.abs((bottom-(height/2)));\n\n\n\t\tif (circleY > bottommargin) {\n\t\t    circleY = (int) bottommargin;\n\t\t}\n\n\t\tfloat value = (sv_2d_gradient.getValues()[circleX-leftmargin]);\n\t\tfloat saturation = (sv_2d_gradient.getSaturations()[circleY-topmargin]);\n\t\t// float hue = sv_2d_gradient.getHue();\n\n\n\t\tvalue = reverseFloatWithRange(value, 0f, 1f);\n\n\t\tif (value > 1f) {\n\t\t    value = 1f;\n\t\t}\n\n\t\tif (value < 0.0000001f) {\n\t\t    value = 0f;\n\t\t}\n\n\t\t_value = value;\n\t\t_saturation = saturation;\n\t    }\n\t} else if (pointInsideHueSlider (circleXstart, circleYstart)) {\n\n\t    // calculate new location\n\t    float left = (hueBar.getLeft())/onePixelWidth;\n\t    int leftmargin = (int)(left+(width/2))+1;\n\n\t    float right = (hueBar.getRight())/onePixelWidth;\n\t    int rightmargin = (int)(right+(width/2))+1;\n\n\t    int bottom_margin_dp = 20;\n\t    int b_px = bottom_margin_dp*(dpi/160);       \n\t    float bottom_margin = heightPxToFloat(b_px);\n\n\t    int screen_height_dp = height/(dpi/160);\n\n\t    int top_margin_dp = (screen_height_dp)-90;\n\t    int px = (top_margin_dp*(dpi/160));\n\t    float top_margin = heightPxToFloat(px);\n\n\t    float screen_width_f = floatFromPx(width, 0);\n\n\t    \n\t    float x2;\n\t    if (x<=leftmargin+1) {\n\t\tx=leftmargin+1;\n\t\tx2 = floatFromPx((int)x, 0);\n\t    } else {\n\t\tx2 = floatFromPx((int)x, 0);\n\t    }\n\t    \n\t    if (x>=rightmargin-1) {\n\t    \tx=rightmargin-1;\n\t    \tx2 = floatFromPx((int)x, 0);\n\t    } else {\n\t    \tx2 = floatFromPx((int)x, 0);\n\t    }\n\n\t    float new_left = ((-(hueRectWidth))+x2)-screen_width_f/2;\n\t    float new_top = -1f+bottom_margin;\n\t    float new_right = (((hueRectWidth))+x2)-screen_width_f/2;\n\t    float new_bottom = 1f-top_margin;\n\n\t    hueRect.setLocation(new_left, new_top, new_right, new_bottom);\n\n\t    // set hue for main gradient\n\t    float hue1 = floatFromPx((int)(x-leftmargin),0);\t   \n\n\t    hue1 = ((hue1/floatFromPx(hueBar.getWidth(),0)));\n\n\t    float hueReal = hue1*360f;\n\n\t    hueReal = reverseFloatWithRange(hueReal,0f, 360f);\n\t    \n\t    sv_2d_gradient.updateHue(hueReal);\n\n\t    // Log.i(\"DEFCOL\",\"current hue: \"+hueReal);\n\t    hue = hueReal;\n\t}\n       \n\n\n    }\n\n    private float reverseFloatWithRange (float f, float min, float max) {\n\tfloat middle;\n\n\tif (min == 0f) {\n\t    middle = max/2;\n\t} else {\n\t    middle = max/min; // (max-min)/2?\n\t}\n\t\n\tif (f > middle) {\n\t    f = f-((f-middle)*2);\n\t} else if (f < middle) {\n\t    f = f+((middle-f)*2);\n\t}\n\n\treturn f;\n    }\n\n    \n    // DRAW-DRAW-DRAW-DRAW-DRAW!! *spins in chair with pencil on head*\n    public void onDrawFrame(GL10 gl) {\n\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n\n\t// draw main box \\\\\n\tsv_2d_gradient.draw();\n\n\n\n\t// if (circleShowing == true) {\n\t//     circle.updateLocation(circleX, circleY, 13f);\n\t//     circle.draw();\n\t// }\n\n\tselected_sv_circle.updateLocation(circleX, circleY, 0.1f);\n\tselected_sv_circle.draw();\n\n\thueBar.draw();\n\thueRect.draw();\n    }\n\n    public void setDpi(int DPI) {\n\tdpi = DPI;\n    }\n    \n    public void onSurfaceChanged(GL10 gl, int _width, int _height) {\n\t// send to gl\n        gl.glViewport(0, 0, _width, _height);\n\n\t// save data in memory\n\twidth = _width;\n\theight = _height;\n\n\tonePixelWidth = (new Float(1)/new Float(width))*2;\n\tonePixelHeight = (new Float(1)/new Float(height))*2;\n\n\t// calculate top margin\n\tint top_margin_dp = 20;\n\tint px = top_margin_dp*(dpi/160);       \n\tfloat top_margin = heightPxToFloat(px);\n\n\t// calculate bottom margin\n\tint bottom_margin_dp = 100;\n\tint b_px = bottom_margin_dp*(dpi/160);       \n\tfloat bottom_margin = heightPxToFloat(b_px);\n\n\t// create gradient\n\tsv_2d_gradient = new sv_2d_gradient(gl, -0.9f, 0.9f, -1f+bottom_margin, 1f-top_margin, 250f, onePixelWidth, onePixelHeight);\n\t\n\n\t// calculate bottom margin\n\tbottom_margin_dp = 20;\n\tb_px = bottom_margin_dp*(dpi/160);       \n\tbottom_margin = heightPxToFloat(b_px);\n\n\tint screen_height_dp = height/(dpi/160);\n\n\ttop_margin_dp = (screen_height_dp)-90;\n\tpx = (top_margin_dp*(dpi/160));\n\ttop_margin = heightPxToFloat(px);\n\n\thueRectWidth = (5*onePixelWidth)/2;\n\n\t// create hue bar\n\thueBar = new hueBar(gl, -0.9f, 0.9f, -1f+bottom_margin, 1f-top_margin, onePixelWidth, onePixelHeight);\n\n\t// create circle\n\tcircle = new circle(gl, 0.5f, 0.5f, 0.5f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n\tselected_sv_circle = new circle(gl, 0.5f, 0.5f, 0.1f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n\n\t// create hueRect\n\thueRect = new rect(gl, -0.9f-(hueRectWidth), -1f+bottom_margin, -0.9f+(hueRectWidth), 1f-top_margin,  2f, onePixelWidth, onePixelHeight, width, height);\n\n\n\tif (doSetColorJob == true) {\n\t    float screen_width_f = floatFromPx(width, 0);\n\n\t    // hue\n\t    float scaledToOne = colorJobHue/360f;\n\n\t    float x3 = (scaledToOne*(hueBar.getWidth()))+((((1f-Math.abs(hueBar.getLeft())))/onePixelWidth));\n\t    x3 = reverseFloatWithRange(x3, 0f, width);\n\n\t    circleXstart = (int) (width/2);\n\t    circleYstart = (int) (height-bottom_margin);\n\t    moveCircle(x3, (height-bottom_margin), 0.5f);\n\n\t    // saturation and value\n\t    if (colorJobValue == 0f && colorJobSaturation == 0f) {\n\t\tint left_margin = (int)(((1f-Math.abs(hueBar.getLeft())))/onePixelWidth);\n\t\t\n\t\ttop_margin_dp = 20;\n\t\tpx = top_margin_dp*(dpi/160);       \n\t\ttop_margin = px;\n\n\t\tx3 = left_margin;;\n\t\tfloat y3 = top_margin+sv_2d_gradient.getHeight();\n\n\t\tcircleXstart = (int) x3+1;\n\t\tcircleYstart = (int) y3;\n\t\tmoveCircle(x3+1, y3, 0.5f);\n\t    } else {\n\n\t\ttop_margin_dp = 20;\n\t\tpx = top_margin_dp*(dpi/160);       \n\t\ttop_margin = px;\n\n\t\tscaledToOne = colorJobSaturation;\n\n\t\tint left_margin = (int)(((1f-Math.abs(hueBar.getLeft())))/onePixelWidth);\n\n\t\tx3 = (scaledToOne*(hueBar.getWidth()));\n\t\tx3 = reverseFloatWithRange(x3, 0f, hueBar.getWidth());\n\t    \n\t\tx3 += left_margin;\n\n\t\tscaledToOne = colorJobValue;\n\t\tfloat y3 = (scaledToOne*(sv_2d_gradient.getHeight()));\n\t\ty3 = reverseFloatWithRange(y3, 0f, sv_2d_gradient.getHeight());\n\n\t\ty3 += top_margin;\n\t    \n\t\t// x3 = reverseFloatWithRange(x3, 0f, width);\n\n\t\tcircleXstart = (int) x3+1;\n\t\tcircleYstart = (int) y3;\n\t\tmoveCircle(x3+1, y3, 0.5f);\n\t    }\n\t}\n\n    }\n\n    public float heightPxToFloat(int px) { // deprecated\n\tfloat f = 0.0f;\n\tif (px != 0) {\n\t    for (int i = 0; i < px; i++) {\n\t\tf += onePixelHeight;\n\t    }\n\t}\n\n\treturn f;\n    }\n  \n    public float floatFromPx (int px, int axis) {\n\tfloat result = 0f;\n\n\tif (px != 0) {\n\t    for (int i = 0; i < px; i++) {\n\t\tif (axis == 0) {\n\t\t    result += onePixelWidth;\n\t\t} else {\n\t\t    result += onePixelHeight;\n\t\t}\n\t    }\n\t}\n\n\treturn result;\n    }\n\n}", "class_id": 0, "repo": "wentam/DefCol", "file": "src/com/wentam/defcol/colorpicker/h_svRenderer.java", "last_update_at": "2021-07-03T06:47:46+00:00", "question_id": "11bd2a32cfcc0fc4457dad773f0af7c018a9725c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class h_svRenderer implements GLSurfaceView.Renderer {\n    private boolean circleShowing = false;\n    private int circleXstart = 0;\n    private int circleYstart = 0;\n    private int circleX = 0;\n    private int circleY = 0;\n    private float circleSize = 0;\n    private int width;\n    private int height;\n    private float onePixelWidth = 0f;\n    private float onePixelHeight = 0f;\n    private sv_2d_gradient sv_2d_gradient;\n    private hueBar hueBar;\n    private circle circle;\n    private circle selected_sv_circle;\n    private rect hueRect;\n    private float hueRectWidth;\n    private int dpi;\n    private float hue; public float getHue(){return hue;}\n    private float _saturation; public float getSaturation(){return _saturation;}\n    private float _value; public float getValue(){return _value;}\n    // color change task that gets ran in onSurfaceChanged\n    private boolean doSetColorJob = false;\n    private float colorJobHue;\n    private float colorJobSaturation;\n    private float colorJobValue;\n    public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n\tgl.glEnableClientState(GL10.GL_VERTEX_ARRAY); // enable vertex arrays\n\tgl.glEnableClientState(GL10.GL_COLOR_ARRAY); // enable color arrays\n\tgl.glShadeModel(GL10.GL_SMOOTH);\n        gl.glClearColor(0,0,0,0);\n    }\n    public void setColor(float[] color) {\n        colorJobHue = color[0];\n\tcolorJobSaturation = color[1];\n        colorJobValue = color[2];       \n\tdoSetColorJob = true;\n    }\n    public void showCircle() {\n\tcircleShowing = true;\n    }\n    public void hideCircle() {\n\tcircleShowing = false;\n    }\n    private boolean pointInsideMainGradient (int x, int y) {\n\tif (sv_2d_gradient == null) { \n\t    return false;\n\t}\n\t// left\n\tfloat left = (sv_2d_gradient.getLeft())/onePixelWidth;\n\tint leftmargin = (int)(left+(width/2))+1;\n\tboolean result = true;\n\tif ((x < leftmargin)) {\n\t    result = false;\n\t}\n\t\n\t// right\n\tfloat right = (sv_2d_gradient.getRight())/onePixelWidth;\n\tint rightmargin = (int) (right+(width/2));\n\tif ((x > rightmargin)) {\n\t    result = false;\n\t}\n\t// top\n\tfloat top = (sv_2d_gradient.getTop())/onePixelHeight;\n\tint topmargin = (int) Math.abs((top-(height/2)));\n\tif ((y < topmargin)) {\n\t    result = false;\n\t}\n\t// bottom \n\tfloat bottom = (sv_2d_gradient.getBottom())/onePixelHeight;\n\tint bottommargin = (int) Math.abs((bottom-(height/2)));\n\t\n\t\n\tif ((y > bottommargin)) {\n\t    result = false;\n\t}\n\t\n\treturn result;\n    }\n    public boolean pointInsideHueSlider (int x, int y) {\n\tif (hueRect == null) {\n\t    return false;\n\t}\n\t// left\n\tfloat left = (hueBar.getLeft())/onePixelWidth;\n\tint leftmargin = (int)(left+(width/2))+1;\n\tboolean result = true;\n\tif ((x < leftmargin)) {\n\t    result = false;\n\t}\n\t// right\n\tfloat right = (hueBar.getRight())/onePixelWidth;\n\tint rightmargin = (int) (right+(width/2));\n\tif ((x > rightmargin)) {\n\t    result = false;\n\t}\n\t// top\n\tfloat top = (hueBar.getTop())/onePixelHeight;\n\tint topmargin = (int) (top-(height/2));\n\tif ((y < topmargin)) {\n\t    result = false;\n\t}\n\t// // bottom \n\t// float bottom = (hueRect.getBottom())/onePixelHeight;\n\t// int bottommargin = (int) Math.abs((bottom-(height/2)));\n\t\n\t\n\t// if ((y > bottommargin)) {\n\t//     result = false;\n\t// }\n\t\n\treturn result;\n    } \n    public void startMoveCircle(float x, float y) {\n\tcircleXstart = (int) x;\n\tcircleYstart = (int) y;\n    }    \n    public void moveCircle(float x, float y, float size) {\n\tif (pointInsideMainGradient(circleXstart, circleYstart)) {\n\t    \n\t    circleX = (int) x;\n\t    circleY = (int) y;\n\t    circleSize =  size;\n\t    if (sv_2d_gradient != null) {\n\t\t// handle edges\n\t\t// left\n\t\tfloat left = (sv_2d_gradient.getLeft())/onePixelWidth;\n\t\tint leftmargin = (int)(left+(width/2))+1;\n\t\n\t\tif (circleX < leftmargin) {\n\t\t    circleX = (int) leftmargin;\n\t\t}\n\t\t// right\n\t\tfloat right = (sv_2d_gradient.getRight())/onePixelWidth;\n\t\tint rightmargin = (int) (right+(width/2));\n\t\tif (circleX > rightmargin) {\n\t\t    circleX = (int) rightmargin;\n\t\t}\n\t\t// top\n\t\tfloat top = (sv_2d_gradient.getTop())/onePixelHeight;\n\t\tint topmargin = (int) Math.abs((top-(height/2)));\n\t\tif (circleY < topmargin) {\n\t\t    circleY = (int) topmargin;\n\t\t}\n\t\t// bottom \n\t\tfloat bottom = (sv_2d_gradient.getBottom())/onePixelHeight;\n\t\tint bottommargin = (int) Math.abs((bottom-(height/2)));\n\t\tif (circleY > bottommargin) {\n\t\t    circleY = (int) bottommargin;\n\t\t}\n\t\tfloat value = (sv_2d_gradient.getValues()[circleX-leftmargin]);\n\t\tfloat saturation = (sv_2d_gradient.getSaturations()[circleY-topmargin]);\n\t\t// float hue = sv_2d_gradient.getHue();\n\t\tvalue = reverseFloatWithRange(value, 0f, 1f);\n\t\tif (value > 1f) {\n\t\t    value = 1f;\n\t\t}\n\t\tif (value < 0.0000001f) {\n\t\t    value = 0f;\n\t\t}\n\t\t_value = value;\n\t\t_saturation = saturation;\n\t    }\n\t} else if (pointInsideHueSlider (circleXstart, circleYstart)) {\n\t    // calculate new location\n\t    float left = (hueBar.getLeft())/onePixelWidth;\n\t    int leftmargin = (int)(left+(width/2))+1;\n\t    float right = (hueBar.getRight())/onePixelWidth;\n\t    int rightmargin = (int)(right+(width/2))+1;\n\t    int bottom_margin_dp = 20;\n\t    int b_px = bottom_margin_dp*(dpi/160);       \n\t    float bottom_margin = heightPxToFloat(b_px);\n\t    int screen_height_dp = height/(dpi/160);\n\t    int top_margin_dp = (screen_height_dp)-90;\n\t    int px = (top_margin_dp*(dpi/160));\n\t    float top_margin = heightPxToFloat(px);\n\t    float screen_width_f = floatFromPx(width, 0);\n\t    \n\t    float x2;\n\t    if (x<=leftmargin+1) {\n\t\tx=leftmargin+1;\n\t\tx2 = floatFromPx((int)x, 0);\n\t    } else {\n\t\tx2 = floatFromPx((int)x, 0);\n\t    }\n\t    \n\t    if (x>=rightmargin-1) {\n\t    \tx=rightmargin-1;\n\t    \tx2 = floatFromPx((int)x, 0);\n\t    } else {\n\t    \tx2 = floatFromPx((int)x, 0);\n\t    }\n\t    float new_left = ((-(hueRectWidth))+x2)-screen_width_f/2;\n\t    float new_top = -1f+bottom_margin;\n\t    float new_right = (((hueRectWidth))+x2)-screen_width_f/2;\n\t    float new_bottom = 1f-top_margin;\n\t    hueRect.setLocation(new_left, new_top, new_right, new_bottom);\n\t    // set hue for main gradient\n\t    float hue1 = floatFromPx((int)(x-leftmargin),0);\t   \n\t    hue1 = ((hue1/floatFromPx(hueBar.getWidth(),0)));\n\t    float hueReal = hue1*360f;\n\t    hueReal = reverseFloatWithRange(hueReal,0f, 360f);\n\t    \n\t    sv_2d_gradient.updateHue(hueReal);\n\t    // Log.i(\"DEFCOL\",\"current hue: \"+hueReal);\n\t    hue = hueReal;\n\t}\n    }\n    private float reverseFloatWithRange (float f, float min, float max) {\n\tfloat middle;\n\tif (min == 0f) {\n\t    middle = max/2;\n\t} else {\n\t    middle = max/min; // (max-min)/2?\n\t}\n\t\n\tif (f > middle) {\n\t    f = f-((f-middle)*2);\n\t} else if (f < middle) {\n\t    f = f+((middle-f)*2);\n\t}\n\treturn f;\n    }\n    // DRAW-DRAW-DRAW-DRAW-DRAW!! *spins in chair with pencil on head*\n    public void onDrawFrame(GL10 gl) {\n\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n\t// draw main box \\\\\n\tsv_2d_gradient.draw();\n\t// if (circleShowing == true) {\n\t//     circle.updateLocation(circleX, circleY, 13f);\n\t//     circle.draw();\n\t// }\n\tselected_sv_circle.updateLocation(circleX, circleY, 0.1f);\n\tselected_sv_circle.draw();\n\thueBar.draw();\n\thueRect.draw();\n    }\n    public void setDpi(int DPI) {\n\tdpi = DPI;\n    }\n    public void onSurfaceChanged(GL10 gl, int _width, int _height) {\n\t// send to gl\n        gl.glViewport(0, 0, _width, _height);\n\t// save data in memory\n\twidth = _width;\n\theight = _height;\n\tonePixelWidth = (new Float(1)/new Float(width))*2;\n\tonePixelHeight = (new Float(1)/new Float(height))*2;\n\t// calculate top margin\n\tint top_margin_dp = 20;\n\tint px = top_margin_dp*(dpi/160);       \n\tfloat top_margin = heightPxToFloat(px);\n\t// calculate bottom margin\n\tint bottom_margin_dp = 100;\n\tint b_px = bottom_margin_dp*(dpi/160);       \n\tfloat bottom_margin = heightPxToFloat(b_px);\n\t// create gradient\n\tsv_2d_gradient = new sv_2d_gradient(gl, -0.9f, 0.9f, -1f+bottom_margin, 1f-top_margin, 250f, onePixelWidth, onePixelHeight);\n\t\n\t// calculate bottom margin\n\tbottom_margin_dp = 20;\n\tb_px = bottom_margin_dp*(dpi/160);       \n\tbottom_margin = heightPxToFloat(b_px);\n\tint screen_height_dp = height/(dpi/160);\n\ttop_margin_dp = (screen_height_dp)-90;\n\tpx = (top_margin_dp*(dpi/160));\n\ttop_margin = heightPxToFloat(px);\n\thueRectWidth = (5*onePixelWidth)/2;\n\t// create hue bar\n\thueBar = new hueBar(gl, -0.9f, 0.9f, -1f+bottom_margin, 1f-top_margin, onePixelWidth, onePixelHeight);\n\t// create circle\n\tcircle = new circle(gl, 0.5f, 0.5f, 0.5f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n\tselected_sv_circle = new circle(gl, 0.5f, 0.5f, 0.1f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n\t// create hueRect\n\thueRect = new rect(gl, -0.9f-(hueRectWidth), -1f+bottom_margin, -0.9f+(hueRectWidth), 1f-top_margin,  2f, onePixelWidth, onePixelHeight, width, height);\n\tif (doSetColorJob == true) {\n\t    float screen_width_f = floatFromPx(width, 0);\n\t    // hue\n\t    float scaledToOne = colorJobHue/360f;\n\t    float x3 = (scaledToOne*(hueBar.getWidth()))+((((1f-Math.abs(hueBar.getLeft())))/onePixelWidth));\n\t    x3 = reverseFloatWithRange(x3, 0f, width);\n\t    circleXstart = (int) (width/2);\n\t    circleYstart = (int) (height-bottom_margin);\n\t    moveCircle(x3, (height-bottom_margin), 0.5f);\n\t    // saturation and value\n\t    if (colorJobValue == 0f && colorJobSaturation == 0f) {\n\t\tint left_margin = (int)(((1f-Math.abs(hueBar.getLeft())))/onePixelWidth);\n\t\t\n\t\ttop_margin_dp = 20;\n\t\tpx = top_margin_dp*(dpi/160);       \n\t\ttop_margin = px;\n\t\tx3 = left_margin;;\n\t\tfloat y3 = top_margin+sv_2d_gradient.getHeight();\n\t\tcircleXstart = (int) x3+1;\n\t\tcircleYstart = (int) y3;\n\t\tmoveCircle(x3+1, y3, 0.5f);\n\t    } else {\n\t\ttop_margin_dp = 20;\n\t\tpx = top_margin_dp*(dpi/160);       \n\t\ttop_margin = px;\n\t\tscaledToOne = colorJobSaturation;\n\t\tint left_margin = (int)(((1f-Math.abs(hueBar.getLeft())))/onePixelWidth);\n\t\tx3 = (scaledToOne*(hueBar.getWidth()));\n\t\tx3 = reverseFloatWithRange(x3, 0f, hueBar.getWidth());\n\t    \n\t\tx3 += left_margin;\n\t\tscaledToOne = colorJobValue;\n\t\tfloat y3 = (scaledToOne*(sv_2d_gradient.getHeight()));\n\t\ty3 = reverseFloatWithRange(y3, 0f, sv_2d_gradient.getHeight());\n\t\ty3 += top_margin;\n\t    \n\t\t// x3 = reverseFloatWithRange(x3, 0f, width);\n\t\tcircleXstart = (int) x3+1;\n\t\tcircleYstart = (int) y3;\n\t\tmoveCircle(x3+1, y3, 0.5f);\n\t    }\n\t}\n    }\n    public float heightPxToFloat(int px) { // deprecated\n\tfloat f = 0.0f;\n\tif (px != 0) {\n\t    for (int i = 0; i < px; i++) {\n\t\tf += onePixelHeight;\n\t    }\n\t}\n\treturn f;\n    }\n    public float floatFromPx (int px, int axis) {\n\tfloat result = 0f;\n\tif (px != 0) {\n\t    for (int i = 0; i < px; i++) {\n\t\tif (axis == 0) {\n\t\t    result += onePixelWidth;\n\t\t} else {\n\t\t    result += onePixelHeight;\n\t\t}\n\t    }\n\t}\n\treturn result;\n    }\n"]]}
{"hexsha": "ee7e106a17a6d3c50b58c0f6591bc9a924d1b4d4", "ext": "java", "lang": "Java", "content": "@Entity\n@EntityListeners(AuditingEntityListener.class)\n@TypeDef(name = \"pgsql_enum\", typeClass = PostgreSQLEnumType.class)\n@Table(name = \"test_item\", schema = \"public\")\npublic class TestItem implements Serializable {\n\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\n\t@Column(name = \"item_id\")\n\tprivate Long itemId;\n\n\t@Column(name = \"uuid\")\n\tprivate String uuid;\n\n\t@Column(name = \"name\", length = 256)\n\tprivate String name;\n\n\t@Column(name = \"code_ref\")\n\tprivate String codeRef;\n\n\t@Enumerated(EnumType.STRING)\n\t@Type(type = \"pqsql_enum\")\n\t@Column(name = \"type\", nullable = false)\n\tprivate TestItemTypeEnum type;\n\n\t@Column(name = \"start_time\", nullable = false)\n\tprivate LocalDateTime startTime;\n\n\t@Column(name = \"description\")\n\tprivate String description;\n\n\t@Column(name = \"launch_id\", nullable = false)\n\tprivate Long launchId;\n\n\t@LastModifiedDate\n\t@Column(name = \"last_modified\", nullable = false)\n\tprivate LocalDateTime lastModified;\n\n\t@ElementCollection(fetch = FetchType.EAGER)\n\t@CollectionTable(name = \"parameter\", joinColumns = @JoinColumn(name = \"item_id\"))\n\t@Fetch(FetchMode.SUBSELECT)\n\tprivate Set<Parameter> parameters = Sets.newHashSet();\n\n\t@Column(name = \"unique_id\", nullable = false, length = 256)\n\tprivate String uniqueId;\n\n\t@Column(name = \"test_case_id\")\n\tprivate String testCaseId;\n\n\t@Column(name = \"test_case_hash\")\n\tprivate Integer testCaseHash;\n\n\t@OneToMany(mappedBy = \"testItem\", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)\n\t@Fetch(FetchMode.SUBSELECT)\n\tprivate Set<ItemAttribute> attributes = Sets.newHashSet();\n\n\t@OneToMany(mappedBy = \"testItem\", fetch = FetchType.LAZY, orphanRemoval = true)\n\tprivate Set<Log> logs = Sets.newHashSet();\n\n\t@Column(name = \"path\", nullable = false, columnDefinition = \"ltree\")\n\t@Type(type = \"com.epam.ta.reportportal.entity.LTreeType\")\n\tprivate String path;\n\n\t@Column(name = \"retry_of\", precision = 64)\n\tprivate Long retryOf;\n\n\t@Column(name = \"parent_id\")\n\tprivate Long parentId;\n\n\t@OneToOne(cascade = CascadeType.ALL, mappedBy = \"testItem\")\n\tprivate TestItemResults itemResults;\n\n\t@OneToMany(mappedBy = \"testItem\", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, fetch = FetchType.LAZY)\n\t@OrderBy(value = \"pattern_id\")\n\t@Fetch(FetchMode.SUBSELECT)\n\tprivate Set<PatternTemplateTestItem> patternTemplateTestItems = Sets.newLinkedHashSet();\n\n\t@Column(name = \"has_children\")\n\tprivate boolean hasChildren;\n\n\t@Column(name = \"has_retries\")\n\tprivate boolean hasRetries;\n\n\t@Column(name = \"has_stats\")\n\tprivate boolean hasStats;\n\n\tpublic TestItem() {\n\t}\n\n\tpublic TestItem(Long id) {\n\t\tthis.itemId = id;\n\t}\n\n\tpublic TestItem(Long itemId, String name, TestItemTypeEnum type, LocalDateTime startTime, String description,\n\t\t\tLocalDateTime lastModified, String uniqueId, boolean hasChildren, boolean hasRetries, boolean hasStats) {\n\t\tthis.itemId = itemId;\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.startTime = startTime;\n\t\tthis.description = description;\n\t\tthis.lastModified = lastModified;\n\t\tthis.uniqueId = uniqueId;\n\t\tthis.hasChildren = hasChildren;\n\t\tthis.hasRetries = hasRetries;\n\t}\n\n\tpublic Set<ItemAttribute> getAttributes() {\n\t\treturn attributes;\n\t}\n\n\tpublic void setAttributes(Set<ItemAttribute> tags) {\n\t\tthis.attributes.clear();\n\t\tthis.attributes.addAll(tags);\n\t}\n\n\tpublic Set<Log> getLogs() {\n\t\treturn logs;\n\t}\n\n\tpublic void setLogs(Set<Log> logs) {\n\t\tthis.logs.clear();\n\t\tthis.logs.addAll(logs);\n\t}\n\n\tpublic void addLog(Log log) {\n\t\tlogs.add(log);\n\t}\n\n\tpublic Long getItemId() {\n\t\treturn itemId;\n\t}\n\n\tpublic void setItemId(Long itemId) {\n\t\tthis.itemId = itemId;\n\t}\n\n\tpublic String getUuid() {\n\t\treturn uuid;\n\t}\n\n\tpublic void setUuid(String uuid) {\n\t\tthis.uuid = uuid;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getCodeRef() {\n\t\treturn codeRef;\n\t}\n\n\tpublic void setCodeRef(String codeRef) {\n\t\tthis.codeRef = codeRef;\n\t}\n\n\tpublic TestItemTypeEnum getType() {\n\t\treturn type;\n\t}\n\n\tpublic void setType(TestItemTypeEnum type) {\n\t\tthis.type = type;\n\t}\n\n\tpublic LocalDateTime getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic void setStartTime(LocalDateTime startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\n\tpublic LocalDateTime getLastModified() {\n\t\treturn lastModified;\n\t}\n\n\tpublic void setLastModified(LocalDateTime lastModified) {\n\t\tthis.lastModified = lastModified;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic Set<Parameter> getParameters() {\n\t\treturn parameters;\n\t}\n\n\tpublic void setParameters(Set<Parameter> parameters) {\n\t\tthis.parameters = parameters;\n\t}\n\n\tpublic String getUniqueId() {\n\t\treturn uniqueId;\n\t}\n\n\tpublic void setUniqueId(String uniqueId) {\n\t\tthis.uniqueId = uniqueId;\n\t}\n\n\tpublic String getTestCaseId() {\n\t\treturn testCaseId;\n\t}\n\n\tpublic void setTestCaseId(String testCaseId) {\n\t\tthis.testCaseId = testCaseId;\n\t}\n\n\tpublic Integer getTestCaseHash() {\n\t\treturn testCaseHash;\n\t}\n\n\tpublic void setTestCaseHash(Integer testCaseHash) {\n\t\tthis.testCaseHash = testCaseHash;\n\t}\n\n\tpublic Long getLaunchId() {\n\t\treturn launchId;\n\t}\n\n\tpublic void setLaunchId(Long launchId) {\n\t\tthis.launchId = launchId;\n\t}\n\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\tpublic void setPath(String path) {\n\t\tthis.path = path;\n\t}\n\n\tpublic Long getRetryOf() {\n\t\treturn retryOf;\n\t}\n\n\tpublic void setRetryOf(Long retryOf) {\n\t\tthis.retryOf = retryOf;\n\t}\n\n\tpublic Long getParentId() {\n\t\treturn parentId;\n\t}\n\n\tpublic void setParentId(Long parentId) {\n\t\tthis.parentId = parentId;\n\t}\n\n\tpublic TestItemResults getItemResults() {\n\t\treturn itemResults;\n\t}\n\n\tpublic void setItemResults(TestItemResults itemResults) {\n\t\tthis.itemResults = itemResults;\n\t}\n\n\tpublic boolean isHasChildren() {\n\t\treturn hasChildren;\n\t}\n\n\tpublic void setHasChildren(boolean hasChildren) {\n\t\tthis.hasChildren = hasChildren;\n\t}\n\n\tpublic Set<PatternTemplateTestItem> getPatternTemplateTestItems() {\n\t\treturn patternTemplateTestItems;\n\t}\n\n\tpublic void setPatternTemplateTestItems(Set<PatternTemplateTestItem> patternTemplateTestItems) {\n\t\tthis.patternTemplateTestItems = patternTemplateTestItems;\n\t}\n\n\tpublic boolean isHasRetries() {\n\t\treturn hasRetries;\n\t}\n\n\tpublic void setHasRetries(boolean hasRetries) {\n\t\tthis.hasRetries = hasRetries;\n\t}\n\n\tpublic boolean isHasStats() {\n\t\treturn hasStats;\n\t}\n\n\tpublic void setHasStats(boolean hasStats) {\n\t\tthis.hasStats = hasStats;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tTestItem testItem = (TestItem) o;\n\t\treturn Objects.equals(itemId, testItem.itemId) && Objects.equals(name, testItem.name) && Objects.equals(codeRef, testItem.codeRef)\n\t\t\t\t&& type == testItem.type && Objects.equals(uniqueId, testItem.uniqueId) && Objects.equals(testCaseId, testItem.testCaseId)\n\t\t\t\t&& Objects.equals(testCaseHash, testItem.testCaseHash) && Objects.equals(path, testItem.path) && Objects.equals(retryOf,\n\t\t\t\ttestItem.retryOf\n\t\t);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(itemId, name, codeRef, type, uniqueId, testCaseId, testCaseHash, path, retryOf);\n\t}\n}", "class_id": 0, "repo": "santhoskumara/commons-dao", "file": "src/main/java/com/epam/ta/reportportal/entity/item/TestItem.java", "last_update_at": "2021-04-13T08:46:19+00:00", "question_id": "ee7e106a17a6d3c50b58c0f6591bc9a924d1b4d4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@EntityListeners(AuditingEntityListener.class)\n@TypeDef(name = \"pgsql_enum\", typeClass = PostgreSQLEnumType.class)\n@Table(name = \"test_item\", schema = \"public\")\npublic class TestItem implements Serializable {\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\n\t@Column(name = \"item_id\")\n\tprivate Long itemId;\n\t@Column(name = \"uuid\")\n\tprivate String uuid;\n\t@Column(name = \"name\", length = 256)\n\tprivate String name;\n\t@Column(name = \"code_ref\")\n\tprivate String codeRef;\n\t@Enumerated(EnumType.STRING)\n\t@Type(type = \"pqsql_enum\")\n\t@Column(name = \"type\", nullable = false)\n\tprivate TestItemTypeEnum type;\n\t@Column(name = \"start_time\", nullable = false)\n\tprivate LocalDateTime startTime;\n\t@Column(name = \"description\")\n\tprivate String description;\n\t@Column(name = \"launch_id\", nullable = false)\n\tprivate Long launchId;\n\t@LastModifiedDate\n\t@Column(name = \"last_modified\", nullable = false)\n\tprivate LocalDateTime lastModified;\n\t@ElementCollection(fetch = FetchType.EAGER)\n\t@CollectionTable(name = \"parameter\", joinColumns = @JoinColumn(name = \"item_id\"))\n\t@Fetch(FetchMode.SUBSELECT)\n\tprivate Set<Parameter> parameters = Sets.newHashSet();\n\t@Column(name = \"unique_id\", nullable = false, length = 256)\n\tprivate String uniqueId;\n\t@Column(name = \"test_case_id\")\n\tprivate String testCaseId;\n\t@Column(name = \"test_case_hash\")\n\tprivate Integer testCaseHash;\n\t@OneToMany(mappedBy = \"testItem\", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)\n\t@Fetch(FetchMode.SUBSELECT)\n\tprivate Set<ItemAttribute> attributes = Sets.newHashSet();\n\t@OneToMany(mappedBy = \"testItem\", fetch = FetchType.LAZY, orphanRemoval = true)\n\tprivate Set<Log> logs = Sets.newHashSet();\n\t@Column(name = \"path\", nullable = false, columnDefinition = \"ltree\")\n\t@Type(type = \"com.epam.ta.reportportal.entity.LTreeType\")\n\tprivate String path;\n\t@Column(name = \"retry_of\", precision = 64)\n\tprivate Long retryOf;\n\t@Column(name = \"parent_id\")\n\tprivate Long parentId;\n\t@OneToOne(cascade = CascadeType.ALL, mappedBy = \"testItem\")\n\tprivate TestItemResults itemResults;\n\t@OneToMany(mappedBy = \"testItem\", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, fetch = FetchType.LAZY)\n\t@OrderBy(value = \"pattern_id\")\n\t@Fetch(FetchMode.SUBSELECT)\n\tprivate Set<PatternTemplateTestItem> patternTemplateTestItems = Sets.newLinkedHashSet();\n\t@Column(name = \"has_children\")\n\tprivate boolean hasChildren;\n\t@Column(name = \"has_retries\")\n\tprivate boolean hasRetries;\n\t@Column(name = \"has_stats\")\n\tprivate boolean hasStats;\n\tpublic TestItem() {\n\t}\n\tpublic TestItem(Long id) {\n\t\tthis.itemId = id;\n\t}\n\tpublic TestItem(Long itemId, String name, TestItemTypeEnum type, LocalDateTime startTime, String description,\n\t\t\tLocalDateTime lastModified, String uniqueId, boolean hasChildren, boolean hasRetries, boolean hasStats) {\n\t\tthis.itemId = itemId;\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.startTime = startTime;\n\t\tthis.description = description;\n\t\tthis.lastModified = lastModified;\n\t\tthis.uniqueId = uniqueId;\n\t\tthis.hasChildren = hasChildren;\n\t\tthis.hasRetries = hasRetries;\n\t}\n\tpublic Set<ItemAttribute> getAttributes() {\n\t\treturn attributes;\n\t}\n\tpublic void setAttributes(Set<ItemAttribute> tags) {\n\t\tthis.attributes.clear();\n\t\tthis.attributes.addAll(tags);\n\t}\n\tpublic Set<Log> getLogs() {\n\t\treturn logs;\n\t}\n\tpublic void setLogs(Set<Log> logs) {\n\t\tthis.logs.clear();\n\t\tthis.logs.addAll(logs);\n\t}\n\tpublic void addLog(Log log) {\n\t\tlogs.add(log);\n\t}\n\tpublic Long getItemId() {\n\t\treturn itemId;\n\t}\n\tpublic void setItemId(Long itemId) {\n\t\tthis.itemId = itemId;\n\t}\n\tpublic String getUuid() {\n\t\treturn uuid;\n\t}\n\tpublic void setUuid(String uuid) {\n\t\tthis.uuid = uuid;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getCodeRef() {\n\t\treturn codeRef;\n\t}\n\tpublic void setCodeRef(String codeRef) {\n\t\tthis.codeRef = codeRef;\n\t}\n\tpublic TestItemTypeEnum getType() {\n\t\treturn type;\n\t}\n\tpublic void setType(TestItemTypeEnum type) {\n\t\tthis.type = type;\n\t}\n\tpublic LocalDateTime getStartTime() {\n\t\treturn startTime;\n\t}\n\tpublic void setStartTime(LocalDateTime startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\tpublic LocalDateTime getLastModified() {\n\t\treturn lastModified;\n\t}\n\tpublic void setLastModified(LocalDateTime lastModified) {\n\t\tthis.lastModified = lastModified;\n\t}\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\tpublic Set<Parameter> getParameters() {\n\t\treturn parameters;\n\t}\n\tpublic void setParameters(Set<Parameter> parameters) {\n\t\tthis.parameters = parameters;\n\t}\n\tpublic String getUniqueId() {\n\t\treturn uniqueId;\n\t}\n\tpublic void setUniqueId(String uniqueId) {\n\t\tthis.uniqueId = uniqueId;\n\t}\n\tpublic String getTestCaseId() {\n\t\treturn testCaseId;\n\t}\n\tpublic void setTestCaseId(String testCaseId) {\n\t\tthis.testCaseId = testCaseId;\n\t}\n\tpublic Integer getTestCaseHash() {\n\t\treturn testCaseHash;\n\t}\n\tpublic void setTestCaseHash(Integer testCaseHash) {\n\t\tthis.testCaseHash = testCaseHash;\n\t}\n\tpublic Long getLaunchId() {\n\t\treturn launchId;\n\t}\n\tpublic void setLaunchId(Long launchId) {\n\t\tthis.launchId = launchId;\n\t}\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\tpublic void setPath(String path) {\n\t\tthis.path = path;\n\t}\n\tpublic Long getRetryOf() {\n\t\treturn retryOf;\n\t}\n\tpublic void setRetryOf(Long retryOf) {\n\t\tthis.retryOf = retryOf;\n\t}\n\tpublic Long getParentId() {\n\t\treturn parentId;\n\t}\n\tpublic void setParentId(Long parentId) {\n\t\tthis.parentId = parentId;\n\t}\n\tpublic TestItemResults getItemResults() {\n\t\treturn itemResults;\n\t}\n\tpublic void setItemResults(TestItemResults itemResults) {\n\t\tthis.itemResults = itemResults;\n\t}\n\tpublic boolean isHasChildren() {\n\t\treturn hasChildren;\n\t}\n\tpublic void setHasChildren(boolean hasChildren) {\n\t\tthis.hasChildren = hasChildren;\n\t}\n\tpublic Set<PatternTemplateTestItem> getPatternTemplateTestItems() {\n\t\treturn patternTemplateTestItems;\n\t}\n\tpublic void setPatternTemplateTestItems(Set<PatternTemplateTestItem> patternTemplateTestItems) {\n\t\tthis.patternTemplateTestItems = patternTemplateTestItems;\n\t}\n\tpublic boolean isHasRetries() {\n\t\treturn hasRetries;\n\t}\n\tpublic void setHasRetries(boolean hasRetries) {\n\t\tthis.hasRetries = hasRetries;\n\t}\n\tpublic boolean isHasStats() {\n\t\treturn hasStats;\n\t}\n\tpublic void setHasStats(boolean hasStats) {\n\t\tthis.hasStats = hasStats;\n\t}\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tTestItem testItem = (TestItem) o;\n\t\treturn Objects.equals(itemId, testItem.itemId) && Objects.equals(name, testItem.name) && Objects.equals(codeRef, testItem.codeRef)\n\t\t\t\t&& type == testItem.type && Objects.equals(uniqueId, testItem.uniqueId) && Objects.equals(testCaseId, testItem.testCaseId)\n\t\t\t\t&& Objects.equals(testCaseHash, testItem.testCaseHash) && Objects.equals(path, testItem.path) && Objects.equals(retryOf,\n\t\t\t\ttestItem.retryOf\n\t\t);\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(itemId, name, codeRef, type, uniqueId, testCaseId, testCaseHash, path, retryOf);\n\t}\n"]]}
{"hexsha": "770ba336660ddb6d1684c88a6ffd4027a484b65d", "ext": "java", "lang": "Java", "content": "@Deprecated\n@Plugin(type = ConsoleArgument.class)\npublic class RunArgument extends AbstractConsoleArgument {\n\n\t@Parameter\n\tprivate CommandService commandService;\n\n\t@Parameter\n\tprivate LogService log;\n\n\t// -- Constructor --\n\n\tpublic RunArgument() {\n\t\tsuper(2, \"--class\");\n\t}\n\n\t// -- ConsoleArgument methods --\n\n\t@Override\n\tpublic void handle(final LinkedList<String> args) {\n\t\tif (!supports(args))\n\t\t\treturn;\n\n\t\tlog.warn(\"The --class flag is deprecated, and will\\n\" +\n\t\t\t\"be removed in a future release. Use --run instead.\");\n\n\t\targs.removeFirst(); // --class\n\t\tfinal String commandToRun = args.removeFirst();\n\t\tfinal String paramString = ConsoleUtils.hasParam(args) ? args.removeFirst() : \"\";\n\n\t\trun(commandToRun, paramString);\n\t}\n\n\t// -- Typed methods --\n\n\t@Override\n\tpublic boolean supports(final LinkedList<String> args) {\n\t\tif (!super.supports(args))\n\t\t\treturn false;\n\t\treturn getInfo(args.get(1)) != null;\n\t}\n\n\t// -- Helper methods --\n\n\t/** Implements the {@code --run} command line argument. */\n\tprivate void run(final String commandToRun, final String optionString) {\n\t\t// get the command info\n\t\tfinal CommandInfo info = getInfo(commandToRun);\n\n\t\t// couldn't find anything to run\n\t\tif (info == null)\n\t\t\treturn;\n\n\t\t// TODO: parse the optionString a la ImageJ1\n\t\tfinal Map<String, Object> inputMap = ConsoleUtils.parseParameterString(optionString, info, log);\n\n\t\ttry {\n\t\t\tcommandService.run(info, true, inputMap).get();\n\t\t} catch (final Exception exc) {\n\t\t\tlog.error(exc);\n\t\t}\n\t}\n\n\t/**\n\t * Try to convert the given string to a {@link CommandInfo}\n\t */\n\tprivate CommandInfo getInfo(final String commandToRun) {\n\t\tCommandInfo info = commandService.getCommand(commandToRun);\n\t\tif (info == null) {\n\t\t\t// command was not a class name; search for command by title instead\n\t\t\tfinal String label = commandToRun.replace('_', ' ');\n\t\t\tfor (final CommandInfo ci : commandService.getCommands()) {\n\t\t\t\tif (label.equals(ci.getTitle())) {\n\t\t\t\t\tinfo = ci;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}\n}", "class_id": 0, "repo": "karlduderstadt/scijava-common", "file": "src/main/java/org/scijava/command/console/RunArgument.java", "last_update_at": "2021-05-18T11:47:13+00:00", "question_id": "770ba336660ddb6d1684c88a6ffd4027a484b65d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Deprecated\n@Plugin(type = ConsoleArgument.class)\npublic class RunArgument extends AbstractConsoleArgument {\n\t@Parameter\n\tprivate CommandService commandService;\n\t@Parameter\n\tprivate LogService log;\n\t// -- Constructor --\n\tpublic RunArgument() {\n\t\tsuper(2, \"--class\");\n\t}\n\t// -- ConsoleArgument methods --\n\t@Override\n\tpublic void handle(final LinkedList<String> args) {\n\t\tif (!supports(args))\n\t\t\treturn;\n\t\tlog.warn(\"The --class flag is deprecated, and will\\n\" +\n\t\t\t\"be removed in a future release. Use --run instead.\");\n\t\targs.removeFirst(); // --class\n\t\tfinal String commandToRun = args.removeFirst();\n\t\tfinal String paramString = ConsoleUtils.hasParam(args) ? args.removeFirst() : \"\";\n\t\trun(commandToRun, paramString);\n\t}\n\t// -- Typed methods --\n\t@Override\n\tpublic boolean supports(final LinkedList<String> args) {\n\t\tif (!super.supports(args))\n\t\t\treturn false;\n\t\treturn getInfo(args.get(1)) != null;\n\t}\n\t// -- Helper methods --\n\t/** Implements the {@code --run} command line argument. */\n\tprivate void run(final String commandToRun, final String optionString) {\n\t\t// get the command info\n\t\tfinal CommandInfo info = getInfo(commandToRun);\n\t\t// couldn't find anything to run\n\t\tif (info == null)\n\t\t\treturn;\n\t\t// TODO: parse the optionString a la ImageJ1\n\t\tfinal Map<String, Object> inputMap = ConsoleUtils.parseParameterString(optionString, info, log);\n\t\ttry {\n\t\t\tcommandService.run(info, true, inputMap).get();\n\t\t} catch (final Exception exc) {\n\t\t\tlog.error(exc);\n\t\t}\n\t}\n\t/**\n\t * Try to convert the given string to a {@link CommandInfo}\n\t */\n\tprivate CommandInfo getInfo(final String commandToRun) {\n\t\tCommandInfo info = commandService.getCommand(commandToRun);\n\t\tif (info == null) {\n\t\t\t// command was not a class name; search for command by title instead\n\t\t\tfinal String label = commandToRun.replace('_', ' ');\n\t\t\tfor (final CommandInfo ci : commandService.getCommands()) {\n\t\t\t\tif (label.equals(ci.getTitle())) {\n\t\t\t\t\tinfo = ci;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}\n"]]}
{"hexsha": "3657c2a163170b02431c0dbfc628de7c3d0901ee", "ext": "java", "lang": "Java", "content": "public class PreRegistrationFragment extends FragmentViewController<EmptyArg, PreRegistrationListener> {\n    @Override\n    public ControllerTypes<EmptyArg, PreRegistrationListener> getTypes() {\n        return new ControllerTypes<>(EmptyArg.class, PreRegistrationListener.class);\n    }\n\n    @Override\n    public View onCreateView(@NonNull final LayoutInflater inflater,\n                             final ViewGroup container,\n                             final Bundle savedInstanceState) {\n        final View view = BottomDetailAndButtonView.inflateWithMenuButton(inflater, container, getActivity(), R.layout.pre_registration);\n        final Button startRegistrationButton = view.findViewById(R.id.start_registration_button);\n        startRegistrationButton.setOnClickListener(click -> getListener().startRegistration());\n        return view;\n    }\n}", "class_id": 0, "repo": "rideOS/rideos-sdk-android", "file": "driver_app/src/main/java/ai/rideos/android/driver_app/vehicle_unregistered/pre_registration/PreRegistrationFragment.java", "last_update_at": "2021-04-03T12:29:56+00:00", "question_id": "3657c2a163170b02431c0dbfc628de7c3d0901ee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PreRegistrationFragment extends FragmentViewController<EmptyArg, PreRegistrationListener> {\n    @Override\n    public ControllerTypes<EmptyArg, PreRegistrationListener> getTypes() {\n        return new ControllerTypes<>(EmptyArg.class, PreRegistrationListener.class);\n    }\n    @Override\n    public View onCreateView(@NonNull final LayoutInflater inflater,\n                             final ViewGroup container,\n                             final Bundle savedInstanceState) {\n        final View view = BottomDetailAndButtonView.inflateWithMenuButton(inflater, container, getActivity(), R.layout.pre_registration);\n        final Button startRegistrationButton = view.findViewById(R.id.start_registration_button);\n        startRegistrationButton.setOnClickListener(click -> getListener().startRegistration());\n        return view;\n    }\n"]]}
{"hexsha": "a24f84caa66e1f813870bcc8b107c4c0772b2c17", "ext": "java", "lang": "Java", "content": "public class ComplexStringExampleActivity extends AppCompatActivity {\n\n    ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder> mListenerRelay = new ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder>() {\n        @Override\n        public void onClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch (view.getId()) {\n                    case R.id.text: {\n                        mSnackbarLogic.make(view, item + \" is clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_a: {\n                        mSnackbarLogic.make(view, item + \" is clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_b: {\n                        mSnackbarLogic.make(view, item + \" is clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                }\n            }\n        }\n\n        @Override\n        public boolean onLongClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch (view.getId()) {\n                    case R.id.text: {\n                        mSnackbarLogic.make(view, item + \" is long clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_a: {\n                        mSnackbarLogic.make(view, item + \" is long clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_b: {\n                        mSnackbarLogic.make(view, item + \" is long clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n    };\n\n    RecyclerView mRecyclerView;\n\n    SnackbarLogic mSnackbarLogic = new SnackbarLogic();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_simple_string_example);\n\n        // find views\n        mRecyclerView = (RecyclerView) findViewById(R.id.recycler);\n\n        { // set adapter\n            List<String> items = new ArrayList<>();\n            for (int i = 0; i < 100; i++) {\n                items.add(\"item \" + i);\n            }\n            ComplexStringAdapter adapter = new ComplexStringAdapter(this, items, mListenerRelay);\n            mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));\n            mRecyclerView.setAdapter(adapter);\n        }\n    }\n}", "class_id": 0, "repo": "cattaka/AdapterToolbox", "file": "example/src/main/java/net/cattaka/android/adaptertoolbox/example/ComplexStringExampleActivity.java", "last_update_at": "2021-02-21T05:12:08+00:00", "question_id": "a24f84caa66e1f813870bcc8b107c4c0772b2c17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ComplexStringExampleActivity extends AppCompatActivity {\n    ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder> mListenerRelay = new ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder>() {\n        @Override\n        public void onClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch (view.getId()) {\n                    case R.id.text: {\n                        mSnackbarLogic.make(view, item + \" is clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_a: {\n                        mSnackbarLogic.make(view, item + \" is clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_b: {\n                        mSnackbarLogic.make(view, item + \" is clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                }\n            }\n        }\n        @Override\n        public boolean onLongClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch (view.getId()) {\n                    case R.id.text: {\n                        mSnackbarLogic.make(view, item + \" is long clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_a: {\n                        mSnackbarLogic.make(view, item + \" is long clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                    case R.id.button_b: {\n                        mSnackbarLogic.make(view, item + \" is long clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n    };\n    RecyclerView mRecyclerView;\n    SnackbarLogic mSnackbarLogic = new SnackbarLogic();\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_simple_string_example);\n        // find views\n        mRecyclerView = (RecyclerView) findViewById(R.id.recycler);\n        { // set adapter\n            List<String> items = new ArrayList<>();\n            for (int i = 0; i < 100; i++) {\n                items.add(\"item \" + i);\n            }\n            ComplexStringAdapter adapter = new ComplexStringAdapter(this, items, mListenerRelay);\n            mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));\n            mRecyclerView.setAdapter(adapter);\n        }\n    }\n"]]}
{"hexsha": "897fdb49750e90c9a13f17c981ee07272d6899b3", "ext": "java", "lang": "Java", "content": "public abstract class TemplateMatchingAlg extends SentenceAlgorithm {\n\n\t// separates the template from the rest of the algorithm in its init string.\n\tprivate static String TEMPLATE_DELINEATOR = \"\\n=\\n\";\n\n\tprivate FeatureTemplate template;\n\n\tprivate String signature;\n\n\tprotected FeatureTemplate getTemplate()\n\t{\n\t\treturn template;\n\t}\n\n\tprotected void setTemplate(FeatureTemplate t)\n\t{\n\t\ttemplate = t;\n\t}\n\n\t/**\n\t * Tests if ConstituentNode is a superset of template\n\t *\n\t * @param node\n\t * @return map of matching nodes\n\t */\n\tprotected Map<String,FeatureNode> canApplyTo(FeatureNode node)\n\t{\n\t\treturn template.match(node);\n\t}\n\n\tprotected String getSignature()\n\t{\n\t\treturn signature;\n\t}\n\n\tpublic int init(String str)\n\t{\n\t\tif (!Character.isLetter(str.charAt(0)))\n\t\t\tthrow new RuntimeException(\"TemplateMatchingAlg string must start with a letter.\\n\" + str);\n\t\t// get signature\n\t\tint sigEnd = str.indexOf(\"\\n\");\n\t\tsignature = str.substring(0, sigEnd);\n\t\t// get template\n\t\tint templateEnd = str.indexOf(TEMPLATE_DELINEATOR);\n\t\tif (templateEnd < 0)\n\t\t\tthrow new RuntimeException(\"TemplateMAtchingAlg must have:\" + TEMPLATE_DELINEATOR\n\t\t\t\t\t+ \"separating the template from the actions.\\n\" + str);\n\t\tsetTemplate(new FeatureTemplate(str.substring(sigEnd + 1, templateEnd)));\n\t\treturn templateEnd + TEMPLATE_DELINEATOR.length();\n\t}\n\n\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(getSignature()).append(\"\\n\").append(getTemplate()).append(TEMPLATE_DELINEATOR);\n\t\treturn sb.toString();\n\t}\n\n}", "class_id": 0, "repo": "tozhovez/relex", "file": "src/java/relex/algs/TemplateMatchingAlg.java", "last_update_at": "2021-11-09T11:27:11+00:00", "question_id": "897fdb49750e90c9a13f17c981ee07272d6899b3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class TemplateMatchingAlg extends SentenceAlgorithm {\n\t// separates the template from the rest of the algorithm in its init string.\n\tprivate static String TEMPLATE_DELINEATOR = \"\\n=\\n\";\n\tprivate FeatureTemplate template;\n\tprivate String signature;\n\tprotected FeatureTemplate getTemplate()\n\t{\n\t\treturn template;\n\t}\n\tprotected void setTemplate(FeatureTemplate t)\n\t{\n\t\ttemplate = t;\n\t}\n\t/**\n\t * Tests if ConstituentNode is a superset of template\n\t *\n\t * @param node\n\t * @return map of matching nodes\n\t */\n\tprotected Map<String,FeatureNode> canApplyTo(FeatureNode node)\n\t{\n\t\treturn template.match(node);\n\t}\n\tprotected String getSignature()\n\t{\n\t\treturn signature;\n\t}\n\tpublic int init(String str)\n\t{\n\t\tif (!Character.isLetter(str.charAt(0)))\n\t\t\tthrow new RuntimeException(\"TemplateMatchingAlg string must start with a letter.\\n\" + str);\n\t\t// get signature\n\t\tint sigEnd = str.indexOf(\"\\n\");\n\t\tsignature = str.substring(0, sigEnd);\n\t\t// get template\n\t\tint templateEnd = str.indexOf(TEMPLATE_DELINEATOR);\n\t\tif (templateEnd < 0)\n\t\t\tthrow new RuntimeException(\"TemplateMAtchingAlg must have:\" + TEMPLATE_DELINEATOR\n\t\t\t\t\t+ \"separating the template from the actions.\\n\" + str);\n\t\tsetTemplate(new FeatureTemplate(str.substring(sigEnd + 1, templateEnd)));\n\t\treturn templateEnd + TEMPLATE_DELINEATOR.length();\n\t}\n\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(getSignature()).append(\"\\n\").append(getTemplate()).append(TEMPLATE_DELINEATOR);\n\t\treturn sb.toString();\n\t}\n"]]}
{"hexsha": "40075c370335e4894f6de3f58bbf672ce1c03ed7", "ext": "java", "lang": "Java", "content": "public class JsonArrayDiff implements JsonDiff {\n    private final Map<Integer, JsonNode> valuesWithoutMatch = new HashMap<>();\n    private final Map<Integer, JsonDiff> valuesWithMatch = new HashMap<>();\n    private final Map<Integer, JsonNode> extraValues = new HashMap<>();\n    private final Path path;\n\n    public JsonArrayDiff(Path path) {\n        this.path = path;\n    }\n\n    public void addNoMatch(int index, JsonNode expectedValue) {\n        this.valuesWithoutMatch.put(index, expectedValue);\n    }\n\n    public void addDiff(int index, JsonDiff jsonDiff) {\n        this.valuesWithMatch.put(index, jsonDiff);\n    }\n\n    public void addExtraItem(int index, JsonNode extraReceivedValue) {\n        this.extraValues.put(index, extraReceivedValue);\n    }\n\n    @Override\n    public double similarityRate() {\n        final var totalArraySize = valuesWithoutMatch.size() + valuesWithMatch.size() + this.extraValues.size();\n        final var totalSimilarityRate = valuesWithMatch.values().stream()\n                .mapToDouble(JsonDiff::similarityRate)\n                .sum();\n\n        return totalSimilarityRate / totalArraySize;\n    }\n\n    @Override\n    public void display(JsonDiffViewer viewer) {\n        for (final var valuesWithMatch : valuesWithMatch.entrySet()) {\n            if (valuesWithMatch.getValue().similarityRate() >= 99.9) {\n                viewer.matchingProperty(valuesWithMatch.getValue());\n            } else {\n                viewer.nonMatchingProperty(valuesWithMatch.getValue());\n            }\n        }\n\n        for (final var valuesWithoutMatch : valuesWithoutMatch.entrySet()) {\n            viewer.missingProperty(new Path.ChainedPath(path(), String.valueOf(valuesWithoutMatch.getKey())), valuesWithoutMatch.getValue());\n        }\n\n        for (final var extraItem: extraValues.entrySet()) {\n            viewer.extraProperty(new Path.ChainedPath(path(), String.valueOf(extraItem.getKey())), extraItem.getValue());\n        }\n    }\n\n    @Override\n    public Path path() {\n        return this.path;\n    }\n}", "class_id": 0, "repo": "deblockt/json-diff", "file": "src/main/java/com/deblock/jsondiff/diff/JsonArrayDiff.java", "last_update_at": "2021-06-29T21:27:43+00:00", "question_id": "40075c370335e4894f6de3f58bbf672ce1c03ed7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JsonArrayDiff implements JsonDiff {\n    private final Map<Integer, JsonNode> valuesWithoutMatch = new HashMap<>();\n    private final Map<Integer, JsonDiff> valuesWithMatch = new HashMap<>();\n    private final Map<Integer, JsonNode> extraValues = new HashMap<>();\n    private final Path path;\n    public JsonArrayDiff(Path path) {\n        this.path = path;\n    }\n    public void addNoMatch(int index, JsonNode expectedValue) {\n        this.valuesWithoutMatch.put(index, expectedValue);\n    }\n    public void addDiff(int index, JsonDiff jsonDiff) {\n        this.valuesWithMatch.put(index, jsonDiff);\n    }\n    public void addExtraItem(int index, JsonNode extraReceivedValue) {\n        this.extraValues.put(index, extraReceivedValue);\n    }\n    @Override\n    public double similarityRate() {\n        final var totalArraySize = valuesWithoutMatch.size() + valuesWithMatch.size() + this.extraValues.size();\n        final var totalSimilarityRate = valuesWithMatch.values().stream()\n                .mapToDouble(JsonDiff::similarityRate)\n                .sum();\n        return totalSimilarityRate / totalArraySize;\n    }\n    @Override\n    public void display(JsonDiffViewer viewer) {\n        for (final var valuesWithMatch : valuesWithMatch.entrySet()) {\n            if (valuesWithMatch.getValue().similarityRate() >= 99.9) {\n                viewer.matchingProperty(valuesWithMatch.getValue());\n            } else {\n                viewer.nonMatchingProperty(valuesWithMatch.getValue());\n            }\n        }\n        for (final var valuesWithoutMatch : valuesWithoutMatch.entrySet()) {\n            viewer.missingProperty(new Path.ChainedPath(path(), String.valueOf(valuesWithoutMatch.getKey())), valuesWithoutMatch.getValue());\n        }\n        for (final var extraItem: extraValues.entrySet()) {\n            viewer.extraProperty(new Path.ChainedPath(path(), String.valueOf(extraItem.getKey())), extraItem.getValue());\n        }\n    }\n    @Override\n    public Path path() {\n        return this.path;\n    }\n"]]}
{"hexsha": "dc9e7da59510f1ed559c7ecc60156b3e286bb598", "ext": "java", "lang": "Java", "content": "public class Auth {\n\n//    private static final int RC_SIGN_IN = 1001; // For Google (Not used actually)\n\n    private final FirebaseAuth mAuth = FirebaseAuth.getInstance();\n    private final UsersDatabaseCrud userCrud = new UsersDatabaseCrud();\n    private FirebaseUser mFirebaseUser;\n\n    private Activity activity = null;\n\n    /**\n     * Constructor Default\n     */\n    public Auth() {\n        // Empty\n    }\n\n    /**\n     * Constructor\n     *\n     * @param activity Activity from where it has been called\n     */\n    public Auth(Activity activity) {\n        this.activity = activity;\n    }\n\n    /**\n     * Check if the current user is logged in or not\n     *\n     * @return boolean False [not logged in], True [logged in]\n     */\n    public boolean isLogged() {\n        return (mAuth.getCurrentUser() != null);\n    }\n\n    /**\n     * Return current user logged\n     *\n     * @return FirebaseUser\n     */\n    public FirebaseUser getCurrentUser() {\n        return mAuth.getCurrentUser();\n    }\n\n    /**\n     * Try to log in with the email and password passed as parameters\n     *\n     * @param email    User validated email\n     * @param password User's validated password\n     */\n    public void signInWithEmailAndPassword(String email, String password) {\n        mAuth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {\n            if (task.isSuccessful()) {\n                if (isLogged()) {\n                    mFirebaseUser = mAuth.getCurrentUser();\n                    userCrud.read(mFirebaseUser.getUid(), user -> {\n//                        Log.d(App.DEFAULT_TAG, mFirebaseUser.getUid());\n                        App.getInstance().setCurrentUser(user);\n//                        Log.d(App.DEFAULT_TAG, \"App.getInstance().getCurrentUser(): \" + App.getInstance().getCurrentUser());\n                        // Update lastAccess field\n                        user.setLastAccess(new Date(System.currentTimeMillis()));\n                        userCrud.update(user.getUid(), user.parseToMap(), response -> {\n                            if (response) {\n                                checkRole(App.getInstance().getCurrentUser().getRole());\n                            } else {\n                                Intent intent = new Intent(App.getContext(), GeneralMainActivity.class);\n                                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                                intent.putExtra(\"message\", \"No se ha podido verificar tu identidad correctamente.\");\n                                App.getContext().startActivity(intent);\n                            }\n                        });\n                    });\n                }\n            } else {\n                App.getInstance().snackMessage(activity.findViewById(R.id.auth_email_activity_container), R.color.black, \"Datos de acceso incorrectos.\", App.getContext());\n            }\n        });\n    }\n\n    /**\n     * Send a password reset email\n     *\n     * @param email User validated email\n     */\n    public void sendPasswordResetEmail(String email) {\n        mAuth.sendPasswordResetEmail(email).addOnCompleteListener(task -> {\n            Intent intent = new Intent(App.getContext(), AuthEmailActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n            intent.putExtra(\"message\", \"S\u00ed el email esta registrado recibir\u00e1s un correo para restablecer la contrase\u00f1a.\");\n            App.getContext().startActivity(intent);\n        });\n    }\n\n    /**\n     * Disconnect the user\n     */\n    public void signOut() {\n        mAuth.signOut();\n        App.getInstance().setCurrentUser(null);\n    }\n\n    /**\n     * Check the role and redirect to the corresponding activity when logging in\n     *\n     * @param role Role of the logged in user\n     */\n    public void checkRole(String role) {\n        switch (role) {\n            case \"root\":\n            case \"administrator\": {\n                redirectActivity(AdministratorMainActivity.class);\n                break;\n            }\n            case \"technician\": {\n                redirectActivity(TechnicianMainActivity.class);\n                break;\n            }\n            default: {\n                redirectActivity(GeneralMainActivity.class);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Redirect to corresponding activity\n     *\n     * @param activity Activity where it will be redirected\n     */\n    public void redirectActivity(Class<?> activity) {\n        Intent intent;\n        intent = new Intent(App.getContext(), activity);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP |\n                Intent.FLAG_ACTIVITY_NEW_TASK |\n                Intent.FLAG_ACTIVITY_CLEAR_TASK\n        );\n        App.getContext().startActivity(intent);\n    }\n\n}", "class_id": 0, "repo": "abidanBrito/murbin", "file": "src/mobile_app/Murbin/app/src/main/java/com/example/murbin/firebase/Auth.java", "last_update_at": "2021-04-01T17:24:35+00:00", "question_id": "dc9e7da59510f1ed559c7ecc60156b3e286bb598", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Auth {\n//    private static final int RC_SIGN_IN = 1001; // For Google (Not used actually)\n    private final FirebaseAuth mAuth = FirebaseAuth.getInstance();\n    private final UsersDatabaseCrud userCrud = new UsersDatabaseCrud();\n    private FirebaseUser mFirebaseUser;\n    private Activity activity = null;\n    /**\n     * Constructor Default\n     */\n    public Auth() {\n        // Empty\n    }\n    /**\n     * Constructor\n     *\n     * @param activity Activity from where it has been called\n     */\n    public Auth(Activity activity) {\n        this.activity = activity;\n    }\n    /**\n     * Check if the current user is logged in or not\n     *\n     * @return boolean False [not logged in], True [logged in]\n     */\n    public boolean isLogged() {\n        return (mAuth.getCurrentUser() != null);\n    }\n    /**\n     * Return current user logged\n     *\n     * @return FirebaseUser\n     */\n    public FirebaseUser getCurrentUser() {\n        return mAuth.getCurrentUser();\n    }\n    /**\n     * Try to log in with the email and password passed as parameters\n     *\n     * @param email    User validated email\n     * @param password User's validated password\n     */\n    public void signInWithEmailAndPassword(String email, String password) {\n        mAuth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {\n            if (task.isSuccessful()) {\n                if (isLogged()) {\n                    mFirebaseUser = mAuth.getCurrentUser();\n                    userCrud.read(mFirebaseUser.getUid(), user -> {\n//                        Log.d(App.DEFAULT_TAG, mFirebaseUser.getUid());\n                        App.getInstance().setCurrentUser(user);\n//                        Log.d(App.DEFAULT_TAG, \"App.getInstance().getCurrentUser(): \" + App.getInstance().getCurrentUser());\n                        // Update lastAccess field\n                        user.setLastAccess(new Date(System.currentTimeMillis()));\n                        userCrud.update(user.getUid(), user.parseToMap(), response -> {\n                            if (response) {\n                                checkRole(App.getInstance().getCurrentUser().getRole());\n                            } else {\n                                Intent intent = new Intent(App.getContext(), GeneralMainActivity.class);\n                                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                                intent.putExtra(\"message\", \"No se ha podido verificar tu identidad correctamente.\");\n                                App.getContext().startActivity(intent);\n                            }\n                        });\n                    });\n                }\n            } else {\n                App.getInstance().snackMessage(activity.findViewById(R.id.auth_email_activity_container), R.color.black, \"Datos de acceso incorrectos.\", App.getContext());\n            }\n        });\n    }\n    /**\n     * Send a password reset email\n     *\n     * @param email User validated email\n     */\n    public void sendPasswordResetEmail(String email) {\n        mAuth.sendPasswordResetEmail(email).addOnCompleteListener(task -> {\n            Intent intent = new Intent(App.getContext(), AuthEmailActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n            intent.putExtra(\"message\", \"S\u00ed el email esta registrado recibir\u00e1s un correo para restablecer la contrase\u00f1a.\");\n            App.getContext().startActivity(intent);\n        });\n    }\n    /**\n     * Disconnect the user\n     */\n    public void signOut() {\n        mAuth.signOut();\n        App.getInstance().setCurrentUser(null);\n    }\n    /**\n     * Check the role and redirect to the corresponding activity when logging in\n     *\n     * @param role Role of the logged in user\n     */\n    public void checkRole(String role) {\n        switch (role) {\n            case \"root\":\n            case \"administrator\": {\n                redirectActivity(AdministratorMainActivity.class);\n                break;\n            }\n            case \"technician\": {\n                redirectActivity(TechnicianMainActivity.class);\n                break;\n            }\n            default: {\n                redirectActivity(GeneralMainActivity.class);\n                break;\n            }\n        }\n    }\n    /**\n     * Redirect to corresponding activity\n     *\n     * @param activity Activity where it will be redirected\n     */\n    public void redirectActivity(Class<?> activity) {\n        Intent intent;\n        intent = new Intent(App.getContext(), activity);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP |\n                Intent.FLAG_ACTIVITY_NEW_TASK |\n                Intent.FLAG_ACTIVITY_CLEAR_TASK\n        );\n        App.getContext().startActivity(intent);\n    }\n"]]}
{"hexsha": "0a2f28df151b3621ae7f64d2d75f3eace8e03e16", "ext": "java", "lang": "Java", "content": "public class WebglInteractiveCubes extends Attachable {\n\n    public final static String name = \"interactive / cubes\";\n    private Random rand = new Random();\n    private Raycaster raycaster;\n    private Vector2 mouse = new Vector2();\n    private float radius = 100, theta = 0;\n    private Mesh INTERSECTED;\n\n    public WebglInteractiveCubes() {\n        camera = new PerspectiveCamera(70, aspect, 1, 10000);\n        scene = new Scene();\n        scene.background = new Color(0xf0f0f0);\n\n        DirectionalLight light = new DirectionalLight(0xffffff, 1);\n        light.position.set(1, 1, 1).normalize();\n\n        scene.add(light);\n        BoxBufferGeometry geometry = new BoxBufferGeometry(20, 20, 20);\n        for (int i = 0; i < 2000; i++) {\n            MeshLambertMaterialParameters parameters = new MeshLambertMaterialParameters();\n            parameters.color = new Color(rand.nextInt() * 0xffffff);\n            Mesh object = new Mesh(geometry, new MeshLambertMaterial(parameters));\n\n            object.position.x = rand.nextFloat() * 800 - 400;\n            object.position.y = rand.nextFloat() * 800 - 400;\n            object.position.z = rand.nextFloat() * 800 - 400;\n            object.rotation.x = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.y = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.z = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.scale.x = rand.nextFloat() + 0.5f;\n            object.scale.y = rand.nextFloat() + 0.5f;\n            object.scale.z = rand.nextFloat() + 0.5f;\n            scene.add(object);\n        }\n        raycaster = new Raycaster();\n\n        // RENDERER\n        WebGLRendererParameters parameters = new WebGLRendererParameters();\n        parameters.antialias = true;\n        renderer = new WebGLRenderer(parameters);\n        setupWebGLRenderer(renderer);\n        container.appendChild(renderer.domElement);\n\n        renderer.domElement.onmousemove = p0 -> {\n            MouseEvent event = Js.uncheckedCast(p0);\n            onDocumentMouseMove(event);\n            return null;\n        };\n    }\n\n    private void animate() {\n        AnimationScheduler.get().requestAnimationFrame(timestamp -> {\n            if (root.parentNode != null) {\n                StatsProducer.getStats().update();\n\n                render();\n                animate();\n            }\n        });\n    }\n\n    private void onDocumentMouseMove(MouseEvent event) {\n        event.preventDefault();\n\n        mouse.x = (float) (((event.clientX - panel.offsetWidth) / (window.innerWidth - panel.offsetWidth)) * 2 - 1);\n        mouse.y = (float) (-(event.clientY / window.innerHeight) * 2 + 1);\n    }\n\n\n    @Override\n    protected void doAttachScene() {\n        root.appendChild(container);\n        renderer.setSize(getWidth(), getHeight());\n        animate();\n    }\n\n    @Override\n    protected void doAttachInfo() {\n        AppSetup.infoDiv.show().setHrefToInfo(\"http://threejs.org\").setTextContentToInfo(\"three.js\").setInnetHtml(\"  -  webgl - interactive cubes\");\n\n    }\n\n    private void render() {\n        theta += 0.1;\n        camera.position.x = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.y = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.z = radius * (float) Math.cos(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.lookAt(scene.position);\n        camera.updateMatrixWorld();\n        // find intersections\n        raycaster.setFromCamera(mouse, camera);\n        Intersect[] intersects = raycaster.intersectObjects(scene.children);\n\n        if (intersects.length > 0) {\n            Intersect intersect = intersects[0];\n            Mesh intersected = intersect.object;\n            if (INTERSECTED != intersected) {\n                int currentHex = ((MeshLambertMaterial) intersected.material).emissive.getHex();\n                intersected.userData.setProperty(\"currentHex\", currentHex);\n                ((MeshLambertMaterial) intersected.material).emissive.setHex(0xff0000);\n                INTERSECTED = intersected;\n            }\n        } else {\n            if (INTERSECTED != null) {\n                ((MeshLambertMaterial) INTERSECTED.material).emissive.setHex(INTERSECTED.userData.getProperty(\"currentHex\"));\n                INTERSECTED = null;\n            }\n        }\n        renderer.render(scene, camera);\n    }\n}", "class_id": 0, "repo": "Calpano/three4g", "file": "demo/src/main/java/org/treblereel/gwt/three4g/demo/client/local/examples/interactive/WebglInteractiveCubes.java", "last_update_at": "2021-11-27T19:59:57+00:00", "question_id": "0a2f28df151b3621ae7f64d2d75f3eace8e03e16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WebglInteractiveCubes extends Attachable {\n    public final static String name = \"interactive / cubes\";\n    private Random rand = new Random();\n    private Raycaster raycaster;\n    private Vector2 mouse = new Vector2();\n    private float radius = 100, theta = 0;\n    private Mesh INTERSECTED;\n    public WebglInteractiveCubes() {\n        camera = new PerspectiveCamera(70, aspect, 1, 10000);\n        scene = new Scene();\n        scene.background = new Color(0xf0f0f0);\n        DirectionalLight light = new DirectionalLight(0xffffff, 1);\n        light.position.set(1, 1, 1).normalize();\n        scene.add(light);\n        BoxBufferGeometry geometry = new BoxBufferGeometry(20, 20, 20);\n        for (int i = 0; i < 2000; i++) {\n            MeshLambertMaterialParameters parameters = new MeshLambertMaterialParameters();\n            parameters.color = new Color(rand.nextInt() * 0xffffff);\n            Mesh object = new Mesh(geometry, new MeshLambertMaterial(parameters));\n            object.position.x = rand.nextFloat() * 800 - 400;\n            object.position.y = rand.nextFloat() * 800 - 400;\n            object.position.z = rand.nextFloat() * 800 - 400;\n            object.rotation.x = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.y = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.z = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.scale.x = rand.nextFloat() + 0.5f;\n            object.scale.y = rand.nextFloat() + 0.5f;\n            object.scale.z = rand.nextFloat() + 0.5f;\n            scene.add(object);\n        }\n        raycaster = new Raycaster();\n        // RENDERER\n        WebGLRendererParameters parameters = new WebGLRendererParameters();\n        parameters.antialias = true;\n        renderer = new WebGLRenderer(parameters);\n        setupWebGLRenderer(renderer);\n        container.appendChild(renderer.domElement);\n        renderer.domElement.onmousemove = p0 -> {\n            MouseEvent event = Js.uncheckedCast(p0);\n            onDocumentMouseMove(event);\n            return null;\n        };\n    }\n    private void animate() {\n        AnimationScheduler.get().requestAnimationFrame(timestamp -> {\n            if (root.parentNode != null) {\n                StatsProducer.getStats().update();\n                render();\n                animate();\n            }\n        });\n    }\n    private void onDocumentMouseMove(MouseEvent event) {\n        event.preventDefault();\n        mouse.x = (float) (((event.clientX - panel.offsetWidth) / (window.innerWidth - panel.offsetWidth)) * 2 - 1);\n        mouse.y = (float) (-(event.clientY / window.innerHeight) * 2 + 1);\n    }\n    @Override\n    protected void doAttachScene() {\n        root.appendChild(container);\n        renderer.setSize(getWidth(), getHeight());\n        animate();\n    }\n    @Override\n    protected void doAttachInfo() {\n        AppSetup.infoDiv.show().setHrefToInfo(\"http://threejs.org\").setTextContentToInfo(\"three.js\").setInnetHtml(\"  -  webgl - interactive cubes\");\n    }\n    private void render() {\n        theta += 0.1;\n        camera.position.x = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.y = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.z = radius * (float) Math.cos(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.lookAt(scene.position);\n        camera.updateMatrixWorld();\n        // find intersections\n        raycaster.setFromCamera(mouse, camera);\n        Intersect[] intersects = raycaster.intersectObjects(scene.children);\n        if (intersects.length > 0) {\n            Intersect intersect = intersects[0];\n            Mesh intersected = intersect.object;\n            if (INTERSECTED != intersected) {\n                int currentHex = ((MeshLambertMaterial) intersected.material).emissive.getHex();\n                intersected.userData.setProperty(\"currentHex\", currentHex);\n                ((MeshLambertMaterial) intersected.material).emissive.setHex(0xff0000);\n                INTERSECTED = intersected;\n            }\n        } else {\n            if (INTERSECTED != null) {\n                ((MeshLambertMaterial) INTERSECTED.material).emissive.setHex(INTERSECTED.userData.getProperty(\"currentHex\"));\n                INTERSECTED = null;\n            }\n        }\n        renderer.render(scene, camera);\n    }\n"]]}
{"hexsha": "95739590f6b06a260225dba9dd818b49155e72a0", "ext": "java", "lang": "Java", "content": "public class BaseWebSettings {\n\n    /**\n     * \u9ed8\u8ba4\u521d\u59cb\u5316\n     */\n    public static void defaultInit(WebSettings webSettings) {\n        /**\n         * \u8bbe\u7f6ejs\n         */\n        //\u5982\u679c\u8bbf\u95ee\u7684\u9875\u9762\u4e2d\u8981\u4e0eJavascript\u4ea4\u4e92\uff0c\u5219webview\u5fc5\u987b\u8bbe\u7f6e\u652f\u6301Javascript\n        webSettings.setJavaScriptEnabled(true);\n        //\u652f\u6301\u901a\u8fc7JS\u6253\u5f00\u65b0\u7a97\u53e3\n        webSettings.setJavaScriptCanOpenWindowsAutomatically(true);\n\n        /**\n         * \u8bbe\u7f6e\u81ea\u9002\u5e94\u5c4f\u5e55\uff0c\u4e24\u8005\u5408\u7528\n         */\n        //\u5c06\u56fe\u7247\u8c03\u6574\u5230\u9002\u5408webview\u7684\u5927\u5c0f,\u652f\u6301\u53cc\u51fb\u7f29\u653e\uff0c\u540c\u65f6\u652f\u6301\u624b\u52bf\u64cd\u4f5c\u653e\u5927\u548c\u7f29\u5c0f?\n        webSettings.setUseWideViewPort(true);\n        // \u7f29\u653e\u81f3\u5c4f\u5e55\u7684\u5927\u5c0f\n        webSettings.setLoadWithOverviewMode(true);\n        //\u81ea\u9002\u5e94\u5c4f\u5e55.NARROW_COLUMNS:\u9002\u5e94\u5185\u5bb9\u5927\u5c0f\n        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);\n\n        /**\n         * \u7f29\u653e\u64cd\u4f5c\n         */\n        webSettings.setSupportZoom(true); //\u652f\u6301\u7f29\u653e\uff0c\u9ed8\u8ba4\u4e3atrue\u3002\u662f\u4e0b\u9762\u90a3\u4e2a\u7684\u524d\u63d0\u3002\n        webSettings.setBuiltInZoomControls(true); //\u7f29\u653e\u63a7\u4ef6\u3002\u82e5\u4e3afalse\uff0c\u5219\u8be5WebView\u4e0d\u53ef\u7f29\u653e\n        webSettings.setDisplayZoomControls(false); //\u9690\u85cf\u539f\u751f\u7684\u7f29\u653e\u63a7\u4ef6\n\n        /**\n         * \u56fe\u7247\n         */\n        webSettings.setBlockNetworkImage(false);//\u4e0d\u963b\u585e\u7f51\u7edc\u56fe\u7247,\u89e3\u51b3\u56fe\u7247\u4e0d\u663e\u793a\n        webSettings.setLoadsImagesAutomatically(true); //\u652f\u6301\u81ea\u52a8\u52a0\u8f7d\u56fe\u7247\n\n        /**\n         * \u5b57\u4f53\n         */\n        webSettings.setDefaultTextEncodingName(\"utf-8\");//\u8bbe\u7f6e\u7f16\u7801\u683c\u5f0f,utf-8, GBK\n        webSettings.setTextSize(WebSettings.TextSize.NORMAL);//\u8bbe\u7f6e\u7f51\u9875\u5b57\u4f53\u5927\u5c0f, \u8fc7\u65f6, \u7528\u4e0b\u9762\u65b9\u6cd5\u2193\n        webSettings.setTextZoom(100);//\u8bbe\u7f6e\u9875\u9762\u7684\u6587\u672c\u7f29\u653e\u767e\u5206\u6bd4, \u9ed8\u8ba4100\n\n        /**\n         * \u7f13\u5b58cache\n         */\n        webSettings.setDomStorageEnabled(false);//\u8bbe\u7f6e\u7f13\u5b58,\u6ca1\u6570\u636e\u4e5f\u53ef\u52a0\u8f7d\n        webSettings.setAppCacheEnabled(true);//\u9875\u9762,\u56fe\u7247,\u811a\u672c,css,js...\n        webSettings.setAppCachePath(ConfigUtils.APPLICATION.getCacheDir().getAbsolutePath());//\u8bbe\u7f6e\u7f13\u5b58\u76ee\u5f55\n//        webSettings.setAppCacheMaxSize(Long.MAX_VALUE);//\u8fc7\u65f6,\u81ea\u52a8\u7ba1\u7406\n        /*\n         * \u8bbe\u7f6e\u7f13\u5b58\u7684\u6a21\u5f0f\n         * \u4ec0\u4e48\u662fcache-control?\n         *   cache-control\u662f\u5728\u8bf7\u6c42\u7f51\u9875\u65f6\u670d\u52a1\u5668\u7684\u54cd\u5e94\u5934,\u6b64\u54cd\u5e94\u5934\u7528\u4e8e\u51b3\u5b9a\u7f51\u9875\u7684\u7f13\u5b58\u7b56\u7565.\n         *   \u5e38\u89c1\u7684\u53d6\u503c\u6709public(\u6240\u6709\u5185\u5bb9\u90fd\u5c06\u88ab\u7f13\u5b58),\n         *   private(\u5185\u5bb9\u53ea\u7f13\u5b58\u5230\u79c1\u6709\u7f13\u5b58\u4e2d),\n         *   no-cache(\u6240\u6709\u5185\u5bb9\u90fd\u4e0d\u4f1a\u88ab\u7f13\u5b58),\n         *   max-age=xxx(\u7f13\u5b58\u7684\u5185\u5bb9\u5c06\u5728 xxx \u79d2\u540e\u5931\u6548)\u7b49\u7b49\n         *\n         * WebSettings.LOAD_CACHE_ELSE_NETWORK  \u53ea\u8981\u672c\u5730\u6709\uff0c\u65e0\u8bba\u662f\u5426\u8fc7\u671f\uff0c\u6216\u8005no-cache\uff0c\u90fd\u4f7f\u7528\u7f13\u5b58\u4e2d\u7684\u6570\u636e\n         * WebSettings.LOAD_CACHE_ONLY          \u53ea\u52a0\u8f7d\u7f13\u5b58\n         * WebSettings.LOAD_DEFAULT             \u6839\u636ecache-control\u51b3\u5b9a\u662f\u5426\u4ece\u7f51\u7edc\u4e0a\u53d6\u6570\u636e\n         * WebSettings.LOAD_NO_CACHE            \u4e0d\u52a0\u8f7d\u7f13\u5b58\n         * WebSettings.LOAD_NORMAL\n         */\n        webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n\n        /**\n         * \u6570\u636e\u5e93\n         */\n        webSettings.setDatabaseEnabled(true);\n        //\u5df2\u8fc7\u65f6, \u81ea\u52a8\u7ba1\u7406\n//        webSettings.setDatabasePath(getContext().getDatabasePath(\"database\").getAbsolutePath());\n        //\u5730\u7406\u4f4d\u7f6e\u6570\u636e\u5e93\u7684\u8def\u5f84, \u5df2\u8fc7\u65f6, \u81ea\u52a8\u7ba1\u7406\n//        webSettings.setGeolocationDatabasePath(getContext().getDir(\"geolocation\", Context.MODE_PRIVATE).getPath());\n\n\n        /**\n         * \u52a0\u8f7d\u6765\u6e90\n         */\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {//\u5b89\u53535.0\u4ee5\u4e0a\u7684\u6743\u9650\n            /**\n             * MIXED_CONTENT_ALWAYS_ALLOW\uff1a\u5141\u8bb8\u4ece\u4efb\u4f55\u6765\u6e90\u52a0\u8f7d\u5185\u5bb9\uff0c\u5373\u4f7f\u8d77\u6e90\u662f\u4e0d\u5b89\u5168\u7684\uff1b\n             * MIXED_CONTENT_NEVER_ALLOW\uff1a\u4e0d\u5141\u8bb8Https\u52a0\u8f7dHttp\u7684\u5185\u5bb9\uff0c\u5373\u4e0d\u5141\u8bb8\u4ece\u5b89\u5168\u7684\u8d77\u6e90\u53bb\u52a0\u8f7d\u4e00\u4e2a\u4e0d\u5b89\u5168\u7684\u8d44\u6e90\uff1b\n             * MIXED_CONTENT_COMPATIBILITY_MODE\uff1a\u5f53\u6d89\u53ca\u5230\u6df7\u5408\u5f0f\u5185\u5bb9\u65f6\uff0cWebView \u4f1a\u5c1d\u8bd5\u53bb\u517c\u5bb9\u6700\u65b0Web\u6d4f\u89c8\u5668\u7684\u98ce\u683c\u3002\n             **/\n            webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n        }\n\n\n        /**\n         * \u5176\u4ed6\u64cd\u4f5c\n         */\n        webSettings.setAllowFileAccess(true); //\u8bbe\u7f6e\u53ef\u4ee5\u8bbf\u95ee\u6587\u4ef6\n        //\u4fdd\u5b58\u5bc6\u7801\n        webSettings.setSavePassword(false);\n        //\u8bbe\u7f6e\u662f\u5426\u542f\u7528\u5730\u7406\u4f4d\u7f6e\n        webSettings.setGeolocationEnabled(true);\n        /*\n         * \u544a\u8bc9WebView\u6309\u9700\u542f\u7528\u3001\u7981\u7528\u6216\u4f7f\u7528\u63d2\u4ef6(swf?)\u3002\u5728 ON_DEMAND \u6a21\u5f0f\u610f\u5473\u7740\u5982\u679c\u63d2\u4ef6\u5b58\u5728\uff0c\n         * \u5c31\u53ef\u4ee5\u5904\u7406\u5d4c\u5165\u7684\u63d2\u4ef6\u5185\u5bb9\uff0c\u4e00\u4e2a\u5360\u4f4d\u7b26\u56fe\u6807\u5c06\u663e\u793a\u800c\u4e0d\u662f\u63d2\u4ef6\u3002\n         * \u5f53\u70b9\u51fb\u5360\u4f4d\u7b26\uff0c\u63d2\u4ef6\u5c06\u88ab\u542f\u7528. \u9ed8\u8ba4OFF.\n         */\n        webSettings.setPluginState(WebSettings.PluginState.ON_DEMAND);\n        /*\n         * UserAgent, \u4f8b:\n         * Mozilla/5.0 (Linux; Android 9; COL-AL10 Build/HUAWEICOL-AL10; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/69.0.3497.100 Mobile Safari/537.36\n         */\n//        String userAgentString = webSettings.getUserAgentString();\n//        webSettings.setUserAgentString(userAgentString);\n    }\n}", "class_id": 0, "repo": "actor20170211030627/MyAndroidFrameWork", "file": "myandroidframework/src/main/java/com/actor/myandroidframework/widget/webview/BaseWebSettings.java", "last_update_at": "2021-11-16T07:04:20+00:00", "question_id": "95739590f6b06a260225dba9dd818b49155e72a0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseWebSettings {\n    /**\n     * \u9ed8\u8ba4\u521d\u59cb\u5316\n     */\n    public static void defaultInit(WebSettings webSettings) {\n        /**\n         * \u8bbe\u7f6ejs\n         */\n        //\u5982\u679c\u8bbf\u95ee\u7684\u9875\u9762\u4e2d\u8981\u4e0eJavascript\u4ea4\u4e92\uff0c\u5219webview\u5fc5\u987b\u8bbe\u7f6e\u652f\u6301Javascript\n        webSettings.setJavaScriptEnabled(true);\n        //\u652f\u6301\u901a\u8fc7JS\u6253\u5f00\u65b0\u7a97\u53e3\n        webSettings.setJavaScriptCanOpenWindowsAutomatically(true);\n        /**\n         * \u8bbe\u7f6e\u81ea\u9002\u5e94\u5c4f\u5e55\uff0c\u4e24\u8005\u5408\u7528\n         */\n        //\u5c06\u56fe\u7247\u8c03\u6574\u5230\u9002\u5408webview\u7684\u5927\u5c0f,\u652f\u6301\u53cc\u51fb\u7f29\u653e\uff0c\u540c\u65f6\u652f\u6301\u624b\u52bf\u64cd\u4f5c\u653e\u5927\u548c\u7f29\u5c0f?\n        webSettings.setUseWideViewPort(true);\n        // \u7f29\u653e\u81f3\u5c4f\u5e55\u7684\u5927\u5c0f\n        webSettings.setLoadWithOverviewMode(true);\n        //\u81ea\u9002\u5e94\u5c4f\u5e55.NARROW_COLUMNS:\u9002\u5e94\u5185\u5bb9\u5927\u5c0f\n        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);\n        /**\n         * \u7f29\u653e\u64cd\u4f5c\n         */\n        webSettings.setSupportZoom(true); //\u652f\u6301\u7f29\u653e\uff0c\u9ed8\u8ba4\u4e3atrue\u3002\u662f\u4e0b\u9762\u90a3\u4e2a\u7684\u524d\u63d0\u3002\n        webSettings.setBuiltInZoomControls(true); //\u7f29\u653e\u63a7\u4ef6\u3002\u82e5\u4e3afalse\uff0c\u5219\u8be5WebView\u4e0d\u53ef\u7f29\u653e\n        webSettings.setDisplayZoomControls(false); //\u9690\u85cf\u539f\u751f\u7684\u7f29\u653e\u63a7\u4ef6\n        /**\n         * \u56fe\u7247\n         */\n        webSettings.setBlockNetworkImage(false);//\u4e0d\u963b\u585e\u7f51\u7edc\u56fe\u7247,\u89e3\u51b3\u56fe\u7247\u4e0d\u663e\u793a\n        webSettings.setLoadsImagesAutomatically(true); //\u652f\u6301\u81ea\u52a8\u52a0\u8f7d\u56fe\u7247\n        /**\n         * \u5b57\u4f53\n         */\n        webSettings.setDefaultTextEncodingName(\"utf-8\");//\u8bbe\u7f6e\u7f16\u7801\u683c\u5f0f,utf-8, GBK\n        webSettings.setTextSize(WebSettings.TextSize.NORMAL);//\u8bbe\u7f6e\u7f51\u9875\u5b57\u4f53\u5927\u5c0f, \u8fc7\u65f6, \u7528\u4e0b\u9762\u65b9\u6cd5\u2193\n        webSettings.setTextZoom(100);//\u8bbe\u7f6e\u9875\u9762\u7684\u6587\u672c\u7f29\u653e\u767e\u5206\u6bd4, \u9ed8\u8ba4100\n        /**\n         * \u7f13\u5b58cache\n         */\n        webSettings.setDomStorageEnabled(false);//\u8bbe\u7f6e\u7f13\u5b58,\u6ca1\u6570\u636e\u4e5f\u53ef\u52a0\u8f7d\n        webSettings.setAppCacheEnabled(true);//\u9875\u9762,\u56fe\u7247,\u811a\u672c,css,js...\n        webSettings.setAppCachePath(ConfigUtils.APPLICATION.getCacheDir().getAbsolutePath());//\u8bbe\u7f6e\u7f13\u5b58\u76ee\u5f55\n//        webSettings.setAppCacheMaxSize(Long.MAX_VALUE);//\u8fc7\u65f6,\u81ea\u52a8\u7ba1\u7406\n        /*\n         * \u8bbe\u7f6e\u7f13\u5b58\u7684\u6a21\u5f0f\n         * \u4ec0\u4e48\u662fcache-control?\n         *   cache-control\u662f\u5728\u8bf7\u6c42\u7f51\u9875\u65f6\u670d\u52a1\u5668\u7684\u54cd\u5e94\u5934,\u6b64\u54cd\u5e94\u5934\u7528\u4e8e\u51b3\u5b9a\u7f51\u9875\u7684\u7f13\u5b58\u7b56\u7565.\n         *   \u5e38\u89c1\u7684\u53d6\u503c\u6709public(\u6240\u6709\u5185\u5bb9\u90fd\u5c06\u88ab\u7f13\u5b58),\n         *   private(\u5185\u5bb9\u53ea\u7f13\u5b58\u5230\u79c1\u6709\u7f13\u5b58\u4e2d),\n         *   no-cache(\u6240\u6709\u5185\u5bb9\u90fd\u4e0d\u4f1a\u88ab\u7f13\u5b58),\n         *   max-age=xxx(\u7f13\u5b58\u7684\u5185\u5bb9\u5c06\u5728 xxx \u79d2\u540e\u5931\u6548)\u7b49\u7b49\n         *\n         * WebSettings.LOAD_CACHE_ELSE_NETWORK  \u53ea\u8981\u672c\u5730\u6709\uff0c\u65e0\u8bba\u662f\u5426\u8fc7\u671f\uff0c\u6216\u8005no-cache\uff0c\u90fd\u4f7f\u7528\u7f13\u5b58\u4e2d\u7684\u6570\u636e\n         * WebSettings.LOAD_CACHE_ONLY          \u53ea\u52a0\u8f7d\u7f13\u5b58\n         * WebSettings.LOAD_DEFAULT             \u6839\u636ecache-control\u51b3\u5b9a\u662f\u5426\u4ece\u7f51\u7edc\u4e0a\u53d6\u6570\u636e\n         * WebSettings.LOAD_NO_CACHE            \u4e0d\u52a0\u8f7d\u7f13\u5b58\n         * WebSettings.LOAD_NORMAL\n         */\n        webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n        /**\n         * \u6570\u636e\u5e93\n         */\n        webSettings.setDatabaseEnabled(true);\n        //\u5df2\u8fc7\u65f6, \u81ea\u52a8\u7ba1\u7406\n//        webSettings.setDatabasePath(getContext().getDatabasePath(\"database\").getAbsolutePath());\n        //\u5730\u7406\u4f4d\u7f6e\u6570\u636e\u5e93\u7684\u8def\u5f84, \u5df2\u8fc7\u65f6, \u81ea\u52a8\u7ba1\u7406\n//        webSettings.setGeolocationDatabasePath(getContext().getDir(\"geolocation\", Context.MODE_PRIVATE).getPath());\n        /**\n         * \u52a0\u8f7d\u6765\u6e90\n         */\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {//\u5b89\u53535.0\u4ee5\u4e0a\u7684\u6743\u9650\n            /**\n             * MIXED_CONTENT_ALWAYS_ALLOW\uff1a\u5141\u8bb8\u4ece\u4efb\u4f55\u6765\u6e90\u52a0\u8f7d\u5185\u5bb9\uff0c\u5373\u4f7f\u8d77\u6e90\u662f\u4e0d\u5b89\u5168\u7684\uff1b\n             * MIXED_CONTENT_NEVER_ALLOW\uff1a\u4e0d\u5141\u8bb8Https\u52a0\u8f7dHttp\u7684\u5185\u5bb9\uff0c\u5373\u4e0d\u5141\u8bb8\u4ece\u5b89\u5168\u7684\u8d77\u6e90\u53bb\u52a0\u8f7d\u4e00\u4e2a\u4e0d\u5b89\u5168\u7684\u8d44\u6e90\uff1b\n             * MIXED_CONTENT_COMPATIBILITY_MODE\uff1a\u5f53\u6d89\u53ca\u5230\u6df7\u5408\u5f0f\u5185\u5bb9\u65f6\uff0cWebView \u4f1a\u5c1d\u8bd5\u53bb\u517c\u5bb9\u6700\u65b0Web\u6d4f\u89c8\u5668\u7684\u98ce\u683c\u3002\n             **/\n            webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n        }\n        /**\n         * \u5176\u4ed6\u64cd\u4f5c\n         */\n        webSettings.setAllowFileAccess(true); //\u8bbe\u7f6e\u53ef\u4ee5\u8bbf\u95ee\u6587\u4ef6\n        //\u4fdd\u5b58\u5bc6\u7801\n        webSettings.setSavePassword(false);\n        //\u8bbe\u7f6e\u662f\u5426\u542f\u7528\u5730\u7406\u4f4d\u7f6e\n        webSettings.setGeolocationEnabled(true);\n        /*\n         * \u544a\u8bc9WebView\u6309\u9700\u542f\u7528\u3001\u7981\u7528\u6216\u4f7f\u7528\u63d2\u4ef6(swf?)\u3002\u5728 ON_DEMAND \u6a21\u5f0f\u610f\u5473\u7740\u5982\u679c\u63d2\u4ef6\u5b58\u5728\uff0c\n         * \u5c31\u53ef\u4ee5\u5904\u7406\u5d4c\u5165\u7684\u63d2\u4ef6\u5185\u5bb9\uff0c\u4e00\u4e2a\u5360\u4f4d\u7b26\u56fe\u6807\u5c06\u663e\u793a\u800c\u4e0d\u662f\u63d2\u4ef6\u3002\n         * \u5f53\u70b9\u51fb\u5360\u4f4d\u7b26\uff0c\u63d2\u4ef6\u5c06\u88ab\u542f\u7528. \u9ed8\u8ba4OFF.\n         */\n        webSettings.setPluginState(WebSettings.PluginState.ON_DEMAND);\n        /*\n         * UserAgent, \u4f8b:\n         * Mozilla/5.0 (Linux; Android 9; COL-AL10 Build/HUAWEICOL-AL10; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/69.0.3497.100 Mobile Safari/537.36\n         */\n//        String userAgentString = webSettings.getUserAgentString();\n//        webSettings.setUserAgentString(userAgentString);\n    }\n"]]}
{"hexsha": "117d1bfc6a7d95635dd924ba6af65c3abadbb183", "ext": "java", "lang": "Java", "content": "public class ProvisionFailureEventNode extends RemoteServiceEventNode<ProvisionFailureEvent> {\n    private String status;\n\n    public ProvisionFailureEventNode(ProvisionFailureEvent event) {\n        super(event);\n        status = \"Pending\";\n    }\n\n    @Override\n    public Throwable getThrown() {\n        return getEvent().getThrowable();\n    }\n\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder();\n        for(String reason : getEvent().getFailureReasons()) {\n            if(builder.length()>0)\n                builder.append(\"\\n    \");\n            builder.append(reason);\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public String getOperationalStringName() {\n        return getEvent().getServiceElement().getOperationalStringName();\n    }\n\n    @Override\n    public String getServiceName() {\n        return getEvent().getServiceElement().getName();\n    }\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n\n    @Override\n    public String toString() {\n        return getServiceName();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 3;\n    }\n\n    @Override\n    public Object getValueAt(int column) {\n        String value;\n        if (column == 0) {\n            value = \"PROVISION_FAILURE\";\n        } else if (column == 1) {\n            value = getDescription();\n        } else {\n            value = Constants.DATE_FORMAT.format(getDate());\n        }\n        return value;\n    }\n}", "class_id": 0, "repo": "khartig/assimilator", "file": "rio-tools/rio-ui/src/main/java/org/rioproject/tools/ui/servicenotification/ProvisionFailureEventNode.java", "last_update_at": "2021-02-07T11:36:51+00:00", "question_id": "117d1bfc6a7d95635dd924ba6af65c3abadbb183", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProvisionFailureEventNode extends RemoteServiceEventNode<ProvisionFailureEvent> {\n    private String status;\n    public ProvisionFailureEventNode(ProvisionFailureEvent event) {\n        super(event);\n        status = \"Pending\";\n    }\n    @Override\n    public Throwable getThrown() {\n        return getEvent().getThrowable();\n    }\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder();\n        for(String reason : getEvent().getFailureReasons()) {\n            if(builder.length()>0)\n                builder.append(\"\\n    \");\n            builder.append(reason);\n        }\n        return builder.toString();\n    }\n    @Override\n    public String getOperationalStringName() {\n        return getEvent().getServiceElement().getOperationalStringName();\n    }\n    @Override\n    public String getServiceName() {\n        return getEvent().getServiceElement().getName();\n    }\n    public String getStatus() {\n        return status;\n    }\n    public void setStatus(String status) {\n        this.status = status;\n    }\n    @Override\n    public String toString() {\n        return getServiceName();\n    }\n    @Override\n    public int getColumnCount() {\n        return 3;\n    }\n    @Override\n    public Object getValueAt(int column) {\n        String value;\n        if (column == 0) {\n            value = \"PROVISION_FAILURE\";\n        } else if (column == 1) {\n            value = getDescription();\n        } else {\n            value = Constants.DATE_FORMAT.format(getDate());\n        }\n        return value;\n    }\n"]]}
{"hexsha": "95fc3562a6d884a48bc6d5bc1a1773c7aed9a8a8", "ext": "java", "lang": "Java", "content": "@Vetoed\npublic class Linker {\n\n\tprivate final Router router;\n\tprivate final ServletContext context;\n\tprivate final List<Object> args;\n\tprivate final String methodName;\n\tprivate final Class<?> controller;\n\tprivate final ReflectionProvider reflectionProvider;\n\n\tpublic Linker(ServletContext context, Router router, Class<?> controller, String methodName, List<Object> args,\n\t\t\tReflectionProvider reflectionProvider) {\n\t\tthis.router = router;\n\t\tthis.context = context;\n\t\tthis.controller = controller;\n\t\tthis.methodName = methodName;\n\t\tthis.args = args;\n\t\tthis.reflectionProvider = reflectionProvider;\n\t}\n\n\tprotected String getLink() {\n\t\tMethod method = getMethod();\n\t\treturn getPrefix() + router.urlFor(controller, method, getArgs(method));\n\t}\n\n\tprotected String getPrefix() {\n\t\treturn context.getContextPath();\n\t}\n\t\n\tprotected Method getMethod() {\n\t\tMethod method = null;\n\n\t\tif (countMethodsWithSameName() > 1) {\n\t\t\tmethod = reflectionProvider.getMethod(controller, methodName, getClasses(args));\n\t\t\tif (method == null && args.isEmpty()) {\n\t\t\t\tthrow new IllegalArgumentException(\"Ambiguous method '\" + methodName + \"' on \" + controller + \". Try to add some parameters to resolve ambiguity, or use different method names.\");\n\t\t\t}\n\t\t} else {\n\t\t\tmethod = findMethodWithName(controller, methodName);\n\t\t}\n\n\t\tif(method == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\"There are no methods on %s named '%s' that receives args of types %s\",\n\t\t\t\t\t\tcontroller, methodName, Arrays.toString(getClasses(args))));\n\t\t}\n\t\treturn method;\n\t}\n\n\tprotected Object[] getArgs(Method method) {\n\t\tint methodArity = method.getParameterTypes().length;\n\n\t\tif (args.size() == methodArity) {\n\t\t\treturn args.toArray();\n\t\t}\n\n\t\tif (args.size() > methodArity) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"linkTo param args must have the same or lower length as method param args. linkTo args: %d | method args: %d\", args.size(), methodArity));\n\t\t}\n\n\t\tObject[] noMissingParamsArgs = new Object[methodArity];\n\t\tSystem.arraycopy(args.toArray(), 0, noMissingParamsArgs, 0, args.size());\n\n\t\treturn noMissingParamsArgs;\n\t}\n\n\tprotected Method findMethodWithName(Class<?> type, String name) {\n\t\tfor (Method method : type.getDeclaredMethods()) {\n\t\t\tif (!method.isBridge() && method.getName().equals(name)) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\n\t\tif (type.getSuperclass().equals(Object.class)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn findMethodWithName(type.getSuperclass(), name);\n\t}\n\n\tprotected int countMethodsWithSameName() {\n\t\tint amount = 0;\n\t\tfor (Method method : controller.getDeclaredMethods()) {\n\t\t\tif (!method.isBridge() && method.getName().equals(methodName)) {\n\t\t\t\tamount++;\n\t\t\t}\n\t\t}\n\n\t\treturn amount;\n\t}\n\n\tprotected Class<?>[] getClasses(List<Object> params) {\n\t\tClass<?>[] classes = new Class<?>[params.size()];\n\t\tfor(int i = 0; i < params.size(); i ++) {\n\t\t\tclasses[i] = params.get(i).getClass();\n\t\t}\n\t\treturn classes;\n\t}\n}", "class_id": 0, "repo": "gruposwa/vraptor4", "file": "vraptor-core/src/main/java/br/com/caelum/vraptor/view/Linker.java", "last_update_at": "2021-12-16T23:35:05+00:00", "question_id": "95fc3562a6d884a48bc6d5bc1a1773c7aed9a8a8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Vetoed\npublic class Linker {\n\tprivate final Router router;\n\tprivate final ServletContext context;\n\tprivate final List<Object> args;\n\tprivate final String methodName;\n\tprivate final Class<?> controller;\n\tprivate final ReflectionProvider reflectionProvider;\n\tpublic Linker(ServletContext context, Router router, Class<?> controller, String methodName, List<Object> args,\n\t\t\tReflectionProvider reflectionProvider) {\n\t\tthis.router = router;\n\t\tthis.context = context;\n\t\tthis.controller = controller;\n\t\tthis.methodName = methodName;\n\t\tthis.args = args;\n\t\tthis.reflectionProvider = reflectionProvider;\n\t}\n\tprotected String getLink() {\n\t\tMethod method = getMethod();\n\t\treturn getPrefix() + router.urlFor(controller, method, getArgs(method));\n\t}\n\tprotected String getPrefix() {\n\t\treturn context.getContextPath();\n\t}\n\t\n\tprotected Method getMethod() {\n\t\tMethod method = null;\n\t\tif (countMethodsWithSameName() > 1) {\n\t\t\tmethod = reflectionProvider.getMethod(controller, methodName, getClasses(args));\n\t\t\tif (method == null && args.isEmpty()) {\n\t\t\t\tthrow new IllegalArgumentException(\"Ambiguous method '\" + methodName + \"' on \" + controller + \". Try to add some parameters to resolve ambiguity, or use different method names.\");\n\t\t\t}\n\t\t} else {\n\t\t\tmethod = findMethodWithName(controller, methodName);\n\t\t}\n\t\tif(method == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\"There are no methods on %s named '%s' that receives args of types %s\",\n\t\t\t\t\t\tcontroller, methodName, Arrays.toString(getClasses(args))));\n\t\t}\n\t\treturn method;\n\t}\n\tprotected Object[] getArgs(Method method) {\n\t\tint methodArity = method.getParameterTypes().length;\n\t\tif (args.size() == methodArity) {\n\t\t\treturn args.toArray();\n\t\t}\n\t\tif (args.size() > methodArity) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"linkTo param args must have the same or lower length as method param args. linkTo args: %d | method args: %d\", args.size(), methodArity));\n\t\t}\n\t\tObject[] noMissingParamsArgs = new Object[methodArity];\n\t\tSystem.arraycopy(args.toArray(), 0, noMissingParamsArgs, 0, args.size());\n\t\treturn noMissingParamsArgs;\n\t}\n\tprotected Method findMethodWithName(Class<?> type, String name) {\n\t\tfor (Method method : type.getDeclaredMethods()) {\n\t\t\tif (!method.isBridge() && method.getName().equals(name)) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\tif (type.getSuperclass().equals(Object.class)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn findMethodWithName(type.getSuperclass(), name);\n\t}\n\tprotected int countMethodsWithSameName() {\n\t\tint amount = 0;\n\t\tfor (Method method : controller.getDeclaredMethods()) {\n\t\t\tif (!method.isBridge() && method.getName().equals(methodName)) {\n\t\t\t\tamount++;\n\t\t\t}\n\t\t}\n\t\treturn amount;\n\t}\n\tprotected Class<?>[] getClasses(List<Object> params) {\n\t\tClass<?>[] classes = new Class<?>[params.size()];\n\t\tfor(int i = 0; i < params.size(); i ++) {\n\t\t\tclasses[i] = params.get(i).getClass();\n\t\t}\n\t\treturn classes;\n\t}\n"]]}
{"hexsha": "855941c331899e68cc0842119277b6bc04059a56", "ext": "java", "lang": "Java", "content": "class TrueFalseQuestionTest {\n\n    private static TrueFalseQuestion validTfQuestion = null;\n\n    @BeforeEach\n    void setUp() {\n        Set<Choice> validTfqChoices = new HashSet<>();\n        validTfqChoices.add(new Choice(TRUE_CHOICE_TITLE, false));\n        validTfqChoices.add(new Choice(FALSE_CHOICE_TITLE, true));\n\n        validTfQuestion = new TrueFalseQuestion(new Name(VALID_QUESTION_1),\n                new Importance(VALID_IMPORTANCE_1), new HashSet<>(), validTfqChoices);\n    }\n\n    @Test\n    void isValidQuestion_validAnswers_true() {\n        assertTrue(validTfQuestion.isValidQuestion());\n    }\n\n    @Test\n    void isValidTrueFalseChoice_validChoice_true() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(TRUE_CHOICE_TITLE, false));\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(FALSE_CHOICE_TITLE, true));\n    }\n\n    @Test\n    void isValidTrueFalseChoice_invalidChoice_false() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(VALID_ANSWER_1, false));\n    }\n}", "class_id": 0, "repo": "cedricongjh/tp", "file": "src/test/java/seedu/smartnus/model/question/TrueFalseQuestionTest.java", "last_update_at": "2021-11-11T11:13:31+00:00", "question_id": "855941c331899e68cc0842119277b6bc04059a56", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class TrueFalseQuestionTest {\n    private static TrueFalseQuestion validTfQuestion = null;\n    @BeforeEach\n    void setUp() {\n        Set<Choice> validTfqChoices = new HashSet<>();\n        validTfqChoices.add(new Choice(TRUE_CHOICE_TITLE, false));\n        validTfqChoices.add(new Choice(FALSE_CHOICE_TITLE, true));\n        validTfQuestion = new TrueFalseQuestion(new Name(VALID_QUESTION_1),\n                new Importance(VALID_IMPORTANCE_1), new HashSet<>(), validTfqChoices);\n    }\n    @Test\n    void isValidQuestion_validAnswers_true() {\n        assertTrue(validTfQuestion.isValidQuestion());\n    }\n    @Test\n    void isValidTrueFalseChoice_validChoice_true() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(TRUE_CHOICE_TITLE, false));\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(FALSE_CHOICE_TITLE, true));\n    }\n    @Test\n    void isValidTrueFalseChoice_invalidChoice_false() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(VALID_ANSWER_1, false));\n    }\n"]]}
{"hexsha": "0c671b7afe8a693de6d48a3af9f2b3772d1a2aa8", "ext": "java", "lang": "Java", "content": "public class InsertTag extends SimpleTagSupport {\n    private String definitionName = null;\n    private String parameterName = null;\n\n    public InsertTag() {\n        super();\n    }\n\n    public void setParameter(String parameter) {\n        this.parameterName = parameter;\n    }\n\n    public void setDefinition(String name) {\n        this.definitionName = name;\n    }\n\n    public void doTag() throws JspTagException {\n        Definition definition = null;\n        Parameter parameter = null;\n        boolean directInclude = false;\n        PageContext context = (PageContext) getJspContext();\n\n        // get the definition from the page context\n        definition = (Definition) context.getAttribute(\n                    definitionName,\n                    context.APPLICATION_SCOPE);\n\n        // get the parameter\n        if ((parameterName != null) && (definition != null)) {\n            parameter = (Parameter) definition.getParam(parameterName);\n        }\n\n        if (parameter != null) {\n            directInclude = parameter.isDirect();\n        }\n\n        try {\n            // if parameter is direct, print to out\n            if (directInclude && (parameter != null)) {\n                context.getOut()\n                       .print(parameter.getValue());\n            }\n            // if parameter is indirect, include results of dispatching to page \n            else {\n                if ((parameter != null) && (parameter.getValue() != null)) {\n                    context.include(parameter.getValue());\n                }\n            }\n        } catch (Exception ex) {\n            Throwable rootCause = null;\n\n            if (ex instanceof ServletException) {\n                rootCause = ((ServletException) ex).getRootCause();\n            }\n\n            throw new JspTagException(\n                ex.getMessage(),\n                rootCause);\n        }\n    }\n}", "class_id": 0, "repo": "kwkoo/fsi-workshop-v2m1-labs", "file": "monolith/dukesbank-war/src/main/java/com/sun/tutorial/javaee/dukesbank/web/template/InsertTag.java", "last_update_at": "2021-03-02T21:01:01+00:00", "question_id": "0c671b7afe8a693de6d48a3af9f2b3772d1a2aa8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InsertTag extends SimpleTagSupport {\n    private String definitionName = null;\n    private String parameterName = null;\n    public InsertTag() {\n        super();\n    }\n    public void setParameter(String parameter) {\n        this.parameterName = parameter;\n    }\n    public void setDefinition(String name) {\n        this.definitionName = name;\n    }\n    public void doTag() throws JspTagException {\n        Definition definition = null;\n        Parameter parameter = null;\n        boolean directInclude = false;\n        PageContext context = (PageContext) getJspContext();\n        // get the definition from the page context\n        definition = (Definition) context.getAttribute(\n                    definitionName,\n                    context.APPLICATION_SCOPE);\n        // get the parameter\n        if ((parameterName != null) && (definition != null)) {\n            parameter = (Parameter) definition.getParam(parameterName);\n        }\n        if (parameter != null) {\n            directInclude = parameter.isDirect();\n        }\n        try {\n            // if parameter is direct, print to out\n            if (directInclude && (parameter != null)) {\n                context.getOut()\n                       .print(parameter.getValue());\n            }\n            // if parameter is indirect, include results of dispatching to page \n            else {\n                if ((parameter != null) && (parameter.getValue() != null)) {\n                    context.include(parameter.getValue());\n                }\n            }\n        } catch (Exception ex) {\n            Throwable rootCause = null;\n            if (ex instanceof ServletException) {\n                rootCause = ((ServletException) ex).getRootCause();\n            }\n            throw new JspTagException(\n                ex.getMessage(),\n                rootCause);\n        }\n    }\n"]]}
{"hexsha": "0a1afb5c947f6e859bce2ccb8a05da9ecf9f75e5", "ext": "java", "lang": "Java", "content": "public class IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest {\n\n    @RegisterExtension\n    static QuarkusUnitTest runner = new QuarkusUnitTest()\n            .withApplicationRoot((jar) -> jar\n                    .addClass(MyEntity.class)\n                    .addAsManifestResource(\"META-INF/persistence-discriminator-ignore-explicit-for-joined-false-value.xml\",\n                            \"persistence.xml\")\n                    .addAsResource(\"application-datasource-only.properties\", \"application.properties\"));\n\n    @Inject\n    EntityManager em;\n\n    @ActivateRequestContext\n    @Test\n    public void testFalseValue() {\n        Map<String, Object> properties = em.getEntityManagerFactory().getProperties();\n\n        // the PU is templatePU from the persistence.xml, not the default entity manager from application.properties\n        assertEquals(\"templatePU\", properties.get(\"hibernate.ejb.persistenceUnitName\"));\n        assertEquals(\"false\", properties.get(\"hibernate.discriminator.ignore_explicit_for_joined\"));\n    }\n}", "class_id": 0, "repo": "Markus-Schwer/quarkus", "file": "extensions/hibernate-orm/deployment/src/test/java/io/quarkus/hibernate/orm/ignore_explicit_for_joined/IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest.java", "last_update_at": "2021-07-27T10:45:53+00:00", "question_id": "0a1afb5c947f6e859bce2ccb8a05da9ecf9f75e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest {\n    @RegisterExtension\n    static QuarkusUnitTest runner = new QuarkusUnitTest()\n            .withApplicationRoot((jar) -> jar\n                    .addClass(MyEntity.class)\n                    .addAsManifestResource(\"META-INF/persistence-discriminator-ignore-explicit-for-joined-false-value.xml\",\n                            \"persistence.xml\")\n                    .addAsResource(\"application-datasource-only.properties\", \"application.properties\"));\n    @Inject\n    EntityManager em;\n    @ActivateRequestContext\n    @Test\n    public void testFalseValue() {\n        Map<String, Object> properties = em.getEntityManagerFactory().getProperties();\n        // the PU is templatePU from the persistence.xml, not the default entity manager from application.properties\n        assertEquals(\"templatePU\", properties.get(\"hibernate.ejb.persistenceUnitName\"));\n        assertEquals(\"false\", properties.get(\"hibernate.discriminator.ignore_explicit_for_joined\"));\n    }\n"]]}
{"hexsha": "e81c1f3aac9022f7c0a476697baebee32efeef68", "ext": "java", "lang": "Java", "content": "class customers{\n\t\tint tableNo;\n\t\tString name;\n\t\tint phoneNo;\n\n\t\tvoid customerData()\n\t\t{\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tSystem.out.print(\"Entere no.    :\");\n\t\t\ttableNo = sc.nextInt();\n\t\t\tSystem.out.print(\"Entermer name : \");\n\t\t\tname = sc.next();\n\t\t\tSystem.out.print(\"Entere no.    :\");\n\t\t\tphoneNo = sc.nextInt();\n\t\t}\n}", "class_id": 1, "repo": "umanggoel2001/Hacktoberfest2021-1", "file": "hotel_AP.java", "last_update_at": "2021-11-08T12:01:08+00:00", "question_id": "e81c1f3aac9022f7c0a476697baebee32efeef68", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class customers{\n\t\tint tableNo;\n\t\tString name;\n\t\tint phoneNo;\n\t\tvoid customerData()\n\t\t{\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tSystem.out.print(\"Entere no.    :\");\n\t\t\ttableNo = sc.nextInt();\n\t\t\tSystem.out.print(\"Entermer name : \");\n\t\t\tname = sc.next();\n\t\t\tSystem.out.print(\"Entere no.    :\");\n\t\t\tphoneNo = sc.nextInt();\n\t\t}\n"]]}
{"hexsha": "36e36bd6a324cff383b99117320c5b7080ea7be0", "ext": "java", "lang": "Java", "content": "public class Literals {\n    public static void main(String[] args) {\n        // int\n        var i = 1234;\n        // double\n        var d1 = 1.;\n        var d2 = 1.0;\n        var d3 = 1.123456;\n        var d4 = 5e3;// 5 * 10 ^ 3 == 5000.0\n        // boolean\n        var b1 = true;\n        var b2 = false;\n        // char\n        var ch1 = 'a';\n        var ch2 = '\\t';\n        var ch3 = '\\n';\n        // String\n        var s1 = \"a\";\n        var s2 = \"Hello world\";\n\n        //\n        int num = 1;\n        char ch = '1';\n        String s = \"1\";\n    }\n}", "class_id": 0, "repo": "lanaflonPerso/java-basic", "file": "src/academy/devonline/java/basic/section03_expression/Literals.java", "last_update_at": "2021-12-27T16:00:51+00:00", "question_id": "36e36bd6a324cff383b99117320c5b7080ea7be0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Literals {\n    public static void main(String[] args) {\n        // int\n        var i = 1234;\n        // double\n        var d1 = 1.;\n        var d2 = 1.0;\n        var d3 = 1.123456;\n        var d4 = 5e3;// 5 * 10 ^ 3 == 5000.0\n        // boolean\n        var b1 = true;\n        var b2 = false;\n        // char\n        var ch1 = 'a';\n        var ch2 = '\\t';\n        var ch3 = '\\n';\n        // String\n        var s1 = \"a\";\n        var s2 = \"Hello world\";\n        //\n        int num = 1;\n        char ch = '1';\n        String s = \"1\";\n    }\n"]]}
{"hexsha": "475d786aedd10b146cce1f943e4de0d4c30628a6", "ext": "java", "lang": "Java", "content": "final public class IpConnectivityMetrics extends SystemService {\n    private static final String TAG = IpConnectivityMetrics.class.getSimpleName();\n    private static final boolean DBG = false;\n\n    // The logical version numbers of ipconnectivity.proto, corresponding to the\n    // \"version\" field of IpConnectivityLog.\n    private static final int NYC      = 0;\n    private static final int NYC_MR1  = 1;\n    private static final int NYC_MR2  = 2;\n    public static final int VERSION   = NYC_MR2;\n\n    private static final String SERVICE_NAME = IpConnectivityLog.SERVICE_NAME;\n\n    // Default size of the event buffer. Once the buffer is full, incoming events are dropped.\n    private static final int DEFAULT_BUFFER_SIZE = 2000;\n    // Maximum size of the event buffer.\n    private static final int MAXIMUM_BUFFER_SIZE = DEFAULT_BUFFER_SIZE * 10;\n\n    private static final int MAXIMUM_CONNECT_LATENCY_RECORDS = 20000;\n\n    private static final int ERROR_RATE_LIMITED = -1;\n\n    // Lock ensuring that concurrent manipulations of the event buffer are correct.\n    // There are three concurrent operations to synchronize:\n    //  - appending events to the buffer.\n    //  - iterating throught the buffer.\n    //  - flushing the buffer content and replacing it by a new buffer.\n    private final Object mLock = new Object();\n\n    @VisibleForTesting\n    public final Impl impl = new Impl();\n    @VisibleForTesting\n    NetdEventListenerService mNetdListener;\n\n    @GuardedBy(\"mLock\")\n    private ArrayList<ConnectivityMetricsEvent> mBuffer;\n    @GuardedBy(\"mLock\")\n    private int mDropped;\n    @GuardedBy(\"mLock\")\n    private int mCapacity;\n    @GuardedBy(\"mLock\")\n    private final ArrayMap<Class<?>, TokenBucket> mBuckets = makeRateLimitingBuckets();\n\n    private final ToIntFunction<Context> mCapacityGetter;\n\n    public IpConnectivityMetrics(Context ctx, ToIntFunction<Context> capacityGetter) {\n        super(ctx);\n        mCapacityGetter = capacityGetter;\n        initBuffer();\n    }\n\n    public IpConnectivityMetrics(Context ctx) {\n        this(ctx, READ_BUFFER_SIZE);\n    }\n\n    @Override\n    public void onStart() {\n        if (DBG) Log.d(TAG, \"onStart\");\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {\n            if (DBG) Log.d(TAG, \"onBootPhase\");\n            mNetdListener = new NetdEventListenerService(getContext());\n\n            publishBinderService(SERVICE_NAME, impl);\n            publishBinderService(mNetdListener.SERVICE_NAME, mNetdListener);\n        }\n    }\n\n    @VisibleForTesting\n    public int bufferCapacity() {\n        return mCapacityGetter.applyAsInt(getContext());\n    }\n\n    private void initBuffer() {\n        synchronized (mLock) {\n            mDropped = 0;\n            mCapacity = bufferCapacity();\n            mBuffer = new ArrayList<>(mCapacity);\n        }\n    }\n\n    private int append(ConnectivityMetricsEvent event) {\n        if (DBG) Log.d(TAG, \"logEvent: \" + event);\n        synchronized (mLock) {\n            final int left = mCapacity - mBuffer.size();\n            if (event == null) {\n                return left;\n            }\n            if (isRateLimited(event)) {\n                // Do not count as a dropped event. TODO: consider adding separate counter\n                return ERROR_RATE_LIMITED;\n            }\n            if (left == 0) {\n                mDropped++;\n                return 0;\n            }\n            mBuffer.add(event);\n            return left - 1;\n        }\n    }\n\n    private boolean isRateLimited(ConnectivityMetricsEvent event) {\n        TokenBucket tb = mBuckets.get(event.data.getClass());\n        return (tb != null) && !tb.get();\n    }\n\n    private String flushEncodedOutput() {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        final int dropped;\n        synchronized (mLock) {\n            events = mBuffer;\n            dropped = mDropped;\n            initBuffer();\n        }\n\n        final List<IpConnectivityEvent> protoEvents = IpConnectivityEventBuilder.toProto(events);\n\n        if (mNetdListener != null) {\n            mNetdListener.flushStatistics(protoEvents);\n        }\n\n        final byte[] data;\n        try {\n            data = IpConnectivityEventBuilder.serialize(dropped, protoEvents);\n        } catch (IOException e) {\n            Log.e(TAG, \"could not serialize events\", e);\n            return \"\";\n        }\n\n        return Base64.encodeToString(data, Base64.DEFAULT);\n    }\n\n    /**\n     * Clears the event buffer and prints its content as a protobuf serialized byte array\n     * inside a base64 encoded string.\n     */\n    private void cmdFlush(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(flushEncodedOutput());\n    }\n\n    /**\n     * Prints the content of the event buffer, either using the events ASCII representation\n     * or using protobuf text format.\n     */\n    private void cmdList(FileDescriptor fd, PrintWriter pw, String[] args) {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        synchronized (mLock) {\n            events = new ArrayList(mBuffer);\n        }\n\n        if (args.length > 1 && args[1].equals(\"proto\")) {\n            for (IpConnectivityEvent ev : IpConnectivityEventBuilder.toProto(events)) {\n                pw.print(ev.toString());\n            }\n            if (mNetdListener != null) {\n                mNetdListener.listAsProtos(pw);\n            }\n            return;\n        }\n\n        for (ConnectivityMetricsEvent ev : events) {\n            pw.println(ev.toString());\n        }\n        if (mNetdListener != null) {\n            mNetdListener.list(pw);\n        }\n    }\n\n    private void cmdStats(FileDescriptor fd, PrintWriter pw, String[] args) {\n        synchronized (mLock) {\n            pw.println(\"Buffered events: \" + mBuffer.size());\n            pw.println(\"Buffer capacity: \" + mCapacity);\n            pw.println(\"Dropped events: \" + mDropped);\n        }\n        if (mNetdListener != null) {\n            mNetdListener.dump(pw);\n        }\n    }\n\n    private void cmdDefault(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (args.length == 0) {\n            pw.println(\"No command\");\n            return;\n        }\n        pw.println(\"Unknown command \" + TextUtils.join(\" \", args));\n    }\n\n    public final class Impl extends IIpConnectivityMetrics.Stub {\n        static final String CMD_FLUSH   = \"flush\";\n        static final String CMD_LIST    = \"list\";\n        static final String CMD_STATS   = \"stats\";\n        static final String CMD_DUMPSYS = \"-a\"; // dumpsys.cpp dumps services with \"-a\" as arguments\n        static final String CMD_DEFAULT = CMD_STATS;\n\n        @Override\n        public int logEvent(ConnectivityMetricsEvent event) {\n            enforceConnectivityInternalPermission();\n            return append(event);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n            enforceDumpPermission();\n            if (DBG) Log.d(TAG, \"dumpsys \" + TextUtils.join(\" \", args));\n            final String cmd = (args.length > 0) ? args[0] : CMD_DEFAULT;\n            switch (cmd) {\n                case CMD_FLUSH:\n                    cmdFlush(fd, pw, args);\n                    return;\n                case CMD_DUMPSYS:\n                    // Fallthrough to CMD_LIST when dumpsys.cpp dumps services states (bug reports)\n                case CMD_LIST:\n                    cmdList(fd, pw, args);\n                    return;\n                case CMD_STATS:\n                    cmdStats(fd, pw, args);\n                    return;\n                default:\n                    cmdDefault(fd, pw, args);\n            }\n        }\n\n        private void enforceConnectivityInternalPermission() {\n            enforcePermission(android.Manifest.permission.CONNECTIVITY_INTERNAL);\n        }\n\n        private void enforceDumpPermission() {\n            enforcePermission(android.Manifest.permission.DUMP);\n        }\n\n        private void enforcePermission(String what) {\n            getContext().enforceCallingOrSelfPermission(what, \"IpConnectivityMetrics\");\n        }\n\n        private void enforceNetdEventListeningPermission() {\n            final int uid = Binder.getCallingUid();\n            if (uid != Process.SYSTEM_UID) {\n                throw new SecurityException(String.format(\"Uid %d has no permission to listen for\"\n                        + \" netd events.\", uid));\n            }\n        }\n\n        @Override\n        public boolean registerNetdEventCallback(INetdEventCallback callback) {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                return false;\n            }\n            return mNetdListener.registerNetdEventCallback(callback);\n        }\n\n        @Override\n        public boolean unregisterNetdEventCallback() {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                // if the service is null, we aren't registered anyway\n                return true;\n            }\n            return mNetdListener.unregisterNetdEventCallback();\n        }\n    };\n\n    private static final ToIntFunction<Context> READ_BUFFER_SIZE = (ctx) -> {\n        int size = Settings.Global.getInt(ctx.getContentResolver(),\n                Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);\n        if (size <= 0) {\n            return DEFAULT_BUFFER_SIZE;\n        }\n        return Math.min(size, MAXIMUM_BUFFER_SIZE);\n    };\n\n    private static ArrayMap<Class<?>, TokenBucket> makeRateLimitingBuckets() {\n        ArrayMap<Class<?>, TokenBucket> map = new ArrayMap<>();\n        // one token every minute, 50 tokens max: burst of ~50 events every hour.\n        map.put(ApfProgramEvent.class, new TokenBucket((int)DateUtils.MINUTE_IN_MILLIS, 50));\n        return map;\n    }\n}", "class_id": 0, "repo": "FrankKwok/Oreo", "file": "com/android/server/connectivity/IpConnectivityMetrics.java", "last_update_at": "2021-10-01T13:23:16+00:00", "question_id": "475d786aedd10b146cce1f943e4de0d4c30628a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final public class IpConnectivityMetrics extends SystemService {\n    private static final String TAG = IpConnectivityMetrics.class.getSimpleName();\n    private static final boolean DBG = false;\n    // The logical version numbers of ipconnectivity.proto, corresponding to the\n    // \"version\" field of IpConnectivityLog.\n    private static final int NYC      = 0;\n    private static final int NYC_MR1  = 1;\n    private static final int NYC_MR2  = 2;\n    public static final int VERSION   = NYC_MR2;\n    private static final String SERVICE_NAME = IpConnectivityLog.SERVICE_NAME;\n    // Default size of the event buffer. Once the buffer is full, incoming events are dropped.\n    private static final int DEFAULT_BUFFER_SIZE = 2000;\n    // Maximum size of the event buffer.\n    private static final int MAXIMUM_BUFFER_SIZE = DEFAULT_BUFFER_SIZE * 10;\n    private static final int MAXIMUM_CONNECT_LATENCY_RECORDS = 20000;\n    private static final int ERROR_RATE_LIMITED = -1;\n    // Lock ensuring that concurrent manipulations of the event buffer are correct.\n    // There are three concurrent operations to synchronize:\n    //  - appending events to the buffer.\n    //  - iterating throught the buffer.\n    //  - flushing the buffer content and replacing it by a new buffer.\n    private final Object mLock = new Object();\n    @VisibleForTesting\n    public final Impl impl = new Impl();\n    @VisibleForTesting\n    NetdEventListenerService mNetdListener;\n    @GuardedBy(\"mLock\")\n    private ArrayList<ConnectivityMetricsEvent> mBuffer;\n    @GuardedBy(\"mLock\")\n    private int mDropped;\n    @GuardedBy(\"mLock\")\n    private int mCapacity;\n    @GuardedBy(\"mLock\")\n    private final ArrayMap<Class<?>, TokenBucket> mBuckets = makeRateLimitingBuckets();\n    private final ToIntFunction<Context> mCapacityGetter;\n    public IpConnectivityMetrics(Context ctx, ToIntFunction<Context> capacityGetter) {\n        super(ctx);\n        mCapacityGetter = capacityGetter;\n        initBuffer();\n    }\n    public IpConnectivityMetrics(Context ctx) {\n        this(ctx, READ_BUFFER_SIZE);\n    }\n    @Override\n    public void onStart() {\n        if (DBG) Log.d(TAG, \"onStart\");\n    }\n    @Override\n    public void onBootPhase(int phase) {\n        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {\n            if (DBG) Log.d(TAG, \"onBootPhase\");\n            mNetdListener = new NetdEventListenerService(getContext());\n            publishBinderService(SERVICE_NAME, impl);\n            publishBinderService(mNetdListener.SERVICE_NAME, mNetdListener);\n        }\n    }\n    @VisibleForTesting\n    public int bufferCapacity() {\n        return mCapacityGetter.applyAsInt(getContext());\n    }\n    private void initBuffer() {\n        synchronized (mLock) {\n            mDropped = 0;\n            mCapacity = bufferCapacity();\n            mBuffer = new ArrayList<>(mCapacity);\n        }\n    }\n    private int append(ConnectivityMetricsEvent event) {\n        if (DBG) Log.d(TAG, \"logEvent: \" + event);\n        synchronized (mLock) {\n            final int left = mCapacity - mBuffer.size();\n            if (event == null) {\n                return left;\n            }\n            if (isRateLimited(event)) {\n                // Do not count as a dropped event. TODO: consider adding separate counter\n                return ERROR_RATE_LIMITED;\n            }\n            if (left == 0) {\n                mDropped++;\n                return 0;\n            }\n            mBuffer.add(event);\n            return left - 1;\n        }\n    }\n    private boolean isRateLimited(ConnectivityMetricsEvent event) {\n        TokenBucket tb = mBuckets.get(event.data.getClass());\n        return (tb != null) && !tb.get();\n    }\n    private String flushEncodedOutput() {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        final int dropped;\n        synchronized (mLock) {\n            events = mBuffer;\n            dropped = mDropped;\n            initBuffer();\n        }\n        final List<IpConnectivityEvent> protoEvents = IpConnectivityEventBuilder.toProto(events);\n        if (mNetdListener != null) {\n            mNetdListener.flushStatistics(protoEvents);\n        }\n        final byte[] data;\n        try {\n            data = IpConnectivityEventBuilder.serialize(dropped, protoEvents);\n        } catch (IOException e) {\n            Log.e(TAG, \"could not serialize events\", e);\n            return \"\";\n        }\n        return Base64.encodeToString(data, Base64.DEFAULT);\n    }\n    /**\n     * Clears the event buffer and prints its content as a protobuf serialized byte array\n     * inside a base64 encoded string.\n     */\n    private void cmdFlush(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(flushEncodedOutput());\n    }\n    /**\n     * Prints the content of the event buffer, either using the events ASCII representation\n     * or using protobuf text format.\n     */\n    private void cmdList(FileDescriptor fd, PrintWriter pw, String[] args) {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        synchronized (mLock) {\n            events = new ArrayList(mBuffer);\n        }\n        if (args.length > 1 && args[1].equals(\"proto\")) {\n            for (IpConnectivityEvent ev : IpConnectivityEventBuilder.toProto(events)) {\n                pw.print(ev.toString());\n            }\n            if (mNetdListener != null) {\n                mNetdListener.listAsProtos(pw);\n            }\n            return;\n        }\n        for (ConnectivityMetricsEvent ev : events) {\n            pw.println(ev.toString());\n        }\n        if (mNetdListener != null) {\n            mNetdListener.list(pw);\n        }\n    }\n    private void cmdStats(FileDescriptor fd, PrintWriter pw, String[] args) {\n        synchronized (mLock) {\n            pw.println(\"Buffered events: \" + mBuffer.size());\n            pw.println(\"Buffer capacity: \" + mCapacity);\n            pw.println(\"Dropped events: \" + mDropped);\n        }\n        if (mNetdListener != null) {\n            mNetdListener.dump(pw);\n        }\n    }\n    private void cmdDefault(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (args.length == 0) {\n            pw.println(\"No command\");\n            return;\n        }\n        pw.println(\"Unknown command \" + TextUtils.join(\" \", args));\n    }\n    public final class Impl extends IIpConnectivityMetrics.Stub {\n        static final String CMD_FLUSH   = \"flush\";\n        static final String CMD_LIST    = \"list\";\n        static final String CMD_STATS   = \"stats\";\n        static final String CMD_DUMPSYS = \"-a\"; // dumpsys.cpp dumps services with \"-a\" as arguments\n        static final String CMD_DEFAULT = CMD_STATS;\n        @Override\n        public int logEvent(ConnectivityMetricsEvent event) {\n            enforceConnectivityInternalPermission();\n            return append(event);\n        }\n        @Override\n        public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n            enforceDumpPermission();\n            if (DBG) Log.d(TAG, \"dumpsys \" + TextUtils.join(\" \", args));\n            final String cmd = (args.length > 0) ? args[0] : CMD_DEFAULT;\n            switch (cmd) {\n                case CMD_FLUSH:\n                    cmdFlush(fd, pw, args);\n                    return;\n                case CMD_DUMPSYS:\n                    // Fallthrough to CMD_LIST when dumpsys.cpp dumps services states (bug reports)\n                case CMD_LIST:\n                    cmdList(fd, pw, args);\n                    return;\n                case CMD_STATS:\n                    cmdStats(fd, pw, args);\n                    return;\n                default:\n                    cmdDefault(fd, pw, args);\n            }\n        }\n        private void enforceConnectivityInternalPermission() {\n            enforcePermission(android.Manifest.permission.CONNECTIVITY_INTERNAL);\n        }\n        private void enforceDumpPermission() {\n            enforcePermission(android.Manifest.permission.DUMP);\n        }\n        private void enforcePermission(String what) {\n            getContext().enforceCallingOrSelfPermission(what, \"IpConnectivityMetrics\");\n        }\n        private void enforceNetdEventListeningPermission() {\n            final int uid = Binder.getCallingUid();\n            if (uid != Process.SYSTEM_UID) {\n                throw new SecurityException(String.format(\"Uid %d has no permission to listen for\"\n                        + \" netd events.\", uid));\n            }\n        }\n        @Override\n        public boolean registerNetdEventCallback(INetdEventCallback callback) {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                return false;\n            }\n            return mNetdListener.registerNetdEventCallback(callback);\n        }\n        @Override\n        public boolean unregisterNetdEventCallback() {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                // if the service is null, we aren't registered anyway\n                return true;\n            }\n            return mNetdListener.unregisterNetdEventCallback();\n        }\n    };\n    private static final ToIntFunction<Context> READ_BUFFER_SIZE = (ctx) -> {\n        int size = Settings.Global.getInt(ctx.getContentResolver(),\n                Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);\n        if (size <= 0) {\n            return DEFAULT_BUFFER_SIZE;\n        }\n        return Math.min(size, MAXIMUM_BUFFER_SIZE);\n    };\n    private static ArrayMap<Class<?>, TokenBucket> makeRateLimitingBuckets() {\n        ArrayMap<Class<?>, TokenBucket> map = new ArrayMap<>();\n        // one token every minute, 50 tokens max: burst of ~50 events every hour.\n        map.put(ApfProgramEvent.class, new TokenBucket((int)DateUtils.MINUTE_IN_MILLIS, 50));\n        return map;\n    }\n"]]}
{"hexsha": "dc2fb05fdd592711ca42fc698fb75e38374df934", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2020-05-04T14:59:31.604+02:00\")\npublic class FeatureDistribution {\n  @SerializedName(\"min\")\n  private BigDecimal min = null;\n\n  @SerializedName(\"max\")\n  private BigDecimal max = null;\n\n  @SerializedName(\"mean\")\n  private BigDecimal mean = null;\n\n  @SerializedName(\"stdDev\")\n  private BigDecimal stdDev = null;\n\n  public FeatureDistribution min(BigDecimal min) {\n    this.min = min;\n    return this;\n  }\n\n   /**\n   * Get min\n   * @return min\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getMin() {\n    return min;\n  }\n\n  public void setMin(BigDecimal min) {\n    this.min = min;\n  }\n\n  public FeatureDistribution max(BigDecimal max) {\n    this.max = max;\n    return this;\n  }\n\n   /**\n   * Get max\n   * @return max\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getMax() {\n    return max;\n  }\n\n  public void setMax(BigDecimal max) {\n    this.max = max;\n  }\n\n  public FeatureDistribution mean(BigDecimal mean) {\n    this.mean = mean;\n    return this;\n  }\n\n   /**\n   * Get mean\n   * @return mean\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getMean() {\n    return mean;\n  }\n\n  public void setMean(BigDecimal mean) {\n    this.mean = mean;\n  }\n\n  public FeatureDistribution stdDev(BigDecimal stdDev) {\n    this.stdDev = stdDev;\n    return this;\n  }\n\n   /**\n   * Get stdDev\n   * @return stdDev\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getStdDev() {\n    return stdDev;\n  }\n\n  public void setStdDev(BigDecimal stdDev) {\n    this.stdDev = stdDev;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    FeatureDistribution featureDistribution = (FeatureDistribution) o;\n    return Objects.equals(this.min, featureDistribution.min) &&\n        Objects.equals(this.max, featureDistribution.max) &&\n        Objects.equals(this.mean, featureDistribution.mean) &&\n        Objects.equals(this.stdDev, featureDistribution.stdDev);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(min, max, mean, stdDev);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class FeatureDistribution {\\n\");\n    \n    sb.append(\"    min: \").append(toIndentedString(min)).append(\"\\n\");\n    sb.append(\"    max: \").append(toIndentedString(max)).append(\"\\n\");\n    sb.append(\"    mean: \").append(toIndentedString(mean)).append(\"\\n\");\n    sb.append(\"    stdDev: \").append(toIndentedString(stdDev)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}", "class_id": 0, "repo": "ruivieira/trusty-ai-sandbox", "file": "explainability/service/xai-poc-v2/m2x-api/target/generated-sources/swagger/src/main/java/org/kie/trusty/xai/model/FeatureDistribution.java", "last_update_at": "2021-11-16T21:55:36+00:00", "question_id": "dc2fb05fdd592711ca42fc698fb75e38374df934", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2020-05-04T14:59:31.604+02:00\")\npublic class FeatureDistribution {\n  @SerializedName(\"min\")\n  private BigDecimal min = null;\n  @SerializedName(\"max\")\n  private BigDecimal max = null;\n  @SerializedName(\"mean\")\n  private BigDecimal mean = null;\n  @SerializedName(\"stdDev\")\n  private BigDecimal stdDev = null;\n  public FeatureDistribution min(BigDecimal min) {\n    this.min = min;\n    return this;\n  }\n   /**\n   * Get min\n   * @return min\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getMin() {\n    return min;\n  }\n  public void setMin(BigDecimal min) {\n    this.min = min;\n  }\n  public FeatureDistribution max(BigDecimal max) {\n    this.max = max;\n    return this;\n  }\n   /**\n   * Get max\n   * @return max\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getMax() {\n    return max;\n  }\n  public void setMax(BigDecimal max) {\n    this.max = max;\n  }\n  public FeatureDistribution mean(BigDecimal mean) {\n    this.mean = mean;\n    return this;\n  }\n   /**\n   * Get mean\n   * @return mean\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getMean() {\n    return mean;\n  }\n  public void setMean(BigDecimal mean) {\n    this.mean = mean;\n  }\n  public FeatureDistribution stdDev(BigDecimal stdDev) {\n    this.stdDev = stdDev;\n    return this;\n  }\n   /**\n   * Get stdDev\n   * @return stdDev\n  **/\n  @ApiModelProperty(value = \"\")\n  public BigDecimal getStdDev() {\n    return stdDev;\n  }\n  public void setStdDev(BigDecimal stdDev) {\n    this.stdDev = stdDev;\n  }\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    FeatureDistribution featureDistribution = (FeatureDistribution) o;\n    return Objects.equals(this.min, featureDistribution.min) &&\n        Objects.equals(this.max, featureDistribution.max) &&\n        Objects.equals(this.mean, featureDistribution.mean) &&\n        Objects.equals(this.stdDev, featureDistribution.stdDev);\n  }\n  @Override\n  public int hashCode() {\n    return Objects.hash(min, max, mean, stdDev);\n  }\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class FeatureDistribution {\\n\");\n    sb.append(\"    min: \").append(toIndentedString(min)).append(\"\\n\");\n    sb.append(\"    max: \").append(toIndentedString(max)).append(\"\\n\");\n    sb.append(\"    mean: \").append(toIndentedString(mean)).append(\"\\n\");\n    sb.append(\"    stdDev: \").append(toIndentedString(stdDev)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n"]]}
{"hexsha": "3b1f1163c4fbe704f26bdef5c95140affece7ef5", "ext": "java", "lang": "Java", "content": "public class Annuity<P extends Payment> implements InstrumentDerivative {\n\n  /**\n   * The list of the annuity payments.\n   */\n  private final P[] _payments;\n  /**\n   * Flag indicating if the annuity is payer (true) or receiver (false). Deduced from the first non-zero amount;\n   * if all amounts don't have the same sign, the flag may be incorrect.\n   */\n  private final boolean _isPayer;\n\n  /**\n   * @param payments The payments, not null or empty\n   */\n  public Annuity(final P[] payments) {\n    ArgumentChecker.noNulls(payments, \"payments\");\n    ArgumentChecker.isTrue(payments.length > 0, \"Have no payments in annuity\");\n    final Currency currency0 = payments[0].getCurrency();\n    double amount = payments[0].getReferenceAmount();\n    for (int loopcpn = 1; loopcpn < payments.length; loopcpn++) {\n      ArgumentChecker.isTrue(currency0.equals(payments[loopcpn].getCurrency()), \"currency not the same for all payments\");\n      amount = (amount == 0) ? payments[loopcpn].getReferenceAmount() : amount;\n    }\n    _payments = payments;\n    _isPayer = (amount < 0);\n  }\n\n  /**\n   * @param payments The payments, not null or empty\n   * @param pType The type of the payments, not null\n   * @param isPayer True if the annuity is to be paid\n   */\n  public Annuity(final List<? extends P> payments, final Class<P> pType, final boolean isPayer) {\n    ArgumentChecker.noNulls(payments, \"payments\");\n    ArgumentChecker.notNull(pType, \"type\");\n    ArgumentChecker.isTrue(payments.size() > 0, \"Payments size must be greater than zero\");\n    _payments = payments.toArray((P[]) Array.newInstance(pType, 0));\n    _isPayer = isPayer;\n  }\n\n  /**\n   * Gets the number of payments in the annuity.\n   * @return The number of payments\n   */\n  public int getNumberOfPayments() {\n    return _payments.length;\n  }\n\n  /**\n   * Gets the nth payment in an annuity. <b>Note that n = 0 will give the first payment</b>.\n   * @param n The number of the payment\n   * @return The nth payment\n   */\n  public P getNthPayment(final int n) {\n    return _payments[n];\n  }\n\n  /**\n   * Return the currency of the annuity.\n   * @return The currency.\n   */\n  public Currency getCurrency() {\n    return _payments[0].getCurrency();\n  }\n\n  /**\n   * Check if the payments of an annuity is of the type CouponFixed or CouponIbor. Used to check that payment are of vanilla type.\n   * @return  True if IborCoupon or FixedCoupon\n   */\n  public boolean isIborOrFixed() { //TODO: is this method necessary?\n    boolean result = true;\n    for (final P payment : _payments) {\n      result = result && payment.isIborOrFixed();\n    }\n    return result;\n  }\n\n  /**\n   * Gets the payments array.\n   * @return the payments\n   */\n  public P[] getPayments() {\n    return _payments;\n  }\n\n  /**\n   * Gets the payer flag: payer (true) or receiver (false)\n   * @return The payer flag.\n   * @deprecated The payer flag is no longer used; the sign of the notional\n   * determines whether a leg is paid or received\n   */\n  @Deprecated\n  public boolean isPayer() {\n    return _isPayer;\n  }\n\n  /**\n   * Return the discounting (or funding) curve name. Deduced from the first payment.\n   * @return The name.\n   * @deprecated Curve names should not be set in {@link InstrumentDerivative}s\n   */\n  @Deprecated\n  public String getDiscountCurve() {\n    return getNthPayment(0).getFundingCurveName();\n  }\n\n  /**\n   * Create a new annuity with the payments of the original one paying strictly after the given time.\n   * @param trimTime The time.\n   * @return The trimmed annuity.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public Annuity<P> trimBefore(final double trimTime) {\n    final List<P> list = new ArrayList<>();\n    list.clear();\n    for (final P payment : _payments) {\n      if (payment.getPaymentTime() > trimTime) {\n        list.add(payment);\n      }\n    }\n    return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n  }\n\n  /**\n   * Create a new annuity with the payments of the original one paying before or on the given time.\n   * @param trimTime The time.\n   * @return The trimmed annuity.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public Annuity<P> trimAfter(final double trimTime) {\n    final List<P> list = new ArrayList<>();\n    for (final P payment : _payments) {\n      if (payment.getPaymentTime() <= trimTime) {\n        list.add(payment);\n      }\n    }\n    return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n  }\n\n  @Override\n  public String toString() {\n    final StringBuffer result = new StringBuffer(\"Annuity:\");\n    for (final P payment : _payments) {\n      result.append(payment.toString());\n      result.append(\"\\n\");\n    }\n    return result.toString();\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + Arrays.hashCode(_payments);\n    return result;\n  }\n\n  @Override\n  public boolean equals(final Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass() != obj.getClass()) {\n      return false;\n    }\n    final Annuity<?> other = (Annuity<?>) obj;\n    if (_payments.length != other._payments.length) {\n      return false;\n    }\n    for (int i = 0; i < _payments.length; i++) {\n      if (!ObjectUtils.equals(_payments[i], other._payments[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {\n    ArgumentChecker.notNull(visitor, \"visitor\");\n    return visitor.visitGenericAnnuity(this, data);\n  }\n\n  @Override\n  public <T> T accept(final InstrumentDerivativeVisitor<?, T> visitor) {\n    ArgumentChecker.notNull(visitor, \"visitor\");\n    return visitor.visitGenericAnnuity(this);\n  }\n\n}", "class_id": 0, "repo": "UbuntuEvangelist/OG-Platform", "file": "projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/annuity/derivative/Annuity.java", "last_update_at": "2021-10-03T01:21:20+00:00", "question_id": "3b1f1163c4fbe704f26bdef5c95140affece7ef5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Annuity<P extends Payment> implements InstrumentDerivative {\n  /**\n   * The list of the annuity payments.\n   */\n  private final P[] _payments;\n  /**\n   * Flag indicating if the annuity is payer (true) or receiver (false). Deduced from the first non-zero amount;\n   * if all amounts don't have the same sign, the flag may be incorrect.\n   */\n  private final boolean _isPayer;\n  /**\n   * @param payments The payments, not null or empty\n   */\n  public Annuity(final P[] payments) {\n    ArgumentChecker.noNulls(payments, \"payments\");\n    ArgumentChecker.isTrue(payments.length > 0, \"Have no payments in annuity\");\n    final Currency currency0 = payments[0].getCurrency();\n    double amount = payments[0].getReferenceAmount();\n    for (int loopcpn = 1; loopcpn < payments.length; loopcpn++) {\n      ArgumentChecker.isTrue(currency0.equals(payments[loopcpn].getCurrency()), \"currency not the same for all payments\");\n      amount = (amount == 0) ? payments[loopcpn].getReferenceAmount() : amount;\n    }\n    _payments = payments;\n    _isPayer = (amount < 0);\n  }\n  /**\n   * @param payments The payments, not null or empty\n   * @param pType The type of the payments, not null\n   * @param isPayer True if the annuity is to be paid\n   */\n  public Annuity(final List<? extends P> payments, final Class<P> pType, final boolean isPayer) {\n    ArgumentChecker.noNulls(payments, \"payments\");\n    ArgumentChecker.notNull(pType, \"type\");\n    ArgumentChecker.isTrue(payments.size() > 0, \"Payments size must be greater than zero\");\n    _payments = payments.toArray((P[]) Array.newInstance(pType, 0));\n    _isPayer = isPayer;\n  }\n  /**\n   * Gets the number of payments in the annuity.\n   * @return The number of payments\n   */\n  public int getNumberOfPayments() {\n    return _payments.length;\n  }\n  /**\n   * Gets the nth payment in an annuity. <b>Note that n = 0 will give the first payment</b>.\n   * @param n The number of the payment\n   * @return The nth payment\n   */\n  public P getNthPayment(final int n) {\n    return _payments[n];\n  }\n  /**\n   * Return the currency of the annuity.\n   * @return The currency.\n   */\n  public Currency getCurrency() {\n    return _payments[0].getCurrency();\n  }\n  /**\n   * Check if the payments of an annuity is of the type CouponFixed or CouponIbor. Used to check that payment are of vanilla type.\n   * @return  True if IborCoupon or FixedCoupon\n   */\n  public boolean isIborOrFixed() { //TODO: is this method necessary?\n    boolean result = true;\n    for (final P payment : _payments) {\n      result = result && payment.isIborOrFixed();\n    }\n    return result;\n  }\n  /**\n   * Gets the payments array.\n   * @return the payments\n   */\n  public P[] getPayments() {\n    return _payments;\n  }\n  /**\n   * Gets the payer flag: payer (true) or receiver (false)\n   * @return The payer flag.\n   * @deprecated The payer flag is no longer used; the sign of the notional\n   * determines whether a leg is paid or received\n   */\n  @Deprecated\n  public boolean isPayer() {\n    return _isPayer;\n  }\n  /**\n   * Return the discounting (or funding) curve name. Deduced from the first payment.\n   * @return The name.\n   * @deprecated Curve names should not be set in {@link InstrumentDerivative}s\n   */\n  @Deprecated\n  public String getDiscountCurve() {\n    return getNthPayment(0).getFundingCurveName();\n  }\n  /**\n   * Create a new annuity with the payments of the original one paying strictly after the given time.\n   * @param trimTime The time.\n   * @return The trimmed annuity.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public Annuity<P> trimBefore(final double trimTime) {\n    final List<P> list = new ArrayList<>();\n    list.clear();\n    for (final P payment : _payments) {\n      if (payment.getPaymentTime() > trimTime) {\n        list.add(payment);\n      }\n    }\n    return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n  }\n  /**\n   * Create a new annuity with the payments of the original one paying before or on the given time.\n   * @param trimTime The time.\n   * @return The trimmed annuity.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public Annuity<P> trimAfter(final double trimTime) {\n    final List<P> list = new ArrayList<>();\n    for (final P payment : _payments) {\n      if (payment.getPaymentTime() <= trimTime) {\n        list.add(payment);\n      }\n    }\n    return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n  }\n  @Override\n  public String toString() {\n    final StringBuffer result = new StringBuffer(\"Annuity:\");\n    for (final P payment : _payments) {\n      result.append(payment.toString());\n      result.append(\"\\n\");\n    }\n    return result.toString();\n  }\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + Arrays.hashCode(_payments);\n    return result;\n  }\n  @Override\n  public boolean equals(final Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass() != obj.getClass()) {\n      return false;\n    }\n    final Annuity<?> other = (Annuity<?>) obj;\n    if (_payments.length != other._payments.length) {\n      return false;\n    }\n    for (int i = 0; i < _payments.length; i++) {\n      if (!ObjectUtils.equals(_payments[i], other._payments[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  @Override\n  public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {\n    ArgumentChecker.notNull(visitor, \"visitor\");\n    return visitor.visitGenericAnnuity(this, data);\n  }\n  @Override\n  public <T> T accept(final InstrumentDerivativeVisitor<?, T> visitor) {\n    ArgumentChecker.notNull(visitor, \"visitor\");\n    return visitor.visitGenericAnnuity(this);\n  }\n"]]}
{"hexsha": "8c59e2cfdbf6b17cb077cdd8149140816c81fd79", "ext": "java", "lang": "Java", "content": "public class CustomerBoardComponent extends Composite implements HasLogger {\n\n  public static final String FILTER_TF_ID          = textfieldID().apply(CustomerBoardComponent.class, \"filterTF\");\n  public static final String FILTER_TF_PLACEHOLDER = FILTER_TF_ID + \".\" + \"placeholder\";\n\n  public static final String CLEAR_FILTER_BTN_ID          = buttonID().apply(CustomerBoardComponent.class, \"clearFilterBTN\");\n  public static final String CLEAR_FILTER_BTN_DESCRIPTION = CLEAR_FILTER_BTN_ID + \".\" + \"description\";\n\n  public static final String NEW_CUSTOMER_BTN_ID      = buttonID().apply(CustomerBoardComponent.class, \"newCustomerBTN\");\n  public static final String NEW_CUSTOMER_BTN_CAPTION = NEW_CUSTOMER_BTN_ID + \".\" + \"caption\";\n\n  public static final String DATA_GRID_ID                     = gridID().apply(CustomerBoardComponent.class, \"dataGrid\");\n  public static final String DATA_GRID_COL                    = DATA_GRID_ID + \".\" + \"col\";\n  public static final String DATA_GRID_COL_CAPTION_FIRST_NAME = DATA_GRID_COL + \".\" + \"firstName\";\n  public static final String DATA_GRID_COL_CAPTION_LAST_NAME  = DATA_GRID_COL + \".\" + \"lastName\";\n  public static final String DATA_GRID_COL_CAPTION_EMAIL      = DATA_GRID_COL + \".\" + \"email\";\n\n  public static final String CUSTOMERFORM_ID = genericID().apply(CustomerForm.class,\n                                                                 CustomerBoardComponent.class,\n                                                                 \"customerForm\");\n\n  @Inject private CustomerService service;\n  @Inject private PropertyService propertyService;\n  @Inject private CustomerForm    customerForm;\n\n  private final Grid<Customer> grid               = new Grid<>();\n  private final TextField      filterText         = new TextField();\n  private final Button         clearFilterTextBtn = new Button();\n  private final Button         addCustomerBtn     = new Button();\n\n  private Registration deleteRegistration;\n  private Registration saveRegistration;\n\n  private String resolve(String key) {\n    return propertyService.resolve(key);\n  }\n\n  @PostConstruct\n  private void postConstruct() {\n\n    filterText.setId(FILTER_TF_ID);\n    filterText.setPlaceholder(resolve(FILTER_TF_PLACEHOLDER));\n    filterText.addValueChangeListener(e -> updateGridItems());\n    filterText.setValueChangeMode(ValueChangeMode.LAZY);\n\n    clearFilterTextBtn.setId(CLEAR_FILTER_BTN_ID);\n    clearFilterTextBtn.setIcon(VaadinIcons.CLOSE_BIG);\n    clearFilterTextBtn.setDescription(resolve(CLEAR_FILTER_BTN_DESCRIPTION));\n    clearFilterTextBtn.addClickListener(e -> filterText.clear());\n\n    addCustomerBtn.setId(NEW_CUSTOMER_BTN_ID);\n    addCustomerBtn.setCaptionAsHtml(true);\n    addCustomerBtn.setCaption(VaadinIcons.USER.getHtml());\n    addCustomerBtn.setDescription(resolve(NEW_CUSTOMER_BTN_CAPTION));\n    addCustomerBtn.setIconAlternateText(resolve(NEW_CUSTOMER_BTN_CAPTION));\n    addCustomerBtn.addClickListener(e -> {\n      grid.asSingleSelect().clear();\n      customerForm.setCustomer(new Customer());\n    });\n\n    final Layout filtering = new CssLayout(filterText, clearFilterTextBtn);\n    filtering.setStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);\n    ((CssLayout) filtering).setResponsive(true);\n    final Layout buttons = new HorizontalLayout(filtering, addCustomerBtn);\n    buttons.setHeight(40, Sizeable.Unit.PIXELS);\n    ((HorizontalLayout) buttons).setResponsive(true);\n\n    grid.setId(DATA_GRID_ID);\n    grid.addColumn(Customer::getFirstName)\n        .setCaption(resolve(DATA_GRID_COL_CAPTION_FIRST_NAME))\n        .setId(DATA_GRID_COL_CAPTION_FIRST_NAME);\n    grid.addColumn(Customer::getLastName)\n        .setCaption(resolve(DATA_GRID_COL_CAPTION_LAST_NAME))\n        .setId(DATA_GRID_COL_CAPTION_LAST_NAME);\n    grid.addColumn(Customer::getEmail)\n        .setCaption(resolve(DATA_GRID_COL_CAPTION_EMAIL))\n        .setId(DATA_GRID_COL_CAPTION_EMAIL);\n\n    grid.setColumnOrder(\n        DATA_GRID_COL_CAPTION_FIRST_NAME,\n        DATA_GRID_COL_CAPTION_LAST_NAME,\n        DATA_GRID_COL_CAPTION_EMAIL\n    );\n\n    grid.asSingleSelect().addValueChangeListener(event -> {\n      if (event.getValue() == null) {\n        customerForm.setVisible(false);\n      } else {\n        customerForm.setCustomer(event.getValue());\n      }\n    });\n    grid.setSizeFull();\n    updateGridItems();\n\n    customerForm.setId(CUSTOMERFORM_ID);\n    customerForm.setVisible(false);\n\n    final HorizontalLayout main = new HorizontalLayout(grid, customerForm);\n    main.setSizeFull();\n    main.setExpandRatio(grid, 1);\n\n    final VerticalLayout compositionRoot = new VerticalLayout(buttons, main);\n    compositionRoot.setExpandRatio(main, 1);\n    compositionRoot.setSizeFull();\n    setCompositionRoot(compositionRoot);\n\n    deleteRegistration = customerForm.registerDeleteListener(customer -> {\n      service.delete(customer);\n      updateGridItems();\n    });\n    saveRegistration = customerForm.registerSaveListener(customer -> {\n      service.save(customer);\n      updateGridItems();\n    });\n  }\n\n  @Override\n  public void detach() {\n    super.detach();\n    ((CheckedExecutor) () -> deleteRegistration.remove()).execute();\n    ((CheckedExecutor) () -> saveRegistration.remove()).execute();\n  }\n\n  private void updateGridItems() {\n    grid.setItems(service.findAll(filterText.getValue()));\n  }\n}", "class_id": 0, "repo": "Java-Archive/vaadin-dev-environment-demo-vaadin-testbench", "file": "src/main/java/org/rapidpm/vaadin/ui/components/CustomerBoardComponent.java", "last_update_at": "2021-04-24T13:48:31+00:00", "question_id": "8c59e2cfdbf6b17cb077cdd8149140816c81fd79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustomerBoardComponent extends Composite implements HasLogger {\n  public static final String FILTER_TF_ID          = textfieldID().apply(CustomerBoardComponent.class, \"filterTF\");\n  public static final String FILTER_TF_PLACEHOLDER = FILTER_TF_ID + \".\" + \"placeholder\";\n  public static final String CLEAR_FILTER_BTN_ID          = buttonID().apply(CustomerBoardComponent.class, \"clearFilterBTN\");\n  public static final String CLEAR_FILTER_BTN_DESCRIPTION = CLEAR_FILTER_BTN_ID + \".\" + \"description\";\n  public static final String NEW_CUSTOMER_BTN_ID      = buttonID().apply(CustomerBoardComponent.class, \"newCustomerBTN\");\n  public static final String NEW_CUSTOMER_BTN_CAPTION = NEW_CUSTOMER_BTN_ID + \".\" + \"caption\";\n  public static final String DATA_GRID_ID                     = gridID().apply(CustomerBoardComponent.class, \"dataGrid\");\n  public static final String DATA_GRID_COL                    = DATA_GRID_ID + \".\" + \"col\";\n  public static final String DATA_GRID_COL_CAPTION_FIRST_NAME = DATA_GRID_COL + \".\" + \"firstName\";\n  public static final String DATA_GRID_COL_CAPTION_LAST_NAME  = DATA_GRID_COL + \".\" + \"lastName\";\n  public static final String DATA_GRID_COL_CAPTION_EMAIL      = DATA_GRID_COL + \".\" + \"email\";\n  public static final String CUSTOMERFORM_ID = genericID().apply(CustomerForm.class,\n                                                                 CustomerBoardComponent.class,\n                                                                 \"customerForm\");\n  @Inject private CustomerService service;\n  @Inject private PropertyService propertyService;\n  @Inject private CustomerForm    customerForm;\n  private final Grid<Customer> grid               = new Grid<>();\n  private final TextField      filterText         = new TextField();\n  private final Button         clearFilterTextBtn = new Button();\n  private final Button         addCustomerBtn     = new Button();\n  private Registration deleteRegistration;\n  private Registration saveRegistration;\n  private String resolve(String key) {\n    return propertyService.resolve(key);\n  }\n  @PostConstruct\n  private void postConstruct() {\n    filterText.setId(FILTER_TF_ID);\n    filterText.setPlaceholder(resolve(FILTER_TF_PLACEHOLDER));\n    filterText.addValueChangeListener(e -> updateGridItems());\n    filterText.setValueChangeMode(ValueChangeMode.LAZY);\n    clearFilterTextBtn.setId(CLEAR_FILTER_BTN_ID);\n    clearFilterTextBtn.setIcon(VaadinIcons.CLOSE_BIG);\n    clearFilterTextBtn.setDescription(resolve(CLEAR_FILTER_BTN_DESCRIPTION));\n    clearFilterTextBtn.addClickListener(e -> filterText.clear());\n    addCustomerBtn.setId(NEW_CUSTOMER_BTN_ID);\n    addCustomerBtn.setCaptionAsHtml(true);\n    addCustomerBtn.setCaption(VaadinIcons.USER.getHtml());\n    addCustomerBtn.setDescription(resolve(NEW_CUSTOMER_BTN_CAPTION));\n    addCustomerBtn.setIconAlternateText(resolve(NEW_CUSTOMER_BTN_CAPTION));\n    addCustomerBtn.addClickListener(e -> {\n      grid.asSingleSelect().clear();\n      customerForm.setCustomer(new Customer());\n    });\n    final Layout filtering = new CssLayout(filterText, clearFilterTextBtn);\n    filtering.setStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);\n    ((CssLayout) filtering).setResponsive(true);\n    final Layout buttons = new HorizontalLayout(filtering, addCustomerBtn);\n    buttons.setHeight(40, Sizeable.Unit.PIXELS);\n    ((HorizontalLayout) buttons).setResponsive(true);\n    grid.setId(DATA_GRID_ID);\n    grid.addColumn(Customer::getFirstName)\n        .setCaption(resolve(DATA_GRID_COL_CAPTION_FIRST_NAME))\n        .setId(DATA_GRID_COL_CAPTION_FIRST_NAME);\n    grid.addColumn(Customer::getLastName)\n        .setCaption(resolve(DATA_GRID_COL_CAPTION_LAST_NAME))\n        .setId(DATA_GRID_COL_CAPTION_LAST_NAME);\n    grid.addColumn(Customer::getEmail)\n        .setCaption(resolve(DATA_GRID_COL_CAPTION_EMAIL))\n        .setId(DATA_GRID_COL_CAPTION_EMAIL);\n    grid.setColumnOrder(\n        DATA_GRID_COL_CAPTION_FIRST_NAME,\n        DATA_GRID_COL_CAPTION_LAST_NAME,\n        DATA_GRID_COL_CAPTION_EMAIL\n    );\n    grid.asSingleSelect().addValueChangeListener(event -> {\n      if (event.getValue() == null) {\n        customerForm.setVisible(false);\n      } else {\n        customerForm.setCustomer(event.getValue());\n      }\n    });\n    grid.setSizeFull();\n    updateGridItems();\n    customerForm.setId(CUSTOMERFORM_ID);\n    customerForm.setVisible(false);\n    final HorizontalLayout main = new HorizontalLayout(grid, customerForm);\n    main.setSizeFull();\n    main.setExpandRatio(grid, 1);\n    final VerticalLayout compositionRoot = new VerticalLayout(buttons, main);\n    compositionRoot.setExpandRatio(main, 1);\n    compositionRoot.setSizeFull();\n    setCompositionRoot(compositionRoot);\n    deleteRegistration = customerForm.registerDeleteListener(customer -> {\n      service.delete(customer);\n      updateGridItems();\n    });\n    saveRegistration = customerForm.registerSaveListener(customer -> {\n      service.save(customer);\n      updateGridItems();\n    });\n  }\n  @Override\n  public void detach() {\n    super.detach();\n    ((CheckedExecutor) () -> deleteRegistration.remove()).execute();\n    ((CheckedExecutor) () -> saveRegistration.remove()).execute();\n  }\n  private void updateGridItems() {\n    grid.setItems(service.findAll(filterText.getValue()));\n  }\n"]]}
{"hexsha": "6084f6710f0ac05ebcbffeae131e30719904a1ee", "ext": "java", "lang": "Java", "content": "public class ResourceCompiler {\n  private static final Logger logger = Logger.getLogger(ResourceCompiler.class.getName());\n\n  private final CompilingVisitor compilingVisitor;\n\n  private static class CompileTask implements Callable<Path> {\n\n    private final Path file;\n    private final Path compiledResourcesOut;\n    private final Path aapt2;\n    private final Revision buildToolsVersion;\n\n    public CompileTask(\n        Path file, Path compiledResourcesOut, Path aapt2, Revision buildToolsVersion) {\n      this.file = file;\n      this.compiledResourcesOut = compiledResourcesOut;\n      this.aapt2 = aapt2;\n      this.buildToolsVersion = buildToolsVersion;\n    }\n\n    @Override\n    public Path call() throws Exception {\n        logger.fine(\n            new AaptCommandBuilder(aapt2)\n                .forBuildToolsVersion(buildToolsVersion)\n                .forVariantType(VariantType.LIBRARY)\n                .add(\"compile\")\n                .add(\"-v\")\n                .add(\"--legacy\")\n                .add(\"-o\", compiledResourcesOut.toString())\n                .add(file.toString())\n                .execute(\"Compiling \" + file));\n\n\n      String type = file.getParent().getFileName().toString();\n      String filename = file.getFileName().toString();\n      if (type.startsWith(\"values\")) {\n        filename =\n            (filename.indexOf('.') != -1 ? filename.substring(0, filename.indexOf('.')) : filename)\n                + \".arsc\";\n      }\n\n      final Path compiledResourcePath =\n          compiledResourcesOut.resolve(type + \"_\" + filename + \".flat\");\n      Preconditions.checkArgument(\n          Files.exists(compiledResourcePath),\n          \"%s does not exists after aapt2 ran.\",\n          compiledResourcePath);\n      return compiledResourcePath;\n    }\n\n    @Override\n    public String toString() {\n      return \"ResourceCompiler.CompileTask(\" + file + \")\";\n    }\n  }\n\n  private static class CompilingVisitor extends SimpleFileVisitor<Path> {\n\n    private final ListeningExecutorService executorService;\n    private final Path compiledResources;\n    private final List<ListenableFuture<Path>> tasks = new ArrayList<>();\n    private final Path aapt2;\n    private final Revision buildToolsVersion;\n\n    public CompilingVisitor(\n        ListeningExecutorService executorService,\n        Path compiledResources,\n        Path aapt2,\n        Revision buildToolsVersion) {\n      this.executorService = executorService;\n      this.compiledResources = compiledResources;\n      this.aapt2 = aapt2;\n      this.buildToolsVersion = buildToolsVersion;\n    }\n\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n      // Ignore directories and \"hidden\" files that start with .\n      if (!Files.isDirectory(file) && !file.getFileName().toString().startsWith(\".\")) {\n        tasks.add(\n            executorService.submit(\n                new CompileTask(\n                    file,\n                    // Creates a relative output path based on the input path under the\n                    // compiledResources path.\n                    Files.createDirectories(\n                        compiledResources.resolve(\n                            (file.isAbsolute() ? file.getRoot().relativize(file) : file)\n                                .getParent()\n                                .getParent())),\n                    aapt2,\n                    buildToolsVersion)));\n      }\n      return super.visitFile(file, attrs);\n    }\n\n    List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n      return Futures.allAsList(tasks).get();\n    }\n  }\n\n  /** Creates a new {@link ResourceCompiler}. */\n  public static ResourceCompiler create(\n      ListeningExecutorService executorService,\n      Path compiledResources,\n      Path aapt2,\n      Revision buildToolsVersion) {\n    return new ResourceCompiler(\n        new CompilingVisitor(executorService, compiledResources, aapt2, buildToolsVersion));\n  }\n\n  private ResourceCompiler(CompilingVisitor compilingVisitor) {\n    this.compilingVisitor = compilingVisitor;\n  }\n\n  /** Adds a task to compile the directory using aapt2. */\n  public void queueDirectoryForCompilation(Path resource) throws IOException {\n    Files.walkFileTree(resource, compilingVisitor);\n  }\n\n  /** Returns all paths of the aapt2 compiled resources. */\n  public List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n    return compilingVisitor.getCompiledArtifacts();\n  }\n}", "class_id": 0, "repo": "ixuexi/bazel", "file": "src/tools/android/java/com/google/devtools/build/android/aapt2/ResourceCompiler.java", "last_update_at": "2021-03-03T07:32:13+00:00", "question_id": "6084f6710f0ac05ebcbffeae131e30719904a1ee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ResourceCompiler {\n  private static final Logger logger = Logger.getLogger(ResourceCompiler.class.getName());\n  private final CompilingVisitor compilingVisitor;\n  private static class CompileTask implements Callable<Path> {\n    private final Path file;\n    private final Path compiledResourcesOut;\n    private final Path aapt2;\n    private final Revision buildToolsVersion;\n    public CompileTask(\n        Path file, Path compiledResourcesOut, Path aapt2, Revision buildToolsVersion) {\n      this.file = file;\n      this.compiledResourcesOut = compiledResourcesOut;\n      this.aapt2 = aapt2;\n      this.buildToolsVersion = buildToolsVersion;\n    }\n    @Override\n    public Path call() throws Exception {\n        logger.fine(\n            new AaptCommandBuilder(aapt2)\n                .forBuildToolsVersion(buildToolsVersion)\n                .forVariantType(VariantType.LIBRARY)\n                .add(\"compile\")\n                .add(\"-v\")\n                .add(\"--legacy\")\n                .add(\"-o\", compiledResourcesOut.toString())\n                .add(file.toString())\n                .execute(\"Compiling \" + file));\n      String type = file.getParent().getFileName().toString();\n      String filename = file.getFileName().toString();\n      if (type.startsWith(\"values\")) {\n        filename =\n            (filename.indexOf('.') != -1 ? filename.substring(0, filename.indexOf('.')) : filename)\n                + \".arsc\";\n      }\n      final Path compiledResourcePath =\n          compiledResourcesOut.resolve(type + \"_\" + filename + \".flat\");\n      Preconditions.checkArgument(\n          Files.exists(compiledResourcePath),\n          \"%s does not exists after aapt2 ran.\",\n          compiledResourcePath);\n      return compiledResourcePath;\n    }\n    @Override\n    public String toString() {\n      return \"ResourceCompiler.CompileTask(\" + file + \")\";\n    }\n  }\n  private static class CompilingVisitor extends SimpleFileVisitor<Path> {\n    private final ListeningExecutorService executorService;\n    private final Path compiledResources;\n    private final List<ListenableFuture<Path>> tasks = new ArrayList<>();\n    private final Path aapt2;\n    private final Revision buildToolsVersion;\n    public CompilingVisitor(\n        ListeningExecutorService executorService,\n        Path compiledResources,\n        Path aapt2,\n        Revision buildToolsVersion) {\n      this.executorService = executorService;\n      this.compiledResources = compiledResources;\n      this.aapt2 = aapt2;\n      this.buildToolsVersion = buildToolsVersion;\n    }\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n      // Ignore directories and \"hidden\" files that start with .\n      if (!Files.isDirectory(file) && !file.getFileName().toString().startsWith(\".\")) {\n        tasks.add(\n            executorService.submit(\n                new CompileTask(\n                    file,\n                    // Creates a relative output path based on the input path under the\n                    // compiledResources path.\n                    Files.createDirectories(\n                        compiledResources.resolve(\n                            (file.isAbsolute() ? file.getRoot().relativize(file) : file)\n                                .getParent()\n                                .getParent())),\n                    aapt2,\n                    buildToolsVersion)));\n      }\n      return super.visitFile(file, attrs);\n    }\n    List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n      return Futures.allAsList(tasks).get();\n    }\n  }\n  /** Creates a new {@link ResourceCompiler}. */\n  public static ResourceCompiler create(\n      ListeningExecutorService executorService,\n      Path compiledResources,\n      Path aapt2,\n      Revision buildToolsVersion) {\n    return new ResourceCompiler(\n        new CompilingVisitor(executorService, compiledResources, aapt2, buildToolsVersion));\n  }\n  private ResourceCompiler(CompilingVisitor compilingVisitor) {\n    this.compilingVisitor = compilingVisitor;\n  }\n  /** Adds a task to compile the directory using aapt2. */\n  public void queueDirectoryForCompilation(Path resource) throws IOException {\n    Files.walkFileTree(resource, compilingVisitor);\n  }\n  /** Returns all paths of the aapt2 compiled resources. */\n  public List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n    return compilingVisitor.getCompiledArtifacts();\n  }\n"]]}
{"hexsha": "a8ba7f5b0c8ef7e57b8db2d114463f4396c0eae6", "ext": "java", "lang": "Java", "content": "public class HomeControllerTest extends WithApplication {\n    private HomeController homeController;\n\n    @Before\n    public void provideHomeController() {\n        this.homeController = new HomeController(Mockito.mock(AssetsFinder.class));\n    }\n\n    @Test\n    public void testIndex() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.index(requestBuilder.build());\n\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testHighscore() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.highscore(requestBuilder.build());\n\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testProfile() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.profile(requestBuilder.build());\n\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testMenu() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.menu(requestBuilder.build());\n\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testPizzaRush() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.pizzaRush(requestBuilder.build());\n\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testMemory() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.memory(requestBuilder.build());\n\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n}", "class_id": 0, "repo": "Pixelhuber/Pizza_Ragazzi", "file": "test/ControllerTests/HomeControllerTest.java", "last_update_at": "2021-09-11T12:22:26+00:00", "question_id": "a8ba7f5b0c8ef7e57b8db2d114463f4396c0eae6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HomeControllerTest extends WithApplication {\n    private HomeController homeController;\n    @Before\n    public void provideHomeController() {\n        this.homeController = new HomeController(Mockito.mock(AssetsFinder.class));\n    }\n    @Test\n    public void testIndex() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.index(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n    @Test\n    public void testHighscore() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.highscore(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n    @Test\n    public void testProfile() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.profile(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n    @Test\n    public void testMenu() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.menu(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n    @Test\n    public void testPizzaRush() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.pizzaRush(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n    @Test\n    public void testMemory() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.memory(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n"]]}
{"hexsha": "9359f69e953ce02cd6b1b8e24ffc79b7e97c5c89", "ext": "java", "lang": "Java", "content": "public class Slag extends Item{\n\n\tprivate static final IDispenseItemBehavior SLAG_DISPENSER_BEHAVIOR = new OptionalDispenseBehavior(){\n\t\t@Override\n\t\tprotected ItemStack execute(IBlockSource source, ItemStack stack){\n\t\t\tWorld world = source.getLevel();\n\t\t\tBlockPos blockpos = source.getPos().relative(source.getBlockState().getValue(DispenserBlock.FACING));\n\n\t\t\t//We currently use the deprecated method because this is what vanilla dispensers currently use\n\t\t\tif(BoneMealItem.growCrop(stack, world, blockpos)){\n\t\t\t\tif(!world.isClientSide){\n\t\t\t\t\tworld.levelEvent(2005, blockpos, 0);\n\t\t\t\t}\n\n\t\t\t\tsetSuccess(true);//Success\n\t\t\t}else{\n\t\t\t\tsetSuccess(false);//Fail\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t};\n\n\tprotected Slag(){\n\t\tsuper(new Properties().tab(CRItems.TAB_CROSSROADS));\n\t\tString name = \"slag\";\n\t\tsetRegistryName(name);\n\t\tCRItems.toRegister.add(this);\n\t\tDispenserBlock.registerBehavior(this, SLAG_DISPENSER_BEHAVIOR);\n\t}\n\n\t@Override\n\tpublic ActionResultType useOn(ItemUseContext context){\n\t\tif(BoneMealItem.applyBonemeal(context.getItemInHand(), context.getLevel(), context.getClickedPos(), context.getPlayer())){\n\t\t\tif(!context.getLevel().isClientSide){\n\t\t\t\tcontext.getLevel().levelEvent(2005, context.getClickedPos(), 0);\n\t\t\t}\n\t\t\treturn ActionResultType.SUCCESS;\n\t\t}\n\t\treturn ActionResultType.FAIL;\n\t}\n}", "class_id": 0, "repo": "EminentMass/Crossroads", "file": "src/main/java/com/Da_Technomancer/crossroads/items/Slag.java", "last_update_at": "2021-09-21T03:04:45+00:00", "question_id": "9359f69e953ce02cd6b1b8e24ffc79b7e97c5c89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Slag extends Item{\n\tprivate static final IDispenseItemBehavior SLAG_DISPENSER_BEHAVIOR = new OptionalDispenseBehavior(){\n\t\t@Override\n\t\tprotected ItemStack execute(IBlockSource source, ItemStack stack){\n\t\t\tWorld world = source.getLevel();\n\t\t\tBlockPos blockpos = source.getPos().relative(source.getBlockState().getValue(DispenserBlock.FACING));\n\t\t\t//We currently use the deprecated method because this is what vanilla dispensers currently use\n\t\t\tif(BoneMealItem.growCrop(stack, world, blockpos)){\n\t\t\t\tif(!world.isClientSide){\n\t\t\t\t\tworld.levelEvent(2005, blockpos, 0);\n\t\t\t\t}\n\t\t\t\tsetSuccess(true);//Success\n\t\t\t}else{\n\t\t\t\tsetSuccess(false);//Fail\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t};\n\tprotected Slag(){\n\t\tsuper(new Properties().tab(CRItems.TAB_CROSSROADS));\n\t\tString name = \"slag\";\n\t\tsetRegistryName(name);\n\t\tCRItems.toRegister.add(this);\n\t\tDispenserBlock.registerBehavior(this, SLAG_DISPENSER_BEHAVIOR);\n\t}\n\t@Override\n\tpublic ActionResultType useOn(ItemUseContext context){\n\t\tif(BoneMealItem.applyBonemeal(context.getItemInHand(), context.getLevel(), context.getClickedPos(), context.getPlayer())){\n\t\t\tif(!context.getLevel().isClientSide){\n\t\t\t\tcontext.getLevel().levelEvent(2005, context.getClickedPos(), 0);\n\t\t\t}\n\t\t\treturn ActionResultType.SUCCESS;\n\t\t}\n\t\treturn ActionResultType.FAIL;\n\t}\n"]]}
{"hexsha": "df86a5988dc4ae6c04ca10898aecb3dc91b26047", "ext": "java", "lang": "Java", "content": "@Mixin(ContainerRepair.class)\npublic abstract class ContainerRepairMixin extends Container {\n\n    @Shadow\n    public int maximumCost;\n\n    @Shadow\n    @Final\n    private IInventory inputSlots;\n\n    @Shadow\n    @Final\n    private IInventory outputSlot;\n\n    @Shadow\n    public int materialCost;\n\n    @Shadow\n    private String repairedItemName;\n\n    @Shadow\n    @Final\n    private EntityPlayer player;\n\n    /**\n     * @author Enaium\n     */\n    @Overwrite\n    public void updateRepairOutput() {\n        ItemStack itemstack = this.inputSlots.getStackInSlot(0);\n        this.maximumCost = 1;\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        if (itemstack.isEmpty()) {\n            this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n            this.maximumCost = 0;\n        } else {\n            ItemStack itemstack1 = itemstack.copy();\n            ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);\n            Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);\n            j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());\n            this.materialCost = 0;\n            boolean flag = false;\n            int k2;\n            if (!itemstack2.isEmpty()) {\n                if (!onAnvilChange(itemstack, itemstack2, this.outputSlot, this.repairedItemName, j)) {\n                    return;\n                }\n\n                flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();\n                int i1;\n                int j1;\n                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {\n                    k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    if (k2 <= 0) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n\n                    for (i1 = 0; k2 > 0 && i1 < itemstack2.getCount(); ++i1) {\n                        j1 = itemstack1.getItemDamage() - k2;\n                        itemstack1.setItemDamage(j1);\n                        ++i;\n                        k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    }\n\n                    this.materialCost = i1;\n                } else {\n                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable())) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n\n                    if (itemstack1.isItemStackDamageable() && !flag) {\n                        k2 = itemstack.getMaxDamage() - itemstack.getItemDamage();\n                        i1 = itemstack2.getMaxDamage() - itemstack2.getItemDamage();\n                        j1 = i1 + itemstack1.getMaxDamage() * 12 / 100;\n                        int k1 = k2 + j1;\n                        int l1 = itemstack1.getMaxDamage() - k1;\n                        if (l1 < 0) {\n                            l1 = 0;\n                        }\n\n                        if (l1 < itemstack1.getItemDamage()) {\n                            itemstack1.setItemDamage(l1);\n                            i += 2;\n                        }\n                    }\n\n                    Map<Enchantment, Integer> map1 = EnchantmentHelper.getEnchantments(itemstack2);\n                    boolean flag2 = false;\n                    boolean flag3 = false;\n                    Iterator var23 = map1.keySet().iterator();\n\n                    label177:\n                    while (true) {\n                        Enchantment enchantment1;\n                        do {\n                            if (!var23.hasNext()) {\n                                if (flag3 && !flag2) {\n                                    this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                                    this.maximumCost = 0;\n                                    return;\n                                }\n                                break label177;\n                            }\n\n                            enchantment1 = (Enchantment) var23.next();\n                        } while (enchantment1 == null);\n\n                        int i2 = map.containsKey(enchantment1) ? (Integer) map.get(enchantment1) : 0;\n                        int j2 = (Integer) map1.get(enchantment1);\n                        j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);\n                        boolean flag1 = enchantment1.canApply(itemstack);\n                        if (this.player.capabilities.isCreativeMode || itemstack.getItem() == Items.ENCHANTED_BOOK) {\n                            flag1 = true;\n                        }\n\n                        Iterator var17 = map.keySet().iterator();\n\n                        while (var17.hasNext()) {\n                            Enchantment enchantment = (Enchantment) var17.next();\n                            if (enchantment != enchantment1 && !isCompatibleWith(enchantment, enchantment1)) {\n                                flag1 = false;\n                                ++i;\n                            }\n                        }\n\n                        if (!flag1) {\n                            flag3 = true;\n                        } else {\n                            flag2 = true;\n                            if (j2 > enchantment1.getMaxLevel()) {\n                                j2 = enchantment1.getMaxLevel();\n                            }\n\n                            map.put(enchantment1, j2);\n                            int k3 = 0;\n                            switch (enchantment1.getRarity()) {\n                                case COMMON:\n                                    k3 = 1;\n                                    break;\n                                case UNCOMMON:\n                                    k3 = 2;\n                                    break;\n                                case RARE:\n                                    k3 = 4;\n                                    break;\n                                case VERY_RARE:\n                                    k3 = 8;\n                            }\n\n                            if (flag) {\n                                k3 = Math.max(1, k3 / 2);\n                            }\n\n                            i += k3 * j2;\n                            if (itemstack.getCount() > 1) {\n                                i = 40;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (StringUtils.isBlank(this.repairedItemName)) {\n                if (itemstack.hasDisplayName()) {\n                    k = 1;\n                    i += k;\n                    itemstack1.clearCustomName();\n                }\n            } else if (!this.repairedItemName.equals(itemstack.getDisplayName())) {\n                k = 1;\n                i += k;\n                itemstack1.setStackDisplayName(this.repairedItemName);\n            }\n\n            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n\n            this.maximumCost = j + i;\n            if (i <= 0) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n\n            if (k == i && k > 0 && this.maximumCost >= 40) {\n                this.maximumCost = 39;\n            }\n\n            if (this.maximumCost >= 40 && !this.player.capabilities.isCreativeMode) {\n                this.maximumCost = 39;\n            }\n\n            if (!itemstack1.isEmpty()) {\n                k2 = itemstack1.getRepairCost();\n                if (!itemstack2.isEmpty() && k2 < itemstack2.getRepairCost()) {\n                    k2 = itemstack2.getRepairCost();\n                }\n\n                if (k != i || k == 0) {\n                    k2 = k2 * 2 + 1;\n                }\n\n                itemstack1.setRepairCost(k2);\n                EnchantmentHelper.setEnchantments(map, itemstack1);\n            }\n\n            this.outputSlot.setInventorySlotContents(0, itemstack1);\n            this.detectAndSendChanges();\n        }\n    }\n\n    private boolean onAnvilChange(ItemStack left, ItemStack right, IInventory outputSlot, String name, int baseCost) {\n        AnvilUpdateEvent e = new AnvilUpdateEvent(left, right, name, baseCost);\n        if (MinecraftForge.EVENT_BUS.post(e)) {\n            return false;\n        } else if (e.getOutput().isEmpty()) {\n            return true;\n        } else {\n            outputSlot.setInventorySlotContents(0, e.getOutput());\n            this.maximumCost = e.getCost();\n            this.materialCost = e.getMaterialCost();\n            return false;\n        }\n    }\n\n    private boolean isCompatibleWith(Enchantment enchantment1, Enchantment enchantment2) {\n        if ((enchantment1 instanceof EnchantmentArrowInfinite && enchantment2 instanceof EnchantmentMending) || (enchantment2 instanceof EnchantmentArrowInfinite && enchantment1 instanceof EnchantmentMending)) {\n            return true;\n        }\n        return enchantment1.isCompatibleWith(enchantment2);\n    }\n}", "class_id": 0, "repo": "Enaium-ForgeMC/NoExpensive", "file": "src/main/java/cn/enaium/noexpensive/injection/mixins/ContainerRepairMixin.java", "last_update_at": "2021-07-30T23:44:06+00:00", "question_id": "df86a5988dc4ae6c04ca10898aecb3dc91b26047", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Mixin(ContainerRepair.class)\npublic abstract class ContainerRepairMixin extends Container {\n    @Shadow\n    public int maximumCost;\n    @Shadow\n    @Final\n    private IInventory inputSlots;\n    @Shadow\n    @Final\n    private IInventory outputSlot;\n    @Shadow\n    public int materialCost;\n    @Shadow\n    private String repairedItemName;\n    @Shadow\n    @Final\n    private EntityPlayer player;\n    /**\n     * @author Enaium\n     */\n    @Overwrite\n    public void updateRepairOutput() {\n        ItemStack itemstack = this.inputSlots.getStackInSlot(0);\n        this.maximumCost = 1;\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        if (itemstack.isEmpty()) {\n            this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n            this.maximumCost = 0;\n        } else {\n            ItemStack itemstack1 = itemstack.copy();\n            ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);\n            Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);\n            j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());\n            this.materialCost = 0;\n            boolean flag = false;\n            int k2;\n            if (!itemstack2.isEmpty()) {\n                if (!onAnvilChange(itemstack, itemstack2, this.outputSlot, this.repairedItemName, j)) {\n                    return;\n                }\n                flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();\n                int i1;\n                int j1;\n                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {\n                    k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    if (k2 <= 0) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n                    for (i1 = 0; k2 > 0 && i1 < itemstack2.getCount(); ++i1) {\n                        j1 = itemstack1.getItemDamage() - k2;\n                        itemstack1.setItemDamage(j1);\n                        ++i;\n                        k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    }\n                    this.materialCost = i1;\n                } else {\n                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable())) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n                    if (itemstack1.isItemStackDamageable() && !flag) {\n                        k2 = itemstack.getMaxDamage() - itemstack.getItemDamage();\n                        i1 = itemstack2.getMaxDamage() - itemstack2.getItemDamage();\n                        j1 = i1 + itemstack1.getMaxDamage() * 12 / 100;\n                        int k1 = k2 + j1;\n                        int l1 = itemstack1.getMaxDamage() - k1;\n                        if (l1 < 0) {\n                            l1 = 0;\n                        }\n                        if (l1 < itemstack1.getItemDamage()) {\n                            itemstack1.setItemDamage(l1);\n                            i += 2;\n                        }\n                    }\n                    Map<Enchantment, Integer> map1 = EnchantmentHelper.getEnchantments(itemstack2);\n                    boolean flag2 = false;\n                    boolean flag3 = false;\n                    Iterator var23 = map1.keySet().iterator();\n                    label177:\n                    while (true) {\n                        Enchantment enchantment1;\n                        do {\n                            if (!var23.hasNext()) {\n                                if (flag3 && !flag2) {\n                                    this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                                    this.maximumCost = 0;\n                                    return;\n                                }\n                                break label177;\n                            }\n                            enchantment1 = (Enchantment) var23.next();\n                        } while (enchantment1 == null);\n                        int i2 = map.containsKey(enchantment1) ? (Integer) map.get(enchantment1) : 0;\n                        int j2 = (Integer) map1.get(enchantment1);\n                        j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);\n                        boolean flag1 = enchantment1.canApply(itemstack);\n                        if (this.player.capabilities.isCreativeMode || itemstack.getItem() == Items.ENCHANTED_BOOK) {\n                            flag1 = true;\n                        }\n                        Iterator var17 = map.keySet().iterator();\n                        while (var17.hasNext()) {\n                            Enchantment enchantment = (Enchantment) var17.next();\n                            if (enchantment != enchantment1 && !isCompatibleWith(enchantment, enchantment1)) {\n                                flag1 = false;\n                                ++i;\n                            }\n                        }\n                        if (!flag1) {\n                            flag3 = true;\n                        } else {\n                            flag2 = true;\n                            if (j2 > enchantment1.getMaxLevel()) {\n                                j2 = enchantment1.getMaxLevel();\n                            }\n                            map.put(enchantment1, j2);\n                            int k3 = 0;\n                            switch (enchantment1.getRarity()) {\n                                case COMMON:\n                                    k3 = 1;\n                                    break;\n                                case UNCOMMON:\n                                    k3 = 2;\n                                    break;\n                                case RARE:\n                                    k3 = 4;\n                                    break;\n                                case VERY_RARE:\n                                    k3 = 8;\n                            }\n                            if (flag) {\n                                k3 = Math.max(1, k3 / 2);\n                            }\n                            i += k3 * j2;\n                            if (itemstack.getCount() > 1) {\n                                i = 40;\n                            }\n                        }\n                    }\n                }\n            }\n            if (StringUtils.isBlank(this.repairedItemName)) {\n                if (itemstack.hasDisplayName()) {\n                    k = 1;\n                    i += k;\n                    itemstack1.clearCustomName();\n                }\n            } else if (!this.repairedItemName.equals(itemstack.getDisplayName())) {\n                k = 1;\n                i += k;\n                itemstack1.setStackDisplayName(this.repairedItemName);\n            }\n            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n            this.maximumCost = j + i;\n            if (i <= 0) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n            if (k == i && k > 0 && this.maximumCost >= 40) {\n                this.maximumCost = 39;\n            }\n            if (this.maximumCost >= 40 && !this.player.capabilities.isCreativeMode) {\n                this.maximumCost = 39;\n            }\n            if (!itemstack1.isEmpty()) {\n                k2 = itemstack1.getRepairCost();\n                if (!itemstack2.isEmpty() && k2 < itemstack2.getRepairCost()) {\n                    k2 = itemstack2.getRepairCost();\n                }\n                if (k != i || k == 0) {\n                    k2 = k2 * 2 + 1;\n                }\n                itemstack1.setRepairCost(k2);\n                EnchantmentHelper.setEnchantments(map, itemstack1);\n            }\n            this.outputSlot.setInventorySlotContents(0, itemstack1);\n            this.detectAndSendChanges();\n        }\n    }\n    private boolean onAnvilChange(ItemStack left, ItemStack right, IInventory outputSlot, String name, int baseCost) {\n        AnvilUpdateEvent e = new AnvilUpdateEvent(left, right, name, baseCost);\n        if (MinecraftForge.EVENT_BUS.post(e)) {\n            return false;\n        } else if (e.getOutput().isEmpty()) {\n            return true;\n        } else {\n            outputSlot.setInventorySlotContents(0, e.getOutput());\n            this.maximumCost = e.getCost();\n            this.materialCost = e.getMaterialCost();\n            return false;\n        }\n    }\n    private boolean isCompatibleWith(Enchantment enchantment1, Enchantment enchantment2) {\n        if ((enchantment1 instanceof EnchantmentArrowInfinite && enchantment2 instanceof EnchantmentMending) || (enchantment2 instanceof EnchantmentArrowInfinite && enchantment1 instanceof EnchantmentMending)) {\n            return true;\n        }\n        return enchantment1.isCompatibleWith(enchantment2);\n    }\n"]]}
{"hexsha": "1734f11ef39ffc15b610a3bd91177494d7572518", "ext": "java", "lang": "Java", "content": "public class DocumentIdNode extends DOMFragmentReader<DocumentId> {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DocumentIdNode.class);\n\n\tprivate static final XPath PATXP = DocumentHelper.createXPath(\"/DOCUMENT/PATN\");\n\tprivate static final XPath NUMXP = DocumentHelper.createXPath(\"WKU\");\n\tprivate static final XPath ISSUEDATEXP = DocumentHelper.createXPath(\"ISD\");\n\n\tprivate static final CountryCode DEFAULT_COUNTRYCODE = CountryCode.US;\n\n\tprivate CountryCode fallbackCountryCode;\n\n\tpublic DocumentIdNode(Document document) {\n\t\tthis(document, DEFAULT_COUNTRYCODE);\n\t}\n\n\tpublic DocumentIdNode(Document document, CountryCode fallbackCountryCode) {\n\t\tsuper(document);\n\t\tthis.fallbackCountryCode = fallbackCountryCode;\n\t}\n\n\t@Override\n\tpublic DocumentId read() {\n\t\tNode parentNode = PATXP.selectSingleNode(document);\n\n\t\tNode docNumN = NUMXP.selectSingleNode(parentNode);\n\t\tif (docNumN == null) {\n\t\t\tLOGGER.warn(\"Invalid document-id, field 'WKU' not found: {}\", document.asXML());\n\t\t\treturn null;\n\t\t}\n\n\t\tString patNum = docNumN.getText().substring(1, 8);\n\t\tDocumentId documentId = new DocumentId(fallbackCountryCode, patNum);\n\n\t\tNode dateN = ISSUEDATEXP.selectSingleNode(parentNode);\n\t\tif (dateN != null) {\n\t\t\tString dateTxt = dateN.getText();\n\t\t\ttry {\n\t\t\t\tdocumentId.setDate(new DocumentDate(dateTxt));\n\t\t\t} catch (InvalidDataException e) {\n\t\t\t\tLOGGER.warn(\"{} : {}\", e.getMessage(), dateN.getParent().asXML());\n\t\t\t}\n\t\t}\n\n\t\treturn documentId;\n\t}\n\n}", "class_id": 0, "repo": "cambialens/PatentPublicData", "file": "PatentDocument/src/main/java/gov/uspto/patent/doc/greenbook/fragments/DocumentIdNode.java", "last_update_at": "2021-08-11T19:14:13+00:00", "question_id": "1734f11ef39ffc15b610a3bd91177494d7572518", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DocumentIdNode extends DOMFragmentReader<DocumentId> {\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DocumentIdNode.class);\n\tprivate static final XPath PATXP = DocumentHelper.createXPath(\"/DOCUMENT/PATN\");\n\tprivate static final XPath NUMXP = DocumentHelper.createXPath(\"WKU\");\n\tprivate static final XPath ISSUEDATEXP = DocumentHelper.createXPath(\"ISD\");\n\tprivate static final CountryCode DEFAULT_COUNTRYCODE = CountryCode.US;\n\tprivate CountryCode fallbackCountryCode;\n\tpublic DocumentIdNode(Document document) {\n\t\tthis(document, DEFAULT_COUNTRYCODE);\n\t}\n\tpublic DocumentIdNode(Document document, CountryCode fallbackCountryCode) {\n\t\tsuper(document);\n\t\tthis.fallbackCountryCode = fallbackCountryCode;\n\t}\n\t@Override\n\tpublic DocumentId read() {\n\t\tNode parentNode = PATXP.selectSingleNode(document);\n\t\tNode docNumN = NUMXP.selectSingleNode(parentNode);\n\t\tif (docNumN == null) {\n\t\t\tLOGGER.warn(\"Invalid document-id, field 'WKU' not found: {}\", document.asXML());\n\t\t\treturn null;\n\t\t}\n\t\tString patNum = docNumN.getText().substring(1, 8);\n\t\tDocumentId documentId = new DocumentId(fallbackCountryCode, patNum);\n\t\tNode dateN = ISSUEDATEXP.selectSingleNode(parentNode);\n\t\tif (dateN != null) {\n\t\t\tString dateTxt = dateN.getText();\n\t\t\ttry {\n\t\t\t\tdocumentId.setDate(new DocumentDate(dateTxt));\n\t\t\t} catch (InvalidDataException e) {\n\t\t\t\tLOGGER.warn(\"{} : {}\", e.getMessage(), dateN.getParent().asXML());\n\t\t\t}\n\t\t}\n\t\treturn documentId;\n\t}\n"]]}
{"hexsha": "013ae4b5c9166755961902e1d4e8a6e2bb028d77", "ext": "java", "lang": "Java", "content": "@Test(singleThreaded = true)\npublic class TestClusterManager\n{\n  private Log log = LogFactory.getLog(TestClusterManager.class);\n\n  @Test\n  /*\n   * Tests that the worker nodes returned are correctly handled by PrestoClusterManager and sorted list of hosts is returned\n   */\n  public void testGetNodes()\n          throws IOException\n  {\n    HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new NoFailedNode());\n\n    log.info(\"STARTED SERVER\");\n\n    ClusterManager clusterManager = getPrestoClusterManager();\n    List<String> nodes = clusterManager.getNodes();\n    log.info(\"Got nodes: \" + nodes);\n\n    assertTrue(nodes.size() == 2, \"Should only have two nodes\");\n    assertTrue(nodes.get(0).equals(\"192.168.1.3\") && nodes.get(1).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n\n    server.stop(0);\n  }\n\n  @Test\n  /*\n   * Tests that in a single node cluster, master node is returned as worker\n   */\n  public void testMasterOnlyCluster()\n          throws IOException\n  {\n    HttpServer server = createServer(\"/v1/node\", new NoWorker(), \"/v1/node/failed\", new NoFailedNode());\n\n    log.info(\"STARTED SERVER\");\n\n    ClusterManager clusterManager = getPrestoClusterManager();\n    List<String> nodes = clusterManager.getNodes();\n    log.info(\"Got nodes: \" + nodes);\n\n    assertTrue(nodes.size() == 1, \"Should have added localhost in list\");\n    assertTrue(nodes.get(0).equals(InetAddress.getLocalHost().getHostAddress()), \"Not added right hostname\");\n    server.stop(0);\n  }\n\n  @Test\n  /*\n   * Tests that in a cluster with failed node, failed node is not returned\n   */\n  public void testFailedNodeCluster()\n          throws IOException\n  {\n    HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new OneFailedNode());\n\n    log.info(\"STARTED SERVER\");\n\n    ClusterManager clusterManager = getPrestoClusterManager();\n    List<String> nodes = clusterManager.getNodes();\n    log.info(\"Got nodes: \" + nodes);\n\n    assertTrue(nodes.size() == 1, \"Should only have two nodes\");\n    assertTrue(nodes.get(0).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n\n    server.stop(0);\n  }\n\n  private HttpServer createServer(String endpoint1, HttpHandler handler1, String endpoint2, HttpHandler handler2)\n          throws IOException\n  {\n    HttpServer server = HttpServer.create(new InetSocketAddress(45326), 0);\n    server.createContext(endpoint1, handler1);\n    server.createContext(endpoint2, handler2);\n    server.setExecutor(null); // creates a default executor\n    server.start();\n    return server;\n  }\n\n  private ClusterManager getPrestoClusterManager()\n          throws UnknownHostException\n  {\n    ClusterManager clusterManager = new PrestoClusterManager();\n    Configuration conf = new Configuration();\n    conf.setInt(PrestoClusterManager.serverPortConf, 45326);\n    clusterManager.initialize(conf);\n    return clusterManager;\n  }\n\n  class MultipleWorkers implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[{\\\"uri\\\":\\\"http://192.168.2.252:8083\\\",\\\"recentRequests\\\":119.0027780896941,\\\"recentFailures\\\":119.00267353393015,\\\"recentSuccesses\\\":1.0845754237194612E-4,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"recentFailureRatio\\\":0.999999121400646,\\\"age\\\":\\\"6.68h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":2.4567611856996272E-6,\\\"java.net.SocketTimeoutException\\\":119.00237271323728,\\\"java.net.SocketException\\\":2.98363931759331E-4}},{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n\n  class NoWorker implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n\n  class NoFailedNode implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n\n  class OneFailedNode implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n}", "class_id": 0, "repo": "starburstdata/rubix", "file": "rubix-prestosql/src/test/java/com/qubole/rubix/prestosql/TestClusterManager.java", "last_update_at": "2021-07-12T16:14:14+00:00", "question_id": "013ae4b5c9166755961902e1d4e8a6e2bb028d77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Test(singleThreaded = true)\npublic class TestClusterManager\n{\n  private Log log = LogFactory.getLog(TestClusterManager.class);\n  @Test\n  /*\n   * Tests that the worker nodes returned are correctly handled by PrestoClusterManager and sorted list of hosts is returned\n   */\n  public void testGetNodes()\n          throws IOException\n  {\n    HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new NoFailedNode());\n    log.info(\"STARTED SERVER\");\n    ClusterManager clusterManager = getPrestoClusterManager();\n    List<String> nodes = clusterManager.getNodes();\n    log.info(\"Got nodes: \" + nodes);\n    assertTrue(nodes.size() == 2, \"Should only have two nodes\");\n    assertTrue(nodes.get(0).equals(\"192.168.1.3\") && nodes.get(1).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n    server.stop(0);\n  }\n  @Test\n  /*\n   * Tests that in a single node cluster, master node is returned as worker\n   */\n  public void testMasterOnlyCluster()\n          throws IOException\n  {\n    HttpServer server = createServer(\"/v1/node\", new NoWorker(), \"/v1/node/failed\", new NoFailedNode());\n    log.info(\"STARTED SERVER\");\n    ClusterManager clusterManager = getPrestoClusterManager();\n    List<String> nodes = clusterManager.getNodes();\n    log.info(\"Got nodes: \" + nodes);\n    assertTrue(nodes.size() == 1, \"Should have added localhost in list\");\n    assertTrue(nodes.get(0).equals(InetAddress.getLocalHost().getHostAddress()), \"Not added right hostname\");\n    server.stop(0);\n  }\n  @Test\n  /*\n   * Tests that in a cluster with failed node, failed node is not returned\n   */\n  public void testFailedNodeCluster()\n          throws IOException\n  {\n    HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new OneFailedNode());\n    log.info(\"STARTED SERVER\");\n    ClusterManager clusterManager = getPrestoClusterManager();\n    List<String> nodes = clusterManager.getNodes();\n    log.info(\"Got nodes: \" + nodes);\n    assertTrue(nodes.size() == 1, \"Should only have two nodes\");\n    assertTrue(nodes.get(0).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n    server.stop(0);\n  }\n  private HttpServer createServer(String endpoint1, HttpHandler handler1, String endpoint2, HttpHandler handler2)\n          throws IOException\n  {\n    HttpServer server = HttpServer.create(new InetSocketAddress(45326), 0);\n    server.createContext(endpoint1, handler1);\n    server.createContext(endpoint2, handler2);\n    server.setExecutor(null); // creates a default executor\n    server.start();\n    return server;\n  }\n  private ClusterManager getPrestoClusterManager()\n          throws UnknownHostException\n  {\n    ClusterManager clusterManager = new PrestoClusterManager();\n    Configuration conf = new Configuration();\n    conf.setInt(PrestoClusterManager.serverPortConf, 45326);\n    clusterManager.initialize(conf);\n    return clusterManager;\n  }\n  class MultipleWorkers implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[{\\\"uri\\\":\\\"http://192.168.2.252:8083\\\",\\\"recentRequests\\\":119.0027780896941,\\\"recentFailures\\\":119.00267353393015,\\\"recentSuccesses\\\":1.0845754237194612E-4,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"recentFailureRatio\\\":0.999999121400646,\\\"age\\\":\\\"6.68h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":2.4567611856996272E-6,\\\"java.net.SocketTimeoutException\\\":119.00237271323728,\\\"java.net.SocketException\\\":2.98363931759331E-4}},{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n  class NoWorker implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n  class NoFailedNode implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n  class OneFailedNode implements HttpHandler\n  {\n    public void handle(HttpExchange exchange) throws IOException\n    {\n      String nodes = \"[{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n      exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n      exchange.sendResponseHeaders(200, nodes.length());\n      OutputStream os = exchange.getResponseBody();\n      os.write(nodes.getBytes());\n      os.close();\n    }\n  }\n"]]}
{"hexsha": "ad60ecfd5bb8c4cfd813c68c144210185e671f15", "ext": "java", "lang": "Java", "content": "@Slf4j\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Override\n    public void registerEmail(String subject,String content,String[] toUserEmailArray) {\n\n        //\u53d1\u9001\u6d88\u606f\u5bf9\u8c61\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n\n        // use the true flag to indicate you need a multipart message\n        MimeMessageHelper mimeMessageHelper;\n        try {\n            mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);\n            mimeMessageHelper.setSubject(subject);\n            //\u90ae\u4ef6\u8c01\u53d1\u9001\u7684\n            mimeMessageHelper.setFrom(mailProperties.getUsername());\n            //\u6dfb\u52a0\u90ae\u4ef6\u53d1\u9001\u7ed9\u8c01\n            mimeMessageHelper.setTo(toUserEmailArray);\n            //\u6dfb\u52a0\u90ae\u4ef6\u6b63\u6587\n            mimeMessageHelper.setText(content,true);\n            //\u90ae\u4ef6\u6b63\u6587\u56fe\u7247\n            ClassPathResource classPathResource=new ClassPathResource(\"/static/images/share-public.png\");\n            //\u5185\u5d4c\u56fe\u7247 \u7ed1\u5b9aID\n            mimeMessageHelper.addInline(\"logoImage\",classPathResource);\n            //\u83b7\u53d6\u9644\u4ef6\u56fe\u7247\n            FileSystemResource fileSystemResource = new FileSystemResource(new File(\"C:\\\\Users\\\\xingyun\\\\Pictures\\\\program.jpg\"));\n            //\u6dfb\u52a0\u9644\u4ef6\n            mimeMessageHelper.addAttachment(\"program.jpg\",fileSystemResource);\n\n            //\u53d1\u9001\u90ae\u4ef6\n            javaMailSender.send(mimeMessage);\n        } catch (MessagingException e) {\n            log.error(\"Messaging Exception:\",e);\n        }\n    }\n}", "class_id": 0, "repo": "geekxingyun/spring-boot-best-practices-sample", "file": "spring-boot-with-java-mail-sender-sample/src/main/java/com/xingyun/springbootwithjavamailsendersample/service/UserServiceImpl.java", "last_update_at": "2021-09-24T04:54:02+00:00", "question_id": "ad60ecfd5bb8c4cfd813c68c144210185e671f15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n    @Autowired\n    private MailProperties mailProperties;\n    @Override\n    public void registerEmail(String subject,String content,String[] toUserEmailArray) {\n        //\u53d1\u9001\u6d88\u606f\u5bf9\u8c61\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        // use the true flag to indicate you need a multipart message\n        MimeMessageHelper mimeMessageHelper;\n        try {\n            mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);\n            mimeMessageHelper.setSubject(subject);\n            //\u90ae\u4ef6\u8c01\u53d1\u9001\u7684\n            mimeMessageHelper.setFrom(mailProperties.getUsername());\n            //\u6dfb\u52a0\u90ae\u4ef6\u53d1\u9001\u7ed9\u8c01\n            mimeMessageHelper.setTo(toUserEmailArray);\n            //\u6dfb\u52a0\u90ae\u4ef6\u6b63\u6587\n            mimeMessageHelper.setText(content,true);\n            //\u90ae\u4ef6\u6b63\u6587\u56fe\u7247\n            ClassPathResource classPathResource=new ClassPathResource(\"/static/images/share-public.png\");\n            //\u5185\u5d4c\u56fe\u7247 \u7ed1\u5b9aID\n            mimeMessageHelper.addInline(\"logoImage\",classPathResource);\n            //\u83b7\u53d6\u9644\u4ef6\u56fe\u7247\n            FileSystemResource fileSystemResource = new FileSystemResource(new File(\"C:\\\\Users\\\\xingyun\\\\Pictures\\\\program.jpg\"));\n            //\u6dfb\u52a0\u9644\u4ef6\n            mimeMessageHelper.addAttachment(\"program.jpg\",fileSystemResource);\n            //\u53d1\u9001\u90ae\u4ef6\n            javaMailSender.send(mimeMessage);\n        } catch (MessagingException e) {\n            log.error(\"Messaging Exception:\",e);\n        }\n    }\n"]]}
{"hexsha": "d9151f6e311531a33967c956253a7916f0cc14ba", "ext": "java", "lang": "Java", "content": "public class CondensedViterbiIntersectionAutomaton<LeftState, RightState> extends GenericCondensedIntersectionAutomaton<LeftState, RightState> {\n\n    private final Int2DoubleMap viterbiStateMap;        ///< Maps a state from this automaton to a probability\n    private final Int2ObjectMap<Rule> viterbiRuleMap;   ///< Maps a state to its best rule\n\n    public CondensedViterbiIntersectionAutomaton(TreeAutomaton<LeftState> left, CondensedTreeAutomaton<RightState> right, SignatureMapper sigMapper) {\n        super(left, right, sigMapper);\n\n        viterbiStateMap = new ArrayInt2DoubleMap();\n        viterbiStateMap.defaultReturnValue(0.0); // if a state is not in this map, return 0\n\n        viterbiRuleMap = new ArrayMap<>();\n    }\n\n    @Override\n    // Add all rules, when the algorithm is finished, so we can be sure,\n    // to enter only the best rules.\n    protected void collectOutputRule(Rule outputRule) {\n        int newState = outputRule.getParent();\n        int[] children = outputRule.getChildren();\n        double childWeight = outputRule.getWeight();\n\n        // multiply the weight of all childs of the rule\n        for (int i = 0; i < children.length; i++) {\n            childWeight *= viterbiStateMap.get(children[i]);\n        }\n\n        if (viterbiStateMap.get(newState) < childWeight) {\n            // current rule is new, or better than old rule\n            viterbiRuleMap.put(newState, outputRule);\n            viterbiStateMap.put(newState, childWeight);\n        }\n    }\n\n    @Override\n    protected void addAllOutputRules() {\n        viterbiRuleMap.values().forEach(this::storeRuleBoth);\n    }\n    \n    public static void main(String[] args) throws Exception {\n        GenericCondensedIntersectionAutomaton.main(args, false, (left, right) -> left.intersectViterbi(right));\n    }\n}", "class_id": 0, "repo": "akoehn/alto", "file": "src/main/java/de/up/ling/irtg/automata/condensed/CondensedViterbiIntersectionAutomaton.java", "last_update_at": "2021-09-03T14:34:06+00:00", "question_id": "d9151f6e311531a33967c956253a7916f0cc14ba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CondensedViterbiIntersectionAutomaton<LeftState, RightState> extends GenericCondensedIntersectionAutomaton<LeftState, RightState> {\n    private final Int2DoubleMap viterbiStateMap;        ///< Maps a state from this automaton to a probability\n    private final Int2ObjectMap<Rule> viterbiRuleMap;   ///< Maps a state to its best rule\n    public CondensedViterbiIntersectionAutomaton(TreeAutomaton<LeftState> left, CondensedTreeAutomaton<RightState> right, SignatureMapper sigMapper) {\n        super(left, right, sigMapper);\n        viterbiStateMap = new ArrayInt2DoubleMap();\n        viterbiStateMap.defaultReturnValue(0.0); // if a state is not in this map, return 0\n        viterbiRuleMap = new ArrayMap<>();\n    }\n    @Override\n    // Add all rules, when the algorithm is finished, so we can be sure,\n    // to enter only the best rules.\n    protected void collectOutputRule(Rule outputRule) {\n        int newState = outputRule.getParent();\n        int[] children = outputRule.getChildren();\n        double childWeight = outputRule.getWeight();\n        // multiply the weight of all childs of the rule\n        for (int i = 0; i < children.length; i++) {\n            childWeight *= viterbiStateMap.get(children[i]);\n        }\n        if (viterbiStateMap.get(newState) < childWeight) {\n            // current rule is new, or better than old rule\n            viterbiRuleMap.put(newState, outputRule);\n            viterbiStateMap.put(newState, childWeight);\n        }\n    }\n    @Override\n    protected void addAllOutputRules() {\n        viterbiRuleMap.values().forEach(this::storeRuleBoth);\n    }\n    public static void main(String[] args) throws Exception {\n        GenericCondensedIntersectionAutomaton.main(args, false, (left, right) -> left.intersectViterbi(right));\n    }\n"]]}
{"hexsha": "0db6462f307cd534cb695bcb86ae0f3fbd5626e1", "ext": "java", "lang": "Java", "content": "public class BlazeLimbEntity extends Entity {\n\n    public static final Identifier SPAWN_PACKET = FrostburnOrigins.id(\"blaze_limb\");\n\n    public BlazeLimbEntity(EntityType<? extends BlazeLimbEntity> entityType, World world) {\n        super(entityType, world);\n    }\n\n    public BlazeLimbEntity(World world, double x, double y, double z, int id, UUID uuid) {\n        this(FrostburnOrigins.BLAZE_LIMB, world);\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n        setEntityId(id);\n        setUuid(uuid);\n    }\n\n    private UUID ownerUuid = null;\n\n    public void setOwnerUuid(UUID uuid) {\n        ownerUuid = uuid;\n    }\n\n    public UUID getOwnerUuid() {\n        return ownerUuid;\n    }\n\n    @Override\n    protected void initDataTracker() {\n\n    }\n\n    @Override\n    public void tick() {\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n    }\n\n    @Override\n    protected void readCustomDataFromTag(CompoundTag tag) {\n\n    }\n\n    @Override\n    protected void writeCustomDataToTag(CompoundTag tag) {\n\n    }\n\n    @Override\n    public Packet<?> createSpawnPacket() {\n        PacketByteBuf packet = new PacketByteBuf(Unpooled.buffer());\n\n        // entity position\n        packet.writeDouble(getX());\n        packet.writeDouble(getY());\n        packet.writeDouble(getZ());\n\n        // entity id & uuid\n        packet.writeInt(getEntityId());\n        packet.writeUuid(getUuid());\n\n        return ServerSidePacketRegistry.INSTANCE.toPacket(SPAWN_PACKET, packet);\n    }\n}", "class_id": 0, "repo": "TheMisteryMan/frostburn-origins", "file": "src/main/java/misteryman/frostburnorigins/entity/BlazeLimbEntity.java", "last_update_at": "2021-01-03T07:29:14+00:00", "question_id": "0db6462f307cd534cb695bcb86ae0f3fbd5626e1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlazeLimbEntity extends Entity {\n    public static final Identifier SPAWN_PACKET = FrostburnOrigins.id(\"blaze_limb\");\n    public BlazeLimbEntity(EntityType<? extends BlazeLimbEntity> entityType, World world) {\n        super(entityType, world);\n    }\n    public BlazeLimbEntity(World world, double x, double y, double z, int id, UUID uuid) {\n        this(FrostburnOrigins.BLAZE_LIMB, world);\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n        setEntityId(id);\n        setUuid(uuid);\n    }\n    private UUID ownerUuid = null;\n    public void setOwnerUuid(UUID uuid) {\n        ownerUuid = uuid;\n    }\n    public UUID getOwnerUuid() {\n        return ownerUuid;\n    }\n    @Override\n    protected void initDataTracker() {\n    }\n    @Override\n    public void tick() {\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n    }\n    @Override\n    protected void readCustomDataFromTag(CompoundTag tag) {\n    }\n    @Override\n    protected void writeCustomDataToTag(CompoundTag tag) {\n    }\n    @Override\n    public Packet<?> createSpawnPacket() {\n        PacketByteBuf packet = new PacketByteBuf(Unpooled.buffer());\n        // entity position\n        packet.writeDouble(getX());\n        packet.writeDouble(getY());\n        packet.writeDouble(getZ());\n        // entity id & uuid\n        packet.writeInt(getEntityId());\n        packet.writeUuid(getUuid());\n        return ServerSidePacketRegistry.INSTANCE.toPacket(SPAWN_PACKET, packet);\n    }\n"]]}
{"hexsha": "36387dd02e802b9e3c3f2cd575b8ec1e1c862fe8", "ext": "java", "lang": "Java", "content": "public class ReorderNoCross {\n    \n    private final ArrayList<String> joinSchema;\n    private final ArrayList<String> lastJoinVars;\n    private BasicPattern inputPattern;\n    private final BasicPattern outputPattern;\n\n    public ReorderNoCross() {\n        joinSchema = new ArrayList<String>();\n        lastJoinVars = new ArrayList<String>();\n        outputPattern = new BasicPattern();\n    }\n\n\n    public BasicPattern reorder(BasicPattern pattern) {\n        inputPattern = pattern;\n        List<Triple> triples = inputPattern.getList();\n\n        int idx = chooseFirst();\n        Triple triple = triples.get(idx);\n        outputPattern.add(triple);\n        joinSchema.addAll(getVarsOfTriple(triple));\n        triples.remove(idx);\n\n        while (!triples.isEmpty()) {\n            idx = chooseNext();\n            triple = triples.get(idx);\n            outputPattern.add(triple);\n            joinSchema.addAll(getVarsOfTriple(triple));\n            triples.remove(idx);\n        }\n\n        return outputPattern;\n    }\n\n    private int chooseNext() {\n        ArrayList<String> tripleVars;\n        ArrayList<String> sharedVars;\n        for (int i=0; i<inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (lastJoinVars.size() > 0 && lastJoinVars.size() == sharedVars.size() && lastJoinVars.containsAll(sharedVars)) {\n                // lastJoinVars remain unchanged\n                return i;\n            }\n        }\n        for (int i=0; i<inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (sharedVars.size() > 0) {\n                lastJoinVars.clear();\n                lastJoinVars.addAll(sharedVars);\n                return i;\n            }\n        }\n        lastJoinVars.clear();\n        return 0;\n    }\n\n    private int chooseFirst() {\n        for (int i=0; i<inputPattern.size(); i++) {\n            if (hasSharedVars(i)) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    private boolean hasSharedVars(int triplePos) {\n        Triple triple = inputPattern.get(triplePos);\n        ArrayList<String> tripleVars = getVarsOfTriple(triple);\n        for (int i=0; i<inputPattern.size(); i++) {\n            if (i != triplePos && getSharedVars(getVarsOfTriple(inputPattern.get(i)), tripleVars).size() > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private ArrayList<String> getVarsOfTriple(Triple t) {\n        ArrayList<String> vars = new ArrayList<String>();\n        Node subject = t.getSubject();\n        Node predicate = t.getPredicate();\n        Node object = t.getObject();\n        if(subject.isVariable())\n            vars.add(subject.getName());\n        if(predicate.isVariable())\n            vars.add(predicate.getName());\n        if(object.isVariable())\n            vars.add(object.getName());\n        return vars;\n    }\n\n    private ArrayList<String> getSharedVars(ArrayList<String> leftSchema, ArrayList<String> rightSchema) {\n        ArrayList<String> sharedVars = new ArrayList<String>();\n        for(int i=0; i<rightSchema.size(); i++) {\n            if(leftSchema.contains(rightSchema.get(i)))\n                sharedVars.add(rightSchema.get(i));\n        }\n        return sharedVars;\n    }\n\n}", "class_id": 0, "repo": "h4ck3rm1k3/S2RDF", "file": "QueryTranslator/S2RDF_QueryTranslator/src/queryTranslator/sparql/ReorderNoCross.java", "last_update_at": "2021-03-21T06:05:15+00:00", "question_id": "36387dd02e802b9e3c3f2cd575b8ec1e1c862fe8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ReorderNoCross {\n    private final ArrayList<String> joinSchema;\n    private final ArrayList<String> lastJoinVars;\n    private BasicPattern inputPattern;\n    private final BasicPattern outputPattern;\n    public ReorderNoCross() {\n        joinSchema = new ArrayList<String>();\n        lastJoinVars = new ArrayList<String>();\n        outputPattern = new BasicPattern();\n    }\n    public BasicPattern reorder(BasicPattern pattern) {\n        inputPattern = pattern;\n        List<Triple> triples = inputPattern.getList();\n        int idx = chooseFirst();\n        Triple triple = triples.get(idx);\n        outputPattern.add(triple);\n        joinSchema.addAll(getVarsOfTriple(triple));\n        triples.remove(idx);\n        while (!triples.isEmpty()) {\n            idx = chooseNext();\n            triple = triples.get(idx);\n            outputPattern.add(triple);\n            joinSchema.addAll(getVarsOfTriple(triple));\n            triples.remove(idx);\n        }\n        return outputPattern;\n    }\n    private int chooseNext() {\n        ArrayList<String> tripleVars;\n        ArrayList<String> sharedVars;\n        for (int i=0; i<inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (lastJoinVars.size() > 0 && lastJoinVars.size() == sharedVars.size() && lastJoinVars.containsAll(sharedVars)) {\n                // lastJoinVars remain unchanged\n                return i;\n            }\n        }\n        for (int i=0; i<inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (sharedVars.size() > 0) {\n                lastJoinVars.clear();\n                lastJoinVars.addAll(sharedVars);\n                return i;\n            }\n        }\n        lastJoinVars.clear();\n        return 0;\n    }\n    private int chooseFirst() {\n        for (int i=0; i<inputPattern.size(); i++) {\n            if (hasSharedVars(i)) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    private boolean hasSharedVars(int triplePos) {\n        Triple triple = inputPattern.get(triplePos);\n        ArrayList<String> tripleVars = getVarsOfTriple(triple);\n        for (int i=0; i<inputPattern.size(); i++) {\n            if (i != triplePos && getSharedVars(getVarsOfTriple(inputPattern.get(i)), tripleVars).size() > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private ArrayList<String> getVarsOfTriple(Triple t) {\n        ArrayList<String> vars = new ArrayList<String>();\n        Node subject = t.getSubject();\n        Node predicate = t.getPredicate();\n        Node object = t.getObject();\n        if(subject.isVariable())\n            vars.add(subject.getName());\n        if(predicate.isVariable())\n            vars.add(predicate.getName());\n        if(object.isVariable())\n            vars.add(object.getName());\n        return vars;\n    }\n    private ArrayList<String> getSharedVars(ArrayList<String> leftSchema, ArrayList<String> rightSchema) {\n        ArrayList<String> sharedVars = new ArrayList<String>();\n        for(int i=0; i<rightSchema.size(); i++) {\n            if(leftSchema.contains(rightSchema.get(i)))\n                sharedVars.add(rightSchema.get(i));\n        }\n        return sharedVars;\n    }\n"]]}
{"hexsha": "ba78fcab5c3ff1462db195ba869fb513fc0c22b3", "ext": "java", "lang": "Java", "content": "@RunWith(FeaturesRunner.class)\n@Features({ CoreFeature.class })\n@Deploy(\"org.nuxeo.ecm.automation.core\")\npublic class GetLastDocumentVersionTest {\n\n    @Inject\n    CoreSession session;\n\n    @Inject\n    AutomationService service;\n\n    protected DocumentModel folder;\n\n    protected DocumentModel section;\n\n    protected DocumentModel doc;\n\n    @Before\n    public void initRepo() throws Exception {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n\n        folder = session.createDocumentModel(\"/\", \"Folder\", \"Folder\");\n        folder.setPropertyValue(\"dc:title\", \"Folder\");\n        folder = session.createDocument(folder);\n        session.save();\n        folder = session.getDocument(folder.getRef());\n    }\n\n    @After\n    public void cleanRepo() {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n    }\n\n    protected DocumentModel createDocumentVersions(DocumentModel doc, VersioningOption vo, int nrVersions) {\n        for (int i = 1; i <= nrVersions; i++) {\n            // make sure the version doesn't have the same \"created\" as the previous one\n            try {\n                Thread.sleep(2); // NOSONAR\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n            doc.setPropertyValue(\"dc:description\", String.valueOf(i));\n            doc.putContextData(VersioningService.VERSIONING_OPTION, vo);\n            doc = session.saveDocument(doc);\n        }\n        session.save();\n        return doc;\n    }\n\n    @Test\n    public void testGetLastMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.0\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testGetLastMinorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"0.3\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testGetLastMinorMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.3\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testNonexistentLastVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithNoVersion\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithNoVersion\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n\n        DocumentModel lastVersion = runOperation(doc);\n        assertNull(lastVersion);\n    }\n\n    /**\n     * Runs the operation for the different document models of the test.\n     */\n    protected DocumentModel runOperation(DocumentModel input) throws OperationException {\n        try (OperationContext ctx = new OperationContext(session)) {\n            ctx.setInput(input);\n            OperationChain chain = new OperationChain(\"testGetLastVersion\");\n            chain.add(GetLastDocumentVersion.ID);\n            return (DocumentModel) service.run(ctx, chain);\n        }\n    }\n\n}", "class_id": 0, "repo": "aTiKhan/nuxeo", "file": "modules/platform/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/GetLastDocumentVersionTest.java", "last_update_at": "2021-02-15T19:07:59+00:00", "question_id": "ba78fcab5c3ff1462db195ba869fb513fc0c22b3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(FeaturesRunner.class)\n@Features({ CoreFeature.class })\n@Deploy(\"org.nuxeo.ecm.automation.core\")\npublic class GetLastDocumentVersionTest {\n    @Inject\n    CoreSession session;\n    @Inject\n    AutomationService service;\n    protected DocumentModel folder;\n    protected DocumentModel section;\n    protected DocumentModel doc;\n    @Before\n    public void initRepo() throws Exception {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n        folder = session.createDocumentModel(\"/\", \"Folder\", \"Folder\");\n        folder.setPropertyValue(\"dc:title\", \"Folder\");\n        folder = session.createDocument(folder);\n        session.save();\n        folder = session.getDocument(folder.getRef());\n    }\n    @After\n    public void cleanRepo() {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n    }\n    protected DocumentModel createDocumentVersions(DocumentModel doc, VersioningOption vo, int nrVersions) {\n        for (int i = 1; i <= nrVersions; i++) {\n            // make sure the version doesn't have the same \"created\" as the previous one\n            try {\n                Thread.sleep(2); // NOSONAR\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n            doc.setPropertyValue(\"dc:description\", String.valueOf(i));\n            doc.putContextData(VersioningService.VERSIONING_OPTION, vo);\n            doc = session.saveDocument(doc);\n        }\n        session.save();\n        return doc;\n    }\n    @Test\n    public void testGetLastMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.0\", lastVersion.getVersionLabel());\n    }\n    @Test\n    public void testGetLastMinorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"0.3\", lastVersion.getVersionLabel());\n    }\n    @Test\n    public void testGetLastMinorMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.3\", lastVersion.getVersionLabel());\n    }\n    @Test\n    public void testNonexistentLastVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithNoVersion\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithNoVersion\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        DocumentModel lastVersion = runOperation(doc);\n        assertNull(lastVersion);\n    }\n    /**\n     * Runs the operation for the different document models of the test.\n     */\n    protected DocumentModel runOperation(DocumentModel input) throws OperationException {\n        try (OperationContext ctx = new OperationContext(session)) {\n            ctx.setInput(input);\n            OperationChain chain = new OperationChain(\"testGetLastVersion\");\n            chain.add(GetLastDocumentVersion.ID);\n            return (DocumentModel) service.run(ctx, chain);\n        }\n    }\n"]]}
{"hexsha": "cd0f2db9b8d8fdb1a2153a795392c8830796df8a", "ext": "java", "lang": "Java", "content": "public class UserStory9 {\n\t\n\tprivate String taskId;\n\tprivate String title;\n\tprivate String firstUpdate;\n\tprivate String secondUpdate;\n\t\n\t@When(\"I adjust the priority of a task to a new priority\")\n\tpublic void i_adjust_the_priority_of_a_task_to_a_new_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"HIGH\";\n\t\tsecondUpdate = \"LOW\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}\n\n\t@Then(\"I can view the task and its updated priority\")\n\tpublic void i_can_view_the_task_and_its_updated_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL(request);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t        conn.setRequestMethod(\"GET\");\n\t        conn.connect();\n\t        \n\t        int code = conn.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t        \n\t        String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            \n            System.out.println(inline);\n\n            //Close the scanner\n            scanner.close();\n\t        \n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}\n\t    \n\t}\n\n\t@When(\"I adjust the priority of a task to the same priority\")\n\tpublic void i_adjust_the_priority_of_a_task_to_the_same_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"MEDIUM\";\n\t\tsecondUpdate = \"MEDIUM\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t    \n\t}\n\n\t@Then(\"I can view the task and its unchanged priority\")\n\tpublic void i_can_view_the_task_and_its_unchanged_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL(request);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t        conn.setRequestMethod(\"GET\");\n\t        conn.connect();\n\t        \n\t        int code = conn.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t        \n\t        String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            \n            System.out.println(inline);\n\n            //Close the scanner\n            scanner.close();\n\t        \n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}\n\t    \n\t}\n\n\t@When(\"I adjust the priority of a non-existent task\")\n\tpublic void i_adjust_the_priority_of_a_non_existent_task() {\n\t\t\n\t\ttaskId = \"92\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"MEDIUM\";\n\t\tsecondUpdate = \"MEDIUM\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 404);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t    \n\t}\n\n\t@Then(\"I get a Not Found error\")\n\tpublic void i_get_a_not_found_error() {\n\t\t\n\t\ttaskId = \"92\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"MEDIUM\";\n\t\tsecondUpdate = \"MEDIUM\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 404);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t    \n\t}\n\t\n\t@When(\"I adjust the priority of a {string} {string} to {string}\")\n\tpublic void i_adjust_the_priority_of_a_to(String taskId, String title, String priority) {\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + priority + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t    \n\t}\n\n\t@Then(\"I can view the {string} {string} and its updated {string}\")\n\tpublic void i_can_view_the_and_its_updated(String taskId, String title, String priority) {\n\t    \n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL(request);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t        conn.setRequestMethod(\"GET\");\n\t        conn.connect();\n\t        \n\t        int code = conn.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t        \n\t        String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            \n            System.out.println(inline);\n\n            //Close the scanner\n            scanner.close();\n\t        \n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}", "class_id": 0, "repo": "marw12/ECSE429_project_part2", "file": "src/test/java/hellocucumber/UserStory9.java", "last_update_at": "2021-04-25T15:06:15+00:00", "question_id": "cd0f2db9b8d8fdb1a2153a795392c8830796df8a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UserStory9 {\n\t\n\tprivate String taskId;\n\tprivate String title;\n\tprivate String firstUpdate;\n\tprivate String secondUpdate;\n\t\n\t@When(\"I adjust the priority of a task to a new priority\")\n\tpublic void i_adjust_the_priority_of_a_task_to_a_new_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"HIGH\";\n\t\tsecondUpdate = \"LOW\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}\n\t@Then(\"I can view the task and its updated priority\")\n\tpublic void i_can_view_the_task_and_its_updated_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL(request);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t        conn.setRequestMethod(\"GET\");\n\t        conn.connect();\n\t        \n\t        int code = conn.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t        \n\t        String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n\t        \n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}\n\t    \n\t}\n\t@When(\"I adjust the priority of a task to the same priority\")\n\tpublic void i_adjust_the_priority_of_a_task_to_the_same_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"MEDIUM\";\n\t\tsecondUpdate = \"MEDIUM\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t    \n\t}\n\t@Then(\"I can view the task and its unchanged priority\")\n\tpublic void i_can_view_the_task_and_its_unchanged_priority() {\n\t\t\n\t\ttaskId = \"1\";\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL(request);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t        conn.setRequestMethod(\"GET\");\n\t        conn.connect();\n\t        \n\t        int code = conn.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t        \n\t        String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n\t        \n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}\n\t    \n\t}\n\t@When(\"I adjust the priority of a non-existent task\")\n\tpublic void i_adjust_the_priority_of_a_non_existent_task() {\n\t\t\n\t\ttaskId = \"92\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"MEDIUM\";\n\t\tsecondUpdate = \"MEDIUM\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 404);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t    \n\t}\n\t@Then(\"I get a Not Found error\")\n\tpublic void i_get_a_not_found_error() {\n\t\t\n\t\ttaskId = \"92\";\n\t\ttitle = \"scan paperwork\";\n\t\tfirstUpdate = \"MEDIUM\";\n\t\tsecondUpdate = \"MEDIUM\";\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 404);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t    \n\t}\n\t\n\t@When(\"I adjust the priority of a {string} {string} to {string}\")\n\tpublic void i_adjust_the_priority_of_a_to(String taskId, String title, String priority) {\n\t\t\n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL (request);\n\t\t\tHttpURLConnection con = (HttpURLConnection)url.openConnection();\n\t\t\tcon.setRequestMethod(\"PUT\");\n\t\t\tcon.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n\t\t\tcon.setRequestProperty(\"Accept\", \"application/json\");\n\t\t\tcon.setDoOutput(true);\n\t\t\t\n\t\t\tString jsonInputString = \t\" {\\\"title\\\":\\\"\" +  title + \n\t\t\t\t\t\t\t\t\t\t\"\\\", \\\"description\\\":\" + priority + \"}\";\n\t\t\t\n\t\t\ttry(OutputStream os = con.getOutputStream()){\n\t\t\t\tbyte[] input = jsonInputString.getBytes(\"utf-8\");\n\t\t\t\tos.write(input, 0, input.length);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tint code = con.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t    \n\t}\n\t@Then(\"I can view the {string} {string} and its updated {string}\")\n\tpublic void i_can_view_the_and_its_updated(String taskId, String title, String priority) {\n\t    \n\t\ttry {\n\t\t\tString request = \"http://localhost:4567/todos/\" + taskId;\n\t\t\tURL url = new URL(request);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t        conn.setRequestMethod(\"GET\");\n\t        conn.connect();\n\t        \n\t        int code = conn.getResponseCode();\n\t\t\tassertEquals(code, 200);\n\t        \n\t        String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n\t        \n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}\n\t\t\n\t}\n"]]}
{"hexsha": "641033c0fb496a6d65e54ca86c4dc0ddb60735ec", "ext": "java", "lang": "Java", "content": "public class MovieListerTest {\n\n    // The use of some mechanism of dependency management enables to using\n    // mocks in unit test. In a unit test, the target type must be tested in isolation.\n    @Test\n    public void moviesDirectedByShouldReturnTheMoviesOfAGivenDirector() {\n        final MovieFinder finder = Mockito.mock(MovieFinder.class);\n        BDDMockito.given(finder.findAll()).willReturn(Collections.emptyList());\n        final MovieLister lister = new MovieLister(finder);\n        final List<Movie> movies = lister.moviesDirectedBy(\"rcardin\");\n        Assertions.assertThat(movies).isEqualTo(Collections.emptyList());\n    }\n}", "class_id": 0, "repo": "rcardin/swe", "file": "src/test/java/it/unipd/math/swe/patterns/di/MovieListerTest.java", "last_update_at": "2021-12-21T18:55:39+00:00", "question_id": "641033c0fb496a6d65e54ca86c4dc0ddb60735ec", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MovieListerTest {\n    // The use of some mechanism of dependency management enables to using\n    // mocks in unit test. In a unit test, the target type must be tested in isolation.\n    @Test\n    public void moviesDirectedByShouldReturnTheMoviesOfAGivenDirector() {\n        final MovieFinder finder = Mockito.mock(MovieFinder.class);\n        BDDMockito.given(finder.findAll()).willReturn(Collections.emptyList());\n        final MovieLister lister = new MovieLister(finder);\n        final List<Movie> movies = lister.moviesDirectedBy(\"rcardin\");\n        Assertions.assertThat(movies).isEqualTo(Collections.emptyList());\n    }\n"]]}
{"hexsha": "46ddefab41709a6be84d5741ef31973bc48ae11a", "ext": "java", "lang": "Java", "content": "public class MinimumSwaps {\n\n    // Complete the minimumSwaps function below.\n    static int minimumSwaps(int[] arr) {\n        int swaps = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            while (arr[i] != i + 1) {\n                int tmp = arr[arr[i] - 1];\n                arr[arr[i] - 1] = arr[i];\n                arr[i] = tmp;\n                swaps++;\n            }\n        }\n        return swaps;\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        int[] arr = {1, 2, 4, 3};\n        int res = minimumSwaps(arr);\n        System.out.println(\"Minimum Number of Swaps is: \" + res);\n    }\n}", "class_id": 0, "repo": "javigs82/code-training", "file": "src/main/java/me/javigs82/training/datastructure/arrays/MinimumSwaps.java", "last_update_at": "2021-12-14T09:25:35+00:00", "question_id": "46ddefab41709a6be84d5741ef31973bc48ae11a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MinimumSwaps {\n    // Complete the minimumSwaps function below.\n    static int minimumSwaps(int[] arr) {\n        int swaps = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            while (arr[i] != i + 1) {\n                int tmp = arr[arr[i] - 1];\n                arr[arr[i] - 1] = arr[i];\n                arr[i] = tmp;\n                swaps++;\n            }\n        }\n        return swaps;\n    }\n    public static void main(String[] args) throws IOException {\n        int[] arr = {1, 2, 4, 3};\n        int res = minimumSwaps(arr);\n        System.out.println(\"Minimum Number of Swaps is: \" + res);\n    }\n"]]}
{"hexsha": "221d19854b3387b4e611c94a1b3119ad951a1176", "ext": "java", "lang": "Java", "content": "public final class zzz implements ObjectEncoder<zzn> {\n    public void encode(Object obj, Object obj2) throws EncodingException, IOException {\n        zzn zzn = (zzn) obj;\n        ObjectEncoderContext objectEncoderContext = (ObjectEncoderContext) obj2;\n        if (zzn.zzb() != null) {\n            objectEncoderContext.add(\"mobileSubtype\", (Object) zzn.zzb().name());\n        }\n        if (zzn.zzc() != null) {\n            objectEncoderContext.add(\"networkType\", (Object) zzn.zzc().name());\n        }\n    }\n}", "class_id": 0, "repo": "Minionguyjpro/Ghostly-Skills", "file": "sources/com/google/android/datatransport/cct/a/zzz.java", "last_update_at": "2021-11-03T14:24:37+00:00", "question_id": "221d19854b3387b4e611c94a1b3119ad951a1176", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class zzz implements ObjectEncoder<zzn> {\n    public void encode(Object obj, Object obj2) throws EncodingException, IOException {\n        zzn zzn = (zzn) obj;\n        ObjectEncoderContext objectEncoderContext = (ObjectEncoderContext) obj2;\n        if (zzn.zzb() != null) {\n            objectEncoderContext.add(\"mobileSubtype\", (Object) zzn.zzb().name());\n        }\n        if (zzn.zzc() != null) {\n            objectEncoderContext.add(\"networkType\", (Object) zzn.zzc().name());\n        }\n    }\n"]]}
{"hexsha": "8cf6191413c62269aaba8dbcb415341dd329a51a", "ext": "java", "lang": "Java", "content": "public class UploadServlet extends HttpServlet {\n\n    private static final Logger LOG = LogManager.getLogger(UploadServlet.class);\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        List<String> images = Optional.ofNullable(new File(getServletContext().getRealPath(\"/images/\")).listFiles())\n                .map(files -> Arrays.stream(files).map(File::getName).collect(Collectors.toList()))\n                .orElse(Collections.emptyList());\n        req.setAttribute(\"images\", images);\n        RequestDispatcher dispatcher = req.getRequestDispatcher(\"/upload-file-view.jsp\");\n        dispatcher.forward(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        File repository = (File) servletContext.getAttribute(\"javax.servlet.context.tempdir\");\n        fileItemFactory.setRepository(repository);\n        ServletFileUpload upload = new ServletFileUpload(fileItemFactory);\n        try {\n            List<FileItem> items = upload.parseRequest(req);\n            File folder = new File(getServletContext().getRealPath(\"/images/\"));\n            if (!folder.exists()) {\n                folder.mkdir();\n            }\n            for (FileItem item : items) {\n                    if (!item.isFormField()) {\n                        File file = new File(folder + File.separator + item.getName());\n                    try (FileOutputStream out = new FileOutputStream(file)) {\n                        out.write(item.getInputStream().readAllBytes());\n                    }\n                }\n            }\n        } catch (FileUploadException e) {\n            LOG.error(e.getMessage(), e);\n        }\n    }\n}", "class_id": 0, "repo": "AlexandrMoralev/amoralev", "file": "chapter_008/src/main/java/ru/job4j/uploaddownloadfiles/UploadServlet.java", "last_update_at": "2021-11-03T19:51:49+00:00", "question_id": "8cf6191413c62269aaba8dbcb415341dd329a51a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UploadServlet extends HttpServlet {\n    private static final Logger LOG = LogManager.getLogger(UploadServlet.class);\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        List<String> images = Optional.ofNullable(new File(getServletContext().getRealPath(\"/images/\")).listFiles())\n                .map(files -> Arrays.stream(files).map(File::getName).collect(Collectors.toList()))\n                .orElse(Collections.emptyList());\n        req.setAttribute(\"images\", images);\n        RequestDispatcher dispatcher = req.getRequestDispatcher(\"/upload-file-view.jsp\");\n        dispatcher.forward(req, resp);\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        File repository = (File) servletContext.getAttribute(\"javax.servlet.context.tempdir\");\n        fileItemFactory.setRepository(repository);\n        ServletFileUpload upload = new ServletFileUpload(fileItemFactory);\n        try {\n            List<FileItem> items = upload.parseRequest(req);\n            File folder = new File(getServletContext().getRealPath(\"/images/\"));\n            if (!folder.exists()) {\n                folder.mkdir();\n            }\n            for (FileItem item : items) {\n                    if (!item.isFormField()) {\n                        File file = new File(folder + File.separator + item.getName());\n                    try (FileOutputStream out = new FileOutputStream(file)) {\n                        out.write(item.getInputStream().readAllBytes());\n                    }\n                }\n            }\n        } catch (FileUploadException e) {\n            LOG.error(e.getMessage(), e);\n        }\n    }\n"]]}
{"hexsha": "472700bf6fa9122b546087fd965781da595983d5", "ext": "java", "lang": "Java", "content": "@RestController\npublic class LoginController {\n\t@Autowired\n\tLoginService loginService;\n\t@Autowired\n\tStudentService studentService;\n\t@Autowired\n\tTeacherService teacherService; \n\t\n\t@GetMapping(\"/\")\n\tpublic ModelAndView Index() {\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"index\");\n\t\treturn mv;\n\t}\n\t@GetMapping(\"/createS\")\n\tpublic ModelAndView CreateS(){\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"Student_form\");\n\t\treturn mv;\n\t}\n\t@GetMapping(\"/forgot.html\")\n\tpublic ModelAndView forgot() {\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"forgot\");\n\t\treturn mv;\n\t}\n\t@PostMapping(\"/login\")\n\tpublic ModelAndView login(Login user,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\n\t\ttry {\n\t\t\t\t\n\t\t\t\tSystem.out.println(user.getEmail()+\" - \"+user.getPassword());\n\t\t\t\tif(user.getEmail().equals(\"admin@admin.com\")&&(user.getPassword().equals(\"admin\")))\n\t\t\t\t{\n\t\t\t\t\tmv.setViewName(\"admin\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\tlong id=this.loginService.findPassword(user.getEmail(), user.getPassword());\n\t\t\t\tint role=this.loginService.findRole(id);\n\t\t\t\tint otl=this.loginService.findOtl(id);\n\t\t\t\tif(role==1)\n\t\t\t\t{  \n\t\t\t\t\tString name=this.studentService.findName(id);\n\t\t\t\t\tHttpSession session=request.getSession();\n\t\t\t\t\tif(otl==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsession.setAttribute(\"id\",id);\n\t\t\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\t\t\treturn mv;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsession.setAttribute(\"name\",name);\n\t\t\t\t\t\tmv.setViewName(\"student\");\n\t\t\t\t\t\tmv.addObject(\"name\",name);\n\t\t\t\t\t}\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name=this.teacherService.findName(id);\n\t\t\t\t\tHttpSession session=request.getSession();\n\t\t\t\t\tsession.setAttribute(\"name\",name);\n\t\t\t\t\tmv.setViewName(\"teacher\");\n\t\t\t\t\tmv.addObject(\"name\",name);\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tmv.setViewName(\"index\");\n\t\t\treturn mv;\n\t\t}\n\t\t\n\t}\n\t@SuppressWarnings(\"unused\")\n\t@PostMapping(\"/forgotpassword\")\n\tpublic ModelAndView forgotPassword(@RequestParam(\"email\") String email,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\n\t\ttry {\n\t\t\tString name;\n\t\t\tSystem.out.println(email);\n\t\t\tlong id=this.loginService.findUserEmail(email);\n\t\t\tLong user_id=id;\n\t\t\tif(user_id!=null) {\n\t\t\t\tint role=this.loginService.findRole(id);\n\t\t\t\tif(role==1) {\n\t\t\t\t\tname=this.studentService.findName(id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tname=this.teacherService.findName(id);\n\t\t\t\t}\n\t\t\t    Random rnd = new Random();\n\t\t\t    int number = rnd.nextInt(999999);\n\t\t\t\tString vcode=String.format(\"%06d\", number);\n\t\t\t\tSystem.out.println(vcode);\n\t\t\t\tHttpSession session=request.getSession();\n\t\t\t\tMailSender.send(email,\"Verfication code for your password recovery\",\"Dear \"+name+\",<br>Provided below is the verification \"\n\t\t\t\t\t\t+ \"code for recovering your password.<br><h1>\"\n\t\t\t\t\t\t+ vcode\n\t\t\t\t\t\t+\"</h1><br>Enter this to set a new password.<br>Thank you.\");\n\t\t\t\tsession.setAttribute(\"id\",id);\n\t\t\t\tsession.setAttribute(\"vcode\", vcode);\n\t\t\t\tmv.setViewName(\"recover\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.setViewName(\"forgot\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tmv.setViewName(\"forgot\");\n\t\t\treturn mv;\n\t\t}\n\t}\n\t\n\t@PostMapping(\"/recoverpassword\")\n\tpublic ModelAndView recoverPassword(@RequestParam(\"code\") String code,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\n\t\ttry {\n\t\t\t\n\t\t\tSystem.out.println(\"user entered:\"+code);\n\t\t\tHttpSession session=request.getSession(false);\n\t\t\tif(session!=null) {\n\t\t\t\tString vcode=(String)session.getAttribute(\"vcode\");\n\t\t\t\tif(vcode.equals(\"\"))\n\t\t\t\t{\n\t\t\t\t\tmv.setViewName(\"forgot\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"in session:\"+vcode);\n\t\t\t\tif(code.equals(vcode))\n\t\t\t\t{\n\t\t\t\t\tsession.setAttribute(\"vcode\",\"\");\n\t\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.setViewName(\"recover\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.setViewName(\"forgot\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tmv.setViewName(\"forgot\");\n\t\t\treturn mv;\n\t\t}\n\t}\n\t\n\t@PostMapping(\"/setpassword\")\n\tpublic ModelAndView setPassword(@RequestParam(\"newpassword\") String npassword,@RequestParam(\"confirmpassword\") String cpassword,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\t\n\t\ttry{\n\t\t\t\t\n\t\t\t\tHttpSession session=request.getSession(false);\n\t\t\t\tif(npassword.equals(cpassword))\n\t\t\t\t{\n\t\t\t\t\tlong id=(long) session.getAttribute(\"id\");\n\t\t\t\t\tloginService.updatePassword(npassword,id);\n\t\t\t\t\tmv.setViewName(\"index\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t\n\t}\n}", "class_id": 0, "repo": "kevinjuthani/school-management-system", "file": "springboot/src/main/java/com/backend/schoolManagementSystem/controller/LoginController.java", "last_update_at": "2021-05-01T05:31:55+00:00", "question_id": "472700bf6fa9122b546087fd965781da595983d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\npublic class LoginController {\n\t@Autowired\n\tLoginService loginService;\n\t@Autowired\n\tStudentService studentService;\n\t@Autowired\n\tTeacherService teacherService; \n\t\n\t@GetMapping(\"/\")\n\tpublic ModelAndView Index() {\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"index\");\n\t\treturn mv;\n\t}\n\t@GetMapping(\"/createS\")\n\tpublic ModelAndView CreateS(){\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"Student_form\");\n\t\treturn mv;\n\t}\n\t@GetMapping(\"/forgot.html\")\n\tpublic ModelAndView forgot() {\n\t\tModelAndView mv = new ModelAndView();\n\t\tmv.setViewName(\"forgot\");\n\t\treturn mv;\n\t}\n\t@PostMapping(\"/login\")\n\tpublic ModelAndView login(Login user,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\n\t\ttry {\n\t\t\t\t\n\t\t\t\tSystem.out.println(user.getEmail()+\" - \"+user.getPassword());\n\t\t\t\tif(user.getEmail().equals(\"admin@admin.com\")&&(user.getPassword().equals(\"admin\")))\n\t\t\t\t{\n\t\t\t\t\tmv.setViewName(\"admin\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\tlong id=this.loginService.findPassword(user.getEmail(), user.getPassword());\n\t\t\t\tint role=this.loginService.findRole(id);\n\t\t\t\tint otl=this.loginService.findOtl(id);\n\t\t\t\tif(role==1)\n\t\t\t\t{  \n\t\t\t\t\tString name=this.studentService.findName(id);\n\t\t\t\t\tHttpSession session=request.getSession();\n\t\t\t\t\tif(otl==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsession.setAttribute(\"id\",id);\n\t\t\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\t\t\treturn mv;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsession.setAttribute(\"name\",name);\n\t\t\t\t\t\tmv.setViewName(\"student\");\n\t\t\t\t\t\tmv.addObject(\"name\",name);\n\t\t\t\t\t}\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name=this.teacherService.findName(id);\n\t\t\t\t\tHttpSession session=request.getSession();\n\t\t\t\t\tsession.setAttribute(\"name\",name);\n\t\t\t\t\tmv.setViewName(\"teacher\");\n\t\t\t\t\tmv.addObject(\"name\",name);\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tmv.setViewName(\"index\");\n\t\t\treturn mv;\n\t\t}\n\t\t\n\t}\n\t@SuppressWarnings(\"unused\")\n\t@PostMapping(\"/forgotpassword\")\n\tpublic ModelAndView forgotPassword(@RequestParam(\"email\") String email,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\n\t\ttry {\n\t\t\tString name;\n\t\t\tSystem.out.println(email);\n\t\t\tlong id=this.loginService.findUserEmail(email);\n\t\t\tLong user_id=id;\n\t\t\tif(user_id!=null) {\n\t\t\t\tint role=this.loginService.findRole(id);\n\t\t\t\tif(role==1) {\n\t\t\t\t\tname=this.studentService.findName(id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tname=this.teacherService.findName(id);\n\t\t\t\t}\n\t\t\t    Random rnd = new Random();\n\t\t\t    int number = rnd.nextInt(999999);\n\t\t\t\tString vcode=String.format(\"%06d\", number);\n\t\t\t\tSystem.out.println(vcode);\n\t\t\t\tHttpSession session=request.getSession();\n\t\t\t\tMailSender.send(email,\"Verfication code for your password recovery\",\"Dear \"+name+\",<br>Provided below is the verification \"\n\t\t\t\t\t\t+ \"code for recovering your password.<br><h1>\"\n\t\t\t\t\t\t+ vcode\n\t\t\t\t\t\t+\"</h1><br>Enter this to set a new password.<br>Thank you.\");\n\t\t\t\tsession.setAttribute(\"id\",id);\n\t\t\t\tsession.setAttribute(\"vcode\", vcode);\n\t\t\t\tmv.setViewName(\"recover\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.setViewName(\"forgot\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tmv.setViewName(\"forgot\");\n\t\t\treturn mv;\n\t\t}\n\t}\n\t\n\t@PostMapping(\"/recoverpassword\")\n\tpublic ModelAndView recoverPassword(@RequestParam(\"code\") String code,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\n\t\ttry {\n\t\t\t\n\t\t\tSystem.out.println(\"user entered:\"+code);\n\t\t\tHttpSession session=request.getSession(false);\n\t\t\tif(session!=null) {\n\t\t\t\tString vcode=(String)session.getAttribute(\"vcode\");\n\t\t\t\tif(vcode.equals(\"\"))\n\t\t\t\t{\n\t\t\t\t\tmv.setViewName(\"forgot\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"in session:\"+vcode);\n\t\t\t\tif(code.equals(vcode))\n\t\t\t\t{\n\t\t\t\t\tsession.setAttribute(\"vcode\",\"\");\n\t\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.setViewName(\"recover\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.setViewName(\"forgot\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tmv.setViewName(\"forgot\");\n\t\t\treturn mv;\n\t\t}\n\t}\n\t\n\t@PostMapping(\"/setpassword\")\n\tpublic ModelAndView setPassword(@RequestParam(\"newpassword\") String npassword,@RequestParam(\"confirmpassword\") String cpassword,HttpServletRequest request) {\n\t\tModelAndView mv = new ModelAndView();\t\n\t\ttry{\n\t\t\t\t\n\t\t\t\tHttpSession session=request.getSession(false);\n\t\t\t\tif(npassword.equals(cpassword))\n\t\t\t\t{\n\t\t\t\t\tlong id=(long) session.getAttribute(\"id\");\n\t\t\t\t\tloginService.updatePassword(npassword,id);\n\t\t\t\t\tmv.setViewName(\"index\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\t\treturn mv;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tmv.setViewName(\"NewPassword\");\n\t\t\t\treturn mv;\n\t\t\t}\n\t\t\n\t}\n"]]}
{"hexsha": "f4faaf5638a49c5121563ade6dd4b7fbef7d664d", "ext": "java", "lang": "Java", "content": "public class BungeeModule extends AbstractModule {\n\n    @Override\n    public void configure() {\n        bindFactory(CommandSender.class, new CommandSenderPartFactory());\n        bindFactory(ProxiedPlayer.class, new ProxiedPlayerPartFactory());\n        bindFactory(new Key(ProxiedPlayer.class, Sender.class), new ProxiedPlayerSenderPartFactory());\n    }\n}", "class_id": 0, "repo": "GatitoUwU/CommandFlow", "file": "Bungee/src/main/java/me/fixeddev/commandflow/bungee/factory/BungeeModule.java", "last_update_at": "2021-12-08T01:40:28+00:00", "question_id": "f4faaf5638a49c5121563ade6dd4b7fbef7d664d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BungeeModule extends AbstractModule {\n    @Override\n    public void configure() {\n        bindFactory(CommandSender.class, new CommandSenderPartFactory());\n        bindFactory(ProxiedPlayer.class, new ProxiedPlayerPartFactory());\n        bindFactory(new Key(ProxiedPlayer.class, Sender.class), new ProxiedPlayerSenderPartFactory());\n    }\n"]]}
{"hexsha": "9e4f9fdccbf6abd563c47d91d05b945d05d65846", "ext": "java", "lang": "Java", "content": "class Solution {\n    public int fib(int n) {\n        int i=0,j=1;\n        int ans=1;\n        if(n<=1) return n;\n        for(int p=2;p<=n;p++)\n        {\n            ans=i+j;\n            i=j;j=ans;\n        }\n        return ans;\n        \n    }\n    \n}", "class_id": 0, "repo": "itsbittoosharma/DSA-JAVA-Problem-Solutions", "file": "509-fibonacci-number/509-fibonacci-number.java", "last_update_at": "2021-09-26T13:04:08+00:00", "question_id": "9e4f9fdccbf6abd563c47d91d05b945d05d65846", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution {\n    public int fib(int n) {\n        int i=0,j=1;\n        int ans=1;\n        if(n<=1) return n;\n        for(int p=2;p<=n;p++)\n        {\n            ans=i+j;\n            i=j;j=ans;\n        }\n        return ans;\n    }\n"]]}
{"hexsha": "2a215fa39841dd8a27838db5d29d1d3464dfd9fe", "ext": "java", "lang": "Java", "content": "@Component\n@CommandImpl(\"mset\")\n@ParamLength(type = AT_LEAST, value = 2)\npublic class MSet {\n    private final KevaDatabase database;\n\n    @Autowired\n    public MSet(KevaDatabase database) {\n        this.database = database;\n    }\n\n    @Execute\n    public StatusReply execute(byte[]... keys) {\n        if (keys.length % 2 != 0) {\n            throw new CommandException(\"Wrong number of arguments for MSET\");\n        }\n        database.mset(keys);\n        return StatusReply.OK;\n    }\n}", "class_id": 0, "repo": "hiepndd/keva", "file": "core/src/main/java/dev/keva/core/command/impl/string/MSet.java", "last_update_at": "2021-09-20T10:20:46+00:00", "question_id": "2a215fa39841dd8a27838db5d29d1d3464dfd9fe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@CommandImpl(\"mset\")\n@ParamLength(type = AT_LEAST, value = 2)\npublic class MSet {\n    private final KevaDatabase database;\n    @Autowired\n    public MSet(KevaDatabase database) {\n        this.database = database;\n    }\n    @Execute\n    public StatusReply execute(byte[]... keys) {\n        if (keys.length % 2 != 0) {\n            throw new CommandException(\"Wrong number of arguments for MSET\");\n        }\n        database.mset(keys);\n        return StatusReply.OK;\n    }\n"]]}
{"hexsha": "bacc5b1878a17e567c59933789e2258b27f89430", "ext": "java", "lang": "Java", "content": "public class PublicKeyEncryptor extends AbstractEncryptor<Cipher, PublicKey, byte[]>\n\timplements\n\t\tByteArrayEncryptor\n{\n\n\t/** The Constant serialVersionUID. */\n\tprivate static final long serialVersionUID = 1L;\n\tprivate CryptModel<Cipher, SecretKey, String> symmetricKeyModel;\n\n\t/**\n\t * Instantiates a new {@link PublicKeyEncryptor} with the given {@link CryptModel} for the\n\t * public key and the given {@link CryptModel} for the symmetric key\n\t *\n\t * @param model\n\t *            The crypt model\n\t * @param symmetricKeyModel\n\t *            The symmetric key model\n\t *\n\t * @throws InvalidAlgorithmParameterException\n\t *             is thrown if initialization of the cipher object fails.\n\t * @throws NoSuchPaddingException\n\t *             is thrown if instantiation of the SecretKeyFactory object fails.\n\t * @throws InvalidKeySpecException\n\t *             is thrown if generation of the SecretKey object fails.\n\t * @throws NoSuchAlgorithmException\n\t *             is thrown if instantiation of the SecretKeyFactory object fails.\n\t * @throws InvalidKeyException\n\t *             is thrown if initialization of the cipher object fails.\n\t * @throws NoSuchAlgorithmException\n\t *             is thrown if instantiation of the SecretKeyFactory object fails.\n\t * @throws UnsupportedEncodingException\n\t *             is thrown if the named charset is not supported.\n\t */\n\tpublic PublicKeyEncryptor(final CryptModel<Cipher, PublicKey, byte[]> model,\n\t\tfinal CryptModel<Cipher, SecretKey, String> symmetricKeyModel)\n\t\tthrows InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException,\n\t\tNoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException\n\t{\n\t\tsuper(model);\n\t\tObjects.requireNonNull(symmetricKeyModel);\n\t\tthis.symmetricKeyModel = symmetricKeyModel;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic byte[] encrypt(final byte[] toEncrypt) throws Exception\n\t{\n\t\tfinal SecretKey symmetricKey = symmetricKeyModel.getKey();\n\t\tCipher symmetricKeyCipher = newSymmetricCipher(symmetricKey,\n\t\t\tsymmetricKeyModel.getAlgorithm().getAlgorithm(), symmetricKeyModel.getOperationMode());\n\t\tbyte[] symmetricKeyEncryptedBytes = symmetricKeyCipher.doFinal(toEncrypt);\n\t\tbyte[] encryptedKey = getModel().getCipher().doFinal(symmetricKey.getEncoded());\n\t\tAesRsaCryptModel cryptData = AesRsaCryptModel.builder().encryptedKey(encryptedKey)\n\t\t\t.symmetricKeyEncryptedObject(symmetricKeyEncryptedBytes).build();\n\t\tbyte[] encryptedCryptData = SerializationUtils.serialize(cryptData);\n\t\treturn encryptedCryptData;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected String newAlgorithm()\n\t{\n\t\tif (getModel().getAlgorithm() == null)\n\t\t{\n\t\t\tgetModel().setAlgorithm(\n\t\t\t\tKeyPairWithModeAndPaddingAlgorithm.RSA_ECB_OAEPWithSHA1AndMGF1Padding);\n\t\t}\n\t\treturn getModel().getAlgorithm().getAlgorithm();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Cipher newCipher(final PublicKey key, final String algorithm, final byte[] salt,\n\t\tfinal int iterationCount, final int operationMode)\n\t\tthrows NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException,\n\t\tInvalidKeyException, InvalidAlgorithmParameterException, UnsupportedEncodingException\n\t{\n\t\tfinal Cipher cipher = CipherFactory.newCipher(algorithm);\n\t\tcipher.init(Cipher.PUBLIC_KEY, key);\n\t\treturn cipher;\n\t}\n\n\tprivate Cipher newSymmetricCipher(final SecretKey key, final String algorithm,\n\t\tfinal int operationMode)\n\t\tthrows NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException\n\t{\n\t\tfinal Cipher cipher = Cipher.getInstance(algorithm);\n\t\tcipher.init(operationMode, key);\n\t\treturn cipher;\n\t}\n\n}", "class_id": 0, "repo": "astrapi69/mystic-crypt", "file": "src/main/java/io/github/astrapi69/crypto/key/PublicKeyEncryptor.java", "last_update_at": "2021-12-14T15:29:07+00:00", "question_id": "bacc5b1878a17e567c59933789e2258b27f89430", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PublicKeyEncryptor extends AbstractEncryptor<Cipher, PublicKey, byte[]>\n\timplements\n\t\tByteArrayEncryptor\n{\n\t/** The Constant serialVersionUID. */\n\tprivate static final long serialVersionUID = 1L;\n\tprivate CryptModel<Cipher, SecretKey, String> symmetricKeyModel;\n\t/**\n\t * Instantiates a new {@link PublicKeyEncryptor} with the given {@link CryptModel} for the\n\t * public key and the given {@link CryptModel} for the symmetric key\n\t *\n\t * @param model\n\t *            The crypt model\n\t * @param symmetricKeyModel\n\t *            The symmetric key model\n\t *\n\t * @throws InvalidAlgorithmParameterException\n\t *             is thrown if initialization of the cipher object fails.\n\t * @throws NoSuchPaddingException\n\t *             is thrown if instantiation of the SecretKeyFactory object fails.\n\t * @throws InvalidKeySpecException\n\t *             is thrown if generation of the SecretKey object fails.\n\t * @throws NoSuchAlgorithmException\n\t *             is thrown if instantiation of the SecretKeyFactory object fails.\n\t * @throws InvalidKeyException\n\t *             is thrown if initialization of the cipher object fails.\n\t * @throws NoSuchAlgorithmException\n\t *             is thrown if instantiation of the SecretKeyFactory object fails.\n\t * @throws UnsupportedEncodingException\n\t *             is thrown if the named charset is not supported.\n\t */\n\tpublic PublicKeyEncryptor(final CryptModel<Cipher, PublicKey, byte[]> model,\n\t\tfinal CryptModel<Cipher, SecretKey, String> symmetricKeyModel)\n\t\tthrows InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException,\n\t\tNoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException\n\t{\n\t\tsuper(model);\n\t\tObjects.requireNonNull(symmetricKeyModel);\n\t\tthis.symmetricKeyModel = symmetricKeyModel;\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic byte[] encrypt(final byte[] toEncrypt) throws Exception\n\t{\n\t\tfinal SecretKey symmetricKey = symmetricKeyModel.getKey();\n\t\tCipher symmetricKeyCipher = newSymmetricCipher(symmetricKey,\n\t\t\tsymmetricKeyModel.getAlgorithm().getAlgorithm(), symmetricKeyModel.getOperationMode());\n\t\tbyte[] symmetricKeyEncryptedBytes = symmetricKeyCipher.doFinal(toEncrypt);\n\t\tbyte[] encryptedKey = getModel().getCipher().doFinal(symmetricKey.getEncoded());\n\t\tAesRsaCryptModel cryptData = AesRsaCryptModel.builder().encryptedKey(encryptedKey)\n\t\t\t.symmetricKeyEncryptedObject(symmetricKeyEncryptedBytes).build();\n\t\tbyte[] encryptedCryptData = SerializationUtils.serialize(cryptData);\n\t\treturn encryptedCryptData;\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected String newAlgorithm()\n\t{\n\t\tif (getModel().getAlgorithm() == null)\n\t\t{\n\t\t\tgetModel().setAlgorithm(\n\t\t\t\tKeyPairWithModeAndPaddingAlgorithm.RSA_ECB_OAEPWithSHA1AndMGF1Padding);\n\t\t}\n\t\treturn getModel().getAlgorithm().getAlgorithm();\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Cipher newCipher(final PublicKey key, final String algorithm, final byte[] salt,\n\t\tfinal int iterationCount, final int operationMode)\n\t\tthrows NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException,\n\t\tInvalidKeyException, InvalidAlgorithmParameterException, UnsupportedEncodingException\n\t{\n\t\tfinal Cipher cipher = CipherFactory.newCipher(algorithm);\n\t\tcipher.init(Cipher.PUBLIC_KEY, key);\n\t\treturn cipher;\n\t}\n\tprivate Cipher newSymmetricCipher(final SecretKey key, final String algorithm,\n\t\tfinal int operationMode)\n\t\tthrows NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException\n\t{\n\t\tfinal Cipher cipher = Cipher.getInstance(algorithm);\n\t\tcipher.init(operationMode, key);\n\t\treturn cipher;\n\t}\n"]]}
{"hexsha": "830dd582a871908ba6897692f86bcd2509046763", "ext": "java", "lang": "Java", "content": "public class ParentEntry extends ModListEntry {\n\tprivate static final String PARENT_MOD_TEXTURE = \"/assets/\" + ModMenu.MOD_ID + \"/textures/gui/parent_mod.png\";\n\tprotected List<ModContainer> children;\n\tprotected ModListWidget list;\n\tprotected boolean hoveringIcon = false;\n\n\tpublic ParentEntry(Minecraft mc, ModContainer parent, List<ModContainer> children, ModListWidget list) {\n\t\tsuper(mc, parent, list);\n\t\tthis.children = children;\n\t\tthis.list = list;\n\t}\n\n\t@Override\n\tpublic void render(int index, int y, int x, int rowWidth, int rowHeight, int mouseX, int mouseY, boolean isSelected, float delta) {\n\t\tsuper.render(index, y, x, rowWidth, rowHeight, mouseX, mouseY, isSelected, delta);\n\t\tTextRenderer font = client.textRenderer;\n\t\tint childrenBadgeHeight = 9;\n\t\tint childrenBadgeWidth = 9;\n\t\tint children = ModListSearch.search(list.getParent(), list.getParent().getSearchInput(), getChildren()).size();\n\t\tint childrenWidth = font.getTextWidth(Integer.toString(children)) - 1;\n\t\tif (childrenBadgeWidth < childrenWidth + 4) {\n\t\t\tchildrenBadgeWidth = childrenWidth + 4;\n\t\t}\n\t\tint childrenBadgeX = x + 32 - childrenBadgeWidth;\n\t\tint childrenBadgeY = y + 32 - childrenBadgeHeight;\n\t\tint childrenOutlineColor = 0x8810d098;\n\t\tint childrenFillColor = 0x88046146;\n\t\tfill(childrenBadgeX + 1, childrenBadgeY, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenOutlineColor);\n\t\tfill(childrenBadgeX, childrenBadgeY + 1, childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n\t\tfill(childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n\t\tfill(childrenBadgeX + 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight - 1, childrenFillColor);\n\t\tfill(childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight, childrenOutlineColor);\n\t\tfont.drawText(Integer.toString(children), childrenBadgeX + childrenBadgeWidth / 2 - childrenWidth / 2, childrenBadgeY + 1, 0xCACACA);\n\t\tthis.hoveringIcon = mouseX >= x - 1 && mouseX <= x - 1 + 32 && mouseY >= y - 1 && mouseY <= y - 1 + 32;\n\t\tif (isMouseOver(mouseX, mouseY)) {\n\t\t\tfill(x, y, x + 32, y + 32, 0xA0909090);\n\t\t\tthis.client.textureManager.bindTexture(this.client.textureManager.getTextureId(PARENT_MOD_TEXTURE));\n\t\t\tint xOffset = list.getParent().showModChildren.contains(getMetadata().getId()) ? 32 : 0;\n\t\t\tint yOffset = hoveringIcon ? 32 : 0;\n\t\t\tGL11.glColor4f(1f, 1f, 1f, 1f);\n\t\t\tTessellator tess = Tessellator.INSTANCE;\n\t\t\ttess.start();\n\t\t\ttess.vertex(x, y, 0, xOffset / 256f, yOffset / 256f);\n\t\t\ttess.vertex(x, y + 32, 0, xOffset / 256f, (yOffset + 32) / 256f);\n\t\t\ttess.vertex(x + 32, y + 32, 0, (xOffset + 32) / 256f, (yOffset + 32) / 256f);\n\t\t\ttess.vertex(x + 32, y, 0, (xOffset + 32) / 256f, yOffset / 256f);\n\t\t\ttess.draw();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean mouseClicked(double mouseX, double mouseY, int i) {\n\t\tif (hoveringIcon) {\n\t\t\tString id = getMetadata().getId();\n\t\t\tif (list.getParent().showModChildren.contains(id)) {\n\t\t\t\tlist.getParent().showModChildren.remove(id);\n\t\t\t} else {\n\t\t\t\tlist.getParent().showModChildren.add(id);\n\t\t\t}\n\t\t\tlist.filter(list.getParent().getSearchInput(), false);\n\t\t}\n\t\treturn super.mouseClicked(mouseX, mouseY, i);\n\t}\n\n\t@Override\n\tpublic boolean keyPressed(int int_1, int int_2, int int_3) {\n\t\tif (int_1 == Keyboard.KEY_RETURN) {\n\t\t\tString id = getMetadata().getId();\n\t\t\tif (list.getParent().showModChildren.contains(id)) {\n\t\t\t\tlist.getParent().showModChildren.remove(id);\n\t\t\t} else {\n\t\t\t\tlist.getParent().showModChildren.add(id);\n\t\t\t}\n\t\t\tlist.filter(list.getParent().getSearchInput(), false);\n\t\t\treturn true;\n\t\t}\n\t\treturn super.keyPressed(int_1, int_2, int_3);\n\t}\n\n\tpublic void setChildren(List<ModContainer> children) {\n\t\tthis.children = children;\n\t}\n\n\tpublic void addChildren(List<ModContainer> children) {\n\t\tthis.children.addAll(children);\n\t}\n\n\tpublic void addChildren(ModContainer... children) {\n\t\tthis.children.addAll(Arrays.asList(children));\n\t}\n\n\tpublic List<ModContainer> getChildren() {\n\t\treturn children;\n\t}\n\n\tpublic boolean isMouseOver(double double_1, double double_2) {\n\t\treturn Objects.equals(this.list.getEntryAtPos(double_1, double_2), this);\n\t}\n}", "class_id": 0, "repo": "ChessChicken-KZ/API", "file": "essentials/modmenu/src/main/java/com/terraformersmc/modmenu/gui/entries/ParentEntry.java", "last_update_at": "2021-11-06T06:33:39+00:00", "question_id": "830dd582a871908ba6897692f86bcd2509046763", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ParentEntry extends ModListEntry {\n\tprivate static final String PARENT_MOD_TEXTURE = \"/assets/\" + ModMenu.MOD_ID + \"/textures/gui/parent_mod.png\";\n\tprotected List<ModContainer> children;\n\tprotected ModListWidget list;\n\tprotected boolean hoveringIcon = false;\n\tpublic ParentEntry(Minecraft mc, ModContainer parent, List<ModContainer> children, ModListWidget list) {\n\t\tsuper(mc, parent, list);\n\t\tthis.children = children;\n\t\tthis.list = list;\n\t}\n\t@Override\n\tpublic void render(int index, int y, int x, int rowWidth, int rowHeight, int mouseX, int mouseY, boolean isSelected, float delta) {\n\t\tsuper.render(index, y, x, rowWidth, rowHeight, mouseX, mouseY, isSelected, delta);\n\t\tTextRenderer font = client.textRenderer;\n\t\tint childrenBadgeHeight = 9;\n\t\tint childrenBadgeWidth = 9;\n\t\tint children = ModListSearch.search(list.getParent(), list.getParent().getSearchInput(), getChildren()).size();\n\t\tint childrenWidth = font.getTextWidth(Integer.toString(children)) - 1;\n\t\tif (childrenBadgeWidth < childrenWidth + 4) {\n\t\t\tchildrenBadgeWidth = childrenWidth + 4;\n\t\t}\n\t\tint childrenBadgeX = x + 32 - childrenBadgeWidth;\n\t\tint childrenBadgeY = y + 32 - childrenBadgeHeight;\n\t\tint childrenOutlineColor = 0x8810d098;\n\t\tint childrenFillColor = 0x88046146;\n\t\tfill(childrenBadgeX + 1, childrenBadgeY, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenOutlineColor);\n\t\tfill(childrenBadgeX, childrenBadgeY + 1, childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n\t\tfill(childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n\t\tfill(childrenBadgeX + 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight - 1, childrenFillColor);\n\t\tfill(childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight, childrenOutlineColor);\n\t\tfont.drawText(Integer.toString(children), childrenBadgeX + childrenBadgeWidth / 2 - childrenWidth / 2, childrenBadgeY + 1, 0xCACACA);\n\t\tthis.hoveringIcon = mouseX >= x - 1 && mouseX <= x - 1 + 32 && mouseY >= y - 1 && mouseY <= y - 1 + 32;\n\t\tif (isMouseOver(mouseX, mouseY)) {\n\t\t\tfill(x, y, x + 32, y + 32, 0xA0909090);\n\t\t\tthis.client.textureManager.bindTexture(this.client.textureManager.getTextureId(PARENT_MOD_TEXTURE));\n\t\t\tint xOffset = list.getParent().showModChildren.contains(getMetadata().getId()) ? 32 : 0;\n\t\t\tint yOffset = hoveringIcon ? 32 : 0;\n\t\t\tGL11.glColor4f(1f, 1f, 1f, 1f);\n\t\t\tTessellator tess = Tessellator.INSTANCE;\n\t\t\ttess.start();\n\t\t\ttess.vertex(x, y, 0, xOffset / 256f, yOffset / 256f);\n\t\t\ttess.vertex(x, y + 32, 0, xOffset / 256f, (yOffset + 32) / 256f);\n\t\t\ttess.vertex(x + 32, y + 32, 0, (xOffset + 32) / 256f, (yOffset + 32) / 256f);\n\t\t\ttess.vertex(x + 32, y, 0, (xOffset + 32) / 256f, yOffset / 256f);\n\t\t\ttess.draw();\n\t\t}\n\t}\n\t@Override\n\tpublic boolean mouseClicked(double mouseX, double mouseY, int i) {\n\t\tif (hoveringIcon) {\n\t\t\tString id = getMetadata().getId();\n\t\t\tif (list.getParent().showModChildren.contains(id)) {\n\t\t\t\tlist.getParent().showModChildren.remove(id);\n\t\t\t} else {\n\t\t\t\tlist.getParent().showModChildren.add(id);\n\t\t\t}\n\t\t\tlist.filter(list.getParent().getSearchInput(), false);\n\t\t}\n\t\treturn super.mouseClicked(mouseX, mouseY, i);\n\t}\n\t@Override\n\tpublic boolean keyPressed(int int_1, int int_2, int int_3) {\n\t\tif (int_1 == Keyboard.KEY_RETURN) {\n\t\t\tString id = getMetadata().getId();\n\t\t\tif (list.getParent().showModChildren.contains(id)) {\n\t\t\t\tlist.getParent().showModChildren.remove(id);\n\t\t\t} else {\n\t\t\t\tlist.getParent().showModChildren.add(id);\n\t\t\t}\n\t\t\tlist.filter(list.getParent().getSearchInput(), false);\n\t\t\treturn true;\n\t\t}\n\t\treturn super.keyPressed(int_1, int_2, int_3);\n\t}\n\tpublic void setChildren(List<ModContainer> children) {\n\t\tthis.children = children;\n\t}\n\tpublic void addChildren(List<ModContainer> children) {\n\t\tthis.children.addAll(children);\n\t}\n\tpublic void addChildren(ModContainer... children) {\n\t\tthis.children.addAll(Arrays.asList(children));\n\t}\n\tpublic List<ModContainer> getChildren() {\n\t\treturn children;\n\t}\n\tpublic boolean isMouseOver(double double_1, double double_2) {\n\t\treturn Objects.equals(this.list.getEntryAtPos(double_1, double_2), this);\n\t}\n"]]}
{"hexsha": "b64d18704447220e35b2d2254fdb3118096bcb32", "ext": "java", "lang": "Java", "content": "@Dependent\npublic class DefaultPaletteFactory<H extends AbstractCanvasHandler>\n        implements PaletteFactory<DefaultPaletteWidget, H> {\n\n    private final DefinitionUtils definitionUtils;\n    private final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders;\n    private final ManagedInstance<DefaultPaletteWidget> palettes;\n    private final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent;\n    private final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent;\n    private final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent;\n\n    @Inject\n    public DefaultPaletteFactory(final DefinitionUtils definitionUtils,\n                                 final @Any ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders,\n                                 final @Any ManagedInstance<DefaultPaletteWidget> palettes,\n                                 final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent,\n                                 final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent,\n                                 final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent) {\n        this.definitionUtils = definitionUtils;\n        this.paletteDefinitionBuilders = paletteDefinitionBuilders;\n        this.palettes = palettes;\n        this.buildCanvasShapeEvent = buildCanvasShapeEvent;\n        this.canvasShapeDragStartEvent = canvasShapeDragStartEvent;\n        this.canvasShapeDragUpdateEvent = canvasShapeDragUpdateEvent;\n    }\n\n    @Override\n    public DefaultPaletteWidget newPalette(final H canvasHandler) {\n        final DefaultPaletteWidget palette = getPaletteWidget(canvasHandler);\n        getPaletteDefinitionBuilder(canvasHandler)\n                .build(canvasHandler,\n                       palette::bind);\n        return palette;\n    }\n\n    @PreDestroy\n    public void destroy() {\n        paletteDefinitionBuilders.destroyAll();\n        palettes.destroyAll();\n    }\n\n    private PaletteDefinitionBuilder<H, DefaultPaletteDefinition> getPaletteDefinitionBuilder(final H canvasHandler) {\n        final String definitionSetId = canvasHandler.getDiagram().getMetadata().getDefinitionSetId();\n        final Annotation qualifier = definitionUtils.getQualifier(definitionSetId);\n        final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> custom =\n                paletteDefinitionBuilders.select(qualifier);\n        if (custom.isUnsatisfied()) {\n            return paletteDefinitionBuilders.select(DefinitionManager.DEFAULT_QUALIFIER).get();\n        }\n        return custom.get();\n    }\n\n    private DefaultPaletteWidget getPaletteWidget(final H canvasHandler) {\n        final DefaultPaletteWidget palette = palettes.get();\n        palette.onItemDrop(event -> buildCanvasShapeEvent.fire(new BuildCanvasShapeEvent(canvasHandler,\n                                                                                         event.getDefinition(),\n                                                                                         event.getFactory(),\n                                                                                         event.getX(),\n                                                                                         event.getY())));\n        palette.onItemDragStart(event -> canvasShapeDragStartEvent.fire(new CanvasShapeDragStartEvent(canvasHandler,\n                                                                                                      event.getDefinition(),\n                                                                                                      event.getFactory(),\n                                                                                                      event.getX(),\n                                                                                                      event.getY())));\n        palette.onItemDragUpdate(event -> canvasShapeDragUpdateEvent.fire(new CanvasShapeDragUpdateEvent(canvasHandler,\n                                                                                                         event.getDefinition(),\n                                                                                                         event.getFactory(),\n                                                                                                         event.getX(),\n                                                                                                         event.getY())));\n        return palette;\n    }\n}", "class_id": 0, "repo": "caponetto/kogito-editors-java", "file": "kie-wb-common-stunner/kie-wb-common-stunner-client/kie-wb-common-stunner-widgets/src/main/java/org/kie/workbench/common/stunner/client/widgets/palette/DefaultPaletteFactory.java", "last_update_at": "2021-07-03T13:15:03+00:00", "question_id": "b64d18704447220e35b2d2254fdb3118096bcb32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Dependent\npublic class DefaultPaletteFactory<H extends AbstractCanvasHandler>\n        implements PaletteFactory<DefaultPaletteWidget, H> {\n    private final DefinitionUtils definitionUtils;\n    private final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders;\n    private final ManagedInstance<DefaultPaletteWidget> palettes;\n    private final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent;\n    private final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent;\n    private final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent;\n    @Inject\n    public DefaultPaletteFactory(final DefinitionUtils definitionUtils,\n                                 final @Any ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders,\n                                 final @Any ManagedInstance<DefaultPaletteWidget> palettes,\n                                 final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent,\n                                 final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent,\n                                 final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent) {\n        this.definitionUtils = definitionUtils;\n        this.paletteDefinitionBuilders = paletteDefinitionBuilders;\n        this.palettes = palettes;\n        this.buildCanvasShapeEvent = buildCanvasShapeEvent;\n        this.canvasShapeDragStartEvent = canvasShapeDragStartEvent;\n        this.canvasShapeDragUpdateEvent = canvasShapeDragUpdateEvent;\n    }\n    @Override\n    public DefaultPaletteWidget newPalette(final H canvasHandler) {\n        final DefaultPaletteWidget palette = getPaletteWidget(canvasHandler);\n        getPaletteDefinitionBuilder(canvasHandler)\n                .build(canvasHandler,\n                       palette::bind);\n        return palette;\n    }\n    @PreDestroy\n    public void destroy() {\n        paletteDefinitionBuilders.destroyAll();\n        palettes.destroyAll();\n    }\n    private PaletteDefinitionBuilder<H, DefaultPaletteDefinition> getPaletteDefinitionBuilder(final H canvasHandler) {\n        final String definitionSetId = canvasHandler.getDiagram().getMetadata().getDefinitionSetId();\n        final Annotation qualifier = definitionUtils.getQualifier(definitionSetId);\n        final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> custom =\n                paletteDefinitionBuilders.select(qualifier);\n        if (custom.isUnsatisfied()) {\n            return paletteDefinitionBuilders.select(DefinitionManager.DEFAULT_QUALIFIER).get();\n        }\n        return custom.get();\n    }\n    private DefaultPaletteWidget getPaletteWidget(final H canvasHandler) {\n        final DefaultPaletteWidget palette = palettes.get();\n        palette.onItemDrop(event -> buildCanvasShapeEvent.fire(new BuildCanvasShapeEvent(canvasHandler,\n                                                                                         event.getDefinition(),\n                                                                                         event.getFactory(),\n                                                                                         event.getX(),\n                                                                                         event.getY())));\n        palette.onItemDragStart(event -> canvasShapeDragStartEvent.fire(new CanvasShapeDragStartEvent(canvasHandler,\n                                                                                                      event.getDefinition(),\n                                                                                                      event.getFactory(),\n                                                                                                      event.getX(),\n                                                                                                      event.getY())));\n        palette.onItemDragUpdate(event -> canvasShapeDragUpdateEvent.fire(new CanvasShapeDragUpdateEvent(canvasHandler,\n                                                                                                         event.getDefinition(),\n                                                                                                         event.getFactory(),\n                                                                                                         event.getX(),\n                                                                                                         event.getY())));\n        return palette;\n    }\n"]]}
{"hexsha": "977a9650b30ee1056d3003eb9836578725120840", "ext": "java", "lang": "Java", "content": "@EActivity(R.layout.activity_main)\npublic class PDFViewActivity extends AppCompatActivity implements OnPageChangeListener {\n\n    public static final String SAMPLE_FILE = \"sample.pdf\";\n\n    @ViewById\n    PDFView pdfView;\n\n    @ViewById\n    ScrollBar scrollBar;\n\n    @NonConfigurationInstance\n    String pdfName = SAMPLE_FILE;\n\n    @NonConfigurationInstance\n    Integer pageNumber = 1;\n\n    @AfterViews\n    void afterViews() {\n        pdfView.setScrollBar(scrollBar);\n        display(pdfName, false);\n    }\n\n    private void display(String assetFileName, boolean jumpToFirstPage) {\n        if (jumpToFirstPage) pageNumber = 1;\n        setTitle(pdfName = assetFileName);\n\n        pdfView.fromAsset(assetFileName)\n                .defaultPage(pageNumber)\n                .onPageChange(this)\n                .swipeVertical(true)\n                .showMinimap(false)\n                .load();\n    }\n\n    @Override\n    public void onPageChanged(int page, int pageCount) {\n        pageNumber = page;\n        setTitle(format(\"%s %s / %s\", pdfName, page, pageCount));\n    }\n\n}", "class_id": 0, "repo": "romeoh/AndroidPdfViewer", "file": "sample/src/main/java/com/github/barteksc/sample/PDFViewActivity.java", "last_update_at": "2021-07-13T07:28:38+00:00", "question_id": "977a9650b30ee1056d3003eb9836578725120840", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@EActivity(R.layout.activity_main)\npublic class PDFViewActivity extends AppCompatActivity implements OnPageChangeListener {\n    public static final String SAMPLE_FILE = \"sample.pdf\";\n    @ViewById\n    PDFView pdfView;\n    @ViewById\n    ScrollBar scrollBar;\n    @NonConfigurationInstance\n    String pdfName = SAMPLE_FILE;\n    @NonConfigurationInstance\n    Integer pageNumber = 1;\n    @AfterViews\n    void afterViews() {\n        pdfView.setScrollBar(scrollBar);\n        display(pdfName, false);\n    }\n    private void display(String assetFileName, boolean jumpToFirstPage) {\n        if (jumpToFirstPage) pageNumber = 1;\n        setTitle(pdfName = assetFileName);\n        pdfView.fromAsset(assetFileName)\n                .defaultPage(pageNumber)\n                .onPageChange(this)\n                .swipeVertical(true)\n                .showMinimap(false)\n                .load();\n    }\n    @Override\n    public void onPageChanged(int page, int pageCount) {\n        pageNumber = page;\n        setTitle(format(\"%s %s / %s\", pdfName, page, pageCount));\n    }\n"]]}
{"hexsha": "3abd49fe01a13f09b3da2e4f76316ccef4ce8fa9", "ext": "java", "lang": "Java", "content": "@Validated\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController extends BaseController {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private AddressService addressService;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @PostMapping(\"/insertDemoData\")\n    public void insertDemoData(String name) {\n        Address address = new Address();\n        address.setCountry(\"CN\");\n        address.setProvince(\"SHAANXI\");\n        address.setCity(\"XI'AN\");\n        address.setHouseNumber(12);\n\n        address = addressService.save(address);\n        User user = new User();\n        user.setName(\"Lisa\");\n        user.setAge(12);\n        user.setRole(Role.USER);\n        user.setAddressId(address.getId());\n        userService.saveAndFlush(user);\n    }\n\n    @PostMapping(\"/insert\")\n    public void insert(@Valid User user, @Valid Address address) {\n        Address address1 = addressService.save(address);\n        user.setAddressId(address1.getId());\n        User user1 = userService.saveAndFlush(user);\n    }\n\n    @PostMapping(\"/update/{id}\")\n    public void update(@PathVariable(\"id\") Long id) {\n        User user = new User();\n        user.setId(id);\n        user.setName(\"Tom\");\n        userService.update(id, user);\n    }\n\n    @GetMapping(\"/all\")\n    public List<User> findAll() {\n        return userService.findAll();\n    }\n\n    @GetMapping(\"/page\")\n    public Pager<User> findPage(Pager<User> pager) {\n        final Page<User> page = userService.findAll(PagerConverter.toPageable(pager));\n        return PagerConverter.toPager(page);\n    }\n\n    @GetMapping(\"/dsl\")\n    public List<User> findAllByQueryDsl(User user) {\n        return userService.findAllByQueryDsl(user);\n    }\n\n    @GetMapping(\"/nativeSql\")\n    public List<Object> findStudentAddress(String userName, String city) {\n        return userService.findStudentAddress(userName, city);\n    }\n\n    @GetMapping(\"/school\")\n    public List<UserRepository.UserSchoolDTO> findUserSchoolDTO() {\n        return userRepository.findUserSchoolDTO();\n    }\n}", "class_id": 0, "repo": "mengweijin/quickboot", "file": "sample-quickboot-jpa-web/src/main/java/com/github/mengweijin/quickboot/sample/system/controller/UserController.java", "last_update_at": "2021-02-04T02:41:01+00:00", "question_id": "3abd49fe01a13f09b3da2e4f76316ccef4ce8fa9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Validated\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController extends BaseController {\n    @Autowired\n    private UserService userService;\n    @Autowired\n    private AddressService addressService;\n    @Autowired\n    private UserRepository userRepository;\n    @PostMapping(\"/insertDemoData\")\n    public void insertDemoData(String name) {\n        Address address = new Address();\n        address.setCountry(\"CN\");\n        address.setProvince(\"SHAANXI\");\n        address.setCity(\"XI'AN\");\n        address.setHouseNumber(12);\n        address = addressService.save(address);\n        User user = new User();\n        user.setName(\"Lisa\");\n        user.setAge(12);\n        user.setRole(Role.USER);\n        user.setAddressId(address.getId());\n        userService.saveAndFlush(user);\n    }\n    @PostMapping(\"/insert\")\n    public void insert(@Valid User user, @Valid Address address) {\n        Address address1 = addressService.save(address);\n        user.setAddressId(address1.getId());\n        User user1 = userService.saveAndFlush(user);\n    }\n    @PostMapping(\"/update/{id}\")\n    public void update(@PathVariable(\"id\") Long id) {\n        User user = new User();\n        user.setId(id);\n        user.setName(\"Tom\");\n        userService.update(id, user);\n    }\n    @GetMapping(\"/all\")\n    public List<User> findAll() {\n        return userService.findAll();\n    }\n    @GetMapping(\"/page\")\n    public Pager<User> findPage(Pager<User> pager) {\n        final Page<User> page = userService.findAll(PagerConverter.toPageable(pager));\n        return PagerConverter.toPager(page);\n    }\n    @GetMapping(\"/dsl\")\n    public List<User> findAllByQueryDsl(User user) {\n        return userService.findAllByQueryDsl(user);\n    }\n    @GetMapping(\"/nativeSql\")\n    public List<Object> findStudentAddress(String userName, String city) {\n        return userService.findStudentAddress(userName, city);\n    }\n    @GetMapping(\"/school\")\n    public List<UserRepository.UserSchoolDTO> findUserSchoolDTO() {\n        return userRepository.findUserSchoolDTO();\n    }\n"]]}
{"hexsha": "51c610d263d838050ce965c17b85338e36da3e55", "ext": "java", "lang": "Java", "content": "public class MongoLockService implements LockService {\n\n    public static final String MIGRAMONGO_LOCK_COLLECTION = \"_migramongo_lock\";\n    private final MongoDatabase database;\n\n    public MongoLockService(MongoDatabase database) {\n        this.database = database;\n        initLockCollection();\n    }\n\n    private void initLockCollection() {\n        //if the table already exists, we do not need to create it anymore\n        if (getLockCollection().countDocuments() > 0) {\n            return;\n        }\n        // assuring that the index exists\n        getLockCollection().createIndex(new BasicDBObject(LockEntryDocBuilder.LOCK_ENTRY, 1));\n        // creating the first entry - as \"lockEntry\" is unique, it will fail if\n        // one already exists, but it's ok\n        final Document basicLockEntry = new LockEntryDocBuilder().build();\n        getLockCollection().insertOne(basicLockEntry);\n    }\n\n    private MongoCollection<Document> getLockCollection() {\n        return this.database.getCollection(MIGRAMONGO_LOCK_COLLECTION);\n    }\n\n    @Override\n    public boolean acquireLock() {\n        if (getLockCollection().countDocuments() == 0) {\n            throw new IllegalStateException(\n                \"Cannot acquire lock because lock table has not been initialized. Initialize MongoLockService properly, or call destroyLock\");\n        }\n        final Document lockDocument = new LockEntryDocBuilder().lock().build();\n        final Document result = getLockCollection()\n            .findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document(\"$set\", lockDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, true) == false;\n    }\n\n    @Override\n    public boolean releaseLock() {\n        final Document releaseDocument = new LockEntryDocBuilder().release().build();\n        final Document result = getLockCollection().findOneAndUpdate(\n            new Document(LockEntryDocBuilder.LOCK_ENTRY, true),\n            new Document(\"$set\", releaseDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, false) == true;\n    }\n\n    static class LockEntryDocBuilder {\n\n        static String LOCK_ENTRY = \"lockEntry\";\n        static String LOCKED = \"locked\";\n        static String LAST_LOCK_DATE = \"lastLockDate\";\n        static String LAST_RELEASE_DATE = \"lastReleaseDate\";\n        private Document doc;\n\n        LockEntryDocBuilder() {\n            doc = new Document();\n            doc.put(LOCK_ENTRY, true);\n            doc.put(LOCKED, false);\n        }\n\n        LockEntryDocBuilder lock() {\n            doc.put(LOCKED, true);\n            doc.put(LAST_LOCK_DATE, new Date());\n            return this;\n        }\n\n        LockEntryDocBuilder release() {\n            doc.put(LOCKED, false);\n            doc.put(LAST_RELEASE_DATE, new Date());\n            return this;\n        }\n\n        Document build() {\n            return doc;\n        }\n\n    }\n\n    @Override\n    public LockEntry getLockInformation() {\n        final Document lockDocument = getLockCollection()\n            .find(new Document(LockEntryDocBuilder.LOCK_ENTRY, true))\n            .first();\n        return new LockEntry(\n            lockDocument.getBoolean(LockEntryDocBuilder.LOCKED),\n            lockDocument.getDate(LockEntryDocBuilder.LAST_LOCK_DATE),\n            lockDocument.getDate(LockEntryDocBuilder.LAST_RELEASE_DATE));\n    }\n\n    @Override\n    public void destroyLock() {\n        getLockCollection().deleteMany(new Document(LockEntryDocBuilder.LOCK_ENTRY, true));\n        initLockCollection();\n    }\n}", "class_id": 0, "repo": "pablotp/migramongo", "file": "migramongo-core/src/main/java/com/rinoto/migramongo/dao/MongoLockService.java", "last_update_at": "2021-06-28T08:50:12+00:00", "question_id": "51c610d263d838050ce965c17b85338e36da3e55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MongoLockService implements LockService {\n    public static final String MIGRAMONGO_LOCK_COLLECTION = \"_migramongo_lock\";\n    private final MongoDatabase database;\n    public MongoLockService(MongoDatabase database) {\n        this.database = database;\n        initLockCollection();\n    }\n    private void initLockCollection() {\n        //if the table already exists, we do not need to create it anymore\n        if (getLockCollection().countDocuments() > 0) {\n            return;\n        }\n        // assuring that the index exists\n        getLockCollection().createIndex(new BasicDBObject(LockEntryDocBuilder.LOCK_ENTRY, 1));\n        // creating the first entry - as \"lockEntry\" is unique, it will fail if\n        // one already exists, but it's ok\n        final Document basicLockEntry = new LockEntryDocBuilder().build();\n        getLockCollection().insertOne(basicLockEntry);\n    }\n    private MongoCollection<Document> getLockCollection() {\n        return this.database.getCollection(MIGRAMONGO_LOCK_COLLECTION);\n    }\n    @Override\n    public boolean acquireLock() {\n        if (getLockCollection().countDocuments() == 0) {\n            throw new IllegalStateException(\n                \"Cannot acquire lock because lock table has not been initialized. Initialize MongoLockService properly, or call destroyLock\");\n        }\n        final Document lockDocument = new LockEntryDocBuilder().lock().build();\n        final Document result = getLockCollection()\n            .findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document(\"$set\", lockDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, true) == false;\n    }\n    @Override\n    public boolean releaseLock() {\n        final Document releaseDocument = new LockEntryDocBuilder().release().build();\n        final Document result = getLockCollection().findOneAndUpdate(\n            new Document(LockEntryDocBuilder.LOCK_ENTRY, true),\n            new Document(\"$set\", releaseDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, false) == true;\n    }\n    static class LockEntryDocBuilder {\n        static String LOCK_ENTRY = \"lockEntry\";\n        static String LOCKED = \"locked\";\n        static String LAST_LOCK_DATE = \"lastLockDate\";\n        static String LAST_RELEASE_DATE = \"lastReleaseDate\";\n        private Document doc;\n        LockEntryDocBuilder() {\n            doc = new Document();\n            doc.put(LOCK_ENTRY, true);\n            doc.put(LOCKED, false);\n        }\n        LockEntryDocBuilder lock() {\n            doc.put(LOCKED, true);\n            doc.put(LAST_LOCK_DATE, new Date());\n            return this;\n        }\n        LockEntryDocBuilder release() {\n            doc.put(LOCKED, false);\n            doc.put(LAST_RELEASE_DATE, new Date());\n            return this;\n        }\n        Document build() {\n            return doc;\n        }\n    }\n    @Override\n    public LockEntry getLockInformation() {\n        final Document lockDocument = getLockCollection()\n            .find(new Document(LockEntryDocBuilder.LOCK_ENTRY, true))\n            .first();\n        return new LockEntry(\n            lockDocument.getBoolean(LockEntryDocBuilder.LOCKED),\n            lockDocument.getDate(LockEntryDocBuilder.LAST_LOCK_DATE),\n            lockDocument.getDate(LockEntryDocBuilder.LAST_RELEASE_DATE));\n    }\n    @Override\n    public void destroyLock() {\n        getLockCollection().deleteMany(new Document(LockEntryDocBuilder.LOCK_ENTRY, true));\n        initLockCollection();\n    }\n"]]}
{"hexsha": "fd5d92b41d2bda214eab3d1eddcc520c7b44e553", "ext": "java", "lang": "Java", "content": "public class UrlPart {\r\n\r\n\tprivate final Object url;\r\n\tprivate final boolean isRegex;\r\n\t\r\n\tpublic UrlPart(String url, boolean isRegex) {\r\n\t\tthis.url = url;\r\n\t\tthis.isRegex = isRegex;\r\n\t}\r\n\t\r\n\tpublic UrlPart(HttpMethod method) {\r\n\t\tthis.url = method;\r\n\t\tthis.isRegex = false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + (isRegex ? 1231 : 1237);\r\n\t\tresult = prime * result + ((url == null) ? 0 : url.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj) {\r\n\t\t\treturn true;\r\n\t\t}\t\t\t\r\n\t\tif (obj == null) {\r\n\t\t\treturn false;\r\n\t\t}\t\t\t\r\n\t\tif (getClass() != obj.getClass()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tUrlPart other = (UrlPart) obj;\r\n\t\tif (url == null && other.url != null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (isRegex) {\r\n\t\t\t/*Matcher m = Pattern.compile(String.format(\"(%s)\", url)).matcher(url);\t\r\n\t\t\treturn m.find();*/\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn url.equals(other.url);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t//\treturn \"UrlPart [url=\" + url + \", isRegex=\" + isRegex + \"]\";\r\n\t\treturn url.toString();\r\n\t}\r\n}", "class_id": 0, "repo": "ondrej-nemec/MVC", "file": "src/main/java/toti/url/UrlPart.java", "last_update_at": "2021-04-22T08:45:01+00:00", "question_id": "fd5d92b41d2bda214eab3d1eddcc520c7b44e553", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UrlPart {\r\n\r\n\tprivate final Object url;\r\n\tprivate final boolean isRegex;\r\n\t\r\n\tpublic UrlPart(String url, boolean isRegex) {\r\n\t\tthis.url = url;\r\n\t\tthis.isRegex = isRegex;\r\n\t}\r\n\t\r\n\tpublic UrlPart(HttpMethod method) {\r\n\t\tthis.url = method;\r\n\t\tthis.isRegex = false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tfinal int prime = 31;\r\n\t\tint result = 1;\r\n\t\tresult = prime * result + (isRegex ? 1231 : 1237);\r\n\t\tresult = prime * result + ((url == null) ? 0 : url.hashCode());\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (this == obj) {\r\n\t\t\treturn true;\r\n\t\t}\t\t\t\r\n\t\tif (obj == null) {\r\n\t\t\treturn false;\r\n\t\t}\t\t\t\r\n\t\tif (getClass() != obj.getClass()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tUrlPart other = (UrlPart) obj;\r\n\t\tif (url == null && other.url != null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (isRegex) {\r\n\t\t\t/*Matcher m = Pattern.compile(String.format(\"(%s)\", url)).matcher(url);\t\r\n\t\t\treturn m.find();*/\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn url.equals(other.url);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t//\treturn \"UrlPart [url=\" + url + \", isRegex=\" + isRegex + \"]\";\r\n\t\treturn url.toString();\r\n\t}\r\n"]]}
{"hexsha": "c85862bd68af35280ddc23c32cb83bc91c2feb4e", "ext": "java", "lang": "Java", "content": "public class PreconditionsTest {\n    @Test\n    public void test() {\n        int i = new Random().nextInt();\n        int j = new Random().nextInt();\n        checkArgument(i >= 0, \"Argument was %s but expected nonnegative\", i);\n        checkArgument(i < j, \"Expected i < j, but %s > %s\", i, j);\n    }\n}", "class_id": 0, "repo": "itning/BigData", "file": "Guava/src/main/java/top/itning/bigdata/guava/precondition/PreconditionsTest.java", "last_update_at": "2021-12-05T02:12:25+00:00", "question_id": "c85862bd68af35280ddc23c32cb83bc91c2feb4e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PreconditionsTest {\n    @Test\n    public void test() {\n        int i = new Random().nextInt();\n        int j = new Random().nextInt();\n        checkArgument(i >= 0, \"Argument was %s but expected nonnegative\", i);\n        checkArgument(i < j, \"Expected i < j, but %s > %s\", i, j);\n    }\n"]]}
{"hexsha": "1aa4b7d2a9d3993327fbc3ab5af3a225a40834a6", "ext": "java", "lang": "Java", "content": "public class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Examples e = new Examples();\n        //System.out.println(e.search(\"600000 4920000\", 10000.0d));\n        //System.out.println(e.prekryv(\"600000 4920000\", 10000.0d));\n        //System.out.println(e.bbox(\"M\"));\n        //System.out.println(e.wfs(\"sf_restricted\"));\n        //System.out.println(e.testREST_PUT_Local());\n        //System.out.println(e.overlayWMS(\"600000 4920000\", 5000.0d));\n        //System.out.println(e.postGIS_example1());\n        //System.out.println(e.postGIS_example2(\"600000 4920000\", 5000.0d));\n        //System.out.println(e.networking(\"Ostrava\", \"Fulnek\"));\n        //System.out.println(e.overlayCollectionOutput(\"600000 4920000\", 5000.0d));\n    }\n    \n}", "class_id": 0, "repo": "ruz76/wps", "file": "GTSearch/src/cz/vsb/gis/ruz76/gt/Main.java", "last_update_at": "2021-05-22T04:40:34+00:00", "question_id": "1aa4b7d2a9d3993327fbc3ab5af3a225a40834a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Main {\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Examples e = new Examples();\n        //System.out.println(e.search(\"600000 4920000\", 10000.0d));\n        //System.out.println(e.prekryv(\"600000 4920000\", 10000.0d));\n        //System.out.println(e.bbox(\"M\"));\n        //System.out.println(e.wfs(\"sf_restricted\"));\n        //System.out.println(e.testREST_PUT_Local());\n        //System.out.println(e.overlayWMS(\"600000 4920000\", 5000.0d));\n        //System.out.println(e.postGIS_example1());\n        //System.out.println(e.postGIS_example2(\"600000 4920000\", 5000.0d));\n        //System.out.println(e.networking(\"Ostrava\", \"Fulnek\"));\n        //System.out.println(e.overlayCollectionOutput(\"600000 4920000\", 5000.0d));\n    }\n"]]}
{"hexsha": "e2b1d74db8b5405d1f9d96ba519d9b6d9d3cd3ab", "ext": "java", "lang": "Java", "content": "public abstract class Node implements UniversalCodeVisitable {\n    /**\n     * The parent node.\n     */\n    private Node parent;\n\n    /**\n     * The parser token image backing this node.\n     */\n    private TokenImage tokenImage;\n\n//    protected Class<?> typeDescriptor;\n\n    private Type type;\n\n\n    /**\n     * Constructs a new AST node instance, with no initial configuration.\n     */\n    public Node() {\n    }\n\n    /**\n     * Constructs a new AST node instance.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public Node(TokenImage tokenImage) {\n        this(tokenImage, (Class<?>)null);\n    }\n\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Class<?> typeDescriptor) {\n        this(null, tokenImage, typeDescriptor);\n    }\n\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param type  the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Type type) {\n        this(null, tokenImage, type);\n    }\n\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Class<?> typeDescriptor) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n//        this.typeDescriptor = typeDescriptor;\n        this.type = typeDescriptor == null ? null : new ResolvedTypeReferenceOld(tokenImage, typeDescriptor);\n    }\n\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param type the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Type type) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n//        this.typeDescriptor = null;\n        this.type = type;\n    }\n\n    public Node accept(UniversalCodeVisitor visitor) {\n        return this;\n    }\n\n    public Node accept(AstVisitor visitor) {\n        return this;\n    }\n\n    /**\n     * Gets the parent node.\n     *\n     * @return the parent node, which may be null if this node does not have a parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     */\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     * @return this instance for builder chaining.\n     */\n    public Node withParent(Node parent) {\n        setParent(parent);\n        return this;\n    }\n\n    /**\n     * Gets the parser token image backing this node.\n     *\n     * @return the parser token image backing this node.\n     */\n    public TokenImage getTokenImage() {\n        return tokenImage;\n    }\n\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public void setTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n    }\n\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @return this instance for builder chaining.\n     */\n    public Node withTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n        return this;\n    }\n\n    public Class<?> getTypeDescriptor() {\n//        return typeDescriptor;\n        return getType() == null ? null : getType().getTypeClass();\n    }\n\n    /**\n     * Returns the established static type of the node.\n     *\n     * @return the node's type, or null if the type cannot be determined at this time.\n     */\n    public Type getType() {\n        return type;\n    }\n\n    public void setType(final TypeReference type) {\n        this.type = type;\n    }\n\n//    public void setTypeDescriptor(Class<?> typeDescriptor) {\n//        this.typeDescriptor = typeDescriptor;\n//    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (!(o instanceof Node))\n            return false;\n        Node node = (Node) o;\n        return Objects.equals(parent, node.parent)\n               && Objects.equals(tokenImage, node.tokenImage)\n               && Objects.equals(type, node.type);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(parent, tokenImage, type);\n    }\n}", "class_id": 0, "repo": "lamerexter/universel", "file": "src/main/java/org/orthodox/universel/ast/Node.java", "last_update_at": "2021-04-17T13:17:11+00:00", "question_id": "e2b1d74db8b5405d1f9d96ba519d9b6d9d3cd3ab", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class Node implements UniversalCodeVisitable {\n    /**\n     * The parent node.\n     */\n    private Node parent;\n    /**\n     * The parser token image backing this node.\n     */\n    private TokenImage tokenImage;\n//    protected Class<?> typeDescriptor;\n    private Type type;\n    /**\n     * Constructs a new AST node instance, with no initial configuration.\n     */\n    public Node() {\n    }\n    /**\n     * Constructs a new AST node instance.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public Node(TokenImage tokenImage) {\n        this(tokenImage, (Class<?>)null);\n    }\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Class<?> typeDescriptor) {\n        this(null, tokenImage, typeDescriptor);\n    }\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param type  the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Type type) {\n        this(null, tokenImage, type);\n    }\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Class<?> typeDescriptor) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n//        this.typeDescriptor = typeDescriptor;\n        this.type = typeDescriptor == null ? null : new ResolvedTypeReferenceOld(tokenImage, typeDescriptor);\n    }\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param type the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Type type) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n//        this.typeDescriptor = null;\n        this.type = type;\n    }\n    public Node accept(UniversalCodeVisitor visitor) {\n        return this;\n    }\n    public Node accept(AstVisitor visitor) {\n        return this;\n    }\n    /**\n     * Gets the parent node.\n     *\n     * @return the parent node, which may be null if this node does not have a parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     */\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     * @return this instance for builder chaining.\n     */\n    public Node withParent(Node parent) {\n        setParent(parent);\n        return this;\n    }\n    /**\n     * Gets the parser token image backing this node.\n     *\n     * @return the parser token image backing this node.\n     */\n    public TokenImage getTokenImage() {\n        return tokenImage;\n    }\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public void setTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n    }\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @return this instance for builder chaining.\n     */\n    public Node withTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n        return this;\n    }\n    public Class<?> getTypeDescriptor() {\n//        return typeDescriptor;\n        return getType() == null ? null : getType().getTypeClass();\n    }\n    /**\n     * Returns the established static type of the node.\n     *\n     * @return the node's type, or null if the type cannot be determined at this time.\n     */\n    public Type getType() {\n        return type;\n    }\n    public void setType(final TypeReference type) {\n        this.type = type;\n    }\n//    public void setTypeDescriptor(Class<?> typeDescriptor) {\n//        this.typeDescriptor = typeDescriptor;\n//    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (!(o instanceof Node))\n            return false;\n        Node node = (Node) o;\n        return Objects.equals(parent, node.parent)\n               && Objects.equals(tokenImage, node.tokenImage)\n               && Objects.equals(type, node.type);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(parent, tokenImage, type);\n    }\n"]]}
{"hexsha": "1fedf96a0bc0d600ebdfb70a4efcf6a14a3fed03", "ext": "java", "lang": "Java", "content": "public class VoteCounter {\n\t//Parameter: The number of candidates that can win\n\tstatic int numberOfWinners;\n\t//The percentage of votes that is needed to guarantee a win for a candidate\n\tstatic double voteThresholdPercent;\n\t//A counter for the total number of candidates\n\tstatic int numberOfCandidates = 0;\n\t//the total number of votes being counted\n\tstatic int numberOfVotes = 0;\n\t//the number of votes needed to guarantee a win\n\tstatic double voteThreshold = 0.0;\n\t//A list of the candidates which have won\n\tstatic ArrayList<String> winningCandidates = new ArrayList<>();\n\t//A list of the candidates which have been eliminated\n\tstatic ArrayList<String> eliminatedCandidates = new ArrayList<>();\n\t//A list of the original, unaltered Votes. Needed for the tie breaker\n\tstatic ArrayList<Vote> originalVotes = new ArrayList<Vote>();\n\t//A list of the votes that are redistributed\n\tstatic ArrayList<Vote> votes = new ArrayList<Vote>();\n\t//A list of the working vote counts\n\tstatic HashMap<String, Double> currentVoteCounts = new HashMap<>();\n\tstatic int roundCounter = 1;\n\t\n\t/**\n\t * The main method. See class docs for description on required arguments\n\t * \n\t * @param args - String[]\n\t */\n\tpublic static void main(String[] args) {\n\t\t//If there was 1 argument, check if it was help and print how to if it was\n\t\tif(args.length == 1 && args[0].equals(\"help\")) {\n\t\t\t//TODO provide how to output\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//Quit if the three arguments were not supplied\n\t\tif(args.length != 3) {\n\t\t\tSystem.out.println(\"Please provide all 3 arguments. Run 'VoteCounter help' for more information.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//Parse the input files\n\t\tif(!parseCandidates(args[0])) {\n\t\t\t//If parseCandidates returns false, then it failed to work correctly and the program should terminate\n\t\t\treturn;\n\t\t}\n\t\tif(!parseVotes(args[1])) {\n\t\t\t//if parseVotes returns false, then it failed to work correctly and the program should terminate\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//Try to get the number of voters\n\t\ttry {\n\t\t\tnumberOfWinners = Integer.parseInt(args[2]);\n\t\t\t\n\t\t\tif(numberOfWinners < 1 || numberOfWinners > currentVoteCounts.keySet().size()) {\n\t\t\t\tSystem.out.println(\"The number of winners must be at least 1 and no more than the number of candidates\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t//Not a valid number, so print error to the user and return\n\t\t\tSystem.out.println(\"Invalid winner count argument. \");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//calculate the vote thresholds\n\t\tvoteThresholdPercent = 1.0/(numberOfWinners+1);\n\t\tvoteThreshold = numberOfVotes*voteThresholdPercent;\n\t\t\n\t\t//perform the initial count of the votes\n\t\tcountVotes();\n\t\t\n\t\t//Analyze the votes, redistributing as needed, until enough winners have been found\n\t\tdo {\n\t\t\tanalyzeVotes();\n\t\t} while(winningCandidates.size() < numberOfWinners);\n\t\t\n\t\t//Print the final winners\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Winners:\");\n\t\tSystem.out.println(String.join(\", \", winningCandidates));\n\t}\n\t\n\t/**\n\t * Parse the candidate file and initialize {@code numberOfCandidates} and {@code currentVoteCounts}\n\t * \n\t * @param candidateFileName - String - the name of the candidate file\n\t * @return boolean - true if successful, false if not successful\n\t */\n\tprivate static boolean parseCandidates(String candidateFileName) {\n\t\tBufferedReader candidateReader = null;\n\t\t\n\t\ttry {\n\t\t\t//try to open the file for reading\n\t\t\tcandidateReader = new BufferedReader(new FileReader(candidateFileName));\n\t\t\tString candidate = null;\n\t\t\t\n\t\t\t//Loop through each line and store the candidate and increase the candidate count\n\t\t\twhile((candidate=candidateReader.readLine()) != null) {\n\t\t\t\tcurrentVoteCounts.put(candidate.trim(), 0.0);\n\t\t\t\tnumberOfCandidates += 1;\n\t\t\t}\n\t\t} catch(FileNotFoundException e) {\n\t\t\t//The file was not found, so print the error message and quit\n\t\t\tSystem.out.println(\"Unable to open the candidate file. Please ensure the provided file path is correct.\");\n\t\t\treturn false;\n\t\t} catch(IOException e) {\n\t\t\t//Something went wrong reading the file, so print the error message and quit\n\t\t\tSystem.out.println(\"An error occured while reading the candidate file:\" + e.getMessage());\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t//Close the candidateReader after everything, if it exists\n\t\t\tif(candidateReader != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcandidateReader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tSystem.out.println(\"An error occured while closing the candidate file:\\n\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Parse the vote file and construct all {@link Vote} objects\n\t * \n\t * @param voteFileName - String - The file name of the vote file\n\t * @return boolean - true if successful, false if not successful\n\t */\n\tprivate static boolean parseVotes(String voteFileName) {\n\t\tBufferedReader voteReader = null;\n\t\t\n\t\ttry {\n\t\t\t//attempt to open the vote file\n\t\t\tvoteReader = new BufferedReader(new FileReader(voteFileName));\n\t\t\tString line = null;\n\t\t\tvoteReader.readLine();\n\t\t\t\n\t\t\t//parse the line of the csv file and use it to create a Vote object\n\t\t\twhile((line = voteReader.readLine()) != null) {\n\t\t\t\tString[] inputRow = line.split(\",\");\n\t\t\t\t\n\t\t\t\t//store the vote as needed and count the total number of votes\n\t\t\t\tvotes.add(new Vote(inputRow));\n\t\t\t\toriginalVotes.add(new Vote(inputRow));\n\t\t\t\tnumberOfVotes++;\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t//File was not found, so return\n\t\t\tSystem.out.println(\"Unable to open the vote file. Please ensure the provided file path is correct.\");\n\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\t//Failure to read file correctly, so return\n\t\t\tSystem.out.println(\"An error occured while reading the vote file:\" + e.getMessage());\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t//Close the buffered reader when finished\n\t\t\tif (voteReader != null) {\n\t\t\t\ttry {\n\t\t\t\t\tvoteReader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tSystem.out.println(\"An error occured while closing the vote file:\\n\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Analyzes the current vote counts, determining a winner or loser for the round, and the redistributes votes as needed\n\t */\n\tprivate static void analyzeVotes() {\n\t\t//Print the start of round text and current vote counts\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Round \" + roundCounter++ + \" vote counts:\");\n\t\tfor(Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n\t\t\tSystem.out.print(entry.getKey() + \": \" + entry.getValue() + \" | \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\t//If the number of candidates left equals the number of winners, mark them all winners and end\n\t\tif(currentVoteCounts.size() == numberOfWinners) {\n\t\t\tfor(Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n\t\t\t\tif(!winningCandidates.contains(entry.getKey())) {\n\t\t\t\t\twinningCandidates.add(entry.getKey());\n\t\t\t\t\tSystem.out.println(entry.getKey() + \" has won in the last round.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean noWinnerFound = true;\n\t\t\n\t\t//create an arrayList that holds the factions with the least number of votes and track the current minimum vote total\n\t\tArrayList<String> minCandidatess = new ArrayList<>();\n\t\tdouble minCount = Double.MAX_VALUE;\n\t\t\n\t\t//The entry key is the candidate name and entry value is the vote count\n\t\tfor(Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n\t\t\t//If the candidate has already won, do not count their votes\n\t\t\tif(!winningCandidates.contains(entry.getKey())) {\n\t\t\t\t//Check if the vote count for this candidate has exceeded the winning threshold\n\t\t\t\tif(entry.getValue().compareTo(voteThreshold) > 0) {\n\t\t\t\t\t//Mark that a winner was found\n\t\t\t\t\tnoWinnerFound = false;\n\t\t\t\t\t\n\t\t\t\t\t//subtract the threshold from the number of votes over\n\t\t\t\t\t//Then divide that by the total number of votes. This results in a percentage which acts as\n\t\t\t\t\t//a weight for all votes from this winner as they are redistributed. \n\t\t\t\t\tdouble redistributeAmount = Double.sum(entry.getValue(), voteThreshold*-1.0)/numberOfVotes;\n\t\t\t\t\t\n\t\t\t\t\t//redistribute the votes of the winner using the calculated redistribution amount\n\t\t\t\t\tredistributeVotes(entry.getKey(), redistributeAmount);\n\t\t\t\t\t\n\t\t\t\t\t//Add the winner to the list of winners and print that they have won\n\t\t\t\t\twinningCandidates.add(entry.getKey());\n\t\t\t\t\tSystem.out.println(entry.getKey() + \" has won with \" + entry.getValue() + \" votes.\");\n\t\t\t\t\t\n\t\t\t\t\t//Exit the loop\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(entry.getValue().compareTo(minCount) < 0) {\n\t\t\t\t//If this candidate has a lower vote count than the current lowest\n\t\t\t\t//Store this count as the new minimum\n\t\t\t\tminCount = entry.getValue();\n\t\t\t\t//remove all current candidates from the minimum count list\n\t\t\t\tminCandidatess.clear();\n\t\t\t\t//and add this candidate to the list\n\t\t\t\tminCandidatess.add(entry.getKey());\n\t\t\t} else if(entry.getValue().compareTo(minCount) == 0) {\n\t\t\t\tminCandidatess.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Since no one won, a loser must be eliminated\n\t\tif(noWinnerFound) {\n\t\t\t//If only one candidate has the lowest vote count, eliminate them\n\t\t\t//If 2 or more are tied for the lowest, run a tie breaker and eliminate the loser\n\t\t\tif(minCandidatess.size() == 1) {\n\t\t\t\teliminateCandidate(minCandidatess.get(0));\n\t\t\t} else {\n\t\t\t\teliminateCandidate(condorcetTieBreak(minCandidatess));\n\t\t\t}\n\t\t} \n\t}\n\t\n\t/**\n\t * Perform a condorcet tie break for all factions in the factions list\n\t * @param candidates - {@code ArrayList<String>} - The list of candidates to check in the tie breaker\n\t * \n\t * @return - String - the name of the candidate that lost the tie breaker\n\t */\n\tprivate static String condorcetTieBreak(ArrayList<String> candidates) {\n\t\t//Output that a tie braker is occuring between the candidates\n\t\tSystem.out.println(\"Breaking last place tie between: \" + String.join(\", \", candidates));\n\t\t\n\t\t//create the master matrix that counts the number of times one candidate beats another candidate\n\t\tint[][] masterMatrix = new int[candidates.size()][candidates.size()];\n\t\t\n\t\t//generate a matrix for each vote and add it to the master\n\t\tfor(Vote vote : originalVotes) {\n\t\t\tmasterMatrix = matrixAddition(masterMatrix, vote.generateMatrix(candidates));\n\t\t}\n\t\t\n\t\t// Create a win matrix which marks if one candidate beats another candidate more in the master matrix\n\t\tint[][] winMatrix = new int[candidates.size()][candidates.size()];\n\t\t// Create a matrix that stores the magnitude of victories in the win matrix\n\t\tint[][] magnitudeMatrix = new int[candidates.size()][candidates.size()];\n\t\t\n\t\t//loop through the master matrix\n\t\tfor(int x=0; x<masterMatrix.length; x++) {\n\t\t\tfor(int y=0; y<masterMatrix[0].length; y++) {\n\t\t\t\t// Only 1 half of the matrix is cared about, so skip it if x < y\n\t\t\t\tif(y>x) {\n\t\t\t\t\tif(masterMatrix[x][y] > masterMatrix[y][x]) {\n\t\t\t\t\t\t//If x beat y more than y beat x, mark that x beats y overall in the win matrix\n\t\t\t\t\t\twinMatrix[x][y] = 1;\n\t\t\t\t\t\t//calculate difference of counts in the master and store it as the magnitude\n\t\t\t\t\t\t//The winner will have a positive value while the lose will have a negative value\n\t\t\t\t\t\tmagnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n\t\t\t\t\t\tmagnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n\t\t\t\t\t} else if (masterMatrix[x][y] < masterMatrix[y][x]) {\n\t\t\t\t\t\t//The same thing as above but if Y won\n\t\t\t\t\t\twinMatrix[y][x] = 1;\n\t\t\t\t\t\tmagnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n\t\t\t\t\t\tmagnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Create a variable to store the currently lowest win count\n\t\tint minWins = Integer.MAX_VALUE;\n\t\t//and a list to store the people with the lowest win count\n\t\tArrayList<Integer> winIndecies = new ArrayList<>();\n\t\t\n\t\t//Loop through each candidate\n\t\tfor(int i=0; i<candidates.size(); i++) {\n\t\t\t//determine that candidates win number by summing their row in the matrix\n\t\t\tint currWins = matrixRowSum(winMatrix, i);\n\t\t\t\n\t\t\tif(currWins < minWins) {\n\t\t\t\t//If this candidate has less wins than the current lowest, reset the list and mark this candidate the loser\n\t\t\t\tminWins = currWins;\n\t\t\t\twinIndecies.clear();\n\t\t\t\twinIndecies.add(i);\n\t\t\t} else if (currWins == minWins) {\n\t\t\t\t//If this candidate has the same number of wins as the lowest, add their index to the list\n\t\t\t\twinIndecies.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//If there is someone worse than everyone else, then they lose\n\t\tif(winIndecies.size() == 1) {\n\t\t\treturn candidates.get(winIndecies.get(0));\n\t\t} else {\n\t\t\t//If multiple people share the worst win number, magnitude is taken into account\n\t\t\tint minMagnitude = Integer.MAX_VALUE;\n\t\t\tArrayList<Integer> worstIndecies = new ArrayList<>();\n\t\t\t\n\t\t\t//Sum the row of the magnitude matrix for each of the worst candidates\n\t\t\tfor(Integer rowNum : winIndecies) {\n\t\t\t\tint currMag = matrixRowSum(magnitudeMatrix, rowNum);\n\t\t\t\t\n\t\t\t\t//Keep track of those candidate with the worst magnitude of wins against all opponents in the tie breaker\n\t\t\t\tif(currMag < minMagnitude) {\n\t\t\t\t\tminMagnitude = currMag;\n\t\t\t\t\tworstIndecies.clear();\n\t\t\t\t\tworstIndecies.add(rowNum);\n\t\t\t\t} else if(currMag == minMagnitude) {\n\t\t\t\t\tworstIndecies.add(rowNum);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//If one is the worst by magnitue, eliminate them\n\t\t\tif(worstIndecies.size() == 1) {\n\t\t\t\treturn candidates.get(worstIndecies.get(0));\n\t\t\t} else {\n\t\t\t\t//If win number and magnitude did not break the tie, then we look at the original votes for each candidate\n\t\t\t\tArrayList<Integer> lowPointIndecies = new ArrayList<>();\n\t\t\t\t//Points are given for the ranking of a candidate on a ballot, with a higher ranked choice getting more points\n\t\t\t\tint lowPoint = Integer.MAX_VALUE;\n\t\t\t\t\n\t\t\t\t//Loop through the candidates that are stilled tied\n\t\t\t\tfor(Integer i : worstIndecies) {\n\t\t\t\t\tint totalPoints = 0;\n\t\t\t\t\t\n\t\t\t\t\t//get the points for that candidate from each vote\n\t\t\t\t\tfor(Vote vote : originalVotes) {\n\t\t\t\t\t\ttotalPoints += vote.getPoints(candidates.get(i));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Keep track of the candidates with the worst votes\n\t\t\t\t\tif(totalPoints < lowPoint) {\n\t\t\t\t\t\tlowPoint = totalPoints;\n\t\t\t\t\t\tlowPointIndecies.clear();\n\t\t\t\t\t\tlowPointIndecies.add(i);\n\t\t\t\t\t} else if (totalPoints == lowPoint) {\n\t\t\t\t\t\tlowPointIndecies.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//If there is one that is worst, eliminate them\n\t\t\t\tif(lowPointIndecies.size() == 1) {\n\t\t\t\t\treturn candidates.get(lowPointIndecies.get(0));\n\t\t\t\t} else {\n\t\t\t\t\t//If there is still a tie, it is broken randomly\n\t\t\t\t\tRandom rand = new Random();\n\t\t\t\t\t\n\t\t\t\t\tint returnIndex = rand.nextInt(lowPointIndecies.size());\n\t\t\t\t\t\n\t\t\t\t\treturn candidates.get(lowPointIndecies.get(returnIndex));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Calculate the sum of a row (1st index) in a matrix\n\t * \n\t * @param matrix The matrix to operate on\n\t * @param row the index of the row to sum\n\t * @return int the sum of the row\n\t */\n\tprivate static int matrixRowSum(int[][] matrix, int row) {\n\t\tint sum = 0;\n\t\t\n\t\tfor(int y=0; y<matrix[0].length; y++) {\n\t\t\tsum += matrix[row][y];\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\t/**\n\t * Add two matrices together\n\t * \n\t * @param a the first matrix to add\n\t * @param b the second matrix to add\n\t * @return int[][] the matrix creating by adding a and b\n\t */\n\tprivate static int[][] matrixAddition(int[][] a, int[][] b) {\n\t\t//get the row and column count for the size of the new matrix\n\t\tint rows = a.length;\n\t\tint columns = a[0].length;\n\t\t\n\t\t//create the matrix\n\t\tint[][] c = new int[rows][columns];\n\t\t\n\t\t//perform the addition\n\t\tfor(int i=0; i<rows; i++) {\n\t\t\tfor(int j=0; j<columns; j++) {\n\t\t\t\tc[i][j] = a[i][j] + b[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\t\n\t/**\n\t * Perform the initial count of the votes\n\t */\n\tprivate static void countVotes() {\n\t\t\n\t\tfor(Vote vote : votes) {\n\t\t\tif(!vote.getChoices().isEmpty()) {\n\t\t\t\t//ensure that the current choice has been reset\n\t\t\t\tvote.resetCurrentChoice();\n\t\t\t\t\n\t\t\t\tString currFaction = vote.getChoice();\n\t\t\t\tdouble newCount = currentVoteCounts.get(currFaction)+vote.getWeight();\n\t\t\t\tcurrentVoteCounts.put(currFaction, newCount);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Eliminates the specified candidate and redistributes every vote that currently is counting for that candidate with a weight of 1.0\n\t * \n\t * @param candidate The candidate to eliminate\n\t */\n\tprivate static void eliminateCandidate(String candidate) {\n\t\tredistributeVotes(candidate, 1.0);\n\t\t\n\t\t//remove the candidate from the vote counts.\n\t\tSystem.out.println(candidate + \" has been eliminated with \" + currentVoteCounts.get(candidate) + \" votes.\");\n\t\tcurrentVoteCounts.remove(candidate);\n\t}\n\t\n\t/**\n\t * Redistribute votes from a candidate to that vote's next candidate with a specified weight\n\t * \n\t * @param candidate The candidate to redistribute votes from\n\t * @param redistributeAmount The weight of the redistributed votes\n\t */\n\tprivate static void redistributeVotes(String candidate, double redistributeAmount) {\n\t\tfor(Vote vote : votes) {\n\t\t\t\n\t\t\t//skip the vote if it has no valid candidate choices remaining\n\t\t\tif(vote.getChoices().isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//If the vote is currently counting for the candidate to redistribute from\n\t\t\tif(vote.getChoice().compareTo(candidate) == 0) {\n\t\t\t\t//If the vote has another valid choice\n\t\t\t\tif(vote.getChoices().size() > vote.getCurrentChoice()+1) {\n\t\t\t\t\t\n\t\t\t\t\t//Set the vote to the next candidate and count the vote for that candidate\n\t\t\t\t\tvote.alterWeight(redistributeAmount);\n\t\t\t\t\tvote.incrementCurrentChoice();\n\t\t\t\t\tString newCandidate = vote.getChoice();\n\t\t\t\t\tdouble newCount =  Double.sum(currentVoteCounts.get(newCandidate), vote.getWeight());\n\t\t\t\t\tcurrentVoteCounts.put(newCandidate, newCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Vote vote : votes) {\n\t\t\tvote.eliminateRanking(candidate);\n\t\t}\t\n\t}\n}", "class_id": 0, "repo": "tn-wright/ranked-choice-voting", "file": "src/voteCounter/VoteCounter.java", "last_update_at": "2021-03-17T06:34:47+00:00", "question_id": "1fedf96a0bc0d600ebdfb70a4efcf6a14a3fed03", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class VoteCounter {\n\t//Parameter: The number of candidates that can win\n\tstatic int numberOfWinners;\n\t//The percentage of votes that is needed to guarantee a win for a candidate\n\tstatic double voteThresholdPercent;\n\t//A counter for the total number of candidates\n\tstatic int numberOfCandidates = 0;\n\t//the total number of votes being counted\n\tstatic int numberOfVotes = 0;\n\t//the number of votes needed to guarantee a win\n\tstatic double voteThreshold = 0.0;\n\t//A list of the candidates which have won\n\tstatic ArrayList<String> winningCandidates = new ArrayList<>();\n\t//A list of the candidates which have been eliminated\n\tstatic ArrayList<String> eliminatedCandidates = new ArrayList<>();\n\t//A list of the original, unaltered Votes. Needed for the tie breaker\n\tstatic ArrayList<Vote> originalVotes = new ArrayList<Vote>();\n\t//A list of the votes that are redistributed\n\tstatic ArrayList<Vote> votes = new ArrayList<Vote>();\n\t//A list of the working vote counts\n\tstatic HashMap<String, Double> currentVoteCounts = new HashMap<>();\n\tstatic int roundCounter = 1;\n\t\n\t/**\n\t * The main method. See class docs for description on required arguments\n\t * \n\t * @param args - String[]\n\t */\n\tpublic static void main(String[] args) {\n\t\t//If there was 1 argument, check if it was help and print how to if it was\n\t\tif(args.length == 1 && args[0].equals(\"help\")) {\n\t\t\t//TODO provide how to output\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//Quit if the three arguments were not supplied\n\t\tif(args.length != 3) {\n\t\t\tSystem.out.println(\"Please provide all 3 arguments. Run 'VoteCounter help' for more information.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//Parse the input files\n\t\tif(!parseCandidates(args[0])) {\n\t\t\t//If parseCandidates returns false, then it failed to work correctly and the program should terminate\n\t\t\treturn;\n\t\t}\n\t\tif(!parseVotes(args[1])) {\n\t\t\t//if parseVotes returns false, then it failed to work correctly and the program should terminate\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//Try to get the number of voters\n\t\ttry {\n\t\t\tnumberOfWinners = Integer.parseInt(args[2]);\n\t\t\t\n\t\t\tif(numberOfWinners < 1 || numberOfWinners > currentVoteCounts.keySet().size()) {\n\t\t\t\tSystem.out.println(\"The number of winners must be at least 1 and no more than the number of candidates\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t//Not a valid number, so print error to the user and return\n\t\t\tSystem.out.println(\"Invalid winner count argument. \");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//calculate the vote thresholds\n\t\tvoteThresholdPercent = 1.0/(numberOfWinners+1);\n\t\tvoteThreshold = numberOfVotes*voteThresholdPercent;\n\t\t\n\t\t//perform the initial count of the votes\n\t\tcountVotes();\n\t\t\n\t\t//Analyze the votes, redistributing as needed, until enough winners have been found\n\t\tdo {\n\t\t\tanalyzeVotes();\n\t\t} while(winningCandidates.size() < numberOfWinners);\n\t\t\n\t\t//Print the final winners\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Winners:\");\n\t\tSystem.out.println(String.join(\", \", winningCandidates));\n\t}\n\t\n\t/**\n\t * Parse the candidate file and initialize {@code numberOfCandidates} and {@code currentVoteCounts}\n\t * \n\t * @param candidateFileName - String - the name of the candidate file\n\t * @return boolean - true if successful, false if not successful\n\t */\n\tprivate static boolean parseCandidates(String candidateFileName) {\n\t\tBufferedReader candidateReader = null;\n\t\t\n\t\ttry {\n\t\t\t//try to open the file for reading\n\t\t\tcandidateReader = new BufferedReader(new FileReader(candidateFileName));\n\t\t\tString candidate = null;\n\t\t\t\n\t\t\t//Loop through each line and store the candidate and increase the candidate count\n\t\t\twhile((candidate=candidateReader.readLine()) != null) {\n\t\t\t\tcurrentVoteCounts.put(candidate.trim(), 0.0);\n\t\t\t\tnumberOfCandidates += 1;\n\t\t\t}\n\t\t} catch(FileNotFoundException e) {\n\t\t\t//The file was not found, so print the error message and quit\n\t\t\tSystem.out.println(\"Unable to open the candidate file. Please ensure the provided file path is correct.\");\n\t\t\treturn false;\n\t\t} catch(IOException e) {\n\t\t\t//Something went wrong reading the file, so print the error message and quit\n\t\t\tSystem.out.println(\"An error occured while reading the candidate file:\" + e.getMessage());\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t//Close the candidateReader after everything, if it exists\n\t\t\tif(candidateReader != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcandidateReader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tSystem.out.println(\"An error occured while closing the candidate file:\\n\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Parse the vote file and construct all {@link Vote} objects\n\t * \n\t * @param voteFileName - String - The file name of the vote file\n\t * @return boolean - true if successful, false if not successful\n\t */\n\tprivate static boolean parseVotes(String voteFileName) {\n\t\tBufferedReader voteReader = null;\n\t\t\n\t\ttry {\n\t\t\t//attempt to open the vote file\n\t\t\tvoteReader = new BufferedReader(new FileReader(voteFileName));\n\t\t\tString line = null;\n\t\t\tvoteReader.readLine();\n\t\t\t\n\t\t\t//parse the line of the csv file and use it to create a Vote object\n\t\t\twhile((line = voteReader.readLine()) != null) {\n\t\t\t\tString[] inputRow = line.split(\",\");\n\t\t\t\t\n\t\t\t\t//store the vote as needed and count the total number of votes\n\t\t\t\tvotes.add(new Vote(inputRow));\n\t\t\t\toriginalVotes.add(new Vote(inputRow));\n\t\t\t\tnumberOfVotes++;\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t//File was not found, so return\n\t\t\tSystem.out.println(\"Unable to open the vote file. Please ensure the provided file path is correct.\");\n\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\t//Failure to read file correctly, so return\n\t\t\tSystem.out.println(\"An error occured while reading the vote file:\" + e.getMessage());\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t//Close the buffered reader when finished\n\t\t\tif (voteReader != null) {\n\t\t\t\ttry {\n\t\t\t\t\tvoteReader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tSystem.out.println(\"An error occured while closing the vote file:\\n\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Analyzes the current vote counts, determining a winner or loser for the round, and the redistributes votes as needed\n\t */\n\tprivate static void analyzeVotes() {\n\t\t//Print the start of round text and current vote counts\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Round \" + roundCounter++ + \" vote counts:\");\n\t\tfor(Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n\t\t\tSystem.out.print(entry.getKey() + \": \" + entry.getValue() + \" | \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\t//If the number of candidates left equals the number of winners, mark them all winners and end\n\t\tif(currentVoteCounts.size() == numberOfWinners) {\n\t\t\tfor(Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n\t\t\t\tif(!winningCandidates.contains(entry.getKey())) {\n\t\t\t\t\twinningCandidates.add(entry.getKey());\n\t\t\t\t\tSystem.out.println(entry.getKey() + \" has won in the last round.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean noWinnerFound = true;\n\t\t\n\t\t//create an arrayList that holds the factions with the least number of votes and track the current minimum vote total\n\t\tArrayList<String> minCandidatess = new ArrayList<>();\n\t\tdouble minCount = Double.MAX_VALUE;\n\t\t\n\t\t//The entry key is the candidate name and entry value is the vote count\n\t\tfor(Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n\t\t\t//If the candidate has already won, do not count their votes\n\t\t\tif(!winningCandidates.contains(entry.getKey())) {\n\t\t\t\t//Check if the vote count for this candidate has exceeded the winning threshold\n\t\t\t\tif(entry.getValue().compareTo(voteThreshold) > 0) {\n\t\t\t\t\t//Mark that a winner was found\n\t\t\t\t\tnoWinnerFound = false;\n\t\t\t\t\t\n\t\t\t\t\t//subtract the threshold from the number of votes over\n\t\t\t\t\t//Then divide that by the total number of votes. This results in a percentage which acts as\n\t\t\t\t\t//a weight for all votes from this winner as they are redistributed. \n\t\t\t\t\tdouble redistributeAmount = Double.sum(entry.getValue(), voteThreshold*-1.0)/numberOfVotes;\n\t\t\t\t\t\n\t\t\t\t\t//redistribute the votes of the winner using the calculated redistribution amount\n\t\t\t\t\tredistributeVotes(entry.getKey(), redistributeAmount);\n\t\t\t\t\t\n\t\t\t\t\t//Add the winner to the list of winners and print that they have won\n\t\t\t\t\twinningCandidates.add(entry.getKey());\n\t\t\t\t\tSystem.out.println(entry.getKey() + \" has won with \" + entry.getValue() + \" votes.\");\n\t\t\t\t\t\n\t\t\t\t\t//Exit the loop\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(entry.getValue().compareTo(minCount) < 0) {\n\t\t\t\t//If this candidate has a lower vote count than the current lowest\n\t\t\t\t//Store this count as the new minimum\n\t\t\t\tminCount = entry.getValue();\n\t\t\t\t//remove all current candidates from the minimum count list\n\t\t\t\tminCandidatess.clear();\n\t\t\t\t//and add this candidate to the list\n\t\t\t\tminCandidatess.add(entry.getKey());\n\t\t\t} else if(entry.getValue().compareTo(minCount) == 0) {\n\t\t\t\tminCandidatess.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Since no one won, a loser must be eliminated\n\t\tif(noWinnerFound) {\n\t\t\t//If only one candidate has the lowest vote count, eliminate them\n\t\t\t//If 2 or more are tied for the lowest, run a tie breaker and eliminate the loser\n\t\t\tif(minCandidatess.size() == 1) {\n\t\t\t\teliminateCandidate(minCandidatess.get(0));\n\t\t\t} else {\n\t\t\t\teliminateCandidate(condorcetTieBreak(minCandidatess));\n\t\t\t}\n\t\t} \n\t}\n\t\n\t/**\n\t * Perform a condorcet tie break for all factions in the factions list\n\t * @param candidates - {@code ArrayList<String>} - The list of candidates to check in the tie breaker\n\t * \n\t * @return - String - the name of the candidate that lost the tie breaker\n\t */\n\tprivate static String condorcetTieBreak(ArrayList<String> candidates) {\n\t\t//Output that a tie braker is occuring between the candidates\n\t\tSystem.out.println(\"Breaking last place tie between: \" + String.join(\", \", candidates));\n\t\t\n\t\t//create the master matrix that counts the number of times one candidate beats another candidate\n\t\tint[][] masterMatrix = new int[candidates.size()][candidates.size()];\n\t\t\n\t\t//generate a matrix for each vote and add it to the master\n\t\tfor(Vote vote : originalVotes) {\n\t\t\tmasterMatrix = matrixAddition(masterMatrix, vote.generateMatrix(candidates));\n\t\t}\n\t\t\n\t\t// Create a win matrix which marks if one candidate beats another candidate more in the master matrix\n\t\tint[][] winMatrix = new int[candidates.size()][candidates.size()];\n\t\t// Create a matrix that stores the magnitude of victories in the win matrix\n\t\tint[][] magnitudeMatrix = new int[candidates.size()][candidates.size()];\n\t\t\n\t\t//loop through the master matrix\n\t\tfor(int x=0; x<masterMatrix.length; x++) {\n\t\t\tfor(int y=0; y<masterMatrix[0].length; y++) {\n\t\t\t\t// Only 1 half of the matrix is cared about, so skip it if x < y\n\t\t\t\tif(y>x) {\n\t\t\t\t\tif(masterMatrix[x][y] > masterMatrix[y][x]) {\n\t\t\t\t\t\t//If x beat y more than y beat x, mark that x beats y overall in the win matrix\n\t\t\t\t\t\twinMatrix[x][y] = 1;\n\t\t\t\t\t\t//calculate difference of counts in the master and store it as the magnitude\n\t\t\t\t\t\t//The winner will have a positive value while the lose will have a negative value\n\t\t\t\t\t\tmagnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n\t\t\t\t\t\tmagnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n\t\t\t\t\t} else if (masterMatrix[x][y] < masterMatrix[y][x]) {\n\t\t\t\t\t\t//The same thing as above but if Y won\n\t\t\t\t\t\twinMatrix[y][x] = 1;\n\t\t\t\t\t\tmagnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n\t\t\t\t\t\tmagnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Create a variable to store the currently lowest win count\n\t\tint minWins = Integer.MAX_VALUE;\n\t\t//and a list to store the people with the lowest win count\n\t\tArrayList<Integer> winIndecies = new ArrayList<>();\n\t\t\n\t\t//Loop through each candidate\n\t\tfor(int i=0; i<candidates.size(); i++) {\n\t\t\t//determine that candidates win number by summing their row in the matrix\n\t\t\tint currWins = matrixRowSum(winMatrix, i);\n\t\t\t\n\t\t\tif(currWins < minWins) {\n\t\t\t\t//If this candidate has less wins than the current lowest, reset the list and mark this candidate the loser\n\t\t\t\tminWins = currWins;\n\t\t\t\twinIndecies.clear();\n\t\t\t\twinIndecies.add(i);\n\t\t\t} else if (currWins == minWins) {\n\t\t\t\t//If this candidate has the same number of wins as the lowest, add their index to the list\n\t\t\t\twinIndecies.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//If there is someone worse than everyone else, then they lose\n\t\tif(winIndecies.size() == 1) {\n\t\t\treturn candidates.get(winIndecies.get(0));\n\t\t} else {\n\t\t\t//If multiple people share the worst win number, magnitude is taken into account\n\t\t\tint minMagnitude = Integer.MAX_VALUE;\n\t\t\tArrayList<Integer> worstIndecies = new ArrayList<>();\n\t\t\t\n\t\t\t//Sum the row of the magnitude matrix for each of the worst candidates\n\t\t\tfor(Integer rowNum : winIndecies) {\n\t\t\t\tint currMag = matrixRowSum(magnitudeMatrix, rowNum);\n\t\t\t\t\n\t\t\t\t//Keep track of those candidate with the worst magnitude of wins against all opponents in the tie breaker\n\t\t\t\tif(currMag < minMagnitude) {\n\t\t\t\t\tminMagnitude = currMag;\n\t\t\t\t\tworstIndecies.clear();\n\t\t\t\t\tworstIndecies.add(rowNum);\n\t\t\t\t} else if(currMag == minMagnitude) {\n\t\t\t\t\tworstIndecies.add(rowNum);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//If one is the worst by magnitue, eliminate them\n\t\t\tif(worstIndecies.size() == 1) {\n\t\t\t\treturn candidates.get(worstIndecies.get(0));\n\t\t\t} else {\n\t\t\t\t//If win number and magnitude did not break the tie, then we look at the original votes for each candidate\n\t\t\t\tArrayList<Integer> lowPointIndecies = new ArrayList<>();\n\t\t\t\t//Points are given for the ranking of a candidate on a ballot, with a higher ranked choice getting more points\n\t\t\t\tint lowPoint = Integer.MAX_VALUE;\n\t\t\t\t\n\t\t\t\t//Loop through the candidates that are stilled tied\n\t\t\t\tfor(Integer i : worstIndecies) {\n\t\t\t\t\tint totalPoints = 0;\n\t\t\t\t\t\n\t\t\t\t\t//get the points for that candidate from each vote\n\t\t\t\t\tfor(Vote vote : originalVotes) {\n\t\t\t\t\t\ttotalPoints += vote.getPoints(candidates.get(i));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Keep track of the candidates with the worst votes\n\t\t\t\t\tif(totalPoints < lowPoint) {\n\t\t\t\t\t\tlowPoint = totalPoints;\n\t\t\t\t\t\tlowPointIndecies.clear();\n\t\t\t\t\t\tlowPointIndecies.add(i);\n\t\t\t\t\t} else if (totalPoints == lowPoint) {\n\t\t\t\t\t\tlowPointIndecies.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//If there is one that is worst, eliminate them\n\t\t\t\tif(lowPointIndecies.size() == 1) {\n\t\t\t\t\treturn candidates.get(lowPointIndecies.get(0));\n\t\t\t\t} else {\n\t\t\t\t\t//If there is still a tie, it is broken randomly\n\t\t\t\t\tRandom rand = new Random();\n\t\t\t\t\t\n\t\t\t\t\tint returnIndex = rand.nextInt(lowPointIndecies.size());\n\t\t\t\t\t\n\t\t\t\t\treturn candidates.get(lowPointIndecies.get(returnIndex));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Calculate the sum of a row (1st index) in a matrix\n\t * \n\t * @param matrix The matrix to operate on\n\t * @param row the index of the row to sum\n\t * @return int the sum of the row\n\t */\n\tprivate static int matrixRowSum(int[][] matrix, int row) {\n\t\tint sum = 0;\n\t\t\n\t\tfor(int y=0; y<matrix[0].length; y++) {\n\t\t\tsum += matrix[row][y];\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\t/**\n\t * Add two matrices together\n\t * \n\t * @param a the first matrix to add\n\t * @param b the second matrix to add\n\t * @return int[][] the matrix creating by adding a and b\n\t */\n\tprivate static int[][] matrixAddition(int[][] a, int[][] b) {\n\t\t//get the row and column count for the size of the new matrix\n\t\tint rows = a.length;\n\t\tint columns = a[0].length;\n\t\t\n\t\t//create the matrix\n\t\tint[][] c = new int[rows][columns];\n\t\t\n\t\t//perform the addition\n\t\tfor(int i=0; i<rows; i++) {\n\t\t\tfor(int j=0; j<columns; j++) {\n\t\t\t\tc[i][j] = a[i][j] + b[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\t\n\t/**\n\t * Perform the initial count of the votes\n\t */\n\tprivate static void countVotes() {\n\t\t\n\t\tfor(Vote vote : votes) {\n\t\t\tif(!vote.getChoices().isEmpty()) {\n\t\t\t\t//ensure that the current choice has been reset\n\t\t\t\tvote.resetCurrentChoice();\n\t\t\t\t\n\t\t\t\tString currFaction = vote.getChoice();\n\t\t\t\tdouble newCount = currentVoteCounts.get(currFaction)+vote.getWeight();\n\t\t\t\tcurrentVoteCounts.put(currFaction, newCount);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Eliminates the specified candidate and redistributes every vote that currently is counting for that candidate with a weight of 1.0\n\t * \n\t * @param candidate The candidate to eliminate\n\t */\n\tprivate static void eliminateCandidate(String candidate) {\n\t\tredistributeVotes(candidate, 1.0);\n\t\t\n\t\t//remove the candidate from the vote counts.\n\t\tSystem.out.println(candidate + \" has been eliminated with \" + currentVoteCounts.get(candidate) + \" votes.\");\n\t\tcurrentVoteCounts.remove(candidate);\n\t}\n\t\n\t/**\n\t * Redistribute votes from a candidate to that vote's next candidate with a specified weight\n\t * \n\t * @param candidate The candidate to redistribute votes from\n\t * @param redistributeAmount The weight of the redistributed votes\n\t */\n\tprivate static void redistributeVotes(String candidate, double redistributeAmount) {\n\t\tfor(Vote vote : votes) {\n\t\t\t\n\t\t\t//skip the vote if it has no valid candidate choices remaining\n\t\t\tif(vote.getChoices().isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//If the vote is currently counting for the candidate to redistribute from\n\t\t\tif(vote.getChoice().compareTo(candidate) == 0) {\n\t\t\t\t//If the vote has another valid choice\n\t\t\t\tif(vote.getChoices().size() > vote.getCurrentChoice()+1) {\n\t\t\t\t\t\n\t\t\t\t\t//Set the vote to the next candidate and count the vote for that candidate\n\t\t\t\t\tvote.alterWeight(redistributeAmount);\n\t\t\t\t\tvote.incrementCurrentChoice();\n\t\t\t\t\tString newCandidate = vote.getChoice();\n\t\t\t\t\tdouble newCount =  Double.sum(currentVoteCounts.get(newCandidate), vote.getWeight());\n\t\t\t\t\tcurrentVoteCounts.put(newCandidate, newCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(Vote vote : votes) {\n\t\t\tvote.eliminateRanking(candidate);\n\t\t}\t\n\t}\n"]]}
{"hexsha": "daa82ec1a1715de64f51cea5d80e4c9ce1e34fa7", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class LabelTest {\n    @Parameter()\n    public String testName;\n    @Parameter(1)\n    public LabelerFactory labelerFactory;\n\n    @Rule\n    public final ExpectedException exception = ExpectedException.none();\n\n\t/**\n\t * @return A collection of parameter arrays for running tests: <ol> <li>arg[0] is the test name;</li> <li>arg[1] is\n\t * the {@link LabelerFactory} for the {@link Label} class to be tested.</li></ol>\n\t */\n\t@Parameterized.Parameters(name = \"{0}\")\n\tpublic static Collection<Object[]> instancesToTest() {\n\t\treturn List.of(\n\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\"IntLabel\", new IntLabelerFactory()\n\t\t\t\t},\n\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\"LongLabel\", new LongLabelerFactory()\n\t\t\t\t},\n\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\"BitSetLabel\", new BitSetLabelerFactory()\n\t\t\t\t});\n\t}\n\n    // test that equals() and hashCode() work correctly and agree\n    @Test\n    public void testEquivalence() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n        Label firstLabel = labeler.fromBits(0b001);\n        Label secondLabel = labeler.fromBits(0b001);\n        Label thirdLabel = labeler.fromBits(0b101);\n\n        assertLabelEquals(firstLabel, secondLabel);\n        assertLabelEquals(firstLabel, firstLabel);\n        assertLabelEquals(secondLabel, secondLabel);\n\n        assertLabelNotEquivalent(firstLabel, thirdLabel);\n        assertLabelNotEquivalent(secondLabel, thirdLabel);\n    }\n\n    private void assertLabelEquals(Label firstLabel, Label secondLabel) {\n\t\tassertEquals(firstLabel, secondLabel);\n\t\tassertEquals(secondLabel, firstLabel);\n\t\tassertEquals(firstLabel.hashCode(), secondLabel.hashCode());\n    }\n\n    private void assertLabelNotEquivalent(Label firstLabel, Label secondLabel) {\n\t\tassertNotEquals(firstLabel, secondLabel);\n\t\tassertNotEquals(secondLabel, firstLabel);\n        // technically not always true, but it's a good test on our small set\n        assertTrue(firstLabel.hashCode() != secondLabel.hashCode());\n    }\n\n    @Test\n    public void testGetCardinality() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel testLabel = labeler.fromBits(0b001);\n        assertEquals(testLabel.getCardinality(), 3);\n    }\n\n    @Test\n    public void testMatches() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n\t\tLabel testLabel = labeler.fromBits(0b001);\n        boolean[] matches = new boolean[]{false, true, true};\n        for (int i = 0; i < matches.length; i++)\n            assertEquals(testLabel.matches(i), matches[i]);\n\n        matches = new boolean[]{false, true, false};\n        testLabel = labeler.fromBits(0b101);\n        for (int i = 0; i < matches.length; i++)\n            assertEquals(testLabel.matches(i), matches[i]);\n    }\n\n    @Test\n    public void testIntersect() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n\t\tLabel label1 = labeler.fromBits(0b001);\n\t\tLabel label2 = labeler.fromBits(0b100);\n        boolean[] matches = new boolean[]{false, true, false};\n        Label intersected = label1.intersect(label2);\n        for (int i = 0; i < matches.length; i++)\n            assertEquals(intersected.matches(i), matches[i]);\n    }\n\n    @Test\n    public void testUnion() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n\t\tLabel label1 = labeler.fromBits(0b001);\n\t\tLabel label2 = labeler.fromBits(0b100);\n        Label intersected = label1.union(label2);\n        for (int i = 0; i < intersected.getCardinality(); i++)\n\t\t\tassertTrue(intersected.matches(i));\n    }\n\n    @Test\n    public void testAllMatching() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        assertTrue(\"Label composed of all 0's\", labeler.fromBits(0b000).allMatching());\n        for (int bits : List.of(0b100, 0b001, 0b010, 0b111)) {\n            assertFalse(\"Label with a 1 in it\", labeler.fromBits(bits).allMatching());\n        }\n    }\n\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooLow() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n\t\tLabel testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(-10);\n    }\n\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooHigh() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n        Label testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(3);\n    }\n\n\t// Currently this also checks iterator order, which shouldn't matter.\n\t// For now, it's fine.\n\t@Test\n\tpublic void testDescendantIterator() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel label = labeler.fromBits(0b100);\n\n\t\tSet<Label> expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b101), labeler.fromBits(0b111), labeler.fromBits(0b110)));\n\n\t\tSet<Label> actualLabels = new HashSet<>();\n\t\tIterator<Label> si = label.descendantIterator();\n\t\twhile (si.hasNext()) actualLabels.add(si.next());\n\t\tassertEquals(expectedLabels, actualLabels);\n\n\t\t// comparing:\n\t\t// V , O , V , I , 0 , ? , O , T , T , A , A\n\t\t// V , U , V , O , 0 , ? , 0 , ? , L , E , A\n\t\tlabeler = labelerFactory.createLabeler(mockInstance(10), false, VARIABLE);\n\t\tlabel = labeler.fromBits(0b0101001111);\n\n\t\texpectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b0101011111), labeler.fromBits(0b0101111111), labeler.fromBits(0b0101101111),\n\t\t\t\tlabeler.fromBits(0b0111101111), labeler.fromBits(0b0111111111), labeler.fromBits(0b0111011111),\n\t\t\t\tlabeler.fromBits(0b0111001111), labeler.fromBits(0b1111001111), labeler.fromBits(0b1111011111),\n\t\t\t\tlabeler.fromBits(0b1111111111), labeler.fromBits(0b1111101111), labeler.fromBits(0b1101101111),\n\t\t\t\tlabeler.fromBits(0b1101111111), labeler.fromBits(0b1101011111), labeler.fromBits(0b1101001111)));\n\n\t\tactualLabels = new HashSet<>();\n\t\tsi = label.descendantIterator();\n\t\twhile (si.hasNext()) actualLabels.add(si.next());\n\t\tassertEquals(expectedLabels, actualLabels);\n\t}\n\n\t@Test\n\tpublic void testIsDescendantOf() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\n\t\tLabel parentLabel = labeler.fromBits(0b100);\n\n\t\tLabel descendantLabel = labeler.fromBits(0b101);\n\t\tassertTrue(descendantLabel.isDescendantOf(parentLabel));\n\n\t\tLabel nonDescendantLabel = labeler.fromBits(0b001);\n\t\tassertFalse(nonDescendantLabel.isDescendantOf(parentLabel));\n\t}\n\n\t@Test\n\tpublic void testToString() {\n\t\tint labelBits = 0b1010101000111;\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n\t\tLabel label = labeler.fromBits(labelBits);\n\t\tassertEquals(\"toString of label with elements\", Integer.toString(labelBits,2), label.toString());\n\t}\n\n\t@Test\n\tpublic void testToStringAllZeroes() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n\t\tLabel label = labeler.fromBits(0);\n\t\tassertEquals(\"0000000000000\", label.toString());\n\t}\n\n\t// It seems like a dumb case to handle, but Weka's classifier test actually exercises this case\n\t@Test\n\tpublic void testToStringNoAttributes() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(0), false, MATCH);\n\t\tLabel label = labeler.fromBits(0);\n\t\tassertEquals(\"\", label.toString());\n\t}\n}", "class_id": 0, "repo": "garfieldnate/Weka_AnalogicalModeling", "file": "src/test/java/weka/classifiers/lazy/AM/label/LabelTest.java", "last_update_at": "2021-09-26T05:48:26+00:00", "question_id": "daa82ec1a1715de64f51cea5d80e4c9ce1e34fa7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class LabelTest {\n    @Parameter()\n    public String testName;\n    @Parameter(1)\n    public LabelerFactory labelerFactory;\n    @Rule\n    public final ExpectedException exception = ExpectedException.none();\n\t/**\n\t * @return A collection of parameter arrays for running tests: <ol> <li>arg[0] is the test name;</li> <li>arg[1] is\n\t * the {@link LabelerFactory} for the {@link Label} class to be tested.</li></ol>\n\t */\n\t@Parameterized.Parameters(name = \"{0}\")\n\tpublic static Collection<Object[]> instancesToTest() {\n\t\treturn List.of(\n\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\"IntLabel\", new IntLabelerFactory()\n\t\t\t\t},\n\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\"LongLabel\", new LongLabelerFactory()\n\t\t\t\t},\n\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\"BitSetLabel\", new BitSetLabelerFactory()\n\t\t\t\t});\n\t}\n    // test that equals() and hashCode() work correctly and agree\n    @Test\n    public void testEquivalence() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label firstLabel = labeler.fromBits(0b001);\n        Label secondLabel = labeler.fromBits(0b001);\n        Label thirdLabel = labeler.fromBits(0b101);\n        assertLabelEquals(firstLabel, secondLabel);\n        assertLabelEquals(firstLabel, firstLabel);\n        assertLabelEquals(secondLabel, secondLabel);\n        assertLabelNotEquivalent(firstLabel, thirdLabel);\n        assertLabelNotEquivalent(secondLabel, thirdLabel);\n    }\n    private void assertLabelEquals(Label firstLabel, Label secondLabel) {\n\t\tassertEquals(firstLabel, secondLabel);\n\t\tassertEquals(secondLabel, firstLabel);\n\t\tassertEquals(firstLabel.hashCode(), secondLabel.hashCode());\n    }\n    private void assertLabelNotEquivalent(Label firstLabel, Label secondLabel) {\n\t\tassertNotEquals(firstLabel, secondLabel);\n\t\tassertNotEquals(secondLabel, firstLabel);\n        // technically not always true, but it's a good test on our small set\n        assertTrue(firstLabel.hashCode() != secondLabel.hashCode());\n    }\n    @Test\n    public void testGetCardinality() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel testLabel = labeler.fromBits(0b001);\n        assertEquals(testLabel.getCardinality(), 3);\n    }\n    @Test\n    public void testMatches() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel testLabel = labeler.fromBits(0b001);\n        boolean[] matches = new boolean[]{false, true, true};\n        for (int i = 0; i < matches.length; i++)\n            assertEquals(testLabel.matches(i), matches[i]);\n        matches = new boolean[]{false, true, false};\n        testLabel = labeler.fromBits(0b101);\n        for (int i = 0; i < matches.length; i++)\n            assertEquals(testLabel.matches(i), matches[i]);\n    }\n    @Test\n    public void testIntersect() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel label1 = labeler.fromBits(0b001);\n\t\tLabel label2 = labeler.fromBits(0b100);\n        boolean[] matches = new boolean[]{false, true, false};\n        Label intersected = label1.intersect(label2);\n        for (int i = 0; i < matches.length; i++)\n            assertEquals(intersected.matches(i), matches[i]);\n    }\n    @Test\n    public void testUnion() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel label1 = labeler.fromBits(0b001);\n\t\tLabel label2 = labeler.fromBits(0b100);\n        Label intersected = label1.union(label2);\n        for (int i = 0; i < intersected.getCardinality(); i++)\n\t\t\tassertTrue(intersected.matches(i));\n    }\n    @Test\n    public void testAllMatching() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        assertTrue(\"Label composed of all 0's\", labeler.fromBits(0b000).allMatching());\n        for (int bits : List.of(0b100, 0b001, 0b010, 0b111)) {\n            assertFalse(\"Label with a 1 in it\", labeler.fromBits(bits).allMatching());\n        }\n    }\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooLow() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(-10);\n    }\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooHigh() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(3);\n    }\n\t// Currently this also checks iterator order, which shouldn't matter.\n\t// For now, it's fine.\n\t@Test\n\tpublic void testDescendantIterator() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel label = labeler.fromBits(0b100);\n\t\tSet<Label> expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b101), labeler.fromBits(0b111), labeler.fromBits(0b110)));\n\t\tSet<Label> actualLabels = new HashSet<>();\n\t\tIterator<Label> si = label.descendantIterator();\n\t\twhile (si.hasNext()) actualLabels.add(si.next());\n\t\tassertEquals(expectedLabels, actualLabels);\n\t\t// comparing:\n\t\t// V , O , V , I , 0 , ? , O , T , T , A , A\n\t\t// V , U , V , O , 0 , ? , 0 , ? , L , E , A\n\t\tlabeler = labelerFactory.createLabeler(mockInstance(10), false, VARIABLE);\n\t\tlabel = labeler.fromBits(0b0101001111);\n\t\texpectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b0101011111), labeler.fromBits(0b0101111111), labeler.fromBits(0b0101101111),\n\t\t\t\tlabeler.fromBits(0b0111101111), labeler.fromBits(0b0111111111), labeler.fromBits(0b0111011111),\n\t\t\t\tlabeler.fromBits(0b0111001111), labeler.fromBits(0b1111001111), labeler.fromBits(0b1111011111),\n\t\t\t\tlabeler.fromBits(0b1111111111), labeler.fromBits(0b1111101111), labeler.fromBits(0b1101101111),\n\t\t\t\tlabeler.fromBits(0b1101111111), labeler.fromBits(0b1101011111), labeler.fromBits(0b1101001111)));\n\t\tactualLabels = new HashSet<>();\n\t\tsi = label.descendantIterator();\n\t\twhile (si.hasNext()) actualLabels.add(si.next());\n\t\tassertEquals(expectedLabels, actualLabels);\n\t}\n\t@Test\n\tpublic void testIsDescendantOf() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n\t\tLabel parentLabel = labeler.fromBits(0b100);\n\t\tLabel descendantLabel = labeler.fromBits(0b101);\n\t\tassertTrue(descendantLabel.isDescendantOf(parentLabel));\n\t\tLabel nonDescendantLabel = labeler.fromBits(0b001);\n\t\tassertFalse(nonDescendantLabel.isDescendantOf(parentLabel));\n\t}\n\t@Test\n\tpublic void testToString() {\n\t\tint labelBits = 0b1010101000111;\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n\t\tLabel label = labeler.fromBits(labelBits);\n\t\tassertEquals(\"toString of label with elements\", Integer.toString(labelBits,2), label.toString());\n\t}\n\t@Test\n\tpublic void testToStringAllZeroes() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n\t\tLabel label = labeler.fromBits(0);\n\t\tassertEquals(\"0000000000000\", label.toString());\n\t}\n\t// It seems like a dumb case to handle, but Weka's classifier test actually exercises this case\n\t@Test\n\tpublic void testToStringNoAttributes() {\n\t\tLabeler labeler = labelerFactory.createLabeler(mockInstance(0), false, MATCH);\n\t\tLabel label = labeler.fromBits(0);\n\t\tassertEquals(\"\", label.toString());\n\t}\n"]]}
{"hexsha": "7142d9c06098c05b438ce4e3aee241b816729134", "ext": "java", "lang": "Java", "content": "public class SPacketScoreboardObjective implements Packet<INetHandlerPlayClient>\n{\n    private String objectiveName;\n    private String objectiveValue;\n    private IScoreCriteria.EnumRenderType type;\n    private int action;\n\n    public SPacketScoreboardObjective()\n    {\n    }\n\n    public SPacketScoreboardObjective(ScoreObjective objective, int actionIn)\n    {\n        this.objectiveName = objective.getName();\n        this.objectiveValue = objective.getDisplayName();\n        this.type = objective.getCriteria().getRenderType();\n        this.action = actionIn;\n    }\n\n    /**\n     * Reads the raw packet data from the data stream.\n     */\n    public void readPacketData(PacketBuffer buf) throws IOException\n    {\n        this.objectiveName = buf.readString(16);\n        this.action = buf.readByte();\n\n        if (this.action == 0 || this.action == 2)\n        {\n            this.objectiveValue = buf.readString(32);\n            this.type = IScoreCriteria.EnumRenderType.getByName(buf.readString(16));\n        }\n    }\n\n    /**\n     * Writes the raw packet data to the data stream.\n     */\n    public void writePacketData(PacketBuffer buf) throws IOException\n    {\n        buf.writeString(this.objectiveName);\n        buf.writeByte(this.action);\n\n        if (this.action == 0 || this.action == 2)\n        {\n            buf.writeString(this.objectiveValue);\n            buf.writeString(this.type.getRenderType());\n        }\n    }\n\n    /**\n     * Passes this Packet on to the NetHandler for processing.\n     */\n    public void processPacket(INetHandlerPlayClient handler)\n    {\n        handler.handleScoreboardObjective(this);\n    }\n\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveName()\n    {\n        return this.objectiveName;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveValue()\n    {\n        return this.objectiveValue;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public int getAction()\n    {\n        return this.action;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public IScoreCriteria.EnumRenderType getRenderType()\n    {\n        return this.type;\n    }\n}", "class_id": 0, "repo": "JeremyHi/402-CryptoSym", "file": "Malmo-0.30.0/Minecraft/build/tmp/recompileMc/sources/net/minecraft/network/play/server/SPacketScoreboardObjective.java", "last_update_at": "2021-12-19T18:11:35+00:00", "question_id": "7142d9c06098c05b438ce4e3aee241b816729134", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SPacketScoreboardObjective implements Packet<INetHandlerPlayClient>\n{\n    private String objectiveName;\n    private String objectiveValue;\n    private IScoreCriteria.EnumRenderType type;\n    private int action;\n    public SPacketScoreboardObjective()\n    {\n    }\n    public SPacketScoreboardObjective(ScoreObjective objective, int actionIn)\n    {\n        this.objectiveName = objective.getName();\n        this.objectiveValue = objective.getDisplayName();\n        this.type = objective.getCriteria().getRenderType();\n        this.action = actionIn;\n    }\n    /**\n     * Reads the raw packet data from the data stream.\n     */\n    public void readPacketData(PacketBuffer buf) throws IOException\n    {\n        this.objectiveName = buf.readString(16);\n        this.action = buf.readByte();\n        if (this.action == 0 || this.action == 2)\n        {\n            this.objectiveValue = buf.readString(32);\n            this.type = IScoreCriteria.EnumRenderType.getByName(buf.readString(16));\n        }\n    }\n    /**\n     * Writes the raw packet data to the data stream.\n     */\n    public void writePacketData(PacketBuffer buf) throws IOException\n    {\n        buf.writeString(this.objectiveName);\n        buf.writeByte(this.action);\n        if (this.action == 0 || this.action == 2)\n        {\n            buf.writeString(this.objectiveValue);\n            buf.writeString(this.type.getRenderType());\n        }\n    }\n    /**\n     * Passes this Packet on to the NetHandler for processing.\n     */\n    public void processPacket(INetHandlerPlayClient handler)\n    {\n        handler.handleScoreboardObjective(this);\n    }\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveName()\n    {\n        return this.objectiveName;\n    }\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveValue()\n    {\n        return this.objectiveValue;\n    }\n    @SideOnly(Side.CLIENT)\n    public int getAction()\n    {\n        return this.action;\n    }\n    @SideOnly(Side.CLIENT)\n    public IScoreCriteria.EnumRenderType getRenderType()\n    {\n        return this.type;\n    }\n"]]}
{"hexsha": "32afa3a8e9b1807eedffda9e3ea7130a21a31f59", "ext": "java", "lang": "Java", "content": "public final class SphereShardingSphereProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(SphereShardingSphereProxy.class);\n    private EventLoopGroup bossGroup;\n\n    private EventLoopGroup workerGroup;\n\n    /**\n     * Start ShardingSphere-Proxy.\n     *\n     * @param port port\n     */\n    public void start(final int port) {\n        try {\n            createEventLoopGroup();\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            initServerBootstrap(bootstrap, port);\n            ChannelFuture future = bootstrap.bind(port).sync();\n            log.info(\"ShardingSphere-Proxy start success.\");\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            throw DbException.convert(e);\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n            BackendExecutorContext.getInstance().getExecutorKernel().close();\n        }\n    }\n\n    private void createEventLoopGroup() {\n        bossGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(1) : new NioEventLoopGroup(1);\n        workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n    }\n\n    private void initServerBootstrap(final ServerBootstrap bootstrap, int port) {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(8 * 1024 * 1024, 16 * 1024 * 1024))\n                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.TCP_NODELAY, true).handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ServerHandlerInitializer(port));\n    }\n\n    public final class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {\n        final int port;\n\n        public ServerHandlerInitializer(int port) {\n            this.port = port;\n        }\n\n        @Override\n        protected void initChannel(final SocketChannel socketChannel) {\n            DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine;\n            if (port == PgServer.DEFAULT_PORT) {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealonePostgreSQL\");\n                databaseProtocolFrontendEngine = LealonePostgreSQLFrontendEngine.INSTANCE;\n            } else {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealoneMySQL\");\n                databaseProtocolFrontendEngine = LealoneMySQLFrontendEngine.INSTANCE;\n            }\n            ChannelPipeline pipeline = socketChannel.pipeline();\n            pipeline.addLast(new PacketCodec(databaseProtocolFrontendEngine.getCodecEngine()));\n            pipeline.addLast(new FrontendChannelInboundHandler(databaseProtocolFrontendEngine));\n        }\n\n        public DatabaseProtocolFrontendEngine getDatabaseProtocolFrontendEngineFactory(final String databaseType) {\n            for (DatabaseProtocolFrontendEngine each : ShardingSphereServiceLoader\n                    .newServiceInstances(DatabaseProtocolFrontendEngine.class)) {\n                if (DatabaseTypeRegistry.getActualDatabaseType(databaseType).getName().equals(databaseType)) {\n                    return each;\n                }\n            }\n            throw new UnsupportedOperationException(String.format(\"Cannot support database type '%s'\", databaseType));\n        }\n    }\n}", "class_id": 0, "repo": "lealone/Bats", "file": "bats-sphere/src/main/java/org/lealone/bats/sphere/bootstrap/SphereShardingSphereProxy.java", "last_update_at": "2021-08-07T04:01:14+00:00", "question_id": "32afa3a8e9b1807eedffda9e3ea7130a21a31f59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class SphereShardingSphereProxy {\n    private static final Logger log = LoggerFactory.getLogger(SphereShardingSphereProxy.class);\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    /**\n     * Start ShardingSphere-Proxy.\n     *\n     * @param port port\n     */\n    public void start(final int port) {\n        try {\n            createEventLoopGroup();\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            initServerBootstrap(bootstrap, port);\n            ChannelFuture future = bootstrap.bind(port).sync();\n            log.info(\"ShardingSphere-Proxy start success.\");\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            throw DbException.convert(e);\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n            BackendExecutorContext.getInstance().getExecutorKernel().close();\n        }\n    }\n    private void createEventLoopGroup() {\n        bossGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(1) : new NioEventLoopGroup(1);\n        workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n    }\n    private void initServerBootstrap(final ServerBootstrap bootstrap, int port) {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(8 * 1024 * 1024, 16 * 1024 * 1024))\n                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.TCP_NODELAY, true).handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ServerHandlerInitializer(port));\n    }\n    public final class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {\n        final int port;\n        public ServerHandlerInitializer(int port) {\n            this.port = port;\n        }\n        @Override\n        protected void initChannel(final SocketChannel socketChannel) {\n            DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine;\n            if (port == PgServer.DEFAULT_PORT) {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealonePostgreSQL\");\n                databaseProtocolFrontendEngine = LealonePostgreSQLFrontendEngine.INSTANCE;\n            } else {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealoneMySQL\");\n                databaseProtocolFrontendEngine = LealoneMySQLFrontendEngine.INSTANCE;\n            }\n            ChannelPipeline pipeline = socketChannel.pipeline();\n            pipeline.addLast(new PacketCodec(databaseProtocolFrontendEngine.getCodecEngine()));\n            pipeline.addLast(new FrontendChannelInboundHandler(databaseProtocolFrontendEngine));\n        }\n        public DatabaseProtocolFrontendEngine getDatabaseProtocolFrontendEngineFactory(final String databaseType) {\n            for (DatabaseProtocolFrontendEngine each : ShardingSphereServiceLoader\n                    .newServiceInstances(DatabaseProtocolFrontendEngine.class)) {\n                if (DatabaseTypeRegistry.getActualDatabaseType(databaseType).getName().equals(databaseType)) {\n                    return each;\n                }\n            }\n            throw new UnsupportedOperationException(String.format(\"Cannot support database type '%s'\", databaseType));\n        }\n    }\n"]]}
{"hexsha": "fffc8b15a202472b064537ba02ca8760174f69e2", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(value = \"/api/admin/discovery\", produces = MediaType.APPLICATION_JSON_VALUE)\npublic class AdminDiscoveryResource extends BaseResource {\n    @Inject\n    private ProgramItemService programItemService;\n\n    /**\n     * Gets discovery programs.\n     *\n     * @return the discovery programs\n     */\n    @ApiOperation(value = \"Get DiscoveryPrograms.\", notes = \"<p>Get DiscoveryPrograms.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    List<DiscoverProgramDTO> getDiscoveryPrograms() {\n        List<DiscoveryProgram> discoveryProgramList = programItemService.getDiscoveryPrograms();\n        List<DiscoverProgramDTO> dto = new ArrayList<>();\n        for (DiscoveryProgram dp : discoveryProgramList) {\n            dto.add(DiscoverProgramDTO.valueOf(dp));\n        }\n        return dto;\n    }\n\n    /**\n     * Upsert discovery program discover program dto.\n     *\n     * @param dto the dto\n     * @return the discover program dto\n     */\n    @ApiOperation(value = \"Upsert DiscoveryProgram.\", notes = \"<p>Upsert DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.PUT)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    DiscoverProgramDTO upsertDiscoveryProgram(@RequestBody DiscoverProgramDTO dto) {\n        DiscoveryProgram dp = programItemService.upsertDiscoveryProgram(dto.getId(), dto.getProgramId(),\n                dto.getActive(), dto.getType(), dto.getDiscoveryProgramText());\n        return DiscoverProgramDTO.valueOf(dp);\n\n    }\n\n    /**\n     * Delete discovery program.\n     *\n     * @param discoveryProgramId the discovery program id\n     */\n    @ApiOperation(value = \"Delete the given DiscoveryProgram.\", notes = \"<p>Delete the given DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/{discoveryProgramId}\", method = RequestMethod.DELETE)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public void deleteDiscoveryProgram(@PathVariable Long discoveryProgramId) {\n        programItemService.deleteDiscoveryProgram(discoveryProgramId);\n    }\n\n    /**\n     * Gets discover type list.\n     *\n     * @return the discover type list\n     */\n    @ApiOperation(value = \"Get discover types\", notes = \"<p>Get list of discover types.</p>\")\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public List<DiscoveryProgramType> getDiscoverTypeList() {\n        return DiscoveryProgramType.getAllTypes();\n    }\n}", "class_id": 0, "repo": "openlearningplatformlxp/lxp", "file": "webapp/src/main/java/com/redhat/uxl/webapp/web/rest/admin/AdminDiscoveryResource.java", "last_update_at": "2021-02-17T15:38:01+00:00", "question_id": "fffc8b15a202472b064537ba02ca8760174f69e2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(value = \"/api/admin/discovery\", produces = MediaType.APPLICATION_JSON_VALUE)\npublic class AdminDiscoveryResource extends BaseResource {\n    @Inject\n    private ProgramItemService programItemService;\n    /**\n     * Gets discovery programs.\n     *\n     * @return the discovery programs\n     */\n    @ApiOperation(value = \"Get DiscoveryPrograms.\", notes = \"<p>Get DiscoveryPrograms.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    List<DiscoverProgramDTO> getDiscoveryPrograms() {\n        List<DiscoveryProgram> discoveryProgramList = programItemService.getDiscoveryPrograms();\n        List<DiscoverProgramDTO> dto = new ArrayList<>();\n        for (DiscoveryProgram dp : discoveryProgramList) {\n            dto.add(DiscoverProgramDTO.valueOf(dp));\n        }\n        return dto;\n    }\n    /**\n     * Upsert discovery program discover program dto.\n     *\n     * @param dto the dto\n     * @return the discover program dto\n     */\n    @ApiOperation(value = \"Upsert DiscoveryProgram.\", notes = \"<p>Upsert DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.PUT)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    DiscoverProgramDTO upsertDiscoveryProgram(@RequestBody DiscoverProgramDTO dto) {\n        DiscoveryProgram dp = programItemService.upsertDiscoveryProgram(dto.getId(), dto.getProgramId(),\n                dto.getActive(), dto.getType(), dto.getDiscoveryProgramText());\n        return DiscoverProgramDTO.valueOf(dp);\n    }\n    /**\n     * Delete discovery program.\n     *\n     * @param discoveryProgramId the discovery program id\n     */\n    @ApiOperation(value = \"Delete the given DiscoveryProgram.\", notes = \"<p>Delete the given DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/{discoveryProgramId}\", method = RequestMethod.DELETE)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public void deleteDiscoveryProgram(@PathVariable Long discoveryProgramId) {\n        programItemService.deleteDiscoveryProgram(discoveryProgramId);\n    }\n    /**\n     * Gets discover type list.\n     *\n     * @return the discover type list\n     */\n    @ApiOperation(value = \"Get discover types\", notes = \"<p>Get list of discover types.</p>\")\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public List<DiscoveryProgramType> getDiscoverTypeList() {\n        return DiscoveryProgramType.getAllTypes();\n    }\n"]]}
{"hexsha": "b7d655e96b2368219f57e0cb9f77e5529aa81369", "ext": "java", "lang": "Java", "content": "public class FixLengthConf {\n\n\tpublic List<FixLengthMessageIn> getConf() {\n\n\t\tList<FixLengthMessageIn> flconf = new ArrayList<FixLengthMessageIn>();\n\t\tResource resource = new ClassPathResource(\"classpath:FixLengthConfig.xml\");\n\t\ttry {\n\n//\t\t\tFile fXmlFile = new File(\"src/main/resources/FixLengthConfig.xml\");\n\t\t\t// File fXmlFile = readXml(resource.getInputStream());\n\t\t\tDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n\t\t\t// Document doc = dBuilder.parse(fXmlFile);\n\t\t\tDocument doc = readXml(resource.getInputStream());\n\t\t\t// optional, but recommended\n\t\t\t// read this -\n\t\t\t// http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work\n\t\t\tdoc.getDocumentElement().normalize();\n\n\t\t\tSystem.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n\n\t\t\tNodeList nList = doc.getElementsByTagName(\"field\");\n\n\t\t\tSystem.out.println(\"----------------------------\");\n\n\t\t\tfor (int temp = 0; temp < nList.getLength(); temp++) {\n\n\t\t\t\tNode nNode = nList.item(temp);\n\n//\t\t\t\tSystem.out.println(\"\\nCurrent Element :\" + nNode.getNodeName());\n\n\t\t\t\tif (nNode.getNodeType() == Node.ELEMENT_NODE) {\n\n\t\t\t\t\tElement eElement = (Element) nNode;\n//\n//\t\t\t\t\tSystem.out.println(\"Field name : \" + eElement.getAttribute(\"name\"));\n//\t\t\t\t\tSystem.out.println(\"start : \" + eElement.getElementsByTagName(\"start\").item(0).getTextContent());\n//\t\t\t\t\tSystem.out.println(\"end : \" + eElement.getElementsByTagName(\"end\").item(0).getTextContent());\n\t\t\t\t\tflconf.add(new FixLengthMessageIn(eElement.getAttribute(\"name\").toString(),\n\t\t\t\t\t\t\teElement.getElementsByTagName(\"start\").item(0).getTextContent().toString(),\n\t\t\t\t\t\t\teElement.getElementsByTagName(\"end\").item(0).getTextContent().toString(), \"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn flconf;\n\t}\n\n\tpublic static Document readXml(InputStream is) throws SAXException, IOException, ParserConfigurationException {\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n\t\tdbf.setValidating(false);\n\t\tdbf.setIgnoringComments(false);\n\t\tdbf.setIgnoringElementContentWhitespace(true);\n\t\tdbf.setNamespaceAware(true);\n\t\t// dbf.setCoalescing(true);\n\t\t// dbf.setExpandEntityReferences(true);\n\n\t\tDocumentBuilder db = null;\n\t\tdb = dbf.newDocumentBuilder();\n\t\tdb.setEntityResolver(new NullResolver());\n\n\t\t// db.setErrorHandler( new MyErrorHandler());\n\n\t\treturn db.parse(is);\n\t}\n}", "class_id": 0, "repo": "arkenabd/fuse-out-rest", "file": "src/main/java/com/netty/fuse/util/FixLengthConf.java", "last_update_at": "2021-12-14T21:40:22+00:00", "question_id": "b7d655e96b2368219f57e0cb9f77e5529aa81369", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FixLengthConf {\n\tpublic List<FixLengthMessageIn> getConf() {\n\t\tList<FixLengthMessageIn> flconf = new ArrayList<FixLengthMessageIn>();\n\t\tResource resource = new ClassPathResource(\"classpath:FixLengthConfig.xml\");\n\t\ttry {\n//\t\t\tFile fXmlFile = new File(\"src/main/resources/FixLengthConfig.xml\");\n\t\t\t// File fXmlFile = readXml(resource.getInputStream());\n\t\t\tDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n\t\t\t// Document doc = dBuilder.parse(fXmlFile);\n\t\t\tDocument doc = readXml(resource.getInputStream());\n\t\t\t// optional, but recommended\n\t\t\t// read this -\n\t\t\t// http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work\n\t\t\tdoc.getDocumentElement().normalize();\n\t\t\tSystem.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n\t\t\tNodeList nList = doc.getElementsByTagName(\"field\");\n\t\t\tSystem.out.println(\"----------------------------\");\n\t\t\tfor (int temp = 0; temp < nList.getLength(); temp++) {\n\t\t\t\tNode nNode = nList.item(temp);\n//\t\t\t\tSystem.out.println(\"\\nCurrent Element :\" + nNode.getNodeName());\n\t\t\t\tif (nNode.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\t\tElement eElement = (Element) nNode;\n//\n//\t\t\t\t\tSystem.out.println(\"Field name : \" + eElement.getAttribute(\"name\"));\n//\t\t\t\t\tSystem.out.println(\"start : \" + eElement.getElementsByTagName(\"start\").item(0).getTextContent());\n//\t\t\t\t\tSystem.out.println(\"end : \" + eElement.getElementsByTagName(\"end\").item(0).getTextContent());\n\t\t\t\t\tflconf.add(new FixLengthMessageIn(eElement.getAttribute(\"name\").toString(),\n\t\t\t\t\t\t\teElement.getElementsByTagName(\"start\").item(0).getTextContent().toString(),\n\t\t\t\t\t\t\teElement.getElementsByTagName(\"end\").item(0).getTextContent().toString(), \"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn flconf;\n\t}\n\tpublic static Document readXml(InputStream is) throws SAXException, IOException, ParserConfigurationException {\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\t\tdbf.setValidating(false);\n\t\tdbf.setIgnoringComments(false);\n\t\tdbf.setIgnoringElementContentWhitespace(true);\n\t\tdbf.setNamespaceAware(true);\n\t\t// dbf.setCoalescing(true);\n\t\t// dbf.setExpandEntityReferences(true);\n\t\tDocumentBuilder db = null;\n\t\tdb = dbf.newDocumentBuilder();\n\t\tdb.setEntityResolver(new NullResolver());\n\t\t// db.setErrorHandler( new MyErrorHandler());\n\t\treturn db.parse(is);\n\t}\n"]]}
{"hexsha": "e4df3fd07315c7a35d07ed02243925bb9e0e5835", "ext": "java", "lang": "Java", "content": "@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(loader = TestWebContextLoader.class, locations = { \"classpath:test-webmvc-config.xml\", })\npublic class ReportResourceTest {\n\n\t@Autowired\n\tprotected WebApplicationContext webApplicationContext;\n\n\tprivate MockMvc mockMvc;\n\n\tprotected ObjectMapper mapper = new ObjectMapper();\n\n\tprivate final String BASE_URL = \"/rest/report/\";\n\tprivate final String expectedReport = \"{\\n\"\n\t\t+ \"\\t\\\"reports\\\": \\\"[{\\\\\\\"baseEntityId\\\\\\\":\\\\\\\"22\\\\\\\",\\\\\\\"locationId\\\\\\\":\\\\\\\"testLocationId\\\\\\\",\\\\\\\"reportType\\\\\\\":\\\\\\\"testReportType\\\\\\\",\\\\\\\"formSubmissionId\\\\\\\":\\\\\\\"testFormSubmissionId\\\\\\\",\\\\\\\"providerId\\\\\\\":\\\\\\\"testProviderId\\\\\\\",\\\\\\\"status\\\\\\\":\\\\\\\"test\\\\\\\"}]\\\"\\n\"\n\t\t+ \"}\";\n\tprivate final String INVALID_JSON = \"{\\n\"\n\t\t\t+ \"\\t\\\"reports\\\": {\\n\"\n\t\t\t+ \"\\t\\t\\\"baseEntityId\\\": \\\"22\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"locationId\\\": \\\"testLocationId\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"reportType\\\": \\\"testReportType\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"formSubmissionId\\\": \\\"testFormSubmissionId\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"providerId\\\": \\\"testProviderId\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"status\\\": \\\"test\\\"\\n\"\n\t\t\t+ \"\\t}\\n\"\n\t\t\t+ \"}\";\n\t\n\t@InjectMocks\n\tprivate ReportResource reportResource;\n\n\t@Mock\n\tprivate ReportService reportService;\n\n\t@Before\n\tpublic void setUp() {\n\t\tMockitoAnnotations.initMocks(this);\n\t\tmockMvc = org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup(reportResource)\n\t\t\t\t.addFilter(new CrossSiteScriptingPreventionFilter(), \"/*\")\n\t\t\t\t.build();\n\t}\n\n\t@Test\n\tpublic void testSaveWithException() throws Exception {\n\t\tMvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(\"\".getBytes()))\n\t\t\t\t.andExpect(status().isBadRequest()).andReturn();\n\t}\n\n\t@Test\n\tpublic void testSave() throws Exception {\n\t\twhen(reportService.addorUpdateReport(any(Report.class))).thenReturn(createReport());\n\t\tMvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(expectedReport.getBytes()))\n\t\t\t\t.andExpect(status().isCreated()).andReturn();\n\t\tString responseString = result.getResponse().getContentAsString();\n\t\tassertEquals(responseString, \"\");\n\t}\n\n\t@Test\n\tpublic void testSaveWithInvalidJson() throws Exception {\n\t\tMvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(INVALID_JSON.getBytes()))\n\t\t\t\t.andExpect(status().isInternalServerError()).andReturn();\n\n\t\tString responseString = result.getResponse().getContentAsString();\n\t\tassertEquals(responseString, \"\");\n\t}\n\t\n\tprivate Report createReport() {\n\t\tReport report = new Report();\n         report.setId(\"Test-ID\");\n         report.setLocationId(\"locationId\");\n         report.setProviderId(\"providerId\");\n         report.setStatus(\"test\");\n         report.setReportType(\"reportType\");\n         report.setFormSubmissionId(\"formSubmissionId\");\n         return report;\n\t}\n\t\n}", "class_id": 0, "repo": "codacy-badger/opensrp-server-web", "file": "src/test/java/org/opensrp/web/rest/ReportResourceTest.java", "last_update_at": "2021-02-04T11:39:14+00:00", "question_id": "e4df3fd07315c7a35d07ed02243925bb9e0e5835", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(loader = TestWebContextLoader.class, locations = { \"classpath:test-webmvc-config.xml\", })\npublic class ReportResourceTest {\n\t@Autowired\n\tprotected WebApplicationContext webApplicationContext;\n\tprivate MockMvc mockMvc;\n\tprotected ObjectMapper mapper = new ObjectMapper();\n\tprivate final String BASE_URL = \"/rest/report/\";\n\tprivate final String expectedReport = \"{\\n\"\n\t\t+ \"\\t\\\"reports\\\": \\\"[{\\\\\\\"baseEntityId\\\\\\\":\\\\\\\"22\\\\\\\",\\\\\\\"locationId\\\\\\\":\\\\\\\"testLocationId\\\\\\\",\\\\\\\"reportType\\\\\\\":\\\\\\\"testReportType\\\\\\\",\\\\\\\"formSubmissionId\\\\\\\":\\\\\\\"testFormSubmissionId\\\\\\\",\\\\\\\"providerId\\\\\\\":\\\\\\\"testProviderId\\\\\\\",\\\\\\\"status\\\\\\\":\\\\\\\"test\\\\\\\"}]\\\"\\n\"\n\t\t+ \"}\";\n\tprivate final String INVALID_JSON = \"{\\n\"\n\t\t\t+ \"\\t\\\"reports\\\": {\\n\"\n\t\t\t+ \"\\t\\t\\\"baseEntityId\\\": \\\"22\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"locationId\\\": \\\"testLocationId\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"reportType\\\": \\\"testReportType\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"formSubmissionId\\\": \\\"testFormSubmissionId\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"providerId\\\": \\\"testProviderId\\\",\\n\"\n\t\t\t+ \"\\t\\t\\\"status\\\": \\\"test\\\"\\n\"\n\t\t\t+ \"\\t}\\n\"\n\t\t\t+ \"}\";\n\t\n\t@InjectMocks\n\tprivate ReportResource reportResource;\n\t@Mock\n\tprivate ReportService reportService;\n\t@Before\n\tpublic void setUp() {\n\t\tMockitoAnnotations.initMocks(this);\n\t\tmockMvc = org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup(reportResource)\n\t\t\t\t.addFilter(new CrossSiteScriptingPreventionFilter(), \"/*\")\n\t\t\t\t.build();\n\t}\n\t@Test\n\tpublic void testSaveWithException() throws Exception {\n\t\tMvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(\"\".getBytes()))\n\t\t\t\t.andExpect(status().isBadRequest()).andReturn();\n\t}\n\t@Test\n\tpublic void testSave() throws Exception {\n\t\twhen(reportService.addorUpdateReport(any(Report.class))).thenReturn(createReport());\n\t\tMvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(expectedReport.getBytes()))\n\t\t\t\t.andExpect(status().isCreated()).andReturn();\n\t\tString responseString = result.getResponse().getContentAsString();\n\t\tassertEquals(responseString, \"\");\n\t}\n\t@Test\n\tpublic void testSaveWithInvalidJson() throws Exception {\n\t\tMvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(INVALID_JSON.getBytes()))\n\t\t\t\t.andExpect(status().isInternalServerError()).andReturn();\n\t\tString responseString = result.getResponse().getContentAsString();\n\t\tassertEquals(responseString, \"\");\n\t}\n\t\n\tprivate Report createReport() {\n\t\tReport report = new Report();\n         report.setId(\"Test-ID\");\n         report.setLocationId(\"locationId\");\n         report.setProviderId(\"providerId\");\n         report.setStatus(\"test\");\n         report.setReportType(\"reportType\");\n         report.setFormSubmissionId(\"formSubmissionId\");\n         return report;\n\t}\n\t\n"]]}
