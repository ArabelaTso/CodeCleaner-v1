{"hexsha": "b08a80f53c729d0b170df6c3806811715adb16ff", "ext": "java", "lang": "Java", "content": "public class BitstreamReader extends AbstractReader implements Recyclable {\n\n    private static Logger log = Logger.getLogger(BitstreamReader.class);\n\n    /**\n     * Messages to be sent when the user is not authorized to view\n     * a particular bitstream. They will be redirected to the login\n     * where this message will be displayed.\n     */\n    private static final String AUTH_REQUIRED_HEADER = \"xmlui.BitstreamReader.auth_header\";\n\n    private static final String AUTH_REQUIRED_MESSAGE = \"xmlui.BitstreamReader.auth_message\";\n\n    /**\n     * How big a buffer should we use when reading from the bitstream before\n     * writing to the HTTP response?\n     */\n    protected static final int BUFFER_SIZE = 8192;\n\n    /**\n     * When should a bitstream expire in milliseconds. This should be set to\n     * some low value just to prevent someone hiting DSpace repeatedy from\n     * killing the server. Note: there are 1000 milliseconds in a second.\n     *\n     * Format: minutes * seconds * milliseconds\n     *  60 * 60 * 1000 == 1 hour\n     */\n    protected static final int expires = 60 * 60 * 1000;\n\n    /**\n     * The Cocoon response\n     */\n    protected Response response;\n\n    /**\n     * The Cocoon request\n     */\n    protected Request request;\n\n    /**\n     * The bitstream file\n     */\n    protected InputStream bitstreamInputStream;\n\n    /**\n     * The bitstream's reported size\n     */\n    protected long bitstreamSize;\n\n    /**\n     * The bitstream's mime-type\n     */\n    protected String bitstreamMimeType;\n\n    /**\n     * The bitstream's name\n     */\n    protected String bitstreamName;\n\n    /**\n     * True if bitstream is readable by anonymous users\n     */\n    protected boolean isAnonymouslyReadable;\n\n    /**\n     * The last modified date of the item containing the bitstream\n     */\n    private Date itemLastModified = null;\n\n    /**\n     * True if user agent making this request was identified as spider.\n     */\n    private boolean isSpider = false;\n\n    /**\n     * TEMP file for citation PDF. We will save here, so we can delete the temp file when done.\n     */\n    private File tempFile;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n\n    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();\n\n    /**\n     * Set up the bitstream reader.\n     *\n     * See the class description for information on configuration options.\n     * @param resolver source resolver.\n     * @param objectModel Cocoon object model.\n     * @param src source to read.\n     * @param par Reader parameters.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) throws ProcessingException, SAXException, IOException {\n        super.setup(resolver, objectModel, src, par);\n        try {\n            this.request = ObjectModelHelper.getRequest(objectModel);\n            this.response = ObjectModelHelper.getResponse(objectModel);\n            Item item = null;\n            // normal processes will close it.\n            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);\n            Context context = ContextUtil.obtainContext(objectModel);\n            // Get our parameters that identify the bitstream\n            String itemID = par.getParameter(\"itemID\", null);\n            String bitstreamID = par.getParameter(\"bitstreamID\", null);\n            String handle = par.getParameter(\"handle\", null);\n            int sequence = par.getParameterAsInteger(\"sequence\", -1);\n            String name = par.getParameter(\"name\", null);\n            this.isSpider = par.getParameter(\"userAgent\", \"\").equals(\"spider\");\n            // Resolve the bitstream\n            Bitstream bitstream = null;\n            DSpaceObject dso = null;\n            if (bitstreamID != null) {\n                // Direct reference to the individual bitstream ID.\n                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);\n            } else if (itemID != null) {\n                // Referenced by internal itemID\n                item = itemService.findByIdOrLegacyId(context, itemID);\n                if (sequence > -1) {\n                    bitstream = findBitstreamBySequence(item, sequence);\n                } else if (name != null) {\n                    bitstream = findBitstreamByName(item, name);\n                }\n            } else if (handle != null) {\n                // Reference by an item's handle.\n                dso = handleService.resolveToObject(context, handle);\n                if (dso instanceof Item) {\n                    item = (Item) dso;\n                    if (sequence > -1) {\n                        bitstream = findBitstreamBySequence(item, sequence);\n                    } else if (name != null) {\n                        bitstream = findBitstreamByName(item, name);\n                    }\n                }\n            }\n            if (item != null) {\n                itemLastModified = item.getLastModified();\n            }\n            // then try to find bitstream by name (assuming we have a file name)\n            if ((sequence > -1 && bitstream == null) && name != null) {\n                bitstream = findBitstreamByName(item, name);\n                // if we found bitstream by name, send a redirect to its new sequence number location\n                if (bitstream != null) {\n                    String redirectURL = \"\";\n                    // build redirect URL based on whether item has a handle assigned yet\n                    if (item.getHandle() != null && item.getHandle().length() > 0) {\n                        redirectURL = request.getContextPath() + \"/bitstream/handle/\" + item.getHandle();\n                    } else {\n                        redirectURL = request.getContextPath() + \"/bitstream/item/\" + item.getID();\n                    }\n                    redirectURL += \"/\" + name + \"?sequence=\" + bitstream.getSequenceID();\n                    HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                    httpResponse.sendRedirect(redirectURL);\n                    return;\n                }\n            }\n            // Was a bitstream found?\n            if (bitstream == null) {\n                throw new ResourceNotFoundException(\"Unable to locate bitstream\");\n            }\n            // Is there a User logged in and does the user have access to read it?\n            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);\n            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context)) {\n                isAuthorized = false;\n                log.info(LogManager.getHeader(context, \"view_bitstream\", \"handle=\" + item.getHandle() + \",withdrawn=true\"));\n            }\n            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request\n            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\");\n            if (!isAuthorized) {\n                if (context.getCurrentUser() != null || StringUtils.equalsIgnoreCase(\"all\", requestItemType)) {\n                    // message that tells them the bitstream is restricted.\n                    String redictURL = request.getContextPath() + \"/handle/\";\n                    if (item != null) {\n                        redictURL += item.getHandle();\n                    } else if (dso != null) {\n                        redictURL += dso.getHandle();\n                    }\n                    redictURL += \"/restricted-resource?bitstreamId=\" + bitstream.getID();\n                    HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                    httpResponse.sendRedirect(redictURL);\n                    return;\n                } else {\n                    if (StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\")) || DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\").equalsIgnoreCase(\"logged\")) {\n                        // successful, their request will be resumed.\n                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);\n                        // Redirect\n                        String redictURL = request.getContextPath() + \"/login\";\n                        HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                    }\n                }\n            }\n            // 3) This object is citation-able\n            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {\n                // on-the-fly citation generator\n                log.info(item.getHandle() + \" - \" + bitstream.getName() + \" is citable.\");\n                FileInputStream fileInputStream = null;\n                try {\n                    //Create the cited document\n                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);\n                    if (tempFile == null) {\n                        log.error(\"CitedDocument was null\");\n                    } else {\n                        log.info(\"CitedDocument was ok,\" + tempFile.getAbsolutePath());\n                    }\n                    fileInputStream = new FileInputStream(tempFile);\n                    if (fileInputStream == null) {\n                        log.error(\"Error opening fileInputStream: \");\n                    }\n                    this.bitstreamInputStream = fileInputStream;\n                    this.bitstreamSize = tempFile.length();\n                } catch (Exception e) {\n                    log.error(\"Caught an error with intercepting the citation document:\" + e.getMessage());\n                }\n            } else {\n                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);\n                this.bitstreamSize = bitstream.getSize();\n            }\n            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();\n            this.bitstreamName = bitstream.getName();\n            if (context.getCurrentUser() == null) {\n                this.isAnonymouslyReadable = true;\n            } else {\n                this.isAnonymouslyReadable = false;\n                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ)) {\n                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS)) {\n                        this.isAnonymouslyReadable = true;\n                    }\n                }\n            }\n            // Trim any path information from the bitstream\n            if (bitstreamName != null && bitstreamName.length() > 0) {\n                int finalSlashIndex = bitstreamName.lastIndexOf('/');\n                if (finalSlashIndex > 0) {\n                    bitstreamName = bitstreamName.substring(finalSlashIndex + 1);\n                }\n            } else {\n                // In-case there is no bitstream name...\n                if (name != null && name.length() > 0) {\n                    bitstreamName = name;\n                    if (name.endsWith(\".jpg\")) {\n                        bitstreamMimeType = \"image/jpeg\";\n                    } else if (name.endsWith(\".png\")) {\n                        bitstreamMimeType = \"image/png\";\n                    }\n                } else {\n                    bitstreamName = \"bitstream\";\n                }\n            }\n            // of adding it to the sitemap for every possible bitstream uri is not very tractable\n            DSpaceServicesFactory.getInstance().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW, ObjectModelHelper.getRequest(objectModel), ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)), bitstream));\n            // If we created the database connection close it, otherwise leave it open.\n            if (BitstreamReaderOpenedContext)\n                context.complete();\n        } catch (SQLException sqle) {\n            throw new ProcessingException(\"Unable to read bitstream.\", sqle);\n        } catch (AuthorizeException ae) {\n            throw new ProcessingException(\"Unable to read bitstream.\", ae);\n        }\n    }\n\n    /**\n     * Find the bitstream identified by a sequence number on this item.\n     *\n     * @param item A DSpace item\n     * @param sequence The sequence of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException {\n        if (item == null) {\n            return null;\n        }\n        List<Bundle> bundles = item.getBundles();\n        for (Bundle bundle : bundles) {\n            List<Bitstream> bitstreams = bundle.getBitstreams();\n            for (Bitstream bitstream : bitstreams) {\n                if (bitstream.getSequenceID() == sequence) {\n                    return bitstream;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Return the bitstream from the given item that is identified by the\n     * given name. If the name has prepended directories they will be removed\n     * one at a time until a bitstream is found. Note that if two bitstreams\n     * have the same name then the first bitstream will be returned.\n     *\n     * @param item A DSpace item\n     * @param name The name of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamByName(Item item, String name) throws SQLException {\n        if (name == null || item == null) {\n            return null;\n        }\n        // Determine our the maximum number of directories that will be removed for a path.\n        int maxDepthPathSearch = 3;\n        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"xmlui.html.max-depth-guess\") != null) {\n            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.html.max-depth-guess\");\n        }\n        int i = 0;\n        while (i < maxDepthPathSearch + 1) try {\n            // if the name can be found\n            List<Bundle> bundles = item.getBundles();\n            for (Bundle bundle : bundles) {\n                List<Bitstream> bitstreams = bundle.getBitstreams();\n                for (Bitstream bitstream : bitstreams) {\n                    if (name.equals(bitstream.getName())) {\n                        return bitstream;\n                    }\n                }\n            }\n            // off of the name and see if we lost some path information.\n            int indexOfSlash = name.indexOf('/');\n            if (indexOfSlash < 0) {\n                // bitstream found.\n                return null;\n            }\n            name = name.substring(indexOfSlash + 1);\n            // trim everything and only use the trailing filename.\n            if (i == maxDepthPathSearch - 1) {\n                int indexOfLastSlash = name.lastIndexOf('/');\n                if (indexOfLastSlash > -1) {\n                    name = name.substring(indexOfLastSlash + 1);\n                }\n            }\n        } finally {\n            i++;\n        }\n        // we search.\n        return null;\n    }\n\n    /**\n     * Write the actual data out to the response.\n     *\n     * Some implementation notes:\n     *\n     * 1) We set a short expiration time just in the hopes of preventing someone\n     * from overloading the server by clicking reload a bunch of times. I\n     * Realize that this is nowhere near 100% effective but it may help in some\n     * cases and shouldn't hurt anything.\n     *\n     * 2) We accept partial downloads, thus if you lose a connection halfway\n     * through most web browser will enable you to resume downloading the\n     * bitstream.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     */\n    @Override\n    public void generate() throws IOException, SAXException, ProcessingException {\n        if (this.bitstreamInputStream == null) {\n            return;\n        }\n        // that might change with different authentication.\n        if (isSpider) {\n            // Check for if-modified-since header -- ONLY if not authenticated\n            long modSince = request.getDateHeader(\"If-Modified-Since\");\n            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince) {\n                // hence bitstream has not been, either; return 304\n                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n        }\n        // users in the cache for a response later to anonymous user.\n        try {\n            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null)) {\n                // we don't have last-mod dates for Bitstreams\n                response.setDateHeader(\"Last-Modified\", itemLastModified.getTime());\n            }\n        } catch (SQLException e) {\n            throw new ProcessingException(e);\n        }\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int length = -1;\n        // if it is accessed anonymously or is readable by Anonymous:\n        if (isAnonymouslyReadable) {\n            response.setDateHeader(\"Expires\", System.currentTimeMillis() + expires);\n        }\n        // If this is a large bitstream then tell the browser it should treat it as a download.\n        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.content_disposition_threshold\");\n        if (bitstreamSize > threshold && threshold != 0) {\n            String name = bitstreamName;\n            // Try and make the download file name formatted for each browser.\n            try {\n                String agent = request.getHeader(\"USER-AGENT\");\n                if (agent != null && agent.contains(\"MSIE\")) {\n                    name = URLEncoder.encode(name, \"UTF8\");\n                } else if (agent != null && agent.contains(\"Mozilla\")) {\n                    name = MimeUtility.encodeText(name, \"UTF8\", \"B\");\n                }\n            } catch (UnsupportedEncodingException see) {\n            }\n            response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + '\"' + name + '\"');\n        }\n        ByteRange byteRange = null;\n        try {\n            if (byteRange != null) {\n                String entityLength;\n                String entityRange;\n                //VT\n                ByteRange requestedRange = null;\n                if (this.bitstreamSize != -1) {\n                    entityLength = \"\" + this.bitstreamSize;\n                    //VT        new ByteRange(0, this.bitstreamSize)).toString();\n                    requestedRange = byteRange.intersection(new ByteRange(0, this.bitstreamSize - 1));\n                    entityRange = requestedRange.toString();\n                } else {\n                    entityLength = \"*\";\n                    entityRange = byteRange.toString();\n                }\n                response.setHeader(\"Content-Range\", entityRange + \"/\" + entityLength);\n                if (response instanceof HttpResponse) {\n                    // Response with status 206 (Partial content)\n                    response.setStatus(206);\n                }\n                int pos = 0;\n                int posEnd;\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1) {\n                    posEnd = pos + length - 1;\n                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));\n                    if (intersection != null) {\n                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());\n                    }\n                    pos += length;\n                }\n            } else {\n                response.setHeader(\"Content-Length\", String.valueOf(this.bitstreamSize));\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1) {\n                    out.write(buffer, 0, length);\n                }\n                out.flush();\n            }\n        } finally {\n            try {\n                // Close the bitstream input stream so that we don't leak a file descriptor\n                this.bitstreamInputStream.close();\n                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html\n                out.close();\n            } catch (IOException ioe) {\n                // No point since the user has already got the bitstream contents.\n                log.warn(\"Caught IO exception when closing a stream: \" + ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * Returns the mime-type of the bitstream.\n     * @return the type.\n     */\n    @Override\n    public String getMimeType() {\n        return this.bitstreamMimeType;\n    }\n\n    /**\n     * Recycle\n     */\n    @Override\n    public void recycle() {\n        this.response = null;\n        this.request = null;\n        this.bitstreamInputStream = null;\n        this.bitstreamSize = 0;\n        this.bitstreamMimeType = null;\n        this.bitstreamName = null;\n        this.itemLastModified = null;\n        this.tempFile = null;\n        super.recycle();\n    }\n}\n", "class_id": 0, "repo": "sunakshitejwani/testOER", "file": "dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/BitstreamReader.java", "last_update_at": "2021-02-13T18:35:31+00:00", "original_content": "public class BitstreamReader extends AbstractReader implements Recyclable {\n\n    private static Logger log = Logger.getLogger(BitstreamReader.class);\n\n    /**\n     * Messages to be sent when the user is not authorized to view\n     * a particular bitstream. They will be redirected to the login\n     * where this message will be displayed.\n     */\n    private static final String AUTH_REQUIRED_HEADER = \"xmlui.BitstreamReader.auth_header\";\n\n    private static final String AUTH_REQUIRED_MESSAGE = \"xmlui.BitstreamReader.auth_message\";\n\n    /**\n     * How big a buffer should we use when reading from the bitstream before\n     * writing to the HTTP response?\n     */\n    protected static final int BUFFER_SIZE = 8192;\n\n    /**\n     * When should a bitstream expire in milliseconds. This should be set to\n     * some low value just to prevent someone hiting DSpace repeatedy from\n     * killing the server. Note: there are 1000 milliseconds in a second.\n     *\n     * Format: minutes * seconds * milliseconds\n     *  60 * 60 * 1000 == 1 hour\n     */\n    protected static final int expires = 60 * 60 * 1000;\n\n    /**\n     * The Cocoon response\n     */\n    protected Response response;\n\n    /**\n     * The Cocoon request\n     */\n    protected Request request;\n\n    /**\n     * The bitstream file\n     */\n    protected InputStream bitstreamInputStream;\n\n    /**\n     * The bitstream's reported size\n     */\n    protected long bitstreamSize;\n\n    /**\n     * The bitstream's mime-type\n     */\n    protected String bitstreamMimeType;\n\n    /**\n     * The bitstream's name\n     */\n    protected String bitstreamName;\n\n    /**\n     * True if bitstream is readable by anonymous users\n     */\n    protected boolean isAnonymouslyReadable;\n\n    /**\n     * The last modified date of the item containing the bitstream\n     */\n    private Date itemLastModified = null;\n\n    /**\n     * True if user agent making this request was identified as spider.\n     */\n    private boolean isSpider = false;\n\n    /**\n     * TEMP file for citation PDF. We will save here, so we can delete the temp file when done.\n     */\n    private File tempFile;\n\n    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n\n    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n\n    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n\n    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n\n    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();\n\n    /**\n     * Set up the bitstream reader.\n     *\n     * See the class description for information on configuration options.\n     * @param resolver source resolver.\n     * @param objectModel Cocoon object model.\n     * @param src source to read.\n     * @param par Reader parameters.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws java.io.IOException passed through.\n     */\n    @Override\n    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) throws ProcessingException, SAXException, IOException {\n        super.setup(resolver, objectModel, src, par);\n        try {\n            this.request = ObjectModelHelper.getRequest(objectModel);\n            this.response = ObjectModelHelper.getResponse(objectModel);\n            Item item = null;\n            // normal processes will close it.\n            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);\n            Context context = ContextUtil.obtainContext(objectModel);\n            // Get our parameters that identify the bitstream\n            String itemID = par.getParameter(\"itemID\", null);\n            String bitstreamID = par.getParameter(\"bitstreamID\", null);\n            String handle = par.getParameter(\"handle\", null);\n            int sequence = par.getParameterAsInteger(\"sequence\", -1);\n            String name = par.getParameter(\"name\", null);\n            this.isSpider = par.getParameter(\"userAgent\", \"\").equals(\"spider\");\n            // Resolve the bitstream\n            Bitstream bitstream = null;\n            DSpaceObject dso = null;\n            if (bitstreamID != null) {\n                // Direct reference to the individual bitstream ID.\n                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);\n            } else if (itemID != null) {\n                // Referenced by internal itemID\n                item = itemService.findByIdOrLegacyId(context, itemID);\n                if (sequence > -1) {\n                    bitstream = findBitstreamBySequence(item, sequence);\n                } else if (name != null) {\n                    bitstream = findBitstreamByName(item, name);\n                }\n            } else if (handle != null) {\n                // Reference by an item's handle.\n                dso = handleService.resolveToObject(context, handle);\n                if (dso instanceof Item) {\n                    item = (Item) dso;\n                    if (sequence > -1) {\n                        bitstream = findBitstreamBySequence(item, sequence);\n                    } else if (name != null) {\n                        bitstream = findBitstreamByName(item, name);\n                    }\n                }\n            }\n            if (item != null) {\n                itemLastModified = item.getLastModified();\n            }\n            // then try to find bitstream by name (assuming we have a file name)\n            if ((sequence > -1 && bitstream == null) && name != null) {\n                bitstream = findBitstreamByName(item, name);\n                // if we found bitstream by name, send a redirect to its new sequence number location\n                if (bitstream != null) {\n                    String redirectURL = \"\";\n                    // build redirect URL based on whether item has a handle assigned yet\n                    if (item.getHandle() != null && item.getHandle().length() > 0) {\n                        redirectURL = request.getContextPath() + \"/bitstream/handle/\" + item.getHandle();\n                    } else {\n                        redirectURL = request.getContextPath() + \"/bitstream/item/\" + item.getID();\n                    }\n                    redirectURL += \"/\" + name + \"?sequence=\" + bitstream.getSequenceID();\n                    HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                    httpResponse.sendRedirect(redirectURL);\n                    return;\n                }\n            }\n            // Was a bitstream found?\n            if (bitstream == null) {\n                throw new ResourceNotFoundException(\"Unable to locate bitstream\");\n            }\n            // Is there a User logged in and does the user have access to read it?\n            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);\n            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context)) {\n                isAuthorized = false;\n                log.info(LogManager.getHeader(context, \"view_bitstream\", \"handle=\" + item.getHandle() + \",withdrawn=true\"));\n            }\n            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request\n            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\");\n            if (!isAuthorized) {\n                if (context.getCurrentUser() != null || StringUtils.equalsIgnoreCase(\"all\", requestItemType)) {\n                    // message that tells them the bitstream is restricted.\n                    String redictURL = request.getContextPath() + \"/handle/\";\n                    if (item != null) {\n                        redictURL += item.getHandle();\n                    } else if (dso != null) {\n                        redictURL += dso.getHandle();\n                    }\n                    redictURL += \"/restricted-resource?bitstreamId=\" + bitstream.getID();\n                    HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                    httpResponse.sendRedirect(redictURL);\n                    return;\n                } else {\n                    if (StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\")) || DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"request.item.type\").equalsIgnoreCase(\"logged\")) {\n                        // successful, their request will be resumed.\n                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);\n                        // Redirect\n                        String redictURL = request.getContextPath() + \"/login\";\n                        HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n                        httpResponse.sendRedirect(redictURL);\n                        return;\n                    }\n                }\n            }\n            // 3) This object is citation-able\n            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {\n                // on-the-fly citation generator\n                log.info(item.getHandle() + \" - \" + bitstream.getName() + \" is citable.\");\n                FileInputStream fileInputStream = null;\n                try {\n                    //Create the cited document\n                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);\n                    if (tempFile == null) {\n                        log.error(\"CitedDocument was null\");\n                    } else {\n                        log.info(\"CitedDocument was ok,\" + tempFile.getAbsolutePath());\n                    }\n                    fileInputStream = new FileInputStream(tempFile);\n                    if (fileInputStream == null) {\n                        log.error(\"Error opening fileInputStream: \");\n                    }\n                    this.bitstreamInputStream = fileInputStream;\n                    this.bitstreamSize = tempFile.length();\n                } catch (Exception e) {\n                    log.error(\"Caught an error with intercepting the citation document:\" + e.getMessage());\n                }\n            } else {\n                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);\n                this.bitstreamSize = bitstream.getSize();\n            }\n            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();\n            this.bitstreamName = bitstream.getName();\n            if (context.getCurrentUser() == null) {\n                this.isAnonymouslyReadable = true;\n            } else {\n                this.isAnonymouslyReadable = false;\n                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ)) {\n                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS)) {\n                        this.isAnonymouslyReadable = true;\n                    }\n                }\n            }\n            // Trim any path information from the bitstream\n            if (bitstreamName != null && bitstreamName.length() > 0) {\n                int finalSlashIndex = bitstreamName.lastIndexOf('/');\n                if (finalSlashIndex > 0) {\n                    bitstreamName = bitstreamName.substring(finalSlashIndex + 1);\n                }\n            } else {\n                // In-case there is no bitstream name...\n                if (name != null && name.length() > 0) {\n                    bitstreamName = name;\n                    if (name.endsWith(\".jpg\")) {\n                        bitstreamMimeType = \"image/jpeg\";\n                    } else if (name.endsWith(\".png\")) {\n                        bitstreamMimeType = \"image/png\";\n                    }\n                } else {\n                    bitstreamName = \"bitstream\";\n                }\n            }\n            // of adding it to the sitemap for every possible bitstream uri is not very tractable\n            DSpaceServicesFactory.getInstance().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW, ObjectModelHelper.getRequest(objectModel), ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)), bitstream));\n            // If we created the database connection close it, otherwise leave it open.\n            if (BitstreamReaderOpenedContext)\n                context.complete();\n        } catch (SQLException sqle) {\n            throw new ProcessingException(\"Unable to read bitstream.\", sqle);\n        } catch (AuthorizeException ae) {\n            throw new ProcessingException(\"Unable to read bitstream.\", ae);\n        }\n    }\n\n    /**\n     * Find the bitstream identified by a sequence number on this item.\n     *\n     * @param item A DSpace item\n     * @param sequence The sequence of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException {\n        if (item == null) {\n            return null;\n        }\n        List<Bundle> bundles = item.getBundles();\n        for (Bundle bundle : bundles) {\n            List<Bitstream> bitstreams = bundle.getBitstreams();\n            for (Bitstream bitstream : bitstreams) {\n                if (bitstream.getSequenceID() == sequence) {\n                    return bitstream;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Return the bitstream from the given item that is identified by the\n     * given name. If the name has prepended directories they will be removed\n     * one at a time until a bitstream is found. Note that if two bitstreams\n     * have the same name then the first bitstream will be returned.\n     *\n     * @param item A DSpace item\n     * @param name The name of the bitstream\n     * @return The bitstream or null if none found.\n     */\n    private Bitstream findBitstreamByName(Item item, String name) throws SQLException {\n        if (name == null || item == null) {\n            return null;\n        }\n        // Determine our the maximum number of directories that will be removed for a path.\n        int maxDepthPathSearch = 3;\n        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty(\"xmlui.html.max-depth-guess\") != null) {\n            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.html.max-depth-guess\");\n        }\n        // loop for a last ditch effort where all directory paths will be removed.\n        for (int i = 0; i < maxDepthPathSearch + 1; i++) {\n            // if the name can be found\n            List<Bundle> bundles = item.getBundles();\n            for (Bundle bundle : bundles) {\n                List<Bitstream> bitstreams = bundle.getBitstreams();\n                for (Bitstream bitstream : bitstreams) {\n                    if (name.equals(bitstream.getName())) {\n                        return bitstream;\n                    }\n                }\n            }\n            // off of the name and see if we lost some path information.\n            int indexOfSlash = name.indexOf('/');\n            if (indexOfSlash < 0) {\n                // bitstream found.\n                return null;\n            }\n            name = name.substring(indexOfSlash + 1);\n            // trim everything and only use the trailing filename.\n            if (i == maxDepthPathSearch - 1) {\n                int indexOfLastSlash = name.lastIndexOf('/');\n                if (indexOfLastSlash > -1) {\n                    name = name.substring(indexOfLastSlash + 1);\n                }\n            }\n        }\n        // we search.\n        return null;\n    }\n\n    /**\n     * Write the actual data out to the response.\n     *\n     * Some implementation notes:\n     *\n     * 1) We set a short expiration time just in the hopes of preventing someone\n     * from overloading the server by clicking reload a bunch of times. I\n     * Realize that this is nowhere near 100% effective but it may help in some\n     * cases and shouldn't hurt anything.\n     *\n     * 2) We accept partial downloads, thus if you lose a connection halfway\n     * through most web browser will enable you to resume downloading the\n     * bitstream.\n     * @throws java.io.IOException passed through.\n     * @throws org.xml.sax.SAXException passed through.\n     * @throws org.apache.cocoon.ProcessingException passed through.\n     */\n    @Override\n    public void generate() throws IOException, SAXException, ProcessingException {\n        if (this.bitstreamInputStream == null) {\n            return;\n        }\n        // that might change with different authentication.\n        if (isSpider) {\n            // Check for if-modified-since header -- ONLY if not authenticated\n            long modSince = request.getDateHeader(\"If-Modified-Since\");\n            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince) {\n                // hence bitstream has not been, either; return 304\n                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n        }\n        // users in the cache for a response later to anonymous user.\n        try {\n            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null)) {\n                // we don't have last-mod dates for Bitstreams\n                response.setDateHeader(\"Last-Modified\", itemLastModified.getTime());\n            }\n        } catch (SQLException e) {\n            throw new ProcessingException(e);\n        }\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int length = -1;\n        // if it is accessed anonymously or is readable by Anonymous:\n        if (isAnonymouslyReadable) {\n            response.setDateHeader(\"Expires\", System.currentTimeMillis() + expires);\n        }\n        // If this is a large bitstream then tell the browser it should treat it as a download.\n        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty(\"xmlui.content_disposition_threshold\");\n        if (bitstreamSize > threshold && threshold != 0) {\n            String name = bitstreamName;\n            // Try and make the download file name formatted for each browser.\n            try {\n                String agent = request.getHeader(\"USER-AGENT\");\n                if (agent != null && agent.contains(\"MSIE\")) {\n                    name = URLEncoder.encode(name, \"UTF8\");\n                } else if (agent != null && agent.contains(\"Mozilla\")) {\n                    name = MimeUtility.encodeText(name, \"UTF8\", \"B\");\n                }\n            } catch (UnsupportedEncodingException see) {\n            }\n            response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + '\"' + name + '\"');\n        }\n        ByteRange byteRange = null;\n        try {\n            if (byteRange != null) {\n                String entityLength;\n                String entityRange;\n                //VT\n                ByteRange requestedRange = null;\n                if (this.bitstreamSize != -1) {\n                    entityLength = \"\" + this.bitstreamSize;\n                    //VT        new ByteRange(0, this.bitstreamSize)).toString();\n                    requestedRange = byteRange.intersection(new ByteRange(0, this.bitstreamSize - 1));\n                    entityRange = requestedRange.toString();\n                } else {\n                    entityLength = \"*\";\n                    entityRange = byteRange.toString();\n                }\n                response.setHeader(\"Content-Range\", entityRange + \"/\" + entityLength);\n                if (response instanceof HttpResponse) {\n                    // Response with status 206 (Partial content)\n                    response.setStatus(206);\n                }\n                int pos = 0;\n                int posEnd;\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1) {\n                    posEnd = pos + length - 1;\n                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));\n                    if (intersection != null) {\n                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());\n                    }\n                    pos += length;\n                }\n            } else {\n                response.setHeader(\"Content-Length\", String.valueOf(this.bitstreamSize));\n                while ((length = this.bitstreamInputStream.read(buffer)) > -1) {\n                    out.write(buffer, 0, length);\n                }\n                out.flush();\n            }\n        } finally {\n            try {\n                // Close the bitstream input stream so that we don't leak a file descriptor\n                this.bitstreamInputStream.close();\n                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html\n                out.close();\n            } catch (IOException ioe) {\n                // No point since the user has already got the bitstream contents.\n                log.warn(\"Caught IO exception when closing a stream: \" + ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * Returns the mime-type of the bitstream.\n     * @return the type.\n     */\n    @Override\n    public String getMimeType() {\n        return this.bitstreamMimeType;\n    }\n\n    /**\n     * Recycle\n     */\n    @Override\n    public void recycle() {\n        this.response = null;\n        this.request = null;\n        this.bitstreamInputStream = null;\n        this.bitstreamSize = 0;\n        this.bitstreamMimeType = null;\n        this.bitstreamName = null;\n        this.itemLastModified = null;\n        this.tempFile = null;\n        super.recycle();\n    }\n}\n", "refactored": true}
{"hexsha": "9070530deb7f6fef01876b2859a32446ef3c2a06", "ext": "java", "lang": "Java", "content": "@NativeTag\n@Execution(ExecutionMode.SAME_THREAD)\npublic class InfNanTests extends BaseNd4jTestWithBackends {\n\n    @BeforeEach\n    public void setUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());\n    }\n\n    @AfterEach\n    public void cleanUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).checkForINF(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).checkForINF(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf3(Nd4jBackend backend) {\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN3(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n}\n", "class_id": 0, "repo": "showkawa/deeplearning4j", "file": "nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/linalg/profiling/InfNanTests.java", "last_update_at": "2021-09-01T06:59:10+00:00", "original_content": "@NativeTag\n@Execution(ExecutionMode.SAME_THREAD)\npublic class InfNanTests extends BaseNd4jTestWithBackends {\n\n    @BeforeEach\n    public void setUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());\n    }\n\n    @AfterEach\n    public void cleanUp() {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).checkForINF(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).checkForINF(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NEGATIVE_INFINITY);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf3(Nd4jBackend backend) {\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testInf4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN1(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN2(Nd4jBackend backend) {\n        assertThrows(ND4JIllegalStateException.class, () -> {\n            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());\n            INDArray x = Nd4j.create(100);\n            x.putScalar(2, Float.NaN);\n            OpExecutionerUtil.checkForAny(x);\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN3(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"org.nd4j.linalg.BaseNd4jTestWithBackends#configs\")\n    public void testNaN4(Nd4jBackend backend) {\n        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());\n        INDArray x = Nd4j.create(100);\n        OpExecutionerUtil.checkForAny(x);\n    }\n\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n}\n", "refactored": false}
{"hexsha": "0bdccbde2f8923091380e6547b9a7dcaa1198eba", "ext": "java", "lang": "Java", "content": "public class GooOverlayRenderer {\n\n    private static final String[] NUM_SUFFIXES = new String[] { \"\", \"k\", \"m\", \"b\", \"t\" };\n\n    private static final int MAX_LENGTH = 4;\n\n    private static final Minecraft CLIENT = Minecraft.getInstance();\n\n    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {\n        if (!stack.isEmpty() && stack.getAmount() != 1) {\n            String s = shortHandNumber(stack.getAmount());\n            if (stack.getAmount() < 1)\n                s = TextFormatting.RED + String.valueOf(stack.getAmount());\n            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);\n        }\n    }\n\n    private static String shortHandNumber(Number number) {\n        String shorthand = new DecimalFormat(\"##0E0\").format(number);\n        shorthand = shorthand.replaceAll(\"E[0-9]\", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);\n        for (; shorthand.length() > MAX_LENGTH || shorthand.matches(\"[0-9]+\\\\.[a-z]\"); ) shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);\n        return shorthand;\n    }\n\n    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {\n        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);\n        if (iconSprite == null)\n            return;\n        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());\n    }\n\n    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {\n        float f = 0.00390625F;\n        float f1 = 0.00390625F;\n        float zLevel = 0.0F;\n        Tessellator tessellator = Tessellator.getInstance();\n        BufferBuilder buffer = tessellator.getBuffer();\n        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);\n        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();\n        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();\n        tessellator.draw();\n    }\n}\n", "class_id": 0, "repo": "skyboy/Goo", "file": "src/main/java/com/xeno/goo/client/render/GooOverlayRenderer.java", "last_update_at": "2021-08-19T01:52:37+00:00", "original_content": "public class GooOverlayRenderer {\n\n    private static final String[] NUM_SUFFIXES = new String[] { \"\", \"k\", \"m\", \"b\", \"t\" };\n\n    private static final int MAX_LENGTH = 4;\n\n    private static final Minecraft CLIENT = Minecraft.getInstance();\n\n    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {\n        if (!stack.isEmpty() && stack.getAmount() != 1) {\n            String s = shortHandNumber(stack.getAmount());\n            if (stack.getAmount() < 1)\n                s = TextFormatting.RED + String.valueOf(stack.getAmount());\n            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);\n        }\n    }\n\n    private static String shortHandNumber(Number number) {\n        String shorthand = new DecimalFormat(\"##0E0\").format(number);\n        shorthand = shorthand.replaceAll(\"E[0-9]\", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);\n        while (shorthand.length() > MAX_LENGTH || shorthand.matches(\"[0-9]+\\\\.[a-z]\")) shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);\n        return shorthand;\n    }\n\n    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {\n        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);\n        if (iconSprite == null)\n            return;\n        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());\n    }\n\n    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {\n        float f = 0.00390625F;\n        float f1 = 0.00390625F;\n        float zLevel = 0.0F;\n        Tessellator tessellator = Tessellator.getInstance();\n        BufferBuilder buffer = tessellator.getBuffer();\n        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);\n        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();\n        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();\n        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();\n        tessellator.draw();\n    }\n}\n", "refactored": true}
{"hexsha": "763fc82862a43e0b16eb8f74bb7a4c58704f0059", "ext": "java", "lang": "Java", "content": "public class MessageBindingsReader {\n\n    public MessageBindingsReader() {\n    }\n\n    public static MessageBindings readMessageBindings(final AnnotationScannerContext context, final AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return null;\n        }\n        IoLogging.logger.annotationsArray(\"@MessageBindings\");\n        AnnotationInstance nested = annotationValue.asNested();\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n\n    public static MessageBindings readMessageBindings(final JsonNode node) {\n        if (node == null) {\n            return null;\n        }\n        IoLogging.logger.singleJsonNode(\"ChannelBindings\");\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n}\n", "class_id": 0, "repo": "openknowledge/smallrye-async-api", "file": "core/src/main/java/io/smallrye/asyncapi/core/runtime/io/bindings/MessageBindingsReader.java", "last_update_at": "2021-02-12T10:51:20+00:00", "original_content": "public class MessageBindingsReader {\n\n    public MessageBindingsReader() {\n    }\n\n    public static MessageBindings readMessageBindings(final AnnotationScannerContext context, final AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return null;\n        }\n        IoLogging.logger.annotationsArray(\"@MessageBindings\");\n        AnnotationInstance nested = annotationValue.asNested();\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n\n    public static MessageBindings readMessageBindings(final JsonNode node) {\n        if (node == null) {\n            return null;\n        }\n        IoLogging.logger.singleJsonNode(\"ChannelBindings\");\n        MessageBindings bindings = new MessageBindingsImpl();\n        bindings.setAMQPBinding(AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));\n        bindings.setHTTPBinding(HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));\n        bindings.setKafkaBinding(KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));\n        bindings.setMQTTBinding(MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));\n        return bindings;\n    }\n}\n", "refactored": false}
{"hexsha": "4d76de705259e8969c3567afa2dc3811eff12574", "ext": "java", "lang": "Java", "content": "@Service\npublic class IssueServiceImpl implements IssueService {\n\n    private final IssueRepository issueRepository;\n\n    private final LabelRepository labelRepository;\n\n    private final UserRepository userRepository;\n\n    private final ModelMapper modelMapper;\n\n    private final FromIssueToIssueDTO fromIssueToIssueDTO;\n\n    private final FromIssueDTOToIssue fromIssueDTOToIssue;\n\n    private final FromLabelToLabelDTO fromLabelToLabelDTO;\n\n    private final FromLabelDTOToLabel fromLabelDTOToLabel;\n\n    private final FromUserToUserDTO fromUserToUserDTO;\n\n    private final FromUserDTOToUser fromUserDTOToUser;\n\n    private final CommentService commentService;\n\n    private final FromCommentDTOToComment fromCommentDTOtoComment;\n\n    private final StateRepository stateRepository;\n\n    private final static String ASCENDING = \"asc\";\n\n    private final static String DESCENDING = \"desc\";\n\n    private final static String ORDER_TYPE_ERROR_MESSAGE = \" Recieved OrderType is : %s .\\nOrder Type must be asc or desc.\";\n\n    @Autowired\n    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper, FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue, FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService, FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {\n        this.issueRepository = issueRepository;\n        this.labelRepository = labelRepository;\n        this.userRepository = userRepository;\n        this.modelMapper = modelMapper;\n        this.fromIssueToIssueDTO = fromIssueToIssueDTO;\n        this.fromIssueDTOToIssue = fromIssueDTOToIssue;\n        this.fromLabelToLabelDTO = fromLabelToLabelDTO;\n        this.fromLabelDTOToLabel = fromLabelDTOToLabel;\n        this.fromUserToUserDTO = fromUserToUserDTO;\n        this.fromUserDTOToUser = fromUserDTOToUser;\n        this.commentService = commentService;\n        this.fromCommentDTOtoComment = fromCommentDTOtoComment;\n        this.stateRepository = stateRepository;\n    }\n\n    @Override\n    public IssueDTO createIssue(IssueDTO idt) {\n        Issue issue = fromIssueDTOToIssue.convert(idt);\n        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));\n        return issueDto;\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssues() {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());\n        return issueDTOList;\n    }\n\n    @Override\n    public IssueDTO findById(Long issueId) {\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new));\n        return issueDTO;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByTitleKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByDescKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlIssuesByLabel(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));\n        return issueDTOList;\n    }\n\n    @Transactional\n    @Override\n    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));\n        issue.getComments().add(addedComment);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public void deleteComment(Long issueId, Long commentId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        Optional<Comment> comment = issue.getComments().stream().filter(x -> x.getId() == commentId).findFirst();\n        if (comment.isPresent()) {\n            issue.getComments().remove(comment.get());\n        } else {\n            throw new IssueTrackerNotFoundException(\"Comment\", commentId.toString());\n        }\n        issueRepository.save(issue);\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());\n        }\n    }\n\n    @Override\n    public IssueDTO updateState(Long issueId, Long stateId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        State state = stateRepository.findById(stateId).orElseThrow(() -> new IssueTrackerNotFoundException(\"State\", stateId.toString()));\n        issue.setState(state);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());\n        }\n    }\n\n    public List<IssueDTO> getAllIssuesSort(String orderType, String byWhichSort) {\n        if (byWhichSort == null) {\n            return getAllIssues();\n        }\n        if (byWhichSort.equalsIgnoreCase(\"createDate\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByCreateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByCreateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else if (byWhichSort.equalsIgnoreCase(\"update\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByUpdateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByUpdateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else {\n            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n        }\n    }\n\n    @Override\n    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {\n        labelRepository.removeLabelFromIssue(labelId, issueId);\n        Issue newIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n\n    @Override\n    public IssueDTO addLabel(Long labelId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        Label label = labelRepository.findById(labelId).orElseThrow(NoSuchElementException::new);\n        issue.getLabels().add(label);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO editIssue(Long issueId, IssueDTO issue) {\n        Issue updatedIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        modelMapper.getConfiguration().setSkipNullEnabled(true);\n        modelMapper.map(issue, updatedIssue);\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));\n        return issueDTO;\n    }\n\n    @Override\n    public void deleteIssue(Long issueId) {\n        issueRepository.deleteById(issueId);\n    }\n\n    @Override\n    public void deleteSelectedIssues(List<Long> selectedIssueIds) {\n        for (Long id : selectedIssueIds) {\n            deleteIssue(id);\n        }\n    }\n\n    @Override\n    public IssueDTO addAssignee(Long userId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        User user = userRepository.findById(userId).orElseThrow(NoSuchElementException::new);\n        issue.getAssignees().add(user);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {\n        userRepository.removeAssigneeFromIssue(userId, issueId);\n        Issue newIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n}\n", "class_id": 0, "repo": "SuzanGencer/issue-tracker-2020-2", "file": "backend/issue-tracker/src/main/java/com/kodstar/issuetracker/service/impl/IssueServiceImpl.java", "last_update_at": "2021-04-06T13:05:56+00:00", "original_content": "@Service\npublic class IssueServiceImpl implements IssueService {\n\n    private final IssueRepository issueRepository;\n\n    private final LabelRepository labelRepository;\n\n    private final UserRepository userRepository;\n\n    private final ModelMapper modelMapper;\n\n    private final FromIssueToIssueDTO fromIssueToIssueDTO;\n\n    private final FromIssueDTOToIssue fromIssueDTOToIssue;\n\n    private final FromLabelToLabelDTO fromLabelToLabelDTO;\n\n    private final FromLabelDTOToLabel fromLabelDTOToLabel;\n\n    private final FromUserToUserDTO fromUserToUserDTO;\n\n    private final FromUserDTOToUser fromUserDTOToUser;\n\n    private final CommentService commentService;\n\n    private final FromCommentDTOToComment fromCommentDTOtoComment;\n\n    private final StateRepository stateRepository;\n\n    private final static String ASCENDING = \"asc\";\n\n    private final static String DESCENDING = \"desc\";\n\n    private final static String ORDER_TYPE_ERROR_MESSAGE = \" Recieved OrderType is : %s .\\nOrder Type must be asc or desc.\";\n\n    @Autowired\n    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper, FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue, FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService, FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {\n        this.issueRepository = issueRepository;\n        this.labelRepository = labelRepository;\n        this.userRepository = userRepository;\n        this.modelMapper = modelMapper;\n        this.fromIssueToIssueDTO = fromIssueToIssueDTO;\n        this.fromIssueDTOToIssue = fromIssueDTOToIssue;\n        this.fromLabelToLabelDTO = fromLabelToLabelDTO;\n        this.fromLabelDTOToLabel = fromLabelDTOToLabel;\n        this.fromUserToUserDTO = fromUserToUserDTO;\n        this.fromUserDTOToUser = fromUserDTOToUser;\n        this.commentService = commentService;\n        this.fromCommentDTOtoComment = fromCommentDTOtoComment;\n        this.stateRepository = stateRepository;\n    }\n\n    @Override\n    public IssueDTO createIssue(IssueDTO idt) {\n        Issue issue = fromIssueDTOToIssue.convert(idt);\n        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));\n        return issueDto;\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssues() {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());\n        return issueDTOList;\n    }\n\n    @Override\n    public IssueDTO findById(Long issueId) {\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new));\n        return issueDTO;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByTitleKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlByDescKeyword(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));\n        return issueDTOList;\n    }\n\n    @Override\n    public List<IssueDTO> findALlIssuesByLabel(String keyword) {\n        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));\n        return issueDTOList;\n    }\n\n    @Transactional\n    @Override\n    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));\n        issue.getComments().add(addedComment);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public void deleteComment(Long issueId, Long commentId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        Optional<Comment> comment = issue.getComments().stream().filter(x -> x.getId() == commentId).findFirst();\n        if (comment.isPresent()) {\n            issue.getComments().remove(comment.get());\n        } else {\n            throw new IssueTrackerNotFoundException(\"Comment\", commentId.toString());\n        }\n        issueRepository.save(issue);\n    }\n\n    @Override\n    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());\n        }\n    }\n\n    @Override\n    public IssueDTO updateState(Long issueId, Long stateId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(() -> new IssueTrackerNotFoundException(\"Issue\", issueId.toString()));\n        State state = stateRepository.findById(stateId).orElseThrow(() -> new IssueTrackerNotFoundException(\"State\", stateId.toString()));\n        issue.setState(state);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {\n        if (isAscending) {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());\n        } else {\n            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());\n        }\n    }\n\n    public List<IssueDTO> getAllIssuesSort(String orderType, String byWhichSort) {\n        if (byWhichSort == null) {\n            return getAllIssues();\n        }\n        if (byWhichSort.equalsIgnoreCase(\"createDate\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByCreateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByCreateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else if (byWhichSort.equalsIgnoreCase(\"update\")) {\n            if (orderType.equalsIgnoreCase(ASCENDING)) {\n                return getAllIssuesOrderByUpdateTime(true);\n            } else if (orderType.equalsIgnoreCase(DESCENDING)) {\n                return getAllIssuesOrderByUpdateTime(false);\n            } else {\n                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n            }\n        } else {\n            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));\n        }\n    }\n\n    @Override\n    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {\n        labelRepository.removeLabelFromIssue(labelId, issueId);\n        Issue newIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n\n    @Override\n    public IssueDTO addLabel(Long labelId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        Label label = labelRepository.findById(labelId).orElseThrow(NoSuchElementException::new);\n        issue.getLabels().add(label);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO editIssue(Long issueId, IssueDTO issue) {\n        Issue updatedIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        modelMapper.getConfiguration().setSkipNullEnabled(true);\n        modelMapper.map(issue, updatedIssue);\n        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));\n        return issueDTO;\n    }\n\n    @Override\n    public void deleteIssue(Long issueId) {\n        issueRepository.deleteById(issueId);\n    }\n\n    @Override\n    public void deleteSelectedIssues(List<Long> selectedIssueIds) {\n        for (Long id : selectedIssueIds) {\n            deleteIssue(id);\n        }\n    }\n\n    @Override\n    public IssueDTO addAssignee(Long userId, Long issueId) {\n        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        User user = userRepository.findById(userId).orElseThrow(NoSuchElementException::new);\n        issue.getAssignees().add(user);\n        return fromIssueToIssueDTO.convert(issueRepository.save(issue));\n    }\n\n    @Override\n    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {\n        userRepository.removeAssigneeFromIssue(userId, issueId);\n        Issue newIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);\n        return fromIssueToIssueDTO.convert(newIssue);\n    }\n}\n", "refactored": false}
{"hexsha": "8443c954494c6c6baca7fbd14f3c738d5cd75922", "ext": "java", "lang": "Java", "content": "public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {\n\n    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)\n    private EventManager eventManager;\n\n    /**\n     * SubAppRuntimeManager Interface member variables.\n     */\n    List<FermatEventListener> listenersAdded = new ArrayList<>();\n\n    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();\n\n    /**\n     * Last desktop-object\n     */\n    String lastDesktopObject;\n\n    public DesktopRuntimeEnginePluginRoot() {\n        super(new PluginVersionReference(new Version()));\n    }\n\n    @Override\n    public void start() throws CantStartPluginException {\n        try {\n            /**\n             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add\n             * functionality based on wallets downloaded by users this wont be an option.\n             * * *\n             */\n            factoryReset();\n            this.serviceStatus = ServiceStatus.STARTED;\n        } catch (CantFactoryResetException ex) {\n            String message = CantStartPluginException.DEFAULT_MESSAGE;\n            FermatException cause = ex;\n            String context = \"App Runtime Start\";\n            String possibleReason = \"Some null definition\";\n            throw new CantStartPluginException(message, cause, context, possibleReason);\n        } catch (Exception exception) {\n            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, \"Unchecked Exception occurred, check the cause\");\n        }\n    }\n\n    @Override\n    public void stop() {\n        /**\n         * I will remove all the listeners registered with the event manager.\n         */\n        for (FermatEventListener eventListener : listenersAdded) {\n            eventManager.removeListener(eventListener);\n        }\n        listenersAdded.clear();\n        this.serviceStatus = ServiceStatus.STOPPED;\n    }\n\n    /**\n     * AppRuntime Interface implementation.\n     */\n    @Override\n    public DesktopObject getLastDesktopObject() {\n        if (lastDesktopObject != null) {\n            return lstDesktops.get(0);\n        }\n        return null;\n    }\n\n    @Override\n    public DesktopObject getDesktopObject(String desktopObjectType) {\n        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta\n        return null;\n    }\n\n    @Override\n    public List<DesktopObject> listDesktops() {\n        return lstDesktops;\n    }\n\n    /**\n     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the\n     * factory structure.\n     */\n    private void factoryReset() throws CantFactoryResetException {\n        try {\n            // = new RuntimeDesktopObject();\n            RuntimeDesktopObject runtimeDesktopObject;\n            //= new Activity();\n            Activity runtimeActivity;\n            //= new Fragment();\n            Fragment runtimeFragment;\n            TitleBar runtimeTitleBar;\n            SideMenu runtimeSideMenu;\n            MainMenu runtimeMainMenu;\n            MenuItem runtimeMenuItem;\n            TabStrip runtimeTabStrip;\n            StatusBar statusBar;\n            Tab runtimeTab;\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCCP\");\n            lastDesktopObject = runtimeDesktopObject.getType();\n            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);\n            Activity activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CCPDHA\");\n            Fragment fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CCPWMF\");\n            activity.addFragment(\"CCPWMF\", fragment);\n            runtimeDesktopObject.setStartActivity(activity.getType());\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"WPD\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);\n            activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"WPD\");\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DDAP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);\n            activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"DAPDHA\");\n            fragment = new Fragment();\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"DAPWMF\");\n            activity.addFragment(\"DAPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"DAPSAMF\");\n            activity.addFragment(\"DAPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCBP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);\n            activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CBPDHA\");\n            fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CBPWMF\");\n            activity.addFragment(\"CBPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CBPSAMF\");\n            activity.addFragment(\"CBPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n        } catch (Exception e) {\n            String message = CantFactoryResetException.DEFAULT_MESSAGE;\n            FermatException cause = FermatException.wrapException(e);\n            String context = \"Error on method Factory Reset, setting the structure of the apps\";\n            String possibleReason = \"some null definition\";\n            throw new CantFactoryResetException(message, cause, context, possibleReason);\n        }\n    }\n}\n", "class_id": 0, "repo": "nattyco/fermatold", "file": "PIP/plugin/engine/fermat-pip-plugin-engine-desktop-runtime-bitdubai/src/main/java/com/bitdubai/fermat_pip_plugin/layer/engine/desktop_runtime/developer/bitdubai/version_1/DesktopRuntimeEnginePluginRoot.java", "last_update_at": "2021-08-15T20:32:35+00:00", "original_content": "public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {\n\n    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)\n    private EventManager eventManager;\n\n    /**\n     * SubAppRuntimeManager Interface member variables.\n     */\n    List<FermatEventListener> listenersAdded = new ArrayList<>();\n\n    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();\n\n    /**\n     * Last desktop-object\n     */\n    String lastDesktopObject;\n\n    public DesktopRuntimeEnginePluginRoot() {\n        super(new PluginVersionReference(new Version()));\n    }\n\n    @Override\n    public void start() throws CantStartPluginException {\n        try {\n            /**\n             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add\n             * functionality based on wallets downloaded by users this wont be an option.\n             * * *\n             */\n            factoryReset();\n            this.serviceStatus = ServiceStatus.STARTED;\n        } catch (CantFactoryResetException ex) {\n            String message = CantStartPluginException.DEFAULT_MESSAGE;\n            FermatException cause = ex;\n            String context = \"App Runtime Start\";\n            String possibleReason = \"Some null definition\";\n            throw new CantStartPluginException(message, cause, context, possibleReason);\n        } catch (Exception exception) {\n            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, \"Unchecked Exception occurred, check the cause\");\n        }\n    }\n\n    @Override\n    public void stop() {\n        /**\n         * I will remove all the listeners registered with the event manager.\n         */\n        for (FermatEventListener eventListener : listenersAdded) {\n            eventManager.removeListener(eventListener);\n        }\n        listenersAdded.clear();\n        this.serviceStatus = ServiceStatus.STOPPED;\n    }\n\n    /**\n     * AppRuntime Interface implementation.\n     */\n    @Override\n    public DesktopObject getLastDesktopObject() {\n        if (lastDesktopObject != null) {\n            return lstDesktops.get(0);\n        }\n        return null;\n    }\n\n    @Override\n    public DesktopObject getDesktopObject(String desktopObjectType) {\n        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta\n        return null;\n    }\n\n    @Override\n    public List<DesktopObject> listDesktops() {\n        return lstDesktops;\n    }\n\n    /**\n     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the\n     * factory structure.\n     */\n    private void factoryReset() throws CantFactoryResetException {\n        try {\n            // = new RuntimeDesktopObject();\n            RuntimeDesktopObject runtimeDesktopObject;\n            //= new Activity();\n            Activity runtimeActivity;\n            //= new Fragment();\n            Fragment runtimeFragment;\n            TitleBar runtimeTitleBar;\n            SideMenu runtimeSideMenu;\n            MainMenu runtimeMainMenu;\n            MenuItem runtimeMenuItem;\n            TabStrip runtimeTabStrip;\n            StatusBar statusBar;\n            Tab runtimeTab;\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCCP\");\n            lastDesktopObject = runtimeDesktopObject.getType();\n            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);\n            Activity activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CCPDHA\");\n            Fragment fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CCPWMF\");\n            activity.addFragment(\"CCPWMF\", fragment);\n            runtimeDesktopObject.setStartActivity(activity.getType());\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"WPD\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);\n            activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"WPD\");\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CCPSAMF\");\n            activity.addFragment(\"CCPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DDAP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);\n            activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"DAPDHA\");\n            fragment = new Fragment();\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"DAPWMF\");\n            activity.addFragment(\"DAPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"DAPSAMF\");\n            activity.addFragment(\"DAPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            runtimeDesktopObject = new RuntimeDesktopObject();\n            runtimeDesktopObject.setType(\"DCBP\");\n            lstDesktops.add(runtimeDesktopObject);\n            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);\n            activity = new Activity();\n            //activity.setType(Activities.dmp_DESKTOP_HOME);\n            activity.setActivityType(\"CBPDHA\");\n            fragment = new Fragment();\n            runtimeDesktopObject.addActivity(activity);\n            // dmp_WALLET_MANAGER_FRAGMENT\n            fragment.setType(\"CBPWMF\");\n            activity.addFragment(\"CBPWMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n            fragment = new Fragment();\n            // dmp_SUB_APP_MANAGER_FRAGMENT\n            fragment.setType(\"CBPSAMF\");\n            activity.addFragment(\"CBPSAMF\", fragment);\n            runtimeDesktopObject.addActivity(activity);\n        } catch (Exception e) {\n            String message = CantFactoryResetException.DEFAULT_MESSAGE;\n            FermatException cause = FermatException.wrapException(e);\n            String context = \"Error on method Factory Reset, setting the structure of the apps\";\n            String possibleReason = \"some null definition\";\n            throw new CantFactoryResetException(message, cause, context, possibleReason);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "a7adb9c2cd2745f6f8a868174542360456f4045b", "ext": "java", "lang": "Java", "content": "public class CPGManualTest extends CPGTestBase {\n\n    @Test\n    public void testGet() {\n        String location = given().post(baseUrlOfSut + \"/api/cpg/x\").then().statusCode(201).extract().header(\"location\");\n        int a = 42;\n        int b = 77;\n        location = resolveLocation(location, baseUrlOfSut + \"/api/cpg/x/{id}/y\");\n        given().contentType(ContentType.JSON).body(\"{\\\"a\\\":\" + a + \", \\\"b\\\":\" + b + \"}\").post(location).then().statusCode(201);\n        given().accept(ContentType.JSON).get(location).then().statusCode(200).body(\"a\", is(a)).body(\"b\", is(b));\n    }\n}\n", "class_id": 0, "repo": "mitchellolsthoorn/ASE-Technical-2021-api-linkage-replication", "file": "EvoMaster/e2e-tests/spring-examples/src/test/java/org/evomaster/e2etests/spring/examples/chainedpostget/CPGManualTest.java", "last_update_at": "2021-07-15T12:44:15+00:00", "original_content": "public class CPGManualTest extends CPGTestBase {\n\n    @Test\n    public void testGet() {\n        String location = given().post(baseUrlOfSut + \"/api/cpg/x\").then().statusCode(201).extract().header(\"location\");\n        int a = 42;\n        int b = 77;\n        location = resolveLocation(location, baseUrlOfSut + \"/api/cpg/x/{id}/y\");\n        given().contentType(ContentType.JSON).body(\"{\\\"a\\\":\" + a + \", \\\"b\\\":\" + b + \"}\").post(location).then().statusCode(201);\n        given().accept(ContentType.JSON).get(location).then().statusCode(200).body(\"a\", is(a)).body(\"b\", is(b));\n    }\n}\n", "refactored": false}
{"hexsha": "16d5f6bd57d22f954e4f4bcebb596da796cc9164", "ext": "java", "lang": "Java", "content": "@UnitTest\npublic class MavenCodeLocationPackagerTest {\n\n    @Test\n    public void testParseProject() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        Dependency dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1:monkey\");\n        assertNull(dependency);\n    }\n\n    @Test\n    public void testParseDependency() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:0.0.1:compile\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1:test\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n    }\n\n    @Test\n    public void testIsLineRelevant() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465] stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]  stuff\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]     \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloaded\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and thingsDownloaded stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloading\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and things Downloadingstuff and things\"));\n    }\n\n    @Test\n    public void testTrimLogLevel() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        String actualLine = \"\";\n        final String expectedValue = \"thing\";\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"weird garbage 3525356 [thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\" [INFO] \" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n    }\n\n    @Test\n    public void testIsProjectSection() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\" \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:other      stuff\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin garbage:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"      ---       maven-dependency-plugin      :       tree\"));\n    }\n\n    @Test\n    public void testIsDependencyTreeUpdates() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"artifact com.google.guava:guava:jar:15.0:compile checking for updates from\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"         artifact       com.google.guava:guava:         checking for updates\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"      checking for updates   artifact       com.google.guava:guava:      \"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"checking for updates\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"+- com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"|  \\\\- com.google.guava:guava:jar:15.0:compile\"));\n    }\n\n    @Test\n    public void testIsGav() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isGav(\" \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"::::\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\" : : : : \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact:version\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group-artifact:type-classifier-version:scope-garbage\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact::classifier:version: :garbage\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope:garbage\"));\n    }\n\n    @Test\n    public void testIndexOfEndOfSegments() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testDoesLineContainSegmentsInOrder() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testLineWithExtraTextAfterScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", dependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithUnknownScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", scopedDependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithBadColonPlacement() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from\", dependency.getExternalId().createExternalId());\n    }\n}\n", "class_id": 0, "repo": "antontroshin/synopsys-detect", "file": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/maven/unit/MavenCodeLocationPackagerTest.java", "last_update_at": "2021-01-08T16:56:35+00:00", "original_content": "@UnitTest\npublic class MavenCodeLocationPackagerTest {\n\n    @Test\n    public void testParseProject() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        Dependency dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToProject(\"stuff:things:jar:classifier:0.0.1:monkey\");\n        assertNull(dependency);\n    }\n\n    @Test\n    public void testParseDependency() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:0.0.1:compile\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1:test\");\n        assertNotNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar\");\n        assertNull(dependency);\n        dependency = mavenCodeLocationPackager.textToDependency(\"stuff:things:jar:classifier:0.0.1\");\n        assertNotNull(dependency);\n    }\n\n    @Test\n    public void testIsLineRelevant() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465] stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]stuff\"));\n        assertTrue(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]  stuff\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]     \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"weird garbage 3525356 [thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO 346534623465]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[thingsINFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" [INFO]\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\" \"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloaded\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and thingsDownloaded stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] Downloading\"));\n        assertFalse(mavenCodeLocationPackager.isLineRelevant(\"[INFO] stuff and things Downloadingstuff and things\"));\n    }\n\n    @Test\n    public void testTrimLogLevel() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        String actualLine = \"\";\n        final String expectedValue = \"thing\";\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"weird garbage 3525356 [thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO 346534623465]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\"[thingsINFO]\" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n        actualLine = mavenCodeLocationPackager.trimLogLevel(\" [INFO] \" + expectedValue);\n        assertEquals(expectedValue, actualLine);\n    }\n\n    @Test\n    public void testIsProjectSection() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\" \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:other      stuff\"));\n        assertFalse(mavenCodeLocationPackager.isProjectSection(\"maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin garbage:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"things --- stuff maven-dependency-plugin:tree      stuff\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"---maven-dependency-plugin:tree\"));\n        assertTrue(mavenCodeLocationPackager.isProjectSection(\"      ---       maven-dependency-plugin      :       tree\"));\n    }\n\n    @Test\n    public void testIsDependencyTreeUpdates() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"artifact com.google.guava:guava:jar:15.0:compile checking for updates from\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"         artifact       com.google.guava:guava:         checking for updates\"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"      checking for updates   artifact       com.google.guava:guava:      \"));\n        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates(\"checking for updates\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"+- com.google.guava:guava:jar:15.0:compile\"));\n        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates(\"|  \\\\- com.google.guava:guava:jar:15.0:compile\"));\n    }\n\n    @Test\n    public void testIsGav() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.isGav(\" \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"       \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"::::\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\" : : : : \"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact:version\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group-artifact:type-classifier-version:scope-garbage\"));\n        assertFalse(mavenCodeLocationPackager.isGav(\"group:artifact::classifier:version: :garbage\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope\"));\n        assertTrue(mavenCodeLocationPackager.isGav(\"group:artifact:type:classifier:version:scope:garbage\"));\n    }\n\n    @Test\n    public void testIndexOfEndOfSegments() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\"));\n        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"and\"));\n        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testDoesLineContainSegmentsInOrder() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\"));\n        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\", \"and\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"stuff\", \"and\", \"things\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"and\"));\n        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(\"stuff and things\", \"things\"));\n    }\n\n    @Test\n    public void testLineWithExtraTextAfterScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", dependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithUnknownScope() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411\", scopedDependency.getExternalId().createExternalId());\n    }\n\n    @Test\n    public void testLineWithBadColonPlacement() {\n        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());\n        String line = \"[INFO] |  |  |  \\\\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))\";\n        line = mavenCodeLocationPackager.trimLogLevel(line);\n        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);\n        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);\n        assertEquals(\"org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from\", dependency.getExternalId().createExternalId());\n    }\n}\n", "refactored": false}
{"hexsha": "236dd9c3e3386bd6a06a244e8ea1516692f3c35d", "ext": "java", "lang": "Java", "content": "public class PluginXMLTextHover extends PDETextHover {\n\n    private PDESourcePage fSourcePage;\n\n    public PluginXMLTextHover(PDESourcePage sourcePage) {\n        fSourcePage = sourcePage;\n    }\n\n    @Override\n    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {\n        int offset = hoverRegion.getOffset();\n        IDocumentRange range = fSourcePage.getRangeElement(offset, true);\n        if (range instanceof IDocumentTextNode)\n            return checkTranslatedValue((IDocumentTextNode) range);\n        if (!(range instanceof IPluginObject))\n            return null;\n        ISchema schema = getExtensionSchema((IPluginObject) range);\n        if (schema != null) {\n            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);\n            if (sObj == null) {\n                return null;\n            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {\n                IDocumentAttributeNode da = (IDocumentAttributeNode) range;\n                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)\n                    // inside name\n                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);\n                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)\n                    // inside value\n                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);\n            } else if (range instanceof IPluginElement) {\n                IDocumentElementNode dn = (IDocumentElementNode) range;\n                int dnOff = dn.getOffset();\n                int dnLen = dn.getLength();\n                String dnName = dn.getXMLTagName();\n                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())\n                    // inside opening tag\n                    return getElementText((ISchemaElement) sObj);\n                try {\n                    String nt = textViewer.getDocument().get(dnOff, dnLen);\n                    if (//$NON-NLS-1$\n                    //$NON-NLS-1$\n                    nt.//$NON-NLS-1$\n                    endsWith(\"</\" + dnName + '>')) {\n                        offset = offset - dnOff;\n                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)\n                            // inside closing tag\n                            return getElementText((ISchemaElement) sObj);\n                    }\n                } catch (BadLocationException e) {\n                }\n            }\n        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)\n            return getExtensionPointHoverInfo((IPluginObject) range, offset);\n        return null;\n    }\n\n    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {\n        IDocumentAttributeNode da = (IDocumentAttributeNode) object;\n        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {\n            String value = da.getAttributeValue();\n            if (//$NON-NLS-1$\n            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith(\"%\"))\n                return object.getResourceString(value);\n        }\n        return null;\n    }\n\n    private ISchema getExtensionSchema(IPluginObject object) {\n        IPluginObject extension = object;\n        if (object instanceof IDocumentAttributeNode)\n            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();\n        for (; extension != null && !(extension instanceof IPluginExtension); ) extension = extension.getParent();\n        if (extension == null)\n            // started off outside of an extension element\n            return null;\n        String point = ((IPluginExtension) extension).getPoint();\n        return PDECore.getDefault().getSchemaRegistry().getSchema(point);\n    }\n\n    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {\n        if (object instanceof IPluginElement)\n            return schema.findElement(((IPluginElement) object).getName());\n        if (object instanceof IPluginExtension)\n            //$NON-NLS-1$\n            return schema.findElement(\"extension\");\n        if (object instanceof IDocumentAttributeNode)\n            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());\n        return null;\n    }\n\n    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        return sAtt.getDescription();\n    }\n\n    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {\n        if (//$NON-NLS-1$\n        sEle.getName().equals(\"extension\") && attrib.getName().equals(IPluginExtension.P_POINT))\n            return getSchemaDescription(attrib, sEle);\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        String value = attrib.getValue();\n        if (//$NON-NLS-1$\n        sAtt.isTranslatable() && value.startsWith(\"%\"))\n            return attrib.getResourceString(value);\n        return null;\n    }\n\n    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {\n        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        if (description == null) {\n            URL url = sEle.getSchema().getURL();\n            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();\n            SchemaUtil.parseURL(url, handler);\n            description = handler.getDescription();\n            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        }\n        return description;\n    }\n\n    private String getElementText(ISchemaElement sEle) {\n        if (sEle == null) {\n            return null;\n        }\n        return sEle.getDescription();\n    }\n\n    private String checkTranslatedValue(IDocumentTextNode node) {\n        String value = node.getText();\n        if (//$NON-NLS-1$\n        value.startsWith(\"%\"))\n            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);\n        return null;\n    }\n}\n", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.pde.ui/1463.java", "last_update_at": "2021-11-29T08:28:07+00:00", "original_content": "public class PluginXMLTextHover extends PDETextHover {\n\n    private PDESourcePage fSourcePage;\n\n    public PluginXMLTextHover(PDESourcePage sourcePage) {\n        fSourcePage = sourcePage;\n    }\n\n    @Override\n    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {\n        int offset = hoverRegion.getOffset();\n        IDocumentRange range = fSourcePage.getRangeElement(offset, true);\n        if (range instanceof IDocumentTextNode)\n            return checkTranslatedValue((IDocumentTextNode) range);\n        if (!(range instanceof IPluginObject))\n            return null;\n        ISchema schema = getExtensionSchema((IPluginObject) range);\n        if (schema != null) {\n            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);\n            if (sObj == null) {\n                return null;\n            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {\n                IDocumentAttributeNode da = (IDocumentAttributeNode) range;\n                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)\n                    // inside name\n                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);\n                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)\n                    // inside value\n                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);\n            } else if (range instanceof IPluginElement) {\n                IDocumentElementNode dn = (IDocumentElementNode) range;\n                int dnOff = dn.getOffset();\n                int dnLen = dn.getLength();\n                String dnName = dn.getXMLTagName();\n                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())\n                    // inside opening tag\n                    return getElementText((ISchemaElement) sObj);\n                try {\n                    String nt = textViewer.getDocument().get(dnOff, dnLen);\n                    if (//$NON-NLS-1$\n                    nt.//$NON-NLS-1$\n                    endsWith(//$NON-NLS-1$\n                    \"</\" + dnName + '>')) {\n                        offset = offset - dnOff;\n                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)\n                            // inside closing tag\n                            return getElementText((ISchemaElement) sObj);\n                    }\n                } catch (BadLocationException e) {\n                }\n            }\n        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)\n            return getExtensionPointHoverInfo((IPluginObject) range, offset);\n        return null;\n    }\n\n    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {\n        IDocumentAttributeNode da = (IDocumentAttributeNode) object;\n        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {\n            String value = da.getAttributeValue();\n            if (//$NON-NLS-1$\n            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith(\"%\"))\n                return object.getResourceString(value);\n        }\n        return null;\n    }\n\n    private ISchema getExtensionSchema(IPluginObject object) {\n        IPluginObject extension = object;\n        if (object instanceof IDocumentAttributeNode)\n            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();\n        while (extension != null && !(extension instanceof IPluginExtension)) extension = extension.getParent();\n        if (extension == null)\n            // started off outside of an extension element\n            return null;\n        String point = ((IPluginExtension) extension).getPoint();\n        return PDECore.getDefault().getSchemaRegistry().getSchema(point);\n    }\n\n    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {\n        if (object instanceof IPluginElement)\n            return schema.findElement(((IPluginElement) object).getName());\n        if (object instanceof IPluginExtension)\n            //$NON-NLS-1$\n            return schema.findElement(\"extension\");\n        if (object instanceof IDocumentAttributeNode)\n            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());\n        return null;\n    }\n\n    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        return sAtt.getDescription();\n    }\n\n    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {\n        if (//$NON-NLS-1$\n        sEle.getName().equals(\"extension\") && attrib.getName().equals(IPluginExtension.P_POINT))\n            return getSchemaDescription(attrib, sEle);\n        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());\n        if (sAtt == null)\n            return null;\n        String value = attrib.getValue();\n        if (//$NON-NLS-1$\n        sAtt.isTranslatable() && value.startsWith(\"%\"))\n            return attrib.getResourceString(value);\n        return null;\n    }\n\n    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {\n        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        if (description == null) {\n            URL url = sEle.getSchema().getURL();\n            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();\n            SchemaUtil.parseURL(url, handler);\n            description = handler.getDescription();\n            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);\n        }\n        return description;\n    }\n\n    private String getElementText(ISchemaElement sEle) {\n        if (sEle == null) {\n            return null;\n        }\n        return sEle.getDescription();\n    }\n\n    private String checkTranslatedValue(IDocumentTextNode node) {\n        String value = node.getText();\n        if (//$NON-NLS-1$\n        value.startsWith(\"%\"))\n            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);\n        return null;\n    }\n}\n", "refactored": true}
{"hexsha": "b5f71a5a6d3aac676e17055cfabf54d3d8029f71", "ext": "java", "lang": "Java", "content": "public class CylonGpioExample {\n\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"<--Pi4J--> GPIO Cylon Example ... started.\");\n        // create gpio controller\n        final GpioController gpio = GpioFactory.getInstance();\n        // provision gpio pin #01 as an output pin and turn on\n        final GpioPinDigitalOutput[] pins = { gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW) };\n        System.out.println(\"--> GPIO state should be: ON\");\n        // set shutdown options on all pins\n        gpio.setShutdownOptions(true, PinState.LOW, pins);\n        // infinite loop\n        while (true) {\n            int index = 0;\n            while (index <= 6) try {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            } finally {\n                index++;\n            }\n            int index = 6;\n            while (index >= 0) try {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            } finally {\n                index--;\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "funk-overload/funky_leds", "file": "pi4j-1.1/examples/CylonGpioExample.java", "last_update_at": "2021-01-13T03:25:14+00:00", "original_content": "public class CylonGpioExample {\n\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"<--Pi4J--> GPIO Cylon Example ... started.\");\n        // create gpio controller\n        final GpioController gpio = GpioFactory.getInstance();\n        // provision gpio pin #01 as an output pin and turn on\n        final GpioPinDigitalOutput[] pins = { gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW) };\n        System.out.println(\"--> GPIO state should be: ON\");\n        // set shutdown options on all pins\n        gpio.setShutdownOptions(true, PinState.LOW, pins);\n        // infinite loop\n        while (true) {\n            for (int index = 0; index <= 6; index++) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n            for (int index = 6; index >= 0; index--) {\n                pins[index].pulse(50);\n                Thread.sleep(50);\n            }\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "f03acb955ac4cb27321bca392b2d1acefa0e597e", "ext": "java", "lang": "Java", "content": "public class PrivateUrlTest {\n\n    @Test\n    public void testProcessLine() throws Exception {\n        PropertiesFile propertiesFile = new PropertiesFile(\"resources/.application.properties\");\n        String accessKeyId = propertiesFile.getValue(\"ten-id\");\n        String accessKeySecret = propertiesFile.getValue(\"ten-secret\");\n        String bucket = propertiesFile.getValue(\"bucket\");\n        String region = \"ap-shanghai\";\n        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, \"~/Downloads\");\n        String result = privateUrl.singleResult(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg\");\n            }\n        });\n        System.out.println(result);\n        List<Map<String, String>> mapList = new ArrayList<>();\n        mapList.add(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"1\");\n            }\n        });\n        mapList.add(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"2\");\n            }\n        });\n        mapList.add(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"3\");\n            }\n        });\n        privateUrl.processLine(mapList);\n        privateUrl.closeResource();\n    }\n}\n", "class_id": 0, "repo": "NigelWu95/qiniu-suits", "file": "src/test/java/com/qiniu/process/tencent/PrivateUrlTest.java", "last_update_at": "2021-05-19T13:33:45+00:00", "original_content": "public class PrivateUrlTest {\n\n    @Test\n    public void testProcessLine() throws Exception {\n        PropertiesFile propertiesFile = new PropertiesFile(\"resources/.application.properties\");\n        String accessKeyId = propertiesFile.getValue(\"ten-id\");\n        String accessKeySecret = propertiesFile.getValue(\"ten-secret\");\n        String bucket = propertiesFile.getValue(\"bucket\");\n        String region = \"ap-shanghai\";\n        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, \"~/Downloads\");\n        String result = privateUrl.singleResult(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg\");\n            }\n        });\n        System.out.println(result);\n        List<Map<String, String>> mapList = new ArrayList<>();\n        mapList.add(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"1\");\n            }\n        });\n        mapList.add(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"2\");\n            }\n        });\n        mapList.add(new HashMap<String, String>() {\n\n            {\n                put(\"key\", \"3\");\n            }\n        });\n        privateUrl.processLine(mapList);\n        privateUrl.closeResource();\n    }\n}\n", "refactored": false}
{"hexsha": "d1df0edd75da094a11db311dfe81daf5603081fa", "ext": "java", "lang": "Java", "content": "public class ViewCommand extends Command {\n\n    public static final String COMMAND_WORD = \"view\";\n\n    public static final String MESSAGE_USAGE = COMMAND_WORD + \": Displays the applicant details identified by the index number used in the displayed applicant list.\\n\" + \"Parameters: INDEX (must be a positive integer) [T] (case sensitive)\\n\" + \"Example: \" + COMMAND_WORD + \" 1 T\";\n\n    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = \"Displayed Applicant details: %1$s\";\n\n    private final Index targetIndex;\n\n    private final Boolean toggle;\n\n    /**\n     * User can view applicant details in Intern Watcher.\n     */\n    public ViewCommand(Index index, Boolean toggle) {\n        this.targetIndex = index;\n        this.toggle = toggle;\n    }\n\n    @Override\n    public CommandResult execute(Model model) throws CommandException {\n        requireNonNull(model);\n        List<Applicant> lastShownList = model.getFilteredApplicantList();\n        if (targetIndex != null) {\n            if (targetIndex.getZeroBased() >= lastShownList.size()) {\n                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);\n            }\n        }\n        if (toggle) {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, true);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS, applicantToView), false, false, true);\n        } else {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, false);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS, applicantToView), false, false, true);\n        }\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return // short circuit if same object\n        other == this || (// instanceof handles nulls\n        // state check\n        other instanceof ViewCommand && targetIndex.equals(((ViewCommand) other).targetIndex));\n    }\n}\n", "class_id": 0, "repo": "jackgugz/tp", "file": "src/main/java/seedu/intern/logic/commands/ViewCommand.java", "last_update_at": "2021-11-11T13:50:27+00:00", "original_content": "public class ViewCommand extends Command {\n\n    public static final String COMMAND_WORD = \"view\";\n\n    public static final String MESSAGE_USAGE = COMMAND_WORD + \": Displays the applicant details identified by the index number used in the displayed applicant list.\\n\" + \"Parameters: INDEX (must be a positive integer) [T] (case sensitive)\\n\" + \"Example: \" + COMMAND_WORD + \" 1 T\";\n\n    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = \"Displayed Applicant details: %1$s\";\n\n    private final Index targetIndex;\n\n    private final Boolean toggle;\n\n    /**\n     * User can view applicant details in Intern Watcher.\n     */\n    public ViewCommand(Index index, Boolean toggle) {\n        this.targetIndex = index;\n        this.toggle = toggle;\n    }\n\n    @Override\n    public CommandResult execute(Model model) throws CommandException {\n        requireNonNull(model);\n        List<Applicant> lastShownList = model.getFilteredApplicantList();\n        if (targetIndex != null) {\n            if (targetIndex.getZeroBased() >= lastShownList.size()) {\n                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);\n            }\n        }\n        if (toggle) {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, true);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS, applicantToView), false, false, true);\n        } else {\n            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());\n            model.displayApplicant(applicantToView, false);\n            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS, applicantToView), false, false, true);\n        }\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return // short circuit if same object\n        other == this || (// instanceof handles nulls\n        other instanceof ViewCommand && // state check\n        targetIndex.equals(((ViewCommand) other).targetIndex));\n    }\n}\n", "refactored": false}
{"hexsha": "73f66a22b3c991c1a48893c0996622a8d2412519", "ext": "java", "lang": "Java", "content": "public class MiniMaxSum {\n\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n        Object[] numbers = Arrays.stream(stdin.nextLine().split(\" \")).map(Long::parseLong).toArray();\n        Arrays.sort(numbers);\n        long minSum = 0;\n        long maxSum = 0;\n        int i = 0;\n        while (i < numbers.length - 1) try {\n            minSum += (long) numbers[i];\n            maxSum += (long) numbers[i + 1];\n        } finally {\n            i++;\n        }\n        System.out.println(minSum + \" \" + maxSum);\n        stdin.close();\n    }\n}\n", "class_id": 0, "repo": "Alok255/hackerrank", "file": "practice/algorithms/implementation/mini-max_sum/MiniMaxSum.java", "last_update_at": "2021-09-04T00:14:38+00:00", "original_content": "public class MiniMaxSum {\n\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n        Object[] numbers = Arrays.stream(stdin.nextLine().split(\" \")).map(Long::parseLong).toArray();\n        Arrays.sort(numbers);\n        long minSum = 0;\n        long maxSum = 0;\n        for (int i = 0; i < numbers.length - 1; i++) {\n            minSum += (long) numbers[i];\n            maxSum += (long) numbers[i + 1];\n        }\n        System.out.println(minSum + \" \" + maxSum);\n        stdin.close();\n    }\n}\n", "refactored": true}
{"hexsha": "f0df889c9a924965d5986a36b2a0cbf9e81b51b7", "ext": "java", "lang": "Java", "content": "public class Saml2IdentityProviderResponse {\n\n    @JsonProperty(\"issuer\")\n    private String issuer = null;\n\n    @JsonProperty(\"settings\")\n    private java.util.List<SettingResponse> settings = null;\n\n    @JsonProperty(\"certificates\")\n    private java.util.List<CertificateResponse> certificates = null;\n\n    @JsonProperty(\"attribute_mappings\")\n    private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;\n\n    /**\n     * issuer.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse issuer(String issuer) {\n        this.issuer = issuer;\n        return this;\n    }\n\n    /**\n     * Get issuer.\n     *\n     * @return issuer\n     */\n    @ApiModelProperty(value = \"\")\n    public String getIssuer() {\n        return issuer;\n    }\n\n    /**\n     * setIssuer.\n     */\n    public void setIssuer(String issuer) {\n        this.issuer = issuer;\n    }\n\n    /**\n     * settings.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    /**\n     * addSettingsItem.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {\n        if (this.settings == null) {\n            this.settings = new java.util.ArrayList<>();\n        }\n        this.settings.add(settingsItem);\n        return this;\n    }\n\n    /**\n     * Get settings.\n     *\n     * @return settings\n     */\n    @ApiModelProperty(value = \"\")\n    public java.util.List<SettingResponse> getSettings() {\n        return settings;\n    }\n\n    /**\n     * setSettings.\n     */\n    public void setSettings(java.util.List<SettingResponse> settings) {\n        this.settings = settings;\n    }\n\n    /**\n     * certificates.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse certificates(java.util.List<CertificateResponse> certificates) {\n        this.certificates = certificates;\n        return this;\n    }\n\n    /**\n     * addCertificatesItem.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {\n        if (this.certificates == null) {\n            this.certificates = new java.util.ArrayList<>();\n        }\n        this.certificates.add(certificatesItem);\n        return this;\n    }\n\n    /**\n     * Get certificates.\n     *\n     * @return certificates\n     */\n    @ApiModelProperty(value = \"\")\n    public java.util.List<CertificateResponse> getCertificates() {\n        return certificates;\n    }\n\n    /**\n     * setCertificates.\n     */\n    public void setCertificates(java.util.List<CertificateResponse> certificates) {\n        this.certificates = certificates;\n    }\n\n    /**\n     * attributeMappings.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse attributeMappings(java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n        this.attributeMappings = attributeMappings;\n        return this;\n    }\n\n    /**\n     * addAttributeMappingsItem.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse addAttributeMappingsItem(RequiredAttributeMappingResponse attributeMappingsItem) {\n        if (this.attributeMappings == null) {\n            this.attributeMappings = new java.util.ArrayList<>();\n        }\n        this.attributeMappings.add(attributeMappingsItem);\n        return this;\n    }\n\n    /**\n     * Get attributeMappings.\n     *\n     * @return attributeMappings\n     */\n    @ApiModelProperty(value = \"\")\n    public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {\n        return attributeMappings;\n    }\n\n    /**\n     * setAttributeMappings.\n     */\n    public void setAttributeMappings(java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n        this.attributeMappings = attributeMappings;\n    }\n\n    /**\n     * Compares objects.\n     *\n     * @return true or false depending on comparison result.\n     */\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;\n        return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer) && Objects.equals(this.settings, saml2IdentityProviderResponse.settings) && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates) && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);\n    }\n\n    /**\n     * Returns the HashCode.\n     */\n    @Override\n    public int hashCode() {\n        return Objects.hash(issuer, settings, certificates, attributeMappings);\n    }\n\n    /**\n     * Converts the given object to string.\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class Saml2IdentityProviderResponse {\\n\");\n        sb.append(\"    issuer: \").append(toIndentedString(issuer)).append(\"\\n\");\n        sb.append(\"    settings: \").append(toIndentedString(settings)).append(\"\\n\");\n        sb.append(\"    certificates: \").append(toIndentedString(certificates)).append(\"\\n\");\n        sb.append(\"    attributeMappings: \").append(toIndentedString(attributeMappings)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "class_id": 0, "repo": "docusign/docusign-admin-java-client", "file": "src/main/java/com/docusign/admin/model/Saml2IdentityProviderResponse.java", "last_update_at": "2021-11-14T17:02:16+00:00", "original_content": "public class Saml2IdentityProviderResponse {\n\n    @JsonProperty(\"issuer\")\n    private String issuer = null;\n\n    @JsonProperty(\"settings\")\n    private java.util.List<SettingResponse> settings = null;\n\n    @JsonProperty(\"certificates\")\n    private java.util.List<CertificateResponse> certificates = null;\n\n    @JsonProperty(\"attribute_mappings\")\n    private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;\n\n    /**\n     * issuer.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse issuer(String issuer) {\n        this.issuer = issuer;\n        return this;\n    }\n\n    /**\n     * Get issuer.\n     *\n     * @return issuer\n     */\n    @ApiModelProperty(value = \"\")\n    public String getIssuer() {\n        return issuer;\n    }\n\n    /**\n     * setIssuer.\n     */\n    public void setIssuer(String issuer) {\n        this.issuer = issuer;\n    }\n\n    /**\n     * settings.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    /**\n     * addSettingsItem.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {\n        if (this.settings == null) {\n            this.settings = new java.util.ArrayList<>();\n        }\n        this.settings.add(settingsItem);\n        return this;\n    }\n\n    /**\n     * Get settings.\n     *\n     * @return settings\n     */\n    @ApiModelProperty(value = \"\")\n    public java.util.List<SettingResponse> getSettings() {\n        return settings;\n    }\n\n    /**\n     * setSettings.\n     */\n    public void setSettings(java.util.List<SettingResponse> settings) {\n        this.settings = settings;\n    }\n\n    /**\n     * certificates.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse certificates(java.util.List<CertificateResponse> certificates) {\n        this.certificates = certificates;\n        return this;\n    }\n\n    /**\n     * addCertificatesItem.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {\n        if (this.certificates == null) {\n            this.certificates = new java.util.ArrayList<>();\n        }\n        this.certificates.add(certificatesItem);\n        return this;\n    }\n\n    /**\n     * Get certificates.\n     *\n     * @return certificates\n     */\n    @ApiModelProperty(value = \"\")\n    public java.util.List<CertificateResponse> getCertificates() {\n        return certificates;\n    }\n\n    /**\n     * setCertificates.\n     */\n    public void setCertificates(java.util.List<CertificateResponse> certificates) {\n        this.certificates = certificates;\n    }\n\n    /**\n     * attributeMappings.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse attributeMappings(java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n        this.attributeMappings = attributeMappings;\n        return this;\n    }\n\n    /**\n     * addAttributeMappingsItem.\n     *\n     * @return Saml2IdentityProviderResponse\n     */\n    public Saml2IdentityProviderResponse addAttributeMappingsItem(RequiredAttributeMappingResponse attributeMappingsItem) {\n        if (this.attributeMappings == null) {\n            this.attributeMappings = new java.util.ArrayList<>();\n        }\n        this.attributeMappings.add(attributeMappingsItem);\n        return this;\n    }\n\n    /**\n     * Get attributeMappings.\n     *\n     * @return attributeMappings\n     */\n    @ApiModelProperty(value = \"\")\n    public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {\n        return attributeMappings;\n    }\n\n    /**\n     * setAttributeMappings.\n     */\n    public void setAttributeMappings(java.util.List<RequiredAttributeMappingResponse> attributeMappings) {\n        this.attributeMappings = attributeMappings;\n    }\n\n    /**\n     * Compares objects.\n     *\n     * @return true or false depending on comparison result.\n     */\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;\n        return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer) && Objects.equals(this.settings, saml2IdentityProviderResponse.settings) && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates) && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);\n    }\n\n    /**\n     * Returns the HashCode.\n     */\n    @Override\n    public int hashCode() {\n        return Objects.hash(issuer, settings, certificates, attributeMappings);\n    }\n\n    /**\n     * Converts the given object to string.\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class Saml2IdentityProviderResponse {\\n\");\n        sb.append(\"    issuer: \").append(toIndentedString(issuer)).append(\"\\n\");\n        sb.append(\"    settings: \").append(toIndentedString(settings)).append(\"\\n\");\n        sb.append(\"    certificates: \").append(toIndentedString(certificates)).append(\"\\n\");\n        sb.append(\"    attributeMappings: \").append(toIndentedString(attributeMappings)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "refactored": false}
{"hexsha": "07f14f69f8dacb6b9a0eeb603908e41613cd4a6a", "ext": "java", "lang": "Java", "content": "public class RegistrationFactory implements FactoryBean<Registration> {\n\n    @Override\n    public Registration getObject() throws Exception {\n        User user = new UserFactory().getObject();\n        Activity activity = new ActivityFactory().getObject();\n        assert user != null;\n        assert activity != null;\n        return Registration.builder().registrationId(new RegistrationId(user.getId(), activity.getId())).user(user).activity(activity).build();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n", "class_id": 0, "repo": "olros/GIDD", "file": "backend/src/test/java/com/ntnu/gidd/factories/RegistrationFactory.java", "last_update_at": "2021-04-30T21:46:19+00:00", "original_content": "public class RegistrationFactory implements FactoryBean<Registration> {\n\n    @Override\n    public Registration getObject() throws Exception {\n        User user = new UserFactory().getObject();\n        Activity activity = new ActivityFactory().getObject();\n        assert user != null;\n        assert activity != null;\n        return Registration.builder().registrationId(new RegistrationId(user.getId(), activity.getId())).user(user).activity(activity).build();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n", "refactored": false}
{"hexsha": "be19510bbe554bc909260040d46c21ac6908f660", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({ \"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\" })\npublic class LRExprParenParser extends Parser {\n\n    static {\n        RuntimeMetaData.checkVersion(\"4.9.2\", RuntimeMetaData.VERSION);\n    }\n\n    protected static final DFA[] _decisionToDFA;\n\n    protected static final PredictionContextCache _sharedContextCache = new PredictionContextCache();\n\n    public static final int T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, ID = 6, INT = 7, WS = 8;\n\n    public static final int RULE_stat = 0, RULE_expr = 1;\n\n    private static String[] makeRuleNames() {\n        return new String[] { \"stat\", \"expr\" };\n    }\n\n    public static final String[] ruleNames = makeRuleNames();\n\n    private static String[] makeLiteralNames() {\n        return new String[] { null, \"';'\", \"'*'\", \"'+'\", \"'('\", \"')'\" };\n    }\n\n    private static final String[] _LITERAL_NAMES = makeLiteralNames();\n\n    private static String[] makeSymbolicNames() {\n        return new String[] { null, null, null, null, null, null, \"ID\", \"INT\", \"WS\" };\n    }\n\n    private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();\n\n    public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);\n\n    /**\n     * @deprecated Use {@link #VOCABULARY} instead.\n     */\n    @Deprecated\n    public static final String[] tokenNames;\n\n    static {\n        tokenNames = new String[_SYMBOLIC_NAMES.length];\n        for (int i = 0; i < tokenNames.length; i++) {\n            tokenNames[i] = VOCABULARY.getLiteralName(i);\n            if (tokenNames[i] == null) {\n                tokenNames[i] = VOCABULARY.getSymbolicName(i);\n            }\n            if (tokenNames[i] == null) {\n                tokenNames[i] = \"<INVALID>\";\n            }\n        }\n    }\n\n    @Override\n    @Deprecated\n    public String[] getTokenNames() {\n        return tokenNames;\n    }\n\n    @Override\n    public Vocabulary getVocabulary() {\n        return VOCABULARY;\n    }\n\n    @Override\n    public String getGrammarFileName() {\n        return \"LRExprParen.g4\";\n    }\n\n    @Override\n    public String[] getRuleNames() {\n        return ruleNames;\n    }\n\n    @Override\n    public String getSerializedATN() {\n        return _serializedATN;\n    }\n\n    @Override\n    public ATN getATN() {\n        return _ATN;\n    }\n\n    public LRExprParenParser(TokenStream input) {\n        super(input);\n        _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n    }\n\n    public static class StatContext extends ParserRuleContext {\n\n        public ExprContext expr() {\n            return getRuleContext(ExprContext.class, 0);\n        }\n\n        public TerminalNode EOF() {\n            return getToken(LRExprParenParser.EOF, 0);\n        }\n\n        public StatContext(ParserRuleContext parent, int invokingState) {\n            super(parent, invokingState);\n        }\n\n        @Override\n        public int getRuleIndex() {\n            return RULE_stat;\n        }\n\n        @Override\n        public void enterRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).enterStat(this);\n        }\n\n        @Override\n        public void exitRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).exitStat(this);\n        }\n\n        @Override\n        public <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n            if (visitor instanceof LRExprParenVisitor)\n                return ((LRExprParenVisitor<? extends T>) visitor).visitStat(this);\n            else\n                return visitor.visitChildren(this);\n        }\n    }\n\n    public final StatContext stat() throws RecognitionException {\n        StatContext _localctx = new StatContext(_ctx, getState());\n        enterRule(_localctx, 0, RULE_stat);\n        try {\n            enterOuterAlt(_localctx, 1);\n            {\n                setState(4);\n                expr(0);\n                setState(5);\n                match(T__0);\n                setState(6);\n                match(EOF);\n            }\n        } catch (RecognitionException re) {\n            _localctx.exception = re;\n            _errHandler.reportError(this, re);\n            _errHandler.recover(this, re);\n        } finally {\n            exitRule();\n        }\n        return _localctx;\n    }\n\n    public static class ExprContext extends ParserRuleContext {\n\n        public List<ExprContext> expr() {\n            return getRuleContexts(ExprContext.class);\n        }\n\n        public ExprContext expr(int i) {\n            return getRuleContext(ExprContext.class, i);\n        }\n\n        public TerminalNode INT() {\n            return getToken(LRExprParenParser.INT, 0);\n        }\n\n        public TerminalNode ID() {\n            return getToken(LRExprParenParser.ID, 0);\n        }\n\n        public ExprContext(ParserRuleContext parent, int invokingState) {\n            super(parent, invokingState);\n        }\n\n        @Override\n        public int getRuleIndex() {\n            return RULE_expr;\n        }\n\n        @Override\n        public void enterRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).enterExpr(this);\n        }\n\n        @Override\n        public void exitRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).exitExpr(this);\n        }\n\n        @Override\n        public <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n            if (visitor instanceof LRExprParenVisitor)\n                return ((LRExprParenVisitor<? extends T>) visitor).visitExpr(this);\n            else\n                return visitor.visitChildren(this);\n        }\n    }\n\n    public final ExprContext expr() throws RecognitionException {\n        return expr(0);\n    }\n\n    private ExprContext expr(int _p) throws RecognitionException {\n        ParserRuleContext _parentctx = _ctx;\n        int _parentState = getState();\n        ExprContext _localctx = new ExprContext(_ctx, _parentState);\n        ExprContext _prevctx = _localctx;\n        int _startState = 2;\n        enterRecursionRule(_localctx, 2, RULE_expr, _p);\n        try {\n            int _alt;\n            enterOuterAlt(_localctx, 1);\n            {\n                setState(15);\n                _errHandler.sync(this);\n                switch(_input.LA(1)) {\n                    case T__3:\n                        {\n                            setState(9);\n                            match(T__3);\n                            setState(10);\n                            expr(0);\n                            setState(11);\n                            match(T__4);\n                        }\n                        break;\n                    case INT:\n                        {\n                            setState(13);\n                            match(INT);\n                        }\n                        break;\n                    case ID:\n                        {\n                            setState(14);\n                            match(ID);\n                        }\n                        break;\n                    default:\n                        throw new NoViableAltException(this);\n                }\n                _ctx.stop = _input.LT(-1);\n                setState(25);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 2, _ctx);\n                for (; _alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER; ) {\n                    if (_alt == 1) {\n                        if (_parseListeners != null)\n                            triggerExitRuleEvent();\n                        _prevctx = _localctx;\n                        {\n                            setState(23);\n                            _errHandler.sync(this);\n                            switch(getInterpreter().adaptivePredict(_input, 1, _ctx)) {\n                                case 1:\n                                    {\n                                        _localctx = new ExprContext(_parentctx, _parentState);\n                                        pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                        setState(17);\n                                        if (!(precpred(_ctx, 5)))\n                                            throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n                                        setState(18);\n                                        match(T__1);\n                                        setState(19);\n                                        expr(6);\n                                    }\n                                    break;\n                                case 2:\n                                    {\n                                        _localctx = new ExprContext(_parentctx, _parentState);\n                                        pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                        setState(20);\n                                        if (!(precpred(_ctx, 4)))\n                                            throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n                                        setState(21);\n                                        match(T__2);\n                                        setState(22);\n                                        expr(5);\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                    setState(27);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 2, _ctx);\n                }\n            }\n        } catch (RecognitionException re) {\n            _localctx.exception = re;\n            _errHandler.reportError(this, re);\n            _errHandler.recover(this, re);\n        } finally {\n            unrollRecursionContexts(_parentctx);\n        }\n        return _localctx;\n    }\n\n    public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n        switch(ruleIndex) {\n            case 1:\n                return expr_sempred((ExprContext) _localctx, predIndex);\n        }\n        return true;\n    }\n\n    private boolean expr_sempred(ExprContext _localctx, int predIndex) {\n        switch(predIndex) {\n            case 0:\n                return precpred(_ctx, 5);\n            case 1:\n                return precpred(_ctx, 4);\n        }\n        return true;\n    }\n\n    public static final String _serializedATN = \"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3\\n\\37\\4\\2\\t\\2\\4\\3\" + \"\\t\\3\\3\\2\\3\\2\\3\\2\\3\\2\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3\\22\\n\\3\\3\\3\\3\\3\\3\" + \"\\3\\3\\3\\3\\3\\3\\3\\7\\3\\32\\n\\3\\f\\3\\16\\3\\35\\13\\3\\3\\3\\2\\3\\4\\4\\2\\4\\2\\2\\2 \\2\\6\" + \"\\3\\2\\2\\2\\4\\21\\3\\2\\2\\2\\6\\7\\5\\4\\3\\2\\7\\b\\7\\3\\2\\2\\b\\t\\7\\2\\2\\3\\t\\3\\3\\2\\2\\2\" + \"\\n\\13\\b\\3\\1\\2\\13\\f\\7\\6\\2\\2\\f\\r\\5\\4\\3\\2\\r\\16\\7\\7\\2\\2\\16\\22\\3\\2\\2\\2\\17\\22\" + \"\\7\\t\\2\\2\\20\\22\\7\\b\\2\\2\\21\\n\\3\\2\\2\\2\\21\\17\\3\\2\\2\\2\\21\\20\\3\\2\\2\\2\\22\\33\" + \"\\3\\2\\2\\2\\23\\24\\f\\7\\2\\2\\24\\25\\7\\4\\2\\2\\25\\32\\5\\4\\3\\b\\26\\27\\f\\6\\2\\2\\27\\30\" + \"\\7\\5\\2\\2\\30\\32\\5\\4\\3\\7\\31\\23\\3\\2\\2\\2\\31\\26\\3\\2\\2\\2\\32\\35\\3\\2\\2\\2\\33\\31\" + \"\\3\\2\\2\\2\\33\\34\\3\\2\\2\\2\\34\\5\\3\\2\\2\\2\\35\\33\\3\\2\\2\\2\\5\\21\\31\\33\";\n\n    public static final ATN _ATN = new ATNDeserializer().deserialize(_serializedATN.toCharArray());\n\n    static {\n        _decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];\n        for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {\n            _decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);\n        }\n    }\n}\n", "class_id": 0, "repo": "courses-at-nju-by-hfwei/compilers-antlr", "file": "build/generated-src/antlr/main/parserllantlr/LRExprParenParser.java", "last_update_at": "2021-12-16T03:24:37+00:00", "original_content": "@SuppressWarnings({ \"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\" })\npublic class LRExprParenParser extends Parser {\n\n    static {\n        RuntimeMetaData.checkVersion(\"4.9.2\", RuntimeMetaData.VERSION);\n    }\n\n    protected static final DFA[] _decisionToDFA;\n\n    protected static final PredictionContextCache _sharedContextCache = new PredictionContextCache();\n\n    public static final int T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, ID = 6, INT = 7, WS = 8;\n\n    public static final int RULE_stat = 0, RULE_expr = 1;\n\n    private static String[] makeRuleNames() {\n        return new String[] { \"stat\", \"expr\" };\n    }\n\n    public static final String[] ruleNames = makeRuleNames();\n\n    private static String[] makeLiteralNames() {\n        return new String[] { null, \"';'\", \"'*'\", \"'+'\", \"'('\", \"')'\" };\n    }\n\n    private static final String[] _LITERAL_NAMES = makeLiteralNames();\n\n    private static String[] makeSymbolicNames() {\n        return new String[] { null, null, null, null, null, null, \"ID\", \"INT\", \"WS\" };\n    }\n\n    private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();\n\n    public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);\n\n    /**\n     * @deprecated Use {@link #VOCABULARY} instead.\n     */\n    @Deprecated\n    public static final String[] tokenNames;\n\n    static {\n        tokenNames = new String[_SYMBOLIC_NAMES.length];\n        for (int i = 0; i < tokenNames.length; i++) {\n            tokenNames[i] = VOCABULARY.getLiteralName(i);\n            if (tokenNames[i] == null) {\n                tokenNames[i] = VOCABULARY.getSymbolicName(i);\n            }\n            if (tokenNames[i] == null) {\n                tokenNames[i] = \"<INVALID>\";\n            }\n        }\n    }\n\n    @Override\n    @Deprecated\n    public String[] getTokenNames() {\n        return tokenNames;\n    }\n\n    @Override\n    public Vocabulary getVocabulary() {\n        return VOCABULARY;\n    }\n\n    @Override\n    public String getGrammarFileName() {\n        return \"LRExprParen.g4\";\n    }\n\n    @Override\n    public String[] getRuleNames() {\n        return ruleNames;\n    }\n\n    @Override\n    public String getSerializedATN() {\n        return _serializedATN;\n    }\n\n    @Override\n    public ATN getATN() {\n        return _ATN;\n    }\n\n    public LRExprParenParser(TokenStream input) {\n        super(input);\n        _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n    }\n\n    public static class StatContext extends ParserRuleContext {\n\n        public ExprContext expr() {\n            return getRuleContext(ExprContext.class, 0);\n        }\n\n        public TerminalNode EOF() {\n            return getToken(LRExprParenParser.EOF, 0);\n        }\n\n        public StatContext(ParserRuleContext parent, int invokingState) {\n            super(parent, invokingState);\n        }\n\n        @Override\n        public int getRuleIndex() {\n            return RULE_stat;\n        }\n\n        @Override\n        public void enterRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).enterStat(this);\n        }\n\n        @Override\n        public void exitRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).exitStat(this);\n        }\n\n        @Override\n        public <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n            if (visitor instanceof LRExprParenVisitor)\n                return ((LRExprParenVisitor<? extends T>) visitor).visitStat(this);\n            else\n                return visitor.visitChildren(this);\n        }\n    }\n\n    public final StatContext stat() throws RecognitionException {\n        StatContext _localctx = new StatContext(_ctx, getState());\n        enterRule(_localctx, 0, RULE_stat);\n        try {\n            enterOuterAlt(_localctx, 1);\n            {\n                setState(4);\n                expr(0);\n                setState(5);\n                match(T__0);\n                setState(6);\n                match(EOF);\n            }\n        } catch (RecognitionException re) {\n            _localctx.exception = re;\n            _errHandler.reportError(this, re);\n            _errHandler.recover(this, re);\n        } finally {\n            exitRule();\n        }\n        return _localctx;\n    }\n\n    public static class ExprContext extends ParserRuleContext {\n\n        public List<ExprContext> expr() {\n            return getRuleContexts(ExprContext.class);\n        }\n\n        public ExprContext expr(int i) {\n            return getRuleContext(ExprContext.class, i);\n        }\n\n        public TerminalNode INT() {\n            return getToken(LRExprParenParser.INT, 0);\n        }\n\n        public TerminalNode ID() {\n            return getToken(LRExprParenParser.ID, 0);\n        }\n\n        public ExprContext(ParserRuleContext parent, int invokingState) {\n            super(parent, invokingState);\n        }\n\n        @Override\n        public int getRuleIndex() {\n            return RULE_expr;\n        }\n\n        @Override\n        public void enterRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).enterExpr(this);\n        }\n\n        @Override\n        public void exitRule(ParseTreeListener listener) {\n            if (listener instanceof LRExprParenListener)\n                ((LRExprParenListener) listener).exitExpr(this);\n        }\n\n        @Override\n        public <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n            if (visitor instanceof LRExprParenVisitor)\n                return ((LRExprParenVisitor<? extends T>) visitor).visitExpr(this);\n            else\n                return visitor.visitChildren(this);\n        }\n    }\n\n    public final ExprContext expr() throws RecognitionException {\n        return expr(0);\n    }\n\n    private ExprContext expr(int _p) throws RecognitionException {\n        ParserRuleContext _parentctx = _ctx;\n        int _parentState = getState();\n        ExprContext _localctx = new ExprContext(_ctx, _parentState);\n        ExprContext _prevctx = _localctx;\n        int _startState = 2;\n        enterRecursionRule(_localctx, 2, RULE_expr, _p);\n        try {\n            int _alt;\n            enterOuterAlt(_localctx, 1);\n            {\n                setState(15);\n                _errHandler.sync(this);\n                switch(_input.LA(1)) {\n                    case T__3:\n                        {\n                            setState(9);\n                            match(T__3);\n                            setState(10);\n                            expr(0);\n                            setState(11);\n                            match(T__4);\n                        }\n                        break;\n                    case INT:\n                        {\n                            setState(13);\n                            match(INT);\n                        }\n                        break;\n                    case ID:\n                        {\n                            setState(14);\n                            match(ID);\n                        }\n                        break;\n                    default:\n                        throw new NoViableAltException(this);\n                }\n                _ctx.stop = _input.LT(-1);\n                setState(25);\n                _errHandler.sync(this);\n                _alt = getInterpreter().adaptivePredict(_input, 2, _ctx);\n                while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {\n                    if (_alt == 1) {\n                        if (_parseListeners != null)\n                            triggerExitRuleEvent();\n                        _prevctx = _localctx;\n                        {\n                            setState(23);\n                            _errHandler.sync(this);\n                            switch(getInterpreter().adaptivePredict(_input, 1, _ctx)) {\n                                case 1:\n                                    {\n                                        _localctx = new ExprContext(_parentctx, _parentState);\n                                        pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                        setState(17);\n                                        if (!(precpred(_ctx, 5)))\n                                            throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n                                        setState(18);\n                                        match(T__1);\n                                        setState(19);\n                                        expr(6);\n                                    }\n                                    break;\n                                case 2:\n                                    {\n                                        _localctx = new ExprContext(_parentctx, _parentState);\n                                        pushNewRecursionContext(_localctx, _startState, RULE_expr);\n                                        setState(20);\n                                        if (!(precpred(_ctx, 4)))\n                                            throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n                                        setState(21);\n                                        match(T__2);\n                                        setState(22);\n                                        expr(5);\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                    setState(27);\n                    _errHandler.sync(this);\n                    _alt = getInterpreter().adaptivePredict(_input, 2, _ctx);\n                }\n            }\n        } catch (RecognitionException re) {\n            _localctx.exception = re;\n            _errHandler.reportError(this, re);\n            _errHandler.recover(this, re);\n        } finally {\n            unrollRecursionContexts(_parentctx);\n        }\n        return _localctx;\n    }\n\n    public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {\n        switch(ruleIndex) {\n            case 1:\n                return expr_sempred((ExprContext) _localctx, predIndex);\n        }\n        return true;\n    }\n\n    private boolean expr_sempred(ExprContext _localctx, int predIndex) {\n        switch(predIndex) {\n            case 0:\n                return precpred(_ctx, 5);\n            case 1:\n                return precpred(_ctx, 4);\n        }\n        return true;\n    }\n\n    public static final String _serializedATN = \"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3\\n\\37\\4\\2\\t\\2\\4\\3\" + \"\\t\\3\\3\\2\\3\\2\\3\\2\\3\\2\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3\\22\\n\\3\\3\\3\\3\\3\\3\" + \"\\3\\3\\3\\3\\3\\3\\3\\7\\3\\32\\n\\3\\f\\3\\16\\3\\35\\13\\3\\3\\3\\2\\3\\4\\4\\2\\4\\2\\2\\2 \\2\\6\" + \"\\3\\2\\2\\2\\4\\21\\3\\2\\2\\2\\6\\7\\5\\4\\3\\2\\7\\b\\7\\3\\2\\2\\b\\t\\7\\2\\2\\3\\t\\3\\3\\2\\2\\2\" + \"\\n\\13\\b\\3\\1\\2\\13\\f\\7\\6\\2\\2\\f\\r\\5\\4\\3\\2\\r\\16\\7\\7\\2\\2\\16\\22\\3\\2\\2\\2\\17\\22\" + \"\\7\\t\\2\\2\\20\\22\\7\\b\\2\\2\\21\\n\\3\\2\\2\\2\\21\\17\\3\\2\\2\\2\\21\\20\\3\\2\\2\\2\\22\\33\" + \"\\3\\2\\2\\2\\23\\24\\f\\7\\2\\2\\24\\25\\7\\4\\2\\2\\25\\32\\5\\4\\3\\b\\26\\27\\f\\6\\2\\2\\27\\30\" + \"\\7\\5\\2\\2\\30\\32\\5\\4\\3\\7\\31\\23\\3\\2\\2\\2\\31\\26\\3\\2\\2\\2\\32\\35\\3\\2\\2\\2\\33\\31\" + \"\\3\\2\\2\\2\\33\\34\\3\\2\\2\\2\\34\\5\\3\\2\\2\\2\\35\\33\\3\\2\\2\\2\\5\\21\\31\\33\";\n\n    public static final ATN _ATN = new ATNDeserializer().deserialize(_serializedATN.toCharArray());\n\n    static {\n        _decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];\n        for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {\n            _decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "80b509f6a9d12338612de5cf8c483f27953d4d54", "ext": "java", "lang": "Java", "content": "public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {\n\n    private int x;\n\n    private int y;\n\n    private int z;\n\n    private List<IoMode> modes;\n\n    private Channel selectedChannel;\n\n    public PacketClientState() {\n    }\n\n    public PacketClientState(TileHyperCube te) {\n        x = te.xCoord;\n        y = te.yCoord;\n        z = te.zCoord;\n        modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n        for (SubChannel sc : SubChannel.values()) {\n            modes.add(te.getModeForChannel(sc));\n        }\n        selectedChannel = te.getChannel();\n    }\n\n    @Override\n    public void toBytes(ByteBuf buf) {\n        buf.writeInt(x);\n        buf.writeInt(y);\n        buf.writeInt(z);\n        if (selectedChannel == null) {\n            ByteBufUtils.writeUTF8String(buf, \"\");\n            ByteBufUtils.writeUTF8String(buf, \"\");\n        } else {\n            ByteBufUtils.writeUTF8String(buf, selectedChannel.name);\n            if (selectedChannel.isPublic()) {\n                ByteBufUtils.writeUTF8String(buf, \"\");\n            } else {\n                ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());\n            }\n        }\n        for (IoMode mode : modes) {\n            buf.writeShort(mode.ordinal());\n        }\n    }\n\n    @Override\n    public void fromBytes(ByteBuf buf) {\n        x = buf.readInt();\n        y = buf.readInt();\n        z = buf.readInt();\n        String name = ByteBufUtils.readUTF8String(buf);\n        String user = ByteBufUtils.readUTF8String(buf);\n        selectedChannel = null;\n        if (name != null && name.trim().length() > 0) {\n            if (user != null && user.trim().length() > 0) {\n                selectedChannel = new Channel(name, user);\n            } else {\n                selectedChannel = new Channel(name, null);\n            }\n        }\n        modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n        for (SubChannel sc : SubChannel.values()) {\n            short ordinal = buf.readShort();\n            modes.add(IoMode.values()[ordinal]);\n        }\n    }\n\n    @Override\n    public IMessage onMessage(PacketClientState message, MessageContext ctx) {\n        EntityPlayer player = ctx.getServerHandler().playerEntity;\n        TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);\n        if (te instanceof TileHyperCube) {\n            TileHyperCube hc = (TileHyperCube) te;\n            SubChannel[] vals = SubChannel.values();\n            int i = 0;\n            while (i < vals.length) try {\n                SubChannel sc = vals[i];\n                IoMode mode = message.modes.get(i);\n                hc.setModeForChannel(sc, mode);\n            } finally {\n                i++;\n            }\n            hc.setChannel(message.selectedChannel);\n            player.worldObj.markBlockForUpdate(message.x, message.y, message.z);\n        }\n        return null;\n    }\n}\n", "class_id": 0, "repo": "LorenzoDCC/EnderIO", "file": "src/main/java/crazypants/enderio/machine/hypercube/PacketClientState.java", "last_update_at": "2021-08-22T03:46:51+00:00", "original_content": "public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {\n\n    private int x;\n\n    private int y;\n\n    private int z;\n\n    private List<IoMode> modes;\n\n    private Channel selectedChannel;\n\n    public PacketClientState() {\n    }\n\n    public PacketClientState(TileHyperCube te) {\n        x = te.xCoord;\n        y = te.yCoord;\n        z = te.zCoord;\n        modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n        for (SubChannel sc : SubChannel.values()) {\n            modes.add(te.getModeForChannel(sc));\n        }\n        selectedChannel = te.getChannel();\n    }\n\n    @Override\n    public void toBytes(ByteBuf buf) {\n        buf.writeInt(x);\n        buf.writeInt(y);\n        buf.writeInt(z);\n        if (selectedChannel == null) {\n            ByteBufUtils.writeUTF8String(buf, \"\");\n            ByteBufUtils.writeUTF8String(buf, \"\");\n        } else {\n            ByteBufUtils.writeUTF8String(buf, selectedChannel.name);\n            if (selectedChannel.isPublic()) {\n                ByteBufUtils.writeUTF8String(buf, \"\");\n            } else {\n                ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());\n            }\n        }\n        for (IoMode mode : modes) {\n            buf.writeShort(mode.ordinal());\n        }\n    }\n\n    @Override\n    public void fromBytes(ByteBuf buf) {\n        x = buf.readInt();\n        y = buf.readInt();\n        z = buf.readInt();\n        String name = ByteBufUtils.readUTF8String(buf);\n        String user = ByteBufUtils.readUTF8String(buf);\n        selectedChannel = null;\n        if (name != null && name.trim().length() > 0) {\n            if (user != null && user.trim().length() > 0) {\n                selectedChannel = new Channel(name, user);\n            } else {\n                selectedChannel = new Channel(name, null);\n            }\n        }\n        modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);\n        for (SubChannel sc : SubChannel.values()) {\n            short ordinal = buf.readShort();\n            modes.add(IoMode.values()[ordinal]);\n        }\n    }\n\n    @Override\n    public IMessage onMessage(PacketClientState message, MessageContext ctx) {\n        EntityPlayer player = ctx.getServerHandler().playerEntity;\n        TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);\n        if (te instanceof TileHyperCube) {\n            TileHyperCube hc = (TileHyperCube) te;\n            SubChannel[] vals = SubChannel.values();\n            for (int i = 0; i < vals.length; i++) {\n                SubChannel sc = vals[i];\n                IoMode mode = message.modes.get(i);\n                hc.setModeForChannel(sc, mode);\n            }\n            hc.setChannel(message.selectedChannel);\n            player.worldObj.markBlockForUpdate(message.x, message.y, message.z);\n        }\n        return null;\n    }\n}\n", "refactored": true}
{"hexsha": "2d088d08cd730611273367ea147d60a48850ecf1", "ext": "java", "lang": "Java", "content": "public final class ResourceLoader {\n\n    static ObjectMapper om;\n\n    static {\n        om = new ObjectMapper();\n        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).enable(SerializationFeature.INDENT_OUTPUT);\n        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n        om.registerModule(new JavaTimeModule());\n        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n\n    public static String load(String resourceName) {\n        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {\n            return IOUtils.toString(is, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String loadGitlabFile(String resourceName) {\n        String loaded = load(resourceName);\n        GitlabFile file = GitlabFile.builder().content(loaded).filePath(\"engagement.json\").build();\n        file.encodeFileAttributes();\n        try {\n            return om.writeValueAsString(file);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n", "class_id": 0, "repo": "rht-labs/lodestar-hosting", "file": "src/test/java/com/redhat/labs/lodestar/hosting/mock/ResourceLoader.java", "last_update_at": "2021-08-09T16:55:15+00:00", "original_content": "public final class ResourceLoader {\n\n    static ObjectMapper om;\n\n    static {\n        om = new ObjectMapper();\n        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).enable(SerializationFeature.INDENT_OUTPUT);\n        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n        om.registerModule(new JavaTimeModule());\n        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n\n    public static String load(String resourceName) {\n        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {\n            return IOUtils.toString(is, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String loadGitlabFile(String resourceName) {\n        String loaded = load(resourceName);\n        GitlabFile file = GitlabFile.builder().content(loaded).filePath(\"engagement.json\").build();\n        file.encodeFileAttributes();\n        try {\n            return om.writeValueAsString(file);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n", "refactored": false}
{"hexsha": "900efec8f77509ae8a2b4b9488dc2c67b487169f", "ext": "java", "lang": "Java", "content": "public class OpFactory {\n\n    public static ASTLeaf createOperator(Token t) {\n        String op = t.getText();\n        String[] AssignOperators = { \"+=\", \"-=\", \"*=\", \"/=\" };\n        if (Arrays.asList(AssignOperators).contains(op))\n            return new CompoundAssignOperator(t);\n        else if (op.equals(\"=\"))\n            return new AssignOperator(t);\n        else if (op.equals(\"+\"))\n            return new PlusOperator(t);\n        else if (op.equals(\"-\"))\n            return new MinusOperator(t);\n        else if (op.equals(\"*\"))\n            return new ProductOperator(t);\n        else if (op.equals(\"/\"))\n            return new QuotientOperator(t);\n        else if (op.equals(\"%\"))\n            return new SurplusOperator(t);\n        else if (op.equals(\"==\"))\n            return new EqualityOperator(t);\n        else if (op.equals(\"!=\"))\n            return new NonEqualityOperator(t);\n        else if (op.equals(\">\"))\n            return new MoreOperator(t);\n        else if (op.equals(\">=\"))\n            return new MoreOrEqualOperator(t);\n        else if (op.equals(\"<\"))\n            return new LessOperator(t);\n        else if (op.equals(\"<=\"))\n            return new LessOrEqualOperator(t);\n        else if (op.equals(\"&&\"))\n            return new AndOperator(t);\n        else if (op.equals(\"||\"))\n            return new OrOperator(t);\n        throw new SheepException(\"Unsupported operator\", t.getLineNumber());\n    }\n}\n", "class_id": 0, "repo": "teru01/Sheep", "file": "src/main/java/sheep/operator/OpFactory.java", "last_update_at": "2021-07-13T15:30:20+00:00", "original_content": "public class OpFactory {\n\n    public static ASTLeaf createOperator(Token t) {\n        String op = t.getText();\n        String[] AssignOperators = { \"+=\", \"-=\", \"*=\", \"/=\" };\n        if (Arrays.asList(AssignOperators).contains(op))\n            return new CompoundAssignOperator(t);\n        else if (op.equals(\"=\"))\n            return new AssignOperator(t);\n        else if (op.equals(\"+\"))\n            return new PlusOperator(t);\n        else if (op.equals(\"-\"))\n            return new MinusOperator(t);\n        else if (op.equals(\"*\"))\n            return new ProductOperator(t);\n        else if (op.equals(\"/\"))\n            return new QuotientOperator(t);\n        else if (op.equals(\"%\"))\n            return new SurplusOperator(t);\n        else if (op.equals(\"==\"))\n            return new EqualityOperator(t);\n        else if (op.equals(\"!=\"))\n            return new NonEqualityOperator(t);\n        else if (op.equals(\">\"))\n            return new MoreOperator(t);\n        else if (op.equals(\">=\"))\n            return new MoreOrEqualOperator(t);\n        else if (op.equals(\"<\"))\n            return new LessOperator(t);\n        else if (op.equals(\"<=\"))\n            return new LessOrEqualOperator(t);\n        else if (op.equals(\"&&\"))\n            return new AndOperator(t);\n        else if (op.equals(\"||\"))\n            return new OrOperator(t);\n        throw new SheepException(\"Unsupported operator\", t.getLineNumber());\n    }\n}\n", "refactored": false}
{"hexsha": "73c0128eea6de9f738bb18aeb804b5c4154dd8dc", "ext": "java", "lang": "Java", "content": "@ExtendWith(MockitoExtension.class)\nclass AuthCodeGenerationServiceTest {\n\n    @Mock\n    private AuthorizationCodeRepository repository;\n\n    @InjectMocks\n    private AuthCodeGenerationService testee;\n\n    @Test\n    void test_create() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));\n        when(repository.existsByCode(anyString())).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_code_already_exists() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_in_future() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_too_far_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017, 7, 7));\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_4_weeks_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_now() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n}\n", "class_id": 0, "repo": "Ruben23/CovidCode-Service", "file": "src/test/java/ch/admin/bag/covidcode/authcodegeneration/service/AuthCodeGenerationServiceTest.java", "last_update_at": "2021-09-11T08:45:20+00:00", "original_content": "@ExtendWith(MockitoExtension.class)\nclass AuthCodeGenerationServiceTest {\n\n    @Mock\n    private AuthorizationCodeRepository repository;\n\n    @InjectMocks\n    private AuthCodeGenerationService testee;\n\n    @Test\n    void test_create() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));\n        when(repository.existsByCode(anyString())).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_code_already_exists() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_in_future() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_too_far_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017, 7, 7));\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));\n        //then\n        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_4_weeks_back() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n\n    @Test\n    void test_create_valid_onset_date_exactly_now() {\n        //given\n        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());\n        //when\n        AuthorizationCodeResponseDto responseDto = testee.create(createDto);\n        //then\n        assertNotNull(responseDto.getAuthorizationCode());\n        assertTrue(responseDto.getAuthorizationCode().matches(\"\\\\d{12}\"));\n        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));\n    }\n}\n", "refactored": false}
{"hexsha": "bbc956ee5ff3ca405fd0af54c93d59a6b745685b", "ext": "java", "lang": "Java", "content": "@Service\npublic class ItemService {\n\n    @Autowired\n    private GmallPmsClient pmsClient;\n\n    @Autowired\n    private GmallSmsClient smsClient;\n\n    @Autowired\n    private GmallWmsClient wmsClient;\n\n    @Autowired\n    private ThreadPoolExecutor threadPoolExecutor;\n\n    public ItemVO queryItemVO(Long skuId) {\n        ItemVO itemVO = new ItemVO();\n        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {\n            itemVO.setSkuId(skuId);\n            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);\n            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();\n            if (skuInfoEntity == null) {\n                return null;\n            }\n            itemVO.setWeight(skuInfoEntity.getWeight());\n            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());\n            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());\n            itemVO.setPrice(skuInfoEntity.getPrice());\n            return skuInfoEntity;\n        }, threadPoolExecutor);\n        //thanApplyAsync: ???????\n        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());\n            CategoryEntity categoryEntity = categoryEntityResp.getData();\n            if (categoryEntity != null) {\n                itemVO.setCategoryId(categoryEntity.getCatId());\n                itemVO.setCategoryName(categoryEntity.getName());\n            }\n        }, threadPoolExecutor);\n        //??sku??brandID????\n        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());\n            BrandEntity brandEntity = brandEntityResp.getData();\n            if (brandEntity != null) {\n                itemVO.setBrandId(brandEntity.getBrandId());\n                itemVO.setBrandName(brandEntity.getName());\n            }\n        }, threadPoolExecutor);\n        //??sku??spu??spu\n        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());\n            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();\n            if (skuInfoEntity != null) {\n                itemVO.setSpuId(spuInfoEntity.getId());\n                itemVO.setSpuName(spuInfoEntity.getSpuName());\n            }\n        }, threadPoolExecutor);\n        //??sku????????\n        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);\n            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();\n            if (!CollectionUtils.isEmpty(imagesEntities)) {\n                itemVO.setImeges(imagesEntities);\n            }\n        }, threadPoolExecutor);\n        //??skuid????\n        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);\n            List<WareSkuEntity> wareSkuEntities = listResp.getData();\n            if (!CollectionUtils.isEmpty(wareSkuEntities)) {\n                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));\n            }\n        }, threadPoolExecutor);\n        //??skuid??????3?\n        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);\n            List<ItemSaleVO> itemSaleVOList = listResp1.getData();\n            itemVO.setSales(itemSaleVOList);\n        }, threadPoolExecutor);\n        //??sku??spuID??????\n        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());\n            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();\n            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {\n                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), \",\")));\n            }\n        }, threadPoolExecutor);\n        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());\n            List<ItemGroupVO> itemGroupVOS = listResp2.getData();\n            itemVO.setGroupVOS(itemGroupVOS);\n        }, threadPoolExecutor);\n        //??skuIds??????\n        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());\n            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();\n            itemVO.setSaleAttrs(skuSaleAttrValueEntities);\n        }, threadPoolExecutor);\n        CompletableFuture.allOf(completableFuture, cateCompletablbe, brandCompletablbe, spuCompletable, imagesCompletableFuture, skuCompletableFuture, saleCompletableFuture, descCompletableFuture, groupCompletableFuture, attrValueCompletableFuture).join();\n        return itemVO;\n    }\n}\n", "class_id": 0, "repo": "lxftheking/gmall", "file": "gmall-item/src/main/java/com/atguigu/gmall/item/service/ItemService.java", "last_update_at": "2021-09-09T07:21:17+00:00", "original_content": "@Service\npublic class ItemService {\n\n    @Autowired\n    private GmallPmsClient pmsClient;\n\n    @Autowired\n    private GmallSmsClient smsClient;\n\n    @Autowired\n    private GmallWmsClient wmsClient;\n\n    @Autowired\n    private ThreadPoolExecutor threadPoolExecutor;\n\n    public ItemVO queryItemVO(Long skuId) {\n        ItemVO itemVO = new ItemVO();\n        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {\n            itemVO.setSkuId(skuId);\n            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);\n            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();\n            if (skuInfoEntity == null) {\n                return null;\n            }\n            itemVO.setWeight(skuInfoEntity.getWeight());\n            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());\n            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());\n            itemVO.setPrice(skuInfoEntity.getPrice());\n            return skuInfoEntity;\n        }, threadPoolExecutor);\n        //thanApplyAsync: ???????\n        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());\n            CategoryEntity categoryEntity = categoryEntityResp.getData();\n            if (categoryEntity != null) {\n                itemVO.setCategoryId(categoryEntity.getCatId());\n                itemVO.setCategoryName(categoryEntity.getName());\n            }\n        }, threadPoolExecutor);\n        //??sku??brandID????\n        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());\n            BrandEntity brandEntity = brandEntityResp.getData();\n            if (brandEntity != null) {\n                itemVO.setBrandId(brandEntity.getBrandId());\n                itemVO.setBrandName(brandEntity.getName());\n            }\n        }, threadPoolExecutor);\n        //??sku??spu??spu\n        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());\n            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();\n            if (skuInfoEntity != null) {\n                itemVO.setSpuId(spuInfoEntity.getId());\n                itemVO.setSpuName(spuInfoEntity.getSpuName());\n            }\n        }, threadPoolExecutor);\n        //??sku????????\n        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);\n            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();\n            if (!CollectionUtils.isEmpty(imagesEntities)) {\n                itemVO.setImeges(imagesEntities);\n            }\n        }, threadPoolExecutor);\n        //??skuid????\n        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);\n            List<WareSkuEntity> wareSkuEntities = listResp.getData();\n            if (!CollectionUtils.isEmpty(wareSkuEntities)) {\n                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));\n            }\n        }, threadPoolExecutor);\n        //??skuid??????3?\n        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {\n            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);\n            List<ItemSaleVO> itemSaleVOList = listResp1.getData();\n            itemVO.setSales(itemSaleVOList);\n        }, threadPoolExecutor);\n        //??sku??spuID??????\n        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());\n            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();\n            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {\n                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), \",\")));\n            }\n        }, threadPoolExecutor);\n        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());\n            List<ItemGroupVO> itemGroupVOS = listResp2.getData();\n            itemVO.setGroupVOS(itemGroupVOS);\n        }, threadPoolExecutor);\n        //??skuIds??????\n        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {\n            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());\n            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();\n            itemVO.setSaleAttrs(skuSaleAttrValueEntities);\n        }, threadPoolExecutor);\n        CompletableFuture.allOf(completableFuture, cateCompletablbe, brandCompletablbe, spuCompletable, imagesCompletableFuture, skuCompletableFuture, saleCompletableFuture, descCompletableFuture, groupCompletableFuture, attrValueCompletableFuture).join();\n        return itemVO;\n    }\n}\n", "refactored": false}
{"hexsha": "b695b9c87c6ae72391dd9e982a7a2b9c105d886d", "ext": "java", "lang": "Java", "content": "public class VertexStroke {\n\n    /**\n     * Method to compute Vertex Stroke\n     *\n     * @param v JUNG's V (Vertex) type\n     * @param dash The array representing the dashing pattern\n     * @param view VisualizationViewer<Object, Edge>\n     * @param layout Layout<Object, Edge>\n     * @return Stroke\n     */\n    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {\n        PickedState<Object> picked_state = view.getPickedVertexState();\n        if (picked_state.isPicked(v)) {\n            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        } else {\n            for (Object w : layout.getGraph().getNeighbors(v)) {\n                if (picked_state.isPicked(w)) {\n                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n                }\n            }\n            //            if(value != value)\n            return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        }\n    }\n\n    /**\n     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,\n     * hired)\n     *\n     * @param v\n     * @param view\n     * @param layout\n     * @param variables\n     * @return\n     */\n    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {\n        float[] dash = null;\n        if (v instanceof Vertex) {\n            if (!variables.config.vertexStrokevariables.isEmpty()) {\n                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {\n                    String[] list = vertexStrokevariable.split(\" \");\n                    String att = ((Vertex) v).getAttributeValue(list[0]);\n                    if (!\"\".equals(att)) {\n                        int j = 1;\n                        while (j < list.length) try {\n                            if (att.equalsIgnoreCase(list[j])) {\n                                dash = new float[1];\n                                dash[0] = 4.0f;\n                            }\n                        } finally {\n                            j++;\n                        }\n                    }\n                }\n            }\n        }\n        return VertexStroke(v, dash, view, layout);\n    }\n}\n", "class_id": 0, "repo": "stain/prov-viewer", "file": "src/main/java/br/uff/ic/provviewer/Stroke/VertexStroke.java", "last_update_at": "2021-12-09T05:27:32+00:00", "original_content": "public class VertexStroke {\n\n    /**\n     * Method to compute Vertex Stroke\n     *\n     * @param v JUNG's V (Vertex) type\n     * @param dash The array representing the dashing pattern\n     * @param view VisualizationViewer<Object, Edge>\n     * @param layout Layout<Object, Edge>\n     * @return Stroke\n     */\n    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {\n        PickedState<Object> picked_state = view.getPickedVertexState();\n        if (picked_state.isPicked(v)) {\n            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        } else {\n            for (Object w : layout.getGraph().getNeighbors(v)) {\n                if (picked_state.isPicked(w)) {\n                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n                }\n            }\n            //            if(value != value)\n            return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);\n        }\n    }\n\n    /**\n     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,\n     * hired)\n     *\n     * @param v\n     * @param view\n     * @param layout\n     * @param variables\n     * @return\n     */\n    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {\n        float[] dash = null;\n        if (v instanceof Vertex) {\n            if (!variables.config.vertexStrokevariables.isEmpty()) {\n                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {\n                    String[] list = vertexStrokevariable.split(\" \");\n                    String att = ((Vertex) v).getAttributeValue(list[0]);\n                    if (!\"\".equals(att)) {\n                        for (int j = 1; j < list.length; j++) {\n                            if (att.equalsIgnoreCase(list[j])) {\n                                dash = new float[1];\n                                dash[0] = 4.0f;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return VertexStroke(v, dash, view, layout);\n    }\n}\n", "refactored": true}
{"hexsha": "1bfe81dec8dca4cb4bef7c48cad2b36862d7d8fe", "ext": "java", "lang": "Java", "content": "@ApiModel(description = \"A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet\")\n@JsonPropertyOrder({ PresentationResult.JSON_PROPERTY_SLIDE_NUMBER, PresentationResult.JSON_PROPERTY_U_R_L, PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS })\n@JsonTypeName(\"PresentationResult\")\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-11-14T13:47:19.979-08:00[America/Los_Angeles]\")\npublic class PresentationResult {\n\n    public static final String JSON_PROPERTY_SLIDE_NUMBER = \"SlideNumber\";\n\n    private Integer slideNumber;\n\n    public static final String JSON_PROPERTY_U_R_L = \"URL\";\n\n    private String URL;\n\n    public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = \"PresentationContents\";\n\n    private byte[] presentationContents;\n\n    public PresentationResult slideNumber(Integer slideNumber) {\n        this.slideNumber = slideNumber;\n        return this;\n    }\n\n    /**\n     * Worksheet number of the converted page, starting with 1 for the left-most worksheet\n     * @return slideNumber\n     */\n    @javax.annotation.Nullable\n    @ApiModelProperty(value = \"Worksheet number of the converted page, starting with 1 for the left-most worksheet\")\n    @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)\n    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n    public Integer getSlideNumber() {\n        return slideNumber;\n    }\n\n    public void setSlideNumber(Integer slideNumber) {\n        this.slideNumber = slideNumber;\n    }\n\n    public PresentationResult URL(String URL) {\n        this.URL = URL;\n        return this;\n    }\n\n    /**\n     * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\n     * @return URL\n     */\n    @javax.annotation.Nullable\n    @ApiModelProperty(value = \"URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\")\n    @JsonProperty(JSON_PROPERTY_U_R_L)\n    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n    public String getURL() {\n        return URL;\n    }\n\n    public void setURL(String URL) {\n        this.URL = URL;\n    }\n\n    public PresentationResult presentationContents(byte[] presentationContents) {\n        this.presentationContents = presentationContents;\n        return this;\n    }\n\n    /**\n     * Contents of the presentation in bytes\n     * @return presentationContents\n     */\n    @javax.annotation.Nullable\n    @ApiModelProperty(value = \"Contents of the presentation in bytes\")\n    @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)\n    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n    public byte[] getPresentationContents() {\n        return presentationContents;\n    }\n\n    public void setPresentationContents(byte[] presentationContents) {\n        this.presentationContents = presentationContents;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        PresentationResult presentationResult = (PresentationResult) o;\n        return Objects.equals(this.slideNumber, presentationResult.slideNumber) && Objects.equals(this.URL, presentationResult.URL) && Arrays.equals(this.presentationContents, presentationResult.presentationContents);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class PresentationResult {\\n\");\n        sb.append(\"    slideNumber: \").append(toIndentedString(slideNumber)).append(\"\\n\");\n        sb.append(\"    URL: \").append(toIndentedString(URL)).append(\"\\n\");\n        sb.append(\"    presentationContents: \").append(toIndentedString(presentationContents)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "class_id": 0, "repo": "Cloudmersive/Cloudmersive.APIClient.Java.RestTemplate", "file": "src/main/java/com/cloudmersive/client/rt/model/PresentationResult.java", "last_update_at": "2021-02-14T19:52:25+00:00", "original_content": "@ApiModel(description = \"A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet\")\n@JsonPropertyOrder({ PresentationResult.JSON_PROPERTY_SLIDE_NUMBER, PresentationResult.JSON_PROPERTY_U_R_L, PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS })\n@JsonTypeName(\"PresentationResult\")\n@javax.annotation.Generated(value = \"org.openapitools.codegen.languages.JavaClientCodegen\", date = \"2020-11-14T13:47:19.979-08:00[America/Los_Angeles]\")\npublic class PresentationResult {\n\n    public static final String JSON_PROPERTY_SLIDE_NUMBER = \"SlideNumber\";\n\n    private Integer slideNumber;\n\n    public static final String JSON_PROPERTY_U_R_L = \"URL\";\n\n    private String URL;\n\n    public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = \"PresentationContents\";\n\n    private byte[] presentationContents;\n\n    public PresentationResult slideNumber(Integer slideNumber) {\n        this.slideNumber = slideNumber;\n        return this;\n    }\n\n    /**\n     * Worksheet number of the converted page, starting with 1 for the left-most worksheet\n     * @return slideNumber\n     */\n    @javax.annotation.Nullable\n    @ApiModelProperty(value = \"Worksheet number of the converted page, starting with 1 for the left-most worksheet\")\n    @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)\n    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n    public Integer getSlideNumber() {\n        return slideNumber;\n    }\n\n    public void setSlideNumber(Integer slideNumber) {\n        this.slideNumber = slideNumber;\n    }\n\n    public PresentationResult URL(String URL) {\n        this.URL = URL;\n        return this;\n    }\n\n    /**\n     * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\n     * @return URL\n     */\n    @javax.annotation.Nullable\n    @ApiModelProperty(value = \"URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted\")\n    @JsonProperty(JSON_PROPERTY_U_R_L)\n    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n    public String getURL() {\n        return URL;\n    }\n\n    public void setURL(String URL) {\n        this.URL = URL;\n    }\n\n    public PresentationResult presentationContents(byte[] presentationContents) {\n        this.presentationContents = presentationContents;\n        return this;\n    }\n\n    /**\n     * Contents of the presentation in bytes\n     * @return presentationContents\n     */\n    @javax.annotation.Nullable\n    @ApiModelProperty(value = \"Contents of the presentation in bytes\")\n    @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)\n    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)\n    public byte[] getPresentationContents() {\n        return presentationContents;\n    }\n\n    public void setPresentationContents(byte[] presentationContents) {\n        this.presentationContents = presentationContents;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        PresentationResult presentationResult = (PresentationResult) o;\n        return Objects.equals(this.slideNumber, presentationResult.slideNumber) && Objects.equals(this.URL, presentationResult.URL) && Arrays.equals(this.presentationContents, presentationResult.presentationContents);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class PresentationResult {\\n\");\n        sb.append(\"    slideNumber: \").append(toIndentedString(slideNumber)).append(\"\\n\");\n        sb.append(\"    URL: \").append(toIndentedString(URL)).append(\"\\n\");\n        sb.append(\"    presentationContents: \").append(toIndentedString(presentationContents)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "refactored": false}
{"hexsha": "b5ba2355ae572f4a5409e77434046a0882844699", "ext": "java", "lang": "Java", "content": "@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class HttpProviderTest {\n\n    /**\n     * Initial configuration.\n     */\n    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://pastebin.com/raw/x28wW7J8\\\"\\n\");\n\n    /**\n     * Initial configuration. Requested remote configuration file does not exists.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn87\\\"\\n\");\n\n    /**\n     * Initial configuration. Remote server can't be resolved.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\\\"\\n\");\n\n    /**\n     * Initial configuration. Requested remote configuration file is not valid.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn\\\"\\n\");\n\n    @Test\n    public void httpTest_001() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        final Config remoteConfig = ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION);\n        // Test version\n        final Properties properties = new Properties();\n        final InputStream is = HttpProvider.class.getClassLoader().getResourceAsStream(\"playrconf-http.properties\");\n        try {\n            properties.load(is);\n            Assert.assertEquals(provider.getVersion(), properties.getProperty(\"playrconf.http.version\", \"unknown\"));\n            properties.clear();\n            is.close();\n        } catch (final IOException ignore) {\n        }\n        // Standard values\n        Assert.assertEquals(5, remoteConfig.getInt(\"application.five\"));\n        Assert.assertEquals(\"world\", remoteConfig.getString(\"application.hello\"));\n        Assert.assertTrue(remoteConfig.getBoolean(\"application.is-enabled\"));\n        Assert.assertEquals(4, remoteConfig.getIntList(\"application.list\").size());\n        // File\n        final File file = new File(\"./test\");\n        try {\n            final InputStream initialStream = new FileInputStream(file);\n            final byte[] buffer = new byte[128];\n            final int nbRead = initialStream.read(buffer);\n            buffer[nbRead] = '\\0';\n            Assert.assertTrue(nbRead > 0);\n            Assert.assertEquals(\"Hello World!\", new String(buffer, 0, nbRead));\n        } catch (final IOException ex) {\n            ex.printStackTrace();\n            Assert.fail();\n        }\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_002() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);\n    }\n\n    @Test(expected = ConfigException.BadValue.class)\n    public void httpTest_003() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_004() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);\n    }\n}\n", "class_id": 0, "repo": "play-rconf/play-rconf-http", "file": "src/test/java/io/playrconf/provider/HttpProviderTest.java", "last_update_at": "2021-09-03T01:39:21+00:00", "original_content": "@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class HttpProviderTest {\n\n    /**\n     * Initial configuration.\n     */\n    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://pastebin.com/raw/x28wW7J8\\\"\\n\");\n\n    /**\n     * Initial configuration. Requested remote configuration file does not exists.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn87\\\"\\n\");\n\n    /**\n     * Initial configuration. Remote server can't be resolved.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\\\"\\n\");\n\n    /**\n     * Initial configuration. Requested remote configuration file is not valid.\n     */\n    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString(\"application.hello = \\\"Bad value\\\"\\n\" + \"http.url = \\\"https://pastebin.com/raw/KaDmFAYn\\\"\\n\");\n\n    @Test\n    public void httpTest_001() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        final Config remoteConfig = ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION);\n        // Test version\n        final Properties properties = new Properties();\n        final InputStream is = HttpProvider.class.getClassLoader().getResourceAsStream(\"playrconf-http.properties\");\n        try {\n            properties.load(is);\n            Assert.assertEquals(provider.getVersion(), properties.getProperty(\"playrconf.http.version\", \"unknown\"));\n            properties.clear();\n            is.close();\n        } catch (final IOException ignore) {\n        }\n        // Standard values\n        Assert.assertEquals(5, remoteConfig.getInt(\"application.five\"));\n        Assert.assertEquals(\"world\", remoteConfig.getString(\"application.hello\"));\n        Assert.assertTrue(remoteConfig.getBoolean(\"application.is-enabled\"));\n        Assert.assertEquals(4, remoteConfig.getIntList(\"application.list\").size());\n        // File\n        final File file = new File(\"./test\");\n        try {\n            final InputStream initialStream = new FileInputStream(file);\n            final byte[] buffer = new byte[128];\n            final int nbRead = initialStream.read(buffer);\n            buffer[nbRead] = '\\0';\n            Assert.assertTrue(nbRead > 0);\n            Assert.assertEquals(\"Hello World!\", new String(buffer, 0, nbRead));\n        } catch (final IOException ex) {\n            ex.printStackTrace();\n            Assert.fail();\n        }\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_002() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);\n    }\n\n    @Test(expected = ConfigException.BadValue.class)\n    public void httpTest_003() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);\n    }\n\n    @Test(expected = ConfigException.ValidationFailed.class)\n    public void httpTest_004() {\n        // Load remote configuration\n        final StringBuilder stringBuilder = new StringBuilder(512);\n        final Provider provider = new HttpProvider();\n        provider.loadData(INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);\n        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);\n    }\n}\n", "refactored": false}
{"hexsha": "03d7a5ce83aba3ab84bada38250092fab43c06b1", "ext": "java", "lang": "Java", "content": "public class RandomTest {\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int i = 0;\n        while (i < 1000000) try {\n            int intv = new Double(Math.random() * 10000).intValue();\n            long longv = new Double(Math.random() * 1000000).longValue();\n            double doublev = Math.random() * 100;\n        } finally {\n            i++;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end - start);\n        long start1 = System.currentTimeMillis();\n        int i = 0;\n        while (i < 10000) try {\n            int intv = ThreadLocalRandom.current().nextInt(10000);\n            long longv = ThreadLocalRandom.current().nextLong(1000000);\n            double doublev = ThreadLocalRandom.current().nextDouble(500);\n        } finally {\n            i++;\n        }\n        long end1 = System.currentTimeMillis();\n        System.out.println(end1 - start1);\n    }\n}\n", "class_id": 0, "repo": "fbjoker/cn.gitv.clickhouse", "file": "src/main/java/com/virtusai/clickhouseclient/utils/RandomTest.java", "last_update_at": "2021-11-11T00:20:35+00:00", "original_content": "public class RandomTest {\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 1000000; i++) {\n            int intv = new Double(Math.random() * 10000).intValue();\n            long longv = new Double(Math.random() * 1000000).longValue();\n            double doublev = Math.random() * 100;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end - start);\n        long start1 = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            int intv = ThreadLocalRandom.current().nextInt(10000);\n            long longv = ThreadLocalRandom.current().nextLong(1000000);\n            double doublev = ThreadLocalRandom.current().nextDouble(500);\n        }\n        long end1 = System.currentTimeMillis();\n        System.out.println(end1 - start1);\n    }\n}\n", "refactored": true}
{"hexsha": "c7ffc9b5dcc827825419f89bb5fd3694937e4516", "ext": "java", "lang": "Java", "content": "public class PlainSpringJSONDocScannerTest {\n\n    private JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();\n\n    @Controller\n    @RequestMapping(value = \"/api\", produces = { MediaType.APPLICATION_JSON_VALUE })\n    private class SpringController {\n\n        @RequestMapping(value = \"/string/{name}\", headers = \"header=test\", params = \"delete\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n        @ResponseStatus(value = HttpStatus.CREATED)\n        @ResponseBody\n        public String string(@PathVariable(value = \"test\") String name, @RequestParam(\"id\") Integer id, @RequestParam Long query, @RequestParam(name = \"user\", required = false, defaultValue = \"admin\") String user, @RequestHeader(value = \"header-two\", defaultValue = \"header-test\") String header, @RequestBody String requestBody) {\n            return \"ok\";\n        }\n    }\n\n    @Test\n    public void testMergeApiDoc() {\n        Set<Class<?>> controllers = new LinkedHashSet<Class<?>>();\n        controllers.add(SpringController.class);\n        Set<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);\n        ApiDoc apiDoc = apiDocs.iterator().next();\n        Assert.assertEquals(\"SpringController\", apiDoc.getDescription());\n        Assert.assertEquals(\"SpringController\", apiDoc.getName());\n        Assert.assertNotNull(apiDoc.getGroup());\n        for (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {\n            Assert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());\n            Assert.assertNull(apiMethodDoc.getAuth());\n            Assert.assertNull(apiMethodDoc.getSupportedversions());\n            Assert.assertTrue(apiMethodDoc.getApierrors().isEmpty());\n            Assert.assertNull(apiMethodDoc.getId());\n            Assert.assertEquals(\"\", apiMethodDoc.getSummary());\n            Assert.assertEquals(\"\", apiMethodDoc.getDescription());\n            if (apiMethodDoc.getPath().contains(\"/api/string/{name}\")) {\n                Assert.assertEquals(2, apiMethodDoc.getHeaders().size());\n                Set<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();\n                Iterator<ApiHeaderDoc> headersIterator = headers.iterator();\n                ApiHeaderDoc headerTest = headersIterator.next();\n                Assert.assertEquals(\"header\", headerTest.getName());\n                Assert.assertEquals(\"test\", headerTest.getAllowedvalues()[0]);\n                ApiHeaderDoc headerTwo = headersIterator.next();\n                Assert.assertEquals(\"header-two\", headerTwo.getName());\n                Assert.assertEquals(\"header-test\", headerTwo.getAllowedvalues()[0]);\n                Assert.assertEquals(\"string\", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());\n                Assert.assertEquals(\"string\", apiMethodDoc.getResponse().getJsondocType().getOneLineText());\n                Assert.assertEquals(\"POST\", apiMethodDoc.getVerb().iterator().next().name());\n                Assert.assertEquals(\"application/json\", apiMethodDoc.getProduces().iterator().next());\n                Assert.assertEquals(\"application/json\", apiMethodDoc.getConsumes().iterator().next());\n                Assert.assertEquals(\"201 - Created\", apiMethodDoc.getResponsestatuscode());\n                Set<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();\n                Assert.assertEquals(4, queryparameters.size());\n                Iterator<ApiParamDoc> qpIterator = queryparameters.iterator();\n                ApiParamDoc apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"delete\", apiParamDoc.getName());\n                Assert.assertEquals(\"true\", apiParamDoc.getRequired());\n                Assert.assertEquals(null, apiParamDoc.getDefaultvalue());\n                Assert.assertEquals(0, apiParamDoc.getAllowedvalues().length);\n                apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"id\", apiParamDoc.getName());\n                Assert.assertEquals(\"true\", apiParamDoc.getRequired());\n                Assert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());\n                apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"\", apiParamDoc.getName());\n                Assert.assertEquals(\"true\", apiParamDoc.getRequired());\n                Assert.assertEquals(\"\", apiParamDoc.getDefaultvalue());\n                apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"user\", apiParamDoc.getName());\n                Assert.assertEquals(\"false\", apiParamDoc.getRequired());\n                Assert.assertEquals(\"admin\", apiParamDoc.getDefaultvalue());\n                Set<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();\n                Iterator<ApiParamDoc> ppIterator = pathparameters.iterator();\n                apiParamDoc = ppIterator.next();\n                apiParamDoc = apiMethodDoc.getPathparameters().iterator().next();\n                Assert.assertEquals(\"test\", apiParamDoc.getName());\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "eoekun/jsondoc", "file": "jsondoc-springmvc/src/test/java/org/jsondoc/springmvc/scanner/PlainSpringJSONDocScannerTest.java", "last_update_at": "2021-12-11T23:36:19+00:00", "original_content": "public class PlainSpringJSONDocScannerTest {\n\n    private JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();\n\n    @Controller\n    @RequestMapping(value = \"/api\", produces = { MediaType.APPLICATION_JSON_VALUE })\n    private class SpringController {\n\n        @RequestMapping(value = \"/string/{name}\", headers = \"header=test\", params = \"delete\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n        @ResponseStatus(value = HttpStatus.CREATED)\n        @ResponseBody\n        public String string(@PathVariable(value = \"test\") String name, @RequestParam(\"id\") Integer id, @RequestParam Long query, @RequestParam(name = \"user\", required = false, defaultValue = \"admin\") String user, @RequestHeader(value = \"header-two\", defaultValue = \"header-test\") String header, @RequestBody String requestBody) {\n            return \"ok\";\n        }\n    }\n\n    @Test\n    public void testMergeApiDoc() {\n        Set<Class<?>> controllers = new LinkedHashSet<Class<?>>();\n        controllers.add(SpringController.class);\n        Set<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);\n        ApiDoc apiDoc = apiDocs.iterator().next();\n        Assert.assertEquals(\"SpringController\", apiDoc.getDescription());\n        Assert.assertEquals(\"SpringController\", apiDoc.getName());\n        Assert.assertNotNull(apiDoc.getGroup());\n        for (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {\n            Assert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());\n            Assert.assertNull(apiMethodDoc.getAuth());\n            Assert.assertNull(apiMethodDoc.getSupportedversions());\n            Assert.assertTrue(apiMethodDoc.getApierrors().isEmpty());\n            Assert.assertNull(apiMethodDoc.getId());\n            Assert.assertEquals(\"\", apiMethodDoc.getSummary());\n            Assert.assertEquals(\"\", apiMethodDoc.getDescription());\n            if (apiMethodDoc.getPath().contains(\"/api/string/{name}\")) {\n                Assert.assertEquals(2, apiMethodDoc.getHeaders().size());\n                Set<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();\n                Iterator<ApiHeaderDoc> headersIterator = headers.iterator();\n                ApiHeaderDoc headerTest = headersIterator.next();\n                Assert.assertEquals(\"header\", headerTest.getName());\n                Assert.assertEquals(\"test\", headerTest.getAllowedvalues()[0]);\n                ApiHeaderDoc headerTwo = headersIterator.next();\n                Assert.assertEquals(\"header-two\", headerTwo.getName());\n                Assert.assertEquals(\"header-test\", headerTwo.getAllowedvalues()[0]);\n                Assert.assertEquals(\"string\", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());\n                Assert.assertEquals(\"string\", apiMethodDoc.getResponse().getJsondocType().getOneLineText());\n                Assert.assertEquals(\"POST\", apiMethodDoc.getVerb().iterator().next().name());\n                Assert.assertEquals(\"application/json\", apiMethodDoc.getProduces().iterator().next());\n                Assert.assertEquals(\"application/json\", apiMethodDoc.getConsumes().iterator().next());\n                Assert.assertEquals(\"201 - Created\", apiMethodDoc.getResponsestatuscode());\n                Set<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();\n                Assert.assertEquals(4, queryparameters.size());\n                Iterator<ApiParamDoc> qpIterator = queryparameters.iterator();\n                ApiParamDoc apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"delete\", apiParamDoc.getName());\n                Assert.assertEquals(\"true\", apiParamDoc.getRequired());\n                Assert.assertEquals(null, apiParamDoc.getDefaultvalue());\n                Assert.assertEquals(0, apiParamDoc.getAllowedvalues().length);\n                apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"id\", apiParamDoc.getName());\n                Assert.assertEquals(\"true\", apiParamDoc.getRequired());\n                Assert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());\n                apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"\", apiParamDoc.getName());\n                Assert.assertEquals(\"true\", apiParamDoc.getRequired());\n                Assert.assertEquals(\"\", apiParamDoc.getDefaultvalue());\n                apiParamDoc = qpIterator.next();\n                Assert.assertEquals(\"user\", apiParamDoc.getName());\n                Assert.assertEquals(\"false\", apiParamDoc.getRequired());\n                Assert.assertEquals(\"admin\", apiParamDoc.getDefaultvalue());\n                Set<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();\n                Iterator<ApiParamDoc> ppIterator = pathparameters.iterator();\n                apiParamDoc = ppIterator.next();\n                apiParamDoc = apiMethodDoc.getPathparameters().iterator().next();\n                Assert.assertEquals(\"test\", apiParamDoc.getName());\n            }\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "7740a522f9d31a442361aea9f7bbad55c45087be", "ext": "java", "lang": "Java", "content": "@Ignore\npublic class PhishingDetectionApiTest {\n\n    private final PhishingDetectionApi api = new PhishingDetectionApi();\n\n    /**\n     * Detects phishing attempts\n     *\n     * @throws ApiException\n     *          if the Api call fails\n     */\n    @Test\n    public void detectAndReportTest() throws ApiException {\n        List<String> attachments = null;\n        String body = null;\n        String from = null;\n        String subject = null;\n        Integer response = api.detectAndReport(attachments, body, from, subject);\n    }\n}\n", "class_id": 0, "repo": "LogSentinel/logsentinel-java-api", "file": "src/test/java/com/logsentinel/api/PhishingDetectionApiTest.java", "last_update_at": "2021-05-14T10:05:46+00:00", "original_content": "@Ignore\npublic class PhishingDetectionApiTest {\n\n    private final PhishingDetectionApi api = new PhishingDetectionApi();\n\n    /**\n     * Detects phishing attempts\n     *\n     * @throws ApiException\n     *          if the Api call fails\n     */\n    @Test\n    public void detectAndReportTest() throws ApiException {\n        List<String> attachments = null;\n        String body = null;\n        String from = null;\n        String subject = null;\n        Integer response = api.detectAndReport(attachments, body, from, subject);\n    }\n}\n", "refactored": false}
{"hexsha": "c6ec38e3aa543ebec430a9ccbdb14ad544958a43", "ext": "java", "lang": "Java", "content": "public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {\n\n    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n    /**\n     * Creation mode.\n     */\n    private ShardMapManagerCreateMode createMode;\n\n    /**\n     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.\n     */\n    private Version targetVersion;\n\n    /**\n     * Constructs request for deploying SMM storage objects to target GSM database.\n     *\n     * @param credentials\n     *            Credentials for connection.\n     * @param retryPolicy\n     *            Retry policy.\n     * @param operationName\n     *            Operation name, useful for diagnostics.\n     * @param createMode\n     *            Creation mode.\n     * @param targetVersion\n     *            target version of store to deploy\n     */\n    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials, RetryPolicy retryPolicy, String operationName, ShardMapManagerCreateMode createMode, Version targetVersion) {\n        super(credentials, retryPolicy, operationName);\n        this.createMode = createMode;\n        this.targetVersion = targetVersion;\n    }\n\n    /**\n     * Whether this is a read-only operation.\n     */\n    @Override\n    public boolean getReadOnly() {\n        return false;\n    }\n\n    /**\n     * Execute the operation against GSM in the current transaction scope.\n     *\n     * @param ts\n     *            Transaction scope.\n     * @return Results of the operation.\n     */\n    @Override\n    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {\n        log.info(\"ShardMapManagerFactory {}, Started creating Global Shard Map structures.\", this.getOperationName());\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));\n        // If we did find some store deployed.\n        if (checkResult.getStoreVersion() != null) {\n            // DevNote: We need to have a way to error out if versions do not match.\n            if (createMode == ShardMapManagerCreateMode.KeepExisting) {\n                stopwatch.stop();\n                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory, ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);\n            }\n            log.info(\"ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.\", this.getOperationName());\n            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());\n        }\n        // Deploy initial version and run upgrade script to bring it to the specified version.\n        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());\n        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));\n        stopwatch.stop();\n        log.info(\"ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}\", this.getOperationName(), stopwatch.elapsed(TimeUnit.MILLISECONDS));\n        return new StoreResults();\n    }\n\n    /**\n     * Handles errors from the GSM operation after the LSM operations.\n     *\n     * @param result\n     *            Operation result.\n     */\n    @Override\n    public void handleDoGlobalExecuteError(StoreResults result) {\n        log.debug(\"Always expect Success or Exception from DoGlobalExecute.\");\n    }\n\n    /**\n     * Error category for store exception.\n     */\n    @Override\n    protected ShardManagementErrorCategory getErrorCategory() {\n        return ShardManagementErrorCategory.ShardMapManagerFactory;\n    }\n}\n", "class_id": 0, "repo": "Blackbaud-MattWalsh/elastic-db-tools-for-java", "file": "elastic-db-tools/src/main/java/com/microsoft/azure/elasticdb/shard/storeops/mapmanagerfactory/CreateShardMapManagerGlobalOperation.java", "last_update_at": "2021-12-07T18:21:33+00:00", "original_content": "public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {\n\n    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n    /**\n     * Creation mode.\n     */\n    private ShardMapManagerCreateMode createMode;\n\n    /**\n     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.\n     */\n    private Version targetVersion;\n\n    /**\n     * Constructs request for deploying SMM storage objects to target GSM database.\n     *\n     * @param credentials\n     *            Credentials for connection.\n     * @param retryPolicy\n     *            Retry policy.\n     * @param operationName\n     *            Operation name, useful for diagnostics.\n     * @param createMode\n     *            Creation mode.\n     * @param targetVersion\n     *            target version of store to deploy\n     */\n    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials, RetryPolicy retryPolicy, String operationName, ShardMapManagerCreateMode createMode, Version targetVersion) {\n        super(credentials, retryPolicy, operationName);\n        this.createMode = createMode;\n        this.targetVersion = targetVersion;\n    }\n\n    /**\n     * Whether this is a read-only operation.\n     */\n    @Override\n    public boolean getReadOnly() {\n        return false;\n    }\n\n    /**\n     * Execute the operation against GSM in the current transaction scope.\n     *\n     * @param ts\n     *            Transaction scope.\n     * @return Results of the operation.\n     */\n    @Override\n    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {\n        log.info(\"ShardMapManagerFactory {}, Started creating Global Shard Map structures.\", this.getOperationName());\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));\n        // If we did find some store deployed.\n        if (checkResult.getStoreVersion() != null) {\n            // DevNote: We need to have a way to error out if versions do not match.\n            if (createMode == ShardMapManagerCreateMode.KeepExisting) {\n                stopwatch.stop();\n                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory, ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);\n            }\n            log.info(\"ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.\", this.getOperationName());\n            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());\n        }\n        // Deploy initial version and run upgrade script to bring it to the specified version.\n        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());\n        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));\n        stopwatch.stop();\n        log.info(\"ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}\", this.getOperationName(), stopwatch.elapsed(TimeUnit.MILLISECONDS));\n        return new StoreResults();\n    }\n\n    /**\n     * Handles errors from the GSM operation after the LSM operations.\n     *\n     * @param result\n     *            Operation result.\n     */\n    @Override\n    public void handleDoGlobalExecuteError(StoreResults result) {\n        log.debug(\"Always expect Success or Exception from DoGlobalExecute.\");\n    }\n\n    /**\n     * Error category for store exception.\n     */\n    @Override\n    protected ShardManagementErrorCategory getErrorCategory() {\n        return ShardManagementErrorCategory.ShardMapManagerFactory;\n    }\n}\n", "refactored": false}
{"hexsha": "11992b1676761a8e7bb5d9a4c39bd1a80802e4e0", "ext": "java", "lang": "Java", "content": "public class DateTest implements Predicate<Object> {\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public boolean test(Object o) {\r\n        if (!(o instanceof Map))\r\n            return false;\r\n        Map<String, Object> m = (Map<String, Object>) o;\r\n        return m.containsKey(\"$date\");\r\n    }\r\n}\r\n", "class_id": 0, "repo": "ozwolf-software/mongo-trek", "file": "src/main/java/net/ozwolf/mongo/migrations/internal/util/strict/test/DateTest.java", "last_update_at": "2021-11-05T13:13:10+00:00", "original_content": "public class DateTest implements Predicate<Object> {\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public boolean test(Object o) {\r\n        if (!(o instanceof Map))\r\n            return false;\r\n        Map<String, Object> m = (Map<String, Object>) o;\r\n        return m.containsKey(\"$date\");\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "471abfbcd5ea2120b3ab3a2bcc2caedb5f103606", "ext": "java", "lang": "Java", "content": "public class CustomInlineFunctions {\n\n    // declare log services\n    private LogServices log = LogServices.getInstance(\"wbtServices\");\n\n    public String doSample(String value) {\n        log.debug(\"wbtServices\", \"WebertiseInlineFunctions - doSample: got value '\" + value + \"'\");\n        return value;\n    }\n}\n", "class_id": 0, "repo": "bernfried/wbf-framework", "file": "dsextensions/src/de/webertise/ds/inlinefunctions/CustomInlineFunctions.java", "last_update_at": "2021-01-15T02:53:06+00:00", "original_content": "public class CustomInlineFunctions {\n\n    // declare log services\n    private LogServices log = LogServices.getInstance(\"wbtServices\");\n\n    public String doSample(String value) {\n        log.debug(\"wbtServices\", \"WebertiseInlineFunctions - doSample: got value '\" + value + \"'\");\n        return value;\n    }\n}\n", "refactored": false}
{"hexsha": "f7178660a3d266187dc4287ef23abc8f0a527d87", "ext": "java", "lang": "Java", "content": "public class AbstractDRResourceProviderTest {\n\n    @Test\n    public void testGetResourceProvider() throws Exception {\n        Set<String> propertyIds = new HashSet<String>();\n        propertyIds.add(\"foo\");\n        propertyIds.add(\"cat1/foo\");\n        propertyIds.add(\"cat2/bar\");\n        propertyIds.add(\"cat2/baz\");\n        propertyIds.add(\"cat3/sub1/bam\");\n        propertyIds.add(\"cat4/sub2/sub3/bat\");\n        propertyIds.add(\"cat5/subcat5/map\");\n        Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();\n        IvoryService ivoryService = createMock(IvoryService.class);\n        AbstractResourceProvider provider = (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(Resource.Type.DRFeed, propertyIds, keyPropertyIds, ivoryService);\n        Assert.assertTrue(provider instanceof FeedResourceProvider);\n    }\n}\n", "class_id": 0, "repo": "dawnwish/ambari", "file": "ambari-server/src/test/java/org/apache/ambari/server/controller/internal/AbstractDRResourceProviderTest.java", "last_update_at": "2021-08-05T03:13:26+00:00", "original_content": "public class AbstractDRResourceProviderTest {\n\n    @Test\n    public void testGetResourceProvider() throws Exception {\n        Set<String> propertyIds = new HashSet<String>();\n        propertyIds.add(\"foo\");\n        propertyIds.add(\"cat1/foo\");\n        propertyIds.add(\"cat2/bar\");\n        propertyIds.add(\"cat2/baz\");\n        propertyIds.add(\"cat3/sub1/bam\");\n        propertyIds.add(\"cat4/sub2/sub3/bat\");\n        propertyIds.add(\"cat5/subcat5/map\");\n        Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();\n        IvoryService ivoryService = createMock(IvoryService.class);\n        AbstractResourceProvider provider = (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(Resource.Type.DRFeed, propertyIds, keyPropertyIds, ivoryService);\n        Assert.assertTrue(provider instanceof FeedResourceProvider);\n    }\n}\n", "refactored": false}
{"hexsha": "7cbaabecd2cc61947ab6279a547d2c9290a3bb1e", "ext": "java", "lang": "Java", "content": "@Path(\"/shop\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ShoppingController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);\n\n    private final StylingApi stylingApi;\n\n    ShoppingController() {\n        String stylingUrl = \"http://localhost:50051\";\n        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;\n        // wavefrontJaxrsFilter = wfJaxrsClientFilter;\n        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);\n    }\n\n    @GET\n    @Path(\"/menu\")\n    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {\n        return Response.ok(stylingApi.getAllStyles()).build();\n    }\n\n    @POST\n    @Path(\"/order\")\n    @Consumes(APPLICATION_JSON)\n    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {\n        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();\n        }\n        Response deliveryResponse = stylingApi.makeShirts(orderDTO.getStyleName(), orderDTO.getQuantity());\n        if (deliveryResponse.getStatus() < 400) {\n            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);\n            return Response.ok().entity(deliveryStatus).build();\n        } else {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(deliveryResponse.getStatus()).entity(msg).build();\n        }\n    }\n}\n", "class_id": 0, "repo": "scrogatl/otel-demo-app-java", "file": "shopping/src/main/java/com/wfsample/shopping/ShoppingController.java", "last_update_at": "2021-06-21T13:56:10+00:00", "original_content": "@Path(\"/shop\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ShoppingController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);\n\n    private final StylingApi stylingApi;\n\n    ShoppingController() {\n        String stylingUrl = \"http://localhost:50051\";\n        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;\n        // wavefrontJaxrsFilter = wfJaxrsClientFilter;\n        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);\n    }\n\n    @GET\n    @Path(\"/menu\")\n    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {\n        return Response.ok(stylingApi.getAllStyles()).build();\n    }\n\n    @POST\n    @Path(\"/order\")\n    @Consumes(APPLICATION_JSON)\n    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {\n        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();\n        }\n        Response deliveryResponse = stylingApi.makeShirts(orderDTO.getStyleName(), orderDTO.getQuantity());\n        if (deliveryResponse.getStatus() < 400) {\n            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);\n            return Response.ok().entity(deliveryStatus).build();\n        } else {\n            String msg = \"Failed to order shirts!\";\n            logger.warn(msg);\n            return Response.status(deliveryResponse.getStatus()).entity(msg).build();\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "d8c97610050943cdf2ccaade422a76ac48e11c71", "ext": "java", "lang": "Java", "content": "public class B_SuperClass {\n\n    public static void main(String[] args) {\n        Class<?> clazz = Example_B_SuperClass.class;\n        Class<?> superclass = clazz.getSuperclass();\n        System.out.println(superclass);\n    }\n}\n", "class_id": 0, "repo": "lsieun/learn-java", "file": "Reflection/code/learn-reflection/src/main/java/lsieun/reflection/a_clazz/B_SuperClass.java", "last_update_at": "2021-03-24T23:13:33+00:00", "original_content": "public class B_SuperClass {\n\n    public static void main(String[] args) {\n        Class<?> clazz = Example_B_SuperClass.class;\n        Class<?> superclass = clazz.getSuperclass();\n        System.out.println(superclass);\n    }\n}\n", "refactored": false}
{"hexsha": "21ca9661f3376f46943fd2a0ddc93a92bb03a6a3", "ext": "java", "lang": "Java", "content": "public class MvnModelFactory {\r\n\r\n    public Model createModel(Project project) throws MvnModelInputException {\r\n        return createModel(project.getProjectDirectory());\r\n    }\r\n\r\n    public Model createModel(FileObject projectDir) throws MvnModelInputException {\r\n        FileObject pomFile = projectDir.getFileObject(\"pom.xml\");\r\n        MavenXpp3Reader mavenreader = new MavenXpp3Reader();\r\n        try (Reader reader = new InputStreamReader(pomFile.getInputStream())) {\r\n            Model model = mavenreader.read(reader);\r\n            model.setPomFile(new File(pomFile.getPath()));\r\n            return model;\r\n        } catch (XmlPullParserException | IOException ex) {\r\n            throw new MvnModelInputException(ex);\r\n        }\r\n    }\r\n}\r\n", "class_id": 0, "repo": "hmvictor/radar-netbeans", "file": "src/main/java/qubexplorer/MvnModelFactory.java", "last_update_at": "2021-11-14T19:52:07+00:00", "original_content": "public class MvnModelFactory {\r\n\r\n    public Model createModel(Project project) throws MvnModelInputException {\r\n        return createModel(project.getProjectDirectory());\r\n    }\r\n\r\n    public Model createModel(FileObject projectDir) throws MvnModelInputException {\r\n        FileObject pomFile = projectDir.getFileObject(\"pom.xml\");\r\n        MavenXpp3Reader mavenreader = new MavenXpp3Reader();\r\n        try (Reader reader = new InputStreamReader(pomFile.getInputStream())) {\r\n            Model model = mavenreader.read(reader);\r\n            model.setPomFile(new File(pomFile.getPath()));\r\n            return model;\r\n        } catch (XmlPullParserException | IOException ex) {\r\n            throw new MvnModelInputException(ex);\r\n        }\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "3037ceb3997c55c745d234f6205a58fc66497019", "ext": "java", "lang": "Java", "content": "public class PushNotificationCallback {\n\n    private String email;\n\n    private String url;\n\n    public PushNotificationCallback(Context appContext) {\n        Breadcaster caster = new Breadcaster(appContext).action(\"1\", new Execution() {\n\n            @Override\n            public void exec(Context context, Intent intent) {\n                String email = intent.getStringExtra(\"email\");\n                if (email != null) {\n                    PushNotificationCallback.this.email = email;\n                    String url = intent.getStringExtra(\"url\");\n                    PushNotificationCallback.this.url = url;\n                }\n                System.out.println(\"****PUSH_NOTIFICATION_CALLBACK_INVOKED*****\");\n                System.out.println(email + \":\" + MyFirebaseMessagingService.pushToken + \":\" + url);\n                if (PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null) {\n                    return;\n                }\n                Thread t = new Thread(() -> {\n                    URL urlValue = null;\n                    HttpsURLConnection urlConnection = null;\n                    String json = null;\n                    OutputStreamWriter writer = null;\n                    BufferedReader reader = null;\n                    try {\n                        urlValue = new URL(PushNotificationCallback.this.url);\n                        urlConnection = (HttpsURLConnection) urlValue.openConnection();\n                        urlConnection.setDoOutput(true);\n                        JSONObject jsonObject = new JSONObject();\n                        jsonObject.put(\"email\", PushNotificationCallback.this.email);\n                        jsonObject.put(\"pushToken\", MyFirebaseMessagingService.pushToken);\n                        json = jsonObject.toString();\n                        writer = new OutputStreamWriter(urlConnection.getOutputStream());\n                        writer.write(json);\n                        writer.flush();\n                        reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                        StringBuilder sb = new StringBuilder();\n                        String line = null;\n                        for (; (line = reader.readLine()) != null; ) {\n                            // Append server response in string\n                            sb.append(line + \"\\n\");\n                        }\n                        System.out.println(\"TOKEN_REGISTRATION_SUCCESS: \" + sb);\n                    } catch (Exception e) {\n                    } finally {\n                        if (urlConnection != null) {\n                            urlConnection.disconnect();\n                        }\n                        try {\n                            if (writer != null) {\n                                writer.close();\n                            }\n                            if (reader != null) {\n                                reader.close();\n                            }\n                        } catch (Exception e) {\n                        }\n                    }\n                });\n                t.start();\n            }\n        }).register();\n    }\n}\n", "class_id": 0, "repo": "slydogshah/appGalCloud", "file": "jennetapp/android/app/src/main/java/io/appgallabs/jennetwork/PushNotificationCallback.java", "last_update_at": "2021-06-17T13:29:02+00:00", "original_content": "public class PushNotificationCallback {\n\n    private String email;\n\n    private String url;\n\n    public PushNotificationCallback(Context appContext) {\n        Breadcaster caster = new Breadcaster(appContext).action(\"1\", new Execution() {\n\n            @Override\n            public void exec(Context context, Intent intent) {\n                String email = intent.getStringExtra(\"email\");\n                if (email != null) {\n                    PushNotificationCallback.this.email = email;\n                    String url = intent.getStringExtra(\"url\");\n                    PushNotificationCallback.this.url = url;\n                }\n                System.out.println(\"****PUSH_NOTIFICATION_CALLBACK_INVOKED*****\");\n                System.out.println(email + \":\" + MyFirebaseMessagingService.pushToken + \":\" + url);\n                if (PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null) {\n                    return;\n                }\n                Thread t = new Thread(() -> {\n                    URL urlValue = null;\n                    HttpsURLConnection urlConnection = null;\n                    String json = null;\n                    OutputStreamWriter writer = null;\n                    BufferedReader reader = null;\n                    try {\n                        urlValue = new URL(PushNotificationCallback.this.url);\n                        urlConnection = (HttpsURLConnection) urlValue.openConnection();\n                        urlConnection.setDoOutput(true);\n                        JSONObject jsonObject = new JSONObject();\n                        jsonObject.put(\"email\", PushNotificationCallback.this.email);\n                        jsonObject.put(\"pushToken\", MyFirebaseMessagingService.pushToken);\n                        json = jsonObject.toString();\n                        writer = new OutputStreamWriter(urlConnection.getOutputStream());\n                        writer.write(json);\n                        writer.flush();\n                        reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                        StringBuilder sb = new StringBuilder();\n                        String line = null;\n                        // Read Server Response\n                        while ((line = reader.readLine()) != null) {\n                            // Append server response in string\n                            sb.append(line + \"\\n\");\n                        }\n                        System.out.println(\"TOKEN_REGISTRATION_SUCCESS: \" + sb);\n                    } catch (Exception e) {\n                    } finally {\n                        if (urlConnection != null) {\n                            urlConnection.disconnect();\n                        }\n                        try {\n                            if (writer != null) {\n                                writer.close();\n                            }\n                            if (reader != null) {\n                                reader.close();\n                            }\n                        } catch (Exception e) {\n                        }\n                    }\n                });\n                t.start();\n            }\n        }).register();\n    }\n}\n", "refactored": true}
{"hexsha": "27a89c084d6ab746c2199fdd9f7518ada1b9eea9", "ext": "java", "lang": "Java", "content": "public class ArrayTypeReference extends SingleTypeReference {\n\n    public int dimensions;\n\n    // jsr308 style type annotations on dimensions.\n    private Annotation[][] annotationsOnDimensions;\n\n    public int originalSourceEnd;\n\n    public int extendedDimensions;\n\n    /**\n     * ArrayTypeReference constructor comment.\n     * @param source char[]\n     * @param dimensions int\n     * @param pos int\n     */\n    public ArrayTypeReference(char[] source, int dimensions, long pos) {\n        super(source, pos);\n        this.originalSourceEnd = this.sourceEnd;\n        this.dimensions = dimensions;\n        this.annotationsOnDimensions = null;\n    }\n\n    public ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {\n        this(source, dimensions, pos);\n        if (annotationsOnDimensions != null) {\n            this.bits |= ASTNode.HasTypeAnnotations;\n        }\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    public int dimensions() {\n        return this.dimensions;\n    }\n\n    public int extraDimensions() {\n        return this.extendedDimensions;\n    }\n\n    /**\n     * \t @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)\n     */\n    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {\n        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)\n            return this.annotationsOnDimensions;\n        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];\n        final int baseDimensions = this.dimensions - this.extendedDimensions;\n        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);\n        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);\n        return externalAnnotations;\n    }\n\n    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    /**\n     * @return char[][]\n     */\n    public char[][] getParameterizedTypeName() {\n        int dim = this.dimensions;\n        char[] dimChars = new char[dim * 2];\n        int i = 0;\n        while (i < dim) try {\n            int index = i * 2;\n            dimChars[index] = '[';\n            dimChars[index + 1] = ']';\n        } finally {\n            i++;\n        }\n        return new char[][] { CharOperation.concat(this.token, dimChars) };\n    }\n\n    protected TypeBinding getTypeBinding(Scope scope) {\n        if (this.resolvedType != null) {\n            return this.resolvedType;\n        }\n        if (this.dimensions > 255) {\n            scope.problemReporter().tooManyDimensions(this);\n        }\n        TypeBinding leafComponentType = scope.getType(this.token);\n        return scope.createArrayType(leafComponentType, this.dimensions);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        super.printExpression(indent, output);\n        if ((this.bits & IsVarArgs) != 0) {\n            int i = 0;\n            while (i < this.dimensions - 1) try {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    output.append(' ');\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    output.append(' ');\n                }\n                //$NON-NLS-1$\n                //$NON-NLS-1$\n                //$NON-NLS-1$\n                output.append(\"[]\");\n            } finally {\n                i++;\n            }\n            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {\n                output.append(' ');\n                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);\n                output.append(' ');\n            }\n            //$NON-NLS-1$\n            output.append(\"...\");\n        } else {\n            int i = 0;\n            while (i < this.dimensions) try {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    //$NON-NLS-1$\n                    //$NON-NLS-1$\n                    //$NON-NLS-1$\n                    output.append(\" \");\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    //$NON-NLS-1$\n                    //$NON-NLS-1$\n                    //$NON-NLS-1$\n                    output.append(\" \");\n                }\n                //$NON-NLS-1$\n                //$NON-NLS-1$\n                //$NON-NLS-1$\n                output.append(\"[]\");\n            } finally {\n                i++;\n            }\n        }\n        return output;\n    }\n\n    public void traverse(ASTVisitor visitor, BlockScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length;\n                while (i < length) try {\n                    typeAnnotations[i].traverse(visitor, scope);\n                } finally {\n                    i++;\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                int i = 0, max = this.annotationsOnDimensions.length;\n                while (i < max) try {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        int j = 0, max2 = annotations2.length;\n                        while (j < max2) try {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        } finally {\n                            j++;\n                        }\n                    }\n                } finally {\n                    i++;\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    public void traverse(ASTVisitor visitor, ClassScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length;\n                while (i < length) try {\n                    typeAnnotations[i].traverse(visitor, scope);\n                } finally {\n                    i++;\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                int i = 0, max = this.annotationsOnDimensions.length;\n                while (i < max) try {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        int j = 0, max2 = annotations2.length;\n                        while (j < max2) try {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        } finally {\n                            j++;\n                        }\n                    }\n                } finally {\n                    i++;\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    protected TypeBinding internalResolveType(Scope scope, int location) {\n        TypeBinding internalResolveType = super.internalResolveType(scope, location);\n        return internalResolveType;\n    }\n\n    @Override\n    public boolean hasNullTypeAnnotation(AnnotationPosition position) {\n        switch(position) {\n            case LEAF_TYPE:\n                // ignore annotationsOnDimensions:\n                return super.hasNullTypeAnnotation(position);\n            case MAIN_TYPE:\n                // outermost dimension only:\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {\n                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];\n                    return containsNullAnnotation(innerAnnotations);\n                }\n                break;\n            case ANY:\n                if (super.hasNullTypeAnnotation(position))\n                    return true;\n                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())\n                    // shortcut\n                    return false;\n                if (this.annotationsOnDimensions != null) {\n                    int i = 0;\n                    while (i < this.annotationsOnDimensions.length) try {\n                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];\n                        if (containsNullAnnotation(innerAnnotations))\n                            return true;\n                    } finally {\n                        i++;\n                    }\n                }\n        }\n        return false;\n    }\n}\n", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.core/4509.java", "last_update_at": "2021-11-29T08:28:07+00:00", "original_content": "public class ArrayTypeReference extends SingleTypeReference {\n\n    public int dimensions;\n\n    // jsr308 style type annotations on dimensions.\n    private Annotation[][] annotationsOnDimensions;\n\n    public int originalSourceEnd;\n\n    public int extendedDimensions;\n\n    /**\n     * ArrayTypeReference constructor comment.\n     * @param source char[]\n     * @param dimensions int\n     * @param pos int\n     */\n    public ArrayTypeReference(char[] source, int dimensions, long pos) {\n        super(source, pos);\n        this.originalSourceEnd = this.sourceEnd;\n        this.dimensions = dimensions;\n        this.annotationsOnDimensions = null;\n    }\n\n    public ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {\n        this(source, dimensions, pos);\n        if (annotationsOnDimensions != null) {\n            this.bits |= ASTNode.HasTypeAnnotations;\n        }\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    public int dimensions() {\n        return this.dimensions;\n    }\n\n    public int extraDimensions() {\n        return this.extendedDimensions;\n    }\n\n    /**\n     * \t @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)\n     */\n    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {\n        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)\n            return this.annotationsOnDimensions;\n        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];\n        final int baseDimensions = this.dimensions - this.extendedDimensions;\n        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);\n        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);\n        return externalAnnotations;\n    }\n\n    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {\n        this.annotationsOnDimensions = annotationsOnDimensions;\n    }\n\n    /**\n     * @return char[][]\n     */\n    public char[][] getParameterizedTypeName() {\n        int dim = this.dimensions;\n        char[] dimChars = new char[dim * 2];\n        for (int i = 0; i < dim; i++) {\n            int index = i * 2;\n            dimChars[index] = '[';\n            dimChars[index + 1] = ']';\n        }\n        return new char[][] { CharOperation.concat(this.token, dimChars) };\n    }\n\n    protected TypeBinding getTypeBinding(Scope scope) {\n        if (this.resolvedType != null) {\n            return this.resolvedType;\n        }\n        if (this.dimensions > 255) {\n            scope.problemReporter().tooManyDimensions(this);\n        }\n        TypeBinding leafComponentType = scope.getType(this.token);\n        return scope.createArrayType(leafComponentType, this.dimensions);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        super.printExpression(indent, output);\n        if ((this.bits & IsVarArgs) != 0) {\n            for (int i = 0; i < this.dimensions - 1; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    output.append(' ');\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    output.append(' ');\n                }\n                //$NON-NLS-1$\n                //$NON-NLS-1$\n                output.//$NON-NLS-1$\n                append(\"[]\");\n            }\n            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {\n                output.append(' ');\n                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);\n                output.append(' ');\n            }\n            //$NON-NLS-1$\n            output.append(\"...\");\n        } else {\n            for (int i = 0; i < this.dimensions; i++) {\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {\n                    //$NON-NLS-1$\n                    //$NON-NLS-1$\n                    output.//$NON-NLS-1$\n                    append(\" \");\n                    printAnnotations(this.annotationsOnDimensions[i], output);\n                    //$NON-NLS-1$\n                    //$NON-NLS-1$\n                    output.//$NON-NLS-1$\n                    append(\" \");\n                }\n                //$NON-NLS-1$\n                //$NON-NLS-1$\n                output.//$NON-NLS-1$\n                append(\"[]\");\n            }\n        }\n        return output;\n    }\n\n    public void traverse(ASTVisitor visitor, BlockScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    public void traverse(ASTVisitor visitor, ClassScope scope) {\n        if (visitor.visit(this, scope)) {\n            if (this.annotations != null) {\n                Annotation[] typeAnnotations = this.annotations[0];\n                for (int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length; i < length; i++) {\n                    typeAnnotations[i].traverse(visitor, scope);\n                }\n            }\n            if (this.annotationsOnDimensions != null) {\n                for (int i = 0, max = this.annotationsOnDimensions.length; i < max; i++) {\n                    Annotation[] annotations2 = this.annotationsOnDimensions[i];\n                    if (annotations2 != null) {\n                        for (int j = 0, max2 = annotations2.length; j < max2; j++) {\n                            Annotation annotation = annotations2[j];\n                            annotation.traverse(visitor, scope);\n                        }\n                    }\n                }\n            }\n        }\n        visitor.endVisit(this, scope);\n    }\n\n    protected TypeBinding internalResolveType(Scope scope, int location) {\n        TypeBinding internalResolveType = super.internalResolveType(scope, location);\n        return internalResolveType;\n    }\n\n    @Override\n    public boolean hasNullTypeAnnotation(AnnotationPosition position) {\n        switch(position) {\n            case LEAF_TYPE:\n                // ignore annotationsOnDimensions:\n                return super.hasNullTypeAnnotation(position);\n            case MAIN_TYPE:\n                // outermost dimension only:\n                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {\n                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];\n                    return containsNullAnnotation(innerAnnotations);\n                }\n                break;\n            case ANY:\n                if (super.hasNullTypeAnnotation(position))\n                    return true;\n                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())\n                    // shortcut\n                    return false;\n                if (this.annotationsOnDimensions != null) {\n                    for (int i = 0; i < this.annotationsOnDimensions.length; i++) {\n                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];\n                        if (containsNullAnnotation(innerAnnotations))\n                            return true;\n                    }\n                }\n        }\n        return false;\n    }\n}\n", "refactored": true}
{"hexsha": "6ba2c65ef09c9dce214c0d5ad690323d7dcafe61", "ext": "java", "lang": "Java", "content": "public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {\n\n    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext, ClassLoader classLoader, List<URL> resources) {\n        if (classLoader == null) {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        }\n        SCAGenericApplicationContext appCtx = new SCAGenericApplicationContext((ApplicationContext) scaParentContext, classLoader);\n        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);\n        // REVIEW: [rfeng] How do we control the schema validation\n        xmlReader.setValidating(false);\n        for (URL resource : resources) {\n            xmlReader.loadBeanDefinitions(new UrlResource(resource));\n        }\n        return appCtx;\n    }\n\n    @Override\n    public Object load(List<URL> resources, List<SpringSCAServiceElement> serviceElements, List<SpringSCAReferenceElement> referenceElements, List<SpringSCAPropertyElement> propertyElements, List<SpringBeanElement> beanElements, ProcessorContext context) {\n        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime\n        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);\n        serviceElements.addAll(applicationContext.getServiceElements());\n        referenceElements.addAll(applicationContext.getReferenceElements());\n        propertyElements.addAll(applicationContext.getPropertyElements());\n        beanElements.addAll(applicationContext.getBeanElements());\n        return applicationContext;\n    }\n}\n", "class_id": 0, "repo": "apache/tuscany-sca-2.x", "file": "modules/implementation-spring-runtime/src/main/java/org/apache/tuscany/sca/implementation/spring/processor/SpringXMLBeanDefinitionLoaderImpl.java", "last_update_at": "2021-11-10T16:04:56+00:00", "original_content": "public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {\n\n    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext, ClassLoader classLoader, List<URL> resources) {\n        if (classLoader == null) {\n            classLoader = Thread.currentThread().getContextClassLoader();\n        }\n        SCAGenericApplicationContext appCtx = new SCAGenericApplicationContext((ApplicationContext) scaParentContext, classLoader);\n        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);\n        // REVIEW: [rfeng] How do we control the schema validation\n        xmlReader.setValidating(false);\n        for (URL resource : resources) {\n            xmlReader.loadBeanDefinitions(new UrlResource(resource));\n        }\n        return appCtx;\n    }\n\n    @Override\n    public Object load(List<URL> resources, List<SpringSCAServiceElement> serviceElements, List<SpringSCAReferenceElement> referenceElements, List<SpringSCAPropertyElement> propertyElements, List<SpringBeanElement> beanElements, ProcessorContext context) {\n        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime\n        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);\n        serviceElements.addAll(applicationContext.getServiceElements());\n        referenceElements.addAll(applicationContext.getReferenceElements());\n        propertyElements.addAll(applicationContext.getPropertyElements());\n        beanElements.addAll(applicationContext.getBeanElements());\n        return applicationContext;\n    }\n}\n", "refactored": false}
{"hexsha": "278ec218a2e650deb4500198e2ed05508b55549c", "ext": "java", "lang": "Java", "content": "public class Builders {\n\n    private Builders() {\n    }\n\n    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();\n\n    static {\n        map.put(User.class, new UserBuilder());\n        map.put(Content.class, new ContentBuilder());\n        map.put(Company.class, new CompanyBuilder());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {\n        K builder = (K) map.get(clazz);\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + clazz.getName());\n        return (K) builder.newInstance();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {\n        if (entity == null)\n            throw new IllegalArgumentException(\"Entity should not be a null.\");\n        K builder = (K) map.get(entity.getClass());\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + entity.getClass().getName());\n        return (K) builder.newInstance(entity);\n    }\n}\n", "class_id": 0, "repo": "Pivopil/spring-boot-oauth2-rest-service-password-encoding", "file": "share/src/main/java/io/github/pivopil/share/builders/Builders.java", "last_update_at": "2021-04-25T08:44:09+00:00", "original_content": "public class Builders {\n\n    private Builders() {\n    }\n\n    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();\n\n    static {\n        map.put(User.class, new UserBuilder());\n        map.put(Content.class, new ContentBuilder());\n        map.put(Company.class, new CompanyBuilder());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {\n        K builder = (K) map.get(clazz);\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + clazz.getName());\n        return (K) builder.newInstance();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {\n        if (entity == null)\n            throw new IllegalArgumentException(\"Entity should not be a null.\");\n        K builder = (K) map.get(entity.getClass());\n        if (builder == null)\n            throw new IllegalArgumentException(\"No builder for entity: \" + entity.getClass().getName());\n        return (K) builder.newInstance(entity);\n    }\n}\n", "refactored": false}
{"hexsha": "cda831809d818cc9f3aa657b63679325f432741b", "ext": "java", "lang": "Java", "content": "public class ObsidianShard extends Item {\n\n    public ObsidianShard() {\n        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));\n    }\n\n    @Override\n    @ParametersAreNonnullByDefault\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {\n        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);\n        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS)).orElse(0D);\n        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS)).orElse(0D);\n        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS)).orElse(0D);\n        if (overworldAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.overworld_attunement_message\", String.format(\"%.2f\", overworldAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.BLUE));\n        }\n        if (netherAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.nether_attunement_message\", String.format(\"%.2f\", netherAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.RED));\n        }\n        if (endAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.end_attunement_message\", String.format(\"%.2f\", endAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.AQUA));\n        }\n    }\n}\n", "class_id": 0, "repo": "Pursuit-of-Glowstone/Obsidimancy", "file": "src/main/java/com/pursuitofglowstone/obsidimancy/items/ObsidianShard.java", "last_update_at": "2021-09-18T17:27:15+00:00", "original_content": "public class ObsidianShard extends Item {\n\n    public ObsidianShard() {\n        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));\n    }\n\n    @Override\n    @ParametersAreNonnullByDefault\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {\n        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);\n        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS)).orElse(0D);\n        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS)).orElse(0D);\n        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS)).orElse(0D);\n        if (overworldAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.overworld_attunement_message\", String.format(\"%.2f\", overworldAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.BLUE));\n        }\n        if (netherAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.nether_attunement_message\", String.format(\"%.2f\", netherAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.RED));\n        }\n        if (endAttuneProgress != 0) {\n            pTooltipComponents.add(new TranslatableComponent(\"obsidimancy.end_attunement_message\", String.format(\"%.2f\", endAttuneProgress / 3 * 100) + \"%\").withStyle(ChatFormatting.AQUA));\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "00bef6747de51bf67fa009897a672aaff33c027a", "ext": "java", "lang": "Java", "content": "@Component\r\npublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {\r\n\r\n    @Override\r\n    public TResponse send(TRequest request, Handler handler) {\r\n        return (TResponse) handler.handle(request);\r\n    }\r\n}\r\n", "class_id": 0, "repo": "unsri-hackers/ecommerce", "file": "src/main/java/com/unsri/ecommerce/infrastructure/mediator/MediatorImpl.java", "last_update_at": "2021-07-12T08:08:01+00:00", "original_content": "@Component\r\npublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {\r\n\r\n    @Override\r\n    public TResponse send(TRequest request, Handler handler) {\r\n        return (TResponse) handler.handle(request);\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "0d702eb90f1c4fb17696cc6f6afccd963790a157", "ext": "java", "lang": "Java", "content": "@ExtendWith(SiriusExtension.class)\nclass XMLReaderTest {\n\n    @Test\n    @DisplayName(\"XMLReader extracts XPATH expression\")\n    void readXpath() throws Exception {\n        ValueHolder<String> readString = ValueHolder.of(null);\n        Counter nodeCount = new Counter();\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            nodeCount.inc();\n            readString.set(node.queryString(\"value\"));\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertEquals(\"5\", readString.get());\n        assertEquals(3, nodeCount.getCount(), \"parsed invalid count of nodes\");\n    }\n\n    @Test\n    @DisplayName(\"XMLReader supports compound XPATH paths\")\n    void readXpathCompound() throws Exception {\n        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);\n        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"doc/test/value\", node -> shouldToggle.set(true));\n        reader.addHandler(\"value\", node -> shouldNotToggle.set(true));\n        reader.parse(new ByteArrayInputStream(\"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertTrue(shouldToggle.get());\n        assertFalse(shouldNotToggle.get());\n    }\n\n    @Test\n    @DisplayName(\"XMLReader reads attributes\")\n    void readXpathAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test namedAttribute=\\\"abc\\\" namedAttribute2=\\\"xyz\\\">1</test></doc>\".getBytes()));\n        assertEquals(2, attributes.size());\n        assertEquals(\"abc\", attribute.get());\n    }\n\n    @Test\n    @DisplayName(\"reading non existing attributes does not throw errors\")\n    void readXpathMissingAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"wrongValue\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test>1</test></doc>\".getBytes()));\n        assertEquals(0, attributes.size());\n        assertEquals(\"\", attribute.get());\n    }\n}\n", "class_id": 0, "repo": "scireum/sirius-kernel", "file": "src/test/java/sirius/kernel/xml/XMLReaderTest.java", "last_update_at": "2021-11-24T01:29:39+00:00", "original_content": "@ExtendWith(SiriusExtension.class)\nclass XMLReaderTest {\n\n    @Test\n    @DisplayName(\"XMLReader extracts XPATH expression\")\n    void readXpath() throws Exception {\n        ValueHolder<String> readString = ValueHolder.of(null);\n        Counter nodeCount = new Counter();\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            nodeCount.inc();\n            readString.set(node.queryString(\"value\"));\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertEquals(\"5\", readString.get());\n        assertEquals(3, nodeCount.getCount(), \"parsed invalid count of nodes\");\n    }\n\n    @Test\n    @DisplayName(\"XMLReader supports compound XPATH paths\")\n    void readXpathCompound() throws Exception {\n        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);\n        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"doc/test/value\", node -> shouldToggle.set(true));\n        reader.addHandler(\"value\", node -> shouldNotToggle.set(true));\n        reader.parse(new ByteArrayInputStream(\"<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>\".getBytes()));\n        assertTrue(shouldToggle.get());\n        assertFalse(shouldNotToggle.get());\n    }\n\n    @Test\n    @DisplayName(\"XMLReader reads attributes\")\n    void readXpathAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test namedAttribute=\\\"abc\\\" namedAttribute2=\\\"xyz\\\">1</test></doc>\".getBytes()));\n        assertEquals(2, attributes.size());\n        assertEquals(\"abc\", attribute.get());\n    }\n\n    @Test\n    @DisplayName(\"reading non existing attributes does not throw errors\")\n    void readXpathMissingAttributes() throws Exception {\n        Map<String, String> attributes = new HashMap<>();\n        ValueHolder<String> attribute = ValueHolder.of(\"wrongValue\");\n        XMLReader reader = new XMLReader();\n        reader.addHandler(\"test\", node -> {\n            attributes.putAll(node.getAttributes());\n            attribute.set(node.getAttribute(\"namedAttribute\").asString());\n        });\n        reader.parse(new ByteArrayInputStream(\"<doc><test>1</test></doc>\".getBytes()));\n        assertEquals(0, attributes.size());\n        assertEquals(\"\", attribute.get());\n    }\n}\n", "refactored": false}
{"hexsha": "16a60673c47ed31ef3e70caf496702cafa6f7bfd", "ext": "java", "lang": "Java", "content": "public class KeyItem extends Item {\n\n    public static final String ID = \"lock_key\";\n\n    public static final String TEX_BASE = \"lock_key_\";\n\n    private static final int ICONS_COUNT = 3;\n\n    private IIcon[] icons = new IIcon[ICONS_COUNT];\n\n    public KeyItem() {\n        setUnlocalizedName(ID);\n    }\n\n    @Override\n    public boolean showDurabilityBar(ItemStack stack) {\n        return false;\n    }\n\n    @Override\n    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {\n        if (!itemStack.hasTagCompound())\n            return false;\n        final LockObject lock = LockObject.find(world, x, y, z);\n        if (lock == null || lock.getLockType() == LockType.DIGITAL)\n            return false;\n        final String secret = itemStack.getTagCompound().getString(\"secret\");\n        if (lock.canUnlockWith(secret)) {\n            lock.toggleLocked();\n            if (!world.isRemote) {\n                final String msg = lock.isLocked() ? \"more.lock.locked\" : \"more.lock.unlocked\";\n                player.addChatMessage(new ChatComponentTranslation(msg));\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public IIcon getIconIndex(ItemStack stack) {\n        if (!stack.hasTagCompound() || stack.getTagCompound().getString(\"secret\").isEmpty())\n            return icons[0];\n        final String secret = stack.getTagCompound().getString(\"secret\");\n        // use second char, because first one can be minus\n        final int iconId = secret.charAt(1) % ICONS_COUNT;\n        return icons[iconId];\n    }\n\n    @Override\n    public void registerIcons(IIconRegister p_94581_1_) {\n        int i = 0;\n        while (i < ICONS_COUNT) try {\n            icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + \":\" + TEX_BASE + (i + 1));\n        } finally {\n            ++i;\n        }\n    }\n\n    public static ItemStack makeKeyItem(String secret) {\n        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);\n        final NBTTagCompound compound = new NBTTagCompound();\n        compound.setString(\"secret\", secret);\n        stack.setTagCompound(compound);\n        return stack;\n    }\n}\n", "class_id": 0, "repo": "msifd/more", "file": "src/main/java/msifeed/mc/extensions/locks/items/KeyItem.java", "last_update_at": "2021-01-25T21:18:39+00:00", "original_content": "public class KeyItem extends Item {\n\n    public static final String ID = \"lock_key\";\n\n    public static final String TEX_BASE = \"lock_key_\";\n\n    private static final int ICONS_COUNT = 3;\n\n    private IIcon[] icons = new IIcon[ICONS_COUNT];\n\n    public KeyItem() {\n        setUnlocalizedName(ID);\n    }\n\n    @Override\n    public boolean showDurabilityBar(ItemStack stack) {\n        return false;\n    }\n\n    @Override\n    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {\n        if (!itemStack.hasTagCompound())\n            return false;\n        final LockObject lock = LockObject.find(world, x, y, z);\n        if (lock == null || lock.getLockType() == LockType.DIGITAL)\n            return false;\n        final String secret = itemStack.getTagCompound().getString(\"secret\");\n        if (lock.canUnlockWith(secret)) {\n            lock.toggleLocked();\n            if (!world.isRemote) {\n                final String msg = lock.isLocked() ? \"more.lock.locked\" : \"more.lock.unlocked\";\n                player.addChatMessage(new ChatComponentTranslation(msg));\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public IIcon getIconIndex(ItemStack stack) {\n        if (!stack.hasTagCompound() || stack.getTagCompound().getString(\"secret\").isEmpty())\n            return icons[0];\n        final String secret = stack.getTagCompound().getString(\"secret\");\n        // use second char, because first one can be minus\n        final int iconId = secret.charAt(1) % ICONS_COUNT;\n        return icons[iconId];\n    }\n\n    @Override\n    public void registerIcons(IIconRegister p_94581_1_) {\n        for (int i = 0; i < ICONS_COUNT; ++i) icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + \":\" + TEX_BASE + (i + 1));\n    }\n\n    public static ItemStack makeKeyItem(String secret) {\n        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);\n        final NBTTagCompound compound = new NBTTagCompound();\n        compound.setString(\"secret\", secret);\n        stack.setTagCompound(compound);\n        return stack;\n    }\n}\n", "refactored": true}
{"hexsha": "ce0aae2d035d5e83776bce459265e8dafe8ff912", "ext": "java", "lang": "Java", "content": "public final class MethodHandlerScanner implements EventHandlerScanner {\n\n    private final AnnotatedListenerPredicate annotatedListenerPredicate = new AnnotatedListenerPredicate();\n\n    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();\n\n    @Override\n    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {\n        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();\n        Stream.of(listenerContainer.getClass().getDeclaredMethods()).filter(annotatedListenerPredicate).forEach(method -> eventHandlers.computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>()).add(new MethodEventHandler(listenerContainer, method, filterScanner.scan(method))));\n        return eventHandlers;\n    }\n}\n", "class_id": 0, "repo": "GentlemanMC/Zenith-Public", "file": "src/main/java/team/stiff/pomelo/impl/annotated/handler/scan/MethodHandlerScanner.java", "last_update_at": "2021-12-19T18:11:35+00:00", "original_content": "public final class MethodHandlerScanner implements EventHandlerScanner {\n\n    private final AnnotatedListenerPredicate annotatedListenerPredicate = new AnnotatedListenerPredicate();\n\n    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();\n\n    @Override\n    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {\n        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();\n        Stream.of(listenerContainer.getClass().getDeclaredMethods()).filter(annotatedListenerPredicate).forEach(method -> eventHandlers.computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>()).add(new MethodEventHandler(listenerContainer, method, filterScanner.scan(method))));\n        return eventHandlers;\n    }\n}\n", "refactored": false}
{"hexsha": "daf88f1a21c8768696553c46d83f94aec56a5ffe", "ext": "java", "lang": "Java", "content": "public class HttpClientHelper {\n\n    public static final String DEFAULT_URL = \"http://localhost:7493/go/\";\n\n    private String baseUrl = DEFAULT_URL;\n\n    public HttpClientHelper() {\n    }\n\n    public HttpClientHelper(String baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {\n        return httpRequest(path, methodRequired, null);\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, params);\n        return method.getResponseBodyAsString();\n    }\n\n    public int httpRequestForHeaders(final String path, RequestMethod methodRequired) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, \"\");\n        return method.getStatusCode();\n    }\n\n    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {\n        HttpMethod method = null;\n        String url = baseUrl + path;\n        switch(methodRequired) {\n            case PUT:\n                method = new PutMethod(url);\n                break;\n            case POST:\n                method = new PostMethod(url);\n                break;\n            case GET:\n                method = new GetMethod(url);\n                break;\n        }\n        method.setQueryString(params);\n        HttpClient client = new HttpClient();\n        client.executeMethod(method);\n        return method;\n    }\n\n    public static boolean isRedirect(int statusCode) {\n        return statusCode >= 300 && statusCode < 400;\n    }\n}\n", "class_id": 0, "repo": "refdiff-data/gocd", "file": "server/test/common/com/thoughtworks/go/helpers/HttpClientHelper.java", "last_update_at": "2021-08-14T13:50:46+00:00", "original_content": "public class HttpClientHelper {\n\n    public static final String DEFAULT_URL = \"http://localhost:7493/go/\";\n\n    private String baseUrl = DEFAULT_URL;\n\n    public HttpClientHelper() {\n    }\n\n    public HttpClientHelper(String baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {\n        return httpRequest(path, methodRequired, null);\n    }\n\n    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, params);\n        return method.getResponseBodyAsString();\n    }\n\n    public int httpRequestForHeaders(final String path, RequestMethod methodRequired) throws Exception {\n        HttpMethod method = doRequest(path, methodRequired, \"\");\n        return method.getStatusCode();\n    }\n\n    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {\n        HttpMethod method = null;\n        String url = baseUrl + path;\n        switch(methodRequired) {\n            case PUT:\n                method = new PutMethod(url);\n                break;\n            case POST:\n                method = new PostMethod(url);\n                break;\n            case GET:\n                method = new GetMethod(url);\n                break;\n        }\n        method.setQueryString(params);\n        HttpClient client = new HttpClient();\n        client.executeMethod(method);\n        return method;\n    }\n\n    public static boolean isRedirect(int statusCode) {\n        return statusCode >= 300 && statusCode < 400;\n    }\n}\n", "refactored": false}
{"hexsha": "969a8d791f5bc2edfa349e8c2e0c99f9951846c6", "ext": "java", "lang": "Java", "content": "@Component\npublic class StartCommandHandler implements ICommandHandler {\n\n    private final UserService userService;\n\n    public StartCommandHandler(UserService userService) {\n        this.userService = userService;\n    }\n\n    @Override\n    public boolean accept(String command) {\n        return Objects.equals(command, \"/start\");\n    }\n\n    @Override\n    public SendMessage handle(User user, String[] args) {\n        String chatId = user.getId().toString();\n        if (args == null || args.length == 0) {\n            userService.resetUser(user);\n            return new SendMessage(chatId, getHelpMessage());\n        }\n        String botAnswer;\n        if (args[0].equals(\"leaveFeedback\")) {\n            Long eventId = Long.parseLong(args[1]);\n            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;\n            user.setConversationStatus(ConversationStatus.LeaveFeedback);\n            user.setSelectedEventId(eventId);\n            user.setSelectedFeedbackId(feedbackId);\n            userService.insertOrUpdate(user);\n            botAnswer = \"Write your message\";\n        } else {\n            botAnswer = \"Something went wrong!\";\n        }\n        return new SendMessage(chatId, botAnswer);\n    }\n}\n", "class_id": 0, "repo": "animolos/mutual_feedback_bot", "file": "src/main/java/ru/home/mutual_feedback_bot/api/command_handlers/StartCommandHandler.java", "last_update_at": "2021-11-06T12:16:30+00:00", "original_content": "@Component\npublic class StartCommandHandler implements ICommandHandler {\n\n    private final UserService userService;\n\n    public StartCommandHandler(UserService userService) {\n        this.userService = userService;\n    }\n\n    @Override\n    public boolean accept(String command) {\n        return Objects.equals(command, \"/start\");\n    }\n\n    @Override\n    public SendMessage handle(User user, String[] args) {\n        String chatId = user.getId().toString();\n        if (args == null || args.length == 0) {\n            userService.resetUser(user);\n            return new SendMessage(chatId, getHelpMessage());\n        }\n        String botAnswer;\n        if (args[0].equals(\"leaveFeedback\")) {\n            Long eventId = Long.parseLong(args[1]);\n            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;\n            user.setConversationStatus(ConversationStatus.LeaveFeedback);\n            user.setSelectedEventId(eventId);\n            user.setSelectedFeedbackId(feedbackId);\n            userService.insertOrUpdate(user);\n            botAnswer = \"Write your message\";\n        } else {\n            botAnswer = \"Something went wrong!\";\n        }\n        return new SendMessage(chatId, botAnswer);\n    }\n}\n", "refactored": false}
{"hexsha": "6dc842b708c83d823cc7570e2b26a376f97948f7", "ext": "java", "lang": "Java", "content": "public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {\n\n    private static final long serialVersionUID = 1L;\n\n    private ModelVersion sinceVersion;\n\n    private ModelVersion deprecatedVersion;\n\n    protected VersionableSurveyObject(Survey survey, int id) {\n        super(survey, id);\n    }\n\n    protected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {\n        super(survey, source, id);\n        if (survey == source.getSurvey()) {\n            this.sinceVersion = source.sinceVersion;\n            this.deprecatedVersion = source.deprecatedVersion;\n        }\n    }\n\n    public void removeVersioning(ModelVersion version) {\n        int versionId = version.getId();\n        if (sinceVersion != null && sinceVersion.getId() == versionId) {\n            sinceVersion = null;\n        }\n        if (deprecatedVersion != null && deprecatedVersion.getId() == versionId) {\n            deprecatedVersion = null;\n        }\n    }\n\n    public String getSinceVersionName() {\n        return sinceVersion == null ? null : sinceVersion.getName();\n    }\n\n    public Integer getSinceVersionId() {\n        return sinceVersion == null ? null : sinceVersion.getId();\n    }\n\n    public void setSinceVersionByName(String name) {\n        this.sinceVersion = name == null ? null : findVersion(name);\n    }\n\n    public String getDeprecatedVersionName() {\n        return deprecatedVersion == null ? null : deprecatedVersion.getName();\n    }\n\n    public Integer getDeprecatedVersionId() {\n        return deprecatedVersion == null ? null : deprecatedVersion.getId();\n    }\n\n    public void setDeprecatedVersionByName(String name) {\n        this.deprecatedVersion = name == null ? null : findVersion(name);\n    }\n\n    public ModelVersion getSinceVersion() {\n        return this.sinceVersion;\n    }\n\n    public void setSinceVersion(ModelVersion since) {\n        this.sinceVersion = since;\n    }\n\n    public ModelVersion getDeprecatedVersion() {\n        return this.deprecatedVersion;\n    }\n\n    public void setDeprecatedVersion(ModelVersion deprecated) {\n        this.deprecatedVersion = deprecated;\n    }\n\n    private ModelVersion findVersion(String name) {\n        if (name == null) {\n            return null;\n        } else {\n            Survey survey = getSurvey();\n            if (survey == null) {\n                throw new IllegalStateException(\"Survey not set!\");\n            }\n            ModelVersion v = survey.getVersion(name);\n            if (v == null) {\n                throw new IllegalArgumentException(\"Undefined version '\" + name + \"' in \" + toString());\n            }\n            return v;\n        }\n    }\n\n    @Override\n    public boolean deepEquals(Object obj) {\n        if (this == obj)\n            return true;\n        if (!super.deepEquals(obj))\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        VersionableSurveyObject other = (VersionableSurveyObject) obj;\n        if (deprecatedVersion == null) {\n            if (other.deprecatedVersion != null)\n                return false;\n        } else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))\n            return false;\n        if (sinceVersion == null) {\n            if (other.sinceVersion != null)\n                return false;\n        } else if (!sinceVersion.deepEquals(other.sinceVersion))\n            return false;\n        return true;\n    }\n}\n", "class_id": 0, "repo": "jadedevin13/collect", "file": "collect-core/src/main/java/org/openforis/idm/metamodel/VersionableSurveyObject.java", "last_update_at": "2021-10-05T13:25:16+00:00", "original_content": "public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {\n\n    private static final long serialVersionUID = 1L;\n\n    private ModelVersion sinceVersion;\n\n    private ModelVersion deprecatedVersion;\n\n    protected VersionableSurveyObject(Survey survey, int id) {\n        super(survey, id);\n    }\n\n    protected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {\n        super(survey, source, id);\n        if (survey == source.getSurvey()) {\n            this.sinceVersion = source.sinceVersion;\n            this.deprecatedVersion = source.deprecatedVersion;\n        }\n    }\n\n    public void removeVersioning(ModelVersion version) {\n        int versionId = version.getId();\n        if (sinceVersion != null && sinceVersion.getId() == versionId) {\n            sinceVersion = null;\n        }\n        if (deprecatedVersion != null && deprecatedVersion.getId() == versionId) {\n            deprecatedVersion = null;\n        }\n    }\n\n    public String getSinceVersionName() {\n        return sinceVersion == null ? null : sinceVersion.getName();\n    }\n\n    public Integer getSinceVersionId() {\n        return sinceVersion == null ? null : sinceVersion.getId();\n    }\n\n    public void setSinceVersionByName(String name) {\n        this.sinceVersion = name == null ? null : findVersion(name);\n    }\n\n    public String getDeprecatedVersionName() {\n        return deprecatedVersion == null ? null : deprecatedVersion.getName();\n    }\n\n    public Integer getDeprecatedVersionId() {\n        return deprecatedVersion == null ? null : deprecatedVersion.getId();\n    }\n\n    public void setDeprecatedVersionByName(String name) {\n        this.deprecatedVersion = name == null ? null : findVersion(name);\n    }\n\n    public ModelVersion getSinceVersion() {\n        return this.sinceVersion;\n    }\n\n    public void setSinceVersion(ModelVersion since) {\n        this.sinceVersion = since;\n    }\n\n    public ModelVersion getDeprecatedVersion() {\n        return this.deprecatedVersion;\n    }\n\n    public void setDeprecatedVersion(ModelVersion deprecated) {\n        this.deprecatedVersion = deprecated;\n    }\n\n    private ModelVersion findVersion(String name) {\n        if (name == null) {\n            return null;\n        } else {\n            Survey survey = getSurvey();\n            if (survey == null) {\n                throw new IllegalStateException(\"Survey not set!\");\n            }\n            ModelVersion v = survey.getVersion(name);\n            if (v == null) {\n                throw new IllegalArgumentException(\"Undefined version '\" + name + \"' in \" + toString());\n            }\n            return v;\n        }\n    }\n\n    @Override\n    public boolean deepEquals(Object obj) {\n        if (this == obj)\n            return true;\n        if (!super.deepEquals(obj))\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        VersionableSurveyObject other = (VersionableSurveyObject) obj;\n        if (deprecatedVersion == null) {\n            if (other.deprecatedVersion != null)\n                return false;\n        } else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))\n            return false;\n        if (sinceVersion == null) {\n            if (other.sinceVersion != null)\n                return false;\n        } else if (!sinceVersion.deepEquals(other.sinceVersion))\n            return false;\n        return true;\n    }\n}\n", "refactored": false}
{"hexsha": "f9adf1391613a41a2b211c8031b0e6fa8832d4dc", "ext": "java", "lang": "Java", "content": "public class ApiOvhSslGateway extends ApiOvhBase {\n\n    public ApiOvhSslGateway(ApiOvhCore core) {\n        super(core);\n    }\n\n    /**\n     * Launch a contact change procedure\n     *\n     * REST: POST /sslGateway/{serviceName}/changeContact\n     * @param contactAdmin [required] The contact to set as admin contact\n     * @param contactTech [required] The contact to set as tech contact\n     * @param contactBilling [required] The contact to set as billing contact\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/changeContact\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"contactAdmin\", contactAdmin);\n        addBody(o, \"contactBilling\", contactBilling);\n        addBody(o, \"contactTech\", contactTech);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, t1);\n    }\n\n    private static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {\n    };\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/serviceInfos\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhService.class);\n    }\n\n    /**\n     * Alter this object properties\n     *\n     * REST: PUT /sslGateway/{serviceName}/serviceInfos\n     * @param body [required] New object properties\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n        StringBuilder sb = path(qPath, serviceName);\n        exec(qPath, \"PUT\", sb.toString(), body);\n    }\n\n    /**\n     * Renew your SSL certificates\n     *\n     * REST: POST /sslGateway/{serviceName}/renewCertificate\n     * @param domain [required] Domain on which you want to renew certificate\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/renewCertificate\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"domain\", domain);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, t2);\n    }\n\n    private static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {\n    };\n\n    /**\n     * Terminate your service\n     *\n     * REST: POST /sslGateway/{serviceName}/terminate\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public String serviceName_terminate_POST(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/terminate\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"POST\", sb.toString(), null);\n        return convertTo(resp, String.class);\n    }\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/domain/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your domain\n     *\n     * API beta\n     */\n    public OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhDomain.class);\n    }\n\n    /**\n     * Detach a domain from your SSL Gateway\n     *\n     * REST: DELETE /sslGateway/{serviceName}/domain/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your domain\n     *\n     * API beta\n     */\n    public void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        exec(qPath, \"DELETE\", sb.toString(), null);\n    }\n\n    /**\n     * Domains attached to your SSL Gateway\n     *\n     * REST: GET /sslGateway/{serviceName}/domain\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t1);\n    }\n\n    /**\n     * Attach a new domain to your SSL Gateway\n     *\n     * REST: POST /sslGateway/{serviceName}/domain\n     * @param domain [required] Domain to attach\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"domain\", domain);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, OvhDomain.class);\n    }\n\n    /**\n     * Servers attached to your SSL Gateway\n     *\n     * REST: GET /sslGateway/{serviceName}/server\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t1);\n    }\n\n    /**\n     * Add a new server to your SSL Gateway\n     *\n     * REST: POST /sslGateway/{serviceName}/server\n     * @param port [required] Port of your server\n     * @param address [required] IPv4 address of your server\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"address\", address);\n        addBody(o, \"port\", port);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, OvhServer.class);\n    }\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/server/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your server\n     *\n     * API beta\n     */\n    public OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhServer.class);\n    }\n\n    /**\n     * Alter this object properties\n     *\n     * REST: PUT /sslGateway/{serviceName}/server/{id}\n     * @param body [required] New object properties\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your server\n     *\n     * API beta\n     */\n    public void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        exec(qPath, \"PUT\", sb.toString(), body);\n    }\n\n    /**\n     * Remove a server\n     *\n     * REST: DELETE /sslGateway/{serviceName}/server/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your server\n     *\n     * API beta\n     */\n    public void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        exec(qPath, \"DELETE\", sb.toString(), null);\n    }\n\n    /**\n     * Task for this SSL Gateway\n     *\n     * REST: GET /sslGateway/{serviceName}/task\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/task\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t1);\n    }\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/task/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of the task\n     *\n     * API beta\n     */\n    public OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/task/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhTask.class);\n    }\n\n    /**\n     * Ip subnet used by OVH to nat requests to your SSL Gateway backends.\n     *\n     * REST: GET /sslGateway/{serviceName}/natIp\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/natIp\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t3);\n    }\n\n    private static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {\n    };\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhSslGateway serviceName_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhSslGateway.class);\n    }\n\n    /**\n     * Alter this object properties\n     *\n     * REST: PUT /sslGateway/{serviceName}\n     * @param body [required] New object properties\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}\";\n        StringBuilder sb = path(qPath, serviceName);\n        exec(qPath, \"PUT\", sb.toString(), body);\n    }\n\n    /**\n     * Confirm termination of your service\n     *\n     * REST: POST /sslGateway/{serviceName}/confirmTermination\n     * @param futureUse [required] What next after your termination request\n     * @param reason [required] Reason of your termination request\n     * @param commentary [required] Commentary about your termination request\n     * @param token [required] The termination token sent by mail to the admin contact\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/confirmTermination\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"commentary\", commentary);\n        addBody(o, \"futureUse\", futureUse);\n        addBody(o, \"reason\", reason);\n        addBody(o, \"token\", token);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, String.class);\n    }\n\n    /**\n     * Check domain eligibility. Return list of eligible IP(s) for this domain.\n     *\n     * REST: GET /sslGateway/eligibility\n     * @param domain [required] domain to check eligibility for SSL Gateway offer\n     *\n     * API beta\n     */\n    public OvhEligibilityStatus eligibility_GET(String domain) throws IOException {\n        String qPath = \"/sslGateway/eligibility\";\n        StringBuilder sb = path(qPath);\n        query(sb, \"domain\", domain);\n        String resp = execN(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhEligibilityStatus.class);\n    }\n\n    /**\n     * List available services\n     *\n     * REST: GET /sslGateway\n     *\n     * API beta\n     */\n    public ArrayList<String> GET() throws IOException {\n        String qPath = \"/sslGateway\";\n        StringBuilder sb = path(qPath);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t2);\n    }\n\n    /**\n     * List of zone available for an SSL Gateway\n     *\n     * REST: GET /sslGateway/availableZones\n     *\n     * API beta\n     */\n    public ArrayList<String> availableZones_GET() throws IOException {\n        String qPath = \"/sslGateway/availableZones\";\n        StringBuilder sb = path(qPath);\n        String resp = execN(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t2);\n    }\n}\n", "class_id": 0, "repo": "marstona/ovh-java-sdk", "file": "ovh-java-sdk-sslGateway/src/main/java/net/minidev/ovh/api/ApiOvhSslGateway.java", "last_update_at": "2021-04-20T07:54:21+00:00", "original_content": "public class ApiOvhSslGateway extends ApiOvhBase {\n\n    public ApiOvhSslGateway(ApiOvhCore core) {\n        super(core);\n    }\n\n    /**\n     * Launch a contact change procedure\n     *\n     * REST: POST /sslGateway/{serviceName}/changeContact\n     * @param contactAdmin [required] The contact to set as admin contact\n     * @param contactTech [required] The contact to set as tech contact\n     * @param contactBilling [required] The contact to set as billing contact\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/changeContact\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"contactAdmin\", contactAdmin);\n        addBody(o, \"contactBilling\", contactBilling);\n        addBody(o, \"contactTech\", contactTech);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, t1);\n    }\n\n    private static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {\n    };\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/serviceInfos\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhService.class);\n    }\n\n    /**\n     * Alter this object properties\n     *\n     * REST: PUT /sslGateway/{serviceName}/serviceInfos\n     * @param body [required] New object properties\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/serviceInfos\";\n        StringBuilder sb = path(qPath, serviceName);\n        exec(qPath, \"PUT\", sb.toString(), body);\n    }\n\n    /**\n     * Renew your SSL certificates\n     *\n     * REST: POST /sslGateway/{serviceName}/renewCertificate\n     * @param domain [required] Domain on which you want to renew certificate\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/renewCertificate\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"domain\", domain);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, t2);\n    }\n\n    private static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {\n    };\n\n    /**\n     * Terminate your service\n     *\n     * REST: POST /sslGateway/{serviceName}/terminate\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public String serviceName_terminate_POST(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/terminate\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"POST\", sb.toString(), null);\n        return convertTo(resp, String.class);\n    }\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/domain/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your domain\n     *\n     * API beta\n     */\n    public OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhDomain.class);\n    }\n\n    /**\n     * Detach a domain from your SSL Gateway\n     *\n     * REST: DELETE /sslGateway/{serviceName}/domain/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your domain\n     *\n     * API beta\n     */\n    public void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        exec(qPath, \"DELETE\", sb.toString(), null);\n    }\n\n    /**\n     * Domains attached to your SSL Gateway\n     *\n     * REST: GET /sslGateway/{serviceName}/domain\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t1);\n    }\n\n    /**\n     * Attach a new domain to your SSL Gateway\n     *\n     * REST: POST /sslGateway/{serviceName}/domain\n     * @param domain [required] Domain to attach\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/domain\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"domain\", domain);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, OvhDomain.class);\n    }\n\n    /**\n     * Servers attached to your SSL Gateway\n     *\n     * REST: GET /sslGateway/{serviceName}/server\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t1);\n    }\n\n    /**\n     * Add a new server to your SSL Gateway\n     *\n     * REST: POST /sslGateway/{serviceName}/server\n     * @param port [required] Port of your server\n     * @param address [required] IPv4 address of your server\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"address\", address);\n        addBody(o, \"port\", port);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, OvhServer.class);\n    }\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/server/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your server\n     *\n     * API beta\n     */\n    public OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhServer.class);\n    }\n\n    /**\n     * Alter this object properties\n     *\n     * REST: PUT /sslGateway/{serviceName}/server/{id}\n     * @param body [required] New object properties\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your server\n     *\n     * API beta\n     */\n    public void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        exec(qPath, \"PUT\", sb.toString(), body);\n    }\n\n    /**\n     * Remove a server\n     *\n     * REST: DELETE /sslGateway/{serviceName}/server/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of your server\n     *\n     * API beta\n     */\n    public void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/server/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        exec(qPath, \"DELETE\", sb.toString(), null);\n    }\n\n    /**\n     * Task for this SSL Gateway\n     *\n     * REST: GET /sslGateway/{serviceName}/task\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/task\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t1);\n    }\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}/task/{id}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     * @param id [required] Id of the task\n     *\n     * API beta\n     */\n    public OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/task/{id}\";\n        StringBuilder sb = path(qPath, serviceName, id);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhTask.class);\n    }\n\n    /**\n     * Ip subnet used by OVH to nat requests to your SSL Gateway backends.\n     *\n     * REST: GET /sslGateway/{serviceName}/natIp\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/natIp\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t3);\n    }\n\n    private static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {\n    };\n\n    /**\n     * Get this object properties\n     *\n     * REST: GET /sslGateway/{serviceName}\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public OvhSslGateway serviceName_GET(String serviceName) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}\";\n        StringBuilder sb = path(qPath, serviceName);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhSslGateway.class);\n    }\n\n    /**\n     * Alter this object properties\n     *\n     * REST: PUT /sslGateway/{serviceName}\n     * @param body [required] New object properties\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}\";\n        StringBuilder sb = path(qPath, serviceName);\n        exec(qPath, \"PUT\", sb.toString(), body);\n    }\n\n    /**\n     * Confirm termination of your service\n     *\n     * REST: POST /sslGateway/{serviceName}/confirmTermination\n     * @param futureUse [required] What next after your termination request\n     * @param reason [required] Reason of your termination request\n     * @param commentary [required] Commentary about your termination request\n     * @param token [required] The termination token sent by mail to the admin contact\n     * @param serviceName [required] The internal name of your SSL Gateway\n     *\n     * API beta\n     */\n    public String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {\n        String qPath = \"/sslGateway/{serviceName}/confirmTermination\";\n        StringBuilder sb = path(qPath, serviceName);\n        HashMap<String, Object> o = new HashMap<String, Object>();\n        addBody(o, \"commentary\", commentary);\n        addBody(o, \"futureUse\", futureUse);\n        addBody(o, \"reason\", reason);\n        addBody(o, \"token\", token);\n        String resp = exec(qPath, \"POST\", sb.toString(), o);\n        return convertTo(resp, String.class);\n    }\n\n    /**\n     * Check domain eligibility. Return list of eligible IP(s) for this domain.\n     *\n     * REST: GET /sslGateway/eligibility\n     * @param domain [required] domain to check eligibility for SSL Gateway offer\n     *\n     * API beta\n     */\n    public OvhEligibilityStatus eligibility_GET(String domain) throws IOException {\n        String qPath = \"/sslGateway/eligibility\";\n        StringBuilder sb = path(qPath);\n        query(sb, \"domain\", domain);\n        String resp = execN(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, OvhEligibilityStatus.class);\n    }\n\n    /**\n     * List available services\n     *\n     * REST: GET /sslGateway\n     *\n     * API beta\n     */\n    public ArrayList<String> GET() throws IOException {\n        String qPath = \"/sslGateway\";\n        StringBuilder sb = path(qPath);\n        String resp = exec(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t2);\n    }\n\n    /**\n     * List of zone available for an SSL Gateway\n     *\n     * REST: GET /sslGateway/availableZones\n     *\n     * API beta\n     */\n    public ArrayList<String> availableZones_GET() throws IOException {\n        String qPath = \"/sslGateway/availableZones\";\n        StringBuilder sb = path(qPath);\n        String resp = execN(qPath, \"GET\", sb.toString(), null);\n        return convertTo(resp, t2);\n    }\n}\n", "refactored": false}
{"hexsha": "2e2144587792d1fd6ca9470159dc937992a00ce0", "ext": "java", "lang": "Java", "content": "public class LectorLadronesJSON implements LectorLadrones {\n\n    private String ruta = \"src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json\";\n\n    public ArrayList<Ladron> cargarLadrones() {\n        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                String hobby = (String) ladron.get(\"Hobby\");\n                String cabello = (String) ladron.get(\"Cabello\");\n                String caracteristica = (String) ladron.get(\"Caracter?stica\");\n                String vehiculo = (String) ladron.get(\"Veh?culo\");\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n                ladrones.add(objLadron);\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        } catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        } catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return ladrones;\n    }\n\n    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {\n        HashMap<String, ArrayList<String>> diccionario = new HashMap();\n        diccionario.put(\"Sexo\", new ArrayList<String>());\n        diccionario.put(\"Cabello\", new ArrayList<String>());\n        diccionario.put(\"Hobby\", new ArrayList<String>());\n        diccionario.put(\"Vehiculo\", new ArrayList<String>());\n        diccionario.put(\"Senia\", new ArrayList<String>());\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                ArrayList<String> sexos = diccionario.get(\"Sexo\");\n                if (!sexos.contains(sexo)) {\n                    sexos.add(sexo);\n                }\n                String hobby = (String) ladron.get(\"Hobby\");\n                ArrayList<String> hobbys = diccionario.get(\"Hobby\");\n                if (!hobbys.contains(hobby)) {\n                    hobbys.add(hobby);\n                }\n                String cabello = (String) ladron.get(\"Cabello\");\n                ArrayList<String> cabellos = diccionario.get(\"Cabello\");\n                if (!cabellos.contains(cabello)) {\n                    cabellos.add(cabello);\n                }\n                String caracteristica = (String) ladron.get(\"Caracter?stica\");\n                ArrayList<String> senias = diccionario.get(\"Senia\");\n                if (!senias.contains(caracteristica)) {\n                    senias.add(caracteristica);\n                }\n                String vehiculo = (String) ladron.get(\"Veh?culo\");\n                ArrayList<String> vehiculos = diccionario.get(\"Vehiculo\");\n                if (!vehiculos.contains(vehiculo)) {\n                    vehiculos.add(vehiculo);\n                }\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        } catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        } catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return diccionario;\n    }\n}\n", "class_id": 0, "repo": "jmdieguez/algothief", "file": "src/main/java/edu/fiuba/algo3/modelo/lectoresDeArchivos/LectorLadronesJSON.java", "last_update_at": "2021-12-23T21:09:22+00:00", "original_content": "public class LectorLadronesJSON implements LectorLadrones {\n\n    private String ruta = \"src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json\";\n\n    public ArrayList<Ladron> cargarLadrones() {\n        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                String hobby = (String) ladron.get(\"Hobby\");\n                String cabello = (String) ladron.get(\"Cabello\");\n                String caracteristica = (String) ladron.get(\"Caracter?stica\");\n                String vehiculo = (String) ladron.get(\"Veh?culo\");\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n                ladrones.add(objLadron);\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        } catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        } catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return ladrones;\n    }\n\n    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {\n        HashMap<String, ArrayList<String>> diccionario = new HashMap();\n        diccionario.put(\"Sexo\", new ArrayList<String>());\n        diccionario.put(\"Cabello\", new ArrayList<String>());\n        diccionario.put(\"Hobby\", new ArrayList<String>());\n        diccionario.put(\"Vehiculo\", new ArrayList<String>());\n        diccionario.put(\"Senia\", new ArrayList<String>());\n        JSONParser parser = new JSONParser();\n        try {\n            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));\n            for (Object o : JSONLadrones) {\n                JSONObject ladron = (JSONObject) o;\n                String nombre = (String) ladron.get(\"Nombre\");\n                String sexo = (String) ladron.get(\"Sexo\");\n                ArrayList<String> sexos = diccionario.get(\"Sexo\");\n                if (!sexos.contains(sexo)) {\n                    sexos.add(sexo);\n                }\n                String hobby = (String) ladron.get(\"Hobby\");\n                ArrayList<String> hobbys = diccionario.get(\"Hobby\");\n                if (!hobbys.contains(hobby)) {\n                    hobbys.add(hobby);\n                }\n                String cabello = (String) ladron.get(\"Cabello\");\n                ArrayList<String> cabellos = diccionario.get(\"Cabello\");\n                if (!cabellos.contains(cabello)) {\n                    cabellos.add(cabello);\n                }\n                String caracteristica = (String) ladron.get(\"Caracter?stica\");\n                ArrayList<String> senias = diccionario.get(\"Senia\");\n                if (!senias.contains(caracteristica)) {\n                    senias.add(caracteristica);\n                }\n                String vehiculo = (String) ladron.get(\"Veh?culo\");\n                ArrayList<String> vehiculos = diccionario.get(\"Vehiculo\");\n                if (!vehiculos.contains(vehiculo)) {\n                    vehiculos.add(vehiculo);\n                }\n                ArrayList<String> descripciones = (ArrayList<String>) ladron.get(\"Descripciones\");\n                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"No se encontro el archivo\");\n        } catch (IOException e) {\n            System.out.println(\"Entrada y salida interrumpida\");\n        } catch (ParseException e) {\n            System.out.println(\"Error de parseo en el archivo\");\n        }\n        return diccionario;\n    }\n}\n", "refactored": false}
{"hexsha": "37ecfb9df884be7d35bf5475a3abf4d1b0e8fe8d", "ext": "java", "lang": "Java", "content": "@RunWith(JMock.class)\npublic class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {\n\n    private PasswordValueSemanticsProvider adapter;\n\n    private Object password;\n\n    private FacetHolder holder;\n\n    @Before\n    public void setUpObjects() throws Exception {\n        holder = new FacetHolderImpl();\n        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));\n        password = new Password(\"secret\");\n    }\n\n    @Test\n    public void testEncoding() {\n        assertEquals(\"secret\", new String(adapter.toEncodedString(password)));\n    }\n}\n", "class_id": 0, "repo": "Corpus-2021/nakedobjects-4.0.0", "file": "core/metamodel/src/test/java/org/nakedobjects/metamodel/value/PasswordValueSemanticsProviderTest.java", "last_update_at": "2021-02-22T15:40:05+00:00", "original_content": "@RunWith(JMock.class)\npublic class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {\n\n    private PasswordValueSemanticsProvider adapter;\n\n    private Object password;\n\n    private FacetHolder holder;\n\n    @Before\n    public void setUpObjects() throws Exception {\n        holder = new FacetHolderImpl();\n        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));\n        password = new Password(\"secret\");\n    }\n\n    @Test\n    public void testEncoding() {\n        assertEquals(\"secret\", new String(adapter.toEncodedString(password)));\n    }\n}\n", "refactored": false}
{"hexsha": "2f37e0e31a286e088d15fb05e86f8bfa506763a6", "ext": "java", "lang": "Java", "content": "public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {\n\n    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());\n\n    private ServerBootstrap serverBootstrap;\n\n    private Channel serverChannel;\n\n    private EndpointService endpointService;\n\n    private AtomicBoolean started = new AtomicBoolean(false);\n\n    private PeerGroup group;\n\n    private PeerGroupID homeGroupID;\n\n    private PeerID localPeerID;\n\n    private MessengerEventListener listener;\n\n    private List<EndpointAddress> publicAddresses;\n\n    private AddressTranslator addrTranslator;\n\n    private ChannelGroup channels;\n\n    private HashedWheelTimer timeoutTimer;\n\n    private ChannelGroupFuture closeChannelsFuture;\n\n    private List<EndpointAddress> boundAddresses;\n\n    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {\n        this.channels = new DefaultChannelGroup();\n        this.group = group;\n        this.homeGroupID = group.getPeerGroupID();\n        this.localPeerID = group.getPeerID();\n        this.addrTranslator = addrTranslator;\n        serverBootstrap = new ServerBootstrap(factory);\n        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());\n        timeoutTimer = new HashedWheelTimer();\n    }\n\n    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {\n        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));\n        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);\n        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));\n        if (serverChannel == null) {\n            Logging.logCheckedWarning(LOG, \"Failed to bind to any of the addresses in the configured range\");\n            throw new PeerGroupException(\"Failed to bind to any address in the configured range\");\n        }\n        if (usePublicOnly) {\n            if (publicAddress == null) {\n                Logging.logCheckedWarning(LOG, \"Instructed to use public address only, but no public address specified! Using all bound addresses instead\");\n                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);\n            } else {\n                publicAddresses = new ArrayList<EndpointAddress>(1);\n                publicAddresses.add(publicAddress);\n            }\n        } else {\n            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);\n            publicAddresses = new ArrayList<EndpointAddress>(size);\n            if (publicAddress != null) {\n                publicAddresses.add(publicAddress);\n            }\n            publicAddresses.addAll(boundAddresses);\n        }\n    }\n\n    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {\n        for (SocketAddress nextBP : potentialBindpoints) {\n            try {\n                serverChannel = serverBootstrap.bind(nextBP);\n                channels.add(serverChannel);\n                return nextBP;\n            } catch (ChannelException e) {\n                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();\n                Logging.logCheckedInfo(LOG, \"Attempt to bind to \", nextBP, \" failed (\", failReason, \"), trying another address\");\n            }\n        }\n        return null;\n    }\n\n    public boolean start(EndpointService endpointService) throws IllegalStateException {\n        if (started.get()) {\n            throw new IllegalStateException(\"already started\");\n        }\n        this.endpointService = endpointService;\n        listener = endpointService.addMessageTransport(this);\n        if (listener == null) {\n            Logging.logCheckedSevere(LOG, \"Transport registration failed for netty transport server, protocol=\", addrTranslator.getProtocolName());\n            return false;\n        }\n        started.set(true);\n        return true;\n    }\n\n    public void beginStop() {\n        if (!started.compareAndSet(true, false)) {\n            Logging.logCheckedWarning(LOG, \"Netty transport server for protocol \", addrTranslator.getProtocolName(), \" already stopped or never started!\");\n            return;\n        }\n        closeChannelsFuture = channels.close();\n    }\n\n    public void stop() throws IllegalStateException {\n        if (closeChannelsFuture != null) {\n            closeChannelsFuture.awaitUninterruptibly();\n        }\n        serverChannel = null;\n        serverBootstrap.releaseExternalResources();\n        timeoutTimer.stop();\n    }\n\n    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {\n        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n        AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n        listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));\n    }\n\n    public Iterator<EndpointAddress> getPublicAddresses() {\n        return publicAddresses.iterator();\n    }\n\n    public EndpointService getEndpointService() {\n        return endpointService;\n    }\n\n    public String getProtocolName() {\n        return addrTranslator.getProtocolName();\n    }\n\n    @Sharable\n    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {\n\n        @Override\n        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {\n            Logging.logCheckedFine(LOG, String.format(\"Incoming connection for transport %s from %s to %s (handled by %s)\", getProtocolName(), e.getChildChannel().getRemoteAddress(), e.getChildChannel().getLocalAddress(), ctx.getChannel().getLocalAddress()));\n            channels.add(e.getChildChannel());\n            super.childChannelOpen(ctx, e);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n            // ServerBootstrap, and handled in in bindServerChannel()\n            if (!(e.getCause() instanceof BindException)) {\n                LOG.log(Level.WARNING, \"Unexpected exception on server channel for {0} protocol:\\n{1}\", new Object[] { getProtocolName(), e.getCause() });\n            }\n        }\n    }\n\n    public boolean isStarted() {\n        return started.get();\n    }\n\n    /**\n     * @return the physically bound addresses for this transport, as opposed to those which are\n     * broadcasted to external peers.\n     */\n    public List<EndpointAddress> getBoundAddresses() {\n        return boundAddresses;\n    }\n}\n", "class_id": 0, "repo": "chaupal/jp2p-jxta", "file": "Workspace/net.jp2p.endpoint.netty/src/net/jxta/impl/endpoint/netty/NettyTransportServer.java", "last_update_at": "2021-01-20T14:53:01+00:00", "original_content": "public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {\n\n    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());\n\n    private ServerBootstrap serverBootstrap;\n\n    private Channel serverChannel;\n\n    private EndpointService endpointService;\n\n    private AtomicBoolean started = new AtomicBoolean(false);\n\n    private PeerGroup group;\n\n    private PeerGroupID homeGroupID;\n\n    private PeerID localPeerID;\n\n    private MessengerEventListener listener;\n\n    private List<EndpointAddress> publicAddresses;\n\n    private AddressTranslator addrTranslator;\n\n    private ChannelGroup channels;\n\n    private HashedWheelTimer timeoutTimer;\n\n    private ChannelGroupFuture closeChannelsFuture;\n\n    private List<EndpointAddress> boundAddresses;\n\n    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {\n        this.channels = new DefaultChannelGroup();\n        this.group = group;\n        this.homeGroupID = group.getPeerGroupID();\n        this.localPeerID = group.getPeerID();\n        this.addrTranslator = addrTranslator;\n        serverBootstrap = new ServerBootstrap(factory);\n        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());\n        timeoutTimer = new HashedWheelTimer();\n    }\n\n    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {\n        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));\n        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);\n        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));\n        if (serverChannel == null) {\n            Logging.logCheckedWarning(LOG, \"Failed to bind to any of the addresses in the configured range\");\n            throw new PeerGroupException(\"Failed to bind to any address in the configured range\");\n        }\n        if (usePublicOnly) {\n            if (publicAddress == null) {\n                Logging.logCheckedWarning(LOG, \"Instructed to use public address only, but no public address specified! Using all bound addresses instead\");\n                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);\n            } else {\n                publicAddresses = new ArrayList<EndpointAddress>(1);\n                publicAddresses.add(publicAddress);\n            }\n        } else {\n            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);\n            publicAddresses = new ArrayList<EndpointAddress>(size);\n            if (publicAddress != null) {\n                publicAddresses.add(publicAddress);\n            }\n            publicAddresses.addAll(boundAddresses);\n        }\n    }\n\n    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {\n        for (SocketAddress nextBP : potentialBindpoints) {\n            try {\n                serverChannel = serverBootstrap.bind(nextBP);\n                channels.add(serverChannel);\n                return nextBP;\n            } catch (ChannelException e) {\n                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();\n                Logging.logCheckedInfo(LOG, \"Attempt to bind to \", nextBP, \" failed (\", failReason, \"), trying another address\");\n            }\n        }\n        return null;\n    }\n\n    public boolean start(EndpointService endpointService) throws IllegalStateException {\n        if (started.get()) {\n            throw new IllegalStateException(\"already started\");\n        }\n        this.endpointService = endpointService;\n        listener = endpointService.addMessageTransport(this);\n        if (listener == null) {\n            Logging.logCheckedSevere(LOG, \"Transport registration failed for netty transport server, protocol=\", addrTranslator.getProtocolName());\n            return false;\n        }\n        started.set(true);\n        return true;\n    }\n\n    public void beginStop() {\n        if (!started.compareAndSet(true, false)) {\n            Logging.logCheckedWarning(LOG, \"Netty transport server for protocol \", addrTranslator.getProtocolName(), \" already stopped or never started!\");\n            return;\n        }\n        closeChannelsFuture = channels.close();\n    }\n\n    public void stop() throws IllegalStateException {\n        if (closeChannelsFuture != null) {\n            closeChannelsFuture.awaitUninterruptibly();\n        }\n        serverChannel = null;\n        serverBootstrap.releaseExternalResources();\n        timeoutTimer.stop();\n    }\n\n    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {\n        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n        AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);\n        listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));\n    }\n\n    public Iterator<EndpointAddress> getPublicAddresses() {\n        return publicAddresses.iterator();\n    }\n\n    public EndpointService getEndpointService() {\n        return endpointService;\n    }\n\n    public String getProtocolName() {\n        return addrTranslator.getProtocolName();\n    }\n\n    @Sharable\n    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {\n\n        @Override\n        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {\n            Logging.logCheckedFine(LOG, String.format(\"Incoming connection for transport %s from %s to %s (handled by %s)\", getProtocolName(), e.getChildChannel().getRemoteAddress(), e.getChildChannel().getLocalAddress(), ctx.getChannel().getLocalAddress()));\n            channels.add(e.getChildChannel());\n            super.childChannelOpen(ctx, e);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n            // ServerBootstrap, and handled in in bindServerChannel()\n            if (!(e.getCause() instanceof BindException)) {\n                LOG.log(Level.WARNING, \"Unexpected exception on server channel for {0} protocol:\\n{1}\", new Object[] { getProtocolName(), e.getCause() });\n            }\n        }\n    }\n\n    public boolean isStarted() {\n        return started.get();\n    }\n\n    /**\n     * @return the physically bound addresses for this transport, as opposed to those which are\n     * broadcasted to external peers.\n     */\n    public List<EndpointAddress> getBoundAddresses() {\n        return boundAddresses;\n    }\n}\n", "refactored": false}
{"hexsha": "5243c099bbc4d6b225d8d4ed73dce3be7503010c", "ext": "java", "lang": "Java", "content": "public class ScannerImplTest {\n\n    private ClientContext context;\n\n    @Before\n    public void setup() {\n        context = EasyMock.createMock(ClientContext.class);\n    }\n\n    @Test\n    public void testValidReadaheadValues() {\n        Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n        s.setReadaheadThreshold(0);\n        s.setReadaheadThreshold(10);\n        s.setReadaheadThreshold(Long.MAX_VALUE);\n        assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());\n        s.close();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInValidReadaheadValues() {\n        Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n        s.setReadaheadThreshold(-1);\n        s.close();\n    }\n\n    @Test\n    public void testGetAuthorizations() {\n        Authorizations expected = new Authorizations(\"a,b\");\n        Scanner s = new ScannerImpl(context, \"foo\", expected);\n        assertEquals(expected, s.getAuthorizations());\n        s.close();\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Test(expected = IllegalArgumentException.class)\n    public void testNullAuthorizationsFails() {\n        new ScannerImpl(context, \"foo\", null);\n    }\n}\n", "class_id": 0, "repo": "dorateq/accumulo", "file": "core/src/test/java/org/apache/accumulo/core/client/impl/ScannerImplTest.java", "last_update_at": "2021-04-07T18:45:40+00:00", "original_content": "public class ScannerImplTest {\n\n    private ClientContext context;\n\n    @Before\n    public void setup() {\n        context = EasyMock.createMock(ClientContext.class);\n    }\n\n    @Test\n    public void testValidReadaheadValues() {\n        Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n        s.setReadaheadThreshold(0);\n        s.setReadaheadThreshold(10);\n        s.setReadaheadThreshold(Long.MAX_VALUE);\n        assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());\n        s.close();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInValidReadaheadValues() {\n        Scanner s = new ScannerImpl(context, \"foo\", Authorizations.EMPTY);\n        s.setReadaheadThreshold(-1);\n        s.close();\n    }\n\n    @Test\n    public void testGetAuthorizations() {\n        Authorizations expected = new Authorizations(\"a,b\");\n        Scanner s = new ScannerImpl(context, \"foo\", expected);\n        assertEquals(expected, s.getAuthorizations());\n        s.close();\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Test(expected = IllegalArgumentException.class)\n    public void testNullAuthorizationsFails() {\n        new ScannerImpl(context, \"foo\", null);\n    }\n}\n", "refactored": false}
{"hexsha": "4d7f0a0119dc23fe4bd356b1832ed7063663cf23", "ext": "java", "lang": "Java", "content": "public class D11_ValidAnagram {\n\n    public static void main(String[] args) {\n        ValidAnagramSolution vas = new ValidAnagramSolution();\n        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();\n        System.out.println(vas.isAnagram(\"azamat\", \"tamaza\"));\n        System.out.println(vas_1.isAnagram(\"azamat\", \"tamaza\"));\n    }\n}\n", "class_id": 0, "repo": "SudoAzek/LeetCodeJava", "file": "Solutions/src/february_daily_challenge/D11_ValidAnagram.java", "last_update_at": "2021-12-18T22:51:42+00:00", "original_content": "public class D11_ValidAnagram {\n\n    public static void main(String[] args) {\n        ValidAnagramSolution vas = new ValidAnagramSolution();\n        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();\n        System.out.println(vas.isAnagram(\"azamat\", \"tamaza\"));\n        System.out.println(vas_1.isAnagram(\"azamat\", \"tamaza\"));\n    }\n}\n", "refactored": false}
{"hexsha": "cf298733351b7e35725e78d8f67a8e27f7e35c3e", "ext": "java", "lang": "Java", "content": "public class demo06ArrayListStudent {\n\n    public static void main(String[] args) {\n        ArrayList<Student> list = new ArrayList<>();\n        list.add(new Student(22, \"???\"));\n        list.add(new Student(23, \"???\"));\n        list.add(new Student(53, \"???\"));\n        list.add(new Student(33, \"???\"));\n        int i = 0;\n        while (i < list.size()) try {\n            Student stu = list.get(i);\n            System.out.println(\"???\" + stu.getName() + \" ???\" + stu.getAge());\n        } finally {\n            i++;\n        }\n    }\n}\n", "class_id": 0, "repo": "BinmingWen/base-code", "file": "day06-code/src/demo04/demo06ArrayListStudent.java", "last_update_at": "2021-03-02T00:49:32+00:00", "original_content": "public class demo06ArrayListStudent {\n\n    public static void main(String[] args) {\n        ArrayList<Student> list = new ArrayList<>();\n        list.add(new Student(22, \"???\"));\n        list.add(new Student(23, \"???\"));\n        list.add(new Student(53, \"???\"));\n        list.add(new Student(33, \"???\"));\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(\"???\" + stu.getName() + \" ???\" + stu.getAge());\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "f897b790e84ce679266078228c42440591f1ba9b", "ext": "java", "lang": "Java", "content": "public class IsDAG_DontHave_Cycles {\n\n    Map<Integer, Set<Integer>> map = new HashMap<>();\n\n    Set<Integer> vis = new HashSet<>();\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (prerequisites == null) {\n            return false;\n        }\n        if (prerequisites.length <= 0) {\n            return true;\n        }\n        Set<Integer> prevS = new HashSet<>();\n        Set<Integer> nextS = new HashSet<>();\n        int n = prerequisites.length;\n        int i = 0;\n        while (i < n) try {\n            int prevCour = prerequisites[i][1];\n            int nextCour = prerequisites[i][0];\n            prevS.add(prevCour);\n            nextS.add(nextCour);\n            Set<Integer> courses = map.get(prevCour);\n            if (courses == null) {\n                courses = new HashSet<>();\n                map.put(prevCour, courses);\n            }\n            courses.add(nextCour);\n        } finally {\n            i++;\n        }\n        prevS.removeAll(nextS);\n        for (Integer item : prevS) {\n            if (!dfs(item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean dfs(Integer node) {\n        if (node == null) {\n            return true;\n        }\n        if (vis.contains(node)) {\n            return false;\n        }\n        vis.add(node);\n        Set<Integer> courses = map.get(node);\n        if (courses != null) {\n            for (Integer n : courses) {\n                if (!dfs(n)) {\n                    return false;\n                }\n            }\n        }\n        vis.remove(node);\n        return true;\n    }\n}\n", "class_id": 0, "repo": "sergeyltd/pilgrim-base", "file": "src/main/java/org/pilgrim/leetcode/y2021/IsDAG_DontHave_Cycles.java", "last_update_at": "2021-04-06T17:19:31+00:00", "original_content": "public class IsDAG_DontHave_Cycles {\n\n    Map<Integer, Set<Integer>> map = new HashMap<>();\n\n    Set<Integer> vis = new HashSet<>();\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (prerequisites == null) {\n            return false;\n        }\n        if (prerequisites.length <= 0) {\n            return true;\n        }\n        Set<Integer> prevS = new HashSet<>();\n        Set<Integer> nextS = new HashSet<>();\n        int n = prerequisites.length;\n        for (int i = 0; i < n; i++) {\n            int prevCour = prerequisites[i][1];\n            int nextCour = prerequisites[i][0];\n            prevS.add(prevCour);\n            nextS.add(nextCour);\n            Set<Integer> courses = map.get(prevCour);\n            if (courses == null) {\n                courses = new HashSet<>();\n                map.put(prevCour, courses);\n            }\n            courses.add(nextCour);\n        }\n        prevS.removeAll(nextS);\n        for (Integer item : prevS) {\n            if (!dfs(item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean dfs(Integer node) {\n        if (node == null) {\n            return true;\n        }\n        if (vis.contains(node)) {\n            return false;\n        }\n        vis.add(node);\n        Set<Integer> courses = map.get(node);\n        if (courses != null) {\n            for (Integer n : courses) {\n                if (!dfs(n)) {\n                    return false;\n                }\n            }\n        }\n        vis.remove(node);\n        return true;\n    }\n}\n", "refactored": true}
{"hexsha": "3b3405f0a50720b0ea3fa6ab7ba19be695a6240c", "ext": "java", "lang": "Java", "content": "public class NullabilityTest {\n\n    @Test\n    public void test() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;\n        settings.sortDeclarations = true;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n        final String expected = \"\" + \"interface A<T> {\\n\" + \"    data?: T;\\n\" + \"    isNonNullableFlag: boolean;\\n\" + \"    isNullableFlag?: boolean;\\n\" + \"    nonNullableBoolean: boolean;\\n\" + \"    nonNullableString: string;\\n\" + \"    nullableArray?: (string | undefined)[];\\n\" + \"    nullableBoolean?: boolean;\\n\" + \"    nullableGenericArray?: (T | undefined)[];\\n\" + \"    nullableGenericType?: T;\\n\" + \"    nullableList?: (string | undefined)[];\\n\" + \"    nullableString?: string;\\n\" + \"    test: string;\\n\" + \"    testNullable?: string;\\n\" + \"}\";\n        Assert.assertEquals(expected.trim(), output.trim());\n    }\n\n    private static class A<T> {\n\n        @Nullable\n        public String nullableString;\n\n        public String nonNullableString;\n\n        @Nullable\n        public List<@Nullable String> nullableList;\n\n        @Nullable\n        public String @Nullable [] nullableArray;\n\n        @Nullable\n        public T @Nullable [] nullableGenericArray;\n\n        @Nullable\n        public T nullableGenericType;\n\n        @Nullable\n        public Boolean nullableBoolean;\n\n        public Boolean nonNullableBoolean;\n\n        @Nullable\n        public Boolean isNullableFlag;\n\n        public Boolean isNonNullableFlag;\n\n        @Nullable\n        public <B extends T> B getData() {\n            return null;\n        }\n\n        public String getTest() {\n            return \"\";\n        }\n\n        @Nullable\n        public String getTestNullable() {\n            return null;\n        }\n    }\n\n    @Test\n    public void testVariants() {\n        testVariant(NullabilityDefinition.nullAndUndefinedUnion, \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null | undefined\");\n        testVariant(NullabilityDefinition.undefinedUnion, \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | undefined\");\n        testVariant(NullabilityDefinition.nullUnion, \"list: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null\");\n        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, \"list?: (string | null | undefined)[] | null\");\n        testVariant(NullabilityDefinition.undefinedInlineUnion, \"list?: (string | undefined)[]\");\n        testVariant(NullabilityDefinition.nullInlineUnion, \"list: (string | null)[] | null\");\n    }\n\n    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        for (String s : expected) {\n            Assert.assertTrue(output.contains(s));\n        }\n    }\n\n    private static class B {\n\n        @Nullable\n        public List<@Nullable String> list;\n    }\n\n    @Test\n    public void testCombinationsOfOptionalAndNullable() {\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.questionMark, NullabilityDefinition.nullInlineUnion, \"list?: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableType, NullabilityDefinition.nullInlineUnion, \"list: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableAndUndefinableType, NullabilityDefinition.nullAndUndefinedInlineUnion, \"list: (string | null | undefined)[] | null | undefined;\");\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableType, NullabilityDefinition.nullAndUndefinedUnion, \"list: Nullable<Nullable<string>[]> | null;\");\n    }\n\n    private static void testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration optionalPropertiesDeclaration, NullabilityDefinition nullabilityDefinition, String expected) {\n        final Settings settings = TestUtils.settings();\n        settings.optionalAnnotations.add(Nullable.class);\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        Assert.assertTrue(\"Unexpected actual output: \" + output, output.contains(expected));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testNullableAnnotationTarget() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(javax.annotation.Nullable.class);\n        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n    }\n}\n", "class_id": 0, "repo": "joaocmendes/typescript-generator", "file": "typescript-generator-core/src/test/java/cz/habarta/typescript/generator/NullabilityTest.java", "last_update_at": "2021-05-21T07:38:40+00:00", "original_content": "public class NullabilityTest {\n\n    @Test\n    public void test() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;\n        settings.sortDeclarations = true;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n        final String expected = \"\" + \"interface A<T> {\\n\" + \"    data?: T;\\n\" + \"    isNonNullableFlag: boolean;\\n\" + \"    isNullableFlag?: boolean;\\n\" + \"    nonNullableBoolean: boolean;\\n\" + \"    nonNullableString: string;\\n\" + \"    nullableArray?: (string | undefined)[];\\n\" + \"    nullableBoolean?: boolean;\\n\" + \"    nullableGenericArray?: (T | undefined)[];\\n\" + \"    nullableGenericType?: T;\\n\" + \"    nullableList?: (string | undefined)[];\\n\" + \"    nullableString?: string;\\n\" + \"    test: string;\\n\" + \"    testNullable?: string;\\n\" + \"}\";\n        Assert.assertEquals(expected.trim(), output.trim());\n    }\n\n    private static class A<T> {\n\n        @Nullable\n        public String nullableString;\n\n        public String nonNullableString;\n\n        @Nullable\n        public List<@Nullable String> nullableList;\n\n        @Nullable\n        public String @Nullable [] nullableArray;\n\n        @Nullable\n        public T @Nullable [] nullableGenericArray;\n\n        @Nullable\n        public T nullableGenericType;\n\n        @Nullable\n        public Boolean nullableBoolean;\n\n        public Boolean nonNullableBoolean;\n\n        @Nullable\n        public Boolean isNullableFlag;\n\n        public Boolean isNonNullableFlag;\n\n        @Nullable\n        public <B extends T> B getData() {\n            return null;\n        }\n\n        public String getTest() {\n            return \"\";\n        }\n\n        @Nullable\n        public String getTestNullable() {\n            return null;\n        }\n    }\n\n    @Test\n    public void testVariants() {\n        testVariant(NullabilityDefinition.nullAndUndefinedUnion, \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null | undefined\");\n        testVariant(NullabilityDefinition.undefinedUnion, \"list?: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | undefined\");\n        testVariant(NullabilityDefinition.nullUnion, \"list: Nullable<Nullable<string>[]>\", \"type Nullable<T> = T | null\");\n        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, \"list?: (string | null | undefined)[] | null\");\n        testVariant(NullabilityDefinition.undefinedInlineUnion, \"list?: (string | undefined)[]\");\n        testVariant(NullabilityDefinition.nullInlineUnion, \"list: (string | null)[] | null\");\n    }\n\n    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        for (String s : expected) {\n            Assert.assertTrue(output.contains(s));\n        }\n    }\n\n    private static class B {\n\n        @Nullable\n        public List<@Nullable String> list;\n    }\n\n    @Test\n    public void testCombinationsOfOptionalAndNullable() {\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.questionMark, NullabilityDefinition.nullInlineUnion, \"list?: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableType, NullabilityDefinition.nullInlineUnion, \"list: (string | null)[] | null;\");\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableAndUndefinableType, NullabilityDefinition.nullAndUndefinedInlineUnion, \"list: (string | null | undefined)[] | null | undefined;\");\n        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableType, NullabilityDefinition.nullAndUndefinedUnion, \"list: Nullable<Nullable<string>[]> | null;\");\n    }\n\n    private static void testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration optionalPropertiesDeclaration, NullabilityDefinition nullabilityDefinition, String expected) {\n        final Settings settings = TestUtils.settings();\n        settings.optionalAnnotations.add(Nullable.class);\n        settings.nullableAnnotations.add(Nullable.class);\n        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;\n        settings.nullabilityDefinition = nullabilityDefinition;\n        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));\n        Assert.assertTrue(\"Unexpected actual output: \" + output, output.contains(expected));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testNullableAnnotationTarget() {\n        final Settings settings = TestUtils.settings();\n        settings.nullableAnnotations.add(javax.annotation.Nullable.class);\n        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));\n    }\n}\n", "refactored": false}
{"hexsha": "147107bc0784d1e698608f00c42fa859e9ca63b2", "ext": "java", "lang": "Java", "content": "public class DatabaseWriter {\n\n    ProcessingEnvironment processingEnv;\n\n    Elements elementUtils;\n\n    Element database;\n\n    String className;\n\n    ClassName clazzName;\n\n    String fileName;\n\n    List<VariableElement> tables = new ArrayList<>();\n\n    List<VariableElement> execOnCreate = new ArrayList<>();\n\n    ExecutableElement onCreate;\n\n    ExecutableElement onUpgrade;\n\n    ExecutableElement onConfigure;\n\n    int version;\n\n    String outPackage;\n\n    public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {\n        this.processingEnv = env;\n        this.elementUtils = env.getElementUtils();\n        this.database = database;\n        String databaseSchematicName = database.getSimpleName().toString();\n        Database db = database.getAnnotation(Database.class);\n        this.version = db.version();\n        this.className = db.className();\n        if (className.trim().isEmpty()) {\n            this.className = databaseSchematicName;\n        }\n        this.outPackage = db.packageName();\n        if (outPackage.trim().isEmpty()) {\n            this.outPackage = elements.getPackageOf(database).getQualifiedName() + \".generated\";\n        }\n        this.fileName = db.fileName();\n        if (fileName.trim().isEmpty()) {\n            this.fileName = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + \".db\";\n        }\n        clazzName = ClassName.get(outPackage, className);\n        findAnnotations(database);\n    }\n\n    private void findAnnotations(Element element) {\n        List<? extends Element> enclosedElements = element.getEnclosedElements();\n        for (Element enclosedElement : enclosedElements) {\n            findAnnotations(enclosedElement);\n            Table table = enclosedElement.getAnnotation(Table.class);\n            if (table != null) {\n                tables.add((VariableElement) enclosedElement);\n            }\n            OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);\n            if (onCreate != null) {\n                if (this.onCreate != null) {\n                    error(\"Multiple OnCreate annotations found in \" + database.getSimpleName().toString());\n                }\n                this.onCreate = (ExecutableElement) enclosedElement;\n            }\n            OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);\n            if (onUpgrade != null) {\n                if (this.onUpgrade != null) {\n                    error(\"Multiple OnUpgrade annotations found in \" + database.getSimpleName().toString());\n                }\n                this.onUpgrade = (ExecutableElement) enclosedElement;\n            }\n            OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);\n            if (onConfigure != null) {\n                if (this.onConfigure != null) {\n                    error(\"Multiple OnConfigure annotations found in \" + database.getSimpleName().toString());\n                }\n                this.onConfigure = (ExecutableElement) enclosedElement;\n            }\n            ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);\n            if (execOnCreate != null) {\n                this.execOnCreate.add((VariableElement) enclosedElement);\n            }\n        }\n    }\n\n    public void writeJava(Filer filer) throws IOException {\n        JavaFileObject jfo = filer.createSourceFile(getFileName());\n        Writer out = jfo.openWriter();\n        TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className).superclass(Clazz.SQLITE_OPEN_HELPER).addModifiers(Modifier.PUBLIC);\n        FieldSpec versionSpec = FieldSpec.builder(int.class, \"DATABASE_VERSION\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL).initializer(\"$L\", version).build();\n        databaseBuilder.addField(versionSpec);\n        for (VariableElement table : tables) {\n            TypeElement tableClass = null;\n            Table columns = table.getAnnotation(Table.class);\n            try {\n                columns.value();\n            } catch (MirroredTypeException e) {\n                TypeMirror mirror = e.getTypeMirror();\n                tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);\n            }\n            ClassName tableClassName = ClassName.get(tableClass);\n            TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);\n            tableWriter.createTable(databaseBuilder);\n            tableWriter.createValuesBuilder(filer, outPackage);\n        }\n        WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);\n        databaseBuilder.addField(Clazz.CONTEXT, \"context\", Modifier.PRIVATE);\n        MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).addParameter(Clazz.CONTEXT, \"context\").addStatement(\"super(context.getApplicationContext(), $S, null, DATABASE_VERSION)\", fileName).addStatement(\"this.context = context.getApplicationContext()\").build();\n        databaseBuilder.addMethod(constructor);\n        databaseBuilder.addMethod(getOnCreateSpec());\n        databaseBuilder.addMethod(getOnUpgradeSpec());\n        if (onConfigure != null) {\n            databaseBuilder.addMethod(getOnConfigureSpec());\n        }\n        JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();\n        javaFile.writeTo(out);\n        out.flush();\n        out.close();\n    }\n\n    private MethodSpec getOnCreateSpec() {\n        MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder(\"onCreate\").returns(void.class).addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, \"db\");\n        for (VariableElement table : tables) {\n            onCreateBuilder.addStatement(\"db.execSQL($L)\", table.getSimpleName().toString());\n        }\n        for (VariableElement exec : execOnCreate) {\n            String variableName = exec.getSimpleName().toString();\n            onCreateBuilder.addStatement(\"db.execSQL($T.$L)\", exec.getEnclosingElement(), variableName);\n        }\n        if (onCreate != null) {\n            List<? extends VariableElement> parameters = onCreate.getParameters();\n            StringBuilder params = new StringBuilder();\n            boolean first = true;\n            for (VariableElement param : parameters) {\n                if (first) {\n                    first = false;\n                } else {\n                    params.append(\", \");\n                }\n                TypeMirror paramType = param.asType();\n                if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n                    params.append(\"context\");\n                }\n                if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n                    params.append(\"db\");\n                }\n            }\n            String methodName = onCreate.getSimpleName().toString();\n            onCreateBuilder.addStatement(\"$T.$L($L)\", onCreate.getEnclosingElement(), methodName, params.toString());\n        }\n        return onCreateBuilder.build();\n    }\n\n    private MethodSpec getOnUpgradeSpec() {\n        MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder(\"onUpgrade\").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, \"db\").addParameter(int.class, \"oldVersion\").addParameter(int.class, \"newVersion\");\n        if (onUpgrade != null) {\n            List<? extends VariableElement> parameters = onUpgrade.getParameters();\n            StringBuilder params = new StringBuilder();\n            boolean first = true;\n            for (VariableElement param : parameters) {\n                if (first) {\n                    first = false;\n                } else {\n                    params.append(\", \");\n                }\n                TypeMirror paramType = param.asType();\n                if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n                    params.append(\"context\");\n                }\n                if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n                    params.append(\"db\");\n                }\n                if (TypeName.get(int.class).equals(TypeName.get(paramType))) {\n                    String name = param.getSimpleName().toString();\n                    if (\"oldVersion\".equals(name)) {\n                        params.append(\"oldVersion\");\n                    } else if (\"newVersion\".equals(name)) {\n                        params.append(\"newVersion\");\n                    } else {\n                        error(\"Unknown int parameter: \" + name);\n                    }\n                }\n            }\n            String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();\n            String methodName = onUpgrade.getSimpleName().toString();\n            onUpgradeBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n        }\n        return onUpgradeBuilder.build();\n    }\n\n    private MethodSpec getOnConfigureSpec() {\n        MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder(\"onConfigure\").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, \"db\");\n        List<? extends VariableElement> parameters = onConfigure.getParameters();\n        StringBuilder params = new StringBuilder();\n        boolean first = true;\n        for (VariableElement param : parameters) {\n            if (first) {\n                first = false;\n            } else {\n                params.append(\", \");\n            }\n            TypeMirror paramType = param.asType();\n            if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n                params.append(\"db\");\n            } else {\n                throw new IllegalArgumentException(\"OnConfigure does not support parameter \" + paramType.toString());\n            }\n        }\n        String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();\n        String methodName = onConfigure.getSimpleName().toString();\n        onConfigureBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n        return onConfigureBuilder.build();\n    }\n\n    public void writeValues(Filer filer) throws IOException {\n        JavaFileObject jfo = filer.createSourceFile(getValuesFileName());\n        Writer out = jfo.openWriter();\n        final String valuesPackage = outPackage + \".values\";\n        TypeSpec.Builder spec = TypeSpec.classBuilder(className + \"Values\").addModifiers(Modifier.PUBLIC);\n        for (VariableElement table : tables) {\n            Table tableAnnotation = table.getAnnotation(Table.class);\n            String tableName = table.getConstantValue().toString();\n            tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);\n            String methodName = \"for\" + tableName;\n            String valuesName = tableName + \"ValuesBuilder\";\n            ClassName builderClass = ClassName.get(valuesPackage, valuesName);\n            MethodSpec builderSpec = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC).returns(builderClass).addStatement(\"return new $T()\", builderClass).build();\n            spec.addMethod(builderSpec);\n        }\n        JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();\n        javaFile.writeTo(out);\n        out.flush();\n        out.close();\n    }\n\n    private String getFileName() {\n        return outPackage + \".\" + className;\n    }\n\n    private String getValuesFileName() {\n        return outPackage + \".values.\" + className + \"Values\";\n    }\n\n    private void error(String error) {\n        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);\n    }\n}\n", "class_id": 0, "repo": "icse18-refactorings/schematic", "file": "schematic-compiler/src/main/java/net/simonvt/schematic/compiler/DatabaseWriter.java", "last_update_at": "2021-12-31T14:46:37+00:00", "original_content": "public class DatabaseWriter {\n\n    ProcessingEnvironment processingEnv;\n\n    Elements elementUtils;\n\n    Element database;\n\n    String className;\n\n    ClassName clazzName;\n\n    String fileName;\n\n    List<VariableElement> tables = new ArrayList<>();\n\n    List<VariableElement> execOnCreate = new ArrayList<>();\n\n    ExecutableElement onCreate;\n\n    ExecutableElement onUpgrade;\n\n    ExecutableElement onConfigure;\n\n    int version;\n\n    String outPackage;\n\n    public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {\n        this.processingEnv = env;\n        this.elementUtils = env.getElementUtils();\n        this.database = database;\n        String databaseSchematicName = database.getSimpleName().toString();\n        Database db = database.getAnnotation(Database.class);\n        this.version = db.version();\n        this.className = db.className();\n        if (className.trim().isEmpty()) {\n            this.className = databaseSchematicName;\n        }\n        this.outPackage = db.packageName();\n        if (outPackage.trim().isEmpty()) {\n            this.outPackage = elements.getPackageOf(database).getQualifiedName() + \".generated\";\n        }\n        this.fileName = db.fileName();\n        if (fileName.trim().isEmpty()) {\n            this.fileName = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + \".db\";\n        }\n        clazzName = ClassName.get(outPackage, className);\n        findAnnotations(database);\n    }\n\n    private void findAnnotations(Element element) {\n        List<? extends Element> enclosedElements = element.getEnclosedElements();\n        for (Element enclosedElement : enclosedElements) {\n            findAnnotations(enclosedElement);\n            Table table = enclosedElement.getAnnotation(Table.class);\n            if (table != null) {\n                tables.add((VariableElement) enclosedElement);\n            }\n            OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);\n            if (onCreate != null) {\n                if (this.onCreate != null) {\n                    error(\"Multiple OnCreate annotations found in \" + database.getSimpleName().toString());\n                }\n                this.onCreate = (ExecutableElement) enclosedElement;\n            }\n            OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);\n            if (onUpgrade != null) {\n                if (this.onUpgrade != null) {\n                    error(\"Multiple OnUpgrade annotations found in \" + database.getSimpleName().toString());\n                }\n                this.onUpgrade = (ExecutableElement) enclosedElement;\n            }\n            OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);\n            if (onConfigure != null) {\n                if (this.onConfigure != null) {\n                    error(\"Multiple OnConfigure annotations found in \" + database.getSimpleName().toString());\n                }\n                this.onConfigure = (ExecutableElement) enclosedElement;\n            }\n            ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);\n            if (execOnCreate != null) {\n                this.execOnCreate.add((VariableElement) enclosedElement);\n            }\n        }\n    }\n\n    public void writeJava(Filer filer) throws IOException {\n        JavaFileObject jfo = filer.createSourceFile(getFileName());\n        Writer out = jfo.openWriter();\n        TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className).superclass(Clazz.SQLITE_OPEN_HELPER).addModifiers(Modifier.PUBLIC);\n        FieldSpec versionSpec = FieldSpec.builder(int.class, \"DATABASE_VERSION\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL).initializer(\"$L\", version).build();\n        databaseBuilder.addField(versionSpec);\n        for (VariableElement table : tables) {\n            TypeElement tableClass = null;\n            Table columns = table.getAnnotation(Table.class);\n            try {\n                columns.value();\n            } catch (MirroredTypeException e) {\n                TypeMirror mirror = e.getTypeMirror();\n                tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);\n            }\n            ClassName tableClassName = ClassName.get(tableClass);\n            TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);\n            tableWriter.createTable(databaseBuilder);\n            tableWriter.createValuesBuilder(filer, outPackage);\n        }\n        WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);\n        databaseBuilder.addField(Clazz.CONTEXT, \"context\", Modifier.PRIVATE);\n        MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).addParameter(Clazz.CONTEXT, \"context\").addStatement(\"super(context.getApplicationContext(), $S, null, DATABASE_VERSION)\", fileName).addStatement(\"this.context = context.getApplicationContext()\").build();\n        databaseBuilder.addMethod(constructor);\n        databaseBuilder.addMethod(getOnCreateSpec());\n        databaseBuilder.addMethod(getOnUpgradeSpec());\n        if (onConfigure != null) {\n            databaseBuilder.addMethod(getOnConfigureSpec());\n        }\n        JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();\n        javaFile.writeTo(out);\n        out.flush();\n        out.close();\n    }\n\n    private MethodSpec getOnCreateSpec() {\n        MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder(\"onCreate\").returns(void.class).addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, \"db\");\n        for (VariableElement table : tables) {\n            onCreateBuilder.addStatement(\"db.execSQL($L)\", table.getSimpleName().toString());\n        }\n        for (VariableElement exec : execOnCreate) {\n            String variableName = exec.getSimpleName().toString();\n            onCreateBuilder.addStatement(\"db.execSQL($T.$L)\", exec.getEnclosingElement(), variableName);\n        }\n        if (onCreate != null) {\n            List<? extends VariableElement> parameters = onCreate.getParameters();\n            StringBuilder params = new StringBuilder();\n            boolean first = true;\n            for (VariableElement param : parameters) {\n                if (first) {\n                    first = false;\n                } else {\n                    params.append(\", \");\n                }\n                TypeMirror paramType = param.asType();\n                if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n                    params.append(\"context\");\n                }\n                if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n                    params.append(\"db\");\n                }\n            }\n            String methodName = onCreate.getSimpleName().toString();\n            onCreateBuilder.addStatement(\"$T.$L($L)\", onCreate.getEnclosingElement(), methodName, params.toString());\n        }\n        return onCreateBuilder.build();\n    }\n\n    private MethodSpec getOnUpgradeSpec() {\n        MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder(\"onUpgrade\").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, \"db\").addParameter(int.class, \"oldVersion\").addParameter(int.class, \"newVersion\");\n        if (onUpgrade != null) {\n            List<? extends VariableElement> parameters = onUpgrade.getParameters();\n            StringBuilder params = new StringBuilder();\n            boolean first = true;\n            for (VariableElement param : parameters) {\n                if (first) {\n                    first = false;\n                } else {\n                    params.append(\", \");\n                }\n                TypeMirror paramType = param.asType();\n                if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {\n                    params.append(\"context\");\n                }\n                if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n                    params.append(\"db\");\n                }\n                if (TypeName.get(int.class).equals(TypeName.get(paramType))) {\n                    String name = param.getSimpleName().toString();\n                    if (\"oldVersion\".equals(name)) {\n                        params.append(\"oldVersion\");\n                    } else if (\"newVersion\".equals(name)) {\n                        params.append(\"newVersion\");\n                    } else {\n                        error(\"Unknown int parameter: \" + name);\n                    }\n                }\n            }\n            String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();\n            String methodName = onUpgrade.getSimpleName().toString();\n            onUpgradeBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n        }\n        return onUpgradeBuilder.build();\n    }\n\n    private MethodSpec getOnConfigureSpec() {\n        MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder(\"onConfigure\").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, \"db\");\n        List<? extends VariableElement> parameters = onConfigure.getParameters();\n        StringBuilder params = new StringBuilder();\n        boolean first = true;\n        for (VariableElement param : parameters) {\n            if (first) {\n                first = false;\n            } else {\n                params.append(\", \");\n            }\n            TypeMirror paramType = param.asType();\n            if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {\n                params.append(\"db\");\n            } else {\n                throw new IllegalArgumentException(\"OnConfigure does not support parameter \" + paramType.toString());\n            }\n        }\n        String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();\n        String methodName = onConfigure.getSimpleName().toString();\n        onConfigureBuilder.addStatement(\"$L.$L($L)\", parent, methodName, params.toString());\n        return onConfigureBuilder.build();\n    }\n\n    public void writeValues(Filer filer) throws IOException {\n        JavaFileObject jfo = filer.createSourceFile(getValuesFileName());\n        Writer out = jfo.openWriter();\n        final String valuesPackage = outPackage + \".values\";\n        TypeSpec.Builder spec = TypeSpec.classBuilder(className + \"Values\").addModifiers(Modifier.PUBLIC);\n        for (VariableElement table : tables) {\n            Table tableAnnotation = table.getAnnotation(Table.class);\n            String tableName = table.getConstantValue().toString();\n            tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);\n            String methodName = \"for\" + tableName;\n            String valuesName = tableName + \"ValuesBuilder\";\n            ClassName builderClass = ClassName.get(valuesPackage, valuesName);\n            MethodSpec builderSpec = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC).returns(builderClass).addStatement(\"return new $T()\", builderClass).build();\n            spec.addMethod(builderSpec);\n        }\n        JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();\n        javaFile.writeTo(out);\n        out.flush();\n        out.close();\n    }\n\n    private String getFileName() {\n        return outPackage + \".\" + className;\n    }\n\n    private String getValuesFileName() {\n        return outPackage + \".values.\" + className + \"Values\";\n    }\n\n    private void error(String error) {\n        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);\n    }\n}\n", "refactored": false}
{"hexsha": "411be56df51eee3c16dfe6b0f35455330e5f8f63", "ext": "java", "lang": "Java", "content": "public final class DnsUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);\n\n    /**\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\n     */\n    public static boolean anyInterfaceSupportsIpV6() {\n        try {\n            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            for (; interfaces.hasMoreElements(); ) {\n                final NetworkInterface iface = interfaces.nextElement();\n                final Enumeration<InetAddress> addresses = iface.getInetAddresses();\n                for (; addresses.hasMoreElements(); ) {\n                    final InetAddress inetAddress = addresses.nextElement();\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() && !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\n                        return true;\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\n        }\n        return false;\n    }\n\n    @Nullable\n    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {\n        final DnsRecordType type = record.type();\n        final ByteBuf content = ((ByteBufHolder) record).content();\n        final int contentLen = content.readableBytes();\n        // Skip invalid records.\n        if (type == DnsRecordType.A) {\n            if (contentLen != 4) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else if (type == DnsRecordType.AAAA) {\n            if (contentLen != 16) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else {\n            return null;\n        }\n        final byte[] addrBytes = new byte[contentLen];\n        content.getBytes(content.readerIndex(), addrBytes);\n        return addrBytes;\n    }\n\n    /**\n     * Logs a warning message about an invalid record.\n     */\n    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {\n        if (logger.isWarnEnabled()) {\n            final String dump = ByteBufUtil.hexDump(content);\n            logger.warn(\"{} Skipping invalid {} record: {}\", logPrefix, type.name(), dump.isEmpty() ? \"<empty>\" : dump);\n        }\n    }\n\n    private DnsUtil() {\n    }\n}\n", "class_id": 0, "repo": "georgecao/armeria", "file": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "last_update_at": "2021-12-22T01:14:48+00:00", "original_content": "public final class DnsUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);\n\n    /**\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\n     */\n    public static boolean anyInterfaceSupportsIpV6() {\n        try {\n            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                final NetworkInterface iface = interfaces.nextElement();\n                final Enumeration<InetAddress> addresses = iface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    final InetAddress inetAddress = addresses.nextElement();\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() && !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\n                        return true;\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\n        }\n        return false;\n    }\n\n    @Nullable\n    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {\n        final DnsRecordType type = record.type();\n        final ByteBuf content = ((ByteBufHolder) record).content();\n        final int contentLen = content.readableBytes();\n        // Skip invalid records.\n        if (type == DnsRecordType.A) {\n            if (contentLen != 4) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else if (type == DnsRecordType.AAAA) {\n            if (contentLen != 16) {\n                warnInvalidRecord(logger, logPrefix, type, content);\n                return null;\n            }\n        } else {\n            return null;\n        }\n        final byte[] addrBytes = new byte[contentLen];\n        content.getBytes(content.readerIndex(), addrBytes);\n        return addrBytes;\n    }\n\n    /**\n     * Logs a warning message about an invalid record.\n     */\n    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {\n        if (logger.isWarnEnabled()) {\n            final String dump = ByteBufUtil.hexDump(content);\n            logger.warn(\"{} Skipping invalid {} record: {}\", logPrefix, type.name(), dump.isEmpty() ? \"<empty>\" : dump);\n        }\n    }\n\n    private DnsUtil() {\n    }\n}\n", "refactored": true}
{"hexsha": "c56eafd18ce46221d394fe0d46db958c396d688c", "ext": "java", "lang": "Java", "content": "class LogicalFormatValidator extends AbstractDataValidator {\n\n    private static final Pattern booleanPattern = Pattern.compile(\"[YNTF ]\");\n\n    LogicalFormatValidator(final Field field) {\n        super(field);\n        assert field.getType() == Type.LOGICAL : \"Can only be validator for LOGICAL fields\";\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A\n     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not\n     * contain leading or trailing spaces.\n     */\n    public void validate(final Object typedObject) throws DbfLibException {\n        if (typedObject instanceof Boolean) {\n            return;\n        }\n        if (typedObject instanceof String) {\n            final String booleanString = (String) typedObject;\n            if (!booleanPattern.matcher(booleanString).matches()) {\n                throw new DataMismatchException(\"Boolean must be one of Y, N, T, F or a space\");\n            }\n            return;\n        }\n        throw new DataMismatchException(\"Cannot write objects of type '\" + typedObject.getClass().getName() + \"' to a LOGICAL field\");\n    }\n}\n", "class_id": 0, "repo": "Switajski/dans-dbf-lib", "file": "src/main/java/nl/knaw/dans/common/dbflib/LogicalFormatValidator.java", "last_update_at": "2021-05-25T13:50:19+00:00", "original_content": "class LogicalFormatValidator extends AbstractDataValidator {\n\n    private static final Pattern booleanPattern = Pattern.compile(\"[YNTF ]\");\n\n    LogicalFormatValidator(final Field field) {\n        super(field);\n        assert field.getType() == Type.LOGICAL : \"Can only be validator for LOGICAL fields\";\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A\n     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not\n     * contain leading or trailing spaces.\n     */\n    public void validate(final Object typedObject) throws DbfLibException {\n        if (typedObject instanceof Boolean) {\n            return;\n        }\n        if (typedObject instanceof String) {\n            final String booleanString = (String) typedObject;\n            if (!booleanPattern.matcher(booleanString).matches()) {\n                throw new DataMismatchException(\"Boolean must be one of Y, N, T, F or a space\");\n            }\n            return;\n        }\n        throw new DataMismatchException(\"Cannot write objects of type '\" + typedObject.getClass().getName() + \"' to a LOGICAL field\");\n    }\n}\n", "refactored": false}
{"hexsha": "8c883a23ce2238926cc5819852b763dc95f1d839", "ext": "java", "lang": "Java", "content": "public class NumFilter implements Filter {\n\n    @Override\n    public boolean doFilter(Msg msg) {\n        String msg1 = msg.getMsg();\n        String num = msg1.replace(\"123\", \"num\");\n        msg.setMsg(num);\n        return true;\n    }\n}\n", "class_id": 0, "repo": "zhaochaoyue1/Beyond", "file": "student/src/test/java/com/example/designPattern23/chainOfResponsibility/easyImpl/NumFilter.java", "last_update_at": "2021-09-20T20:51:51+00:00", "original_content": "public class NumFilter implements Filter {\n\n    @Override\n    public boolean doFilter(Msg msg) {\n        String msg1 = msg.getMsg();\n        String num = msg1.replace(\"123\", \"num\");\n        msg.setMsg(num);\n        return true;\n    }\n}\n", "refactored": false}
{"hexsha": "004f0b95f9d31afac73fdba3b9f2530353bc2072", "ext": "java", "lang": "Java", "content": "public class MessagesManager {\n\n    private Configuration freemarkerCfg = null;\n\n    @Inject\n    private ServletContext context;\n\n    @Inject\n    private AssetsManager assetsManager;\n\n    @Inject\n    private SherlockConfig config;\n\n    @PostConstruct\n    public void init() {\n        WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, \"WEB-INF/messages/\");\n        freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);\n        freemarkerCfg.setTemplateLoader(templateLoader);\n        freemarkerCfg.setDefaultEncoding(\"UTF-8\");\n        freemarkerCfg.setLocale(Locale.US);\n        freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n    }\n\n    public String message(String id) throws IOException, MessageException {\n        return message(id, ImmutableMap.of());\n    }\n\n    public String message(String id, Map<String, Object> context) throws IOException, MessageException {\n        if (!context.containsKey(\"random\")) {\n            ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\n            builder.putAll(context);\n            builder.put(\"tool\", new MessagesTool(assetsManager, config));\n            context = builder.build();\n        }\n        Template template = freemarkerCfg.getTemplate(id + \".ftl\");\n        StringWriter output = new StringWriter();\n        try {\n            template.process(context, output);\n        } catch (TemplateException e) {\n            throw new MessageException(\"Freemarker error\", e);\n        }\n        return output.toString();\n    }\n}\n", "class_id": 0, "repo": "actions-on-google-labs/sherlock-mysteries-java", "file": "sherlock-web/src/main/java/com/google/mystery/actions/messages/MessagesManager.java", "last_update_at": "2021-03-31T21:52:36+00:00", "original_content": "public class MessagesManager {\n\n    private Configuration freemarkerCfg = null;\n\n    @Inject\n    private ServletContext context;\n\n    @Inject\n    private AssetsManager assetsManager;\n\n    @Inject\n    private SherlockConfig config;\n\n    @PostConstruct\n    public void init() {\n        WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, \"WEB-INF/messages/\");\n        freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);\n        freemarkerCfg.setTemplateLoader(templateLoader);\n        freemarkerCfg.setDefaultEncoding(\"UTF-8\");\n        freemarkerCfg.setLocale(Locale.US);\n        freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n    }\n\n    public String message(String id) throws IOException, MessageException {\n        return message(id, ImmutableMap.of());\n    }\n\n    public String message(String id, Map<String, Object> context) throws IOException, MessageException {\n        if (!context.containsKey(\"random\")) {\n            ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\n            builder.putAll(context);\n            builder.put(\"tool\", new MessagesTool(assetsManager, config));\n            context = builder.build();\n        }\n        Template template = freemarkerCfg.getTemplate(id + \".ftl\");\n        StringWriter output = new StringWriter();\n        try {\n            template.process(context, output);\n        } catch (TemplateException e) {\n            throw new MessageException(\"Freemarker error\", e);\n        }\n        return output.toString();\n    }\n}\n", "refactored": false}
{"hexsha": "5e2fa117bef24890f7d8225ed48450f9a62751c1", "ext": "java", "lang": "Java", "content": "public class CompletionJavadoc extends Javadoc {\n\n    Expression completionNode;\n\n    public CompletionJavadoc(int sourceStart, int sourceEnd) {\n        super(sourceStart, sourceEnd);\n    }\n\n    /**\n     * @return Returns the completionNode.\n     */\n    public Expression getCompletionNode() {\n        return this.completionNode;\n    }\n\n    /**\n     * Resolve selected node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    private void internalResolve(Scope scope) {\n        if (this.completionNode != null) {\n            if (this.completionNode instanceof CompletionOnJavadocTag) {\n                ((CompletionOnJavadocTag) this.completionNode).filterPossibleTags(scope);\n            } else {\n                boolean resolve = true;\n                if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n                    resolve = ((CompletionOnJavadocParamNameReference) this.completionNode).token != null;\n                } else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n                    resolve = ((CompletionOnJavadocTypeParamReference) this.completionNode).token != null;\n                }\n                if (resolve) {\n                    switch(scope.kind) {\n                        case Scope.CLASS_SCOPE:\n                            this.completionNode.resolveType((ClassScope) scope);\n                            break;\n                        case Scope.METHOD_SCOPE:\n                            this.completionNode.resolveType((MethodScope) scope);\n                            break;\n                    }\n                }\n                if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n                    CompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;\n                    if (scope.kind == Scope.METHOD_SCOPE) {\n                        paramNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope) scope);\n                    }\n                    if (paramNameReference.token == null || paramNameReference.token.length == 0) {\n                        paramNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);\n                    }\n                } else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n                    CompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;\n                    typeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);\n                }\n            }\n            Binding qualifiedBinding = null;\n            if (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {\n                CompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;\n                if (typeRef.packageBinding == null) {\n                    qualifiedBinding = typeRef.resolvedType;\n                } else {\n                    qualifiedBinding = typeRef.packageBinding;\n                }\n            } else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {\n                CompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;\n                if (!msg.receiver.isThis())\n                    qualifiedBinding = msg.receiver.resolvedType;\n            } else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {\n                CompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;\n                qualifiedBinding = alloc.type.resolvedType;\n            }\n            throw new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);\n        }\n    }\n\n    /*\n\t * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)\n\t */\n    public StringBuffer print(int indent, StringBuffer output) {\n        //$NON-NLS-1$\n        printIndent(indent, output).append(\"/**\\n\");\n        boolean nodePrinted = false;\n        if (this.paramReferences != null) {\n            int i = 0, length = this.paramReferences.length;\n            while (i < length) try {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @param \");\n                this.paramReferences[i].print(indent, output).append('\\n');\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.paramReferences[i];\n                }\n            } finally {\n                i++;\n            }\n        }\n        if (this.paramTypeParameters != null) {\n            int i = 0, length = this.paramTypeParameters.length;\n            while (i < length) try {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @param <\");\n                //$NON-NLS-1$\n                this.paramTypeParameters[i].print(indent, output).append(\">\\n\");\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.paramTypeParameters[i];\n                }\n            } finally {\n                i++;\n            }\n        }\n        if (this.returnStatement != null) {\n            //$NON-NLS-1$\n            printIndent(indent, output).append(\" * @\");\n            this.returnStatement.print(indent, output).append('\\n');\n        }\n        if (this.exceptionReferences != null) {\n            int i = 0, length = this.exceptionReferences.length;\n            while (i < length) try {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @throws \");\n                this.exceptionReferences[i].print(indent, output).append('\\n');\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.exceptionReferences[i];\n                }\n            } finally {\n                i++;\n            }\n        }\n        if (this.seeReferences != null) {\n            int i = 0, length = this.seeReferences.length;\n            while (i < length) try {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @see \");\n                this.seeReferences[i].print(indent, output).append('\\n');\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.seeReferences[i];\n                }\n            } finally {\n                i++;\n            }\n        }\n        if (!nodePrinted && this.completionNode != null) {\n            //$NON-NLS-1$\n            printIndent(indent, output).append(\" * \");\n            this.completionNode.print(indent, output).append('\\n');\n        }\n        //$NON-NLS-1$\n        printIndent(indent, output).append(\" */\\n\");\n        return output;\n    }\n\n    /**\n     * Resolve completion node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    public void resolve(ClassScope scope) {\n        super.resolve(scope);\n        internalResolve(scope);\n    }\n\n    /**\n     * Resolve completion node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    public void resolve(CompilationUnitScope scope) {\n        internalResolve(scope);\n    }\n\n    /**\n     * Resolve completion node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    public void resolve(MethodScope scope) {\n        super.resolve(scope);\n        internalResolve(scope);\n    }\n\n    /*\n\t * Look for missing method @param tags\n\t */\n    private char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {\n        // Verify if there's some possible param tag\n        AbstractMethodDeclaration md = methScope.referenceMethod();\n        int paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;\n        if (md == null)\n            return null;\n        int argumentsSize = md.arguments == null ? 0 : md.arguments.length;\n        if (argumentsSize == 0)\n            return null;\n        // Store all method arguments if there's no @param in javadoc\n        if (paramTagsSize == 0) {\n            char[][] missingParams = new char[argumentsSize][];\n            int i = 0;\n            while (i < argumentsSize) try {\n                missingParams[i] = md.arguments[i].name;\n            } finally {\n                i++;\n            }\n            return missingParams;\n        }\n        // Look for missing arguments\n        char[][] missingParams = new char[argumentsSize][];\n        int size = 0;\n        int i = 0;\n        while (i < argumentsSize) try {\n            Argument arg = md.arguments[i];\n            boolean found = false;\n            int paramNameRefCount = 0;\n            int j = 0;\n            while (j < paramTagsSize && !found) try {\n                JavadocSingleNameReference param = this.paramReferences[j];\n                if (arg.binding == param.binding) {\n                    if (param.binding == paramNameRefBinding) {\n                        // do not count first occurence of param name reference\n                        paramNameRefCount++;\n                        found = paramNameRefCount > 1;\n                    } else {\n                        found = true;\n                    }\n                }\n            } finally {\n                j++;\n            }\n            if (!found) {\n                missingParams[size++] = arg.name;\n            }\n        } finally {\n            i++;\n        }\n        if (size > 0) {\n            if (size != argumentsSize) {\n                System.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n            }\n            return missingParams;\n        }\n        return null;\n    }\n\n    /*\n\t * Look for missing type parameters @param tags\n\t */\n    private char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {\n        int paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;\n        // Verify if there's any type parameter to tag\n        TypeParameter[] parameters = null;\n        TypeVariableBinding[] typeVariables = null;\n        switch(scope.kind) {\n            case Scope.METHOD_SCOPE:\n                AbstractMethodDeclaration methodDeclaration = ((MethodScope) scope).referenceMethod();\n                if (methodDeclaration == null)\n                    return null;\n                parameters = methodDeclaration.typeParameters();\n                typeVariables = methodDeclaration.binding.typeVariables;\n                break;\n            case Scope.CLASS_SCOPE:\n                TypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;\n                parameters = typeDeclaration.typeParameters;\n                typeVariables = typeDeclaration.binding.typeVariables;\n                break;\n        }\n        if (typeVariables == null || typeVariables.length == 0)\n            return null;\n        // Store all type parameters if there's no @param in javadoc\n        if (parameters != null) {\n            int typeParametersLength = parameters.length;\n            if (paramTypeParamLength == 0) {\n                char[][] missingParams = new char[typeParametersLength][];\n                int i = 0;\n                while (i < typeParametersLength) try {\n                    missingParams[i] = parameters[i].name;\n                } finally {\n                    i++;\n                }\n                return missingParams;\n            }\n            // Look for missing type parameter\n            char[][] missingParams = new char[typeParametersLength][];\n            int size = 0;\n            int i = 0;\n            while (i < typeParametersLength) try {\n                TypeParameter parameter = parameters[i];\n                boolean found = false;\n                int paramNameRefCount = 0;\n                int j = 0;\n                while (j < paramTypeParamLength && !found) try {\n                    if (parameter.binding == this.paramTypeParameters[j].resolvedType) {\n                        if (parameter.binding == paramNameRefBinding) {\n                            // do not count first occurence of param nmae reference\n                            paramNameRefCount++;\n                            found = paramNameRefCount > 1;\n                        } else {\n                            found = true;\n                        }\n                    }\n                } finally {\n                    j++;\n                }\n                if (!found) {\n                    missingParams[size++] = parameter.name;\n                }\n            } finally {\n                i++;\n            }\n            if (size > 0) {\n                if (size != typeParametersLength) {\n                    System.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n                }\n                return missingParams;\n            }\n        }\n        return null;\n    }\n}\n", "class_id": 0, "repo": "TheRakeshPurohit/CodingSpectator", "file": "plug-ins/indigo/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionJavadoc.java", "last_update_at": "2021-05-11T06:56:51+00:00", "original_content": "public class CompletionJavadoc extends Javadoc {\n\n    Expression completionNode;\n\n    public CompletionJavadoc(int sourceStart, int sourceEnd) {\n        super(sourceStart, sourceEnd);\n    }\n\n    /**\n     * @return Returns the completionNode.\n     */\n    public Expression getCompletionNode() {\n        return this.completionNode;\n    }\n\n    /**\n     * Resolve selected node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    private void internalResolve(Scope scope) {\n        if (this.completionNode != null) {\n            if (this.completionNode instanceof CompletionOnJavadocTag) {\n                ((CompletionOnJavadocTag) this.completionNode).filterPossibleTags(scope);\n            } else {\n                boolean resolve = true;\n                if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n                    resolve = ((CompletionOnJavadocParamNameReference) this.completionNode).token != null;\n                } else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n                    resolve = ((CompletionOnJavadocTypeParamReference) this.completionNode).token != null;\n                }\n                if (resolve) {\n                    switch(scope.kind) {\n                        case Scope.CLASS_SCOPE:\n                            this.completionNode.resolveType((ClassScope) scope);\n                            break;\n                        case Scope.METHOD_SCOPE:\n                            this.completionNode.resolveType((MethodScope) scope);\n                            break;\n                    }\n                }\n                if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {\n                    CompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;\n                    if (scope.kind == Scope.METHOD_SCOPE) {\n                        paramNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope) scope);\n                    }\n                    if (paramNameReference.token == null || paramNameReference.token.length == 0) {\n                        paramNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);\n                    }\n                } else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {\n                    CompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;\n                    typeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);\n                }\n            }\n            Binding qualifiedBinding = null;\n            if (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {\n                CompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;\n                if (typeRef.packageBinding == null) {\n                    qualifiedBinding = typeRef.resolvedType;\n                } else {\n                    qualifiedBinding = typeRef.packageBinding;\n                }\n            } else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {\n                CompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;\n                if (!msg.receiver.isThis())\n                    qualifiedBinding = msg.receiver.resolvedType;\n            } else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {\n                CompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;\n                qualifiedBinding = alloc.type.resolvedType;\n            }\n            throw new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);\n        }\n    }\n\n    /*\n\t * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)\n\t */\n    public StringBuffer print(int indent, StringBuffer output) {\n        //$NON-NLS-1$\n        printIndent(indent, output).append(\"/**\\n\");\n        boolean nodePrinted = false;\n        if (this.paramReferences != null) {\n            for (int i = 0, length = this.paramReferences.length; i < length; i++) {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @param \");\n                this.paramReferences[i].print(indent, output).append('\\n');\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.paramReferences[i];\n                }\n            }\n        }\n        if (this.paramTypeParameters != null) {\n            for (int i = 0, length = this.paramTypeParameters.length; i < length; i++) {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @param <\");\n                //$NON-NLS-1$\n                this.paramTypeParameters[i].print(indent, output).append(\">\\n\");\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.paramTypeParameters[i];\n                }\n            }\n        }\n        if (this.returnStatement != null) {\n            //$NON-NLS-1$\n            printIndent(indent, output).append(\" * @\");\n            this.returnStatement.print(indent, output).append('\\n');\n        }\n        if (this.exceptionReferences != null) {\n            for (int i = 0, length = this.exceptionReferences.length; i < length; i++) {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @throws \");\n                this.exceptionReferences[i].print(indent, output).append('\\n');\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.exceptionReferences[i];\n                }\n            }\n        }\n        if (this.seeReferences != null) {\n            for (int i = 0, length = this.seeReferences.length; i < length; i++) {\n                //$NON-NLS-1$\n                printIndent(indent, output).append(\" * @see \");\n                this.seeReferences[i].print(indent, output).append('\\n');\n                if (!nodePrinted && this.completionNode != null) {\n                    nodePrinted = this.completionNode == this.seeReferences[i];\n                }\n            }\n        }\n        if (!nodePrinted && this.completionNode != null) {\n            //$NON-NLS-1$\n            printIndent(indent, output).append(\" * \");\n            this.completionNode.print(indent, output).append('\\n');\n        }\n        //$NON-NLS-1$\n        printIndent(indent, output).append(\" */\\n\");\n        return output;\n    }\n\n    /**\n     * Resolve completion node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    public void resolve(ClassScope scope) {\n        super.resolve(scope);\n        internalResolve(scope);\n    }\n\n    /**\n     * Resolve completion node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    public void resolve(CompilationUnitScope scope) {\n        internalResolve(scope);\n    }\n\n    /**\n     * Resolve completion node if not null and throw exception to let clients know\n     * that it has been found.\n     *\n     * @throws CompletionNodeFound\n     */\n    public void resolve(MethodScope scope) {\n        super.resolve(scope);\n        internalResolve(scope);\n    }\n\n    /*\n\t * Look for missing method @param tags\n\t */\n    private char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {\n        // Verify if there's some possible param tag\n        AbstractMethodDeclaration md = methScope.referenceMethod();\n        int paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;\n        if (md == null)\n            return null;\n        int argumentsSize = md.arguments == null ? 0 : md.arguments.length;\n        if (argumentsSize == 0)\n            return null;\n        // Store all method arguments if there's no @param in javadoc\n        if (paramTagsSize == 0) {\n            char[][] missingParams = new char[argumentsSize][];\n            for (int i = 0; i < argumentsSize; i++) {\n                missingParams[i] = md.arguments[i].name;\n            }\n            return missingParams;\n        }\n        // Look for missing arguments\n        char[][] missingParams = new char[argumentsSize][];\n        int size = 0;\n        for (int i = 0; i < argumentsSize; i++) {\n            Argument arg = md.arguments[i];\n            boolean found = false;\n            int paramNameRefCount = 0;\n            for (int j = 0; j < paramTagsSize && !found; j++) {\n                JavadocSingleNameReference param = this.paramReferences[j];\n                if (arg.binding == param.binding) {\n                    if (param.binding == paramNameRefBinding) {\n                        // do not count first occurence of param name reference\n                        paramNameRefCount++;\n                        found = paramNameRefCount > 1;\n                    } else {\n                        found = true;\n                    }\n                }\n            }\n            if (!found) {\n                missingParams[size++] = arg.name;\n            }\n        }\n        if (size > 0) {\n            if (size != argumentsSize) {\n                System.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n            }\n            return missingParams;\n        }\n        return null;\n    }\n\n    /*\n\t * Look for missing type parameters @param tags\n\t */\n    private char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {\n        int paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;\n        // Verify if there's any type parameter to tag\n        TypeParameter[] parameters = null;\n        TypeVariableBinding[] typeVariables = null;\n        switch(scope.kind) {\n            case Scope.METHOD_SCOPE:\n                AbstractMethodDeclaration methodDeclaration = ((MethodScope) scope).referenceMethod();\n                if (methodDeclaration == null)\n                    return null;\n                parameters = methodDeclaration.typeParameters();\n                typeVariables = methodDeclaration.binding.typeVariables;\n                break;\n            case Scope.CLASS_SCOPE:\n                TypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;\n                parameters = typeDeclaration.typeParameters;\n                typeVariables = typeDeclaration.binding.typeVariables;\n                break;\n        }\n        if (typeVariables == null || typeVariables.length == 0)\n            return null;\n        // Store all type parameters if there's no @param in javadoc\n        if (parameters != null) {\n            int typeParametersLength = parameters.length;\n            if (paramTypeParamLength == 0) {\n                char[][] missingParams = new char[typeParametersLength][];\n                for (int i = 0; i < typeParametersLength; i++) {\n                    missingParams[i] = parameters[i].name;\n                }\n                return missingParams;\n            }\n            // Look for missing type parameter\n            char[][] missingParams = new char[typeParametersLength][];\n            int size = 0;\n            for (int i = 0; i < typeParametersLength; i++) {\n                TypeParameter parameter = parameters[i];\n                boolean found = false;\n                int paramNameRefCount = 0;\n                for (int j = 0; j < paramTypeParamLength && !found; j++) {\n                    if (parameter.binding == this.paramTypeParameters[j].resolvedType) {\n                        if (parameter.binding == paramNameRefBinding) {\n                            // do not count first occurence of param nmae reference\n                            paramNameRefCount++;\n                            found = paramNameRefCount > 1;\n                        } else {\n                            found = true;\n                        }\n                    }\n                }\n                if (!found) {\n                    missingParams[size++] = parameter.name;\n                }\n            }\n            if (size > 0) {\n                if (size != typeParametersLength) {\n                    System.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);\n                }\n                return missingParams;\n            }\n        }\n        return null;\n    }\n}\n", "refactored": true}
{"hexsha": "b340f2fb457ab4721fc8027ede739eb8fda262c5", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class CertificateTypeServiceImpl implements CertificateTypeService {\n\n    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);\n\n    private final CertificateTypeRepository certificateTypeRepository;\n\n    private final CertificateTypeMapper certificateTypeMapper;\n\n    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {\n        this.certificateTypeRepository = certificateTypeRepository;\n        this.certificateTypeMapper = certificateTypeMapper;\n    }\n\n    /**\n     * Save a certificateType.\n     *\n     * @param certificateTypeDTO the entity to save.\n     * @return the persisted entity.\n     */\n    @Override\n    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {\n        log.debug(\"Request to save CertificateType : {}\", certificateTypeDTO);\n        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);\n        certificateType = certificateTypeRepository.save(certificateType);\n        return certificateTypeMapper.toDto(certificateType);\n    }\n\n    /**\n     * Get all the certificateTypes.\n     *\n     * @return the list of entities.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public List<CertificateTypeDTO> findAll() {\n        log.debug(\"Request to get all CertificateTypes\");\n        return certificateTypeRepository.findAll().stream().map(certificateTypeMapper::toDto).collect(Collectors.toCollection(LinkedList::new));\n    }\n\n    /**\n     * Get one certificateType by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public Optional<CertificateTypeDTO> findOne(Long id) {\n        log.debug(\"Request to get CertificateType : {}\", id);\n        return certificateTypeRepository.findById(id).map(certificateTypeMapper::toDto);\n    }\n\n    /**\n     * Delete the certificateType by id.\n     *\n     * @param id the id of the entity.\n     */\n    @Override\n    public void delete(Long id) {\n        log.debug(\"Request to delete CertificateType : {}\", id);\n        certificateTypeRepository.deleteById(id);\n    }\n}\n", "class_id": 0, "repo": "boutainaLemrabet/jhipster-composite-key-server-blueprint", "file": "test/samples/composite-key-blueprint/src/main/java/com/mycompany/myapp/service/impl/CertificateTypeServiceImpl.java", "last_update_at": "2021-09-15T07:41:05+00:00", "original_content": "@Service\n@Transactional\npublic class CertificateTypeServiceImpl implements CertificateTypeService {\n\n    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);\n\n    private final CertificateTypeRepository certificateTypeRepository;\n\n    private final CertificateTypeMapper certificateTypeMapper;\n\n    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {\n        this.certificateTypeRepository = certificateTypeRepository;\n        this.certificateTypeMapper = certificateTypeMapper;\n    }\n\n    /**\n     * Save a certificateType.\n     *\n     * @param certificateTypeDTO the entity to save.\n     * @return the persisted entity.\n     */\n    @Override\n    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {\n        log.debug(\"Request to save CertificateType : {}\", certificateTypeDTO);\n        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);\n        certificateType = certificateTypeRepository.save(certificateType);\n        return certificateTypeMapper.toDto(certificateType);\n    }\n\n    /**\n     * Get all the certificateTypes.\n     *\n     * @return the list of entities.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public List<CertificateTypeDTO> findAll() {\n        log.debug(\"Request to get all CertificateTypes\");\n        return certificateTypeRepository.findAll().stream().map(certificateTypeMapper::toDto).collect(Collectors.toCollection(LinkedList::new));\n    }\n\n    /**\n     * Get one certificateType by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Override\n    @Transactional(readOnly = true)\n    public Optional<CertificateTypeDTO> findOne(Long id) {\n        log.debug(\"Request to get CertificateType : {}\", id);\n        return certificateTypeRepository.findById(id).map(certificateTypeMapper::toDto);\n    }\n\n    /**\n     * Delete the certificateType by id.\n     *\n     * @param id the id of the entity.\n     */\n    @Override\n    public void delete(Long id) {\n        log.debug(\"Request to delete CertificateType : {}\", id);\n        certificateTypeRepository.deleteById(id);\n    }\n}\n", "refactored": false}
{"hexsha": "66221d0b3719371c37d84e20dc260cfa0cb7971a", "ext": "java", "lang": "Java", "content": "public class ClientServiceImplTest extends AbstractSpringTests {\n\n    @Autowired\n    private ClientService clientService;\n\n    public ClientServiceImplTest() {\n        super(true);\n    }\n\n    @Test\n    public void testCreate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"ABC\").setShortName(//\n        \"abc\").//\n        setContactName(//\n        \"Abc Def\").setEmail(//\n        \"abc@example.com\").//\n        setAddress(//\n        \"555 Betancour\").//\n        setTel(//\n        \"555-202-0101\").//\n        setMainSite(//\n        \"http://abc.here.com\").setLang(\"EN\").setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testCreate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"ABC\").setShortName(//\n        \"abc\").//\n        setContactName(//\n        \"Abc Def\").setEmail(//\n        \"abc@example.com\").//\n        setAddress(//\n        \"555 Betancour\").//\n        setTel(//\n        \"555-202-0101\").//\n        setMainSite(//\n        \"http://abc.here.com\").setLang(\"EN\").setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testCreate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testCreate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"ABC\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA).//\n        setContactName(//\n        \"Abc Def\").setEmail(//\n        \"abc@example.com\").//\n        setAddress(//\n        \"555 Betancour\").//\n        setTel(//\n        \"555-202-0101\").//\n        setMainSite(//\n        \"http://abc.here.com\").setLang(\"EN\").setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testDelete_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        expectNotAdmin(() -> {\n            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testDelete_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testDelete_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testListAll_notAdmin_FAIL() {\n        expectNotAdmin(() -> {\n            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);\n        });\n    }\n\n    @Test\n    public void testListAll_OK() {\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-testListAll_OK.json\", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));\n    }\n\n    @Test\n    public void testUpdate_noChange_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"Bazar\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).//\n        setContactName(//\n        \"Benoit Bezos\").setEmail(//\n        \"benoit@example.com\").//\n        setAddress(//\n        \"1010 Betancour\").//\n        setTel(//\n        \"555-101-0101\").//\n        setMainSite(//\n        \"http://bazar.example.com\").setLang(\"FR\").setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"Bazar Yay\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).//\n        setContactName(//\n        \"Benoit Banana\").setEmail(//\n        \"benoit@example2.com\").//\n        setAddress(//\n        \"1020 Betancour\").//\n        setTel(//\n        \"555-202-0101\").//\n        setMainSite(//\n        \"http://bazar.here.com\").setLang(\"EN\").setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"Bazar Yay\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).//\n        setContactName(//\n        \"Benoit Banana\").setEmail(//\n        \"benoit@example2.com\").//\n        setAddress(//\n        \"1020 Betancour\").//\n        setTel(//\n        \"555-202-0101\").//\n        setMainSite(//\n        \"http://bazar.here.com\").setLang(\"EN\").setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"Bazar\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA).//\n        setContactName(//\n        \"Benoit Bezos\").setEmail(//\n        \"benoit@example.com\").//\n        setAddress(//\n        \"1010 Betancour\").//\n        setTel(//\n        \"555-101-0101\").//\n        setMainSite(//\n        \"http://bazar.example.com\").setLang(\"FR\").setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_shortName_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        //\n        CreateOrUpdateClientForm //\n        //\n        form = //\n        new CreateOrUpdateClientForm().//\n        setName(//\n        \"Bazar\").setShortName(//\n        \"bbb\").//\n        setContactName(//\n        \"Benoit Bezos\").setEmail(//\n        \"benoit@example.com\").//\n        setAddress(//\n        \"1010 Betancour\").//\n        setTel(//\n        \"555-101-0101\").//\n        setMainSite(//\n        \"http://bazar.example.com\").setLang(\"FR\").setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_shortName_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n}\n", "class_id": 0, "repo": "foilen/foilen-crm", "file": "src/test/java/com/foilen/crm/services/ClientServiceImplTest.java", "last_update_at": "2021-02-23T13:22:53+00:00", "original_content": "public class ClientServiceImplTest extends AbstractSpringTests {\n\n    @Autowired\n    private ClientService clientService;\n\n    public ClientServiceImplTest() {\n        super(true);\n    }\n\n    @Test\n    public void testCreate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"ABC\").setShortName(//\n        \"abc\").setContactName(\"Abc Def\").setEmail(//\n        \"abc@example.com\").setAddress(\"555 Betancour\").setTel(//\n        \"555-202-0101\").setMainSite(//\n        \"http://abc.here.com\").setLang(//\n        \"EN\").setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testCreate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"ABC\").setShortName(//\n        \"abc\").setContactName(\"Abc Def\").setEmail(//\n        \"abc@example.com\").setAddress(\"555 Betancour\").setTel(//\n        \"555-202-0101\").setMainSite(//\n        \"http://abc.here.com\").setLang(//\n        \"EN\").setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testCreate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testCreate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"ABC\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA).setContactName(\"Abc Def\").setEmail(//\n        \"abc@example.com\").setAddress(\"555 Betancour\").setTel(//\n        \"555-202-0101\").setMainSite(//\n        \"http://abc.here.com\").setLang(//\n        \"EN\").setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testDelete_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        expectNotAdmin(() -> {\n            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testDelete_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testDelete_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testListAll_notAdmin_FAIL() {\n        expectNotAdmin(() -> {\n            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);\n        });\n    }\n\n    @Test\n    public void testListAll_OK() {\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-testListAll_OK.json\", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));\n    }\n\n    @Test\n    public void testUpdate_noChange_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"Bazar\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).setContactName(\"Benoit Bezos\").setEmail(//\n        \"benoit@example.com\").setAddress(\"1010 Betancour\").setTel(//\n        \"555-101-0101\").setMainSite(//\n        \"http://bazar.example.com\").setLang(//\n        \"FR\").setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_notAdmin_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"Bazar Yay\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).setContactName(\"Benoit Banana\").setEmail(//\n        \"benoit@example2.com\").setAddress(\"1020 Betancour\").setTel(//\n        \"555-202-0101\").setMainSite(//\n        \"http://bazar.here.com\").setLang(//\n        \"EN\").setTechnicalSupportSid(\"S2\");\n        expectNotAdmin(() -> {\n            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        });\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"Bazar Yay\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).setContactName(\"Benoit Banana\").setEmail(//\n        \"benoit@example2.com\").setAddress(\"1020 Betancour\").setTel(//\n        \"555-202-0101\").setMainSite(//\n        \"http://bazar.here.com\").setLang(//\n        \"EN\").setTechnicalSupportSid(\"S2\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_shortName_exists_FAIL() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"Bazar\").setShortName(//\n        FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA).setContactName(\"Benoit Bezos\").setEmail(//\n        \"benoit@example.com\").setAddress(\"1010 Betancour\").setTel(//\n        \"555-101-0101\").setMainSite(//\n        \"http://bazar.example.com\").setLang(//\n        \"FR\").setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"ClientServiceImplTest-shortName_exists_FAIL-FormResult.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n\n    @Test\n    public void testUpdate_shortName_OK() {\n        List<?> initialClients = trimClient(clientDao.findAll(Sort.by(\"shortName\")));\n        CreateOrUpdateClientForm form = //\n        new CreateOrUpdateClientForm().setName(//\n        \"Bazar\").setShortName(//\n        \"bbb\").setContactName(\"Benoit Bezos\").setEmail(//\n        \"benoit@example.com\").setAddress(\"1010 Betancour\").setTel(//\n        \"555-101-0101\").setMainSite(//\n        \"http://bazar.example.com\").setLang(//\n        \"FR\").setTechnicalSupportSid(\"S1\");\n        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);\n        AssertTools.assertJsonComparisonWithoutNulls(\"FormResult-success.json\", getClass(), result);\n        AssertTools.assertDiffJsonComparison(\"ClientServiceImplTest-testUpdate_shortName_OK-clients.json\", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by(\"shortName\"))));\n    }\n}\n", "refactored": false}
{"hexsha": "201d81bb57bfceee81740093f870c685ab999062", "ext": "java", "lang": "Java", "content": "class Solution1 {\n\n    private int[][] dx_dy = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\n\n    private void dfs(int[][] image, int i, int j) {\n        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != oldColor)\n            return;\n        image[i][j] = newColor;\n        for (int[] offset : dx_dy) {\n            dfs(image, i + offset[0], j + offset[1]);\n        }\n    }\n\n    private int oldColor = 0, newColor = 0;\n\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        this.oldColor = image[sr][sc];\n        this.newColor = newColor;\n        if (this.oldColor == this.newColor)\n            return image;\n        dfs(image, sr, sc);\n        return image;\n    }\n\n    private static void test(int[][] image, int sr, int sc, int newColor) {\n        Solution1 solution = new Solution1();\n        int[][] ans = solution.floodFill(image, sr, sc, newColor);\n        for (int[] ints : ans) {\n            for (int i : ints) {\n                System.out.print(i + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        test(new int[][] { { 0, 0, 0 }, { 0, 1, 1 } }, 1, 1, 1);\n        test(new int[][] { { 1, 1, 1 }, { 1, 1, 0 }, { 1, 0, 1 } }, 1, 1, 2);\n    }\n}\n", "class_id": 0, "repo": "ooooo-youwillsee/leetcode", "file": "lcci_08_10/java_08_10/src/com/ooooo/Solution1.java", "last_update_at": "2021-12-19T02:24:33+00:00", "original_content": "class Solution1 {\n\n    private int[][] dx_dy = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\n\n    private void dfs(int[][] image, int i, int j) {\n        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != oldColor)\n            return;\n        image[i][j] = newColor;\n        for (int[] offset : dx_dy) {\n            dfs(image, i + offset[0], j + offset[1]);\n        }\n    }\n\n    private int oldColor = 0, newColor = 0;\n\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        this.oldColor = image[sr][sc];\n        this.newColor = newColor;\n        if (this.oldColor == this.newColor)\n            return image;\n        dfs(image, sr, sc);\n        return image;\n    }\n\n    private static void test(int[][] image, int sr, int sc, int newColor) {\n        Solution1 solution = new Solution1();\n        int[][] ans = solution.floodFill(image, sr, sc, newColor);\n        for (int[] ints : ans) {\n            for (int i : ints) {\n                System.out.print(i + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        test(new int[][] { { 0, 0, 0 }, { 0, 1, 1 } }, 1, 1, 1);\n        test(new int[][] { { 1, 1, 1 }, { 1, 1, 0 }, { 1, 0, 1 } }, 1, 1, 2);\n    }\n}\n", "refactored": false}
{"hexsha": "5e28482a90909ff8a582c684e353d5dcc0a58b48", "ext": "java", "lang": "Java", "content": "@EqualsAndHashCode(of = { \"annotatedObject\", \"descriptor\", \"clientId\" })\nclass /* package */\nAnnotatedModelInterceptor implements IModelInterceptor {\n\n    private static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);\n\n    private final AnnotatedModelInterceptorDescriptor descriptor;\n\n    private final transient Object annotatedObject;\n\n    private ClientId clientId;\n\n    /**\n     * @param annotatedObject\n     */\n    AnnotatedModelInterceptor(@NonNull final Object annotatedObject) {\n        this.annotatedObject = annotatedObject;\n        this.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass()).build();\n    }\n\n    @Override\n    public String toString() {\n        return \"annotated[\" + annotatedObject.getClass().getName() + \"]\";\n    }\n\n    /**\n     * @return true if it has no initializers, no pointcuts, no nothing\n     */\n    public boolean isEmpty() {\n        return descriptor.isEmpty();\n    }\n\n    @Override\n    public void initialize(final IModelValidationEngine engine, final I_AD_Client client) {\n        if (client != null) {\n            this.clientId = ClientId.ofRepoId(client.getAD_Client_ID());\n        }\n        bindPointcuts(engine);\n        // Execute initializers\n        for (final InterceptorInit init : descriptor.getInitializers()) {\n            Object[] params = new Object[] {};\n            if (init.isMethodRequiresEngine()) {\n                params = new Object[] { engine };\n            }\n            final Method method = init.getMethod();\n            try {\n                // Make sure the method is accessible\n                if (!method.isAccessible()) {\n                    method.setAccessible(true);\n                }\n                // Execute\n                method.invoke(annotatedObject, params);\n            } catch (Exception e) {\n                throw new AdempiereException(\"Cannot initialize \" + annotatedObject + \". Initializer \" + init + \" failed.\" + \"\\n Method: \" + method + \"\\n Params:\" + Arrays.toString(params) + \"\\n Method Descriptor: \" + init, Throwables.getRootCause(e));\n            }\n            logger.debug(\"Initializer {} executed successfully.\", init);\n        }\n    }\n\n    private void bindPointcuts(@NonNull final IModelValidationEngine engine) {\n        logger.debug(\"Binding pointcuts for {}\", annotatedObject);\n        for (final PointcutKey key : descriptor.getPointcutKeys()) {\n            final Set<Pointcut> list = descriptor.getPointcuts(key);\n            if (list.isEmpty()) {\n                continue;\n            }\n            logger.debug(\"Binding pointcuts for {} on {}\", annotatedObject, key);\n            switch(key.getType()) {\n                case ModelChange:\n                    engine.addModelChange(key.getTableName(), this);\n                    break;\n                case DocValidate:\n                    engine.addDocValidate(key.getTableName(), this);\n                    break;\n                default:\n                    throw new AdempiereException(\"Unknown PointcutType \" + key.getType());\n            }\n        }\n        logger.debug(\"Binding pointcuts for {} done.\", annotatedObject);\n    }\n\n    @Override\n    public int getAD_Client_ID() {\n        return ClientId.toRepoId(clientId);\n    }\n\n    @Override\n    public void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID) {\n    }\n\n    @Override\n    public final void onModelChange(final Object model, final ModelChangeType changeType) {\n        execute(PointcutType.ModelChange, model, changeType.toInt());\n    }\n\n    @Override\n    public final void onDocValidate(final Object model, final DocTimingType timing) {\n        execute(PointcutType.DocValidate, model, timing.toInt());\n    }\n\n    private void execute(final PointcutType type, final Object po, final int timing) {\n        final String tableName = InterfaceWrapperHelper.getModelTableName(po);\n        final PointcutKey key = PointcutKey.of(tableName, type);\n        final ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);\n        if (pointcuts.isEmpty()) {\n            return;\n        }\n        for (final Pointcut pointcut : pointcuts) {\n            execute(pointcut, po, timing);\n        }\n    }\n\n    private void execute(final Pointcut pointcut, final Object po, final int timing) {\n        // Check timings\n        final Set<Integer> timings = pointcut.getTimings();\n        if (!timings.contains(timing)) {\n            return;\n        }\n        // Check if UserAction required (i.e. user manually changed this record from a window)\n        if (pointcut.isOnlyIfUIAction()) {\n            final boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);\n            if (!isUIAction) {\n                return;\n            }\n        }\n        // Check if we shall skip when copying\n        if (pointcut.isSkipIfCopying()) {\n            final boolean isCopying = InterfaceWrapperHelper.isCopy(po);\n            if (isCopying) {\n                return;\n            }\n        }\n        // Else, does not make sense.\n        if (isTimingChange(timing)) {\n            final Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();\n            if (!columnsToCheckForChanges.isEmpty()) {\n                // none of our columns had changed; skip\n                if (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges)) {\n                    return;\n                }\n            }\n        }\n        // Execute the method now\n        if (!pointcut.isAfterCommit()) {\n            executeNow(po, pointcut, timing);\n        } else {\n            logger.trace(\"Scheduling to be executed after commit: {}\", pointcut);\n            final String trxName = InterfaceWrapperHelper.getTrxName(po);\n            Services.get(ITrxManager.class).getTrxListenerManagerOrAutoCommit(trxName).newEventListener(TrxEventTiming.AFTER_COMMIT).additionalToStringInfo(() -> MoreObjects.toStringHelper(this).add(\"pointcut\", pointcut).add(\"po\", po).add(\"timing\", timing).toString()).invokeMethodJustOnce(true).registerHandlingMethod(transaction -> {\n                executeNow(po, pointcut, timing);\n                InterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    private final void executeNow(@NonNull final Object po, @NonNull final Pointcut pointcut, final int timing) {\n        if (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut)) {\n            logger.info(\"Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}\", AnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);\n            return;\n        }\n        final Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());\n        try {\n            executeNow0(model, pointcut, timing);\n        } catch (final Exception e) {\n            final AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);\n            throw adempiereException;\n        }\n    }\n\n    private static AdempiereException appendAndLogHowtoDisableMessage(@NonNull final Exception e, @NonNull final Pointcut pointcut) {\n        final String parameterName = \"HowtoDisableModelInterceptor\";\n        final AdempiereException ae = AdempiereException.wrapIfNeeded(e);\n        if (!ae.hasParameter(parameterName)) {\n            final String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);\n            logger.error(howtoDisableMsg);\n            ae.setParameter(parameterName, howtoDisableMsg);\n        }\n        return ae;\n    }\n\n    private void executeNow0(@NonNull final Object model, @NonNull final Pointcut pointcut, final int timing) throws IllegalAccessException, InvocationTargetException {\n        final Method method = pointcut.getMethod();\n        // Make sure the method is accessible\n        if (!method.isAccessible()) {\n            method.setAccessible(true);\n        }\n        final Stopwatch stopwatch = Stopwatch.createStarted();\n        if (pointcut.isMethodRequiresTiming()) {\n            final Object timingParam = pointcut.convertToMethodTimingParameterType(timing);\n            method.invoke(annotatedObject, model, timingParam);\n        } else {\n            method.invoke(annotatedObject, model);\n        }\n        logger.trace(\"Executed in {}: {} (timing={}) on {}\", stopwatch, pointcut, timing, model);\n    }\n\n    /**\n     * @param timing\n     * @return true if timing is change (before, after)\n     */\n    private static final boolean isTimingChange(final int timing) {\n        return ModelValidator.TYPE_BEFORE_CHANGE == timing || ModelValidator.TYPE_AFTER_CHANGE == timing || ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;\n    }\n}\n", "class_id": 0, "repo": "focadiz/metasfresh", "file": "backend/de.metas.adempiere.adempiere/base/src/main/java/org/adempiere/ad/modelvalidator/AnnotatedModelInterceptor.java", "last_update_at": "2021-02-17T12:00:41+00:00", "original_content": "@EqualsAndHashCode(of = { \"annotatedObject\", \"descriptor\", \"clientId\" })\nclass /* package */\nAnnotatedModelInterceptor implements IModelInterceptor {\n\n    private static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);\n\n    private final AnnotatedModelInterceptorDescriptor descriptor;\n\n    private final transient Object annotatedObject;\n\n    private ClientId clientId;\n\n    /**\n     * @param annotatedObject\n     */\n    AnnotatedModelInterceptor(@NonNull final Object annotatedObject) {\n        this.annotatedObject = annotatedObject;\n        this.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass()).build();\n    }\n\n    @Override\n    public String toString() {\n        return \"annotated[\" + annotatedObject.getClass().getName() + \"]\";\n    }\n\n    /**\n     * @return true if it has no initializers, no pointcuts, no nothing\n     */\n    public boolean isEmpty() {\n        return descriptor.isEmpty();\n    }\n\n    @Override\n    public void initialize(final IModelValidationEngine engine, final I_AD_Client client) {\n        if (client != null) {\n            this.clientId = ClientId.ofRepoId(client.getAD_Client_ID());\n        }\n        bindPointcuts(engine);\n        // Execute initializers\n        for (final InterceptorInit init : descriptor.getInitializers()) {\n            Object[] params = new Object[] {};\n            if (init.isMethodRequiresEngine()) {\n                params = new Object[] { engine };\n            }\n            final Method method = init.getMethod();\n            try {\n                // Make sure the method is accessible\n                if (!method.isAccessible()) {\n                    method.setAccessible(true);\n                }\n                // Execute\n                method.invoke(annotatedObject, params);\n            } catch (Exception e) {\n                throw new AdempiereException(\"Cannot initialize \" + annotatedObject + \". Initializer \" + init + \" failed.\" + \"\\n Method: \" + method + \"\\n Params:\" + Arrays.toString(params) + \"\\n Method Descriptor: \" + init, Throwables.getRootCause(e));\n            }\n            logger.debug(\"Initializer {} executed successfully.\", init);\n        }\n    }\n\n    private void bindPointcuts(@NonNull final IModelValidationEngine engine) {\n        logger.debug(\"Binding pointcuts for {}\", annotatedObject);\n        for (final PointcutKey key : descriptor.getPointcutKeys()) {\n            final Set<Pointcut> list = descriptor.getPointcuts(key);\n            if (list.isEmpty()) {\n                continue;\n            }\n            logger.debug(\"Binding pointcuts for {} on {}\", annotatedObject, key);\n            switch(key.getType()) {\n                case ModelChange:\n                    engine.addModelChange(key.getTableName(), this);\n                    break;\n                case DocValidate:\n                    engine.addDocValidate(key.getTableName(), this);\n                    break;\n                default:\n                    throw new AdempiereException(\"Unknown PointcutType \" + key.getType());\n            }\n        }\n        logger.debug(\"Binding pointcuts for {} done.\", annotatedObject);\n    }\n\n    @Override\n    public int getAD_Client_ID() {\n        return ClientId.toRepoId(clientId);\n    }\n\n    @Override\n    public void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID) {\n    }\n\n    @Override\n    public final void onModelChange(final Object model, final ModelChangeType changeType) {\n        execute(PointcutType.ModelChange, model, changeType.toInt());\n    }\n\n    @Override\n    public final void onDocValidate(final Object model, final DocTimingType timing) {\n        execute(PointcutType.DocValidate, model, timing.toInt());\n    }\n\n    private void execute(final PointcutType type, final Object po, final int timing) {\n        final String tableName = InterfaceWrapperHelper.getModelTableName(po);\n        final PointcutKey key = PointcutKey.of(tableName, type);\n        final ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);\n        if (pointcuts.isEmpty()) {\n            return;\n        }\n        for (final Pointcut pointcut : pointcuts) {\n            execute(pointcut, po, timing);\n        }\n    }\n\n    private void execute(final Pointcut pointcut, final Object po, final int timing) {\n        // Check timings\n        final Set<Integer> timings = pointcut.getTimings();\n        if (!timings.contains(timing)) {\n            return;\n        }\n        // Check if UserAction required (i.e. user manually changed this record from a window)\n        if (pointcut.isOnlyIfUIAction()) {\n            final boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);\n            if (!isUIAction) {\n                return;\n            }\n        }\n        // Check if we shall skip when copying\n        if (pointcut.isSkipIfCopying()) {\n            final boolean isCopying = InterfaceWrapperHelper.isCopy(po);\n            if (isCopying) {\n                return;\n            }\n        }\n        // Else, does not make sense.\n        if (isTimingChange(timing)) {\n            final Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();\n            if (!columnsToCheckForChanges.isEmpty()) {\n                // none of our columns had changed; skip\n                if (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges)) {\n                    return;\n                }\n            }\n        }\n        // Execute the method now\n        if (!pointcut.isAfterCommit()) {\n            executeNow(po, pointcut, timing);\n        } else {\n            logger.trace(\"Scheduling to be executed after commit: {}\", pointcut);\n            final String trxName = InterfaceWrapperHelper.getTrxName(po);\n            Services.get(ITrxManager.class).getTrxListenerManagerOrAutoCommit(trxName).newEventListener(TrxEventTiming.AFTER_COMMIT).additionalToStringInfo(() -> MoreObjects.toStringHelper(this).add(\"pointcut\", pointcut).add(\"po\", po).add(\"timing\", timing).toString()).invokeMethodJustOnce(true).registerHandlingMethod(transaction -> {\n                executeNow(po, pointcut, timing);\n                InterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    private final void executeNow(@NonNull final Object po, @NonNull final Pointcut pointcut, final int timing) {\n        if (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut)) {\n            logger.info(\"Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}\", AnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);\n            return;\n        }\n        final Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());\n        try {\n            executeNow0(model, pointcut, timing);\n        } catch (final Exception e) {\n            final AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);\n            throw adempiereException;\n        }\n    }\n\n    private static AdempiereException appendAndLogHowtoDisableMessage(@NonNull final Exception e, @NonNull final Pointcut pointcut) {\n        final String parameterName = \"HowtoDisableModelInterceptor\";\n        final AdempiereException ae = AdempiereException.wrapIfNeeded(e);\n        if (!ae.hasParameter(parameterName)) {\n            final String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);\n            logger.error(howtoDisableMsg);\n            ae.setParameter(parameterName, howtoDisableMsg);\n        }\n        return ae;\n    }\n\n    private void executeNow0(@NonNull final Object model, @NonNull final Pointcut pointcut, final int timing) throws IllegalAccessException, InvocationTargetException {\n        final Method method = pointcut.getMethod();\n        // Make sure the method is accessible\n        if (!method.isAccessible()) {\n            method.setAccessible(true);\n        }\n        final Stopwatch stopwatch = Stopwatch.createStarted();\n        if (pointcut.isMethodRequiresTiming()) {\n            final Object timingParam = pointcut.convertToMethodTimingParameterType(timing);\n            method.invoke(annotatedObject, model, timingParam);\n        } else {\n            method.invoke(annotatedObject, model);\n        }\n        logger.trace(\"Executed in {}: {} (timing={}) on {}\", stopwatch, pointcut, timing, model);\n    }\n\n    /**\n     * @param timing\n     * @return true if timing is change (before, after)\n     */\n    private static final boolean isTimingChange(final int timing) {\n        return ModelValidator.TYPE_BEFORE_CHANGE == timing || ModelValidator.TYPE_AFTER_CHANGE == timing || ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;\n    }\n}\n", "refactored": false}
{"hexsha": "7d552efcea6c5f5cdd42841cc34ad20e76f615e1", "ext": "java", "lang": "Java", "content": "public final class MatrixAppendCPInstruction extends AppendCPInstruction {\n\n    protected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type, String opcode, String istr) {\n        super(op, in1, in2, out, type, opcode, istr);\n    }\n\n    @Override\n    public void processInstruction(ExecutionContext ec) {\n        // get inputs\n        MatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());\n        MatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());\n        validateInput(matBlock1, matBlock2);\n        MatrixBlock ret;\n        if (matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)\n            ret = CLALibAppend.append(matBlock1, matBlock2);\n        else\n            ret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);\n        ec.setMatrixOutput(output.getName(), ret);\n        ec.releaseMatrixInput(input1.getName(), input2.getName());\n    }\n\n    private void validateInput(MatrixBlock m1, MatrixBlock m2) {\n        if (_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {\n            throw new DMLRuntimeException(\"Append-cbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName() + \" with different number of rows: \" + m1.getNumRows() + \" vs \" + m2.getNumRows());\n        } else if (_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {\n            throw new DMLRuntimeException(\"Append-rbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName() + \" with different number of columns: \" + m1.getNumColumns() + \" vs \" + m2.getNumColumns());\n        }\n    }\n\n    @Override\n    public Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {\n        // TODO: break append to cbind and rbind for full compilation chain\n        String opcode = _type.toString().toLowerCase();\n        return Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));\n    }\n}\n", "class_id": 0, "repo": "Shafaq-Siddiqi/systemml", "file": "src/main/java/org/apache/sysds/runtime/instructions/cp/MatrixAppendCPInstruction.java", "last_update_at": "2021-06-08T18:02:41+00:00", "original_content": "public final class MatrixAppendCPInstruction extends AppendCPInstruction {\n\n    protected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type, String opcode, String istr) {\n        super(op, in1, in2, out, type, opcode, istr);\n    }\n\n    @Override\n    public void processInstruction(ExecutionContext ec) {\n        // get inputs\n        MatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());\n        MatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());\n        validateInput(matBlock1, matBlock2);\n        MatrixBlock ret;\n        if (matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)\n            ret = CLALibAppend.append(matBlock1, matBlock2);\n        else\n            ret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);\n        ec.setMatrixOutput(output.getName(), ret);\n        ec.releaseMatrixInput(input1.getName(), input2.getName());\n    }\n\n    private void validateInput(MatrixBlock m1, MatrixBlock m2) {\n        if (_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {\n            throw new DMLRuntimeException(\"Append-cbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName() + \" with different number of rows: \" + m1.getNumRows() + \" vs \" + m2.getNumRows());\n        } else if (_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {\n            throw new DMLRuntimeException(\"Append-rbind is not possible for input matrices \" + input1.getName() + \" and \" + input2.getName() + \" with different number of columns: \" + m1.getNumColumns() + \" vs \" + m2.getNumColumns());\n        }\n    }\n\n    @Override\n    public Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {\n        // TODO: break append to cbind and rbind for full compilation chain\n        String opcode = _type.toString().toLowerCase();\n        return Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));\n    }\n}\n", "refactored": false}
{"hexsha": "95b4f2f41928e6bf7ea2abf2c075fca294df06a9", "ext": "java", "lang": "Java", "content": "@Component\n@Description(\"Authorization policy assigned by given identity by assigned or default role.\")\npublic class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {\n\n    @Autowired\n    @Lazy\n    private RoleConfiguration roleConfiguration;\n\n    @Autowired\n    @Lazy\n    private IdmRoleCompositionService roleCompositionService;\n\n    @Autowired\n    public AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {\n        super(repository);\n    }\n\n    @Override\n    public String getName() {\n        return IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;\n    }\n\n    @Override\n    public Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {\n        UUID identityId = filter.getIdentityId();\n        if (identityId == null) {\n            return null;\n        }\n        // assigned role subquery\n        Subquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);\n        Root<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);\n        subquery.select(subRoot);\n        // correlation\n        subquery.// correlation\n        where(// correlation\n        builder.// correlation\n        and(builder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId), builder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role))));\n        Predicate predicate = builder.exists(subquery);\n        // or default role\n        UUID defaultRoleId = roleConfiguration.getDefaultRoleId();\n        if (defaultRoleId == null) {\n            // default role is not defined\n            return predicate;\n        }\n        // find all default role sub roles\n        Set<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);\n        defaultRoles.addAll(roleCompositionService.findAllSubRoles(defaultRoleId).stream().map(IdmRoleCompositionDto::getSub).collect(Collectors.toSet()));\n        return builder.or(predicate, root.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles));\n    }\n}\n", "class_id": 0, "repo": "piougy/CzechIdMng", "file": "Realization/backend/core/core-impl/src/main/java/eu/bcvsolutions/idm/core/model/repository/filter/AuthorizationPolicyByIdentityFilterBuilder.java", "last_update_at": "2021-08-06T19:55:05+00:00", "original_content": "@Component\n@Description(\"Authorization policy assigned by given identity by assigned or default role.\")\npublic class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {\n\n    @Autowired\n    @Lazy\n    private RoleConfiguration roleConfiguration;\n\n    @Autowired\n    @Lazy\n    private IdmRoleCompositionService roleCompositionService;\n\n    @Autowired\n    public AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {\n        super(repository);\n    }\n\n    @Override\n    public String getName() {\n        return IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;\n    }\n\n    @Override\n    public Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {\n        UUID identityId = filter.getIdentityId();\n        if (identityId == null) {\n            return null;\n        }\n        // assigned role subquery\n        Subquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);\n        Root<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);\n        subquery.select(subRoot);\n        subquery.where(builder.and(builder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId), // correlation\n        builder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role))));\n        Predicate predicate = builder.exists(subquery);\n        // or default role\n        UUID defaultRoleId = roleConfiguration.getDefaultRoleId();\n        if (defaultRoleId == null) {\n            // default role is not defined\n            return predicate;\n        }\n        // find all default role sub roles\n        Set<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);\n        defaultRoles.addAll(roleCompositionService.findAllSubRoles(defaultRoleId).stream().map(IdmRoleCompositionDto::getSub).collect(Collectors.toSet()));\n        return builder.or(predicate, root.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles));\n    }\n}\n", "refactored": false}
{"hexsha": "d0aa6b0a1e5c6f19bbc40686624f1ab36563df62", "ext": "java", "lang": "Java", "content": "public class Dispatcher {\n\n    /**\n     * DispatcherRunnable is the runnable class in which a group of dispatch\n     *   messages (sharing the same url) get dispatched to corresponding worker\n     *   service\n     */\n    private class DispatcherRunnable implements Runnable {\n\n        private static final String kWorkerEntryPoint = \"/Worker\";\n\n        private String dispatchMessages;\n\n        private ArrayList<String> workersTopology;\n\n        /**\n         * Constructor DispatcherRunnable\n         * @param url: worker service's url\n         * @param dispatchMessages: messages to be dispatched\n         * @return new DispatcherRunnable Object\n         */\n        public DispatcherRunnable(String dispatchMessages) {\n            this.dispatchMessages = dispatchMessages;\n            this.workersTopology = new ArrayList<String>();\n            try {\n                String propertiesWorkersTopology = DispatcherProperties.i().getStringPropterty(DispatcherProperties.kWorkersTopology);\n                String[] topologyArr = propertiesWorkersTopology.split(\",\");\n                for (String topologyEntry : topologyArr) {\n                    this.workersTopology.add(topologyEntry + kWorkerEntryPoint);\n                }\n            } catch (Exception e) {\n                throw new CodeException(32, 1, \"propterty [\" + DispatcherProperties.kWorkersTopology + \"] isn't defined in properties file [\" + DispatcherProperties.i().getName() + \"]\", ExceptionClass.PROPERTIES);\n            }\n        }\n\n        /**\n         * send the messages to be despatched in a POST http request to the\n         *   worker service\n         * NOTE: silent in case of failure, change as needed?\n         */\n        @Override\n        public void run() {\n            for (String workerTopologyPoint : this.workersTopology) {\n                try {\n                    URLConnection urlConnection = RestSyncInl.restCall(workerTopologyPoint, RestCallType.POST, this.dispatchMessages);\n                    if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {\n                        break;\n                    }\n                } catch (Exception e) {\n                }\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"DispatcherRunnable:  dispatchMessages(\" + this.dispatchMessages + \")\";\n        }\n    }\n\n    // url -> list of dispatch messages\n    private ArrayList<DispatchMessage> dispatchMessages;\n\n    /**\n     * Constructor Dispatcher\n     * @return new Dispatcher Object\n     */\n    public Dispatcher() {\n        this.dispatchMessages = new ArrayList<DispatchMessage>();\n    }\n\n    /**\n     * addDispatchMessage\n     * adds a new dispatch message to the dispatcher's buffer\n     * @param url: url of the worker service that handles this type of\n     *               dispatch message\n     * @param dispatchMessage: the message to be dispatched\n     * @throws Exception\n     */\n    public void addDispatchMessage(DispatchMessage dispatchMessage) throws Exception {\n        this.dispatchMessages.add(dispatchMessage);\n    }\n\n    /**\n     * dispatchMessages\n     * dispatches all the dispatch messages in the dispatcher buffer to their\n     *   corresponding worker services then clears the dispatcher buffer\n     * @throws Exception\n     */\n    public void dispatchMessages() throws Exception {\n        if (this.dispatchMessages.isEmpty() == true) {\n            return;\n        }\n        ThreadPool.i().executeInDispatcherPool(new DispatcherRunnable(new DispatchMessages(this.dispatchMessages).toJsonString()));\n        this.dispatchMessages.clear();\n    }\n\n    @Override\n    public String toString() {\n        return this.dispatchMessages.toString();\n    }\n}\n", "class_id": 0, "repo": "vangav/vos_backend", "file": "src/com/vangav/backend/dispatcher/Dispatcher.java", "last_update_at": "2021-08-09T19:54:45+00:00", "original_content": "public class Dispatcher {\n\n    /**\n     * DispatcherRunnable is the runnable class in which a group of dispatch\n     *   messages (sharing the same url) get dispatched to corresponding worker\n     *   service\n     */\n    private class DispatcherRunnable implements Runnable {\n\n        private static final String kWorkerEntryPoint = \"/Worker\";\n\n        private String dispatchMessages;\n\n        private ArrayList<String> workersTopology;\n\n        /**\n         * Constructor DispatcherRunnable\n         * @param url: worker service's url\n         * @param dispatchMessages: messages to be dispatched\n         * @return new DispatcherRunnable Object\n         */\n        public DispatcherRunnable(String dispatchMessages) {\n            this.dispatchMessages = dispatchMessages;\n            this.workersTopology = new ArrayList<String>();\n            try {\n                String propertiesWorkersTopology = DispatcherProperties.i().getStringPropterty(DispatcherProperties.kWorkersTopology);\n                String[] topologyArr = propertiesWorkersTopology.split(\",\");\n                for (String topologyEntry : topologyArr) {\n                    this.workersTopology.add(topologyEntry + kWorkerEntryPoint);\n                }\n            } catch (Exception e) {\n                throw new CodeException(32, 1, \"propterty [\" + DispatcherProperties.kWorkersTopology + \"] isn't defined in properties file [\" + DispatcherProperties.i().getName() + \"]\", ExceptionClass.PROPERTIES);\n            }\n        }\n\n        /**\n         * send the messages to be despatched in a POST http request to the\n         *   worker service\n         * NOTE: silent in case of failure, change as needed?\n         */\n        @Override\n        public void run() {\n            for (String workerTopologyPoint : this.workersTopology) {\n                try {\n                    URLConnection urlConnection = RestSyncInl.restCall(workerTopologyPoint, RestCallType.POST, this.dispatchMessages);\n                    if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {\n                        break;\n                    }\n                } catch (Exception e) {\n                }\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"DispatcherRunnable:  dispatchMessages(\" + this.dispatchMessages + \")\";\n        }\n    }\n\n    // url -> list of dispatch messages\n    private ArrayList<DispatchMessage> dispatchMessages;\n\n    /**\n     * Constructor Dispatcher\n     * @return new Dispatcher Object\n     */\n    public Dispatcher() {\n        this.dispatchMessages = new ArrayList<DispatchMessage>();\n    }\n\n    /**\n     * addDispatchMessage\n     * adds a new dispatch message to the dispatcher's buffer\n     * @param url: url of the worker service that handles this type of\n     *               dispatch message\n     * @param dispatchMessage: the message to be dispatched\n     * @throws Exception\n     */\n    public void addDispatchMessage(DispatchMessage dispatchMessage) throws Exception {\n        this.dispatchMessages.add(dispatchMessage);\n    }\n\n    /**\n     * dispatchMessages\n     * dispatches all the dispatch messages in the dispatcher buffer to their\n     *   corresponding worker services then clears the dispatcher buffer\n     * @throws Exception\n     */\n    public void dispatchMessages() throws Exception {\n        if (this.dispatchMessages.isEmpty() == true) {\n            return;\n        }\n        ThreadPool.i().executeInDispatcherPool(new DispatcherRunnable(new DispatchMessages(this.dispatchMessages).toJsonString()));\n        this.dispatchMessages.clear();\n    }\n\n    @Override\n    public String toString() {\n        return this.dispatchMessages.toString();\n    }\n}\n", "refactored": false}
{"hexsha": "1168d4b7c2a618ee1fa85e5a4e7400a4dc63922f", "ext": "java", "lang": "Java", "content": "public class DialogShopCarAdapter extends BaseAdapter {\n\n    private static final int FIRST = 0;\n\n    private static final int SECOND = 1;\n\n    private static final int COUNT = 2;\n\n    private FunctionListActivity activity;\n\n    private List<Quotation> data;\n\n    private LayoutInflater mInflater;\n\n    private DelOnClickListener delOnClickListener;\n\n    private AddDelOnClickListener addDelOnClickListener;\n\n    private ShopCarDialog dialog;\n\n    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {\n        this.activity = activity;\n        mInflater = LayoutInflater.from(activity);\n        this.dialog = dialog;\n        this.delOnClickListener = new DelOnClickListener();\n        this.addDelOnClickListener = new AddDelOnClickListener();\n    }\n\n    public void setData(List<Quotation> data) {\n        this.data = data;\n    }\n\n    public List<Quotation> getData() {\n        return data;\n    }\n\n    @Override\n    public int getCount() {\n        return data == null ? 0 : data.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (data.get(position).type == 1) {\n            return FIRST;\n        } else {\n            return SECOND;\n        }\n    }\n\n    @Override\n    public int getViewTypeCount() {\n        return COUNT;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        int type = getItemViewType(position);\n        if (convertView == null) {\n            holder = new ViewHolder();\n            switch(type) {\n                case FIRST:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);\n                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);\n                    holder.clearAll = convertView.findViewById(R.id.tv_clear);\n                    holder.reset = convertView.findViewById(R.id.tv_reset);\n                    holder.clearAll.setOnClickListener(clickClear);\n                    holder.reset.setOnClickListener(clickReset);\n                    break;\n                case SECOND:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);\n                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);\n                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);\n                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);\n                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);\n                    break;\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        Quotation quotation = data.get(position);\n        switch(type) {\n            case FIRST:\n                String sectionTitle = String.format(\"%s . %d\", quotation.title, quotation.getExtra().size());\n                holder.tv_head.setText(sectionTitle);\n                holder.clearAll.setTag(quotation);\n                holder.reset.setTag(quotation);\n                break;\n            case SECOND:\n                holder.tv_name.setText(quotation.title);\n                if (quotation.title.equals(\"????\")) {\n                    holder.ivDelCar.setVisibility(View.VISIBLE);\n                    holder.tvNum.setVisibility(View.VISIBLE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);\n                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);\n                    holder.tvNum.setText(activity.getNum() + \"\");\n                    //???\n                    holder.ivAddCar.setTag(R.id.action_type, 0);\n                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);\n                    //???\n                    holder.ivDelCar.setTag(R.id.action_type, 1);\n                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);\n                } else {\n                    holder.ivDelCar.setVisibility(View.GONE);\n                    holder.tvNum.setVisibility(View.GONE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);\n                    holder.ivAddCar.setTag(quotation);\n                    holder.ivAddCar.setOnClickListener(delOnClickListener);\n                }\n                break;\n        }\n        return convertView;\n    }\n\n    private class ViewHolder {\n\n        TextView tv_head;\n\n        View reset;\n\n        View clearAll;\n\n        TextView tv_name;\n\n        ImageView ivAddCar;\n\n        ImageView ivDelCar;\n\n        TextView tvNum;\n    }\n\n    private View.OnClickListener clickClear = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.clearPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private View.OnClickListener clickReset = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.resetPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private class DelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            Quotation quotation = (Quotation) v.getTag();\n            if (quotation.isRadioItem()) {\n                return;\n            }\n            int pos = data.indexOf(quotation);\n            if (pos != -1) {\n                data.remove(quotation);\n                Quotation platform = null;\n                int i = pos - 1;\n                while (i >= 0) try {\n                    Quotation quotation1 = data.get(i);\n                    if (quotation1.isPlatform()) {\n                        platform = quotation1;\n                        break;\n                    }\n                } finally {\n                    --i;\n                }\n                if (platform != null) {\n                    platform.getExtra().remove(quotation);\n                }\n                dialog.updateNum();\n                notifyDataSetChanged();\n            }\n        }\n    }\n\n    private class AddDelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            int type = (int) v.getTag(R.id.action_type);\n            switch(type) {\n                case 0:\n                    {\n                        int num = activity.getNum();\n                        num++;\n                        activity.setNum(num);\n                        dialog.updateNum();\n                        notifyDataSetChanged();\n                    }\n                    break;\n                case 1:\n                    {\n                        int num = activity.getNum();\n                        if (num < 1) {\n                            return;\n                        }\n                        num--;\n                        activity.setNum(num);\n                        dialog.updateNum();\n                        notifyDataSetChanged();\n                    }\n                    break;\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "JingMeng/Mart-Android", "file": "app/src/main/java/net/coding/mart/developers/adapter/DialogShopCarAdapter.java", "last_update_at": "2021-05-19T05:38:56+00:00", "original_content": "public class DialogShopCarAdapter extends BaseAdapter {\n\n    private static final int FIRST = 0;\n\n    private static final int SECOND = 1;\n\n    private static final int COUNT = 2;\n\n    private FunctionListActivity activity;\n\n    private List<Quotation> data;\n\n    private LayoutInflater mInflater;\n\n    private DelOnClickListener delOnClickListener;\n\n    private AddDelOnClickListener addDelOnClickListener;\n\n    private ShopCarDialog dialog;\n\n    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {\n        this.activity = activity;\n        mInflater = LayoutInflater.from(activity);\n        this.dialog = dialog;\n        this.delOnClickListener = new DelOnClickListener();\n        this.addDelOnClickListener = new AddDelOnClickListener();\n    }\n\n    public void setData(List<Quotation> data) {\n        this.data = data;\n    }\n\n    public List<Quotation> getData() {\n        return data;\n    }\n\n    @Override\n    public int getCount() {\n        return data == null ? 0 : data.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (data.get(position).type == 1) {\n            return FIRST;\n        } else {\n            return SECOND;\n        }\n    }\n\n    @Override\n    public int getViewTypeCount() {\n        return COUNT;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        int type = getItemViewType(position);\n        if (convertView == null) {\n            holder = new ViewHolder();\n            switch(type) {\n                case FIRST:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);\n                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);\n                    holder.clearAll = convertView.findViewById(R.id.tv_clear);\n                    holder.reset = convertView.findViewById(R.id.tv_reset);\n                    holder.clearAll.setOnClickListener(clickClear);\n                    holder.reset.setOnClickListener(clickReset);\n                    break;\n                case SECOND:\n                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);\n                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);\n                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);\n                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);\n                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);\n                    break;\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        Quotation quotation = data.get(position);\n        switch(type) {\n            case FIRST:\n                String sectionTitle = String.format(\"%s . %d\", quotation.title, quotation.getExtra().size());\n                holder.tv_head.setText(sectionTitle);\n                holder.clearAll.setTag(quotation);\n                holder.reset.setTag(quotation);\n                break;\n            case SECOND:\n                holder.tv_name.setText(quotation.title);\n                if (quotation.title.equals(\"????\")) {\n                    holder.ivDelCar.setVisibility(View.VISIBLE);\n                    holder.tvNum.setVisibility(View.VISIBLE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);\n                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);\n                    holder.tvNum.setText(activity.getNum() + \"\");\n                    //???\n                    holder.ivAddCar.setTag(R.id.action_type, 0);\n                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);\n                    //???\n                    holder.ivDelCar.setTag(R.id.action_type, 1);\n                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);\n                } else {\n                    holder.ivDelCar.setVisibility(View.GONE);\n                    holder.tvNum.setVisibility(View.GONE);\n                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);\n                    holder.ivAddCar.setTag(quotation);\n                    holder.ivAddCar.setOnClickListener(delOnClickListener);\n                }\n                break;\n        }\n        return convertView;\n    }\n\n    private class ViewHolder {\n\n        TextView tv_head;\n\n        View reset;\n\n        View clearAll;\n\n        TextView tv_name;\n\n        ImageView ivAddCar;\n\n        ImageView ivDelCar;\n\n        TextView tvNum;\n    }\n\n    private View.OnClickListener clickClear = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.clearPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private View.OnClickListener clickReset = v -> {\n        Quotation tag = (Quotation) v.getTag();\n        activity.resetPickedFunction(tag);\n        dialog.updateNum();\n        notifyDataSetChanged();\n    };\n\n    private class DelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            Quotation quotation = (Quotation) v.getTag();\n            if (quotation.isRadioItem()) {\n                return;\n            }\n            int pos = data.indexOf(quotation);\n            if (pos != -1) {\n                data.remove(quotation);\n                Quotation platform = null;\n                for (int i = pos - 1; i >= 0; --i) {\n                    Quotation quotation1 = data.get(i);\n                    if (quotation1.isPlatform()) {\n                        platform = quotation1;\n                        break;\n                    }\n                }\n                if (platform != null) {\n                    platform.getExtra().remove(quotation);\n                }\n                dialog.updateNum();\n                notifyDataSetChanged();\n            }\n        }\n    }\n\n    private class AddDelOnClickListener implements View.OnClickListener {\n\n        @Override\n        public void onClick(View v) {\n            int type = (int) v.getTag(R.id.action_type);\n            switch(type) {\n                case 0:\n                    {\n                        int num = activity.getNum();\n                        num++;\n                        activity.setNum(num);\n                        dialog.updateNum();\n                        notifyDataSetChanged();\n                    }\n                    break;\n                case 1:\n                    {\n                        int num = activity.getNum();\n                        if (num < 1) {\n                            return;\n                        }\n                        num--;\n                        activity.setNum(num);\n                        dialog.updateNum();\n                        notifyDataSetChanged();\n                    }\n                    break;\n            }\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "20ce929ce28429536893d7323990cd9eaf4116b3", "ext": "java", "lang": "Java", "content": "public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener {\n\n    private static final String TAG = MainActivity.class.getSimpleName();\n\n    private static final String KEY_NAV_POS = \"key_nav_pos\";\n\n    private Fragment m_actualFragment;\n\n    private NavigationView m_navigationView;\n\n    private int m_navPos;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        Log.d(TAG, \"TAG: \" + TAG);\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawer.setDrawerListener(toggle);\n        toggle.syncState();\n        m_navigationView = (NavigationView) findViewById(R.id.nav_view);\n        m_navigationView.setNavigationItemSelectedListener(this);\n        // Select first menu item of drawer\n        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);\n        m_navPos = R.id.nav_example_1;\n    }\n\n    @Override\n    public void onBackPressed() {\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main_activity, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @SuppressWarnings(\"StatementWithEmptyBody\")\n    @Override\n    public boolean onNavigationItemSelected(MenuItem item) {\n        // Handle navigation view item clicks here.\n        int id = item.getItemId();\n        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();\n        if (id == R.id.nav_example_1) {\n            if (!(m_actualFragment instanceof FragmentColors)) {\n                m_navPos = R.id.nav_example_1;\n                FragmentColors fragmentColors = FragmentColors.newInstance();\n                m_actualFragment = fragmentColors;\n                fragmentManager.beginTransaction().replace(R.id.container, fragmentColors, FragmentCities.TAG).commit();\n            }\n        } else if (id == R.id.nav_example_2) {\n            if (!(m_actualFragment instanceof FragmentCities)) {\n                m_navPos = R.id.nav_example_2;\n                FragmentCities fragmentCities = FragmentCities.newInstance();\n                m_actualFragment = fragmentCities;\n                fragmentManager.beginTransaction().replace(R.id.container, fragmentCities, FragmentCities.TAG).commit();\n            }\n        }\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_NAV_POS, m_navPos);\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        if (savedInstanceState != null) {\n            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);\n            // Select first menu item of drawer\n            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);\n        }\n    }\n}\n", "class_id": 0, "repo": "TmCrafz/FlipIconChecker", "file": "example/src/main/java/org/tmcrafz/flipiconcheckerexample/MainActivity.java", "last_update_at": "2021-03-16T13:55:31+00:00", "original_content": "public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener {\n\n    private static final String TAG = MainActivity.class.getSimpleName();\n\n    private static final String KEY_NAV_POS = \"key_nav_pos\";\n\n    private Fragment m_actualFragment;\n\n    private NavigationView m_navigationView;\n\n    private int m_navPos;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        Log.d(TAG, \"TAG: \" + TAG);\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawer.setDrawerListener(toggle);\n        toggle.syncState();\n        m_navigationView = (NavigationView) findViewById(R.id.nav_view);\n        m_navigationView.setNavigationItemSelectedListener(this);\n        // Select first menu item of drawer\n        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);\n        m_navPos = R.id.nav_example_1;\n    }\n\n    @Override\n    public void onBackPressed() {\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main_activity, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @SuppressWarnings(\"StatementWithEmptyBody\")\n    @Override\n    public boolean onNavigationItemSelected(MenuItem item) {\n        // Handle navigation view item clicks here.\n        int id = item.getItemId();\n        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();\n        if (id == R.id.nav_example_1) {\n            if (!(m_actualFragment instanceof FragmentColors)) {\n                m_navPos = R.id.nav_example_1;\n                FragmentColors fragmentColors = FragmentColors.newInstance();\n                m_actualFragment = fragmentColors;\n                fragmentManager.beginTransaction().replace(R.id.container, fragmentColors, FragmentCities.TAG).commit();\n            }\n        } else if (id == R.id.nav_example_2) {\n            if (!(m_actualFragment instanceof FragmentCities)) {\n                m_navPos = R.id.nav_example_2;\n                FragmentCities fragmentCities = FragmentCities.newInstance();\n                m_actualFragment = fragmentCities;\n                fragmentManager.beginTransaction().replace(R.id.container, fragmentCities, FragmentCities.TAG).commit();\n            }\n        }\n        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_NAV_POS, m_navPos);\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        if (savedInstanceState != null) {\n            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);\n            // Select first menu item of drawer\n            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "9911321d53109bf16da1df0c35f7787910b99c99", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\n@ComponentScan({ \"com.song7749.incident.drs\" })\r\npublic class LogRepositoryTest {\r\n\r\n    Logger logger = LoggerFactory.getLogger(getClass());\r\n\r\n    @Autowired\r\n    LogRepository logRepository;\r\n\r\n    @Test\r\n    public void testSaveLogLogin() {\r\n        // give\r\n        LogLogin ll = new LogLogin();\r\n        ll.setIp(\"111.111.111.111\");\r\n        ll.setLoginId(\"song7749\");\r\n        ll.setCipher(\"12314142341231\");\r\n        // when\r\n        logRepository.saveAndFlush(ll);\r\n        // then\r\n        assertThat(ll.getId(), notNullValue());\r\n    }\r\n\r\n    @Test\r\n    public void testSaveLogQuery() {\r\n        //give\r\n        LogQuery lq = new LogQuery();\r\n        lq.setIp(\"111.111.111.111\");\r\n        lq.setDatabaseId(1L);\r\n        lq.setAccount(\"song7749\");\r\n        lq.setHost(\"11.11.11.11\");\r\n        lq.setHostAlias(\"??? ??\");\r\n        lq.setLoginId(\"song7749\");\r\n        lq.setQuery(\"select * from dual\");\r\n        lq.setSchemaName(\"song7749\");\r\n        //when\r\n        logRepository.saveAndFlush(lq);\r\n        //then\r\n        assertThat(lq.getId(), notNullValue());\r\n    }\r\n}\r\n", "class_id": 0, "repo": "MS-Song/Spring4BootWithGradel", "file": "incidentAlert/src/test/java/com/song7749/incident/drs/repository/LogRepositoryTest.java", "last_update_at": "2021-09-16T04:20:54+00:00", "original_content": "@RunWith(SpringRunner.class)\r\n@DataJpaTest\r\n@ComponentScan({ \"com.song7749.incident.drs\" })\r\npublic class LogRepositoryTest {\r\n\r\n    Logger logger = LoggerFactory.getLogger(getClass());\r\n\r\n    @Autowired\r\n    LogRepository logRepository;\r\n\r\n    @Test\r\n    public void testSaveLogLogin() {\r\n        // give\r\n        LogLogin ll = new LogLogin();\r\n        ll.setIp(\"111.111.111.111\");\r\n        ll.setLoginId(\"song7749\");\r\n        ll.setCipher(\"12314142341231\");\r\n        // when\r\n        logRepository.saveAndFlush(ll);\r\n        // then\r\n        assertThat(ll.getId(), notNullValue());\r\n    }\r\n\r\n    @Test\r\n    public void testSaveLogQuery() {\r\n        //give\r\n        LogQuery lq = new LogQuery();\r\n        lq.setIp(\"111.111.111.111\");\r\n        lq.setDatabaseId(1L);\r\n        lq.setAccount(\"song7749\");\r\n        lq.setHost(\"11.11.11.11\");\r\n        lq.setHostAlias(\"??? ??\");\r\n        lq.setLoginId(\"song7749\");\r\n        lq.setQuery(\"select * from dual\");\r\n        lq.setSchemaName(\"song7749\");\r\n        //when\r\n        logRepository.saveAndFlush(lq);\r\n        //then\r\n        assertThat(lq.getId(), notNullValue());\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "6c338a1f6834fb9094f88ce1c7d13fe385e54000", "ext": "java", "lang": "Java", "content": "@RunWith(value = YBTestRunnerNonTsanOnly.class)\npublic class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {\n\n    private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);\n\n    @Test\n    public void simplest() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n        }\n    }\n\n    @Test\n    public void duplicates() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, v int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 2)\");\n            // PG error in this case mentions \"nopk_pkey\", not just \"nopk\"\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", \"duplicate key value violates unique constraint \\\"nopk\\\"\");\n            stmt.executeUpdate(\"DELETE FROM nopk WHERE v = 2\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1)));\n        }\n    }\n\n    @Test\n    public void nulls() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (NULL)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", \"column \\\"id\\\" contains null values\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1), new Row((Object) null)));\n        }\n    }\n\n    @Test\n    public void columnTypes() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int[10][20], v2 text)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, new Integer[] { 1, 2, 3 }, \"qwe\"), new Row(2, new Integer[] { 3, 4 }, \"zxcv\")));\n        }\n    }\n\n    @Test\n    public void columnTypesUnsupported() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TYPE typeid AS (i int)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (id typeid, v int)\");\n            String msg = \"PRIMARY KEY containing column of type 'user_defined_type' not yet supported\";\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)\", msg);\n        }\n    }\n\n    @Test\n    public void missing() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            String msg = \"column \\\"missme\\\" named in key does not exist\";\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)\", msg);\n        }\n    }\n\n    @Test\n    public void complexPk() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '111', '1', true)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '2', false)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '3', true)\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, '222', '2', false)\", \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY v1, v2, v3, v4\", Arrays.asList(new Row(1, \"111\", \"1\", true), new Row(2, \"222\", \"2\", false), new Row(2, \"222\", \"3\", true)));\n        }\n    }\n\n    @Test\n    public void pkInclude() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int, v2 int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 11, 111)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 22, 222)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id) INCLUDE (v1, v2)\");\n            // Scan is supposed to be index-only scan, but it's index scan for us.\n            {\n                String includeQuery = \"SELECT v1 FROM nopk WHERE id = 2\";\n                assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n                assertQuery(stmt, includeQuery, new Row(22));\n            }\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (3, 11, 111)\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (3, 99, 999)\", \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 11, 111), new Row(2, 22, 222), new Row(3, 11, 111)));\n            {\n                String includeQuery = \"SELECT v1 FROM nopk WHERE id = 3\";\n                assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n                assertQuery(stmt, includeQuery, new Row(11));\n            }\n        }\n    }\n\n    @Test\n    public void pkUsingIndex() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY\" + \" USING INDEX nopk_idx\", \"ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported\");\n        }\n    }\n\n    @Test\n    public void sequences() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \"id serial,\" + \"v1 int GENERATED ALWAYS AS IDENTITY,\" + \"v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10),\" + \"stuff text)\");\n            stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r1')\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 10, \"r1\")));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r2')\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 10, \"r1\"), new Row(2, 2, 11, \"r2\")));\n        }\n    }\n\n    @Test\n    public void typedTable() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TYPE nopk_type AS (id int, v int)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk OF nopk_type\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 10)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 20)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 10), new Row(2, 20)));\n            runInvalidQuery(stmt, \"ALTER TABLE nopk DROP COLUMN v\", \"cannot drop column from typed table\");\n        }\n    }\n\n    // TODO(alex): Enable after INHERITS is supported in #1129\n    @Ignore\n    public void inheritedTable() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk_parent (id int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (1)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);\");\n            stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (3, 30)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (4, 40)\");\n            alterAddPrimaryKey(stmt, \"nopk_parent\", \"ADD PRIMARY KEY (id)\");\n            alterAddPrimaryKey(stmt, \"nopk_child\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk_parent ORDER BY id\", Arrays.asList(new Row(1), new Row(2)));\n            assertRowList(stmt, \"SELECT * FROM nopk_child ORDER BY id\", Arrays.asList(new Row(3, 30), new Row(4, 40)));\n        }\n    }\n\n    /**\n     * Adding PK to a partitioned table is not yet implemented.\n     */\n    @Test\n    public void partitionedTable() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part1 PARTITION OF nopk_whole\" + \" FOR VALUES IN (1, 2, 3)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part2 PARTITION OF nopk_whole\" + \" FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2\" + \" FOR VALUES IN (10, 20)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2\" + \" FOR VALUES IN (30, 40)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_whole ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n        }\n    }\n\n    @Test\n    public void tablesInColocatedDb() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE DATABASE clc WITH colocated = true\");\n        }\n        try (Connection conn2 = getConnectionBuilder().withDatabase(\"clc\").connect();\n            Statement stmt = conn2.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_c (id int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (3)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (4)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_nc (id int) WITH (colocated = false)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (5)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (6)\");\n            assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n            assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n            assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n            // See #6159\n            alterAddPrimaryKey(stmt, \"nopk_c\", \"ADD PRIMARY KEY (id)\");\n            alterAddPrimaryKey(stmt, \"nopk_nc\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(new Row(1), new Row(2)));\n            assertRowList(stmt, \"SELECT * FROM nopk_c ORDER BY id\", Arrays.asList(new Row(3), new Row(4)));\n            assertRowList(stmt, \"SELECT * FROM nopk_nc ORDER BY id\", Arrays.asList(new Row(5), new Row(6)));\n            assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n            assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n            assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n        }\n    }\n\n    @Test\n    public void tablesInTablegroup() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\" + \" TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\" + \" TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (3)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (4)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk2 (id int, id2 int unique)\" + \" TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (5, 5)\");\n            stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (6, 6)\");\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            alterAddPrimaryKey(stmt, \"nopk2\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(new Row(1), new Row(2)));\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(3), new Row(4)));\n            assertRowList(stmt, \"SELECT * FROM nopk2 ORDER BY id\", Arrays.asList(new Row(5, 5), new Row(6, 6)));\n            assertRowList(stmt, \"SELECT s.relname, pg_tablegroup.grpname \" + \"FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) \" + \"s, pg_tablegroup WHERE opts LIKE \" + \"CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') \" + \"ORDER BY s\", Arrays.asList(new Row(\"nopk\", \"tgroup1\"), new Row(\"nopk2\", \"tgroup1\"), new Row(\"nopk2_id2_key\", \"tgroup1\"), new Row(\"nopk2_pkey\", \"tgroup1\"), new Row(\"nopk_pkey\", \"tgroup1\"), new Row(\"normal_table\", \"tgroup1\"), new Row(\"normal_table_pkey\", \"tgroup1\")));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n        }\n    }\n\n    @Test\n    public void defaults() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int DEFAULT 10, \" + \" drop_me int DEFAULT 10, \" + \" v int DEFAULT 10\" + \")\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1)));\n            stmt.executeUpdate(\"INSERT INTO nopk (id) VALUES (2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1), new Row(2, 10)));\n            stmt.executeUpdate(\"INSERT INTO nopk (v) VALUES (2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1), new Row(2, 10), new Row(10, 2)));\n        }\n    }\n\n    @Test\n    public void notNullAndCheck() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int CHECK (id > 0),\" + \" drop_me int,\" + \" v1 int CHECK (v1 > 0),\" + \" v2 int NOT NULL\" + \")\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (0, 2, 2)\", \"violates check constraint \\\"nopk_id_check\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 0, 2)\", \"violates check constraint \\\"nopk_v1_check\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, NULL)\", \"violates not-null constraint\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1)));\n        }\n    }\n\n    /**\n     * Altered table references a FK table.\n     */\n    @Test\n    public void foreignKeys() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON fk_ref_table (v, id)\");\n            stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (1, 1)\");\n            stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (2, 2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int,\" + \" fk1 int REFERENCES fk_ref_table (id),\" + \" drop_me int,\" + \" fk2 int REFERENCES fk_ref_table (v),\" + \" fk3 int)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)\" + \" REFERENCES fk_ref_table (v, id)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 20, 2, 2)\", \"violates foreign key constraint \\\"nopk_fk1_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 20, 2)\", \"violates foreign key constraint \\\"nopk_fk2_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 2, 20)\", \"violates foreign key constraint \\\"nopk_fk2_fkey1\\\"\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1), new Row(2, 2, 2, 2)));\n            runInvalidQuery(stmt, \"DELETE FROM fk_ref_table WHERE id = 1\", \"violates foreign key constraint \\\"nopk_fk1_fkey\\\" on table \\\"nopk\\\"\");\n        }\n    }\n\n    /**\n     * Altered table itself is referenced through FK constraints from other table.\n     */\n    @Test\n    public void foreignKeys2() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v, id)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            stmt.executeUpdate(\"CREATE TABLE referencing_table (\" + \" id int PRIMARY KEY,\" + \" fk1 int REFERENCES nopk (id),\" + \" drop_me int,\" + \" fk2 int REFERENCES nopk (v),\" + \" fk3 int)\");\n            stmt.executeUpdate(\"ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)\" + \" REFERENCES nopk (v, id)\");\n            stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)\");\n            stmt.executeUpdate(\"ALTER TABLE referencing_table DROP COLUMN drop_me\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1), new Row(2, 2)));\n            assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 20, 2, 2)\", \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 20, 2)\", \"violates foreign key constraint \\\"referencing_table_fk2_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 2, 20)\", \"violates foreign key constraint \\\"referencing_table_fk2_fkey1\\\"\");\n            stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (2, 2, 2, 2)\");\n            assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1), new Row(2, 2, 2, 2)));\n            runInvalidQuery(stmt, \"DELETE FROM nopk WHERE id = 1\", \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\" + \" on table \\\"referencing_table\\\"\");\n        }\n    }\n\n    @Test\n    public void otherConstraintsAndIndexes() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.\n            runInvalidQuery(stmt, \"CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))\", \"EXCLUDE constraint not supported yet\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int,\" + \" v1 int UNIQUE,\" + \" drop_me int,\" + \" v2 int,\" + \" v3 int,\" + \" v4 int\" + \")\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v2)\");\n            stmt.executeUpdate(\"CREATE INDEX ON nopk (v3)\");\n            stmt.executeUpdate(\"CREATE INDEX ON nopk ((v4 * 2))\");\n            stmt.executeUpdate(\"CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            String v3query = \"SELECT v3 FROM nopk WHERE v3 = 1\";\n            String v4query = \"SELECT v4 FROM nopk WHERE v4 * 2 = 2\";\n            assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n            assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 1, 2, 2, 2)\", \"violates unique constraint \\\"nopk_v1_key\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 1, 2, 2)\", \"violates unique constraint \\\"nopk_v2_idx\\\"\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 1, 2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1, 1), new Row(2, 2, 2, 1, 2)));\n            assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n            assertRowList(stmt, v3query, Arrays.asList(new Row(1), new Row(1)));\n            assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n            assertRowList(stmt, v4query, Arrays.asList(new Row(1)));\n        }\n    }\n\n    @Test\n    public void triggers() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, drop_me int, v int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            stmt.executeUpdate(\"CREATE FUNCTION notice_on_trigger() RETURNS trigger\" + \" LANGUAGE plpgsql\" + \" AS $$\" + \"   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;\" + \"   RETURN NEW;\" + \"   END;\" + \" $$;\");\n            for (String timing : Arrays.asList(\"before\", \"after\")) {\n                for (String scope : Arrays.asList(\"statement\", \"row\")) {\n                    for (String action : Arrays.asList(\"insert\", \"update\", \"delete\")) {\n                        stmt.executeUpdate(MessageFormat.format(\"CREATE TRIGGER nopk__{0}_{2}_{1}\" + \" {0} {2} ON nopk\" + \" FOR EACH {1}\" + \" EXECUTE PROCEDURE notice_on_trigger()\", timing, scope, action));\n                    }\n                    String whenExpr = scope.equals(\"row\") ? \"OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0\" : \"RANDOM() >= 0\";\n                    stmt.executeUpdate(MessageFormat.format(\"CREATE TRIGGER nopk__{0}_update_c_{1}\" + \" {0} UPDATE OF id, v ON nopk\" + \" FOR EACH {1}\" + \" WHEN (\" + whenExpr + \")\" + \" EXECUTE PROCEDURE notice_on_trigger()\", timing, scope));\n                }\n            }\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1)));\n        }\n    }\n\n    @Test\n    public void secondPk() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int PRIMARY KEY)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", \"multiple primary keys for table \\\"nopk\\\" are not allowed\");\n        }\n    }\n\n    @Test\n    public void splitInto() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS\");\n            assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n        }\n    }\n\n    @Test\n    public void roles() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            stmt.executeUpdate(\"CREATE ROLE new_user\");\n            stmt.executeUpdate(\"ALTER TABLE nopk OWNER TO new_user\");\n            assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\", new Row(\"new_user\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\", new Row(\"new_user\"));\n        }\n    }\n\n    /**\n     * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).\n     * <p>\n     * Source was a real output from pg_dump in its default configuration.\n     */\n    @Test\n    public void restorePgDump() throws Exception {\n        URL sqlFileRes = getClass().getClassLoader().getResource(\"TestPgAlterTableAddPrimaryKey/restorePgDump.sql\");\n        assertTrue(\"Dump SQL resource not found!\", sqlFileRes != null);\n        File sqlFile = new File(sqlFileRes.getFile());\n        String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), \"ysqlsh\").getAbsolutePath();\n        ProcessBuilder procBuilder = new ProcessBuilder(ysqlshPath, \"-h\", getPgHost(0), \"-p\", Integer.toString(getPgPort(0)), DEFAULT_PG_DATABASE);\n        procBuilder.redirectInput(sqlFile);\n        List<String> output = runProcess(procBuilder);\n        // Sanity checks.\n        assertTrue(output.size() > 0);\n        assertFalse(\"There was an error executing SQL: \" + output, StringUtils.join(output, '\\n').toLowerCase().contains(\"error\"));\n        try (Statement stmt = connection.createStatement()) {\n            assertRowList(stmt, \"SELECT * FROM public.with_constraints_and_such ORDER BY id\", Arrays.asList(new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111), new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222), new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));\n        }\n    }\n\n    /**\n     * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.\n     */\n    private void alterAddPrimaryKey(Statement stmt, String tableName, String alterSpec) throws Exception {\n        String countPgClass = \"SELECT COUNT(*) FROM pg_class\";\n        String getTableNames = \"SELECT table_name FROM information_schema.tables\" + \" WHERE table_schema = 'public' ORDER BY table_name\";\n        String getOid = \"SELECT oid FROM pg_class WHERE relname = '\" + tableName + \"'\";\n        // We're also selecting owning_tab_name instead of owning_tab OID.\n        String getSequences = \"SELECT c.oid, c.relname, \" + \"     c.relkind, c.relnamespace, \" + \"     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, \" + \"     c.relchecks, c.relhastriggers, \" + \"     c.relhasindex, c.relhasrules, c.relhasoids, \" + \"     c.relrowsecurity, c.relforcerowsecurity, \" + \"     c.relfrozenxid, c.relminmxid, tc.oid AS toid, \" + \"     tc.relfrozenxid AS tfrozenxid, \" + \"     tc.relminmxid AS tminmxid, \" + \"     c.relpersistence, c.relispopulated, \" + \"     c.relreplident, c.relpages, \" + \"     CASE WHEN c.reloftype <> 0\" + \"       THEN c.reloftype::pg_catalog.regtype ELSE NULL END\" + \"     AS reloftype, \" + \"     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, \" + \"     d.refobjsubid AS owning_col, \" + \"     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)\" + \"       AS reltablespace, \" + \"     array_remove(array_remove(c.reloptions,'check_option=local'),\" + \"                  'check_option=cascaded')\" + \"     AS reloptions, \" + \"     CASE\" + \"       WHEN 'check_option=local' = ANY (c.reloptions)\" + \"         THEN 'LOCAL'::text \" + \"       WHEN 'check_option=cascaded' = ANY (c.reloptions)\" + \"         THEN 'CASCADED'::text ELSE NULL END\" + \"     AS checkoption, \" + \"     tc.reloptions AS toast_reloptions, \" + \"     c.relkind = 'S' AND EXISTS (\" + \"       SELECT 1 FROM pg_depend\" + \"       WHERE classid = 'pg_class'::regclass\" + \"         AND objid = c.oid\" + \"         AND objsubid = 0\" + \"         AND refclassid = 'pg_class'::regclass\" + \"         AND deptype = 'i'\" + \"     ) AS is_identity_sequence\" + \" FROM pg_class c \" + \" LEFT JOIN pg_depend d\" + \"   ON (c.relkind = 'S' AND d.classid = c.tableoid AND\" + \"     d.objid = c.oid AND d.objsubid = 0 AND \" + \"     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) \" + \" LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) \" + \" LEFT JOIN pg_init_privs pip\" + \"   ON (c.oid = pip.objoid AND\" + \"     pip.classoid = 'pg_class'::regclass AND\" + \"     pip.objsubid = 0) \" + \" WHERE c.relkind in ('S') \" + \" ORDER BY c.oid\";\n        long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n        long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);\n        List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));\n        List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));\n        PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);\n        stmt.executeUpdate(\"ALTER TABLE \" + tableName + \" \" + alterSpec);\n        // OID has changed, but the pg_class row content did not.\n        long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n        assertNotEquals(oldOid, newOid);\n        // There's one more index in the pool now.\n        assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));\n        // Everything else should remain as it was.\n        assertRowList(stmt, getTableNames, oldTableNames);\n        assertRowList(stmt, getSequences, oldSequences);\n        PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);\n        assertPgStateEquals(oldState, newState);\n    }\n\n    private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {\n        ps.setLong(1, oid);\n        return getRowList(ps.executeQuery());\n    }\n\n    private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {\n        assertRow(oldState.pgClassRow, newState.pgClassRow);\n        assertRows(oldState.attrs, newState.attrs);\n        assertRows(oldState.defaults, newState.defaults);\n        assertRows(oldState.checkConstrs, newState.checkConstrs);\n        assertRows(oldState.indexes, newState.indexes);\n        assertRows(oldState.foreignKeys, newState.foreignKeys);\n        assertRows(oldState.triggers, newState.triggers);\n    }\n\n    private int getNumTablets(String databaseName, String tableName) throws Exception {\n        List<String> lines = runProcess(TestUtils.findBinary(\"yb-admin\"), \"--master_addresses\", masterAddresses, \"list_tablets\", \"ysql.\" + databaseName, tableName);\n        // We don't care about the output, just number of lines (minus header line).\n        return lines.size() - 1;\n    }\n\n    private class PgSystemTableInfo {\n\n        Row pgClassRow;\n\n        List<Row> attrs;\n\n        List<Row> defaults;\n\n        List<Row> checkConstrs;\n\n        List<Row> indexes;\n\n        List<Row> foreignKeys;\n\n        List<Row> triggers;\n\n        public PgSystemTableInfo(Connection conn, long oid) throws Exception {\n            // relnatts (because it includes dropped attributes).\n            PreparedStatement getPgClassRow = conn.prepareStatement(\"SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages,\" + \"   reltuples, relallvisible, reltoastrelid, relisshared,\" + \"   relpersistence, relkind, relchecks, relhasoids, relhasrules,\" + \"   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity,\" + \"   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid,\" + \"   relminmxid, relacl\" + \" FROM pg_class WHERE oid = ?\");\n            //  * Added ORDER BY to all queries.\n            PreparedStatement getAttrs = conn.prepareStatement(\"SELECT a.attname, a.atttypmod, \" + \"   a.attstattarget, a.attstorage, t.typstorage, \" + \"   a.atthasdef, a.attlen, a.attalign, a.attislocal, \" + \"   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, \" + \"   array_to_string(a.attoptions, ', ') AS attoptions, \" + \"   CASE WHEN a.attcollation <> t.typcollation \" + \"     THEN a.attcollation ELSE 0 END AS attcollation, \" + \"   a.attidentity, \" + \"   pg_catalog.array_to_string(ARRAY(\" + \"     SELECT pg_catalog.quote_ident(option_name) || \" + \"     ' ' || pg_catalog.quote_literal(option_value) \" + \"     FROM pg_catalog.pg_options_to_table(attfdwoptions) \" + \"     ORDER BY option_name\" + \"   ), E',\\n    ') AS attfdwoptions ,\" + \"   CASE WHEN a.atthasmissing AND NOT a.attisdropped \" + \"     THEN a.attmissingval ELSE null END AS attmissingval \" + \" FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t \" + \"   ON a.atttypid = t.oid \" + \" WHERE a.attrelid = ?::pg_catalog.oid \" + \"   AND a.attnum > 0::pg_catalog.int2 \" + \"   AND NOT a.attisdropped \" + \" ORDER BY a.attnum\");\n            PreparedStatement getDefaults = conn.prepareStatement(\"SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc \" + \" FROM pg_catalog.pg_attrdef \" + \" WHERE adrelid = ?::pg_catalog.oid \" + \" ORDER BY adnum\");\n            PreparedStatement getCheckConstrs = conn.prepareStatement(\"SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc,\" + \"   conislocal, convalidated\" + \" FROM pg_catalog.pg_constraint \" + \" WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'\" + \" ORDER BY conname\");\n            PreparedStatement getIndexes = conn.prepareStatement(\"SELECT t.relname AS indexname, \" + \"   inh.inhparent AS parentidx, \" + \"   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, \" + \"   i.indnkeyatts AS indnkeyatts, \" + \"   i.indnatts AS indnatts, \" + \"   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k \" + \"     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) \" + \"     AS indkey_colnames, \" + \"   i.indisclustered, \" + \"   i.indisreplident, i.indoption, t.relpages, \" + \"   c.contype, c.conname, \" + \"   c.condeferrable, c.condeferred, \" + \"   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, \" + \"   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)\" + \"     AS tablespace, \" + \"   t.reloptions AS indreloptions, \" + \"   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) \" + \"     FROM pg_catalog.pg_attribute \" + \"     WHERE attrelid = i.indexrelid AND \" + \"       attstattarget >= 0) AS indstatcols,\" + \"   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) \" + \"     FROM pg_catalog.pg_attribute \" + \"     WHERE attrelid = i.indexrelid AND \" + \"       attstattarget >= 0) AS indstatvals \" + \" FROM pg_catalog.pg_index i \" + \" JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) \" + \" JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) \" + \" LEFT JOIN pg_catalog.pg_constraint c \" + \"   ON (i.indrelid = c.conrelid AND \" + \"     i.indexrelid = c.conindid AND \" + \"     c.contype IN ('u','x')) \" + \" LEFT JOIN pg_catalog.pg_inherits inh \" + \"   ON (inh.inhrelid = indexrelid) \" + \" WHERE i.indrelid = ?::pg_catalog.oid \" + \"   AND (i.indisvalid OR t2.relkind = 'p') \" + \"   AND i.indisready \" + \"   AND i.indisprimary = false \" + \" ORDER BY indexname\");\n            PreparedStatement getForeignKeys = conn.prepareStatement(\"SELECT conname, confrelid, \" + \"   pg_catalog.pg_get_constraintdef(oid) AS condef \" + \" FROM pg_catalog.pg_constraint \" + \" WHERE conrelid = ?::pg_catalog.oid \" + \"  AND conparentid = 0 \" + \"  AND contype = 'f'\" + \" ORDER BY conname\");\n            PreparedStatement getTriggers = conn.prepareStatement(\"SELECT tgname, \" + \"   tgfoid::pg_catalog.regproc AS tgfname, \" + \"   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, \" + \"   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k \" + \"     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) \" + \"     AS tgattr_colnames, \" + \"   tgenabled \" + \" FROM pg_catalog.pg_trigger t \" + \" WHERE tgrelid = ?::pg_catalog.oid \" + \"   AND NOT tgisinternal\" + \" ORDER BY tgfname\");\n            List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);\n            assertTrue(\"Table with OID \" + oid + \" not found!\", pgClassRows.size() > 0);\n            this.pgClassRow = pgClassRows.get(0);\n            this.attrs = execCheckQuery(getAttrs, oid);\n            this.defaults = execCheckQuery(getDefaults, oid);\n            this.checkConstrs = execCheckQuery(getCheckConstrs, oid);\n            this.indexes = execCheckQuery(getIndexes, oid);\n            this.foreignKeys = execCheckQuery(getForeignKeys, oid);\n            this.triggers = execCheckQuery(getTriggers, oid);\n        }\n    }\n}\n", "class_id": 0, "repo": "nextgres/yugabyte-db", "file": "java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgAlterTableAddPrimaryKey.java", "last_update_at": "2021-06-14T23:51:05+00:00", "original_content": "@RunWith(value = YBTestRunnerNonTsanOnly.class)\npublic class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {\n\n    private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);\n\n    @Test\n    public void simplest() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n        }\n    }\n\n    @Test\n    public void duplicates() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, v int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 2)\");\n            // PG error in this case mentions \"nopk_pkey\", not just \"nopk\"\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", \"duplicate key value violates unique constraint \\\"nopk\\\"\");\n            stmt.executeUpdate(\"DELETE FROM nopk WHERE v = 2\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1)));\n        }\n    }\n\n    @Test\n    public void nulls() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (NULL)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", \"column \\\"id\\\" contains null values\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1), new Row((Object) null)));\n        }\n    }\n\n    @Test\n    public void columnTypes() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int[10][20], v2 text)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, new Integer[] { 1, 2, 3 }, \"qwe\"), new Row(2, new Integer[] { 3, 4 }, \"zxcv\")));\n        }\n    }\n\n    @Test\n    public void columnTypesUnsupported() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TYPE typeid AS (i int)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (id typeid, v int)\");\n            String msg = \"PRIMARY KEY containing column of type 'user_defined_type' not yet supported\";\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)\", msg);\n        }\n    }\n\n    @Test\n    public void missing() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            String msg = \"column \\\"missme\\\" named in key does not exist\";\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)\", msg);\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)\", msg);\n        }\n    }\n\n    @Test\n    public void complexPk() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, '111', '1', true)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '2', false)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, '222', '3', true)\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, '222', '2', false)\", \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY v1, v2, v3, v4\", Arrays.asList(new Row(1, \"111\", \"1\", true), new Row(2, \"222\", \"2\", false), new Row(2, \"222\", \"3\", true)));\n        }\n    }\n\n    @Test\n    public void pkInclude() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, v1 int, v2 int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 11, 111)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 22, 222)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id) INCLUDE (v1, v2)\");\n            // Scan is supposed to be index-only scan, but it's index scan for us.\n            {\n                String includeQuery = \"SELECT v1 FROM nopk WHERE id = 2\";\n                assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n                assertQuery(stmt, includeQuery, new Row(22));\n            }\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (3, 11, 111)\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (3, 99, 999)\", \"duplicate key value violates unique constraint \\\"nopk_pkey\\\"\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 11, 111), new Row(2, 22, 222), new Row(3, 11, 111)));\n            {\n                String includeQuery = \"SELECT v1 FROM nopk WHERE id = 3\";\n                assertTrue(isIndexScan(stmt, includeQuery, \"nopk_pkey\"));\n                assertQuery(stmt, includeQuery, new Row(11));\n            }\n        }\n    }\n\n    @Test\n    public void pkUsingIndex() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY\" + \" USING INDEX nopk_idx\", \"ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported\");\n        }\n    }\n\n    @Test\n    public void sequences() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \"id serial,\" + \"v1 int GENERATED ALWAYS AS IDENTITY,\" + \"v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10),\" + \"stuff text)\");\n            stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r1')\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 10, \"r1\")));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            stmt.executeUpdate(\"INSERT INTO nopk (stuff) VALUES ('r2')\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 10, \"r1\"), new Row(2, 2, 11, \"r2\")));\n        }\n    }\n\n    @Test\n    public void typedTable() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TYPE nopk_type AS (id int, v int)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk OF nopk_type\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 10)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 20)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 10), new Row(2, 20)));\n            runInvalidQuery(stmt, \"ALTER TABLE nopk DROP COLUMN v\", \"cannot drop column from typed table\");\n        }\n    }\n\n    // TODO(alex): Enable after INHERITS is supported in #1129\n    @Ignore\n    public void inheritedTable() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk_parent (id int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (1)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_parent VALUES (2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);\");\n            stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (3, 30)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_child VALUES (4, 40)\");\n            alterAddPrimaryKey(stmt, \"nopk_parent\", \"ADD PRIMARY KEY (id)\");\n            alterAddPrimaryKey(stmt, \"nopk_child\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk_parent ORDER BY id\", Arrays.asList(new Row(1), new Row(2)));\n            assertRowList(stmt, \"SELECT * FROM nopk_child ORDER BY id\", Arrays.asList(new Row(3, 30), new Row(4, 40)));\n        }\n    }\n\n    /**\n     * Adding PK to a partitioned table is not yet implemented.\n     */\n    @Test\n    public void partitionedTable() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part1 PARTITION OF nopk_whole\" + \" FOR VALUES IN (1, 2, 3)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part2 PARTITION OF nopk_whole\" + \" FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2\" + \" FOR VALUES IN (10, 20)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2\" + \" FOR VALUES IN (30, 40)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_whole ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)\", \"adding primary key to a partitioned table is not yet implemented\");\n        }\n    }\n\n    @Test\n    public void tablesInColocatedDb() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE DATABASE clc WITH colocated = true\");\n        }\n        try (Connection conn2 = getConnectionBuilder().withDatabase(\"clc\").connect();\n            Statement stmt = conn2.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_c (id int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (3)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_c VALUES (4)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk_nc (id int) WITH (colocated = false)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (5)\");\n            stmt.executeUpdate(\"INSERT INTO nopk_nc VALUES (6)\");\n            assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n            assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n            assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n            // See #6159\n            alterAddPrimaryKey(stmt, \"nopk_c\", \"ADD PRIMARY KEY (id)\");\n            alterAddPrimaryKey(stmt, \"nopk_nc\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(new Row(1), new Row(2)));\n            assertRowList(stmt, \"SELECT * FROM nopk_c ORDER BY id\", Arrays.asList(new Row(3), new Row(4)));\n            assertRowList(stmt, \"SELECT * FROM nopk_nc ORDER BY id\", Arrays.asList(new Row(5), new Row(6)));\n            assertEquals(1, getNumTablets(\"clc\", \"normal_table\"));\n            assertEquals(1, getNumTablets(\"clc\", \"nopk_c\"));\n            assertEquals(NUM_TABLET_SERVERS, getNumTablets(\"clc\", \"nopk_nc\"));\n        }\n    }\n\n    @Test\n    public void tablesInTablegroup() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"CREATE TABLE normal_table (id int PRIMARY KEY)\" + \" TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (1)\");\n            stmt.executeUpdate(\"INSERT INTO normal_table VALUES (2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\" + \" TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (3)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (4)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk2 (id int, id2 int unique)\" + \" TABLEGROUP tgroup1\");\n            stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (5, 5)\");\n            stmt.executeUpdate(\"INSERT INTO nopk2 VALUES (6, 6)\");\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            alterAddPrimaryKey(stmt, \"nopk2\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM normal_table ORDER BY id\", Arrays.asList(new Row(1), new Row(2)));\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(3), new Row(4)));\n            assertRowList(stmt, \"SELECT * FROM nopk2 ORDER BY id\", Arrays.asList(new Row(5, 5), new Row(6, 6)));\n            assertRowList(stmt, \"SELECT s.relname, pg_tablegroup.grpname \" + \"FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) \" + \"s, pg_tablegroup WHERE opts LIKE \" + \"CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') \" + \"ORDER BY s\", Arrays.asList(new Row(\"nopk\", \"tgroup1\"), new Row(\"nopk2\", \"tgroup1\"), new Row(\"nopk2_id2_key\", \"tgroup1\"), new Row(\"nopk2_pkey\", \"tgroup1\"), new Row(\"nopk_pkey\", \"tgroup1\"), new Row(\"normal_table\", \"tgroup1\"), new Row(\"normal_table_pkey\", \"tgroup1\")));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"normal_table\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, \"nopk2\"));\n        }\n    }\n\n    @Test\n    public void defaults() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int DEFAULT 10, \" + \" drop_me int DEFAULT 10, \" + \" v int DEFAULT 10\" + \")\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1)));\n            stmt.executeUpdate(\"INSERT INTO nopk (id) VALUES (2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1), new Row(2, 10)));\n            stmt.executeUpdate(\"INSERT INTO nopk (v) VALUES (2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1), new Row(2, 10), new Row(10, 2)));\n        }\n    }\n\n    @Test\n    public void notNullAndCheck() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int CHECK (id > 0),\" + \" drop_me int,\" + \" v1 int CHECK (v1 > 0),\" + \" v2 int NOT NULL\" + \")\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (0, 2, 2)\", \"violates check constraint \\\"nopk_id_check\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 0, 2)\", \"violates check constraint \\\"nopk_v1_check\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, NULL)\", \"violates not-null constraint\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1)));\n        }\n    }\n\n    /**\n     * Altered table references a FK table.\n     */\n    @Test\n    public void foreignKeys() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON fk_ref_table (v, id)\");\n            stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (1, 1)\");\n            stmt.executeUpdate(\"INSERT INTO fk_ref_table VALUES (2, 2)\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int,\" + \" fk1 int REFERENCES fk_ref_table (id),\" + \" drop_me int,\" + \" fk2 int REFERENCES fk_ref_table (v),\" + \" fk3 int)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)\" + \" REFERENCES fk_ref_table (v, id)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1)\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 20, 2, 2)\", \"violates foreign key constraint \\\"nopk_fk1_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 20, 2)\", \"violates foreign key constraint \\\"nopk_fk2_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 2, 20)\", \"violates foreign key constraint \\\"nopk_fk2_fkey1\\\"\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1), new Row(2, 2, 2, 2)));\n            runInvalidQuery(stmt, \"DELETE FROM fk_ref_table WHERE id = 1\", \"violates foreign key constraint \\\"nopk_fk1_fkey\\\" on table \\\"nopk\\\"\");\n        }\n    }\n\n    /**\n     * Altered table itself is referenced through FK constraints from other table.\n     */\n    @Test\n    public void foreignKeys2() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v)\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v, id)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            stmt.executeUpdate(\"CREATE TABLE referencing_table (\" + \" id int PRIMARY KEY,\" + \" fk1 int REFERENCES nopk (id),\" + \" drop_me int,\" + \" fk2 int REFERENCES nopk (v),\" + \" fk3 int)\");\n            stmt.executeUpdate(\"ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)\" + \" REFERENCES nopk (v, id)\");\n            stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)\");\n            stmt.executeUpdate(\"ALTER TABLE referencing_table DROP COLUMN drop_me\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1), new Row(2, 2)));\n            assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 20, 2, 2)\", \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 20, 2)\", \"violates foreign key constraint \\\"referencing_table_fk2_fkey\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO referencing_table VALUES (2, 2, 2, 20)\", \"violates foreign key constraint \\\"referencing_table_fk2_fkey1\\\"\");\n            stmt.executeUpdate(\"INSERT INTO referencing_table VALUES (2, 2, 2, 2)\");\n            assertRowList(stmt, \"SELECT * FROM referencing_table ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1), new Row(2, 2, 2, 2)));\n            runInvalidQuery(stmt, \"DELETE FROM nopk WHERE id = 1\", \"violates foreign key constraint \\\"referencing_table_fk1_fkey\\\"\" + \" on table \\\"referencing_table\\\"\");\n        }\n    }\n\n    @Test\n    public void otherConstraintsAndIndexes() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.\n            runInvalidQuery(stmt, \"CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))\", \"EXCLUDE constraint not supported yet\");\n            stmt.executeUpdate(\"CREATE TABLE nopk (\" + \" id int,\" + \" v1 int UNIQUE,\" + \" drop_me int,\" + \" v2 int,\" + \" v3 int,\" + \" v4 int\" + \")\");\n            stmt.executeUpdate(\"CREATE UNIQUE INDEX ON nopk (v2)\");\n            stmt.executeUpdate(\"CREATE INDEX ON nopk (v3)\");\n            stmt.executeUpdate(\"CREATE INDEX ON nopk ((v4 * 2))\");\n            stmt.executeUpdate(\"CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)\");\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            String v3query = \"SELECT v3 FROM nopk WHERE v3 = 1\";\n            String v4query = \"SELECT v4 FROM nopk WHERE v4 * 2 = 2\";\n            assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n            assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1, 1)));\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 1, 2, 2, 2)\", \"violates unique constraint \\\"nopk_v1_key\\\"\");\n            runInvalidQuery(stmt, \"INSERT INTO nopk VALUES (2, 2, 1, 2, 2)\", \"violates unique constraint \\\"nopk_v2_idx\\\"\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (2, 2, 2, 1, 2)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1, 1, 1, 1), new Row(2, 2, 2, 1, 2)));\n            assertTrue(isIndexOnlyScan(stmt, v3query, \"nopk_v3_idx\"));\n            assertRowList(stmt, v3query, Arrays.asList(new Row(1), new Row(1)));\n            assertTrue(isIndexScan(stmt, v4query, \"nopk_expr_idx\"));\n            assertRowList(stmt, v4query, Arrays.asList(new Row(1)));\n        }\n    }\n\n    @Test\n    public void triggers() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int, drop_me int, v int)\");\n            stmt.executeUpdate(\"INSERT INTO nopk VALUES (1, 1, 1)\");\n            stmt.executeUpdate(\"CREATE FUNCTION notice_on_trigger() RETURNS trigger\" + \" LANGUAGE plpgsql\" + \" AS $$\" + \"   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;\" + \"   RETURN NEW;\" + \"   END;\" + \" $$;\");\n            for (String timing : Arrays.asList(\"before\", \"after\")) {\n                for (String scope : Arrays.asList(\"statement\", \"row\")) {\n                    for (String action : Arrays.asList(\"insert\", \"update\", \"delete\")) {\n                        stmt.executeUpdate(MessageFormat.format(\"CREATE TRIGGER nopk__{0}_{2}_{1}\" + \" {0} {2} ON nopk\" + \" FOR EACH {1}\" + \" EXECUTE PROCEDURE notice_on_trigger()\", timing, scope, action));\n                    }\n                    String whenExpr = scope.equals(\"row\") ? \"OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0\" : \"RANDOM() >= 0\";\n                    stmt.executeUpdate(MessageFormat.format(\"CREATE TRIGGER nopk__{0}_update_c_{1}\" + \" {0} UPDATE OF id, v ON nopk\" + \" FOR EACH {1}\" + \" WHEN (\" + whenExpr + \")\" + \" EXECUTE PROCEDURE notice_on_trigger()\", timing, scope));\n                }\n            }\n            stmt.executeUpdate(\"ALTER TABLE nopk DROP COLUMN drop_me\");\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertRowList(stmt, \"SELECT * FROM nopk ORDER BY id\", Arrays.asList(new Row(1, 1)));\n        }\n    }\n\n    @Test\n    public void secondPk() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int PRIMARY KEY)\");\n            runInvalidQuery(stmt, \"ALTER TABLE nopk ADD PRIMARY KEY (id)\", \"multiple primary keys for table \\\"nopk\\\" are not allowed\");\n        }\n    }\n\n    @Test\n    public void splitInto() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS\");\n            assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, \"nopk\"));\n        }\n    }\n\n    @Test\n    public void roles() throws Exception {\n        try (Statement stmt = connection.createStatement()) {\n            stmt.executeUpdate(\"CREATE TABLE nopk (id int)\");\n            stmt.executeUpdate(\"CREATE ROLE new_user\");\n            stmt.executeUpdate(\"ALTER TABLE nopk OWNER TO new_user\");\n            assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\", new Row(\"new_user\"));\n            alterAddPrimaryKey(stmt, \"nopk\", \"ADD PRIMARY KEY (id)\");\n            assertQuery(stmt, \"SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'\", new Row(\"new_user\"));\n        }\n    }\n\n    /**\n     * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).\n     * <p>\n     * Source was a real output from pg_dump in its default configuration.\n     */\n    @Test\n    public void restorePgDump() throws Exception {\n        URL sqlFileRes = getClass().getClassLoader().getResource(\"TestPgAlterTableAddPrimaryKey/restorePgDump.sql\");\n        assertTrue(\"Dump SQL resource not found!\", sqlFileRes != null);\n        File sqlFile = new File(sqlFileRes.getFile());\n        String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), \"ysqlsh\").getAbsolutePath();\n        ProcessBuilder procBuilder = new ProcessBuilder(ysqlshPath, \"-h\", getPgHost(0), \"-p\", Integer.toString(getPgPort(0)), DEFAULT_PG_DATABASE);\n        procBuilder.redirectInput(sqlFile);\n        List<String> output = runProcess(procBuilder);\n        // Sanity checks.\n        assertTrue(output.size() > 0);\n        assertFalse(\"There was an error executing SQL: \" + output, StringUtils.join(output, '\\n').toLowerCase().contains(\"error\"));\n        try (Statement stmt = connection.createStatement()) {\n            assertRowList(stmt, \"SELECT * FROM public.with_constraints_and_such ORDER BY id\", Arrays.asList(new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111), new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222), new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));\n        }\n    }\n\n    /**\n     * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.\n     */\n    private void alterAddPrimaryKey(Statement stmt, String tableName, String alterSpec) throws Exception {\n        String countPgClass = \"SELECT COUNT(*) FROM pg_class\";\n        String getTableNames = \"SELECT table_name FROM information_schema.tables\" + \" WHERE table_schema = 'public' ORDER BY table_name\";\n        String getOid = \"SELECT oid FROM pg_class WHERE relname = '\" + tableName + \"'\";\n        // We're also selecting owning_tab_name instead of owning_tab OID.\n        String getSequences = \"SELECT c.oid, c.relname, \" + \"     c.relkind, c.relnamespace, \" + \"     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, \" + \"     c.relchecks, c.relhastriggers, \" + \"     c.relhasindex, c.relhasrules, c.relhasoids, \" + \"     c.relrowsecurity, c.relforcerowsecurity, \" + \"     c.relfrozenxid, c.relminmxid, tc.oid AS toid, \" + \"     tc.relfrozenxid AS tfrozenxid, \" + \"     tc.relminmxid AS tminmxid, \" + \"     c.relpersistence, c.relispopulated, \" + \"     c.relreplident, c.relpages, \" + \"     CASE WHEN c.reloftype <> 0\" + \"       THEN c.reloftype::pg_catalog.regtype ELSE NULL END\" + \"     AS reloftype, \" + \"     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, \" + \"     d.refobjsubid AS owning_col, \" + \"     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)\" + \"       AS reltablespace, \" + \"     array_remove(array_remove(c.reloptions,'check_option=local'),\" + \"                  'check_option=cascaded')\" + \"     AS reloptions, \" + \"     CASE\" + \"       WHEN 'check_option=local' = ANY (c.reloptions)\" + \"         THEN 'LOCAL'::text \" + \"       WHEN 'check_option=cascaded' = ANY (c.reloptions)\" + \"         THEN 'CASCADED'::text ELSE NULL END\" + \"     AS checkoption, \" + \"     tc.reloptions AS toast_reloptions, \" + \"     c.relkind = 'S' AND EXISTS (\" + \"       SELECT 1 FROM pg_depend\" + \"       WHERE classid = 'pg_class'::regclass\" + \"         AND objid = c.oid\" + \"         AND objsubid = 0\" + \"         AND refclassid = 'pg_class'::regclass\" + \"         AND deptype = 'i'\" + \"     ) AS is_identity_sequence\" + \" FROM pg_class c \" + \" LEFT JOIN pg_depend d\" + \"   ON (c.relkind = 'S' AND d.classid = c.tableoid AND\" + \"     d.objid = c.oid AND d.objsubid = 0 AND \" + \"     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) \" + \" LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) \" + \" LEFT JOIN pg_init_privs pip\" + \"   ON (c.oid = pip.objoid AND\" + \"     pip.classoid = 'pg_class'::regclass AND\" + \"     pip.objsubid = 0) \" + \" WHERE c.relkind in ('S') \" + \" ORDER BY c.oid\";\n        long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n        long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);\n        List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));\n        List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));\n        PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);\n        stmt.executeUpdate(\"ALTER TABLE \" + tableName + \" \" + alterSpec);\n        // OID has changed, but the pg_class row content did not.\n        long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);\n        assertNotEquals(oldOid, newOid);\n        // There's one more index in the pool now.\n        assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));\n        // Everything else should remain as it was.\n        assertRowList(stmt, getTableNames, oldTableNames);\n        assertRowList(stmt, getSequences, oldSequences);\n        PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);\n        assertPgStateEquals(oldState, newState);\n    }\n\n    private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {\n        ps.setLong(1, oid);\n        return getRowList(ps.executeQuery());\n    }\n\n    private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {\n        assertRow(oldState.pgClassRow, newState.pgClassRow);\n        assertRows(oldState.attrs, newState.attrs);\n        assertRows(oldState.defaults, newState.defaults);\n        assertRows(oldState.checkConstrs, newState.checkConstrs);\n        assertRows(oldState.indexes, newState.indexes);\n        assertRows(oldState.foreignKeys, newState.foreignKeys);\n        assertRows(oldState.triggers, newState.triggers);\n    }\n\n    private int getNumTablets(String databaseName, String tableName) throws Exception {\n        List<String> lines = runProcess(TestUtils.findBinary(\"yb-admin\"), \"--master_addresses\", masterAddresses, \"list_tablets\", \"ysql.\" + databaseName, tableName);\n        // We don't care about the output, just number of lines (minus header line).\n        return lines.size() - 1;\n    }\n\n    private class PgSystemTableInfo {\n\n        Row pgClassRow;\n\n        List<Row> attrs;\n\n        List<Row> defaults;\n\n        List<Row> checkConstrs;\n\n        List<Row> indexes;\n\n        List<Row> foreignKeys;\n\n        List<Row> triggers;\n\n        public PgSystemTableInfo(Connection conn, long oid) throws Exception {\n            // relnatts (because it includes dropped attributes).\n            PreparedStatement getPgClassRow = conn.prepareStatement(\"SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages,\" + \"   reltuples, relallvisible, reltoastrelid, relisshared,\" + \"   relpersistence, relkind, relchecks, relhasoids, relhasrules,\" + \"   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity,\" + \"   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid,\" + \"   relminmxid, relacl\" + \" FROM pg_class WHERE oid = ?\");\n            //  * Added ORDER BY to all queries.\n            PreparedStatement getAttrs = conn.prepareStatement(\"SELECT a.attname, a.atttypmod, \" + \"   a.attstattarget, a.attstorage, t.typstorage, \" + \"   a.atthasdef, a.attlen, a.attalign, a.attislocal, \" + \"   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, \" + \"   array_to_string(a.attoptions, ', ') AS attoptions, \" + \"   CASE WHEN a.attcollation <> t.typcollation \" + \"     THEN a.attcollation ELSE 0 END AS attcollation, \" + \"   a.attidentity, \" + \"   pg_catalog.array_to_string(ARRAY(\" + \"     SELECT pg_catalog.quote_ident(option_name) || \" + \"     ' ' || pg_catalog.quote_literal(option_value) \" + \"     FROM pg_catalog.pg_options_to_table(attfdwoptions) \" + \"     ORDER BY option_name\" + \"   ), E',\\n    ') AS attfdwoptions ,\" + \"   CASE WHEN a.atthasmissing AND NOT a.attisdropped \" + \"     THEN a.attmissingval ELSE null END AS attmissingval \" + \" FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t \" + \"   ON a.atttypid = t.oid \" + \" WHERE a.attrelid = ?::pg_catalog.oid \" + \"   AND a.attnum > 0::pg_catalog.int2 \" + \"   AND NOT a.attisdropped \" + \" ORDER BY a.attnum\");\n            PreparedStatement getDefaults = conn.prepareStatement(\"SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc \" + \" FROM pg_catalog.pg_attrdef \" + \" WHERE adrelid = ?::pg_catalog.oid \" + \" ORDER BY adnum\");\n            PreparedStatement getCheckConstrs = conn.prepareStatement(\"SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc,\" + \"   conislocal, convalidated\" + \" FROM pg_catalog.pg_constraint \" + \" WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'\" + \" ORDER BY conname\");\n            PreparedStatement getIndexes = conn.prepareStatement(\"SELECT t.relname AS indexname, \" + \"   inh.inhparent AS parentidx, \" + \"   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, \" + \"   i.indnkeyatts AS indnkeyatts, \" + \"   i.indnatts AS indnatts, \" + \"   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k \" + \"     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) \" + \"     AS indkey_colnames, \" + \"   i.indisclustered, \" + \"   i.indisreplident, i.indoption, t.relpages, \" + \"   c.contype, c.conname, \" + \"   c.condeferrable, c.condeferred, \" + \"   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, \" + \"   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)\" + \"     AS tablespace, \" + \"   t.reloptions AS indreloptions, \" + \"   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) \" + \"     FROM pg_catalog.pg_attribute \" + \"     WHERE attrelid = i.indexrelid AND \" + \"       attstattarget >= 0) AS indstatcols,\" + \"   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) \" + \"     FROM pg_catalog.pg_attribute \" + \"     WHERE attrelid = i.indexrelid AND \" + \"       attstattarget >= 0) AS indstatvals \" + \" FROM pg_catalog.pg_index i \" + \" JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) \" + \" JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) \" + \" LEFT JOIN pg_catalog.pg_constraint c \" + \"   ON (i.indrelid = c.conrelid AND \" + \"     i.indexrelid = c.conindid AND \" + \"     c.contype IN ('u','x')) \" + \" LEFT JOIN pg_catalog.pg_inherits inh \" + \"   ON (inh.inhrelid = indexrelid) \" + \" WHERE i.indrelid = ?::pg_catalog.oid \" + \"   AND (i.indisvalid OR t2.relkind = 'p') \" + \"   AND i.indisready \" + \"   AND i.indisprimary = false \" + \" ORDER BY indexname\");\n            PreparedStatement getForeignKeys = conn.prepareStatement(\"SELECT conname, confrelid, \" + \"   pg_catalog.pg_get_constraintdef(oid) AS condef \" + \" FROM pg_catalog.pg_constraint \" + \" WHERE conrelid = ?::pg_catalog.oid \" + \"  AND conparentid = 0 \" + \"  AND contype = 'f'\" + \" ORDER BY conname\");\n            PreparedStatement getTriggers = conn.prepareStatement(\"SELECT tgname, \" + \"   tgfoid::pg_catalog.regproc AS tgfname, \" + \"   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, \" + \"   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k \" + \"     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) \" + \"     AS tgattr_colnames, \" + \"   tgenabled \" + \" FROM pg_catalog.pg_trigger t \" + \" WHERE tgrelid = ?::pg_catalog.oid \" + \"   AND NOT tgisinternal\" + \" ORDER BY tgfname\");\n            List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);\n            assertTrue(\"Table with OID \" + oid + \" not found!\", pgClassRows.size() > 0);\n            this.pgClassRow = pgClassRows.get(0);\n            this.attrs = execCheckQuery(getAttrs, oid);\n            this.defaults = execCheckQuery(getDefaults, oid);\n            this.checkConstrs = execCheckQuery(getCheckConstrs, oid);\n            this.indexes = execCheckQuery(getIndexes, oid);\n            this.foreignKeys = execCheckQuery(getForeignKeys, oid);\n            this.triggers = execCheckQuery(getTriggers, oid);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "469ab8b8135d229de2f22682bfe1f823e382cb62", "ext": "java", "lang": "Java", "content": "public class BaseKnowledgeManagerTest {\n\n    private BaseKnowledgeManager tested;\n\n    @Mock\n    private TriggerListener triggerListener;\n\n    @Before\n    public void setUp() throws Exception {\n        tested = new BaseKnowledgeManager(\"TEST\", null, null);\n        tested.update(createKnowledge());\n        initMocks(this);\n    }\n\n    public static ChangeSet createKnowledge() {\n        ChangeSet result = new ChangeSet();\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"id\"), \"Test\");\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"number\"), 10);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"mapKeyInner\"), \"x\");\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"date\"), null);\n        List<Integer> list = new LinkedList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"list\"), list);\n        Map<String, Integer> map = new HashMap<String, Integer>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n        map.put(\"c\", 3);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"map\"), map);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), new InnerKnowledge(\"innerA\", \"innerB\"));\n        Map<String, String> mapNested = new HashMap<>();\n        mapNested.put(\"x\", \"a\");\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"mapNested\"), mapNested);\n        return result;\n    }\n\n    @Test\n    public void testUpdateIntegerField() throws Exception {\n        // and as a ChangeSet, the update for the 'number' field is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 17);\n        tested.update(toUpdate, \"X\");\n        // return updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(17, result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n    }\n\n    @Test\n    public void testInnerKnowledgeUpdate() throws Exception {\n        // and as a ChangeSet, the update for some nested inner field is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, \"innerAModified\");\n        tested.update(toUpdate, \"X\");\n        // return updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(\"innerAModified\", result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n        assertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\")));\n    }\n\n    @Test\n    public void testUpdateListField() throws Exception {\n        // and as a ChangeSet, the update for one of the 'list' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 4);\n        tested.update(toUpdate, \"X\");\n        // updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(4, result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n        assertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"list\")));\n    }\n\n    @Test\n    public void testUpdateMapField() throws Exception {\n        // and as a ChangeSet, the update for one of the 'map' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 16);\n        tested.update(toUpdate, \"X\");\n        // updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(16, result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n        assertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"map\")));\n    }\n\n    @Test\n    public void testRemovalFromList() throws Exception {\n        // and as a ChangeSet, the removal of one of the 'list' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        Object nextItemValue = tested.get(knowledgePaths).getValue(kp);\n        kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n        knowledgePaths.clear();\n        knowledgePaths.add(kp);\n        ChangeSet toDelete = new ChangeSet();\n        toDelete.setDeleted(kp);\n        tested.update(toDelete);\n        // the value of the next item\n        assertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));\n    }\n\n    @Test(expected = KnowledgeNotFoundException.class)\n    public void testDeleteFromMap() throws Exception {\n        // passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toDelete = new ChangeSet();\n        toDelete.setDeleted(kp);\n        tested.update(toDelete);\n        // should throw the KnowledgeNotExistentException\n        tested.get(knowledgePaths);\n    }\n\n    @Test\n    public void testGetIntegerField() throws Exception {\n        // WHEN a field is accessed from the ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(10, result.getValue(kp));\n    }\n\n    @Test\n    public void testInnerKnowledgeGet() throws Exception {\n        // WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(\"innerA\", result.getValue(kp));\n    }\n\n    @Test(expected = KnowledgeNotFoundException.class)\n    public void testNullBaseKnowledgeAccess() throws Exception {\n        tested = new BaseKnowledgeManager(\"TEST\", null, null);\n        // null base knowledge\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        // THEN exception is thrown.\n        tested.get(knowledgePaths);\n    }\n\n    @Test\n    public void testGetListField() throws Exception {\n        // WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(3, result.getValue(kp));\n    }\n\n    @Test\n    public void testGetMapField() throws Exception {\n        // ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(1, result.getValue(kp));\n    }\n\n    @Test(expected = KnowledgeNotFoundException.class)\n    public void testNotExsistentAccess() throws Exception {\n        // ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"dummy\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        // KnowledgeNotExistentException\n        tested.get(knowledgePaths);\n    }\n\n    @Test\n    public void testRegisterListener() throws Exception {\n        // WHEN a listener is registered at the KnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        KnowledgeChangeTrigger trigger = RuntimeModelHelper.createKnowledgeChangeTrigger();\n        trigger.setKnowledgePath(kp);\n        tested.register(trigger, triggerListener);\n        // and WHEN listener's releavant knowledge is updated\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 17);\n        tested.update(toUpdate);\n        // THEN the listener is notify once.\n        verify(triggerListener).triggered(trigger);\n        verifyNoMoreInteractions(triggerListener);\n    }\n\n    @Test\n    public void testUnregisterListener() throws Exception {\n        // WHEN a previously registered listener\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        KnowledgeChangeTrigger trigger = RuntimeModelHelper.createKnowledgeChangeTrigger();\n        trigger.setKnowledgePath(kp);\n        tested.register(trigger, triggerListener);\n        // is unregistered from the KnowledgeManager\n        tested.register(trigger, triggerListener);\n        // THEN it is not notified about knowledge changes any more\n        verifyNoMoreInteractions(triggerListener);\n    }\n\n    @Test\n    public void testGetRootKnowledge() throws Exception {\n        // WHEN empty knowledge path is created\n        KnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(emptyKP);\n        // and WHEN it is used to access knowledge manager data\n        ValueSet result = tested.get(knowledgePaths);\n        // knowledge\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"id\");\n        assertTrue(result.getKnowledgePaths().contains(kp));\n        kp = RuntimeModelHelper.createKnowledgePath(\"date\");\n        assertTrue(result.getKnowledgePaths().contains(kp));\n    }\n\n    public void testForbiddenUpdate() throws Exception {\n        // removal and number field update and incorrect inner knowledge change\n        KnowledgePath numberPath = RuntimeModelHelper.createKnowledgePath(\"number\");\n        KnowledgePath listElementPath = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n        KnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        ChangeSet toChange = new ChangeSet();\n        toChange.setValue(numberPath, 100);\n        toChange.setValue(innerPath, 66);\n        toChange.setDeleted(listElementPath);\n        boolean exceptionThrown = false;\n        try {\n            tested.update(toChange, \"update_author\");\n        } catch (KnowledgeUpdateException e) {\n            exceptionThrown = true;\n        }\n        // THEN the KnowledgeUpdateException is thrown\n        assertTrue(exceptionThrown);\n        KnowledgePath listPath = RuntimeModelHelper.createKnowledgePath(\"list\");\n        List<KnowledgePath> listOfPaths = new LinkedList<>();\n        // and THEN list remains unchanged\n        listOfPaths.add(listPath);\n        assertEquals(3, ((List<?>) tested.get(listOfPaths).getValue(listPath)).size());\n        listOfPaths.clear();\n        // and THEN inner knowledge has its original value\n        listOfPaths.add(innerPath);\n        assertEquals(\"innerA\", tested.get(listOfPaths).getValue(innerPath));\n        listOfPaths.clear();\n        // and THEN number field has its original value\n        listOfPaths.add(numberPath);\n        assertEquals(10, tested.get(listOfPaths).getValue(numberPath));\n        // then authors of knowledge remain the same\n        assertEquals(\"TEST\", tested.getAuthor(numberPath));\n        assertEquals(\"TEST\", tested.getAuthor(listElementPath));\n        assertEquals(\"TEST\", tested.getAuthor(innerPath));\n    }\n\n    @Test\n    public void securityTagsTest() {\n        // given single-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n        KnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n        tag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n        tag.getRequiredRole().setRoleName(\"role\");\n        Collection<SecurityTag> expectedTags = Arrays.asList(tag);\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n        // when security tags are then retrieved\n        KnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n        List<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n        // then collections are equal\n        assertEquals(expectedTags, actualTags);\n    }\n\n    @Test\n    public void addSecurityTagsTest() {\n        // given single-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n        KnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n        tag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n        tag.getRequiredRole().setRoleName(\"role\");\n        Collection<SecurityTag> expectedTags = Arrays.asList(tag);\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n        tested.addSecurityTag(kp, tag);\n        // when security tags are then retrieved\n        KnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n        List<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n        // then collections are equal\n        assertEquals(2, actualTags.size());\n        assertEquals(tag, actualTags.get(0));\n        assertEquals(tag, actualTags.get(1));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void markAsSecured_MultiNodePathTest() {\n        // given multi-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\", \"inner\");\n        Collection<SecurityTag> expectedTags = Arrays.asList();\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void markAsSecured_IdPathTest() {\n        // given single-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath();\n        kp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());\n        Collection<SecurityTag> expectedTags = Arrays.asList();\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n    }\n\n    @Test\n    public void getAuthorTest1() {\n        // given basic knowledge is created\n        KnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        KnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\");\n        // when nested path is used and getAuthor() called\n        String innerAuthor = tested.getAuthor(nestedPath);\n        String outerAuthor = tested.getAuthor(basicPath);\n        // then author is returned\n        assertEquals(\"TEST\", innerAuthor);\n        assertEquals(\"TEST\", outerAuthor);\n        // then knowledge paths remain intact\n        assertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\"), nestedPath);\n        assertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), basicPath);\n    }\n\n    @Test\n    public void getAuthorTest2() {\n        // given basic knowledge is created\n        KnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath(\"non\", \"existent\", \"path\");\n        // when getAuthor() is called\n        String author = tested.getAuthor(nonExistentPath);\n        // then null is returned\n        assertNull(author);\n    }\n\n    @Test\n    public void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n        // and as a ChangeSet, the update for one of the 'map' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 16);\n        tested.update(toUpdate, \"X\");\n        // WHEN the 'map' itself is then updated by a different author\n        KnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n        List<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n        knowledgePaths2.add(kp2);\n        ChangeSet toUpdate2 = new ChangeSet();\n        toUpdate2.setValue(kp2, new HashMap<>());\n        tested.update(toUpdate2, \"Y\");\n        // THEN author of the 'map' and the 'map.a' is set to Y\n        assertEquals(\"Y\", tested.getAuthor(kp2));\n        assertEquals(\"Y\", tested.getAuthor(kp));\n    }\n\n    @Test\n    public void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n        // and as a ChangeSet, the update for one of the 'map' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 16);\n        tested.update(toUpdate, \"X\");\n        // WHEN the 'map' itself is then deleted\n        KnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n        List<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n        knowledgePaths2.add(kp2);\n        ChangeSet toUpdate2 = new ChangeSet();\n        toUpdate2.setDeleted(kp2);\n        tested.update(toUpdate2, \"Y\");\n        // THEN author of the 'map' and the 'map.a' is null\n        assertNull(tested.getAuthor(kp2));\n        assertNull(tested.getAuthor(kp));\n    }\n\n    public static class InnerKnowledge {\n\n        public String a;\n\n        public String b;\n\n        public InnerKnowledge(String a, String b) {\n            super();\n            this.a = a;\n            this.b = b;\n        }\n    }\n}\n", "class_id": 0, "repo": "d3scomp/JDEECo", "file": "jdeeco-core/test/cz/cuni/mff/d3s/deeco/knowledge/BaseKnowledgeManagerTest.java", "last_update_at": "2021-09-22T12:46:58+00:00", "original_content": "public class BaseKnowledgeManagerTest {\n\n    private BaseKnowledgeManager tested;\n\n    @Mock\n    private TriggerListener triggerListener;\n\n    @Before\n    public void setUp() throws Exception {\n        tested = new BaseKnowledgeManager(\"TEST\", null, null);\n        tested.update(createKnowledge());\n        initMocks(this);\n    }\n\n    public static ChangeSet createKnowledge() {\n        ChangeSet result = new ChangeSet();\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"id\"), \"Test\");\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"number\"), 10);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"mapKeyInner\"), \"x\");\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"date\"), null);\n        List<Integer> list = new LinkedList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"list\"), list);\n        Map<String, Integer> map = new HashMap<String, Integer>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n        map.put(\"c\", 3);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"map\"), map);\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), new InnerKnowledge(\"innerA\", \"innerB\"));\n        Map<String, String> mapNested = new HashMap<>();\n        mapNested.put(\"x\", \"a\");\n        result.setValue(RuntimeModelHelper.createKnowledgePath(\"mapNested\"), mapNested);\n        return result;\n    }\n\n    @Test\n    public void testUpdateIntegerField() throws Exception {\n        // and as a ChangeSet, the update for the 'number' field is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 17);\n        tested.update(toUpdate, \"X\");\n        // return updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(17, result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n    }\n\n    @Test\n    public void testInnerKnowledgeUpdate() throws Exception {\n        // and as a ChangeSet, the update for some nested inner field is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, \"innerAModified\");\n        tested.update(toUpdate, \"X\");\n        // return updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(\"innerAModified\", result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n        assertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\")));\n    }\n\n    @Test\n    public void testUpdateListField() throws Exception {\n        // and as a ChangeSet, the update for one of the 'list' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 4);\n        tested.update(toUpdate, \"X\");\n        // updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(4, result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n        assertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"list\")));\n    }\n\n    @Test\n    public void testUpdateMapField() throws Exception {\n        // and as a ChangeSet, the update for one of the 'map' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 16);\n        tested.update(toUpdate, \"X\");\n        // updated value\n        ValueSet result = tested.get(knowledgePaths);\n        assertEquals(16, result.getValue(kp));\n        assertEquals(\"X\", tested.getAuthor(kp));\n        assertEquals(\"TEST\", tested.getAuthor(RuntimeModelHelper.createKnowledgePath(\"map\")));\n    }\n\n    @Test\n    public void testRemovalFromList() throws Exception {\n        // and as a ChangeSet, the removal of one of the 'list' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        Object nextItemValue = tested.get(knowledgePaths).getValue(kp);\n        kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n        knowledgePaths.clear();\n        knowledgePaths.add(kp);\n        ChangeSet toDelete = new ChangeSet();\n        toDelete.setDeleted(kp);\n        tested.update(toDelete);\n        // the value of the next item\n        assertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));\n    }\n\n    @Test(expected = KnowledgeNotFoundException.class)\n    public void testDeleteFromMap() throws Exception {\n        // passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toDelete = new ChangeSet();\n        toDelete.setDeleted(kp);\n        tested.update(toDelete);\n        // should throw the KnowledgeNotExistentException\n        tested.get(knowledgePaths);\n    }\n\n    @Test\n    public void testGetIntegerField() throws Exception {\n        // WHEN a field is accessed from the ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(10, result.getValue(kp));\n    }\n\n    @Test\n    public void testInnerKnowledgeGet() throws Exception {\n        // WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(\"innerA\", result.getValue(kp));\n    }\n\n    @Test(expected = KnowledgeNotFoundException.class)\n    public void testNullBaseKnowledgeAccess() throws Exception {\n        tested = new BaseKnowledgeManager(\"TEST\", null, null);\n        // null base knowledge\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        // THEN exception is thrown.\n        tested.get(knowledgePaths);\n    }\n\n    @Test\n    public void testGetListField() throws Exception {\n        // WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"list\", \"2\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(3, result.getValue(kp));\n    }\n\n    @Test\n    public void testGetMapField() throws Exception {\n        // ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ValueSet result = tested.get(knowledgePaths);\n        // THEN the correct value is returned\n        assertEquals(1, result.getValue(kp));\n    }\n\n    @Test(expected = KnowledgeNotFoundException.class)\n    public void testNotExsistentAccess() throws Exception {\n        // ReadOnlyKnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"dummy\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        // KnowledgeNotExistentException\n        tested.get(knowledgePaths);\n    }\n\n    @Test\n    public void testRegisterListener() throws Exception {\n        // WHEN a listener is registered at the KnowledgeManager\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        KnowledgeChangeTrigger trigger = RuntimeModelHelper.createKnowledgeChangeTrigger();\n        trigger.setKnowledgePath(kp);\n        tested.register(trigger, triggerListener);\n        // and WHEN listener's releavant knowledge is updated\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 17);\n        tested.update(toUpdate);\n        // THEN the listener is notify once.\n        verify(triggerListener).triggered(trigger);\n        verifyNoMoreInteractions(triggerListener);\n    }\n\n    @Test\n    public void testUnregisterListener() throws Exception {\n        // WHEN a previously registered listener\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"number\");\n        KnowledgeChangeTrigger trigger = RuntimeModelHelper.createKnowledgeChangeTrigger();\n        trigger.setKnowledgePath(kp);\n        tested.register(trigger, triggerListener);\n        // is unregistered from the KnowledgeManager\n        tested.register(trigger, triggerListener);\n        // THEN it is not notified about knowledge changes any more\n        verifyNoMoreInteractions(triggerListener);\n    }\n\n    @Test\n    public void testGetRootKnowledge() throws Exception {\n        // WHEN empty knowledge path is created\n        KnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(emptyKP);\n        // and WHEN it is used to access knowledge manager data\n        ValueSet result = tested.get(knowledgePaths);\n        // knowledge\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"id\");\n        assertTrue(result.getKnowledgePaths().contains(kp));\n        kp = RuntimeModelHelper.createKnowledgePath(\"date\");\n        assertTrue(result.getKnowledgePaths().contains(kp));\n    }\n\n    public void testForbiddenUpdate() throws Exception {\n        // removal and number field update and incorrect inner knowledge change\n        KnowledgePath numberPath = RuntimeModelHelper.createKnowledgePath(\"number\");\n        KnowledgePath listElementPath = RuntimeModelHelper.createKnowledgePath(\"list\", \"1\");\n        KnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        ChangeSet toChange = new ChangeSet();\n        toChange.setValue(numberPath, 100);\n        toChange.setValue(innerPath, 66);\n        toChange.setDeleted(listElementPath);\n        boolean exceptionThrown = false;\n        try {\n            tested.update(toChange, \"update_author\");\n        } catch (KnowledgeUpdateException e) {\n            exceptionThrown = true;\n        }\n        // THEN the KnowledgeUpdateException is thrown\n        assertTrue(exceptionThrown);\n        KnowledgePath listPath = RuntimeModelHelper.createKnowledgePath(\"list\");\n        List<KnowledgePath> listOfPaths = new LinkedList<>();\n        // and THEN list remains unchanged\n        listOfPaths.add(listPath);\n        assertEquals(3, ((List<?>) tested.get(listOfPaths).getValue(listPath)).size());\n        listOfPaths.clear();\n        // and THEN inner knowledge has its original value\n        listOfPaths.add(innerPath);\n        assertEquals(\"innerA\", tested.get(listOfPaths).getValue(innerPath));\n        listOfPaths.clear();\n        // and THEN number field has its original value\n        listOfPaths.add(numberPath);\n        assertEquals(10, tested.get(listOfPaths).getValue(numberPath));\n        // then authors of knowledge remain the same\n        assertEquals(\"TEST\", tested.getAuthor(numberPath));\n        assertEquals(\"TEST\", tested.getAuthor(listElementPath));\n        assertEquals(\"TEST\", tested.getAuthor(innerPath));\n    }\n\n    @Test\n    public void securityTagsTest() {\n        // given single-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n        KnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n        tag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n        tag.getRequiredRole().setRoleName(\"role\");\n        Collection<SecurityTag> expectedTags = Arrays.asList(tag);\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n        // when security tags are then retrieved\n        KnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n        List<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n        // then collections are equal\n        assertEquals(expectedTags, actualTags);\n    }\n\n    @Test\n    public void addSecurityTagsTest() {\n        // given single-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\");\n        KnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();\n        tag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());\n        tag.getRequiredRole().setRoleName(\"role\");\n        Collection<SecurityTag> expectedTags = Arrays.asList(tag);\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n        tested.addSecurityTag(kp, tag);\n        // when security tags are then retrieved\n        KnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath(\"field\");\n        List<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));\n        // then collections are equal\n        assertEquals(2, actualTags.size());\n        assertEquals(tag, actualTags.get(0));\n        assertEquals(tag, actualTags.get(1));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void markAsSecured_MultiNodePathTest() {\n        // given multi-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"field\", \"inner\");\n        Collection<SecurityTag> expectedTags = Arrays.asList();\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void markAsSecured_IdPathTest() {\n        // given single-noded knowledge path and security tags are prepared\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath();\n        kp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());\n        Collection<SecurityTag> expectedTags = Arrays.asList();\n        // when setSecurityTags() is called\n        tested.setSecurityTags(kp, expectedTags);\n    }\n\n    @Test\n    public void getAuthorTest1() {\n        // given basic knowledge is created\n        KnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\");\n        KnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\");\n        // when nested path is used and getAuthor() called\n        String innerAuthor = tested.getAuthor(nestedPath);\n        String outerAuthor = tested.getAuthor(basicPath);\n        // then author is returned\n        assertEquals(\"TEST\", innerAuthor);\n        assertEquals(\"TEST\", outerAuthor);\n        // then knowledge paths remain intact\n        assertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\", \"a\"), nestedPath);\n        assertEquals(RuntimeModelHelper.createKnowledgePath(\"innerKnowledge\"), basicPath);\n    }\n\n    @Test\n    public void getAuthorTest2() {\n        // given basic knowledge is created\n        KnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath(\"non\", \"existent\", \"path\");\n        // when getAuthor() is called\n        String author = tested.getAuthor(nonExistentPath);\n        // then null is returned\n        assertNull(author);\n    }\n\n    @Test\n    public void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n        // and as a ChangeSet, the update for one of the 'map' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 16);\n        tested.update(toUpdate, \"X\");\n        // WHEN the 'map' itself is then updated by a different author\n        KnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n        List<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n        knowledgePaths2.add(kp2);\n        ChangeSet toUpdate2 = new ChangeSet();\n        toUpdate2.setValue(kp2, new HashMap<>());\n        tested.update(toUpdate2, \"Y\");\n        // THEN author of the 'map' and the 'map.a' is set to Y\n        assertEquals(\"Y\", tested.getAuthor(kp2));\n        assertEquals(\"Y\", tested.getAuthor(kp));\n    }\n\n    @Test\n    public void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {\n        // and as a ChangeSet, the update for one of the 'map' items is passed\n        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath(\"map\", \"a\");\n        List<KnowledgePath> knowledgePaths = new LinkedList<>();\n        knowledgePaths.add(kp);\n        ChangeSet toUpdate = new ChangeSet();\n        toUpdate.setValue(kp, 16);\n        tested.update(toUpdate, \"X\");\n        // WHEN the 'map' itself is then deleted\n        KnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath(\"map\");\n        List<KnowledgePath> knowledgePaths2 = new LinkedList<>();\n        knowledgePaths2.add(kp2);\n        ChangeSet toUpdate2 = new ChangeSet();\n        toUpdate2.setDeleted(kp2);\n        tested.update(toUpdate2, \"Y\");\n        // THEN author of the 'map' and the 'map.a' is null\n        assertNull(tested.getAuthor(kp2));\n        assertNull(tested.getAuthor(kp));\n    }\n\n    public static class InnerKnowledge {\n\n        public String a;\n\n        public String b;\n\n        public InnerKnowledge(String a, String b) {\n            super();\n            this.a = a;\n            this.b = b;\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "2f09050d499d8eb4df2f94048b0b44a79bf11ad5", "ext": "java", "lang": "Java", "content": "public class MockApnsServer extends BaseHttp2Server {\n\n    private final PushNotificationHandlerFactory handlerFactory;\n\n    private final MockApnsServerListener listener;\n\n    private final int maxConcurrentStreams;\n\n    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup, final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener, final int maxConcurrentStreams) {\n        super(sslContext, eventLoopGroup);\n        this.handlerFactory = handlerFactory;\n        this.listener = listener;\n        this.maxConcurrentStreams = maxConcurrentStreams;\n    }\n\n    @Override\n    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {\n        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);\n        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder().pushNotificationHandler(pushNotificationHandler).initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams)).listener(this.listener).build();\n        pipeline.addLast(serverHandler);\n    }\n}\n", "class_id": 0, "repo": "Chatatata/pushy", "file": "pushy/src/main/java/sa/com/stcpay/blink/pushy/server/MockApnsServer.java", "last_update_at": "2021-01-04T11:06:26+00:00", "original_content": "public class MockApnsServer extends BaseHttp2Server {\n\n    private final PushNotificationHandlerFactory handlerFactory;\n\n    private final MockApnsServerListener listener;\n\n    private final int maxConcurrentStreams;\n\n    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup, final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener, final int maxConcurrentStreams) {\n        super(sslContext, eventLoopGroup);\n        this.handlerFactory = handlerFactory;\n        this.listener = listener;\n        this.maxConcurrentStreams = maxConcurrentStreams;\n    }\n\n    @Override\n    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {\n        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);\n        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder().pushNotificationHandler(pushNotificationHandler).initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams)).listener(this.listener).build();\n        pipeline.addLast(serverHandler);\n    }\n}\n", "refactored": false}
{"hexsha": "6121857566879d003fc4f936c4f45ac6ff2ab499", "ext": "java", "lang": "Java", "content": "public class GrobidCitationFetcher implements SearchBasedFetcher {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);\n\n    private static final String GROBID_URL = \"http://grobid.jabref.org:8070\";\n\n    private ImportFormatPreferences importFormatPreferences;\n\n    private GrobidService grobidService;\n\n    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {\n        this(importFormatPreferences, new GrobidService(GROBID_URL));\n    }\n\n    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {\n        this.importFormatPreferences = importFormatPreferences;\n        this.grobidService = grobidService;\n    }\n\n    /**\n     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the\n     * server has to look up the entry.\n     *\n     * @return A BibTeX string if extraction is successful\n     */\n    private Optional<String> parseUsingGrobid(String plainText) {\n        try {\n            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));\n        } catch (SocketTimeoutException e) {\n            String msg = \"Connection timed out.\";\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        } catch (IOException e) {\n            String msg = \"Could not process citation. \" + e.getMessage();\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        }\n    }\n\n    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {\n        try {\n            return BibtexParser.singleFromString(bibtexString, importFormatPreferences, new DummyFileUpdateMonitor());\n        } catch (ParseException e) {\n            return Optional.empty();\n        }\n    }\n\n    @Override\n    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {\n        List<BibEntry> bibEntries = null;\n        // This just treats the complex query like a normal string query until it it implemented correctly\n        String query = complexSearchQuery.toString();\n        try {\n            bibEntries = Arrays.stream(query.split(\"\\\\r\\\\r+|\\\\n\\\\n+|\\\\r\\\\n(\\\\r\\\\n)+\")).map(String::trim).filter(str -> !str.isBlank()).map(this::parseUsingGrobid).flatMap(Optional::stream).map(this::parseBibToBibEntry).flatMap(Optional::stream).collect(Collectors.toList());\n        } catch (RuntimeException e) {\n            // un-wrap the wrapped exceptions\n            throw new FetcherException(e.getMessage(), e.getCause());\n        }\n        return bibEntries;\n    }\n\n    @Override\n    public String getName() {\n        return \"GROBID\";\n    }\n}\n", "class_id": 0, "repo": "scfinniss/jabref", "file": "src/main/java/org/jabref/logic/importer/fetcher/GrobidCitationFetcher.java", "last_update_at": "2021-04-02T16:02:25+00:00", "original_content": "public class GrobidCitationFetcher implements SearchBasedFetcher {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);\n\n    private static final String GROBID_URL = \"http://grobid.jabref.org:8070\";\n\n    private ImportFormatPreferences importFormatPreferences;\n\n    private GrobidService grobidService;\n\n    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {\n        this(importFormatPreferences, new GrobidService(GROBID_URL));\n    }\n\n    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {\n        this.importFormatPreferences = importFormatPreferences;\n        this.grobidService = grobidService;\n    }\n\n    /**\n     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the\n     * server has to look up the entry.\n     *\n     * @return A BibTeX string if extraction is successful\n     */\n    private Optional<String> parseUsingGrobid(String plainText) {\n        try {\n            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));\n        } catch (SocketTimeoutException e) {\n            String msg = \"Connection timed out.\";\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        } catch (IOException e) {\n            String msg = \"Could not process citation. \" + e.getMessage();\n            LOGGER.debug(msg, e);\n            throw new RuntimeException(msg, e);\n        }\n    }\n\n    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {\n        try {\n            return BibtexParser.singleFromString(bibtexString, importFormatPreferences, new DummyFileUpdateMonitor());\n        } catch (ParseException e) {\n            return Optional.empty();\n        }\n    }\n\n    @Override\n    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {\n        List<BibEntry> bibEntries = null;\n        // This just treats the complex query like a normal string query until it it implemented correctly\n        String query = complexSearchQuery.toString();\n        try {\n            bibEntries = Arrays.stream(query.split(\"\\\\r\\\\r+|\\\\n\\\\n+|\\\\r\\\\n(\\\\r\\\\n)+\")).map(String::trim).filter(str -> !str.isBlank()).map(this::parseUsingGrobid).flatMap(Optional::stream).map(this::parseBibToBibEntry).flatMap(Optional::stream).collect(Collectors.toList());\n        } catch (RuntimeException e) {\n            // un-wrap the wrapped exceptions\n            throw new FetcherException(e.getMessage(), e.getCause());\n        }\n        return bibEntries;\n    }\n\n    @Override\n    public String getName() {\n        return \"GROBID\";\n    }\n}\n", "refactored": false}
{"hexsha": "9687d6ab54c8b9d8f51dadc5b7c29d4734a45987", "ext": "java", "lang": "Java", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"AddClientsToClassesRequest\", propOrder = { \"clientIDs\", \"classIDs\", \"test\", \"requirePayment\", \"waitlist\", \"sendEmail\" })\npublic class AddClientsToClassesRequest extends MBRequest implements Serializable, Equals, HashCode, ToString {\n\n    private final static long serialVersionUID = 1L;\n\n    @XmlElement(name = \"ClientIDs\")\n    protected ArrayOfString clientIDs;\n\n    @XmlElement(name = \"ClassIDs\")\n    protected ArrayOfInt classIDs;\n\n    @XmlElement(name = \"Test\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean test;\n\n    @XmlElement(name = \"RequirePayment\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean requirePayment;\n\n    @XmlElement(name = \"Waitlist\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean waitlist;\n\n    @XmlElement(name = \"SendEmail\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean sendEmail;\n\n    /**\n     * Gets the value of the clientIDs property.\n     *\n     * @return\n     *     possible object is\n     *     {@link ArrayOfString }\n     */\n    public ArrayOfString getClientIDs() {\n        return clientIDs;\n    }\n\n    /**\n     * Sets the value of the clientIDs property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfString }\n     */\n    public void setClientIDs(ArrayOfString value) {\n        this.clientIDs = value;\n    }\n\n    /**\n     * Gets the value of the classIDs property.\n     *\n     * @return\n     *     possible object is\n     *     {@link ArrayOfInt }\n     */\n    public ArrayOfInt getClassIDs() {\n        return classIDs;\n    }\n\n    /**\n     * Sets the value of the classIDs property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfInt }\n     */\n    public void setClassIDs(ArrayOfInt value) {\n        this.classIDs = value;\n    }\n\n    /**\n     * Gets the value of the test property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getTest() {\n        return test;\n    }\n\n    /**\n     * Sets the value of the test property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setTest(Boolean value) {\n        this.test = value;\n    }\n\n    /**\n     * Gets the value of the requirePayment property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getRequirePayment() {\n        return requirePayment;\n    }\n\n    /**\n     * Sets the value of the requirePayment property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setRequirePayment(Boolean value) {\n        this.requirePayment = value;\n    }\n\n    /**\n     * Gets the value of the waitlist property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getWaitlist() {\n        return waitlist;\n    }\n\n    /**\n     * Sets the value of the waitlist property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setWaitlist(Boolean value) {\n        this.waitlist = value;\n    }\n\n    /**\n     * Gets the value of the sendEmail property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getSendEmail() {\n        return sendEmail;\n    }\n\n    /**\n     * Sets the value of the sendEmail property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setSendEmail(Boolean value) {\n        this.sendEmail = value;\n    }\n\n    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {\n        int currentHashCode = super.hashCode(locator, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"clientIDs\", theClientIDs), currentHashCode, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"classIDs\", theClassIDs), currentHashCode, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"test\", theTest), currentHashCode, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"requirePayment\", theRequirePayment), currentHashCode, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"waitlist\", theWaitlist), currentHashCode, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"sendEmail\", theSendEmail), currentHashCode, theSendEmail);\n        }\n        return currentHashCode;\n    }\n\n    public int hashCode() {\n        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;\n        return this.hashCode(null, strategy);\n    }\n\n    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {\n        if (!(object instanceof AddClientsToClassesRequest)) {\n            return false;\n        }\n        if (this == object) {\n            return true;\n        }\n        if (!super.equals(thisLocator, thatLocator, object, strategy)) {\n            return false;\n        }\n        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);\n        {\n            ArrayOfString lhsClientIDs;\n            lhsClientIDs = this.getClientIDs();\n            ArrayOfString rhsClientIDs;\n            rhsClientIDs = that.getClientIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"clientIDs\", lhsClientIDs), LocatorUtils.property(thatLocator, \"clientIDs\", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {\n                return false;\n            }\n        }\n        {\n            ArrayOfInt lhsClassIDs;\n            lhsClassIDs = this.getClassIDs();\n            ArrayOfInt rhsClassIDs;\n            rhsClassIDs = that.getClassIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"classIDs\", lhsClassIDs), LocatorUtils.property(thatLocator, \"classIDs\", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsTest;\n            lhsTest = this.getTest();\n            Boolean rhsTest;\n            rhsTest = that.getTest();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"test\", lhsTest), LocatorUtils.property(thatLocator, \"test\", rhsTest), lhsTest, rhsTest)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsRequirePayment;\n            lhsRequirePayment = this.getRequirePayment();\n            Boolean rhsRequirePayment;\n            rhsRequirePayment = that.getRequirePayment();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"requirePayment\", lhsRequirePayment), LocatorUtils.property(thatLocator, \"requirePayment\", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsWaitlist;\n            lhsWaitlist = this.getWaitlist();\n            Boolean rhsWaitlist;\n            rhsWaitlist = that.getWaitlist();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"waitlist\", lhsWaitlist), LocatorUtils.property(thatLocator, \"waitlist\", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsSendEmail;\n            lhsSendEmail = this.getSendEmail();\n            Boolean rhsSendEmail;\n            rhsSendEmail = that.getSendEmail();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"sendEmail\", lhsSendEmail), LocatorUtils.property(thatLocator, \"sendEmail\", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean equals(Object object) {\n        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;\n        return equals(null, null, object, strategy);\n    }\n\n    public String toString() {\n        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;\n        final StringBuilder buffer = new StringBuilder();\n        append(null, buffer, strategy);\n        return buffer.toString();\n    }\n\n    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        strategy.appendStart(locator, this, buffer);\n        appendFields(locator, buffer, strategy);\n        strategy.appendEnd(locator, this, buffer);\n        return buffer;\n    }\n\n    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        super.appendFields(locator, buffer, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            strategy.appendField(locator, this, \"clientIDs\", buffer, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            strategy.appendField(locator, this, \"classIDs\", buffer, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            strategy.appendField(locator, this, \"test\", buffer, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            strategy.appendField(locator, this, \"requirePayment\", buffer, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            strategy.appendField(locator, this, \"waitlist\", buffer, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            strategy.appendField(locator, this, \"sendEmail\", buffer, theSendEmail);\n        }\n        return buffer;\n    }\n}\n", "class_id": 0, "repo": "xaderfos/hyperjaxb3-support", "file": "m/MindBody/src/main/java/integration/mindbody/AddClientsToClassesRequest.java", "last_update_at": "2021-02-03T09:26:07+00:00", "original_content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"AddClientsToClassesRequest\", propOrder = { \"clientIDs\", \"classIDs\", \"test\", \"requirePayment\", \"waitlist\", \"sendEmail\" })\npublic class AddClientsToClassesRequest extends MBRequest implements Serializable, Equals, HashCode, ToString {\n\n    private final static long serialVersionUID = 1L;\n\n    @XmlElement(name = \"ClientIDs\")\n    protected ArrayOfString clientIDs;\n\n    @XmlElement(name = \"ClassIDs\")\n    protected ArrayOfInt classIDs;\n\n    @XmlElement(name = \"Test\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean test;\n\n    @XmlElement(name = \"RequirePayment\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean requirePayment;\n\n    @XmlElement(name = \"Waitlist\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean waitlist;\n\n    @XmlElement(name = \"SendEmail\", required = true, type = Boolean.class, nillable = true)\n    protected Boolean sendEmail;\n\n    /**\n     * Gets the value of the clientIDs property.\n     *\n     * @return\n     *     possible object is\n     *     {@link ArrayOfString }\n     */\n    public ArrayOfString getClientIDs() {\n        return clientIDs;\n    }\n\n    /**\n     * Sets the value of the clientIDs property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfString }\n     */\n    public void setClientIDs(ArrayOfString value) {\n        this.clientIDs = value;\n    }\n\n    /**\n     * Gets the value of the classIDs property.\n     *\n     * @return\n     *     possible object is\n     *     {@link ArrayOfInt }\n     */\n    public ArrayOfInt getClassIDs() {\n        return classIDs;\n    }\n\n    /**\n     * Sets the value of the classIDs property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link ArrayOfInt }\n     */\n    public void setClassIDs(ArrayOfInt value) {\n        this.classIDs = value;\n    }\n\n    /**\n     * Gets the value of the test property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getTest() {\n        return test;\n    }\n\n    /**\n     * Sets the value of the test property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setTest(Boolean value) {\n        this.test = value;\n    }\n\n    /**\n     * Gets the value of the requirePayment property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getRequirePayment() {\n        return requirePayment;\n    }\n\n    /**\n     * Sets the value of the requirePayment property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setRequirePayment(Boolean value) {\n        this.requirePayment = value;\n    }\n\n    /**\n     * Gets the value of the waitlist property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getWaitlist() {\n        return waitlist;\n    }\n\n    /**\n     * Sets the value of the waitlist property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setWaitlist(Boolean value) {\n        this.waitlist = value;\n    }\n\n    /**\n     * Gets the value of the sendEmail property.\n     *\n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     */\n    public Boolean getSendEmail() {\n        return sendEmail;\n    }\n\n    /**\n     * Sets the value of the sendEmail property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     */\n    public void setSendEmail(Boolean value) {\n        this.sendEmail = value;\n    }\n\n    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {\n        int currentHashCode = super.hashCode(locator, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"clientIDs\", theClientIDs), currentHashCode, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"classIDs\", theClassIDs), currentHashCode, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"test\", theTest), currentHashCode, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"requirePayment\", theRequirePayment), currentHashCode, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"waitlist\", theWaitlist), currentHashCode, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, \"sendEmail\", theSendEmail), currentHashCode, theSendEmail);\n        }\n        return currentHashCode;\n    }\n\n    public int hashCode() {\n        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;\n        return this.hashCode(null, strategy);\n    }\n\n    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {\n        if (!(object instanceof AddClientsToClassesRequest)) {\n            return false;\n        }\n        if (this == object) {\n            return true;\n        }\n        if (!super.equals(thisLocator, thatLocator, object, strategy)) {\n            return false;\n        }\n        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);\n        {\n            ArrayOfString lhsClientIDs;\n            lhsClientIDs = this.getClientIDs();\n            ArrayOfString rhsClientIDs;\n            rhsClientIDs = that.getClientIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"clientIDs\", lhsClientIDs), LocatorUtils.property(thatLocator, \"clientIDs\", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {\n                return false;\n            }\n        }\n        {\n            ArrayOfInt lhsClassIDs;\n            lhsClassIDs = this.getClassIDs();\n            ArrayOfInt rhsClassIDs;\n            rhsClassIDs = that.getClassIDs();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"classIDs\", lhsClassIDs), LocatorUtils.property(thatLocator, \"classIDs\", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsTest;\n            lhsTest = this.getTest();\n            Boolean rhsTest;\n            rhsTest = that.getTest();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"test\", lhsTest), LocatorUtils.property(thatLocator, \"test\", rhsTest), lhsTest, rhsTest)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsRequirePayment;\n            lhsRequirePayment = this.getRequirePayment();\n            Boolean rhsRequirePayment;\n            rhsRequirePayment = that.getRequirePayment();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"requirePayment\", lhsRequirePayment), LocatorUtils.property(thatLocator, \"requirePayment\", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsWaitlist;\n            lhsWaitlist = this.getWaitlist();\n            Boolean rhsWaitlist;\n            rhsWaitlist = that.getWaitlist();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"waitlist\", lhsWaitlist), LocatorUtils.property(thatLocator, \"waitlist\", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {\n                return false;\n            }\n        }\n        {\n            Boolean lhsSendEmail;\n            lhsSendEmail = this.getSendEmail();\n            Boolean rhsSendEmail;\n            rhsSendEmail = that.getSendEmail();\n            if (!strategy.equals(LocatorUtils.property(thisLocator, \"sendEmail\", lhsSendEmail), LocatorUtils.property(thatLocator, \"sendEmail\", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean equals(Object object) {\n        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;\n        return equals(null, null, object, strategy);\n    }\n\n    public String toString() {\n        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;\n        final StringBuilder buffer = new StringBuilder();\n        append(null, buffer, strategy);\n        return buffer.toString();\n    }\n\n    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        strategy.appendStart(locator, this, buffer);\n        appendFields(locator, buffer, strategy);\n        strategy.appendEnd(locator, this, buffer);\n        return buffer;\n    }\n\n    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {\n        super.appendFields(locator, buffer, strategy);\n        {\n            ArrayOfString theClientIDs;\n            theClientIDs = this.getClientIDs();\n            strategy.appendField(locator, this, \"clientIDs\", buffer, theClientIDs);\n        }\n        {\n            ArrayOfInt theClassIDs;\n            theClassIDs = this.getClassIDs();\n            strategy.appendField(locator, this, \"classIDs\", buffer, theClassIDs);\n        }\n        {\n            Boolean theTest;\n            theTest = this.getTest();\n            strategy.appendField(locator, this, \"test\", buffer, theTest);\n        }\n        {\n            Boolean theRequirePayment;\n            theRequirePayment = this.getRequirePayment();\n            strategy.appendField(locator, this, \"requirePayment\", buffer, theRequirePayment);\n        }\n        {\n            Boolean theWaitlist;\n            theWaitlist = this.getWaitlist();\n            strategy.appendField(locator, this, \"waitlist\", buffer, theWaitlist);\n        }\n        {\n            Boolean theSendEmail;\n            theSendEmail = this.getSendEmail();\n            strategy.appendField(locator, this, \"sendEmail\", buffer, theSendEmail);\n        }\n        return buffer;\n    }\n}\n", "refactored": false}
{"hexsha": "8a9bfb3171c29a5cac43a722a02e924726776612", "ext": "java", "lang": "Java", "content": "@Getter\n@Setter\npublic class NpcShop {\n\n    private int shopId;\n\n    private int selectNpcItemId;\n\n    private int npcTemplateId;\n\n    private int starCoin;\n\n    private int shopVerNo;\n\n    private List<NpcShopItem> items = new ArrayList<>();\n\n    public List<NpcShopItem> getItems() {\n        return items;\n    }\n\n    public void setItems(List<NpcShopItem> items) {\n        this.items = items;\n    }\n\n    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {\n        out.writeZeroBytes(20);\n        out.writeInt(DateUtil.getTime());\n        out.writeBool(false);\n        out.writeShort(items.size() + repurchaseItems.size());\n        items.forEach(npcShopItem -> npcShopItem.encode(out));\n        ListIterator<NpcShopItem> itemListIterator;\n        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {\n            itemListIterator.next();\n        }\n        for (; itemListIterator.hasPrevious(); ) {\n            NpcShopItem shopItem = itemListIterator.previous();\n            shopItem.encode(out);\n        }\n    }\n\n    public NpcShopItem getItemByIndex(int idx) {\n        NpcShopItem item = null;\n        if (idx >= 0 && idx < getItems().size()) {\n            item = getItems().get(idx);\n        }\n        return item;\n    }\n}\n", "class_id": 0, "repo": "Heasn/ms", "file": "src/main/java/im/cave/ms/client/field/obj/npc/shop/NpcShop.java", "last_update_at": "2021-12-23T02:26:11+00:00", "original_content": "@Getter\n@Setter\npublic class NpcShop {\n\n    private int shopId;\n\n    private int selectNpcItemId;\n\n    private int npcTemplateId;\n\n    private int starCoin;\n\n    private int shopVerNo;\n\n    private List<NpcShopItem> items = new ArrayList<>();\n\n    public List<NpcShopItem> getItems() {\n        return items;\n    }\n\n    public void setItems(List<NpcShopItem> items) {\n        this.items = items;\n    }\n\n    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {\n        out.writeZeroBytes(20);\n        out.writeInt(DateUtil.getTime());\n        out.writeBool(false);\n        out.writeShort(items.size() + repurchaseItems.size());\n        items.forEach(npcShopItem -> npcShopItem.encode(out));\n        ListIterator<NpcShopItem> itemListIterator;\n        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {\n            itemListIterator.next();\n        }\n        while (itemListIterator.hasPrevious()) {\n            NpcShopItem shopItem = itemListIterator.previous();\n            shopItem.encode(out);\n        }\n    }\n\n    public NpcShopItem getItemByIndex(int idx) {\n        NpcShopItem item = null;\n        if (idx >= 0 && idx < getItems().size()) {\n            item = getItems().get(idx);\n        }\n        return item;\n    }\n}\n", "refactored": true}
{"hexsha": "13ff8592e8c99706938dc8f4175004a0e584dad8", "ext": "java", "lang": "Java", "content": "@Controller\npublic class IndexEditController {\n\n    /**\n     * Helper class used as form backing object\n     */\n    public static final class FormBackingObject {\n\n        private String catalog;\n\n        private String schema;\n\n        private String object;\n\n        private String name;\n\n        private boolean unique;\n\n        private final Map<Integer, String> columns;\n\n        /**\n         * Constructor\n         */\n        public FormBackingObject() {\n            this.columns = new TreeMap<Integer, String>();\n        }\n\n        /**\n         * Get the column names\n         * @return column names\n         */\n        public List<String> getColumnNames() {\n            final List<String> ret = new ArrayList<String>(columns.size());\n            int i = 0;\n            while (true) try {\n                final String s = columns.get(i);\n                if (StringUtils.empty(s))\n                    break;\n                ret.add(s);\n            } finally {\n                i++;\n            }\n            return (ret);\n        }\n\n        /**\n         * @return the catalog\n         */\n        public String getCatalog() {\n            return catalog;\n        }\n\n        /**\n         * @param catalog the catalog to set\n         */\n        public void setCatalog(String catalog) {\n            this.catalog = catalog;\n        }\n\n        /**\n         * @return the schema\n         */\n        public String getSchema() {\n            return schema;\n        }\n\n        /**\n         * @param schema the schema to set\n         */\n        public void setSchema(String schema) {\n            this.schema = schema;\n        }\n\n        /**\n         * @return the object\n         */\n        public String getObject() {\n            return object;\n        }\n\n        /**\n         * @param object the object to set\n         */\n        public void setObject(String object) {\n            this.object = object;\n        }\n\n        /**\n         * @return the name\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * @param name the name to set\n         */\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        /**\n         * @return the unique\n         */\n        public boolean isUnique() {\n            return unique;\n        }\n\n        /**\n         * @param unique the unique to set\n         */\n        public void setUnique(boolean unique) {\n            this.unique = unique;\n        }\n\n        /**\n         * @return the columns\n         */\n        public Map<Integer, String> getColumns() {\n            return columns;\n        }\n    }\n\n    private final MetadataService metadataService;\n\n    private final QuerySettingsManager querySettingsManager;\n\n    private final QueryPerformerService runner;\n\n    private final QueryGeneratorService queryGeneratorService;\n\n    private final ConnectionSettings connectionSettings;\n\n    private final FrontendHelperService frontendHelperService;\n\n    /**\n     * Constructor\n     * @param metadataService MetadataService\n     * @param querySettingsManager QuerySettingsManager\n     * @param runner QueryPerformerService\n     * @param queryGeneratorService QueryGeneratorService\n     * @param connectionSettings ConnectionSettings\n     * @param frontendHelperService FrontendHelperService\n     */\n    @Autowired\n    public IndexEditController(MetadataService metadataService, QuerySettingsManager querySettingsManager, QueryPerformerService runner, QueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings, FrontendHelperService frontendHelperService) {\n        this.metadataService = metadataService;\n        this.querySettingsManager = querySettingsManager;\n        this.runner = runner;\n        this.queryGeneratorService = queryGeneratorService;\n        this.connectionSettings = connectionSettings;\n        this.frontendHelperService = frontendHelperService;\n    }\n\n    /**\n     * Get the FormBackingObject\n     * @param obj DB object name\n     * @return FormBackingObject\n     */\n    @ModelAttribute(\"model\")\n    public FormBackingObject getFormBackingObject(@RequestParam(value = \"q\", required = false) String obj) {\n        final FormBackingObject fbo = new FormBackingObject();\n        // Hack to recognize object name in \"q\" as well as \"object\" parameter\n        fbo.setObject(obj);\n        int i = 0;\n        while (i < 10) try {\n            fbo.getColumns().put(i, \"\");\n        } finally {\n            i++;\n        }\n        return (fbo);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-add-index.html\", method = RequestMethod.GET)\n    public Map<String, Object> showInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        model.put(\"columns\", info.getColumns());\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-add-index.html\", method = RequestMethod.POST)\n    public Map<String, Object> performInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());\n        final Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-drop-index.html\", method = RequestMethod.GET)\n    public Map<String, Object> showDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final IndexDescription id = info.getIndex(fbo.getName());\n        fbo.setUnique(id.isUnique());\n        int i = 0;\n        for (String c : id.getColumns()) fbo.getColumns().put(i++, c);\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-drop-index.html\", method = RequestMethod.POST)\n    public Map<String, Object> performDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final IndexDescription id = info.getIndex(fbo.getName());\n        final Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-add-primarykey.html\", method = RequestMethod.GET)\n    public Map<String, Object> showPKInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        model.put(\"columns\", info.getColumns());\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-add-primarykey.html\", method = RequestMethod.POST)\n    public Map<String, Object> performPKInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());\n        final Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-drop-primarykey.html\", method = RequestMethod.GET)\n    public Map<String, Object> showPKDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final PrimaryKeyDescription pk = info.getPrimaryKey();\n        fbo.setUnique(pk.isUnique());\n        int i = 0;\n        for (String c : pk.getColumns()) fbo.getColumns().put(i++, c);\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-drop-primarykey.html\", method = RequestMethod.POST)\n    public Map<String, Object> performPKDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final PrimaryKeyDescription pk = info.getPrimaryKey();\n        final Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    private SQLDialect getSQLDialect() {\n        return (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));\n    }\n}\n", "class_id": 0, "repo": "tweerlei/dbgrazer", "file": "web/plugins/jdbc-web/src/main/java/de/tweerlei/dbgrazer/web/controller/jdbc/IndexEditController.java", "last_update_at": "2021-09-26T03:05:18+00:00", "original_content": "@Controller\npublic class IndexEditController {\n\n    /**\n     * Helper class used as form backing object\n     */\n    public static final class FormBackingObject {\n\n        private String catalog;\n\n        private String schema;\n\n        private String object;\n\n        private String name;\n\n        private boolean unique;\n\n        private final Map<Integer, String> columns;\n\n        /**\n         * Constructor\n         */\n        public FormBackingObject() {\n            this.columns = new TreeMap<Integer, String>();\n        }\n\n        /**\n         * Get the column names\n         * @return column names\n         */\n        public List<String> getColumnNames() {\n            final List<String> ret = new ArrayList<String>(columns.size());\n            for (int i = 0; ; i++) {\n                final String s = columns.get(i);\n                if (StringUtils.empty(s))\n                    break;\n                ret.add(s);\n            }\n            return (ret);\n        }\n\n        /**\n         * @return the catalog\n         */\n        public String getCatalog() {\n            return catalog;\n        }\n\n        /**\n         * @param catalog the catalog to set\n         */\n        public void setCatalog(String catalog) {\n            this.catalog = catalog;\n        }\n\n        /**\n         * @return the schema\n         */\n        public String getSchema() {\n            return schema;\n        }\n\n        /**\n         * @param schema the schema to set\n         */\n        public void setSchema(String schema) {\n            this.schema = schema;\n        }\n\n        /**\n         * @return the object\n         */\n        public String getObject() {\n            return object;\n        }\n\n        /**\n         * @param object the object to set\n         */\n        public void setObject(String object) {\n            this.object = object;\n        }\n\n        /**\n         * @return the name\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * @param name the name to set\n         */\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        /**\n         * @return the unique\n         */\n        public boolean isUnique() {\n            return unique;\n        }\n\n        /**\n         * @param unique the unique to set\n         */\n        public void setUnique(boolean unique) {\n            this.unique = unique;\n        }\n\n        /**\n         * @return the columns\n         */\n        public Map<Integer, String> getColumns() {\n            return columns;\n        }\n    }\n\n    private final MetadataService metadataService;\n\n    private final QuerySettingsManager querySettingsManager;\n\n    private final QueryPerformerService runner;\n\n    private final QueryGeneratorService queryGeneratorService;\n\n    private final ConnectionSettings connectionSettings;\n\n    private final FrontendHelperService frontendHelperService;\n\n    /**\n     * Constructor\n     * @param metadataService MetadataService\n     * @param querySettingsManager QuerySettingsManager\n     * @param runner QueryPerformerService\n     * @param queryGeneratorService QueryGeneratorService\n     * @param connectionSettings ConnectionSettings\n     * @param frontendHelperService FrontendHelperService\n     */\n    @Autowired\n    public IndexEditController(MetadataService metadataService, QuerySettingsManager querySettingsManager, QueryPerformerService runner, QueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings, FrontendHelperService frontendHelperService) {\n        this.metadataService = metadataService;\n        this.querySettingsManager = querySettingsManager;\n        this.runner = runner;\n        this.queryGeneratorService = queryGeneratorService;\n        this.connectionSettings = connectionSettings;\n        this.frontendHelperService = frontendHelperService;\n    }\n\n    /**\n     * Get the FormBackingObject\n     * @param obj DB object name\n     * @return FormBackingObject\n     */\n    @ModelAttribute(\"model\")\n    public FormBackingObject getFormBackingObject(@RequestParam(value = \"q\", required = false) String obj) {\n        final FormBackingObject fbo = new FormBackingObject();\n        // Hack to recognize object name in \"q\" as well as \"object\" parameter\n        fbo.setObject(obj);\n        for (int i = 0; i < 10; i++) fbo.getColumns().put(i, \"\");\n        return (fbo);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-add-index.html\", method = RequestMethod.GET)\n    public Map<String, Object> showInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        model.put(\"columns\", info.getColumns());\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-add-index.html\", method = RequestMethod.POST)\n    public Map<String, Object> performInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());\n        final Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-drop-index.html\", method = RequestMethod.GET)\n    public Map<String, Object> showDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final IndexDescription id = info.getIndex(fbo.getName());\n        fbo.setUnique(id.isUnique());\n        int i = 0;\n        for (String c : id.getColumns()) fbo.getColumns().put(i++, c);\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-drop-index.html\", method = RequestMethod.POST)\n    public Map<String, Object> performDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final IndexDescription id = info.getIndex(fbo.getName());\n        final Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-add-primarykey.html\", method = RequestMethod.GET)\n    public Map<String, Object> showPKInsertDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        model.put(\"columns\", info.getColumns());\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-add-primarykey.html\", method = RequestMethod.POST)\n    public Map<String, Object> performPKInsertQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());\n        final Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ajax/ddl-drop-primarykey.html\", method = RequestMethod.GET)\n    public Map<String, Object> showPKDeleteDialog(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final PrimaryKeyDescription pk = info.getPrimaryKey();\n        fbo.setUnique(pk.isUnique());\n        int i = 0;\n        for (String c : pk.getColumns()) fbo.getColumns().put(i++, c);\n        return (model);\n    }\n\n    /**\n     * Show a parameter input form\n     * @param fbo FormBackingObject\n     * @return Model\n     */\n    @RequestMapping(value = \"/db/*/ddl-drop-primarykey.html\", method = RequestMethod.POST)\n    public Map<String, Object> performPKDeleteQuery(@ModelAttribute(\"model\") FormBackingObject fbo) {\n        if (!connectionSettings.isBrowserEnabled())\n            throw new AccessDeniedException();\n        if (!connectionSettings.isWritable())\n            throw new AccessDeniedException();\n        final Map<String, Object> model = new HashMap<String, Object>();\n        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());\n        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);\n        final PrimaryKeyDescription pk = info.getPrimaryKey();\n        final Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);\n        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());\n        try {\n            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);\n            metadataService.flushCache(connectionSettings.getLinkName());\n            model.put(\"result\", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));\n            model.put(\"exceptionText\", null);\n        } catch (PerformQueryException e) {\n            model.put(\"exceptionText\", frontendHelperService.toJSONString(e.getMessage()));\n        }\n        return (model);\n    }\n\n    private SQLDialect getSQLDialect() {\n        return (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));\n    }\n}\n", "refactored": true}
{"hexsha": "3e73974b19bd63eef0024f08c1d9d9f3549ef0b5", "ext": "java", "lang": "Java", "content": "public class RestClientLoadBalancerTest {\n\n    public static ResourceBundle messageBundle = ResourceBundle.getBundle(\"Messages\");\n\n    public static MessageUtils messageUtils = new MessageUtils(messageBundle);\n\n    public static HttpClient httpClient = HttpClient.newHttpClient();\n\n    public static MockWebServer mockServer;\n\n    @BeforeEach\n    void setUp() throws IOException {\n        mockServer = new MockWebServer();\n        mockServer.start();\n    }\n\n    @Test\n    public void happyMakeRequest() throws Exception {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        Integer statusCode = 200;\n        String body = \"someBody\";\n        mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body).setResponseCode(statusCode));\n        String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n        String urlServer2 = \"https://incorrectServer:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        Integer actual = httpResponse.statusCode();\n        Integer expected = statusCode;\n        assertTrue(actual.equals(expected));\n        assertTrue(httpResponse.body().equals(body));\n    }\n\n    @Test\n    public void happyMakeRequestAfterRetries() throws Exception {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        Integer statusCode = 400;\n        String body = \"badBody\";\n        int i = 0;\n        while (i < 5) try {\n            mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body + i).setResponseCode(statusCode));\n        } finally {\n            i++;\n        }\n        statusCode = 200;\n        body = \"goodBody\";\n        for (int i = 0; i < 5; i++) {\n            mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body + i).setResponseCode(statusCode));\n        }\n        String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n        String urlServer2 = \"https://incorrectServer:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        Integer actual = httpResponse.statusCode();\n        Integer expected = statusCode;\n        assertTrue(actual.equals(expected));\n        assertTrue(httpResponse.body().equals(\"goodBody0\"));\n        System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());\n    }\n\n    @Test\n    public void failedMakeRequestNoValidServer() {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        String urlServer1 = \"https://incorrectServer1:100\";\n        String urlServer2 = \"https://incorrectServer2:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n            HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        });\n        assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n    }\n\n    @Test\n    public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        Integer statusCode = 400;\n        String body = \"someBody\";\n        int i = 0;\n        while (i < 10) try {\n            mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body + i).setResponseCode(statusCode));\n        } finally {\n            i++;\n        }\n        String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n        String urlServer2 = \"https://incorrectServer:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n            HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        });\n        assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n    }\n\n    @AfterEach\n    void tearDown() throws Exception {\n        mockServer.shutdown();\n    }\n}\n", "class_id": 0, "repo": "IBM/uni-resolver-driver-did-hpass", "file": "src/test/java/uniresolver/driver/did/hpass/utils/RestClientLoadBalancerTest.java", "last_update_at": "2021-12-13T15:56:55+00:00", "original_content": "public class RestClientLoadBalancerTest {\n\n    public static ResourceBundle messageBundle = ResourceBundle.getBundle(\"Messages\");\n\n    public static MessageUtils messageUtils = new MessageUtils(messageBundle);\n\n    public static HttpClient httpClient = HttpClient.newHttpClient();\n\n    public static MockWebServer mockServer;\n\n    @BeforeEach\n    void setUp() throws IOException {\n        mockServer = new MockWebServer();\n        mockServer.start();\n    }\n\n    @Test\n    public void happyMakeRequest() throws Exception {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        Integer statusCode = 200;\n        String body = \"someBody\";\n        mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body).setResponseCode(statusCode));\n        String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n        String urlServer2 = \"https://incorrectServer:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        Integer actual = httpResponse.statusCode();\n        Integer expected = statusCode;\n        assertTrue(actual.equals(expected));\n        assertTrue(httpResponse.body().equals(body));\n    }\n\n    @Test\n    public void happyMakeRequestAfterRetries() throws Exception {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        Integer statusCode = 400;\n        String body = \"badBody\";\n        for (int i = 0; i < 5; i++) {\n            mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body + i).setResponseCode(statusCode));\n        }\n        statusCode = 200;\n        body = \"goodBody\";\n        for (int i = 0; i < 5; i++) {\n            mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body + i).setResponseCode(statusCode));\n        }\n        String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n        String urlServer2 = \"https://incorrectServer:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        Integer actual = httpResponse.statusCode();\n        Integer expected = statusCode;\n        assertTrue(actual.equals(expected));\n        assertTrue(httpResponse.body().equals(\"goodBody0\"));\n        System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());\n    }\n\n    @Test\n    public void failedMakeRequestNoValidServer() {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        String urlServer1 = \"https://incorrectServer1:100\";\n        String urlServer2 = \"https://incorrectServer2:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n            HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        });\n        assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n    }\n\n    @Test\n    public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {\n        Boolean staticServerList = true;\n        ArrayList<Server> networkServerList = new ArrayList<>();\n        Integer statusCode = 400;\n        String body = \"someBody\";\n        // put at least as many requests into the queue as the retry limit\n        for (int i = 0; i < 10; i++) {\n            mockServer.enqueue(new MockResponse().addHeader(\"Content-Type\", \"application/json; charset=utf-8\").setBody(body + i).setResponseCode(statusCode));\n        }\n        String urlServer1 = String.format(\"http://%s:%s/\", mockServer.getHostName(), mockServer.getPort());\n        String urlServer2 = \"https://incorrectServer:200\";\n        networkServerList.add(new Server(urlServer1, 1));\n        networkServerList.add(new Server(urlServer2, 2));\n        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);\n        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();\n        String networkID = \"identifier1\";\n        String parameters = \"?network_id=\" + networkID;\n        ResolutionException exception = assertThrows(ResolutionException.class, () -> {\n            HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);\n        });\n        assertTrue(exception.getMessage().contains(\"Number of retries on next server exceeded max 10 retries\"));\n    }\n\n    @AfterEach\n    void tearDown() throws Exception {\n        mockServer.shutdown();\n    }\n}\n", "refactored": true}
{"hexsha": "720da52387d7399deb3c25aef1d5a296b400d45c", "ext": "java", "lang": "Java", "content": "public class BulkOperation extends ExtensibleObject {\n\n    /**\n     *  Status ACTIVE: when bulk operation is created.\n     */\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n\n    /**\n     *  Status IN_PROGRESS: when bulk operation is performing on all devices.\n     */\n    public static final String STATUS_IN_PROGRESS = \"IN_PROGRESS\";\n\n    /**\n     * Status COMPLETED: when the operation was performed on all devices.\n     */\n    public static final String STATUS_COMPLETED = \"COMPLETED\";\n\n    /**\n     * Status DELETED: when already created operation was cancelled by deleting the bulk operation\n     */\n    public static final String STATUS_DELETED = \"DELETED\";\n\n    /**\n     * Constructor to create a bulk operation.\n     */\n    public BulkOperation() {\n        super();\n    }\n\n    /**\n     * Internal constructor to create a bulk operation object.\n     *\n     * @param extensibleObject existing base class object.\n     */\n    BulkOperation(ExtensibleObject extensibleObject) {\n        super(extensibleObject);\n    }\n\n    /**\n     * Set the unique identifier of the bulk operation.\n     * Just used internally.\n     *\n     * @param id the new identifier created by storing the entity.\n     */\n    void setId(String id) {\n        anyObject.put(\"id\", id);\n    }\n\n    /**\n     * Get the unique identifier for the bulk operation.\n     *\n     * @return String with the unique identifier of the bulk operation or null if not\n     * available.\n     */\n    public String getId() {\n        Object id = anyObject.get(\"id\");\n        if (id == null) {\n            return null;\n        }\n        return id.toString();\n    }\n\n    /**\n     * Set the groupId of the target group on which the bulk operation should be performed.\n     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'\n     *\n     * @param groupId the unique identifier of the target group.\n     */\n    public void setGroupId(String groupId) {\n        anyObject.put(\"groupId\", groupId);\n    }\n\n    /**\n     * Get the groupId of the target group of the bulk operation.\n     *\n     * @return String with the unique identifier of the target group or null if not\n     * available.\n     */\n    public String getGroupId() {\n        return (String) anyObject.get(\"groupId\");\n    }\n\n    /**\n     * Set the bulk operation id to reschedule this operation on devices where it failed.\n     *\n     * @param failedBulkOperationId the unique identifier of the bulk operation.\n     */\n    public void setFailedBulkOperationId(String failedBulkOperationId) {\n        anyObject.put(\"failedBulkOperationId\", failedBulkOperationId);\n    }\n\n    /**\n     * Get the bulk operation id from which failed operation should be rescheduled.\n     *\n     * @return String with the unique identifier of the failed bulk operation id\n     * or null if not available.\n     */\n    public String getFailedBulkOperationId() {\n        return (String) anyObject.get(\"failedBulkOperationId\");\n    }\n\n    /**\n     * Get the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @return a String with the status\n     */\n    public String getStatus() {\n        return (String) anyObject.get(\"status\");\n    }\n\n    /**\n     * Set the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @param status String which represents the status of the bulk operation.\n     */\n    public void setStatus(String status) {\n        anyObject.put(\"status\", status);\n    }\n\n    /**\n     * Set the ramp up time, specifying the delay between every operation.\n     *\n     * @param creationRamp number in seconds.\n     */\n    public void setCreationRamp(Number creationRamp) {\n        anyObject.put(\"creationRamp\", creationRamp);\n    }\n\n    /**\n     * Get the ramp up time, specifying the delay between every operation.\n     *\n     * @return the number in seconds.\n     */\n    public Number getCreationRamp() {\n        return (Number) anyObject.get(\"creationRamp\");\n    }\n\n    /**\n     * Get the time when operation should be started.\n     *\n     * @return Date object representing the timestamp when bulk operation should be performed.\n     */\n    public Date getStartDate() {\n        return (Date) anyObject.get(\"startDate\");\n    }\n\n    /**\n     * Set the schedule time.\n     *\n     * @param startDate Date object with the time when bulk operation should be performed.\n     */\n    public void setStartDate(Date startDate) {\n        anyObject.put(\"startDate\", startDate);\n    }\n\n    /**\n     * Get the operation which will be executed for every device in the target group.\n     *\n     * @return Operation object representing the operation which will be executed for every device in the target group.\n     */\n    public Operation getOperation() {\n        Object operationPrototype = anyObject.get(\"operationPrototype\");\n        // At first we need to check the type to avoid an unnecessary wrap into Operation Object\n        if (operationPrototype instanceof Operation) {\n            return (Operation) operationPrototype;\n        }\n        return new Operation((ExtensibleObject) operationPrototype);\n    }\n\n    /**\n     * Set the operation which should be executed for every device in the target group.\n     *\n     * @param operation Operation object representing the operation which need to be executed for every device in the target group.\n     */\n    public void setOperation(Operation operation) {\n        anyObject.put(\"operationPrototype\", operation);\n    }\n\n    /**\n     * Get the progress of the bulk operation.\n     *\n     * @return Progress object containing the number of processed bulk operations.\n     */\n    public Progress getProgress() {\n        Object progress = anyObject.get(\"progress\");\n        // At first we need to check the type to avoid an unnecessary wrap into Progress Object\n        if (progress instanceof Progress) {\n            return (Progress) progress;\n        }\n        return new Progress((ExtensibleObject) progress);\n    }\n\n    /**\n     * Set the progress of the bulk operation.\n     *\n     * @param progress Progress object containing the number of processed bulk operations.\n     */\n    public void setProgress(Progress progress) {\n        anyObject.put(\"progress\", progress);\n    }\n}\n", "class_id": 0, "repo": "Matthimatiker/cot-java-rest-sdk", "file": "src/main/java/com/telekom/m2m/cot/restsdk/devicecontrol/BulkOperation.java", "last_update_at": "2021-04-30T23:56:52+00:00", "original_content": "public class BulkOperation extends ExtensibleObject {\n\n    /**\n     *  Status ACTIVE: when bulk operation is created.\n     */\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n\n    /**\n     *  Status IN_PROGRESS: when bulk operation is performing on all devices.\n     */\n    public static final String STATUS_IN_PROGRESS = \"IN_PROGRESS\";\n\n    /**\n     * Status COMPLETED: when the operation was performed on all devices.\n     */\n    public static final String STATUS_COMPLETED = \"COMPLETED\";\n\n    /**\n     * Status DELETED: when already created operation was cancelled by deleting the bulk operation\n     */\n    public static final String STATUS_DELETED = \"DELETED\";\n\n    /**\n     * Constructor to create a bulk operation.\n     */\n    public BulkOperation() {\n        super();\n    }\n\n    /**\n     * Internal constructor to create a bulk operation object.\n     *\n     * @param extensibleObject existing base class object.\n     */\n    BulkOperation(ExtensibleObject extensibleObject) {\n        super(extensibleObject);\n    }\n\n    /**\n     * Set the unique identifier of the bulk operation.\n     * Just used internally.\n     *\n     * @param id the new identifier created by storing the entity.\n     */\n    void setId(String id) {\n        anyObject.put(\"id\", id);\n    }\n\n    /**\n     * Get the unique identifier for the bulk operation.\n     *\n     * @return String with the unique identifier of the bulk operation or null if not\n     * available.\n     */\n    public String getId() {\n        Object id = anyObject.get(\"id\");\n        if (id == null) {\n            return null;\n        }\n        return id.toString();\n    }\n\n    /**\n     * Set the groupId of the target group on which the bulk operation should be performed.\n     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'\n     *\n     * @param groupId the unique identifier of the target group.\n     */\n    public void setGroupId(String groupId) {\n        anyObject.put(\"groupId\", groupId);\n    }\n\n    /**\n     * Get the groupId of the target group of the bulk operation.\n     *\n     * @return String with the unique identifier of the target group or null if not\n     * available.\n     */\n    public String getGroupId() {\n        return (String) anyObject.get(\"groupId\");\n    }\n\n    /**\n     * Set the bulk operation id to reschedule this operation on devices where it failed.\n     *\n     * @param failedBulkOperationId the unique identifier of the bulk operation.\n     */\n    public void setFailedBulkOperationId(String failedBulkOperationId) {\n        anyObject.put(\"failedBulkOperationId\", failedBulkOperationId);\n    }\n\n    /**\n     * Get the bulk operation id from which failed operation should be rescheduled.\n     *\n     * @return String with the unique identifier of the failed bulk operation id\n     * or null if not available.\n     */\n    public String getFailedBulkOperationId() {\n        return (String) anyObject.get(\"failedBulkOperationId\");\n    }\n\n    /**\n     * Get the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @return a String with the status\n     */\n    public String getStatus() {\n        return (String) anyObject.get(\"status\");\n    }\n\n    /**\n     * Set the status of the bulk operation.\n     * <p>\n     * Valid values: ACTIVE, COMPLETED, DELETED\n     *\n     * @param status String which represents the status of the bulk operation.\n     */\n    public void setStatus(String status) {\n        anyObject.put(\"status\", status);\n    }\n\n    /**\n     * Set the ramp up time, specifying the delay between every operation.\n     *\n     * @param creationRamp number in seconds.\n     */\n    public void setCreationRamp(Number creationRamp) {\n        anyObject.put(\"creationRamp\", creationRamp);\n    }\n\n    /**\n     * Get the ramp up time, specifying the delay between every operation.\n     *\n     * @return the number in seconds.\n     */\n    public Number getCreationRamp() {\n        return (Number) anyObject.get(\"creationRamp\");\n    }\n\n    /**\n     * Get the time when operation should be started.\n     *\n     * @return Date object representing the timestamp when bulk operation should be performed.\n     */\n    public Date getStartDate() {\n        return (Date) anyObject.get(\"startDate\");\n    }\n\n    /**\n     * Set the schedule time.\n     *\n     * @param startDate Date object with the time when bulk operation should be performed.\n     */\n    public void setStartDate(Date startDate) {\n        anyObject.put(\"startDate\", startDate);\n    }\n\n    /**\n     * Get the operation which will be executed for every device in the target group.\n     *\n     * @return Operation object representing the operation which will be executed for every device in the target group.\n     */\n    public Operation getOperation() {\n        Object operationPrototype = anyObject.get(\"operationPrototype\");\n        // At first we need to check the type to avoid an unnecessary wrap into Operation Object\n        if (operationPrototype instanceof Operation) {\n            return (Operation) operationPrototype;\n        }\n        return new Operation((ExtensibleObject) operationPrototype);\n    }\n\n    /**\n     * Set the operation which should be executed for every device in the target group.\n     *\n     * @param operation Operation object representing the operation which need to be executed for every device in the target group.\n     */\n    public void setOperation(Operation operation) {\n        anyObject.put(\"operationPrototype\", operation);\n    }\n\n    /**\n     * Get the progress of the bulk operation.\n     *\n     * @return Progress object containing the number of processed bulk operations.\n     */\n    public Progress getProgress() {\n        Object progress = anyObject.get(\"progress\");\n        // At first we need to check the type to avoid an unnecessary wrap into Progress Object\n        if (progress instanceof Progress) {\n            return (Progress) progress;\n        }\n        return new Progress((ExtensibleObject) progress);\n    }\n\n    /**\n     * Set the progress of the bulk operation.\n     *\n     * @param progress Progress object containing the number of processed bulk operations.\n     */\n    public void setProgress(Progress progress) {\n        anyObject.put(\"progress\", progress);\n    }\n}\n", "refactored": false}
{"hexsha": "04baabdf7c25ae7771d5baa86ba14663503d9f40", "ext": "java", "lang": "Java", "content": "@ConstantFieldsFirstExcept({})\n@ConstantFieldsSecondExcept({})\npublic class StratosphereSqlCrossOperator extends CrossFunction {\n\n    private static final long serialVersionUID = 1L;\n\n    private Filter filter;\n\n    public StratosphereSqlCrossOperator(Filter f) {\n        this.filter = f;\n    }\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        // TODO Auto-generated method stub\n        super.open(parameters);\n        filter.prepareEvaluation();\n    }\n\n    @Override\n    public void cross(Record record1, Record record2, Collector<Record> out) throws Exception {\n        if (filter.evaluateTwo(record1, record2)) {\n            System.err.println(\"Cross got rec1=\" + record1 + \" rec2=\" + record2);\n            record1.concatenate(record2);\n            System.err.println(\"Cross is outputting \" + record1);\n            out.collect(record1);\n        }\n    }\n}\n", "class_id": 0, "repo": "rmetzger/stratosphere-sql", "file": "src/main/java/eu/stratosphere/sql/relOpt/join/StratosphereSqlCrossOperator.java", "last_update_at": "2021-09-08T11:01:56+00:00", "original_content": "@ConstantFieldsFirstExcept({})\n@ConstantFieldsSecondExcept({})\npublic class StratosphereSqlCrossOperator extends CrossFunction {\n\n    private static final long serialVersionUID = 1L;\n\n    private Filter filter;\n\n    public StratosphereSqlCrossOperator(Filter f) {\n        this.filter = f;\n    }\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        // TODO Auto-generated method stub\n        super.open(parameters);\n        filter.prepareEvaluation();\n    }\n\n    @Override\n    public void cross(Record record1, Record record2, Collector<Record> out) throws Exception {\n        if (filter.evaluateTwo(record1, record2)) {\n            System.err.println(\"Cross got rec1=\" + record1 + \" rec2=\" + record2);\n            record1.concatenate(record2);\n            System.err.println(\"Cross is outputting \" + record1);\n            out.collect(record1);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "f72f58de555633dae38ae5ca07680378374dc88b", "ext": "java", "lang": "Java", "content": "public class StickyKey {\n\n    public static final StickyKey DEFAULT = new StickyKey(0, 0);\n\n    public final long clusterId;\n\n    public final long stickyId;\n\n    private StickyKey(final long clusterId, final long stickyId) {\n        this.clusterId = (clusterId <= 0 ? 0 : clusterId);\n        this.stickyId = (stickyId <= 0 ? 0 : stickyId);\n    }\n\n    public static StickyKey valueOf(final String clusterName, final String stickyName) {\n        final long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));\n        final long stickyId = IOHelper.longIdFromString(stickyName);\n        if (clusterName != null) {\n            Log.info(StickyKey.class.getSimpleName(), \"Mapped clusterName=\" + clusterName + \" clusterId=\" + clusterId);\n        }\n        if (stickyName != null) {\n            Log.info(StickyKey.class.getSimpleName(), \"Mapped stickyName=\" + stickyName + \" stickyId=\" + stickyId);\n        }\n        return valueOf(clusterId, stickyId);\n    }\n\n    public static StickyKey valueOf(final long clusterId, final long stickyId) {\n        return new StickyKey(clusterId, stickyId);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj instanceof StickyKey) {\n            final StickyKey o = (StickyKey) obj;\n            return ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));\n    }\n\n    @Override\n    public String toString() {\n        return super.toString() + \"[clusterId=\" + clusterId + \" stickyId=\" + stickyId + \"]\";\n    }\n}\n", "class_id": 0, "repo": "ggrandes/jrinetd", "file": "src/main/java/org/javastack/jrinetd/StickyKey.java", "last_update_at": "2021-11-10T10:37:44+00:00", "original_content": "public class StickyKey {\n\n    public static final StickyKey DEFAULT = new StickyKey(0, 0);\n\n    public final long clusterId;\n\n    public final long stickyId;\n\n    private StickyKey(final long clusterId, final long stickyId) {\n        this.clusterId = (clusterId <= 0 ? 0 : clusterId);\n        this.stickyId = (stickyId <= 0 ? 0 : stickyId);\n    }\n\n    public static StickyKey valueOf(final String clusterName, final String stickyName) {\n        final long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));\n        final long stickyId = IOHelper.longIdFromString(stickyName);\n        if (clusterName != null) {\n            Log.info(StickyKey.class.getSimpleName(), \"Mapped clusterName=\" + clusterName + \" clusterId=\" + clusterId);\n        }\n        if (stickyName != null) {\n            Log.info(StickyKey.class.getSimpleName(), \"Mapped stickyName=\" + stickyName + \" stickyId=\" + stickyId);\n        }\n        return valueOf(clusterId, stickyId);\n    }\n\n    public static StickyKey valueOf(final long clusterId, final long stickyId) {\n        return new StickyKey(clusterId, stickyId);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj instanceof StickyKey) {\n            final StickyKey o = (StickyKey) obj;\n            return ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));\n    }\n\n    @Override\n    public String toString() {\n        return super.toString() + \"[clusterId=\" + clusterId + \" stickyId=\" + stickyId + \"]\";\n    }\n}\n", "refactored": false}
{"hexsha": "2e39263ceb6cb884efccdb282a6247b85892ec0e", "ext": "java", "lang": "Java", "content": "public class ConfigTest {\n\n    Connection conn;\n\n    Session session;\n\n    public static final String uri = \"table:test_config06\";\n\n    public static final String key = \"keyABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    public static final String value = \"valueABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    public void session_config(String config) {\n        Exception e = null;\n        try {\n            session.create(uri, config);\n        } catch (WiredTigerException wte) {\n            e = wte;\n        }\n        Assert.assertTrue(e != null && e.toString().indexOf(\"Invalid argument\") >= 0);\n    }\n\n    // Edge cases for key/value formats.\n    @Test\n    public void test_session_config() throws WiredTigerException {\n        setup();\n        System.err.println(\"\\n-- expect error output --\");\n        session_config(\"key_format=A,value_format=S\");\n        session_config(\"key_format=S,value_format=A\");\n        session_config(\"key_format=0s,value_format=s\");\n        session_config(\"key_format=s,value_format=0s\");\n        session_config(\"key_format=0t,value_format=4t\");\n        session_config(\"key_format=4t,value_format=0t\");\n        System.err.println(\"-- end expected error output --\");\n        teardown();\n    }\n\n    // ignore trailing bytes, verify that.\n    public void format_string(String fmt, int len) throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=\" + len + fmt + \",value_format=\" + len + fmt);\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0, len));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0, len), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_S_1() throws WiredTigerException {\n        format_string(\"S\", 1);\n    }\n\n    @Test\n    public void test_format_string_S_4() throws WiredTigerException {\n        format_string(\"S\", 4);\n    }\n\n    @Test\n    public void test_format_string_S_10() throws WiredTigerException {\n        format_string(\"S\", 10);\n    }\n\n    @Test\n    public void test_format_string_s_1() throws WiredTigerException {\n        format_string(\"s\", 1);\n    }\n\n    @Test\n    public void test_format_string_s_4() throws WiredTigerException {\n        format_string(\"s\", 4);\n    }\n\n    @Test\n    public void test_format_string_s_10() throws WiredTigerException {\n        format_string(\"s\", 10);\n    }\n\n    @Test\n    public void test_format_string_S_default() throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=S,value_format=S\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key);\n        assertEquals(0, cursor.search());\n        assertEquals(value, cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_s_default() throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=s,value_format=s\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0, 1));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0, 1), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    public static void main(String[] args) {\n        ConfigTest tester = new ConfigTest();\n        try {\n            tester.test_session_config();\n            tester.test_format_string_S_1();\n            tester.test_format_string_S_4();\n            tester.test_format_string_S_10();\n            tester.test_format_string_s_1();\n            tester.test_format_string_s_4();\n            tester.test_format_string_s_10();\n            tester.test_format_string_S_default();\n            tester.test_format_string_s_default();\n        } catch (WiredTigerException wte) {\n            System.err.println(\"WiredTigerException: \" + wte);\n        }\n    }\n\n    private void setup() {\n        conn = wiredtiger.open(\"WT_HOME\", \"create\");\n        session = conn.open_session(null);\n    }\n\n    private void teardown() {\n        session.close(\"\");\n        conn.close(\"\");\n    }\n}\n", "class_id": 0, "repo": "danx0r/mongo", "file": "src/third_party/wiredtiger/test/java/com/wiredtiger/test/ConfigTest.java", "last_update_at": "2021-03-22T03:15:56+00:00", "original_content": "public class ConfigTest {\n\n    Connection conn;\n\n    Session session;\n\n    public static final String uri = \"table:test_config06\";\n\n    public static final String key = \"keyABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    public static final String value = \"valueABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    public void session_config(String config) {\n        Exception e = null;\n        try {\n            session.create(uri, config);\n        } catch (WiredTigerException wte) {\n            e = wte;\n        }\n        Assert.assertTrue(e != null && e.toString().indexOf(\"Invalid argument\") >= 0);\n    }\n\n    // Edge cases for key/value formats.\n    @Test\n    public void test_session_config() throws WiredTigerException {\n        setup();\n        System.err.println(\"\\n-- expect error output --\");\n        session_config(\"key_format=A,value_format=S\");\n        session_config(\"key_format=S,value_format=A\");\n        session_config(\"key_format=0s,value_format=s\");\n        session_config(\"key_format=s,value_format=0s\");\n        session_config(\"key_format=0t,value_format=4t\");\n        session_config(\"key_format=4t,value_format=0t\");\n        System.err.println(\"-- end expected error output --\");\n        teardown();\n    }\n\n    // ignore trailing bytes, verify that.\n    public void format_string(String fmt, int len) throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=\" + len + fmt + \",value_format=\" + len + fmt);\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0, len));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0, len), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_S_1() throws WiredTigerException {\n        format_string(\"S\", 1);\n    }\n\n    @Test\n    public void test_format_string_S_4() throws WiredTigerException {\n        format_string(\"S\", 4);\n    }\n\n    @Test\n    public void test_format_string_S_10() throws WiredTigerException {\n        format_string(\"S\", 10);\n    }\n\n    @Test\n    public void test_format_string_s_1() throws WiredTigerException {\n        format_string(\"s\", 1);\n    }\n\n    @Test\n    public void test_format_string_s_4() throws WiredTigerException {\n        format_string(\"s\", 4);\n    }\n\n    @Test\n    public void test_format_string_s_10() throws WiredTigerException {\n        format_string(\"s\", 10);\n    }\n\n    @Test\n    public void test_format_string_S_default() throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=S,value_format=S\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key);\n        assertEquals(0, cursor.search());\n        assertEquals(value, cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    @Test\n    public void test_format_string_s_default() throws WiredTigerException {\n        setup();\n        session.create(uri, \"key_format=s,value_format=s\");\n        Cursor cursor = session.open_cursor(uri, null, null);\n        cursor.putKeyString(key);\n        cursor.putValueString(value);\n        cursor.insert();\n        cursor.putKeyString(key.substring(0, 1));\n        assertEquals(0, cursor.search());\n        assertEquals(value.substring(0, 1), cursor.getValueString());\n        cursor.close();\n        session.drop(uri, null);\n        teardown();\n    }\n\n    public static void main(String[] args) {\n        ConfigTest tester = new ConfigTest();\n        try {\n            tester.test_session_config();\n            tester.test_format_string_S_1();\n            tester.test_format_string_S_4();\n            tester.test_format_string_S_10();\n            tester.test_format_string_s_1();\n            tester.test_format_string_s_4();\n            tester.test_format_string_s_10();\n            tester.test_format_string_S_default();\n            tester.test_format_string_s_default();\n        } catch (WiredTigerException wte) {\n            System.err.println(\"WiredTigerException: \" + wte);\n        }\n    }\n\n    private void setup() {\n        conn = wiredtiger.open(\"WT_HOME\", \"create\");\n        session = conn.open_session(null);\n    }\n\n    private void teardown() {\n        session.close(\"\");\n        conn.close(\"\");\n    }\n}\n", "refactored": false}
{"hexsha": "0e0da15f7cbb858c23517f700b77e09fcb2e8e1f", "ext": "java", "lang": "Java", "content": "@WebServlet(name = \"smarthomeUpdate\", urlPatterns = \"/smarthome/update\")\npublic class SmartHomeUpdateServlet extends HttpServlet {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);\n\n    private static MyDataStore database = MyDataStore.getInstance();\n\n    private final SmartHomeApp actionsApp = new MySmartHomeApp();\n\n    //private String msg;\n    private static final List<String> UPDATE_DEVICE_PARAMS_KEYS = Arrays.asList(new String[] { \"name\", \"nickname\", \"localDeviceId\", \"errorCode\", \"tfa\" });\n\n    {\n        try {\n            GoogleCredentials credentials = GoogleCredentials.fromStream(getClass().getResourceAsStream(\"/smart-home-key.json\"));\n            actionsApp.setCredentials(credentials);\n        } catch (Exception e) {\n            LOGGER.error(\"couldn't load credentials\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String body = req.getReader().lines().collect(Collectors.joining());\n        LOGGER.info(\"doPost, body = {}\", body);\n        JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();\n        String userId = bodyJson.get(\"userId\").getAsString();\n        String deviceId = bodyJson.get(\"deviceId\").getAsString();\n        JsonObject states = bodyJson.getAsJsonObject(\"states\");\n        Map<String, Object> deviceStates = states != null ? new Gson().fromJson(states, HashMap.class) : null;\n        Map<String, String> deviceParams = new HashMap<>();\n        Set<String> deviceParamsKeys = bodyJson.keySet();\n        deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);\n        for (String k : deviceParamsKeys) {\n            deviceParams.put(k, bodyJson.get(k).getAsString());\n        }\n        try {\n            database.updateDevice(userId, deviceId, deviceStates, deviceParams);\n            if (deviceParams.containsKey(\"localDeviceId\")) {\n                actionsApp.requestSync(userId);\n            }\n            if (states != null) {\n                ReportState.makeRequest(actionsApp, userId, deviceId, states);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"failed to update device: {}\", e);\n            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n            res.setContentType(\"text/plain\");\n            res.getWriter().println(\"ERROR\");\n            return;\n        }\n        res.setStatus(HttpServletResponse.SC_OK);\n        res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        res.setContentType(\"text/plain\");\n        res.getWriter().println(\"OK\");\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/plain\");\n        response.getWriter().println(\"/smarthome/update is a POST call\");\n    }\n\n    @Override\n    protected void doOptions(HttpServletRequest req, HttpServletResponse res) {\n        // pre-flight request processing\n        res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n        res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,Accept,Origin\");\n    }\n}\n", "class_id": 0, "repo": "aniketkumar2012/GH_Home_Smart_Devices", "file": "src/main/java/com/example/SmartHomeUpdateServlet.java", "last_update_at": "2021-09-25T07:01:30+00:00", "original_content": "@WebServlet(name = \"smarthomeUpdate\", urlPatterns = \"/smarthome/update\")\npublic class SmartHomeUpdateServlet extends HttpServlet {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);\n\n    private static MyDataStore database = MyDataStore.getInstance();\n\n    private final SmartHomeApp actionsApp = new MySmartHomeApp();\n\n    //private String msg;\n    private static final List<String> UPDATE_DEVICE_PARAMS_KEYS = Arrays.asList(new String[] { \"name\", \"nickname\", \"localDeviceId\", \"errorCode\", \"tfa\" });\n\n    {\n        try {\n            GoogleCredentials credentials = GoogleCredentials.fromStream(getClass().getResourceAsStream(\"/smart-home-key.json\"));\n            actionsApp.setCredentials(credentials);\n        } catch (Exception e) {\n            LOGGER.error(\"couldn't load credentials\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String body = req.getReader().lines().collect(Collectors.joining());\n        LOGGER.info(\"doPost, body = {}\", body);\n        JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();\n        String userId = bodyJson.get(\"userId\").getAsString();\n        String deviceId = bodyJson.get(\"deviceId\").getAsString();\n        JsonObject states = bodyJson.getAsJsonObject(\"states\");\n        Map<String, Object> deviceStates = states != null ? new Gson().fromJson(states, HashMap.class) : null;\n        Map<String, String> deviceParams = new HashMap<>();\n        Set<String> deviceParamsKeys = bodyJson.keySet();\n        deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);\n        for (String k : deviceParamsKeys) {\n            deviceParams.put(k, bodyJson.get(k).getAsString());\n        }\n        try {\n            database.updateDevice(userId, deviceId, deviceStates, deviceParams);\n            if (deviceParams.containsKey(\"localDeviceId\")) {\n                actionsApp.requestSync(userId);\n            }\n            if (states != null) {\n                ReportState.makeRequest(actionsApp, userId, deviceId, states);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"failed to update device: {}\", e);\n            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n            res.setContentType(\"text/plain\");\n            res.getWriter().println(\"ERROR\");\n            return;\n        }\n        res.setStatus(HttpServletResponse.SC_OK);\n        res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        res.setContentType(\"text/plain\");\n        res.getWriter().println(\"OK\");\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/plain\");\n        response.getWriter().println(\"/smarthome/update is a POST call\");\n    }\n\n    @Override\n    protected void doOptions(HttpServletRequest req, HttpServletResponse res) {\n        // pre-flight request processing\n        res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n        res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,Accept,Origin\");\n    }\n}\n", "refactored": false}
{"hexsha": "b08f107779d239c4b7d57ae1d699871248d132d2", "ext": "java", "lang": "Java", "content": "public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {\n\n    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {\n\n        private JpaGpsDevice device;\n\n        public OpenJPAEventListener(JpaGpsDevice device) {\n            this.device = device;\n        }\n\n        @Override\n        protected JpaGpsDevice getDevice() {\n            return this.device;\n        }\n\n        public void beforeDelete(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterDelete(LifecycleEvent lifecycleEvent) {\n            postRemove(lifecycleEvent.getSource());\n        }\n\n        public void beforePersist(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterPersist(LifecycleEvent lifecycleEvent) {\n            postPersist(lifecycleEvent.getSource());\n        }\n\n        public void beforeStore(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterStore(LifecycleEvent lifecycleEvent) {\n            postUpdate(lifecycleEvent.getSource());\n        }\n    }\n\n    private boolean useSpecificClassEvents = true;\n\n    private ClassLoader classLoader;\n\n    private Object eventListener;\n\n    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {\n        this.useSpecificClassEvents = useSpecificClassEvents;\n    }\n\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Allows to directly inject the event listener that will be used with Open JPA. Will\n     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.\n     */\n    public void setEventListener(Object eventListener) {\n        this.eventListener = eventListener;\n    }\n\n    public boolean requireRefresh() {\n        return true;\n    }\n\n    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        if (eventListener == null) {\n            eventListener = new OpenJPAEventListener(device);\n        }\n        if (useSpecificClassEvents) {\n            ArrayList<Class> matchedClasses = new ArrayList<Class>();\n            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);\n            for (Class clazz : classes) {\n                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);\n                Class mappedClass = classMetaData.getDescribedType();\n                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {\n                    matchedClasses.add(mappedClass);\n                }\n            }\n            if (matchedClasses.size() > 0) {\n                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));\n            }\n        } else {\n            emf.addLifecycleListener(eventListener);\n        }\n    }\n\n    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        eventListener = new OpenJPAEventListener(device);\n        emf.removeLifecycleListener(eventListener);\n    }\n}\n", "class_id": 0, "repo": "guaxinim/compass", "file": "src/main/src/org/compass/gps/device/jpa/lifecycle/OpenJPAJpaEntityLifecycleInjector.java", "last_update_at": "2021-11-10T06:48:02+00:00", "original_content": "public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {\n\n    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {\n\n        private JpaGpsDevice device;\n\n        public OpenJPAEventListener(JpaGpsDevice device) {\n            this.device = device;\n        }\n\n        @Override\n        protected JpaGpsDevice getDevice() {\n            return this.device;\n        }\n\n        public void beforeDelete(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterDelete(LifecycleEvent lifecycleEvent) {\n            postRemove(lifecycleEvent.getSource());\n        }\n\n        public void beforePersist(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterPersist(LifecycleEvent lifecycleEvent) {\n            postPersist(lifecycleEvent.getSource());\n        }\n\n        public void beforeStore(LifecycleEvent lifecycleEvent) {\n        }\n\n        public void afterStore(LifecycleEvent lifecycleEvent) {\n            postUpdate(lifecycleEvent.getSource());\n        }\n    }\n\n    private boolean useSpecificClassEvents = true;\n\n    private ClassLoader classLoader;\n\n    private Object eventListener;\n\n    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {\n        this.useSpecificClassEvents = useSpecificClassEvents;\n    }\n\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Allows to directly inject the event listener that will be used with Open JPA. Will\n     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.\n     */\n    public void setEventListener(Object eventListener) {\n        this.eventListener = eventListener;\n    }\n\n    public boolean requireRefresh() {\n        return true;\n    }\n\n    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        if (eventListener == null) {\n            eventListener = new OpenJPAEventListener(device);\n        }\n        if (useSpecificClassEvents) {\n            ArrayList<Class> matchedClasses = new ArrayList<Class>();\n            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);\n            for (Class clazz : classes) {\n                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);\n                Class mappedClass = classMetaData.getDescribedType();\n                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {\n                    matchedClasses.add(mappedClass);\n                }\n            }\n            if (matchedClasses.size() > 0) {\n                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));\n            }\n        } else {\n            emf.addLifecycleListener(eventListener);\n        }\n    }\n\n    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {\n        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0\n        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);\n        eventListener = new OpenJPAEventListener(device);\n        emf.removeLifecycleListener(eventListener);\n    }\n}\n", "refactored": false}
{"hexsha": "44cf8deda1243d30e680509d78d40d7907b51d93", "ext": "java", "lang": "Java", "content": "@Configuration\r\npublic class ShiroConfig {\r\n\r\n    @Bean(\"sessionManager\")\r\n    public SessionManager sessionManager() {\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n        sessionManager.setSessionValidationSchedulerEnabled(true);\r\n        sessionManager.setSessionIdCookieEnabled(true);\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean(\"securityManager\")\r\n    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(oAuth2Realm);\r\n        securityManager.setSessionManager(sessionManager);\r\n        return securityManager;\r\n    }\r\n\r\n    @Bean(\"shiroFilter\")\r\n    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n        //oauth??\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"oauth2\", new OAuth2Filter());\r\n        shiroFilter.setFilters(filters);\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/webjars/**\", \"anon\");\r\n        filterMap.put(\"/druid/**\", \"anon\");\r\n        filterMap.put(\"/app/**\", \"anon\");\r\n        filterMap.put(\"/sys/login\", \"anon\");\r\n        filterMap.put(\"/swagger/**\", \"anon\");\r\n        filterMap.put(\"/v2/api-docs\", \"anon\");\r\n        filterMap.put(\"/swagger-ui.html\", \"anon\");\r\n        filterMap.put(\"/swagger-resources/**\", \"anon\");\r\n        filterMap.put(\"/captcha.jpg\", \"anon\");\r\n        filterMap.put(\"/webname\", \"anon\");\r\n        filterMap.put(\"/licence/**\", \"anon\");\r\n        filterMap.put(\"/report/**\", \"anon\");\r\n        filterMap.put(\"/**/*.html\", \"anon\");\r\n        filterMap.put(\"/fonts/**\", \"anon\");\r\n        filterMap.put(\"/**/*.js\", \"anon\");\r\n        filterMap.put(\"/**/*.css\", \"anon\");\r\n        filterMap.put(\"/plugins/**\", \"anon\");\r\n        filterMap.put(\"/**/*.jpg\", \"anon\");\r\n        filterMap.put(\"/**/*.mp4\", \"anon\");\r\n        filterMap.put(\"/**/*.zip\", \"anon\");\r\n        filterMap.put(\"/**/*.png\", \"anon\");\r\n        filterMap.put(\"/\", \"anon\");\r\n        filterMap.put(\"/**\", \"oauth2\");\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n        return shiroFilter;\r\n    }\r\n\r\n    @Bean(\"lifecycleBeanPostProcessor\")\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        proxyCreator.setProxyTargetClass(true);\r\n        return proxyCreator;\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "stuMental/StudentMental", "file": "src/main/java/io/student/config/ShiroConfig.java", "last_update_at": "2021-09-20T20:44:43+00:00", "original_content": "@Configuration\r\npublic class ShiroConfig {\r\n\r\n    @Bean(\"sessionManager\")\r\n    public SessionManager sessionManager() {\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n        sessionManager.setSessionValidationSchedulerEnabled(true);\r\n        sessionManager.setSessionIdCookieEnabled(true);\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean(\"securityManager\")\r\n    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        securityManager.setRealm(oAuth2Realm);\r\n        securityManager.setSessionManager(sessionManager);\r\n        return securityManager;\r\n    }\r\n\r\n    @Bean(\"shiroFilter\")\r\n    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n        //oauth??\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"oauth2\", new OAuth2Filter());\r\n        shiroFilter.setFilters(filters);\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/webjars/**\", \"anon\");\r\n        filterMap.put(\"/druid/**\", \"anon\");\r\n        filterMap.put(\"/app/**\", \"anon\");\r\n        filterMap.put(\"/sys/login\", \"anon\");\r\n        filterMap.put(\"/swagger/**\", \"anon\");\r\n        filterMap.put(\"/v2/api-docs\", \"anon\");\r\n        filterMap.put(\"/swagger-ui.html\", \"anon\");\r\n        filterMap.put(\"/swagger-resources/**\", \"anon\");\r\n        filterMap.put(\"/captcha.jpg\", \"anon\");\r\n        filterMap.put(\"/webname\", \"anon\");\r\n        filterMap.put(\"/licence/**\", \"anon\");\r\n        filterMap.put(\"/report/**\", \"anon\");\r\n        filterMap.put(\"/**/*.html\", \"anon\");\r\n        filterMap.put(\"/fonts/**\", \"anon\");\r\n        filterMap.put(\"/**/*.js\", \"anon\");\r\n        filterMap.put(\"/**/*.css\", \"anon\");\r\n        filterMap.put(\"/plugins/**\", \"anon\");\r\n        filterMap.put(\"/**/*.jpg\", \"anon\");\r\n        filterMap.put(\"/**/*.mp4\", \"anon\");\r\n        filterMap.put(\"/**/*.zip\", \"anon\");\r\n        filterMap.put(\"/**/*.png\", \"anon\");\r\n        filterMap.put(\"/\", \"anon\");\r\n        filterMap.put(\"/**\", \"oauth2\");\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n        return shiroFilter;\r\n    }\r\n\r\n    @Bean(\"lifecycleBeanPostProcessor\")\r\n    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {\r\n        return new LifecycleBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        proxyCreator.setProxyTargetClass(true);\r\n        return proxyCreator;\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();\r\n        advisor.setSecurityManager(securityManager);\r\n        return advisor;\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "117f3d055e06497bc9bf38c477b32879ef1305eb", "ext": "java", "lang": "Java", "content": "public class MultiAtlasTest {\n\n    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);\n\n    private final Atlas base = new PackedAtlasTest().getAtlas();\n\n    private Atlas other;\n\n    private MultiAtlas multi;\n\n    @Test\n    public void connectivityTest() {\n        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));\n        // Out edges of CC2: 987\n        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());\n        Assert.assertEquals(987, this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());\n        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());\n        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());\n        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());\n    }\n\n    public Atlas getAtlas() {\n        if (this.multi == null) {\n            setup();\n        }\n        return this.multi;\n    }\n\n    @Before\n    public void setup() {\n        final PackedAtlasBuilder builder = new PackedAtlasBuilder().withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));\n        final Map<String, String> edge5Tags = new HashMap<>();\n        edge5Tags.put(\"highway\", \"primary\");\n        edge5Tags.put(\"name\", \"edge5\");\n        edge5Tags.put(\"surface\", \"concrete\");\n        edge5Tags.put(\"lanes\", \"3\");\n        final Map<String, String> edge6Tags = new HashMap<>();\n        edge6Tags.put(\"highway\", \"secondary\");\n        edge6Tags.put(\"name\", \"edge98\");\n        edge6Tags.put(\"bridge\", \"cantilever\");\n        edge6Tags.put(\"maxspeed\", \"100\");\n        final Map<String, String> nodeTags = new HashMap<>();\n        nodeTags.put(\"highway\", \"traffic_signal\");\n        // shared\n        builder.addNode(123, Location.TEST_6, nodeTags);\n        // shared\n        builder.addNode(12345, Location.TEST_2, nodeTags);\n        // private\n        builder.addNode(4, Location.TEST_1, nodeTags);\n        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);\n        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);\n        // This one is already in the base atlas\n        final RelationBean structure1 = new RelationBean();\n        // structure1.addItem(null, \"out\", ItemType.EDGE);\n        structure1.addItem(4L, \"notThere\", ItemType.NODE);\n        final RelationBean structure3 = new RelationBean();\n        structure3.addItem(5L, \"in\", ItemType.EDGE);\n        structure3.addItem(12345L, \"node\", ItemType.NODE);\n        structure3.addItem(6L, \"out\", ItemType.EDGE);\n        // Add relations\n        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());\n        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());\n        this.other = builder.get();\n        this.multi = new MultiAtlas(this.base, this.other);\n    }\n\n    @Test\n    public void spatialIndexTest() {\n        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);\n        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));\n        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());\n        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));\n        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();\n        Assert.assertEquals(6, edgeIterator.next().getIdentifier());\n        Assert.assertEquals(5, edgeIterator.next().getIdentifier());\n        Assert.assertFalse(edgeIterator.hasNext());\n    }\n\n    @Test\n    public void testSlicedRelation() {\n        final Relation relation1 = this.multi.relation(1L);\n        final RelationMemberList members = relation1.members();\n        Assert.assertEquals(4, members.size());\n        for (int i = 0; i < members.size(); i++) {\n            Assert.assertTrue(members.get(i) != null);\n        }\n        // Members are ordered by entity type and ascending member identifier\n        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());\n        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());\n        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());\n        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());\n        final Relation relation2 = this.multi.relation(2L);\n        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();\n        final Relation relation3 = this.multi.relation(3L);\n        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();\n        Assert.assertEquals(8, allMembers2.size());\n        Assert.assertEquals(8, allMembers3.size());\n    }\n\n    @Test\n    public void totalTest() {\n        final Iterator<Edge> edges = this.multi.edges().iterator();\n        int numberEdges = 0;\n        for (; edges.hasNext(); ) {\n            numberEdges++;\n            edges.next();\n        }\n        Assert.assertEquals(6, numberEdges);\n        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(3, Iterables.size(this.multi.relations()));\n    }\n}\n", "class_id": 0, "repo": "gitclonefun/atlas", "file": "src/test/java/org/openstreetmap/atlas/geography/atlas/multi/MultiAtlasTest.java", "last_update_at": "2021-07-07T12:27:00+00:00", "original_content": "public class MultiAtlasTest {\n\n    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);\n\n    private final Atlas base = new PackedAtlasTest().getAtlas();\n\n    private Atlas other;\n\n    private MultiAtlas multi;\n\n    @Test\n    public void connectivityTest() {\n        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));\n        // Out edges of CC2: 987\n        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());\n        Assert.assertEquals(987, this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());\n        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());\n        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());\n        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());\n    }\n\n    public Atlas getAtlas() {\n        if (this.multi == null) {\n            setup();\n        }\n        return this.multi;\n    }\n\n    @Before\n    public void setup() {\n        final PackedAtlasBuilder builder = new PackedAtlasBuilder().withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));\n        final Map<String, String> edge5Tags = new HashMap<>();\n        edge5Tags.put(\"highway\", \"primary\");\n        edge5Tags.put(\"name\", \"edge5\");\n        edge5Tags.put(\"surface\", \"concrete\");\n        edge5Tags.put(\"lanes\", \"3\");\n        final Map<String, String> edge6Tags = new HashMap<>();\n        edge6Tags.put(\"highway\", \"secondary\");\n        edge6Tags.put(\"name\", \"edge98\");\n        edge6Tags.put(\"bridge\", \"cantilever\");\n        edge6Tags.put(\"maxspeed\", \"100\");\n        final Map<String, String> nodeTags = new HashMap<>();\n        nodeTags.put(\"highway\", \"traffic_signal\");\n        // shared\n        builder.addNode(123, Location.TEST_6, nodeTags);\n        // shared\n        builder.addNode(12345, Location.TEST_2, nodeTags);\n        // private\n        builder.addNode(4, Location.TEST_1, nodeTags);\n        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);\n        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);\n        // This one is already in the base atlas\n        final RelationBean structure1 = new RelationBean();\n        // structure1.addItem(null, \"out\", ItemType.EDGE);\n        structure1.addItem(4L, \"notThere\", ItemType.NODE);\n        final RelationBean structure3 = new RelationBean();\n        structure3.addItem(5L, \"in\", ItemType.EDGE);\n        structure3.addItem(12345L, \"node\", ItemType.NODE);\n        structure3.addItem(6L, \"out\", ItemType.EDGE);\n        // Add relations\n        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());\n        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());\n        this.other = builder.get();\n        this.multi = new MultiAtlas(this.base, this.other);\n    }\n\n    @Test\n    public void spatialIndexTest() {\n        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);\n        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));\n        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());\n        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));\n        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();\n        Assert.assertEquals(6, edgeIterator.next().getIdentifier());\n        Assert.assertEquals(5, edgeIterator.next().getIdentifier());\n        Assert.assertFalse(edgeIterator.hasNext());\n    }\n\n    @Test\n    public void testSlicedRelation() {\n        final Relation relation1 = this.multi.relation(1L);\n        final RelationMemberList members = relation1.members();\n        Assert.assertEquals(4, members.size());\n        for (int i = 0; i < members.size(); i++) {\n            Assert.assertTrue(members.get(i) != null);\n        }\n        // Members are ordered by entity type and ascending member identifier\n        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());\n        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());\n        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());\n        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());\n        final Relation relation2 = this.multi.relation(2L);\n        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();\n        final Relation relation3 = this.multi.relation(3L);\n        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();\n        Assert.assertEquals(8, allMembers2.size());\n        Assert.assertEquals(8, allMembers3.size());\n    }\n\n    @Test\n    public void totalTest() {\n        final Iterator<Edge> edges = this.multi.edges().iterator();\n        int numberEdges = 0;\n        while (edges.hasNext()) {\n            numberEdges++;\n            edges.next();\n        }\n        Assert.assertEquals(6, numberEdges);\n        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(6, Iterables.size(this.multi.edges()));\n        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));\n        Assert.assertEquals(3, Iterables.size(this.multi.relations()));\n    }\n}\n", "refactored": true}
{"hexsha": "6bfcbd87be2fa0596ebe5830cc52201b86851996", "ext": "java", "lang": "Java", "content": "public class FeedJournalStorage implements JournalStorage {\n\n    private FeedJournalBridge mFeedJournalBridge;\n\n    /**\n     * Creates a {@link FeedJournalStorage} for storing journals for the current user.\n     *\n     * @param profile {@link Profile} of the user we are rendering the Feed for.\n     */\n    public FeedJournalStorage(Profile profile) {\n        mFeedJournalBridge = new FeedJournalBridge(profile);\n    }\n\n    /**\n     * Creates a {@link FeedJournalStorage} for testing.\n     *\n     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.\n     */\n    @VisibleForTesting\n    public FeedJournalStorage(FeedJournalBridge bridge) {\n        mFeedJournalBridge = bridge;\n    }\n\n    /**\n     * Cleans up {@link FeedJournalStorage}.\n     */\n    public void destroy() {\n        assert mFeedJournalBridge != null;\n        mFeedJournalBridge.destroy();\n        mFeedJournalBridge = null;\n    }\n\n    @Override\n    public void read(String journalName, Consumer<Result<List<byte[]>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {\n                List<byte[]> journal = Arrays.asList(entries);\n                consumer.accept(Result.success(journal));\n            }, (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.commitJournalMutation(mutation, (Boolean result) -> consumer.accept(result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n\n    @Override\n    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.doesJournalExist(journalName, (Boolean exist) -> consumer.accept(Result.success(exist)), (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void getAllJournals(Consumer<Result<List<String>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadAllJournalKeys((String[] data) -> consumer.accept(Result.success(Arrays.asList(data))), (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void deleteAll(Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.deleteAllJournals((Boolean result) -> consumer.accept(result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n}\n", "class_id": 0, "repo": "jhonatasrm/chromium-android", "file": "app/src/main/java/org/chromium/chrome/browser/feed/FeedJournalStorage.java", "last_update_at": "2021-11-18T09:04:42+00:00", "original_content": "public class FeedJournalStorage implements JournalStorage {\n\n    private FeedJournalBridge mFeedJournalBridge;\n\n    /**\n     * Creates a {@link FeedJournalStorage} for storing journals for the current user.\n     *\n     * @param profile {@link Profile} of the user we are rendering the Feed for.\n     */\n    public FeedJournalStorage(Profile profile) {\n        mFeedJournalBridge = new FeedJournalBridge(profile);\n    }\n\n    /**\n     * Creates a {@link FeedJournalStorage} for testing.\n     *\n     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.\n     */\n    @VisibleForTesting\n    public FeedJournalStorage(FeedJournalBridge bridge) {\n        mFeedJournalBridge = bridge;\n    }\n\n    /**\n     * Cleans up {@link FeedJournalStorage}.\n     */\n    public void destroy() {\n        assert mFeedJournalBridge != null;\n        mFeedJournalBridge.destroy();\n        mFeedJournalBridge = null;\n    }\n\n    @Override\n    public void read(String journalName, Consumer<Result<List<byte[]>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {\n                List<byte[]> journal = Arrays.asList(entries);\n                consumer.accept(Result.success(journal));\n            }, (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.commitJournalMutation(mutation, (Boolean result) -> consumer.accept(result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n\n    @Override\n    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.doesJournalExist(journalName, (Boolean exist) -> consumer.accept(Result.success(exist)), (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void getAllJournals(Consumer<Result<List<String>>> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(Result.failure());\n        } else {\n            mFeedJournalBridge.loadAllJournalKeys((String[] data) -> consumer.accept(Result.success(Arrays.asList(data))), (Void ignored) -> consumer.accept(Result.failure()));\n        }\n    }\n\n    @Override\n    public void deleteAll(Consumer<CommitResult> consumer) {\n        if (mFeedJournalBridge == null) {\n            consumer.accept(CommitResult.FAILURE);\n        } else {\n            mFeedJournalBridge.deleteAllJournals((Boolean result) -> consumer.accept(result ? CommitResult.SUCCESS : CommitResult.FAILURE));\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "73f3690e36701a98e4dd08553207601b0f576d1b", "ext": "java", "lang": "Java", "content": "public class EnvLoadFileTest {\n\n    @Test\n    public void envTest0() throws IOException {\n        System.setProperty(\"CONFLICTS_VAR\", \"with app\");\n        StandardEnvironment env = null;\n        //\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\");\n        assert \"my my my\".equals(env.evalString(\"%MY_ENV%\"));\n        assert \"with app\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n        //\n        Map<String, String> envMap = new HashMap<String, String>();\n        envMap.put(\"CONFLICTS_VAR\", \"with env\");\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\", envMap, Thread.currentThread().getContextClassLoader());\n        assert \"with env\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n    }\n}\n", "class_id": 0, "repo": "corner4world/hasor", "file": "hasor-core/src/test/java/net/hasor/core/environment/EnvLoadFileTest.java", "last_update_at": "2021-06-01T06:52:08+00:00", "original_content": "public class EnvLoadFileTest {\n\n    @Test\n    public void envTest0() throws IOException {\n        System.setProperty(\"CONFLICTS_VAR\", \"with app\");\n        StandardEnvironment env = null;\n        //\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\");\n        assert \"my my my\".equals(env.evalString(\"%MY_ENV%\"));\n        assert \"with app\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n        //\n        Map<String, String> envMap = new HashMap<String, String>();\n        envMap.put(\"CONFLICTS_VAR\", \"with env\");\n        env = new StandardEnvironment(null, \"/net_hasor_core_environment/simple-config.xml\", envMap, Thread.currentThread().getContextClassLoader());\n        assert \"with env\".equals(env.evalString(\"%CONFLICTS_VAR%\"));\n    }\n}\n", "refactored": false}
{"hexsha": "ffa598d57403bf725a49c67af6e7b5b8fddbdb6f", "ext": "java", "lang": "Java", "content": "public final class BoruvkaMST {\r\n\r\n    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> compute(int vertices, Iterable<E> edges) {\r\n        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();\r\n        for (E e : edges) wrapper.add(new ContractedEdge<>(e));\r\n        return recurse(vertices, wrapper);\r\n    }\r\n\r\n    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {\r\n        if (vertices < 2)\r\n            return new EdgeList<>();\r\n        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);\r\n        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);\r\n        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);\r\n        // extract original edges\r\n        EdgeList<E> markedEdges = new EdgeList<>();\r\n        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);\r\n        markedEdges.meld(recurse(contracted.vertices, contractedEdges));\r\n        return markedEdges;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "lazyguyy/optimal-mst", "file": "src/mst/BoruvkaMST.java", "last_update_at": "2021-12-07T21:13:34+00:00", "original_content": "public final class BoruvkaMST {\r\n\r\n    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> compute(int vertices, Iterable<E> edges) {\r\n        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();\r\n        for (E e : edges) wrapper.add(new ContractedEdge<>(e));\r\n        return recurse(vertices, wrapper);\r\n    }\r\n\r\n    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {\r\n        if (vertices < 2)\r\n            return new EdgeList<>();\r\n        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);\r\n        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);\r\n        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);\r\n        // extract original edges\r\n        EdgeList<E> markedEdges = new EdgeList<>();\r\n        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);\r\n        markedEdges.meld(recurse(contracted.vertices, contractedEdges));\r\n        return markedEdges;\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "19807beaf0c29dd03789fd7847ec074e209b45d0", "ext": "java", "lang": "Java", "content": "public class Client {\n\n    private static final List<String> data = List.of(\"some\", \"data\", \"for\", \"test\");\n\n    public Client() {\n        exp02();\n    }\n\n    private void exp01() {\n        Dao dao = new XmlDao();\n        Service service = new ServiceImpl(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    private void exp02() {\n        Dao dao = new MongoDBDao();\n        Service service = new ServiceImplWithLog(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    public static void main(String[] args) {\n        new Client();\n    }\n}\n", "class_id": 0, "repo": "ismailbenhallam/Design-Patterns", "file": "07-Bridge/src/main/java/client/Client.java", "last_update_at": "2021-07-23T22:52:40+00:00", "original_content": "public class Client {\n\n    private static final List<String> data = List.of(\"some\", \"data\", \"for\", \"test\");\n\n    public Client() {\n        exp02();\n    }\n\n    private void exp01() {\n        Dao dao = new XmlDao();\n        Service service = new ServiceImpl(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    private void exp02() {\n        Dao dao = new MongoDBDao();\n        Service service = new ServiceImplWithLog(dao);\n        System.out.println(service.validateAndSave(data));\n    }\n\n    public static void main(String[] args) {\n        new Client();\n    }\n}\n", "refactored": false}
{"hexsha": "e6daad92b85ef23f3921081ecaf6d618b18c2f1b", "ext": "java", "lang": "Java", "content": "public class OrmBenchmarksTask extends Task {\n\n    public static final String TAG = \"OrmBenchmarksTask\";\n\n    private static final boolean USE_IN_MEMORY_DB = false;\n\n    private static final int NUM_ITERATIONS = 5;\n\n    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] { new SquidbExecutor(), new SugarOrmExecutor(), new SQLiteExecutor(), new DBFlowExecutor(), new SqueakyExecutor(), new CupboardExecutor(), new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(), new RealmExecutor(), new RequeryExecutor(), new OptimizedSQLiteExecutor(), new ORMLiteExecutor(), new GreenDaoExecutor() };\n\n    public String resultString;\n\n    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();\n\n    enum BenchmarkTask {\n\n        CREATE_DB, WRITE_DATA, READ_DATA, DROP_DB\n    }\n\n    @Override\n    protected void run(Context context) throws Throwable {\n        for (BenchmarkExecutable orm : mOrms) {\n            orm.init(context, USE_IN_MEMORY_DB);\n            Log.w(TAG, orm.getOrmName() + \" init\");\n        }\n        List<BenchmarkExecutable> failed = new ArrayList<>();\n        int i = 0;\n        while (i < NUM_ITERATIONS) try {\n            for (BenchmarkExecutable item : mOrms) {\n                for (BenchmarkTask task : BenchmarkTask.values()) {\n                    long result = 0;\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" start\");\n                    try {\n                        switch(task) {\n                            case CREATE_DB:\n                                result = item.createDbStructure();\n                                break;\n                            case DROP_DB:\n                                result = item.dropDb();\n                                break;\n                            case READ_DATA:\n                                result = item.readWholeData();\n                                break;\n                            case WRITE_DATA:\n                                result = item.writeWholeData();\n                                break;\n                        }\n                    } catch (Exception e) {\n                        result = Long.MIN_VALUE;\n                        failed.add(item);\n                    }\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" end\");\n                    addProfilerResult(item.getOrmName(), task, result);\n                }\n            }\n        } finally {\n            i++;\n        }\n        buildResultString();\n    }\n\n    private void buildResultString() {\n        StringBuilder sb = new StringBuilder();\n        BenchmarkTask[] bTasks = new BenchmarkTask[] { BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA };\n        for (BenchmarkTask bTask : bTasks) {\n            sb.append(\"<b>\").append(bTask.name()).append(\"</b>\").append(\"<br/>\");\n            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());\n            if (stringLongMap != null) {\n                for (String ormName : stringLongMap.keySet()) {\n                    long result = stringLongMap.get(ormName);\n                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);\n                    sb.append(ormName).append(\" - \");\n                    if (printResult < 0) {\n                        sb.append(\"(crashed)\");\n                    } else {\n                        sb.append(Math.round(printResult)).append(\"ms\");\n                    }\n                    sb.append(\"<br/>\");\n                    Log.w(\"FOR_SPREADSHEET\", ormName + \",\" + Math.round(printResult));\n                }\n            }\n        }\n        resultString = sb.toString();\n    }\n\n    private void addProfilerResult(String ormName, BenchmarkTask task, long result) {\n        Map<String, Long> taskMap = benchmarkResults.get(task.name());\n        if (taskMap == null) {\n            taskMap = new TreeMap<>();\n            benchmarkResults.put(task.name(), taskMap);\n        }\n        Long storedResult = taskMap.get(ormName);\n        if (storedResult == null) {\n            storedResult = 0l;\n        }\n        long value = result + storedResult;\n        taskMap.put(ormName, value);\n        Log.w(TAG, \"adding \" + task.name() + \"-\" + ormName + \"-\" + value);\n    }\n\n    @Override\n    protected boolean handleError(Context context, Throwable e) {\n        return false;\n    }\n\n    @Override\n    protected void onComplete(Context context) {\n        EventBusExt.getDefault().post(this);\n    }\n}\n", "class_id": 0, "repo": "greenrobot/android-orm-benchmark-updated", "file": "ORM-Benchmark/src/main/java/com/littleinc/orm_benchmark/tasks/OrmBenchmarksTask.java", "last_update_at": "2021-06-14T18:42:56+00:00", "original_content": "public class OrmBenchmarksTask extends Task {\n\n    public static final String TAG = \"OrmBenchmarksTask\";\n\n    private static final boolean USE_IN_MEMORY_DB = false;\n\n    private static final int NUM_ITERATIONS = 5;\n\n    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] { new SquidbExecutor(), new SugarOrmExecutor(), new SQLiteExecutor(), new DBFlowExecutor(), new SqueakyExecutor(), new CupboardExecutor(), new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(), new RealmExecutor(), new RequeryExecutor(), new OptimizedSQLiteExecutor(), new ORMLiteExecutor(), new GreenDaoExecutor() };\n\n    public String resultString;\n\n    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();\n\n    enum BenchmarkTask {\n\n        CREATE_DB, WRITE_DATA, READ_DATA, DROP_DB\n    }\n\n    @Override\n    protected void run(Context context) throws Throwable {\n        for (BenchmarkExecutable orm : mOrms) {\n            orm.init(context, USE_IN_MEMORY_DB);\n            Log.w(TAG, orm.getOrmName() + \" init\");\n        }\n        List<BenchmarkExecutable> failed = new ArrayList<>();\n        for (int i = 0; i < NUM_ITERATIONS; i++) {\n            for (BenchmarkExecutable item : mOrms) {\n                for (BenchmarkTask task : BenchmarkTask.values()) {\n                    long result = 0;\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" start\");\n                    try {\n                        switch(task) {\n                            case CREATE_DB:\n                                result = item.createDbStructure();\n                                break;\n                            case DROP_DB:\n                                result = item.dropDb();\n                                break;\n                            case READ_DATA:\n                                result = item.readWholeData();\n                                break;\n                            case WRITE_DATA:\n                                result = item.writeWholeData();\n                                break;\n                        }\n                    } catch (Exception e) {\n                        result = Long.MIN_VALUE;\n                        failed.add(item);\n                    }\n                    Log.w(TAG, item.getOrmName() + \"-\" + task.name() + \" end\");\n                    addProfilerResult(item.getOrmName(), task, result);\n                }\n            }\n        }\n        buildResultString();\n    }\n\n    private void buildResultString() {\n        StringBuilder sb = new StringBuilder();\n        BenchmarkTask[] bTasks = new BenchmarkTask[] { BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA };\n        for (BenchmarkTask bTask : bTasks) {\n            sb.append(\"<b>\").append(bTask.name()).append(\"</b>\").append(\"<br/>\");\n            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());\n            if (stringLongMap != null) {\n                for (String ormName : stringLongMap.keySet()) {\n                    long result = stringLongMap.get(ormName);\n                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);\n                    sb.append(ormName).append(\" - \");\n                    if (printResult < 0) {\n                        sb.append(\"(crashed)\");\n                    } else {\n                        sb.append(Math.round(printResult)).append(\"ms\");\n                    }\n                    sb.append(\"<br/>\");\n                    Log.w(\"FOR_SPREADSHEET\", ormName + \",\" + Math.round(printResult));\n                }\n            }\n        }\n        resultString = sb.toString();\n    }\n\n    private void addProfilerResult(String ormName, BenchmarkTask task, long result) {\n        Map<String, Long> taskMap = benchmarkResults.get(task.name());\n        if (taskMap == null) {\n            taskMap = new TreeMap<>();\n            benchmarkResults.put(task.name(), taskMap);\n        }\n        Long storedResult = taskMap.get(ormName);\n        if (storedResult == null) {\n            storedResult = 0l;\n        }\n        long value = result + storedResult;\n        taskMap.put(ormName, value);\n        Log.w(TAG, \"adding \" + task.name() + \"-\" + ormName + \"-\" + value);\n    }\n\n    @Override\n    protected boolean handleError(Context context, Throwable e) {\n        return false;\n    }\n\n    @Override\n    protected void onComplete(Context context) {\n        EventBusExt.getDefault().post(this);\n    }\n}\n", "refactored": true}
{"hexsha": "e0aa48a7e2cf1b6234970b1b127112d88e948138", "ext": "java", "lang": "Java", "content": "public class PrivateMessage extends Chat {\n\n    private static Pattern privateMessageRegex = Pattern.compile(\"\\\\[([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16}) -> mir\\\\] (.*)$\");\n\n    private static Pattern privateMessageSentRegex = Pattern.compile(\"\\\\[mir -> ([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16})\\\\] (.*)$\");\n\n    private long lastAfkMessage = 0;\n\n    @Override\n    public String getName() {\n        return \"privateMessage\";\n    }\n\n    public boolean doAction(String unformatted) {\n        if (unformatted.trim().length() > 0) {\n            Matcher privateMessage = privateMessageRegex.matcher(unformatted);\n            Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n            return privateMessage.find() || privateMessageSent.find();\n        }\n        return false;\n    }\n\n    @Override\n    public boolean doActionHandleChatMessage(String unformatted, String formatted) {\n        return getSettings().isPrivateChatRight() && doAction(unformatted);\n    }\n\n    @Override\n    public boolean doActionModifyChatMessage(IChatComponent msg) {\n        String unformatted = msg.getUnformattedText();\n        return doAction(unformatted);\n    }\n\n    @Override\n    public ChatDisplayAction handleChatMessage(String unformatted, String formatted) {\n        return ChatDisplayAction.SWAP;\n    }\n\n    @Override\n    public IChatComponent modifyChatMessage(IChatComponent msg) {\n        String unformatted = msg.getUnformattedText();\n        Matcher privateMessage = privateMessageRegex.matcher(unformatted);\n        Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n        String suggestMsgHoverTxt = LanguageManager.translateOrReturnKey(\"message_gg_suggestMsgHoverMsg\");\n        IChatComponent hoverText = new ChatComponentText(ModColor.cl(\"a\") + suggestMsgHoverTxt);\n        if (privateMessage.find()) {\n            String playerName = privateMessage.group(2);\n            if (playerName.startsWith(\"~\"))\n                playerName = playerName.replaceFirst(\"~\", \"\");\n            if (getSettings().isPrivateChatSound()) {\n                LabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);\n            }\n            if (getSettings().isMsgDisplayNameClick()) {\n                String username = \"/msg \" + playerName + \" \";\n                int siblingCnt = 0;\n                int nameStart = 0;\n                int nameEnd = 0;\n                for (IChatComponent msgs : msg.getSiblings()) {\n                    if (nameStart == 0 && msgs.getFormattedText().contains(\"?6[?r\")) {\n                        nameStart = siblingCnt + 1;\n                    }\n                    if (nameEnd == 0 && msgs.getFormattedText().equals(\"?6 -> ?r\")) {\n                        nameEnd = siblingCnt - 1;\n                    }\n                    siblingCnt++;\n                }\n                int i = nameStart;\n                while (i <= nameEnd) try {\n                    msg.getSiblings().get(i).getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username)).setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n                } finally {\n                    i++;\n                }\n            }\n            if (getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage + 1000 <= System.currentTimeMillis()) {\n                String message = getSettings().getAfkMsgText();\n                if (message.length() > 0) {\n                    if (message.startsWith(\"~\"))\n                        message = message.replaceFirst(\"~\", \"\");\n                    Minecraft.getMinecraft().thePlayer.sendChatMessage(\"/msg \" + playerName + \" \" + message);\n                    lastAfkMessage = System.currentTimeMillis();\n                }\n            }\n        }\n        if (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {\n            String playerName = privateMessageSent.group(2);\n            if (playerName.startsWith(\"~\"))\n                playerName = playerName.replaceFirst(\"~\", \"\");\n            String username = \"/msg \" + playerName + \" \";\n            int siblingCnt = 0;\n            int nameStart = 0;\n            int nameEnd = 0;\n            for (IChatComponent msgs : msg.getSiblings()) {\n                if (nameStart == 0 && msgs.getFormattedText().equals(\"?6 -> ?r\")) {\n                    nameStart = siblingCnt + 1;\n                }\n                if (nameEnd == 0 && msgs.getFormattedText().equals(\"?6] ?r\")) {\n                    nameEnd = siblingCnt - 1;\n                }\n                siblingCnt++;\n            }\n            int i = nameStart;\n            while (i <= nameEnd) try {\n                msg.getSiblings().get(i).getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username)).setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n            } finally {\n                i++;\n            }\n        }\n        return msg;\n    }\n}\n", "class_id": 0, "repo": "Dominic11/LabyMod-GrieferGames-Addon-1.8.9", "file": "src/main/java/de/neocraftr/griefergames/chat/PrivateMessage.java", "last_update_at": "2021-12-22T00:27:11+00:00", "original_content": "public class PrivateMessage extends Chat {\n\n    private static Pattern privateMessageRegex = Pattern.compile(\"\\\\[([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16}) -> mir\\\\] (.*)$\");\n\n    private static Pattern privateMessageSentRegex = Pattern.compile(\"\\\\[mir -> ([A-Za-z\\\\-\\\\+]+) \\\\u2503 (~?\\\\!?\\\\w{1,16})\\\\] (.*)$\");\n\n    private long lastAfkMessage = 0;\n\n    @Override\n    public String getName() {\n        return \"privateMessage\";\n    }\n\n    public boolean doAction(String unformatted) {\n        if (unformatted.trim().length() > 0) {\n            Matcher privateMessage = privateMessageRegex.matcher(unformatted);\n            Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n            return privateMessage.find() || privateMessageSent.find();\n        }\n        return false;\n    }\n\n    @Override\n    public boolean doActionHandleChatMessage(String unformatted, String formatted) {\n        return getSettings().isPrivateChatRight() && doAction(unformatted);\n    }\n\n    @Override\n    public boolean doActionModifyChatMessage(IChatComponent msg) {\n        String unformatted = msg.getUnformattedText();\n        return doAction(unformatted);\n    }\n\n    @Override\n    public ChatDisplayAction handleChatMessage(String unformatted, String formatted) {\n        return ChatDisplayAction.SWAP;\n    }\n\n    @Override\n    public IChatComponent modifyChatMessage(IChatComponent msg) {\n        String unformatted = msg.getUnformattedText();\n        Matcher privateMessage = privateMessageRegex.matcher(unformatted);\n        Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);\n        String suggestMsgHoverTxt = LanguageManager.translateOrReturnKey(\"message_gg_suggestMsgHoverMsg\");\n        IChatComponent hoverText = new ChatComponentText(ModColor.cl(\"a\") + suggestMsgHoverTxt);\n        if (privateMessage.find()) {\n            String playerName = privateMessage.group(2);\n            if (playerName.startsWith(\"~\"))\n                playerName = playerName.replaceFirst(\"~\", \"\");\n            if (getSettings().isPrivateChatSound()) {\n                LabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);\n            }\n            if (getSettings().isMsgDisplayNameClick()) {\n                String username = \"/msg \" + playerName + \" \";\n                int siblingCnt = 0;\n                int nameStart = 0;\n                int nameEnd = 0;\n                for (IChatComponent msgs : msg.getSiblings()) {\n                    if (nameStart == 0 && msgs.getFormattedText().contains(\"?6[?r\")) {\n                        nameStart = siblingCnt + 1;\n                    }\n                    if (nameEnd == 0 && msgs.getFormattedText().equals(\"?6 -> ?r\")) {\n                        nameEnd = siblingCnt - 1;\n                    }\n                    siblingCnt++;\n                }\n                for (int i = nameStart; i <= nameEnd; i++) {\n                    msg.getSiblings().get(i).getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username)).setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n                }\n            }\n            if (getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage + 1000 <= System.currentTimeMillis()) {\n                String message = getSettings().getAfkMsgText();\n                if (message.length() > 0) {\n                    if (message.startsWith(\"~\"))\n                        message = message.replaceFirst(\"~\", \"\");\n                    Minecraft.getMinecraft().thePlayer.sendChatMessage(\"/msg \" + playerName + \" \" + message);\n                    lastAfkMessage = System.currentTimeMillis();\n                }\n            }\n        }\n        if (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {\n            String playerName = privateMessageSent.group(2);\n            if (playerName.startsWith(\"~\"))\n                playerName = playerName.replaceFirst(\"~\", \"\");\n            String username = \"/msg \" + playerName + \" \";\n            int siblingCnt = 0;\n            int nameStart = 0;\n            int nameEnd = 0;\n            for (IChatComponent msgs : msg.getSiblings()) {\n                if (nameStart == 0 && msgs.getFormattedText().equals(\"?6 -> ?r\")) {\n                    nameStart = siblingCnt + 1;\n                }\n                if (nameEnd == 0 && msgs.getFormattedText().equals(\"?6] ?r\")) {\n                    nameEnd = siblingCnt - 1;\n                }\n                siblingCnt++;\n            }\n            for (int i = nameStart; i <= nameEnd; i++) {\n                msg.getSiblings().get(i).getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username)).setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));\n            }\n        }\n        return msg;\n    }\n}\n", "refactored": true}
{"hexsha": "22f1d27c88a69020fcf20563969e6c9de6ef532c", "ext": "java", "lang": "Java", "content": "@ChannelHandler.Sharable\npublic class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {\n\n    public static final String POOL_KEY = \"AsyncRpcClientHandler\";\n\n    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);\n\n    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();\n\n    public AsyncRpcClientHandler(String address) {\n        super(address);\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {\n        String requestId = response.getRequestId();\n        LOGGER.info(\"Receive response : \" + requestId);\n        RpcFuture rpcFuture = pendingRPC.get(requestId);\n        if (rpcFuture != null) {\n            pendingRPC.remove(requestId);\n            rpcFuture.done(response);\n        }\n        AsyncRpcPool.getInstance().returnObject(address, this);\n    }\n\n    public void close() {\n        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n    }\n\n    public RpcFuture send(final Request request) throws Exception {\n        RpcFuture rpcFuture = new SwiftFuture(request);\n        pendingRPC.put(request.getRequestId(), rpcFuture);\n        final CountDownLatch latch = new CountDownLatch(1);\n        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {\n            LOGGER.info(\"Send request : \" + request.getRequestId());\n            latch.countDown();\n        });\n        return rpcFuture;\n    }\n}\n", "class_id": 0, "repo": "fanruan/swift-engine", "file": "swift-rpc-netty/src/main/java/com/fr/swift/cloud/netty/rpc/client/async/AsyncRpcClientHandler.java", "last_update_at": "2021-12-03T03:41:22+00:00", "original_content": "@ChannelHandler.Sharable\npublic class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {\n\n    public static final String POOL_KEY = \"AsyncRpcClientHandler\";\n\n    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);\n\n    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();\n\n    public AsyncRpcClientHandler(String address) {\n        super(address);\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {\n        String requestId = response.getRequestId();\n        LOGGER.info(\"Receive response : \" + requestId);\n        RpcFuture rpcFuture = pendingRPC.get(requestId);\n        if (rpcFuture != null) {\n            pendingRPC.remove(requestId);\n            rpcFuture.done(response);\n        }\n        AsyncRpcPool.getInstance().returnObject(address, this);\n    }\n\n    public void close() {\n        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n    }\n\n    public RpcFuture send(final Request request) throws Exception {\n        RpcFuture rpcFuture = new SwiftFuture(request);\n        pendingRPC.put(request.getRequestId(), rpcFuture);\n        final CountDownLatch latch = new CountDownLatch(1);\n        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {\n            LOGGER.info(\"Send request : \" + request.getRequestId());\n            latch.countDown();\n        });\n        return rpcFuture;\n    }\n}\n", "refactored": false}
{"hexsha": "afdbd11a44ee520634dc2f62fa377a7a4d3f4e36", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"planes\")\npublic class Plane extends Vehicle {\n\n    @Column(name = \"passenger_capacity\")\n    private int passengerCapacity;\n\n    @ManyToOne\n    private Company company;\n\n    public Plane() {\n    }\n\n    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(id, model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n\n    public void setPassengerCapacity(int seats) {\n        this.passengerCapacity = seats;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"Plane{\");\n        sb.append(super.toString());\n        sb.append(\"passengerCapacity=\").append(passengerCapacity);\n        sb.append('}');\n        return sb.toString();\n    }\n}\n", "class_id": 0, "repo": "TsvetomirN1/Soft-Uni-Spring-Data", "file": "Lections/spring-data-master/04-jpa-codefirst-lab/src/main/java/course/springdata/codefirst/entity/Plane.java", "last_update_at": "2021-04-24T20:29:56+00:00", "original_content": "@Entity\n@Table(name = \"planes\")\npublic class Plane extends Vehicle {\n\n    @Column(name = \"passenger_capacity\")\n    private int passengerCapacity;\n\n    @ManyToOne\n    private Company company;\n\n    public Plane() {\n    }\n\n    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {\n        super(id, model, price, fuelType);\n        this.passengerCapacity = passengerCapacity;\n        this.company = company;\n    }\n\n    public int getPassengerCapacity() {\n        return passengerCapacity;\n    }\n\n    public void setPassengerCapacity(int seats) {\n        this.passengerCapacity = seats;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"Plane{\");\n        sb.append(super.toString());\n        sb.append(\"passengerCapacity=\").append(passengerCapacity);\n        sb.append('}');\n        return sb.toString();\n    }\n}\n", "refactored": false}
{"hexsha": "b9f4d52f93a8b27867f96d7d2bf06ba3c97bf302", "ext": "java", "lang": "Java", "content": "public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {\n\n    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, \"textures/gui/dimmer_rack.png\");\n\n    private final ContainerDimmerRack inventoryPlayer;\n\n    private final TileEntityDimmerRack tileDimmerRack;\n\n    private final List<ISocapexReceiver> receivers;\n\n    private TextFieldWidget dmxStartField;\n\n    private final List<ButtonSocket> sockets;\n\n    private final List<ButtonPlug> plugs;\n\n    private int currentPage = 0;\n\n    private int activePlug = -1;\n\n    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {\n        super(container, inventory, title);\n        this.inventoryPlayer = container;\n        this.tileDimmerRack = container.dimmerRack;\n        this.xSize = 250;\n        this.ySize = 131;\n        sockets = new ArrayList<>();\n        plugs = new ArrayList<>();\n        receivers = inventoryPlayer.getDevices();\n    }\n\n    @Override\n    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {\n        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {\n            this.onClose();\n            this.getMinecraft().player.closeScreen();\n            return true;\n        }\n        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n        generateButtons();\n    }\n\n    @Override\n    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {\n        this.init(p_resize_1_, p_resize_2_, p_resize_3_);\n    }\n\n    public void generateButtons() {\n        this.buttons.removeAll(sockets);\n        this.buttons.removeAll(plugs);\n        this.children.removeAll(sockets);\n        this.children.removeAll(plugs);\n        this.plugs.clear();\n        this.sockets.clear();\n        int width = this.width / 2;\n        int height = (this.height - this.ySize) / 2;\n        int i = 0;\n        while (i < 6) try {\n            SocapexPatch[] patch = inventoryPlayer.getPatch(i);\n            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);\n            int y = height + (i < 3 ? 25 : 70);\n            int j = 0;\n            while (j < 2) try {\n                ButtonSocket buttonSocket;\n                if (patch == null || j >= patch.length) {\n                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                } else {\n                    SocapexPatch patch1 = patch[j];\n                    if (patch1 != null && patch1.getReceiver() != null) {\n                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);\n                    } else {\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                    }\n                }\n                this.addButton(buttonSocket);\n                sockets.add(buttonSocket);\n            } finally {\n                j++;\n            }\n        } finally {\n            i++;\n        }\n        if (receivers.size() > 0) {\n            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);\n            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {\n                int i = 0;\n                while (i < channels.length) try {\n                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));\n                    int y = height + (i < 3 ? 45 : 65);\n                    if (channels[i] != 1) {\n                        int finalI = i;\n                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, \"\", activePlug == i, (button) -> {\n                            if (button instanceof ButtonPlug) {\n                                ButtonPlug plug = (ButtonPlug) button;\n                                if (activePlug == finalI) {\n                                    plug.setActive(false);\n                                    activePlug = -1;\n                                } else {\n                                    plug.setActive(true);\n                                    activePlug = finalI;\n                                }\n                            }\n                        });\n                        this.addButton(buttonPlug);\n                        plugs.add(buttonPlug);\n                    }\n                } finally {\n                    i++;\n                }\n            });\n        }\n    }\n\n    @Override\n    protected void init() {\n        super.init();\n        int lvt_1_1_ = (this.width - this.xSize) / 2;\n        int lvt_2_1_ = (this.height - this.ySize) / 2;\n        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\"<\"), (button) -> {\n            if (currentPage - 1 < 0) {\n                currentPage = receivers.size() - 1;\n            } else {\n                currentPage--;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\">\"), (button) -> {\n            if (currentPage + 1 > receivers.size() - 1) {\n                currentPage = 0;\n            } else {\n                currentPage++;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(\"\"));\n        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {\n            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));\n        }\n        this.dmxStartField.setCanLoseFocus(false);\n        this.dmxStartField.changeFocus(true);\n        this.dmxStartField.setTextColor(-1);\n        this.dmxStartField.setDisabledTextColour(-1);\n        this.dmxStartField.setEnableBackgroundDrawing(true);\n        this.dmxStartField.setMaxStringLength(35);\n        this.dmxStartField.setValidator(s -> {\n            if (s.length() == 0) {\n                return true;\n            }\n            try {\n                Integer.parseInt(s);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        });\n        this.children.add(this.dmxStartField);\n        this.setFocusedDefault(this.dmxStartField);\n        generateButtons();\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if (this.dmxStartField.isMouseOver(mouseX, mouseY)) {\n            this.dmxStartField.setFocused2(true);\n        }\n        return super.mouseClicked(mouseX, mouseY, button);\n    }\n\n    @Override\n    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {\n        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);\n        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);\n        int lvt_4_1_ = this.guiLeft;\n        int lvt_5_1_ = (this.height - this.ySize) / 2;\n        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);\n    }\n\n    @Override\n    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {\n        this.renderBackground(ms);\n        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        RenderSystem.disableBlend();\n        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        this.renderHoveredTooltip(ms, p_230430_2_, p_230430_3_);\n    }\n\n    @Override\n    public void onClose() {\n        super.onClose();\n        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));\n    }\n\n    @Override\n    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {\n        String name = container.dimmerRack.getDisplayName().getString();\n        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);\n        font.drawString(matrixStack, \"Plugs\", 180 + font.getStringWidth(\"Plugs\") / 2, 6, 0x404040);\n        int i = 0;\n        while (i < 6) try {\n            int x1 = 33 + 46 * (i < 3 ? i : i - 3);\n            int y1 = (i < 3 ? 15 : 62);\n            font.drawString(matrixStack, \"\" + (i + 1), x1, y1, 0x000000);\n        } finally {\n            i++;\n        }\n        if (receivers.size() > 0) {\n            String pageName = \"Panel \" + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());\n            font.drawString(matrixStack, pageName, 150 + font.getStringWidth(pageName) / 2, 30, 0x404040);\n        }\n        if (activePlug != -1) {\n            int width = this.width / 2;\n            int height = (this.height - this.ySize) / 2;\n            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));\n            int plugY = height + (activePlug < 3 ? 45 : 65);\n            int xDist = plugX - x;\n            int yDist = plugY - y;\n            if (Minecraft.getInstance().currentScreen != null) {\n                long distanceSq = xDist * xDist + yDist * yDist;\n                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;\n                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);\n            }\n            final int color = 0x13C90A;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n            RenderSystem.disableTexture();\n            RenderSystem.disableCull();\n            RenderSystem.lineWidth(3);\n            RenderSystem.color4f(1F, 1F, 1F, 1F);\n            Tessellator tessellator = Tessellator.getInstance();\n            BufferBuilder bufferBuilder = tessellator.getBuffer();\n            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);\n            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();\n            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();\n            tessellator.draw();\n            RenderSystem.enableTexture();\n            RenderSystem.enableCull();\n        }\n    }\n\n    private void handleSocket(Button button) {\n        if (button instanceof ButtonSocket) {\n            ButtonSocket socket = (ButtonSocket) button;\n            int channel = socket.getChannelNumber();\n            int socketNumber = socket.isSecondSocket() ? 2 : 1;\n            if (activePlug == -1) {\n                if (socket.isPatched()) {\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));\n                    generateButtons();\n                }\n            } else {\n                if (!socket.isPatched()) {\n                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));\n                    activePlug = -1;\n                    generateButtons();\n                }\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "manmaed/theatrical-forge", "file": "src/main/java/dev/theatricalmod/theatrical/client/gui/screen/ScreenDimmerRack.java", "last_update_at": "2021-12-19T23:19:11+00:00", "original_content": "public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {\n\n    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, \"textures/gui/dimmer_rack.png\");\n\n    private final ContainerDimmerRack inventoryPlayer;\n\n    private final TileEntityDimmerRack tileDimmerRack;\n\n    private final List<ISocapexReceiver> receivers;\n\n    private TextFieldWidget dmxStartField;\n\n    private final List<ButtonSocket> sockets;\n\n    private final List<ButtonPlug> plugs;\n\n    private int currentPage = 0;\n\n    private int activePlug = -1;\n\n    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {\n        super(container, inventory, title);\n        this.inventoryPlayer = container;\n        this.tileDimmerRack = container.dimmerRack;\n        this.xSize = 250;\n        this.ySize = 131;\n        sockets = new ArrayList<>();\n        plugs = new ArrayList<>();\n        receivers = inventoryPlayer.getDevices();\n    }\n\n    @Override\n    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {\n        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {\n            this.onClose();\n            this.getMinecraft().player.closeScreen();\n            return true;\n        }\n        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n        generateButtons();\n    }\n\n    @Override\n    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {\n        this.init(p_resize_1_, p_resize_2_, p_resize_3_);\n    }\n\n    public void generateButtons() {\n        this.buttons.removeAll(sockets);\n        this.buttons.removeAll(plugs);\n        this.children.removeAll(sockets);\n        this.children.removeAll(plugs);\n        this.plugs.clear();\n        this.sockets.clear();\n        int width = this.width / 2;\n        int height = (this.height - this.ySize) / 2;\n        for (int i = 0; i < 6; i++) {\n            SocapexPatch[] patch = inventoryPlayer.getPatch(i);\n            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);\n            int y = height + (i < 3 ? 25 : 70);\n            for (int j = 0; j < 2; j++) {\n                ButtonSocket buttonSocket;\n                if (patch == null || j >= patch.length) {\n                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                } else {\n                    SocapexPatch patch1 = patch[j];\n                    if (patch1 != null && patch1.getReceiver() != null) {\n                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);\n                    } else {\n                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);\n                    }\n                }\n                this.addButton(buttonSocket);\n                sockets.add(buttonSocket);\n            }\n        }\n        if (receivers.size() > 0) {\n            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);\n            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {\n                for (int i = 0; i < channels.length; i++) {\n                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));\n                    int y = height + (i < 3 ? 45 : 65);\n                    if (channels[i] != 1) {\n                        int finalI = i;\n                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, \"\", activePlug == i, (button) -> {\n                            if (button instanceof ButtonPlug) {\n                                ButtonPlug plug = (ButtonPlug) button;\n                                if (activePlug == finalI) {\n                                    plug.setActive(false);\n                                    activePlug = -1;\n                                } else {\n                                    plug.setActive(true);\n                                    activePlug = finalI;\n                                }\n                            }\n                        });\n                        this.addButton(buttonPlug);\n                        plugs.add(buttonPlug);\n                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    protected void init() {\n        super.init();\n        int lvt_1_1_ = (this.width - this.xSize) / 2;\n        int lvt_2_1_ = (this.height - this.ySize) / 2;\n        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\"<\"), (button) -> {\n            if (currentPage - 1 < 0) {\n                currentPage = receivers.size() - 1;\n            } else {\n                currentPage--;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(\">\"), (button) -> {\n            if (currentPage + 1 > receivers.size() - 1) {\n                currentPage = 0;\n            } else {\n                currentPage++;\n            }\n            activePlug = -1;\n            generateButtons();\n        }));\n        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(\"\"));\n        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {\n            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));\n        }\n        this.dmxStartField.setCanLoseFocus(false);\n        this.dmxStartField.changeFocus(true);\n        this.dmxStartField.setTextColor(-1);\n        this.dmxStartField.setDisabledTextColour(-1);\n        this.dmxStartField.setEnableBackgroundDrawing(true);\n        this.dmxStartField.setMaxStringLength(35);\n        this.dmxStartField.setValidator(s -> {\n            if (s.length() == 0) {\n                return true;\n            }\n            try {\n                Integer.parseInt(s);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        });\n        this.children.add(this.dmxStartField);\n        this.setFocusedDefault(this.dmxStartField);\n        generateButtons();\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int button) {\n        if (this.dmxStartField.isMouseOver(mouseX, mouseY)) {\n            this.dmxStartField.setFocused2(true);\n        }\n        return super.mouseClicked(mouseX, mouseY, button);\n    }\n\n    @Override\n    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {\n        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);\n        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);\n        int lvt_4_1_ = this.guiLeft;\n        int lvt_5_1_ = (this.height - this.ySize) / 2;\n        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);\n    }\n\n    @Override\n    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {\n        this.renderBackground(ms);\n        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        RenderSystem.disableBlend();\n        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);\n        this.renderHoveredTooltip(ms, p_230430_2_, p_230430_3_);\n    }\n\n    @Override\n    public void onClose() {\n        super.onClose();\n        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));\n    }\n\n    @Override\n    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {\n        String name = container.dimmerRack.getDisplayName().getString();\n        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);\n        font.drawString(matrixStack, \"Plugs\", 180 + font.getStringWidth(\"Plugs\") / 2, 6, 0x404040);\n        for (int i = 0; i < 6; i++) {\n            int x1 = 33 + 46 * (i < 3 ? i : i - 3);\n            int y1 = (i < 3 ? 15 : 62);\n            font.drawString(matrixStack, \"\" + (i + 1), x1, y1, 0x000000);\n        }\n        if (receivers.size() > 0) {\n            String pageName = \"Panel \" + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());\n            font.drawString(matrixStack, pageName, 150 + font.getStringWidth(pageName) / 2, 30, 0x404040);\n        }\n        if (activePlug != -1) {\n            int width = this.width / 2;\n            int height = (this.height - this.ySize) / 2;\n            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));\n            int plugY = height + (activePlug < 3 ? 45 : 65);\n            int xDist = plugX - x;\n            int yDist = plugY - y;\n            if (Minecraft.getInstance().currentScreen != null) {\n                long distanceSq = xDist * xDist + yDist * yDist;\n                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;\n                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);\n            }\n            final int color = 0x13C90A;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n            RenderSystem.disableTexture();\n            RenderSystem.disableCull();\n            RenderSystem.lineWidth(3);\n            RenderSystem.color4f(1F, 1F, 1F, 1F);\n            Tessellator tessellator = Tessellator.getInstance();\n            BufferBuilder bufferBuilder = tessellator.getBuffer();\n            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);\n            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();\n            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();\n            tessellator.draw();\n            RenderSystem.enableTexture();\n            RenderSystem.enableCull();\n        }\n    }\n\n    private void handleSocket(Button button) {\n        if (button instanceof ButtonSocket) {\n            ButtonSocket socket = (ButtonSocket) button;\n            int channel = socket.getChannelNumber();\n            int socketNumber = socket.isSecondSocket() ? 2 : 1;\n            if (activePlug == -1) {\n                if (socket.isPatched()) {\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));\n                    generateButtons();\n                }\n            } else {\n                if (!socket.isPatched()) {\n                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);\n                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));\n                    activePlug = -1;\n                    generateButtons();\n                }\n            }\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "2f69a2cf43dadc045ceb638260afaf3f2210355e", "ext": "java", "lang": "Java", "content": "public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe {\n\n    public Recipe_AA_Plating(ItemStack result, List components) {\n        super(result, components);\n    }\n\n    @Override\n    public ItemStack getCraftingResult(InventoryCrafting matrix) {\n        ItemStack stack = this.getRecipeOutput().copy();\n        ItemStack previousAA = this.getAAFromMatrix(matrix);\n        if (// Copying existing properties\n        previousAA != null && previousAA.hasTagCompound()) {\n            stack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());\n        } else // ...or just applying new ones\n        {\n            stack.setTagCompound(new NBTTagCompound());\n        }\n        // Apply the new upgrade now\n        stack.getTagCompound().setBoolean(\"hasHeavyPlatingUpgrade\", true);\n        return stack;\n    }\n\n    private ItemStack getAAFromMatrix(InventoryCrafting matrix) {\n        int counter = 0;\n        for (; counter < matrix.getSizeInventory(); ) {\n            if (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA) {\n                // Found it\n                return matrix.getStackInSlot(counter);\n            }\n            counter += 1;\n        }\n        return null;\n    }\n}\n", "class_id": 0, "repo": "Domochevsky/minecraft-quiverbow", "file": "src/main/java/com/domochevsky/quiverbow/recipes/Recipe_AA_Plating.java", "last_update_at": "2021-05-10T04:57:25+00:00", "original_content": "public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe {\n\n    public Recipe_AA_Plating(ItemStack result, List components) {\n        super(result, components);\n    }\n\n    @Override\n    public ItemStack getCraftingResult(InventoryCrafting matrix) {\n        ItemStack stack = this.getRecipeOutput().copy();\n        ItemStack previousAA = this.getAAFromMatrix(matrix);\n        if (// Copying existing properties\n        previousAA != null && previousAA.hasTagCompound()) {\n            stack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());\n        } else // ...or just applying new ones\n        {\n            stack.setTagCompound(new NBTTagCompound());\n        }\n        // Apply the new upgrade now\n        stack.getTagCompound().setBoolean(\"hasHeavyPlatingUpgrade\", true);\n        return stack;\n    }\n\n    private ItemStack getAAFromMatrix(InventoryCrafting matrix) {\n        int counter = 0;\n        while (counter < matrix.getSizeInventory()) {\n            if (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA) {\n                // Found it\n                return matrix.getStackInSlot(counter);\n            }\n            counter += 1;\n        }\n        return null;\n    }\n}\n", "refactored": true}
{"hexsha": "1c582ac1b81910b0f81a82266c59f8c5b94e8164", "ext": "java", "lang": "Java", "content": "public class ShimBridgingClassloader extends ClassLoader implements BundleReference {\n\n    public static final String HADOOP_SPOON_PLUGIN = \"HadoopSpoonPlugin\";\n\n    private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();\n\n    private final BundleWiring bundleWiring;\n\n    private final PublicLoadResolveClassLoader bundleWiringClassloader;\n\n    public ShimBridgingClassloader(ClassLoader parentClassLoader, BundleContext bundleContext) {\n        super(parentClassLoader);\n        this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt(BundleWiring.class);\n        this.bundleWiringClassloader = new PublicLoadResolveClassLoader(bundleWiring.getClassLoader());\n    }\n\n    public static Object create(BundleContext bundleContext, String className, List<Object> arguments) throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        ShimBridgingClassloader shimBridgingClassloader = new ShimBridgingClassloader(pluginClassloaderGetter.getPluginClassloader(LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN), bundleContext);\n        Class<?> clazz = Class.forName(className, true, shimBridgingClassloader);\n        if (arguments == null || arguments.size() == 0) {\n            return clazz.newInstance();\n        }\n        for (Constructor<?> constructor : clazz.getConstructors()) {\n            Class<?>[] parameterTypes = constructor.getParameterTypes();\n            if (parameterTypes.length == arguments.size()) {\n                boolean match = true;\n                int i = 0;\n                while (i < parameterTypes.length) try {\n                    Object o = arguments.get(i);\n                    if (o != null && !parameterTypes[i].isInstance(o)) {\n                        match = false;\n                        break;\n                    }\n                } finally {\n                    i++;\n                }\n                if (match) {\n                    return constructor.newInstance(arguments.toArray());\n                }\n            }\n        }\n        throw new InstantiationException(\"Unable to find constructor for class \" + className + \" with arguments \" + arguments);\n    }\n\n    @VisibleForTesting\n    static PluginClassloaderGetter getPluginClassloaderGetter() {\n        return pluginClassloaderGetter;\n    }\n\n    @VisibleForTesting\n    static void setPluginClassloaderGetter(PluginClassloaderGetter pluginClassloaderGetter) {\n        ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        int lastIndexOfDot = name.lastIndexOf('.');\n        final String packageName;\n        final String translatedPath;\n        final String translatedName;\n        if (lastIndexOfDot >= 0) {\n            packageName = name.substring(0, lastIndexOfDot);\n            if (getPackage(packageName) == null) {\n                definePackage(packageName, null, null, null, null, null, null, null);\n            }\n            translatedPath = \"/\" + packageName.replace('.', '/');\n            translatedName = name.substring(lastIndexOfDot + 1) + \".class\";\n        } else {\n            packageName = \"\";\n            translatedPath = \"/\";\n            translatedName = name;\n        }\n        if (getPackage(packageName) == null) {\n            definePackage(packageName, null, null, null, null, null, null, null);\n        }\n        List<URL> entries = bundleWiring.findEntries(translatedPath, translatedName, 0);\n        if (entries.size() == 1) {\n            byte[] bytes;\n            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n                IOUtils.copy(entries.get(0).openStream(), byteArrayOutputStream);\n                bytes = byteArrayOutputStream.toByteArray();\n            } catch (IOException e) {\n                throw new ClassNotFoundException(\"Unable to define class\", e);\n            }\n            return defineClass(name, bytes, 0, bytes.length);\n        }\n        throw new ClassNotFoundException();\n    }\n\n    @Override\n    public URL getResource(String name) {\n        int lastIndexOf = name.lastIndexOf('/');\n        List<URL> entries;\n        if (lastIndexOf > 0) {\n            entries = bundleWiring.findEntries(name.substring(0, lastIndexOf), name.substring(lastIndexOf + 1), 0);\n        } else {\n            entries = bundleWiring.findEntries(\"/\", name, 0);\n        }\n        if (entries.size() == 1) {\n            return entries.get(0);\n        }\n        URL resource = bundleWiringClassloader.getResource(name);\n        if (resource == null) {\n            resource = super.getResource(name);\n        }\n        return resource;\n    }\n\n    @Override\n    public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        Class<?> result = null;\n        synchronized (this) {\n            result = findLoadedClass(name);\n        }\n        if (result == null) {\n            try {\n                result = findClass(name);\n            } catch (Exception e) {\n            }\n        }\n        if (result == null) {\n            try {\n                Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass(name, resolve);\n                if (osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader()) {\n                    // should have loaded from the parent)\n                    try {\n                        return super.loadClass(name, resolve);\n                    } catch (Exception e) {\n                    }\n                }\n                return osgiProvidedClass;\n            } catch (Exception e) {\n            }\n        }\n        if (result == null) {\n            return super.loadClass(name, resolve);\n        }\n        if (resolve) {\n            resolveClass(result);\n        }\n        return result;\n    }\n\n    @Override\n    public Bundle getBundle() {\n        return this.bundleWiring.getBundle();\n    }\n\n    /**\n     * Trivial classloader subclass that lets us call loadClass with a resolve parameter\n     */\n    @VisibleForTesting\n    static class PublicLoadResolveClassLoader extends ClassLoader {\n\n        public PublicLoadResolveClassLoader(ClassLoader parent) {\n            super(parent);\n        }\n\n        @Override\n        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n            return super.loadClass(name, resolve);\n        }\n    }\n}\n", "class_id": 0, "repo": "plagoa/big-data-plugin", "file": "impl/shim/common/src/main/java/com/pentaho/big/data/bundles/impl/shim/common/ShimBridgingClassloader.java", "last_update_at": "2021-06-01T15:15:10+00:00", "original_content": "public class ShimBridgingClassloader extends ClassLoader implements BundleReference {\n\n    public static final String HADOOP_SPOON_PLUGIN = \"HadoopSpoonPlugin\";\n\n    private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();\n\n    private final BundleWiring bundleWiring;\n\n    private final PublicLoadResolveClassLoader bundleWiringClassloader;\n\n    public ShimBridgingClassloader(ClassLoader parentClassLoader, BundleContext bundleContext) {\n        super(parentClassLoader);\n        this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt(BundleWiring.class);\n        this.bundleWiringClassloader = new PublicLoadResolveClassLoader(bundleWiring.getClassLoader());\n    }\n\n    public static Object create(BundleContext bundleContext, String className, List<Object> arguments) throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        ShimBridgingClassloader shimBridgingClassloader = new ShimBridgingClassloader(pluginClassloaderGetter.getPluginClassloader(LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN), bundleContext);\n        Class<?> clazz = Class.forName(className, true, shimBridgingClassloader);\n        if (arguments == null || arguments.size() == 0) {\n            return clazz.newInstance();\n        }\n        for (Constructor<?> constructor : clazz.getConstructors()) {\n            Class<?>[] parameterTypes = constructor.getParameterTypes();\n            if (parameterTypes.length == arguments.size()) {\n                boolean match = true;\n                for (int i = 0; i < parameterTypes.length; i++) {\n                    Object o = arguments.get(i);\n                    if (o != null && !parameterTypes[i].isInstance(o)) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    return constructor.newInstance(arguments.toArray());\n                }\n            }\n        }\n        throw new InstantiationException(\"Unable to find constructor for class \" + className + \" with arguments \" + arguments);\n    }\n\n    @VisibleForTesting\n    static PluginClassloaderGetter getPluginClassloaderGetter() {\n        return pluginClassloaderGetter;\n    }\n\n    @VisibleForTesting\n    static void setPluginClassloaderGetter(PluginClassloaderGetter pluginClassloaderGetter) {\n        ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        int lastIndexOfDot = name.lastIndexOf('.');\n        final String packageName;\n        final String translatedPath;\n        final String translatedName;\n        if (lastIndexOfDot >= 0) {\n            packageName = name.substring(0, lastIndexOfDot);\n            if (getPackage(packageName) == null) {\n                definePackage(packageName, null, null, null, null, null, null, null);\n            }\n            translatedPath = \"/\" + packageName.replace('.', '/');\n            translatedName = name.substring(lastIndexOfDot + 1) + \".class\";\n        } else {\n            packageName = \"\";\n            translatedPath = \"/\";\n            translatedName = name;\n        }\n        if (getPackage(packageName) == null) {\n            definePackage(packageName, null, null, null, null, null, null, null);\n        }\n        List<URL> entries = bundleWiring.findEntries(translatedPath, translatedName, 0);\n        if (entries.size() == 1) {\n            byte[] bytes;\n            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n                IOUtils.copy(entries.get(0).openStream(), byteArrayOutputStream);\n                bytes = byteArrayOutputStream.toByteArray();\n            } catch (IOException e) {\n                throw new ClassNotFoundException(\"Unable to define class\", e);\n            }\n            return defineClass(name, bytes, 0, bytes.length);\n        }\n        throw new ClassNotFoundException();\n    }\n\n    @Override\n    public URL getResource(String name) {\n        int lastIndexOf = name.lastIndexOf('/');\n        List<URL> entries;\n        if (lastIndexOf > 0) {\n            entries = bundleWiring.findEntries(name.substring(0, lastIndexOf), name.substring(lastIndexOf + 1), 0);\n        } else {\n            entries = bundleWiring.findEntries(\"/\", name, 0);\n        }\n        if (entries.size() == 1) {\n            return entries.get(0);\n        }\n        URL resource = bundleWiringClassloader.getResource(name);\n        if (resource == null) {\n            resource = super.getResource(name);\n        }\n        return resource;\n    }\n\n    @Override\n    public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        Class<?> result = null;\n        synchronized (this) {\n            result = findLoadedClass(name);\n        }\n        if (result == null) {\n            try {\n                result = findClass(name);\n            } catch (Exception e) {\n            }\n        }\n        if (result == null) {\n            try {\n                Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass(name, resolve);\n                if (osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader()) {\n                    // should have loaded from the parent)\n                    try {\n                        return super.loadClass(name, resolve);\n                    } catch (Exception e) {\n                    }\n                }\n                return osgiProvidedClass;\n            } catch (Exception e) {\n            }\n        }\n        if (result == null) {\n            return super.loadClass(name, resolve);\n        }\n        if (resolve) {\n            resolveClass(result);\n        }\n        return result;\n    }\n\n    @Override\n    public Bundle getBundle() {\n        return this.bundleWiring.getBundle();\n    }\n\n    /**\n     * Trivial classloader subclass that lets us call loadClass with a resolve parameter\n     */\n    @VisibleForTesting\n    static class PublicLoadResolveClassLoader extends ClassLoader {\n\n        public PublicLoadResolveClassLoader(ClassLoader parent) {\n            super(parent);\n        }\n\n        @Override\n        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n            return super.loadClass(name, resolve);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "0faf5feafc496ca15627b4ccf3b1a7b044eb1614", "ext": "java", "lang": "Java", "content": "@WebService(serviceName = \"vnfAdapterNotify\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\")\npublic class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify {\n\n    private static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);\n\n    private final String logMarker = \"[VNF-NOTIFY]\";\n\n    @Context\n    WebServiceContext wsContext;\n\n    @WebMethod(operationName = \"rollbackVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"rollbackVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest\")\n    public void rollbackVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage) {\n        RollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();\n        rollbackVnfNotification.setMessageId(messageId);\n        rollbackVnfNotification.setCompleted(completed);\n        rollbackVnfNotification.setException(exception);\n        rollbackVnfNotification.setErrorMessage(errorMessage);\n        String method = \"rollbackVnfNotification\";\n        Object message = rollbackVnfNotification;\n        String messageEventName = \"rollbackVnfNotificationCallback\";\n        String messageVariable = \"rollbackVnfNotificationCallback\";\n        String correlationVariable = \"VNFRB_messageId\";\n        String correlationValue = messageId;\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"queryVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"queryVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest\")\n    public void queryVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage, @WebParam(name = \"vnfExists\", targetNamespace = \"\") Boolean vnfExists, @WebParam(name = \"vnfId\", targetNamespace = \"\") String vnfId, @WebParam(name = \"status\", targetNamespace = \"\") VnfStatus status, @WebParam(name = \"outputs\", targetNamespace = \"\") QueryVnfNotification.Outputs outputs) {\n        String method = \"queryVnfNotification\";\n        String messageEventName = \"queryVnfNotificationCallback\";\n        String messageVariable = \"queryVnfNotificationCallback\";\n        String correlationVariable = \"VNFQ_messageId\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        QueryVnfNotification message = new QueryVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        message.setVnfExists(vnfExists);\n        message.setVnfId(vnfId);\n        message.setStatus(status);\n        message.setOutputs(outputs);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"createVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"createVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest\")\n    public void createVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage, @WebParam(name = \"vnfId\", targetNamespace = \"\") String vnfId, @WebParam(name = \"outputs\", targetNamespace = \"\") CreateVnfNotification.Outputs outputs, @WebParam(name = \"rollback\", targetNamespace = \"\") VnfRollback rollback) {\n        String method = \"createVnfNotification\";\n        String messageEventName = \"createVnfNotificationCallback\";\n        String messageVariable = \"createVnfNotificationCallback\";\n        String correlationVariable = \"VNFC_messageId\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        CreateVnfNotification message = new CreateVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        message.setVnfId(vnfId);\n        message.setOutputs(outputs);\n        message.setRollback(rollback);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"updateVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"updateVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest\")\n    public void updateVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage, @WebParam(name = \"outputs\", targetNamespace = \"\") UpdateVnfNotification.Outputs outputs, @WebParam(name = \"rollback\", targetNamespace = \"\") VnfRollback rollback) {\n        String method = \"updateVnfNotification\";\n        String messageEventName = \"updateVnfNotificationCallback\";\n        String messageVariable = \"updateVnfNotificationCallback\";\n        String correlationVariable = \"VNFU_messageId\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        UpdateVnfNotification message = new UpdateVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        message.setOutputs(outputs);\n        message.setRollback(rollback);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"deleteVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"deleteVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest\")\n    public void deleteVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage) {\n        String method = \"deleteVnfNotification\";\n        String messageEventName = \"deleteVnfACallback\";\n        String messageVariable = \"deleteVnfACallback\";\n        String correlationVariable = \"VNFDEL_uuid\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        DeleteVnfNotification message = new DeleteVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n}\n", "class_id": 0, "repo": "onap/mso", "file": "bpmn/MSOCommonBPMN/src/main/java/org/openecomp/mso/bpmn/common/workflow/service/VnfAdapterNotifyServiceImpl.java", "last_update_at": "2021-10-15T19:28:17+00:00", "original_content": "@WebService(serviceName = \"vnfAdapterNotify\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\")\npublic class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify {\n\n    private static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);\n\n    private final String logMarker = \"[VNF-NOTIFY]\";\n\n    @Context\n    WebServiceContext wsContext;\n\n    @WebMethod(operationName = \"rollbackVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"rollbackVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest\")\n    public void rollbackVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage) {\n        RollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();\n        rollbackVnfNotification.setMessageId(messageId);\n        rollbackVnfNotification.setCompleted(completed);\n        rollbackVnfNotification.setException(exception);\n        rollbackVnfNotification.setErrorMessage(errorMessage);\n        String method = \"rollbackVnfNotification\";\n        Object message = rollbackVnfNotification;\n        String messageEventName = \"rollbackVnfNotificationCallback\";\n        String messageVariable = \"rollbackVnfNotificationCallback\";\n        String correlationVariable = \"VNFRB_messageId\";\n        String correlationValue = messageId;\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"queryVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"queryVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest\")\n    public void queryVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage, @WebParam(name = \"vnfExists\", targetNamespace = \"\") Boolean vnfExists, @WebParam(name = \"vnfId\", targetNamespace = \"\") String vnfId, @WebParam(name = \"status\", targetNamespace = \"\") VnfStatus status, @WebParam(name = \"outputs\", targetNamespace = \"\") QueryVnfNotification.Outputs outputs) {\n        String method = \"queryVnfNotification\";\n        String messageEventName = \"queryVnfNotificationCallback\";\n        String messageVariable = \"queryVnfNotificationCallback\";\n        String correlationVariable = \"VNFQ_messageId\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        QueryVnfNotification message = new QueryVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        message.setVnfExists(vnfExists);\n        message.setVnfId(vnfId);\n        message.setStatus(status);\n        message.setOutputs(outputs);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"createVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"createVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest\")\n    public void createVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage, @WebParam(name = \"vnfId\", targetNamespace = \"\") String vnfId, @WebParam(name = \"outputs\", targetNamespace = \"\") CreateVnfNotification.Outputs outputs, @WebParam(name = \"rollback\", targetNamespace = \"\") VnfRollback rollback) {\n        String method = \"createVnfNotification\";\n        String messageEventName = \"createVnfNotificationCallback\";\n        String messageVariable = \"createVnfNotificationCallback\";\n        String correlationVariable = \"VNFC_messageId\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        CreateVnfNotification message = new CreateVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        message.setVnfId(vnfId);\n        message.setOutputs(outputs);\n        message.setRollback(rollback);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"updateVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"updateVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest\")\n    public void updateVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage, @WebParam(name = \"outputs\", targetNamespace = \"\") UpdateVnfNotification.Outputs outputs, @WebParam(name = \"rollback\", targetNamespace = \"\") VnfRollback rollback) {\n        String method = \"updateVnfNotification\";\n        String messageEventName = \"updateVnfNotificationCallback\";\n        String messageVariable = \"updateVnfNotificationCallback\";\n        String correlationVariable = \"VNFU_messageId\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        UpdateVnfNotification message = new UpdateVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        message.setOutputs(outputs);\n        message.setRollback(rollback);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n\n    @WebMethod(operationName = \"deleteVnfNotification\")\n    @Oneway\n    @RequestWrapper(localName = \"deleteVnfNotification\", targetNamespace = \"http://org.openecomp.mso/vnfNotify\", className = \"org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification\")\n    @Action(input = \"http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest\")\n    public void deleteVnfNotification(@WebParam(name = \"messageId\", targetNamespace = \"\") String messageId, @WebParam(name = \"completed\", targetNamespace = \"\") boolean completed, @WebParam(name = \"exception\", targetNamespace = \"\") MsoExceptionCategory exception, @WebParam(name = \"errorMessage\", targetNamespace = \"\") String errorMessage) {\n        String method = \"deleteVnfNotification\";\n        String messageEventName = \"deleteVnfACallback\";\n        String messageVariable = \"deleteVnfACallback\";\n        String correlationVariable = \"VNFDEL_uuid\";\n        String correlationValue = messageId;\n        MsoLogger.setServiceName(\"MSO.\" + method);\n        MsoLogger.setLogContext(correlationValue, \"N/A\");\n        DeleteVnfNotification message = new DeleteVnfNotification();\n        message.setMessageId(messageId);\n        message.setCompleted(completed);\n        message.setException(exception);\n        message.setErrorMessage(errorMessage);\n        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);\n    }\n}\n", "refactored": false}
{"hexsha": "ef4088695a2bdbb3f8b94bb4019081cc3a616e2e", "ext": "java", "lang": "Java", "content": "public class MatrixCalculator {\n\n    private static ILexicalDatabase db;\n\n    public MatrixCalculator(ILexicalDatabase db) {\n        MatrixCalculator.db = db;\n    }\n\n    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] result = new double[words1.length][words2.length];\n        int i = 0;\n        while (i < words1.length) try {\n            int j = 0;\n            while (j < words2.length) try {\n                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);\n                result[i][j] = score;\n            } finally {\n                j++;\n            }\n        } finally {\n            i++;\n        }\n        return result;\n    }\n\n    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] scores = getSimilarityMatrix(words1, words2, rc);\n        double bestScore = 1.0D;\n        for (double[] score : scores) {\n            for (double aScore : score) {\n                if (aScore > bestScore && aScore != Double.MAX_VALUE)\n                    bestScore = aScore;\n            }\n        }\n        int i = 0;\n        while (i < scores.length) try {\n            int j = 0;\n            while (j < scores[i].length) try {\n                if (scores[i][j] == Double.MAX_VALUE)\n                    scores[i][j] = 1;\n                else\n                    scores[i][j] /= bestScore;\n            } finally {\n                j++;\n            }\n        } finally {\n            i++;\n        }\n        return scores;\n    }\n\n    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {\n        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);\n        Arrays.asList(words1).forEach(aWords1 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos).forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms1.add(synonyms);\n        });\n        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);\n        Arrays.asList(words2).forEach(aWords2 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos).forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms2.add(synonyms);\n        });\n        double[][] result = new double[words1.length][words2.length];\n        int i = 0;\n        while (i < words1.length) try {\n            int j = 0;\n            while (j < words2.length) try {\n                String w1 = words1[i];\n                String w2 = words2[j];\n                if (w1.equals(w2)) {\n                    result[i][j] = 1.0D;\n                    continue;\n                }\n                Set<String> s1 = synonyms1.get(i);\n                Set<String> s2 = synonyms2.get(j);\n                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;\n            } finally {\n                j++;\n            }\n        } finally {\n            i++;\n        }\n        return result;\n    }\n}\n", "class_id": 0, "repo": "iamani123/Disatt", "file": "OpenNlp/src/main/java/one/ws4j/util/MatrixCalculator.java", "last_update_at": "2021-03-31T21:12:45+00:00", "original_content": "public class MatrixCalculator {\n\n    private static ILexicalDatabase db;\n\n    public MatrixCalculator(ILexicalDatabase db) {\n        MatrixCalculator.db = db;\n    }\n\n    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);\n                result[i][j] = score;\n            }\n        }\n        return result;\n    }\n\n    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {\n        double[][] scores = getSimilarityMatrix(words1, words2, rc);\n        double bestScore = 1.0D;\n        for (double[] score : scores) {\n            for (double aScore : score) {\n                if (aScore > bestScore && aScore != Double.MAX_VALUE)\n                    bestScore = aScore;\n            }\n        }\n        for (int i = 0; i < scores.length; i++) {\n            for (int j = 0; j < scores[i].length; j++) {\n                if (scores[i][j] == Double.MAX_VALUE)\n                    scores[i][j] = 1;\n                else\n                    scores[i][j] /= bestScore;\n            }\n        }\n        return scores;\n    }\n\n    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {\n        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);\n        Arrays.asList(words1).forEach(aWords1 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos).forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms1.add(synonyms);\n        });\n        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);\n        Arrays.asList(words2).forEach(aWords2 -> {\n            Set<String> synonyms = new HashSet<>();\n            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos).forEach(concept -> synonyms.add(concept.getSynsetID())));\n            synonyms2.add(synonyms);\n        });\n        double[][] result = new double[words1.length][words2.length];\n        for (int i = 0; i < words1.length; i++) {\n            for (int j = 0; j < words2.length; j++) {\n                String w1 = words1[i];\n                String w2 = words2[j];\n                if (w1.equals(w2)) {\n                    result[i][j] = 1.0D;\n                    continue;\n                }\n                Set<String> s1 = synonyms1.get(i);\n                Set<String> s2 = synonyms2.get(j);\n                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;\n            }\n        }\n        return result;\n    }\n}\n", "refactored": true}
{"hexsha": "2bb34c545567de1b63d21140f0cf44c5afcf6090", "ext": "java", "lang": "Java", "content": "public class WikiParserTest {\n\n    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));\n\n    @Test\n    public void parse() throws Exception {\n        final String sample = Resources.toString(getClass().getResource(\"/markdown/sample.md\"), StandardCharsets.UTF_8);\n        final WikiPageSource src = new WikiPageSource();\n        src.setMarkdownSource(sample);\n        final ParsedWikiPage page = toTest.parse(src);\n        System.out.println(page.getHtml());\n    }\n}\n", "class_id": 0, "repo": "voho/website", "file": "website/src/test/java/cz/voho/wiki/backend/WikiParserTest.java", "last_update_at": "2021-02-06T20:49:46+00:00", "original_content": "public class WikiParserTest {\n\n    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));\n\n    @Test\n    public void parse() throws Exception {\n        final String sample = Resources.toString(getClass().getResource(\"/markdown/sample.md\"), StandardCharsets.UTF_8);\n        final WikiPageSource src = new WikiPageSource();\n        src.setMarkdownSource(sample);\n        final ParsedWikiPage page = toTest.parse(src);\n        System.out.println(page.getHtml());\n    }\n}\n", "refactored": false}
{"hexsha": "aec0215d4dc6b60e41e0cce06ce6ef28c82d7239", "ext": "java", "lang": "Java", "content": "public class Julius {\n\n    public static void test() throws FileNotFoundException {\n        if (!Settings.julius_bin.exists())\n            throw new FileNotFoundException(Settings.julius_bin.getAbsolutePath());\n        if (!Settings.julius_mklm_bin.exists())\n            throw new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());\n    }\n\n    public static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {\n        String[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), \"-C\", conf.getAbsolutePath(), \"-filelist\", filelist.getAbsolutePath(), \"-v\", dic.getAbsolutePath(), \"-d\", binlm.getAbsolutePath() };\n        ProgramLauncher launcher = new ProgramLauncher(cmd);\n        launcher.setStdoutStream(new Log.Stream());\n        launcher.setStderrStream(new Log.Stream(\"ERR>>\"));\n        Log.verbose(\"julius: \" + filelist.getName());\n        launcher.run();\n        Log.verbose(\"Done.\");\n        if (launcher.getReturnValue() != 0)\n            throw new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n    }\n\n    public static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {\n        String[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), \"-nrl\", model_bkwd.getAbsolutePath(), binlm.getAbsolutePath() };\n        ProgramLauncher launcher = new ProgramLauncher(cmd);\n        launcher.setStdoutStream(new Log.Stream());\n        launcher.setStderrStream(new Log.Stream(\"ERR>>\"));\n        Log.verbose(\"mkbingram: \" + model_bkwd.getName() + \" -> \" + binlm.getName());\n        launcher.run();\n        Log.verbose(\"Done.\");\n        if (launcher.getReturnValue() != 0)\n            throw new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n    }\n\n    public static Segmentation align(File sound, File text) throws IOException, RuntimeException {\n        File[] files = new File[] { sound };\n        File conf = new File(\"julius_model/julius.jconf\");\n        File scp = new File(Settings.temp_dir, \"julius.scp\");\n        File vocab = new File(Settings.temp_dir, \"julius.voc\");\n        File dict = new File(Settings.temp_dir, \"julius.dic\");\n        File model = new File(Settings.temp_dir, \"julius.lm\");\n        File text_b = new File(Settings.temp_dir, \"julius_rev.txt\");\n        File binlm = new File(Settings.temp_dir, \"julius.jlm\");\n        FileUtils.reverse(text, text_b);\n        NGram.srilm_estimate(text_b, vocab, model, 3);\n        mkbingram(model, binlm);\n        Transcriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);\n        FileUtils.makeSCPFile(scp, files, false);\n        Log.verbose(\"Running julius...\");\n        julius(conf, scp, dict, binlm);\n        Log.verbose(\"Parsing julius output...\");\n        String soundname = sound.getAbsolutePath();\n        soundname = soundname.substring(0, soundname.lastIndexOf('.'));\n        File outfile = new File(soundname + \".out\");\n        Vector<JuliusOutput> julouts = null;\n        julouts = JuliusOutput.loadFromJulius(outfile);\n        if (julouts.isEmpty())\n            throw new RuntimeException(\"Julius didn't provide any outputs!\");\n        Segmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);\n        int i = 1;\n        while (i < julouts.size()) try {\n            double offset = ret.tiers.get(0).max();\n            ret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);\n        } finally {\n            i++;\n        }\n        return ret;\n    }\n\n    /**\n     * Unit tests.\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            Locale.setDefault(Locale.ENGLISH);\n            Log.init(\"JuliusUnitTest\", false);\n            Transcriber.init();\n            Transcriber.test();\n            Segmentation seg = align(new File(\"/home/guest/Desktop/Respeaking/test/kopacz.wav\"), new File(\"/home/guest/Desktop/Respeaking/test/kopacz.txt\"));\n            TextGrid grid = new TextGrid(seg);\n            grid.write(new File(\"/home/guest/Desktop/Respeaking/test/out.TextGrid\"));\n            Log.info(\"Julius Test complete!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "class_id": 0, "repo": "danijel3/KaldiJava", "file": "src/main/java/pl/edu/pjwstk/kaldi/programs/Julius.java", "last_update_at": "2021-09-30T09:16:45+00:00", "original_content": "public class Julius {\n\n    public static void test() throws FileNotFoundException {\n        if (!Settings.julius_bin.exists())\n            throw new FileNotFoundException(Settings.julius_bin.getAbsolutePath());\n        if (!Settings.julius_mklm_bin.exists())\n            throw new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());\n    }\n\n    public static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {\n        String[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), \"-C\", conf.getAbsolutePath(), \"-filelist\", filelist.getAbsolutePath(), \"-v\", dic.getAbsolutePath(), \"-d\", binlm.getAbsolutePath() };\n        ProgramLauncher launcher = new ProgramLauncher(cmd);\n        launcher.setStdoutStream(new Log.Stream());\n        launcher.setStderrStream(new Log.Stream(\"ERR>>\"));\n        Log.verbose(\"julius: \" + filelist.getName());\n        launcher.run();\n        Log.verbose(\"Done.\");\n        if (launcher.getReturnValue() != 0)\n            throw new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n    }\n\n    public static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {\n        String[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), \"-nrl\", model_bkwd.getAbsolutePath(), binlm.getAbsolutePath() };\n        ProgramLauncher launcher = new ProgramLauncher(cmd);\n        launcher.setStdoutStream(new Log.Stream());\n        launcher.setStderrStream(new Log.Stream(\"ERR>>\"));\n        Log.verbose(\"mkbingram: \" + model_bkwd.getName() + \" -> \" + binlm.getName());\n        launcher.run();\n        Log.verbose(\"Done.\");\n        if (launcher.getReturnValue() != 0)\n            throw new RuntimeException(\"Retval: \" + launcher.getReturnValue());\n    }\n\n    public static Segmentation align(File sound, File text) throws IOException, RuntimeException {\n        File[] files = new File[] { sound };\n        File conf = new File(\"julius_model/julius.jconf\");\n        File scp = new File(Settings.temp_dir, \"julius.scp\");\n        File vocab = new File(Settings.temp_dir, \"julius.voc\");\n        File dict = new File(Settings.temp_dir, \"julius.dic\");\n        File model = new File(Settings.temp_dir, \"julius.lm\");\n        File text_b = new File(Settings.temp_dir, \"julius_rev.txt\");\n        File binlm = new File(Settings.temp_dir, \"julius.jlm\");\n        FileUtils.reverse(text, text_b);\n        NGram.srilm_estimate(text_b, vocab, model, 3);\n        mkbingram(model, binlm);\n        Transcriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);\n        FileUtils.makeSCPFile(scp, files, false);\n        Log.verbose(\"Running julius...\");\n        julius(conf, scp, dict, binlm);\n        Log.verbose(\"Parsing julius output...\");\n        String soundname = sound.getAbsolutePath();\n        soundname = soundname.substring(0, soundname.lastIndexOf('.'));\n        File outfile = new File(soundname + \".out\");\n        Vector<JuliusOutput> julouts = null;\n        julouts = JuliusOutput.loadFromJulius(outfile);\n        if (julouts.isEmpty())\n            throw new RuntimeException(\"Julius didn't provide any outputs!\");\n        Segmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);\n        for (int i = 1; i < julouts.size(); i++) {\n            double offset = ret.tiers.get(0).max();\n            ret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);\n        }\n        return ret;\n    }\n\n    /**\n     * Unit tests.\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n            Locale.setDefault(Locale.ENGLISH);\n            Log.init(\"JuliusUnitTest\", false);\n            Transcriber.init();\n            Transcriber.test();\n            Segmentation seg = align(new File(\"/home/guest/Desktop/Respeaking/test/kopacz.wav\"), new File(\"/home/guest/Desktop/Respeaking/test/kopacz.txt\"));\n            TextGrid grid = new TextGrid(seg);\n            grid.write(new File(\"/home/guest/Desktop/Respeaking/test/out.TextGrid\"));\n            Log.info(\"Julius Test complete!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "67b397e218f28a428fff73d04687e53b5722b22e", "ext": "java", "lang": "Java", "content": "public class RDateTest {\n\n    @Test\n    public void testOf1() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));\n    }\n\n    @Test\n    public void testOf2() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));\n        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));\n    }\n\n    @Test\n    public void testOf3() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));\n    }\n\n    @Test\n    public void testOfInvalidSpecialDay() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));\n        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));\n    }\n\n    @Test\n    public void testDecade() {\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());\n    }\n\n    @Test\n    public void testIsBefore() {\n        RDate d1 = RDate.of(6, RMonth.Floreal, 4);\n        RDate d2 = RDate.of(6, RMonth.Floreal, 5);\n        assertTrue(d1.isBefore(d2));\n        assertFalse(d2.isBefore(d1));\n        assertFalse(d1.isBefore(d1));\n        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));\n        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));\n    }\n\n    @Test\n    public void testIsSextile() {\n        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());\n    }\n\n    @Test\n    public void testIsSpecialDay() {\n        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());\n        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());\n    }\n\n    @Test\n    public void testGetSpecialDay() {\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());\n    }\n\n    @Test\n    public void testPlusDays_success() {\n        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));\n        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));\n        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));\n        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));\n    }\n\n    @Test\n    public void testPlusDays_invalid() {\n        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));\n    }\n\n    @Test\n    public void testCompareTo() {\n        RDate rd = RDate.of(12, RMonth.Brumaire, 18);\n        assertEquals(-1, rd.compareTo(null));\n        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);\n        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));\n    }\n\n    @Test\n    public void testEquals() {\n        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);\n        RDate rd2 = RDate.of(12, 2, 18);\n        assertEquals(rd1, rd2);\n        assertNotEquals(rd1, new Object());\n        assertNotEquals(rd1, null);\n        assertEquals(rd2.hashCode(), rd1.hashCode());\n    }\n}\n", "class_id": 0, "repo": "jarnaud/republican-calendar", "file": "src/test/java/com/github/jarnaud/republican/RDateTest.java", "last_update_at": "2021-04-13T16:23:41+00:00", "original_content": "public class RDateTest {\n\n    @Test\n    public void testOf1() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));\n    }\n\n    @Test\n    public void testOf2() {\n        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));\n        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));\n    }\n\n    @Test\n    public void testOf3() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));\n    }\n\n    @Test\n    public void testOfInvalidSpecialDay() {\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));\n        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));\n        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));\n    }\n\n    @Test\n    public void testDecade() {\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());\n        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());\n        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());\n        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());\n    }\n\n    @Test\n    public void testIsBefore() {\n        RDate d1 = RDate.of(6, RMonth.Floreal, 4);\n        RDate d2 = RDate.of(6, RMonth.Floreal, 5);\n        assertTrue(d1.isBefore(d2));\n        assertFalse(d2.isBefore(d1));\n        assertFalse(d1.isBefore(d1));\n        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));\n        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));\n    }\n\n    @Test\n    public void testIsSextile() {\n        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());\n        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());\n        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());\n    }\n\n    @Test\n    public void testIsSpecialDay() {\n        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());\n        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());\n    }\n\n    @Test\n    public void testGetSpecialDay() {\n        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());\n        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());\n    }\n\n    @Test\n    public void testPlusDays_success() {\n        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));\n        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));\n        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));\n        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));\n    }\n\n    @Test\n    public void testPlusDays_invalid() {\n        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));\n    }\n\n    @Test\n    public void testCompareTo() {\n        RDate rd = RDate.of(12, RMonth.Brumaire, 18);\n        assertEquals(-1, rd.compareTo(null));\n        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);\n        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);\n        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));\n    }\n\n    @Test\n    public void testEquals() {\n        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);\n        RDate rd2 = RDate.of(12, 2, 18);\n        assertEquals(rd1, rd2);\n        assertNotEquals(rd1, new Object());\n        assertNotEquals(rd1, null);\n        assertEquals(rd2.hashCode(), rd1.hashCode());\n    }\n}\n", "refactored": false}
{"hexsha": "f93ae094e9bce6ccecad58faf15cf654916b969b", "ext": "java", "lang": "Java", "content": "public class ProjectSaver {\n\n    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {\n        if (projectDef.getFileName() == null)\n            throw new IllegalArgumentException(\"Built-in projects cannot be exported.\");\n        final Path directory = Paths.get(rootDirectory);\n        if (!Files.exists(directory))\n            throw new IllegalArgumentException(\"Directory does not exist.\");\n        saveProjectFile(projectDef, directory);\n        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values()) saveNamespace(namespaceDef, directory);\n    }\n\n    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {\n        final ProjectFile projectFile = new ProjectFile();\n        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);\n        projectFile.Sources = new ProjectSource[] { new ProjectSource() };\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {\n            gson.toJson(projectFile, writer);\n        }\n    }\n\n    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {\n        Path currentDirectory = directory;\n        for (String component : namespaceDef.getNamespace().split(\"\\\\.\")) {\n            currentDirectory = currentDirectory.resolve(component);\n            Files.createDirectories(currentDirectory);\n        }\n        for (FileDef fileDef : namespaceDef.getFiles().values()) {\n            final CodeWriter writer = new CodeWriter(4);\n            writer.writeLine(String.format(\"namespace %s;\", namespaceDef.getNamespace()));\n            if (fileDef.getImports().size() > 0) {\n                writer.newLine();\n                for (ImportDef importDef : fileDef.getImports()) {\n                    switch(importDef.getKind()) {\n                        case NAMESPACE:\n                            writer.writeLine(String.format(\"import %s.*;\", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));\n                            break;\n                        case TYPE:\n                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;\n                            writer.writeLine(importTypeDef.getAlias() == null ? String.format(\"import %s.%s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName()) : String.format(\"import %s.%s as %s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));\n                            break;\n                        default:\n                            throw new IllegalArgumentException(\"Type of import directive is unknown: \" + importDef.getKind());\n                    }\n                }\n            }\n            if (fileDef.getOptions().size() > 0) {\n                writer.newLine();\n                for (NameValuePair option : fileDef.getOptions()) writer.writeLine(String.format(\"option %s = %s;\", option.getName(), option.getValue().toString()));\n            }\n            saveTypeScope(fileDef, writer);\n            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {\n                writer.saveTo(stream);\n            }\n        }\n    }\n\n    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {\n        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {\n            writer.newLine();\n            saveDecorator(decoratorDef, writer);\n        }\n        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {\n            writer.newLine();\n            saveEnumeration(enumerationDef, writer);\n        }\n        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {\n            writer.newLine();\n            saveInterface(interfaceDef, writer);\n        }\n        for (ClassDef classDef : scope.getDefinedClasses()) {\n            writer.newLine();\n            saveClass(classDef, writer);\n        }\n    }\n\n    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {\n        saveComments(decoratorDef, writer);\n        saveDecorators(decoratorDef, writer);\n        writer.write(String.format(\"decorator %s {\", decoratorDef.getName()));\n        writer.indent();\n        if (decoratorDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(decoratorDef, writer);\n        }\n        saveTypeScope(decoratorDef, writer);\n        if (decoratorDef.getProperties().size() > 0) {\n            writer.newLine();\n            int i = 0;\n            while (i < decoratorDef.getProperties().size()) try {\n                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s %s;\", propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s %s = %s;\", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < decoratorDef.getProperties().size())\n                    writer.newLine();\n            } finally {\n                i += 1;\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static String luminaryTypeName(IntegralType type) {\n        switch(type) {\n            case INT8:\n                return \"Int8\";\n            case UINT8:\n                return \"Int8\";\n            case INT16:\n                return \"Int8\";\n            case UINT16:\n                return \"Int8\";\n            case INT32:\n                return \"Int8\";\n            case UINT32:\n                return \"Int8\";\n            case INT64:\n                return \"Int8\";\n            case UINT64:\n                return \"Int8\";\n            default:\n                throw new IllegalArgumentException(\"Integral type '\" + type + \"' is unknown.\");\n        }\n    }\n\n    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {\n        saveComments(enumerationDef, writer);\n        saveDecorators(enumerationDef, writer);\n        writer.write(String.format(\"enum %s : %s {\", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));\n        writer.indent();\n        if (enumerationDef.getMembers().size() > 0) {\n            writer.newLine();\n            int i = 0;\n            while (i < enumerationDef.getMembers().size()) try {\n                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);\n                saveComments(memberDef, writer);\n                saveDecorators(memberDef, writer);\n                writer.writeLine(String.format(\"%s = %s;\", memberDef.getName(), memberDef.getValue().toString()));\n                if (i + 1 < enumerationDef.getMembers().size())\n                    writer.newLine();\n            } finally {\n                i += 1;\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {\n        saveComments(interfaceDef, writer);\n        saveDecorators(interfaceDef, writer);\n        writer.write(String.format(\"interface %s \", interfaceDef.getName()));\n        if (interfaceDef.getSuperInterfaces().size() > 0) {\n            writer.write(\": \" + interfaceDef.getSuperInterfaces().get(0).getName());\n            int i = 1;\n            while (i < interfaceDef.getSuperInterfaces().size()) try {\n                writer.write(\", \" + interfaceDef.getSuperInterfaces().get(i).getName());\n            } finally {\n                i += 1;\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n        saveTypeScope(interfaceDef, writer);\n        if (interfaceDef.getProperties().size() > 0) {\n            writer.newLine();\n            int i = 0;\n            while (i < interfaceDef.getProperties().size()) try {\n                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                writer.write(String.format(\"%s %s\", propertyDef.getType().toString(), propertyDef.getName()));\n                if (propertyDef.isReadable())\n                    writer.write(\" get\");\n                if (propertyDef.isWritable())\n                    writer.write(\" set\");\n                writer.writeLine(\";\");\n                if (i + 1 < interfaceDef.getProperties().size())\n                    writer.newLine();\n            } finally {\n                i += 1;\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveClass(ClassDef classDef, CodeWriter writer) {\n        saveComments(classDef, writer);\n        saveDecorators(classDef, writer);\n        writer.write(String.format(classDef.isFinal() ? \"final class\" : \"class %s\", classDef.getName()));\n        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {\n            boolean isFirst = true;\n            if (classDef.getSuperClass() != null) {\n                isFirst = false;\n                writer.write(String.format(\": %s\", classDef.getSuperClass().getName()));\n            }\n            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {\n                if (isFirst) {\n                    isFirst = false;\n                    writer.write(String.format(\": %s\", superInterfaceDef.getName()));\n                } else\n                    writer.write(String.format(\", %s\", superInterfaceDef.getName()));\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n        if (classDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(classDef, writer);\n        }\n        saveTypeScope(classDef, writer);\n        if (classDef.getProperties().size() > 0) {\n            writer.newLine();\n            int i = 0;\n            while (i < classDef.getProperties().size()) try {\n                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                final String prefix = propertyDef.isFinal() ? (propertyDef.isOverride() ? \"final override \" : \"final \") : (propertyDef.isOverride() ? \"override \" : \"\");\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s%s %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s%s %s = %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < classDef.getProperties().size())\n                    writer.newLine();\n            } finally {\n                i += 1;\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveComments(ItemDef commentable, CodeWriter writer) {\n        for (String comment : commentable.getComments()) writer.writeLine(\"/// \" + comment);\n    }\n\n    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {\n        for (Decorator decorator : decoratable.getDecorators()) {\n            final DecoratorDef decoratorDef = decorator.getDefinition();\n            writer.write(String.format(\"[%s\", decoratorDef.getName()));\n            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {\n                writer.write(\"(\");\n                boolean isFirst = true;\n                int i = 0;\n                while (i < decorator.getArguments().size()) try {\n                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();\n                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {\n                        if (!isFirst)\n                            writer.write(\", \");\n                        else\n                            isFirst = false;\n                        writer.write(String.format(\"%s = %s\", propertyDef.getName(), decorator.getArguments().get(i).getValue()));\n                    }\n                } finally {\n                    i += 1;\n                }\n                writer.write(\")\");\n            }\n            writer.writeLine(\"]\");\n        }\n    }\n\n    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {\n        int i = 0;\n        while (i < constantScope.getDefinedConstants().size()) try {\n            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);\n            saveComments(constantDef, writer);\n            saveDecorators(constantDef, writer);\n            writer.writeLine(String.format(\"const %s %s = %s;\", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));\n            if (i + 1 < constantScope.getDefinedConstants().size())\n                writer.newLine();\n        } finally {\n            i += 1;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final ProjectLoader loader = new ProjectLoader();\n        System.setProperty(\"luminary.search.path\", \"C:\\\\Projects\\\\MaxiMarkets\\\\ProtocolGenerators\\\\luminary\");\n        final ProjectDef projectDef = loader.load(\"C:\\\\Projects\\\\MaxiMarkets\\\\TradingServer\\\\luminary\\\\External\\\\External.json\");\n        ProjectSaver.save(projectDef, \"D:\\\\Temporary\\\\Luminary\");\n    }\n}\n", "class_id": 0, "repo": "DeltixInc/Luminary", "file": "java/src/main/java/deltix/luminary/ProjectSaver.java", "last_update_at": "2021-08-19T12:50:45+00:00", "original_content": "public class ProjectSaver {\n\n    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {\n        if (projectDef.getFileName() == null)\n            throw new IllegalArgumentException(\"Built-in projects cannot be exported.\");\n        final Path directory = Paths.get(rootDirectory);\n        if (!Files.exists(directory))\n            throw new IllegalArgumentException(\"Directory does not exist.\");\n        saveProjectFile(projectDef, directory);\n        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values()) saveNamespace(namespaceDef, directory);\n    }\n\n    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {\n        final ProjectFile projectFile = new ProjectFile();\n        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);\n        projectFile.Sources = new ProjectSource[] { new ProjectSource() };\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {\n            gson.toJson(projectFile, writer);\n        }\n    }\n\n    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {\n        Path currentDirectory = directory;\n        for (String component : namespaceDef.getNamespace().split(\"\\\\.\")) {\n            currentDirectory = currentDirectory.resolve(component);\n            Files.createDirectories(currentDirectory);\n        }\n        for (FileDef fileDef : namespaceDef.getFiles().values()) {\n            final CodeWriter writer = new CodeWriter(4);\n            writer.writeLine(String.format(\"namespace %s;\", namespaceDef.getNamespace()));\n            if (fileDef.getImports().size() > 0) {\n                writer.newLine();\n                for (ImportDef importDef : fileDef.getImports()) {\n                    switch(importDef.getKind()) {\n                        case NAMESPACE:\n                            writer.writeLine(String.format(\"import %s.*;\", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));\n                            break;\n                        case TYPE:\n                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;\n                            writer.writeLine(importTypeDef.getAlias() == null ? String.format(\"import %s.%s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName()) : String.format(\"import %s.%s as %s;\", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));\n                            break;\n                        default:\n                            throw new IllegalArgumentException(\"Type of import directive is unknown: \" + importDef.getKind());\n                    }\n                }\n            }\n            if (fileDef.getOptions().size() > 0) {\n                writer.newLine();\n                for (NameValuePair option : fileDef.getOptions()) writer.writeLine(String.format(\"option %s = %s;\", option.getName(), option.getValue().toString()));\n            }\n            saveTypeScope(fileDef, writer);\n            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {\n                writer.saveTo(stream);\n            }\n        }\n    }\n\n    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {\n        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {\n            writer.newLine();\n            saveDecorator(decoratorDef, writer);\n        }\n        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {\n            writer.newLine();\n            saveEnumeration(enumerationDef, writer);\n        }\n        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {\n            writer.newLine();\n            saveInterface(interfaceDef, writer);\n        }\n        for (ClassDef classDef : scope.getDefinedClasses()) {\n            writer.newLine();\n            saveClass(classDef, writer);\n        }\n    }\n\n    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {\n        saveComments(decoratorDef, writer);\n        saveDecorators(decoratorDef, writer);\n        writer.write(String.format(\"decorator %s {\", decoratorDef.getName()));\n        writer.indent();\n        if (decoratorDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(decoratorDef, writer);\n        }\n        saveTypeScope(decoratorDef, writer);\n        if (decoratorDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < decoratorDef.getProperties().size(); i += 1) {\n                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s %s;\", propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s %s = %s;\", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < decoratorDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static String luminaryTypeName(IntegralType type) {\n        switch(type) {\n            case INT8:\n                return \"Int8\";\n            case UINT8:\n                return \"Int8\";\n            case INT16:\n                return \"Int8\";\n            case UINT16:\n                return \"Int8\";\n            case INT32:\n                return \"Int8\";\n            case UINT32:\n                return \"Int8\";\n            case INT64:\n                return \"Int8\";\n            case UINT64:\n                return \"Int8\";\n            default:\n                throw new IllegalArgumentException(\"Integral type '\" + type + \"' is unknown.\");\n        }\n    }\n\n    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {\n        saveComments(enumerationDef, writer);\n        saveDecorators(enumerationDef, writer);\n        writer.write(String.format(\"enum %s : %s {\", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));\n        writer.indent();\n        if (enumerationDef.getMembers().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < enumerationDef.getMembers().size(); i += 1) {\n                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);\n                saveComments(memberDef, writer);\n                saveDecorators(memberDef, writer);\n                writer.writeLine(String.format(\"%s = %s;\", memberDef.getName(), memberDef.getValue().toString()));\n                if (i + 1 < enumerationDef.getMembers().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {\n        saveComments(interfaceDef, writer);\n        saveDecorators(interfaceDef, writer);\n        writer.write(String.format(\"interface %s \", interfaceDef.getName()));\n        if (interfaceDef.getSuperInterfaces().size() > 0) {\n            writer.write(\": \" + interfaceDef.getSuperInterfaces().get(0).getName());\n            for (int i = 1; i < interfaceDef.getSuperInterfaces().size(); i += 1) writer.write(\", \" + interfaceDef.getSuperInterfaces().get(i).getName());\n        }\n        writer.write(\" {\");\n        writer.indent();\n        saveTypeScope(interfaceDef, writer);\n        if (interfaceDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < interfaceDef.getProperties().size(); i += 1) {\n                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                writer.write(String.format(\"%s %s\", propertyDef.getType().toString(), propertyDef.getName()));\n                if (propertyDef.isReadable())\n                    writer.write(\" get\");\n                if (propertyDef.isWritable())\n                    writer.write(\" set\");\n                writer.writeLine(\";\");\n                if (i + 1 < interfaceDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveClass(ClassDef classDef, CodeWriter writer) {\n        saveComments(classDef, writer);\n        saveDecorators(classDef, writer);\n        writer.write(String.format(classDef.isFinal() ? \"final class\" : \"class %s\", classDef.getName()));\n        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {\n            boolean isFirst = true;\n            if (classDef.getSuperClass() != null) {\n                isFirst = false;\n                writer.write(String.format(\": %s\", classDef.getSuperClass().getName()));\n            }\n            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {\n                if (isFirst) {\n                    isFirst = false;\n                    writer.write(String.format(\": %s\", superInterfaceDef.getName()));\n                } else\n                    writer.write(String.format(\", %s\", superInterfaceDef.getName()));\n            }\n        }\n        writer.write(\" {\");\n        writer.indent();\n        if (classDef.getDefinedConstants().size() > 0) {\n            writer.newLine();\n            saveConstants(classDef, writer);\n        }\n        saveTypeScope(classDef, writer);\n        if (classDef.getProperties().size() > 0) {\n            writer.newLine();\n            for (int i = 0; i < classDef.getProperties().size(); i += 1) {\n                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);\n                saveComments(propertyDef, writer);\n                saveDecorators(propertyDef, writer);\n                final String prefix = propertyDef.isFinal() ? (propertyDef.isOverride() ? \"final override \" : \"final \") : (propertyDef.isOverride() ? \"override \" : \"\");\n                if (propertyDef.getDefault() == null)\n                    writer.writeLine(String.format(\"%s%s %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName()));\n                else\n                    writer.writeLine(String.format(\"%s%s %s = %s;\", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));\n                if (i + 1 < classDef.getProperties().size())\n                    writer.newLine();\n            }\n        }\n        writer.dedent();\n        writer.writeLine(\"}\");\n    }\n\n    private static void saveComments(ItemDef commentable, CodeWriter writer) {\n        for (String comment : commentable.getComments()) writer.writeLine(\"/// \" + comment);\n    }\n\n    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {\n        for (Decorator decorator : decoratable.getDecorators()) {\n            final DecoratorDef decoratorDef = decorator.getDefinition();\n            writer.write(String.format(\"[%s\", decoratorDef.getName()));\n            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {\n                writer.write(\"(\");\n                boolean isFirst = true;\n                for (int i = 0; i < decorator.getArguments().size(); i += 1) {\n                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();\n                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {\n                        if (!isFirst)\n                            writer.write(\", \");\n                        else\n                            isFirst = false;\n                        writer.write(String.format(\"%s = %s\", propertyDef.getName(), decorator.getArguments().get(i).getValue()));\n                    }\n                }\n                writer.write(\")\");\n            }\n            writer.writeLine(\"]\");\n        }\n    }\n\n    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {\n        for (int i = 0; i < constantScope.getDefinedConstants().size(); i += 1) {\n            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);\n            saveComments(constantDef, writer);\n            saveDecorators(constantDef, writer);\n            writer.writeLine(String.format(\"const %s %s = %s;\", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));\n            if (i + 1 < constantScope.getDefinedConstants().size())\n                writer.newLine();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final ProjectLoader loader = new ProjectLoader();\n        System.setProperty(\"luminary.search.path\", \"C:\\\\Projects\\\\MaxiMarkets\\\\ProtocolGenerators\\\\luminary\");\n        final ProjectDef projectDef = loader.load(\"C:\\\\Projects\\\\MaxiMarkets\\\\TradingServer\\\\luminary\\\\External\\\\External.json\");\n        ProjectSaver.save(projectDef, \"D:\\\\Temporary\\\\Luminary\");\n    }\n}\n", "refactored": true}
{"hexsha": "b03dd0c9940a7be99af35e2cda606850ecc8f431", "ext": "java", "lang": "Java", "content": "@Controller\n@RequestMapping(\"/applications\")\npublic class ApplicationCrudController extends AbstractCrudController<Application> {\n\n    private static final String[] ALLOWED_FIELDS = new String[] { \"name\", \"shortDescription\", \"scm.user\", \"scm.repo\" };\n\n    @Inject\n    private ApplicationService applicationService;\n\n    @Inject\n    private FarmService farmService;\n\n    /* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getService()\n\t */\n    @Override\n    public CIService<Application> getService() {\n        return applicationService;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()\n\t */\n    @Override\n    protected String[] getAllowedFields() {\n        return ALLOWED_FIELDS;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)\n\t */\n    @Override\n    protected Application doGetDetails(Long id, Model model) {\n        Application app = getService().findOne(id);\n        List<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));\n        model.addAttribute(farms);\n        return app;\n    }\n}\n", "class_id": 0, "repo": "williewheeler/zkybase", "file": "ui/src/main/java/org/zkybase/web/controller/application/ApplicationCrudController.java", "last_update_at": "2021-11-12T21:51:18+00:00", "original_content": "@Controller\n@RequestMapping(\"/applications\")\npublic class ApplicationCrudController extends AbstractCrudController<Application> {\n\n    private static final String[] ALLOWED_FIELDS = new String[] { \"name\", \"shortDescription\", \"scm.user\", \"scm.repo\" };\n\n    @Inject\n    private ApplicationService applicationService;\n\n    @Inject\n    private FarmService farmService;\n\n    /* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getService()\n\t */\n    @Override\n    public CIService<Application> getService() {\n        return applicationService;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()\n\t */\n    @Override\n    protected String[] getAllowedFields() {\n        return ALLOWED_FIELDS;\n    }\n\n    /* (non-Javadoc)\n\t * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)\n\t */\n    @Override\n    protected Application doGetDetails(Long id, Model model) {\n        Application app = getService().findOne(id);\n        List<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));\n        model.addAttribute(farms);\n        return app;\n    }\n}\n", "refactored": false}
{"hexsha": "f62399e89a1c3106290095c2b907f8016f2f0999", "ext": "java", "lang": "Java", "content": "public class SimilarRatingGraph {\n\n    public double maxLength(int[] date, int[] rating) {\n        int n = date.length;\n        double ans = 0;\n        int[] ps = new int[n - 1];\n        int[] qs = new int[n - 1];\n        double[] hypot = new double[n - 1];\n        int i = 0;\n        while (i + 1 < n) try {\n            ps[i] = date[i + 1] - date[i];\n            qs[i] = rating[i + 1] - rating[i];\n            hypot[i] = Math.hypot(ps[i], qs[i]);\n        } finally {\n            i++;\n        }\n        int i = 0;\n        while (i < n) try {\n            int j = i + 1;\n            while (j < n) try {\n                long p01 = 0, p02 = 0;\n                double cur = 0;\n                int k = 0;\n                while (true) try {\n                    if (i + k + 1 == n || j + k + 1 == n) {\n                        break;\n                    }\n                    long p1 = ps[i + k];\n                    long q1 = qs[i + k];\n                    long p2 = ps[j + k];\n                    long q2 = qs[j + k];\n                    if (p1 * q2 != p2 * q1) {\n                        break;\n                    }\n                    if (k == 0) {\n                        p01 = p1;\n                        p02 = p2;\n                    } else {\n                        if (p1 * p02 != p2 * p01) {\n                            break;\n                        }\n                    }\n                    if (p1 > p2) {\n                        cur += hypot[i + k];\n                    } else {\n                        cur += hypot[j + k];\n                    }\n                    ans = Math.max(ans, cur);\n                } finally {\n                    k++;\n                }\n            } finally {\n                j++;\n            }\n        } finally {\n            i++;\n        }\n        return ans;\n    }\n}\n", "class_id": 0, "repo": "mikhail-dvorkin/competitions", "file": "topcoder/srm635/SimilarRatingGraph.java", "last_update_at": "2021-06-24T10:52:44+00:00", "original_content": "public class SimilarRatingGraph {\n\n    public double maxLength(int[] date, int[] rating) {\n        int n = date.length;\n        double ans = 0;\n        int[] ps = new int[n - 1];\n        int[] qs = new int[n - 1];\n        double[] hypot = new double[n - 1];\n        for (int i = 0; i + 1 < n; i++) {\n            ps[i] = date[i + 1] - date[i];\n            qs[i] = rating[i + 1] - rating[i];\n            hypot[i] = Math.hypot(ps[i], qs[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                long p01 = 0, p02 = 0;\n                double cur = 0;\n                for (int k = 0; ; k++) {\n                    if (i + k + 1 == n || j + k + 1 == n) {\n                        break;\n                    }\n                    long p1 = ps[i + k];\n                    long q1 = qs[i + k];\n                    long p2 = ps[j + k];\n                    long q2 = qs[j + k];\n                    if (p1 * q2 != p2 * q1) {\n                        break;\n                    }\n                    if (k == 0) {\n                        p01 = p1;\n                        p02 = p2;\n                    } else {\n                        if (p1 * p02 != p2 * p01) {\n                            break;\n                        }\n                    }\n                    if (p1 > p2) {\n                        cur += hypot[i + k];\n                    } else {\n                        cur += hypot[j + k];\n                    }\n                    ans = Math.max(ans, cur);\n                }\n            }\n        }\n        return ans;\n    }\n}\n", "refactored": true}
{"hexsha": "e2ac5750c6ffaf6424160a62dbcfd9d31d5d8011", "ext": "java", "lang": "Java", "content": "public class LOServer {\n\n    /**\n     * Entry point from the command line\n     *\n     * @param args Command line arguments (currently nothing is supported)\n     */\n    public static void main(String[] args) {\n        Game game = new Game();\n        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);\n        Javalin app = Javalin.create(config -> config.server(() -> new Server(queuedThreadPool))).start(7000);\n        app.routes(() -> {\n            get(\"/api/state\", ctx -> ctx.json(game.getState()));\n            post(\"/api/update\", ctx -> {\n                if (Objects.equals(ctx.contentType(), \"application/json\")) {\n                    List<Integer> list = ctx.bodyAsClass(List.class);\n                    game.update(list.get(0), list.get(1));\n                    ctx.json(game.getState());\n                }\n            });\n            get(\"/api/reset\", ctx -> {\n                game.reset();\n                ctx.json(game.getState());\n            });\n            get(\"/api/status\", ctx -> {\n                ctx.result(\"OK\");\n            });\n        });\n    }\n}\n", "class_id": 0, "repo": "codemaxx1/java_lights_out", "file": "server/src/main/java/cs/isu/edu/cs3321/server/LOServer.java", "last_update_at": "2021-11-15T00:20:10+00:00", "original_content": "public class LOServer {\n\n    /**\n     * Entry point from the command line\n     *\n     * @param args Command line arguments (currently nothing is supported)\n     */\n    public static void main(String[] args) {\n        Game game = new Game();\n        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);\n        Javalin app = Javalin.create(config -> config.server(() -> new Server(queuedThreadPool))).start(7000);\n        app.routes(() -> {\n            get(\"/api/state\", ctx -> ctx.json(game.getState()));\n            post(\"/api/update\", ctx -> {\n                if (Objects.equals(ctx.contentType(), \"application/json\")) {\n                    List<Integer> list = ctx.bodyAsClass(List.class);\n                    game.update(list.get(0), list.get(1));\n                    ctx.json(game.getState());\n                }\n            });\n            get(\"/api/reset\", ctx -> {\n                game.reset();\n                ctx.json(game.getState());\n            });\n            get(\"/api/status\", ctx -> {\n                ctx.result(\"OK\");\n            });\n        });\n    }\n}\n", "refactored": false}
{"hexsha": "54ecda69bf301ee6df3cd3d351eb78aa768b8338", "ext": "java", "lang": "Java", "content": "public class InferenceFrame<V extends Value> extends Frame<V> {\n\n    private V lostValue;\n\n    public InferenceFrame(int nLocals, int nStack) {\n        super(nLocals, nStack);\n    }\n\n    public InferenceFrame(Frame<? extends V> src) {\n        super(src);\n    }\n\n    public V getLostValue() {\n        return lostValue;\n    }\n\n    public void setLostValue(V lostValue) {\n        this.lostValue = lostValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Frame<V> init(Frame<? extends V> src) {\n        if (!(src instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>) src;\n        super.init(inferenceFrame);\n        this.lostValue = inferenceFrame.lostValue;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {\n        if (!(frame instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>) frame;\n        boolean changed = super.merge(frame, interpreter);\n        if (lostValue == null) {\n            lostValue = inferenceFrame.lostValue;\n            changed |= lostValue != null;\n        } else if (inferenceFrame.lostValue != null) {\n            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);\n            changed |= lostValue != newLostValue;\n            lostValue = newLostValue;\n        }\n        return changed;\n    }\n}\n", "class_id": 0, "repo": "prezi/kannotator", "file": "src/org/jetbrains/kannotator/annotationsInference/engine/InferenceFrame.java", "last_update_at": "2021-11-08T09:49:52+00:00", "original_content": "public class InferenceFrame<V extends Value> extends Frame<V> {\n\n    private V lostValue;\n\n    public InferenceFrame(int nLocals, int nStack) {\n        super(nLocals, nStack);\n    }\n\n    public InferenceFrame(Frame<? extends V> src) {\n        super(src);\n    }\n\n    public V getLostValue() {\n        return lostValue;\n    }\n\n    public void setLostValue(V lostValue) {\n        this.lostValue = lostValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Frame<V> init(Frame<? extends V> src) {\n        if (!(src instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>) src;\n        super.init(inferenceFrame);\n        this.lostValue = inferenceFrame.lostValue;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {\n        if (!(frame instanceof InferenceFrame)) {\n            throw new IllegalArgumentException(\"InferenceFrame expected\");\n        }\n        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>) frame;\n        boolean changed = super.merge(frame, interpreter);\n        if (lostValue == null) {\n            lostValue = inferenceFrame.lostValue;\n            changed |= lostValue != null;\n        } else if (inferenceFrame.lostValue != null) {\n            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);\n            changed |= lostValue != newLostValue;\n            lostValue = newLostValue;\n        }\n        return changed;\n    }\n}\n", "refactored": false}
{"hexsha": "64bb9c2ab498522d17c515ad45125a5faeadbb58", "ext": "java", "lang": "Java", "content": "public class SaleRepository extends AbstractBaseRepository<Sale> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Sale get(Long id) {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale WHERE id = :id\", Sale.class);\n        query.setParameter(\"id\", id);\n        Sale result = query.getSingleResult();\n        session.getTransaction().commit();\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<Sale> getAll() {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale\", Sale.class);\n        List<Sale> result = query.getResultList();\n        session.getTransaction().commit();\n        return result;\n    }\n}\n", "class_id": 0, "repo": "clovergaze/dilithium-exchange-manager", "file": "src/main/java/org/infokin/repository/SaleRepository.java", "last_update_at": "2021-05-07T18:19:07+00:00", "original_content": "public class SaleRepository extends AbstractBaseRepository<Sale> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Sale get(Long id) {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale WHERE id = :id\", Sale.class);\n        query.setParameter(\"id\", id);\n        Sale result = query.getSingleResult();\n        session.getTransaction().commit();\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<Sale> getAll() {\n        Session session = getSession();\n        session.beginTransaction();\n        TypedQuery<Sale> query = session.createQuery(\"FROM Sale\", Sale.class);\n        List<Sale> result = query.getResultList();\n        session.getTransaction().commit();\n        return result;\n    }\n}\n", "refactored": false}
{"hexsha": "2ebc1707a010e070eba98804a31f5ec0cac11d57", "ext": "java", "lang": "Java", "content": "public class ProxyIT {\n\n    private static final int MOCK_SERVER_PORT = 8088;\n\n    public static final String MOCK_SERVER_BASE_URL = \"http://localhost:\" + MOCK_SERVER_PORT + \"/\";\n\n    private static final int PROXY_SERVER_PORT = 8080;\n\n    public static final String PROXY_SERVER_BASE_URL = \"http://localhost:\" + PROXY_SERVER_PORT + \"/\";\n\n    private final HttpClient client = new HttpClient();\n\n    {\n        try {\n            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, \"integration test client\"));\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @ClassRule\n    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);\n\n    @Test\n    public void forwardsSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci?lago hind? com?a feliz cardillo y kiwi. La cig?e?a tocaba el saxof?n detr?s del palenque de paja.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL + \"boo\").content(new StringContentProvider(body)).header(\"Content-Type\", \"application/json; charset=UTF-8\").header(\"Foo-Header\", \"foo\").send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(500);\n        verify(postRequestedFor(urlMatching(\"/boo\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n    }\n\n    @Test\n    public void retriesSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci?lago hind? com?a feliz cardillo y kiwi. La cig?e?a tocaba el saxof?n detr?s del palenque de paja.\\\"\";\n        stubFor(post(urlMatching(\"/\")).inScenario(\"retry\").whenScenarioStateIs(Scenario.STARTED).willReturn(aResponse().withStatus(503)).willSetStateTo(\"retry1\"));\n        stubFor(post(urlMatching(\"/\")).inScenario(\"retry\").whenScenarioStateIs(\"retry1\").willReturn(aResponse().withStatus(202)).willSetStateTo(\"retryN\"));\n        stubFor(post(urlMatching(\"/\")).inScenario(\"retry\").whenScenarioStateIs(\"retryN\").willReturn(aResponse().withStatus(208)));\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL).content(new StringContentProvider(body)).header(\"Content-Type\", \"application/json; charset=UTF-8\").header(\"Foo-Header\", \"foo\").send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(5000);\n        verify(2, postRequestedFor(urlMatching(\"/\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:\n        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());\n    }\n\n    @Test\n    public void rejectsMalformedUri() throws Exception {\n        final String body = \"\\\"El veloz murci?lago hind? com?a feliz cardillo y kiwi.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL.replace('/', '\\\\')).content(new StringContentProvider(body)).send();\n        assertEquals(400, response.getStatus());\n    }\n\n    @Test\n    public void rejectsMissingUri() throws Exception {\n        final String body = \"\\\"boo\\\"\";\n        ContentResponse response = client.POST(\"http://localhost:\" + PROXY_SERVER_PORT + \"/\").content(new StringContentProvider(body)).send();\n        assertEquals(400, response.getStatus());\n    }\n}\n", "class_id": 0, "repo": "XroadMedia/qproxy", "file": "src/test/java/tv/xrm/qproxy/ProxyIT.java", "last_update_at": "2021-06-17T12:13:24+00:00", "original_content": "public class ProxyIT {\n\n    private static final int MOCK_SERVER_PORT = 8088;\n\n    public static final String MOCK_SERVER_BASE_URL = \"http://localhost:\" + MOCK_SERVER_PORT + \"/\";\n\n    private static final int PROXY_SERVER_PORT = 8080;\n\n    public static final String PROXY_SERVER_BASE_URL = \"http://localhost:\" + PROXY_SERVER_PORT + \"/\";\n\n    private final HttpClient client = new HttpClient();\n\n    {\n        try {\n            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, \"integration test client\"));\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @ClassRule\n    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);\n\n    @Test\n    public void forwardsSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci?lago hind? com?a feliz cardillo y kiwi. La cig?e?a tocaba el saxof?n detr?s del palenque de paja.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL + \"boo\").content(new StringContentProvider(body)).header(\"Content-Type\", \"application/json; charset=UTF-8\").header(\"Foo-Header\", \"foo\").send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(500);\n        verify(postRequestedFor(urlMatching(\"/boo\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n    }\n\n    @Test\n    public void retriesSimplePost() throws Exception {\n        final String body = \"\\\"El veloz murci?lago hind? com?a feliz cardillo y kiwi. La cig?e?a tocaba el saxof?n detr?s del palenque de paja.\\\"\";\n        stubFor(post(urlMatching(\"/\")).inScenario(\"retry\").whenScenarioStateIs(Scenario.STARTED).willReturn(aResponse().withStatus(503)).willSetStateTo(\"retry1\"));\n        stubFor(post(urlMatching(\"/\")).inScenario(\"retry\").whenScenarioStateIs(\"retry1\").willReturn(aResponse().withStatus(202)).willSetStateTo(\"retryN\"));\n        stubFor(post(urlMatching(\"/\")).inScenario(\"retry\").whenScenarioStateIs(\"retryN\").willReturn(aResponse().withStatus(208)));\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL).content(new StringContentProvider(body)).header(\"Content-Type\", \"application/json; charset=UTF-8\").header(\"Foo-Header\", \"foo\").send();\n        assertEquals(202, response.getStatus());\n        Thread.sleep(5000);\n        verify(2, postRequestedFor(urlMatching(\"/\")).withHeader(\"Foo-Header\", equalTo(\"foo\")).withRequestBody(equalTo(body)));\n        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:\n        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());\n    }\n\n    @Test\n    public void rejectsMalformedUri() throws Exception {\n        final String body = \"\\\"El veloz murci?lago hind? com?a feliz cardillo y kiwi.\\\"\";\n        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param(\"url\", MOCK_SERVER_BASE_URL.replace('/', '\\\\')).content(new StringContentProvider(body)).send();\n        assertEquals(400, response.getStatus());\n    }\n\n    @Test\n    public void rejectsMissingUri() throws Exception {\n        final String body = \"\\\"boo\\\"\";\n        ContentResponse response = client.POST(\"http://localhost:\" + PROXY_SERVER_PORT + \"/\").content(new StringContentProvider(body)).send();\n        assertEquals(400, response.getStatus());\n    }\n}\n", "refactored": false}
{"hexsha": "df29abba1282769ae50dd6b261a43891e13c91c9", "ext": "java", "lang": "Java", "content": "public class SortCapList extends Vector {\n\n    public SortCap getSortCap(int n) {\n        return (SortCap) get(n);\n    }\n\n    public SortCap getSortCap(String type) {\n        if (type == null) {\n            return null;\n        }\n        int nLists = size();\n        int n = 0;\n        while (n < nLists) try {\n            SortCap scap = getSortCap(n);\n            if (type.compareTo(scap.getType()) == 0) {\n                return scap;\n            }\n        } finally {\n            n++;\n        }\n        return null;\n    }\n}\n", "class_id": 0, "repo": "tiwer/letv", "file": "src/main/java/org/cybergarage/upnp/std/av/server/object/SortCapList.java", "last_update_at": "2021-09-29T09:31:39+00:00", "original_content": "public class SortCapList extends Vector {\n\n    public SortCap getSortCap(int n) {\n        return (SortCap) get(n);\n    }\n\n    public SortCap getSortCap(String type) {\n        if (type == null) {\n            return null;\n        }\n        int nLists = size();\n        for (int n = 0; n < nLists; n++) {\n            SortCap scap = getSortCap(n);\n            if (type.compareTo(scap.getType()) == 0) {\n                return scap;\n            }\n        }\n        return null;\n    }\n}\n", "refactored": true}
{"hexsha": "d93af83b46884f4e33c75a2aeeab3e3f01c313cc", "ext": "java", "lang": "Java", "content": "public class CoreTests extends TestCase {\n\n    public static Test suite() {\n        TestSuite suite = new TestSuite(CoreTests.class.getName());\n        suite.addTest(AddImportTest.suite());\n        suite.addTest(SourceActionTests.suite());\n        suite.addTest(ASTNodesInsertTest.suite());\n        suite.addTest(BindingsNameTest.suite());\n        suite.addTest(CallHierarchyTest.suite());\n        suite.addTest(ClassPathDetectorTest.suite());\n        suite.addTest(CodeFormatterUtilTest.suite());\n        suite.addTest(CodeFormatterTest.suite());\n        suite.addTest(HierarchicalASTVisitorTest.suite());\n        suite.addTest(ImportOrganizeTest.suite());\n        suite.addTest(ImportOrganizeTest18.suite());\n        suite.addTest(JavaElementLabelsTest.suite());\n        suite.addTest(JavaElementLabelsTest18.suite());\n        suite.addTest(BindingLabelsTest.suite());\n        suite.addTest(BindingLabels18Test.suite());\n        suite.addTest(JavaElementPropertyTesterTest.suite());\n        suite.addTest(JavaModelUtilTest.suite());\n        suite.addTest(MethodOverrideTest.suite());\n        suite.addTest(MethodOverrideTest18.suite());\n        suite.addTest(NameProposerTest.suite());\n        suite.addTest(OverrideTest.suite());\n        suite.addTest(PartialASTTest.suite());\n        suite.addTest(ScopeAnalyzerTest.suite());\n        suite.addTest(TemplateStoreTest.suite());\n        suite.addTest(TypeHierarchyTest.suite());\n        suite.addTest(TypeRulesTest.suite());\n        suite.addTest(TypeInfoTest.suite());\n        suite.addTest(StringsTest.suite());\n        suite.addTest(IndentManipulationTest.suite());\n        suite.addTest(SelectionHistoryTest.suite());\n        suite.addTest(ASTProviderTest.suite());\n        suite.addTest(JDTFlagsTest18.suite());\n        return new ProjectTestSetup(suite);\n    }\n\n    public CoreTests(String name) {\n        super(name);\n    }\n\n    public static void assertEqualString(String actual, String expected) {\n        StringAsserts.assertEqualString(actual, expected);\n    }\n\n    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {\n        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);\n    }\n\n    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {\n        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);\n    }\n\n    public static void assertNumberOf(String name, int is, int expected) {\n        assertTrue(\"Wrong number of \" + name + \", is: \" + is + \", expected: \" + expected, is == expected);\n    }\n\n    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {\n        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n\n    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {\n        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n}\n", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.ui/10378.java", "last_update_at": "2021-11-29T08:28:07+00:00", "original_content": "public class CoreTests extends TestCase {\n\n    public static Test suite() {\n        TestSuite suite = new TestSuite(CoreTests.class.getName());\n        suite.addTest(AddImportTest.suite());\n        suite.addTest(SourceActionTests.suite());\n        suite.addTest(ASTNodesInsertTest.suite());\n        suite.addTest(BindingsNameTest.suite());\n        suite.addTest(CallHierarchyTest.suite());\n        suite.addTest(ClassPathDetectorTest.suite());\n        suite.addTest(CodeFormatterUtilTest.suite());\n        suite.addTest(CodeFormatterTest.suite());\n        suite.addTest(HierarchicalASTVisitorTest.suite());\n        suite.addTest(ImportOrganizeTest.suite());\n        suite.addTest(ImportOrganizeTest18.suite());\n        suite.addTest(JavaElementLabelsTest.suite());\n        suite.addTest(JavaElementLabelsTest18.suite());\n        suite.addTest(BindingLabelsTest.suite());\n        suite.addTest(BindingLabels18Test.suite());\n        suite.addTest(JavaElementPropertyTesterTest.suite());\n        suite.addTest(JavaModelUtilTest.suite());\n        suite.addTest(MethodOverrideTest.suite());\n        suite.addTest(MethodOverrideTest18.suite());\n        suite.addTest(NameProposerTest.suite());\n        suite.addTest(OverrideTest.suite());\n        suite.addTest(PartialASTTest.suite());\n        suite.addTest(ScopeAnalyzerTest.suite());\n        suite.addTest(TemplateStoreTest.suite());\n        suite.addTest(TypeHierarchyTest.suite());\n        suite.addTest(TypeRulesTest.suite());\n        suite.addTest(TypeInfoTest.suite());\n        suite.addTest(StringsTest.suite());\n        suite.addTest(IndentManipulationTest.suite());\n        suite.addTest(SelectionHistoryTest.suite());\n        suite.addTest(ASTProviderTest.suite());\n        suite.addTest(JDTFlagsTest18.suite());\n        return new ProjectTestSetup(suite);\n    }\n\n    public CoreTests(String name) {\n        super(name);\n    }\n\n    public static void assertEqualString(String actual, String expected) {\n        StringAsserts.assertEqualString(actual, expected);\n    }\n\n    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {\n        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);\n    }\n\n    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {\n        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);\n    }\n\n    public static void assertNumberOf(String name, int is, int expected) {\n        assertTrue(\"Wrong number of \" + name + \", is: \" + is + \", expected: \" + expected, is == expected);\n    }\n\n    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {\n        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n\n    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {\n        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);\n        rewrite.setImportOrder(order);\n        rewrite.setOnDemandImportThreshold(normalThreshold);\n        rewrite.setStaticOnDemandImportThreshold(staticThreshold);\n        return rewrite;\n    }\n}\n", "refactored": false}
{"hexsha": "ffa7aaacd75d5ecdbf2cb0c38e1b729e373cae89", "ext": "java", "lang": "Java", "content": "public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {\n\n    private HashMap<String, HashMap<String, int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();\n\n    private int m_countSpectra = 0;\n\n    private int m_groups = 10;\n\n    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {\n        FragmentationSite fs = f.getFragmentationSites()[0];\n        String[] siteNames = new String[] { fs.NTerm.SequenceID, fs.CTerm.SequenceID };\n        if (fs.site == 0) {\n            siteNames[0] += \"nt\";\n        }\n        if (fs.site == fs.peptide.length() - 1) {\n            siteNames[1] += \"ct\";\n        }\n        if (fs.site == match.getLinkingSite(fs.peptide)) {\n            siteNames[0] += \"xl\";\n        }\n        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {\n            siteNames[1] += \"xl\";\n        }\n        return siteNames;\n    }\n\n    protected boolean checkCrosslinked(Fragment f, int linkSide) {\n        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @return the m_countSpectra\n     */\n    public int getSeenSpectra() {\n        return m_countSpectra;\n    }\n\n    public FragmentationSiteIntensityIonSpecific() {\n    }\n\n    public boolean validFragment(Fragment f) {\n        // no loss and no double fragmentation\n        return (!(f instanceof Loss)) && f.getFragmentationSites().length == 1;\n    }\n\n    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {\n        if (f.getFragmentationSites().length != 1) {\n            return false;\n        }\n        if (f instanceof Loss) {\n            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, charge);\n            return mbf.isBaseFragmentFound();\n        } else\n            return true;\n    }\n\n    private void incrementSite(String n, String c, int group) {\n        HashMap<String, int[]> nGroup = m_FragmentationSiteOccurence.get(n);\n        if (nGroup == null) {\n            nGroup = new HashMap<String, int[]>();\n            int[] cGroup = new int[m_groups + 1];\n            java.util.Arrays.fill(cGroup, 0);\n            cGroup[group] = 1;\n            nGroup.put(c, cGroup);\n            m_FragmentationSiteOccurence.put(n, nGroup);\n        } else {\n            int[] cGroup = nGroup.get(c);\n            if (cGroup == null) {\n                cGroup = new int[m_groups + 1];\n                java.util.Arrays.fill(cGroup, 0);\n                cGroup[group] = 1;\n                nGroup.put(c, cGroup);\n            } else\n                cGroup[group]++;\n        }\n    }\n\n    public void countSpectraMatch(MatchedXlinkedPeptide match) {\n        MatchedFragmentCollection mfc = match.getMatchedFragments();\n        Spectra deisotoped = match.getSpectrum().deIsotop();\n        HashMap<String, HashMap<String, Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();\n        HashMap<Fragment, Boolean> foundFragments = new HashMap<Fragment, Boolean>();\n        // read out all possible fragmentation sites\n        for (Fragment f : match.getPossibleFragments()) {\n            if (validFragment(f)) {\n                foundFragments.put(f, Boolean.FALSE);\n            }\n        }\n        // among all peaks sorted by intensity\n        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);\n        int group = 0;\n        int peakCount = peaks.size();\n        double groupSize = peakCount / (double) m_groups;\n        int currentPeak = -1;\n        int counted = 0;\n        for (SpectraPeak sp : peaks) {\n            currentPeak++;\n            group = (int) (currentPeak / groupSize);\n            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {\n                Fragment f = mf.getFragment();\n                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());\n                // only if the fragment matches the conditions and was not found yet\n                if (canCountFragment(f, mf.getCharge(), mfc) && !foundFragments.get(mbf.getBaseFragment())) {\n                    String[] siteNames = convertFragmentationSite(match, f);\n                    String n = siteNames[0];\n                    String c = siteNames[1];\n                    // only if we didn't count that site combination already\n                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);\n                    incrementSite(n, c, group);\n                    counted++;\n                }\n            }\n        }\n        int found = 0;\n        int missed = 0;\n        // now look at all non matched fragmentation sites\n        for (Fragment f : foundFragments.keySet()) {\n            if (!foundFragments.get(f)) {\n                missed++;\n                String[] siteNames = convertFragmentationSite(match, f);\n                String n = siteNames[0];\n                String c = siteNames[1];\n                incrementSite(n, c, m_groups);\n            } else {\n                found++;\n            }\n        }\n        System.err.println(\"counted : \" + counted + \",  found : \" + found + \",  missed : \" + missed);\n        m_countSpectra++;\n    }\n\n    @Override\n    public void writeFile(OutputStream output) {\n        PrintStream out = new PrintStream(output);\n        out.print(\"C,N\");\n        int i = 1;\n        while (i <= m_groups) try {\n            out.print(\",\" + (100.0 * i / (double) m_groups));\n        } finally {\n            i++;\n        }\n        out.print(\", notFound\");\n        out.println(getTable());\n        out.flush();\n    }\n\n    public String getTable() {\n        //StringBuffer ret = new StringBuffer(\"#intesity based fragmentation events of aminoacid pairs\\n\");\n        StringBuffer ret = new StringBuffer();\n        String[] nList = m_FragmentationSiteOccurence.keySet().toArray(new String[0]);\n        java.util.Arrays.sort(nList);\n        for (String n : nList) {\n            HashMap<String, int[]> cGroups = m_FragmentationSiteOccurence.get(n);\n            String[] cList = cGroups.keySet().toArray(new String[0]);\n            java.util.Arrays.sort(cList);\n            for (String c : cList) {\n                int[] groups = cGroups.get(c);\n                ret.append(n + \",\" + c);\n                for (int count : groups) {\n                    ret.append(\",\" + count);\n                }\n                ret.append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }\n}\n", "class_id": 0, "repo": "MireiaDiaz/XiSearch", "file": "src/main/java/rappsilber/ms/statistics/generator/FragmentationSiteIntensityIonSpecific.java", "last_update_at": "2021-02-16T00:30:24+00:00", "original_content": "public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {\n\n    private HashMap<String, HashMap<String, int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();\n\n    private int m_countSpectra = 0;\n\n    private int m_groups = 10;\n\n    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {\n        FragmentationSite fs = f.getFragmentationSites()[0];\n        String[] siteNames = new String[] { fs.NTerm.SequenceID, fs.CTerm.SequenceID };\n        if (fs.site == 0) {\n            siteNames[0] += \"nt\";\n        }\n        if (fs.site == fs.peptide.length() - 1) {\n            siteNames[1] += \"ct\";\n        }\n        if (fs.site == match.getLinkingSite(fs.peptide)) {\n            siteNames[0] += \"xl\";\n        }\n        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {\n            siteNames[1] += \"xl\";\n        }\n        return siteNames;\n    }\n\n    protected boolean checkCrosslinked(Fragment f, int linkSide) {\n        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @return the m_countSpectra\n     */\n    public int getSeenSpectra() {\n        return m_countSpectra;\n    }\n\n    public FragmentationSiteIntensityIonSpecific() {\n    }\n\n    public boolean validFragment(Fragment f) {\n        // no loss and no double fragmentation\n        return (!(f instanceof Loss)) && f.getFragmentationSites().length == 1;\n    }\n\n    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {\n        if (f.getFragmentationSites().length != 1) {\n            return false;\n        }\n        if (f instanceof Loss) {\n            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, charge);\n            return mbf.isBaseFragmentFound();\n        } else\n            return true;\n    }\n\n    private void incrementSite(String n, String c, int group) {\n        HashMap<String, int[]> nGroup = m_FragmentationSiteOccurence.get(n);\n        if (nGroup == null) {\n            nGroup = new HashMap<String, int[]>();\n            int[] cGroup = new int[m_groups + 1];\n            java.util.Arrays.fill(cGroup, 0);\n            cGroup[group] = 1;\n            nGroup.put(c, cGroup);\n            m_FragmentationSiteOccurence.put(n, nGroup);\n        } else {\n            int[] cGroup = nGroup.get(c);\n            if (cGroup == null) {\n                cGroup = new int[m_groups + 1];\n                java.util.Arrays.fill(cGroup, 0);\n                cGroup[group] = 1;\n                nGroup.put(c, cGroup);\n            } else\n                cGroup[group]++;\n        }\n    }\n\n    public void countSpectraMatch(MatchedXlinkedPeptide match) {\n        MatchedFragmentCollection mfc = match.getMatchedFragments();\n        Spectra deisotoped = match.getSpectrum().deIsotop();\n        HashMap<String, HashMap<String, Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();\n        HashMap<Fragment, Boolean> foundFragments = new HashMap<Fragment, Boolean>();\n        // read out all possible fragmentation sites\n        for (Fragment f : match.getPossibleFragments()) {\n            if (validFragment(f)) {\n                foundFragments.put(f, Boolean.FALSE);\n            }\n        }\n        // among all peaks sorted by intensity\n        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);\n        int group = 0;\n        int peakCount = peaks.size();\n        double groupSize = peakCount / (double) m_groups;\n        int currentPeak = -1;\n        int counted = 0;\n        for (SpectraPeak sp : peaks) {\n            currentPeak++;\n            group = (int) (currentPeak / groupSize);\n            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {\n                Fragment f = mf.getFragment();\n                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());\n                // only if the fragment matches the conditions and was not found yet\n                if (canCountFragment(f, mf.getCharge(), mfc) && !foundFragments.get(mbf.getBaseFragment())) {\n                    String[] siteNames = convertFragmentationSite(match, f);\n                    String n = siteNames[0];\n                    String c = siteNames[1];\n                    // only if we didn't count that site combination already\n                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);\n                    incrementSite(n, c, group);\n                    counted++;\n                }\n            }\n        }\n        int found = 0;\n        int missed = 0;\n        // now look at all non matched fragmentation sites\n        for (Fragment f : foundFragments.keySet()) {\n            if (!foundFragments.get(f)) {\n                missed++;\n                String[] siteNames = convertFragmentationSite(match, f);\n                String n = siteNames[0];\n                String c = siteNames[1];\n                incrementSite(n, c, m_groups);\n            } else {\n                found++;\n            }\n        }\n        System.err.println(\"counted : \" + counted + \",  found : \" + found + \",  missed : \" + missed);\n        m_countSpectra++;\n    }\n\n    @Override\n    public void writeFile(OutputStream output) {\n        PrintStream out = new PrintStream(output);\n        out.print(\"C,N\");\n        for (int i = 1; i <= m_groups; i++) {\n            out.print(\",\" + (100.0 * i / (double) m_groups));\n        }\n        out.print(\", notFound\");\n        out.println(getTable());\n        out.flush();\n    }\n\n    public String getTable() {\n        //StringBuffer ret = new StringBuffer(\"#intesity based fragmentation events of aminoacid pairs\\n\");\n        StringBuffer ret = new StringBuffer();\n        String[] nList = m_FragmentationSiteOccurence.keySet().toArray(new String[0]);\n        java.util.Arrays.sort(nList);\n        for (String n : nList) {\n            HashMap<String, int[]> cGroups = m_FragmentationSiteOccurence.get(n);\n            String[] cList = cGroups.keySet().toArray(new String[0]);\n            java.util.Arrays.sort(cList);\n            for (String c : cList) {\n                int[] groups = cGroups.get(c);\n                ret.append(n + \",\" + c);\n                for (int count : groups) {\n                    ret.append(\",\" + count);\n                }\n                ret.append(\"\\n\");\n            }\n        }\n        return ret.toString();\n    }\n}\n", "refactored": true}
{"hexsha": "3ede65710f688d01a47e728a22d61210d6155313", "ext": "java", "lang": "Java", "content": "public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {\n\n    public static final String COLOR = \"color\";\n\n    public static final String IS_MUTED = \"is_muted\";\n\n    public static final String PIN_TO_TOP = \"pin_to_top\";\n\n    public static final String DESKTOP_NOTIFICATIONS = \"desktop_notifications\";\n\n    public static final String AUDIBLE_NOTIFICATIONS = \"audible_notifications\";\n\n    public static final String PUSH_NOTIFICATIONS = \"push_notifications\";\n\n    public static final String EMAIL_NOTIFICATIONS = \"email_notifications\";\n\n    public static final String SUBSCRIPTION_DATA = \"subscription_data\";\n\n    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();\n\n    /**\n     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.\n     *\n     * @param client The Zulip HTTP client\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {\n        super(client);\n    }\n\n    /**\n     * Sets the hex value of the color to display on the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  color    The hex value of the color\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {\n        addSetting(streamId, COLOR, color);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be muted.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {\n        addSetting(streamId, IS_MUTED, muted);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be pinned to the top in the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {\n        addSetting(streamId, PIN_TO_TOP, pinToTop);\n        return this;\n    }\n\n    /**\n     * Sets whether to show desktop notifications for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {\n        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to play a sound for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {\n        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId          The id of the stream for which the setting should be updated\n     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push\n     *                           notifications.\n     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {\n        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId           The id of the stream for which the setting should be updated\n     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.\n     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {\n        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);\n        return this;\n    }\n\n    private void addSetting(long streamId, String property, Object value) {\n        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);\n        settings.remove(setting);\n        settings.add(setting);\n    }\n\n    /**\n     * Executes the Zulip API request for updating stream subscription settings.\n     *\n     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}\n     * @throws ZulipClientException if the request was not successful\n     */\n    @Override\n    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {\n        putParamAsJsonString(SUBSCRIPTION_DATA, settings);\n        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(), UpdateStreamSubscriptionSettingsApiResponse.class);\n        return response.getSubscriptionData();\n    }\n}\n", "class_id": 0, "repo": "mrchaos/zulip-java-client", "file": "src/main/java/com/github/jamesnetherton/zulip/client/api/stream/request/UpdateStreamSubscriptionSettingsApiRequest.java", "last_update_at": "2021-12-10T13:20:55+00:00", "original_content": "public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {\n\n    public static final String COLOR = \"color\";\n\n    public static final String IS_MUTED = \"is_muted\";\n\n    public static final String PIN_TO_TOP = \"pin_to_top\";\n\n    public static final String DESKTOP_NOTIFICATIONS = \"desktop_notifications\";\n\n    public static final String AUDIBLE_NOTIFICATIONS = \"audible_notifications\";\n\n    public static final String PUSH_NOTIFICATIONS = \"push_notifications\";\n\n    public static final String EMAIL_NOTIFICATIONS = \"email_notifications\";\n\n    public static final String SUBSCRIPTION_DATA = \"subscription_data\";\n\n    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();\n\n    /**\n     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.\n     *\n     * @param client The Zulip HTTP client\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {\n        super(client);\n    }\n\n    /**\n     * Sets the hex value of the color to display on the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  color    The hex value of the color\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {\n        addSetting(streamId, COLOR, color);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be muted.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {\n        addSetting(streamId, IS_MUTED, muted);\n        return this;\n    }\n\n    /**\n     * Sets whether the stream should be pinned to the top in the Zulip UI.\n     *\n     * @param  streamId The id of the stream for which the setting should be updated\n     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream\n     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {\n        addSetting(streamId, PIN_TO_TOP, pinToTop);\n        return this;\n    }\n\n    /**\n     * Sets whether to show desktop notifications for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {\n        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to play a sound for messages sent to the stream.\n     *\n     * @param  streamId             The id of the stream for which the setting should be updated\n     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible\n     *                              notifications.\n     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {\n        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId          The id of the stream for which the setting should be updated\n     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push\n     *                           notifications.\n     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {\n        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);\n        return this;\n    }\n\n    /**\n     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.\n     *\n     * @param  streamId           The id of the stream for which the setting should be updated\n     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.\n     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance\n     */\n    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {\n        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);\n        return this;\n    }\n\n    private void addSetting(long streamId, String property, Object value) {\n        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);\n        settings.remove(setting);\n        settings.add(setting);\n    }\n\n    /**\n     * Executes the Zulip API request for updating stream subscription settings.\n     *\n     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}\n     * @throws ZulipClientException if the request was not successful\n     */\n    @Override\n    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {\n        putParamAsJsonString(SUBSCRIPTION_DATA, settings);\n        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(), UpdateStreamSubscriptionSettingsApiResponse.class);\n        return response.getSubscriptionData();\n    }\n}\n", "refactored": false}
{"hexsha": "8ed1c75425218a94e5c8b30fb96444eeac5d7691", "ext": "java", "lang": "Java", "content": "public class PointPlot extends Plot2D {\n\n    protected double m_x;\n\n    protected double m_y;\n\n    protected boolean m_first;\n\n    public PointPlot(double x, double y, ChartX chart, Color color) {\n        super(chart, color);\n        m_maxX = m_minX = m_x = x;\n        m_maxY = m_minY = m_y = y;\n    }\n\n    public void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY) {\n        g.setColor(m_color);\n        int GX = projectX(m_x, minGX, maxGX);\n        int GY = projectY(m_y, minGY, maxGY);\n        g.fillOval(GX - 5, GY - 5, 10, 10);\n    }\n}\n", "class_id": 0, "repo": "chen0040/cpp-ogre-mllab", "file": "ML/src/visualizer/simpleui/PointPlot.java", "last_update_at": "2021-10-04T09:40:26+00:00", "original_content": "public class PointPlot extends Plot2D {\n\n    protected double m_x;\n\n    protected double m_y;\n\n    protected boolean m_first;\n\n    public PointPlot(double x, double y, ChartX chart, Color color) {\n        super(chart, color);\n        m_maxX = m_minX = m_x = x;\n        m_maxY = m_minY = m_y = y;\n    }\n\n    public void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY) {\n        g.setColor(m_color);\n        int GX = projectX(m_x, minGX, maxGX);\n        int GY = projectY(m_y, minGY, maxGY);\n        g.fillOval(GX - 5, GY - 5, 10, 10);\n    }\n}\n", "refactored": false}
{"hexsha": "58a1281ad64f50e807c784278332fa731843ae46", "ext": "java", "lang": "Java", "content": "public class FCBlockTorchBaseBurning extends FCBlockTorchBase {\r\n\r\n    protected FCBlockTorchBaseBurning(int iBlockID) {\r\n        super(iBlockID);\r\n    }\r\n\r\n    @Override\r\n    public boolean GetCanBlockLightItemOnFire(IBlockAccess blockAccess, int i, int j, int k) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void OnFluidFlowIntoBlock(World world, int i, int j, int k, BlockFluid newBlock) {\r\n        if (newBlock.blockMaterial == Material.water) {\r\n            world.playAuxSFX(FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0);\r\n            dropBlockAsItem_do(world, i, j, k, new ItemStack(FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0));\r\n        } else {\r\n            super.OnFluidFlowIntoBlock(world, i, j, k, newBlock);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void randomDisplayTick(World world, int i, int j, int k, Random rand) {\r\n        Vec3 pos = GetParticalPos(world, i, j, k);\r\n        world.spawnParticle(\"smoke\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D);\r\n        world.spawnParticle(\"flame\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D);\r\n    }\r\n\r\n    protected Vec3 GetParticalPos(World world, int i, int j, int k) {\r\n        Vec3 pos = Vec3.createVectorHelper(i + 0.5D, j + 0.92D, k + 0.5D);\r\n        int iOrientation = GetOrientation(world, i, j, k);\r\n        double dHorizontalOffset = 0.27D;\r\n        if (iOrientation == 1) {\r\n            pos.xCoord -= dHorizontalOffset;\r\n        } else if (iOrientation == 2) {\r\n            pos.xCoord += dHorizontalOffset;\r\n        } else if (iOrientation == 3) {\r\n            pos.zCoord -= dHorizontalOffset;\r\n        } else if (iOrientation == 4) {\r\n            pos.zCoord += dHorizontalOffset;\r\n        } else {\r\n            pos.yCoord -= 0.22D;\r\n        }\r\n        return pos;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "sargunv/better-than-wolves-mod", "file": "Src/FCBlockTorchBaseBurning.java", "last_update_at": "2021-04-11T22:29:23+00:00", "original_content": "public class FCBlockTorchBaseBurning extends FCBlockTorchBase {\r\n\r\n    protected FCBlockTorchBaseBurning(int iBlockID) {\r\n        super(iBlockID);\r\n    }\r\n\r\n    @Override\r\n    public boolean GetCanBlockLightItemOnFire(IBlockAccess blockAccess, int i, int j, int k) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void OnFluidFlowIntoBlock(World world, int i, int j, int k, BlockFluid newBlock) {\r\n        if (newBlock.blockMaterial == Material.water) {\r\n            world.playAuxSFX(FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0);\r\n            dropBlockAsItem_do(world, i, j, k, new ItemStack(FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0));\r\n        } else {\r\n            super.OnFluidFlowIntoBlock(world, i, j, k, newBlock);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void randomDisplayTick(World world, int i, int j, int k, Random rand) {\r\n        Vec3 pos = GetParticalPos(world, i, j, k);\r\n        world.spawnParticle(\"smoke\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D);\r\n        world.spawnParticle(\"flame\", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D);\r\n    }\r\n\r\n    protected Vec3 GetParticalPos(World world, int i, int j, int k) {\r\n        Vec3 pos = Vec3.createVectorHelper(i + 0.5D, j + 0.92D, k + 0.5D);\r\n        int iOrientation = GetOrientation(world, i, j, k);\r\n        double dHorizontalOffset = 0.27D;\r\n        if (iOrientation == 1) {\r\n            pos.xCoord -= dHorizontalOffset;\r\n        } else if (iOrientation == 2) {\r\n            pos.xCoord += dHorizontalOffset;\r\n        } else if (iOrientation == 3) {\r\n            pos.zCoord -= dHorizontalOffset;\r\n        } else if (iOrientation == 4) {\r\n            pos.zCoord += dHorizontalOffset;\r\n        } else {\r\n            pos.yCoord -= 0.22D;\r\n        }\r\n        return pos;\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "76e896093e16ee748c72b09602331499e4880900", "ext": "java", "lang": "Java", "content": "public final class ClassTools {\n\n    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];\n\n    public static final Object[] ZERO_PARAMETERS = new Object[0];\n\n    private static final String CR = StringTools.CR;\n\n    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';\n\n    public static final char ARRAY_INDICATOR = '[';\n\n    public static final char REFERENCE_CLASS_CODE = 'L';\n\n    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';\n\n    private static PrimitiveClassCode[] primitiveClassCodes;\n\n    public static final char BYTE_CODE = 'B';\n\n    public static final char CHAR_CODE = 'C';\n\n    public static final char DOUBLE_CODE = 'D';\n\n    public static final char FLOAT_CODE = 'F';\n\n    public static final char INT_CODE = 'I';\n\n    public static final char LONG_CODE = 'J';\n\n    public static final char SHORT_CODE = 'S';\n\n    public static final char BOOLEAN_CODE = 'Z';\n\n    public static final char VOID_CODE = 'V';\n\n    /**\n     * Return all the fields for the\n     * specified class, including inherited fields.\n     * Class#allFields()\n     */\n    public static Field[] allFields(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredFields(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Field[]) stack.toArray(new Field[stack.size()]);\n    }\n\n    /**\n     * Return all the methods for the\n     * specified class, including inherited methods.\n     * Class#allMethods()\n     */\n    public static Method[] allMethods(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredMethods(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Method[]) stack.toArray(new Method[stack.size()]);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Throw an exception if the default constructor is not defined.\n     * Class#newInstance() throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        try {\n            return constructor(javaClass, parameterTypes).newInstance(parameters);\n        } catch (InstantiationException ie) {\n            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Attempt to get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#getFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(object, fieldName).get(object);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to get a static field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(javaClass, fieldName).get(null);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument method,\n     * given the receiver and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * If the invoked method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws Throwable, NoSuchMethodException {\n        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Attempt to set a field value, given the\n     * containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(object, fieldName).set(object, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to set a static field value, given the\n     * containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(javaClass, fieldName).set(null, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor() throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return the constructor for the specified class\n     * and formal parameter types.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {\n        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);\n        constructor.setAccessible(true);\n        return constructor;\n    }\n\n    /**\n     * Convenience method.\n     * Return the constructor for the specified class\n     * and formal parameter type.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class parameterType) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {\n        return constructor(javaClass, new Class[] { parameterType });\n    }\n\n    /**\n     * Return the declared fields for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     * Class#accessibleDeclaredFields()\n     */\n    public static Field[] declaredFields(Class javaClass) {\n        Field[] fields = javaClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n        return fields;\n    }\n\n    /**\n     * Return the declared methods for the\n     * specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     * Class#accessibleDeclaredMethods()\n     */\n    public static Method[] declaredMethods(Class javaClass) {\n        Method[] methods = javaClass.getDeclaredMethods();\n        for (int i = 0; i < methods.length; i++) {\n            methods[i].setAccessible(true);\n        }\n        return methods;\n    }\n\n    /**\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#defaultConstructor()\n     */\n    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass);\n    }\n\n    /**\n     * Return a field for the specified class and field name.\n     * If the class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {\n        Field field = null;\n        try {\n            field = javaClass.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return field(superclass, fieldName);\n        }\n        field.setAccessible(true);\n        return field;\n    }\n\n    /**\n     * Convenience method.\n     * Return a field for the specified object and field name.\n     * If the object's class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Object object, String fieldName) throws NoSuchFieldException {\n        return field(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified constructor.\n     */\n    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        sb.append('.');\n        sb.append(fieldName);\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Object object, String fieldName) {\n        return fullyQualifiedFieldName(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        // this check allows us to use this code for constructors, where the methodName is null\n        if (methodName != null) {\n            sb.append('.');\n            sb.append(methodName);\n        }\n        sb.append('(');\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sb.append(parameterTypes[i].getName());\n            if (i < parameterTypes.length - 1)\n                sb.append(\", \");\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Object#getFieldValue(String fieldName)\n     */\n    public static Object getFieldValue(Object object, String fieldName) {\n        try {\n            return attemptToGetFieldValue(object, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Get a static field value, given the containing class and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Class#getStaticFieldValue(String fieldName)\n     */\n    public static Object getStaticFieldValue(Class javaClass, String fieldName) {\n        try {\n            return attemptToGetStaticFieldValue(javaClass, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethod(Object receiver, String methodName) {\n        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {\n        return invokeMethod(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName) throws Throwable {\n        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter) throws Throwable {\n        return invokeMethodWithException(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws Throwable {\n        try {\n            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(method + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Convert all other exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters) throws Throwable {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause == null) {\n                throw new RuntimeException(method.toString(), ite);\n            }\n            throw cause;\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName) {\n        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {\n        return invokeStaticMethod(javaClass, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Invoke the specified static method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeStaticMethod(Method method, Object[] parameters) {\n        return invokeMethod(method, null, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {\n        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = null;\n        try {\n            method = javaClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return method(superclass, methodName, parameterTypes);\n        }\n        method.setAccessible(true);\n        return method;\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(javaClass, methodName, new Class[] { parameterType });\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified object\n     * and method name. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName) throws NoSuchMethodException {\n        return method(object.getClass(), methodName);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter types. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter type. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterType);\n    }\n\n    /**\n     * Convenience method.\n     * Return the specified class (w/o the checked exception).\n     */\n    public static Class classForName(String className) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(className, ex);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(Class javaClass) {\n        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className) throws ClassNotFoundException {\n        return newInstance(className, null);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader));\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptNewInstance(javaClass, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {\n        return newInstance(className, parameterTypes, parameters, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {\n        return newInstance(javaClass, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {\n        return newInstance(className, parameterType, parameter, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);\n    }\n\n    /**\n     * Push the declared fields for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredFields(Class javaClass, Stack stack) {\n        Field[] fields = declaredFields(javaClass);\n        for (int i = fields.length - 1; i >= 0; i--) {\n            stack.push(fields[i]);\n        }\n    }\n\n    /**\n     * Push the declared methods for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredMethods(Class javaClass, Stack stack) {\n        Method[] methods = declaredMethods(javaClass);\n        for (int i = methods.length - 1; i >= 0; i--) {\n            stack.push(methods[i]);\n        }\n    }\n\n    /**\n     * Set a field value, given the containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Object#setFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetFieldValue(object, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Set a static field value, given the containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Return the short name of the object's class.\n     * Class#getShortName()\n     */\n    public static String shortClassNameForObject(Object object) {\n        return shortNameFor(object.getClass());\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameFor(Class javaClass) {\n        return shortNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the nested name of the object's class.\n     * Class#getNestedName()\n     */\n    public static String nestedClassNameForObject(Object object) {\n        return nestedNameFor(object.getClass());\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameFor(Class javaClass) {\n        return nestedNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the \"toString()\" name of the object's class.\n     */\n    public static String toStringClassNameForObject(Object object) {\n        return toStringNameFor(object.getClass());\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     * \"Member\" classes will return only the final name:\n     *     \"com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass\"\n     *         => \"NestedMemberClass\"\n     * \"Local\" and \"anonymous\" classes will still return the embedded '$'s:\n     *     \"com.foo.bar.TopLevelClass$1LocalClass\"\n     *         => \"TopLevelClass$1LocalClass\"\n     *     \"com.foo.bar.TopLevelClass$1\"\n     *         => \"TopLevelClass$1\"\n     */\n    public static String toStringNameForClassNamed(String className) {\n        return classNamedIsMember(className) ? className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1) : className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     */\n    public static String toStringNameFor(Class javaClass) {\n        return toStringNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameFor(Class javaClass) {\n        return packageNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameForClassNamed(String className) {\n        int lastPeriod = className.lastIndexOf('.');\n        if (lastPeriod == -1) {\n            return \"\";\n        }\n        return className.substring(0, lastPeriod);\n    }\n\n    /**\n     * Return the short name of the class,\n     * followed by its package name (e.g. \"Object (java.lang)\").\n     * Class#getShortNameWithPackage()\n     */\n    public static String shortNameWithPackage(Class javaClass) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(shortNameFor(javaClass));\n        if (!javaClass.isPrimitive()) {\n            sb.append(\" (\");\n            sb.append(packageNameFor(javaClass));\n            sb.append(')');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument, static method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a static method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = method(javaClass, methodName, parameterTypes);\n        if (Modifier.isStatic(method.getModifiers())) {\n            return method;\n        }\n        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));\n    }\n\n    /**\n     * Convenience method.\n     * Return a static method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, new Class[] { parameterTypes });\n    }\n\n    /**\n     * Return whether the specified class can be \"declared\" in code;\n     * i.e. it is either a \"top-level\" class or a \"member\" class, but it\n     * is not an \"array\" class. This method rolls together all the checks\n     * from the other methods for a bit of a performance tweak.\n     * Class#isDeclarable()\n     */\n    public static boolean classNamedIsDeclarable(String className) {\n        if (className.charAt(0) == ARRAY_INDICATOR) {\n            // it is an \"array\" class\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            // it is a \"top-level\" class\n            return true;\n        }\n        for (; ; ) try {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } finally {\n            if (!index != -1) {\n                break;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"top-level\" class,\n     * as opposed to a \"member\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name does NOT contain a '$': \"TopLevelClass\").\n     * Class#isTopLevel()\n     */\n    public static boolean classNamedIsTopLevel(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;\n    }\n\n    /**\n     * Return whether the specified class is a \"member\" class,\n     * as opposed to a \"top-level\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name contains at least one '$' and all the names between\n     * each '$' are legal class names:\n     * \"TopLevelClass$MemberClass$NestedMemberClass\").\n     * Class#isMember()\n     */\n    public static boolean classNamedIsMember(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            // it is a \"top-level\" class\n            return false;\n        }\n        for (; ; ) try {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } finally {\n            if (!index != -1) {\n                break;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"local\" class,\n     * as opposed to a \"top-level\", \"member\", or \"anonymous\" class,\n     * using the standard jdk (or Eclipse) naming conventions.\n     * In the jdk, the class name ends with '$nnnXXX' where the '$' is\n     * followed by a series of numeric digits which are followed by the\n     * local class name: \"TopLevelClass$1LocalClass\".\n     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is\n     * followed by a series of numeric digits which are separated from\n     * the local class name by another '$': \"TopLevelClass$1$LocalClass\".\n     * Class#isLocal()\n     */\n    public static boolean classNamedIsLocal(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        if (!Character.isDigit(className.charAt(dollar + 1))) {\n            return false;\n        }\n        for (int i = dollar + 2; i < className.length(); i++) {\n            if (Character.isJavaIdentifierStart(className.charAt(i))) {\n                return true;\n            }\n        }\n        // all the characters past the $ are digits (anonymous)\n        return false;\n    }\n\n    /**\n     * Return whether the specified class is an \"anonymous\" class,\n     * as opposed to a \"top-level\", \"member\", or \"local\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name ends with '$nnn' where all the characters past the\n     * last '$' are numeric digits: \"TopLevelClass$1\").\n     * Class#isAnonymous()\n     */\n    public static boolean classNamedIsAnonymous(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        int start = dollar + 1;\n        for (int i = className.length(); i-- > start; ) {\n            if (!Character.isDigit(className.charAt(i))) {\n                return false;\n            }\n        }\n        // all the characters past the $ are digits\n        return true;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthFor(Class javaClass) {\n        int depth = 0;\n        for (; javaClass.isArray(); ) {\n            depth++;\n            javaClass = javaClass.getComponentType();\n        }\n        return depth;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified object.\n     * The depth is the number of dimensions for an array.\n     * Non-arrays have a depth of zero.\n     */\n    public static int arrayDepthForObject(Object object) {\n        return arrayDepthFor(object.getClass());\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * @see java.lang.Class#getName()\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthForClassNamed(String className) {\n        int depth = 0;\n        for (; className.charAt(depth) == ARRAY_INDICATOR; ) {\n            depth++;\n        }\n        return depth;\n    }\n\n    /**\n     * Return whether the specified class is an array type.\n     * @see java.lang.Class#getName()\n     */\n    public static boolean classNamedIsArray(String className) {\n        return className.charAt(0) == ARRAY_INDICATOR;\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * A non-array type simply returns itself.\n     * Class#getElementType()\n     */\n    public static Class elementTypeFor(Class javaClass) {\n        for (; javaClass.isArray(); ) {\n            javaClass = javaClass.getComponentType();\n        }\n        return javaClass;\n    }\n\n    /**\n     * Return the \"element type\" of the specified object.\n     * The element type is the base type held by an array.\n     * A non-array simply returns its class.\n     */\n    public static Class elementTypeForObject(Object object) {\n        return elementTypeFor(object.getClass());\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * Class#getElementType()\n     */\n    public static String elementTypeNameFor(Class javaClass) {\n        return elementTypeFor(javaClass).getName();\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * @see java.lang.Class#getName()\n     * Class#getElementType()\n     */\n    public static String elementTypeNameForClassNamed(String className) {\n        int depth = arrayDepthForClassNamed(className);\n        if (depth == 0) {\n            // the name is in the form: \"java.lang.Object\" or \"int\"\n            return className;\n        }\n        int last = className.length() - 1;\n        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {\n            // drop the trailing ';'\n            return className.substring(depth + 1, last);\n        }\n        // the name is in the form: \"[[[I\"\n        return classNameForCode(className.charAt(last));\n    }\n\n    /**\n     * Return whether the specified class is a \"reference\"\n     * class (i.e. not void or one of the primitives).\n     */\n    public static boolean classNamedIsReference(String className) {\n        return !classNamedIsNonReference(className);\n    }\n\n    /**\n     * Return whether the specified class is a \"non-reference\"\n     * class (i.e. void or one of the primitives).\n     */\n    public static boolean classNamedIsNonReference(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(char classCode) {\n        return classForCode(classCode).getName();\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(int classCode) {\n        return classNameForCode((char) classCode);\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(char classCode) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].code == classCode) {\n                return codes[i].javaClass;\n            }\n        }\n        throw new IllegalArgumentException(String.valueOf(classCode));\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(int classCode) {\n        return classForCode((char) classCode);\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClass(Class javaClass) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass == javaClass) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(javaClass.getName());\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClassNamed(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(className);\n    }\n\n    /**\n     * Return the class for specified \"type declaration\".\n     */\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {\n        return classForTypeDeclaration(elementTypeName, arrayDepth, null);\n    }\n\n    // see the \"Evaluation\" of jdk bug 6446627 for a discussion of loading classes\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {\n        // so check for a primitive class name first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        // non-array\n        if (arrayDepth == 0) {\n            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return Class.forName(sb.toString(), false, classLoader);\n    }\n\n    /**\n     * Return the class name for specified \"type declaration\".\n     */\n    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {\n        // non-array\n        if (arrayDepth == 0) {\n            return elementTypeName;\n        }\n        if (elementTypeName.equals(void.class.getName())) {\n            throw new IllegalArgumentException(\"'void' must have an array depth of zero: \" + arrayDepth + '.');\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        // look for a primitive first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return sb.toString();\n    }\n\n    private static PrimitiveClassCode[] getPrimitiveClassCodes() {\n        if (primitiveClassCodes == null) {\n            primitiveClassCodes = buildPrimitiveClassCodes();\n        }\n        return primitiveClassCodes;\n    }\n\n    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {\n        PrimitiveClassCode[] result = new PrimitiveClassCode[9];\n        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);\n        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);\n        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);\n        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);\n        result[4] = new PrimitiveClassCode(INT_CODE, int.class);\n        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);\n        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);\n        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);\n        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);\n        return result;\n    }\n\n    /**\n     * Suppress default constructor, ensuring non-instantiability.\n     */\n    private ClassTools() {\n        super();\n        throw new UnsupportedOperationException();\n    }\n\n    private static class PrimitiveClassCode {\n\n        char code;\n\n        Class javaClass;\n\n        PrimitiveClassCode(char code, Class javaClass) {\n            this.code = code;\n            this.javaClass = javaClass;\n        }\n    }\n}\n", "class_id": 0, "repo": "Pandrex247/patched-src-eclipselink", "file": "utils/eclipselink.utils.workbench/utility/source/org/eclipse/persistence/tools/workbench/utility/ClassTools.java", "last_update_at": "2021-12-14T20:59:52+00:00", "original_content": "public final class ClassTools {\n\n    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];\n\n    public static final Object[] ZERO_PARAMETERS = new Object[0];\n\n    private static final String CR = StringTools.CR;\n\n    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';\n\n    public static final char ARRAY_INDICATOR = '[';\n\n    public static final char REFERENCE_CLASS_CODE = 'L';\n\n    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';\n\n    private static PrimitiveClassCode[] primitiveClassCodes;\n\n    public static final char BYTE_CODE = 'B';\n\n    public static final char CHAR_CODE = 'C';\n\n    public static final char DOUBLE_CODE = 'D';\n\n    public static final char FLOAT_CODE = 'F';\n\n    public static final char INT_CODE = 'I';\n\n    public static final char LONG_CODE = 'J';\n\n    public static final char SHORT_CODE = 'S';\n\n    public static final char BOOLEAN_CODE = 'Z';\n\n    public static final char VOID_CODE = 'V';\n\n    /**\n     * Return all the fields for the\n     * specified class, including inherited fields.\n     * Class#allFields()\n     */\n    public static Field[] allFields(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredFields(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Field[]) stack.toArray(new Field[stack.size()]);\n    }\n\n    /**\n     * Return all the methods for the\n     * specified class, including inherited methods.\n     * Class#allMethods()\n     */\n    public static Method[] allMethods(Class javaClass) {\n        Stack stack = new Stack();\n        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {\n            pushDeclaredMethods(tempClass, stack);\n        }\n        Collections.reverse(stack);\n        return (Method[]) stack.toArray(new Method[stack.size()]);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Throw an exception if the default constructor is not defined.\n     * Class#newInstance() throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        try {\n            return constructor(javaClass, parameterTypes).newInstance(parameters);\n        } catch (InstantiationException ie) {\n            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Throw an exception if the constructor is not defined.\n     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptNewInstance(javaClass, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Attempt to get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#getFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(object, fieldName).get(object);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to get a static field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException\n     */\n    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {\n        try {\n            return field(javaClass, fieldName).get(null);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument method,\n     * given the receiver and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeMethod(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Attempt to invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * If the invoked method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws Throwable, NoSuchMethodException {\n        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {\n        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Attempt to invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Throw an exception if the method is not found.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException\n     */\n    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {\n        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Attempt to set a field value, given the\n     * containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(object, fieldName).set(object, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);\n        }\n    }\n\n    /**\n     * Attempt to set a static field value, given the\n     * containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Throw an exception if the field is not defined.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException\n     */\n    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {\n        try {\n            field(javaClass, fieldName).set(null, fieldValue);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor() throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return the constructor for the specified class\n     * and formal parameter types.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {\n        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);\n        constructor.setAccessible(true);\n        return constructor;\n    }\n\n    /**\n     * Convenience method.\n     * Return the constructor for the specified class\n     * and formal parameter type.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#constructor(Class parameterType) throws NoSuchMethodException\n     */\n    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {\n        return constructor(javaClass, new Class[] { parameterType });\n    }\n\n    /**\n     * Return the declared fields for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     * Class#accessibleDeclaredFields()\n     */\n    public static Field[] declaredFields(Class javaClass) {\n        Field[] fields = javaClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n        return fields;\n    }\n\n    /**\n     * Return the declared methods for the\n     * specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     * Class#accessibleDeclaredMethods()\n     */\n    public static Method[] declaredMethods(Class javaClass) {\n        Method[] methods = javaClass.getDeclaredMethods();\n        for (int i = 0; i < methods.length; i++) {\n            methods[i].setAccessible(true);\n        }\n        return methods;\n    }\n\n    /**\n     * Return the default (zero-argument) constructor\n     * for the specified class.\n     * Set accessible to true, so we can access\n     * private/package/protected constructors.\n     * Class#defaultConstructor()\n     */\n    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {\n        return constructor(javaClass);\n    }\n\n    /**\n     * Return a field for the specified class and field name.\n     * If the class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {\n        Field field = null;\n        try {\n            field = javaClass.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return field(superclass, fieldName);\n        }\n        field.setAccessible(true);\n        return field;\n    }\n\n    /**\n     * Convenience method.\n     * Return a field for the specified object and field name.\n     * If the object's class does not directly\n     * define the field, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected fields.\n     */\n    public static Field field(Object object, String fieldName) throws NoSuchFieldException {\n        return field(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified constructor.\n     */\n    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        sb.append('.');\n        sb.append(fieldName);\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified field.\n     */\n    private static String fullyQualifiedFieldName(Object object, String fieldName) {\n        return fullyQualifiedFieldName(object.getClass(), fieldName);\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(javaClass.getName());\n        // this check allows us to use this code for constructors, where the methodName is null\n        if (methodName != null) {\n            sb.append('.');\n            sb.append(methodName);\n        }\n        sb.append('(');\n        for (int i = 0; i < parameterTypes.length; i++) {\n            sb.append(parameterTypes[i].getName());\n            if (i < parameterTypes.length - 1)\n                sb.append(\", \");\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n\n    /**\n     * Return a string representation of the specified method.\n     */\n    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {\n        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Get a field value, given the containing object and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Object#getFieldValue(String fieldName)\n     */\n    public static Object getFieldValue(Object object, String fieldName) {\n        try {\n            return attemptToGetFieldValue(object, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Get a static field value, given the containing class and field name.\n     * Return its result.\n     * Useful for accessing private, package, or protected fields.\n     * Class#getStaticFieldValue(String fieldName)\n     */\n    public static Object getStaticFieldValue(Class javaClass, String fieldName) {\n        try {\n            return attemptToGetStaticFieldValue(javaClass, fieldName);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethod(Object receiver, String methodName) {\n        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {\n        return invokeMethod(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument method, given the receiver and method name.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName) throws Throwable {\n        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a one-argument method, given the receiver,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter) throws Throwable {\n        return invokeMethodWithException(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Invoke a method, given the receiver,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Useful for invoking private, package, or protected methods.\n     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws Throwable {\n        try {\n            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            throw new RuntimeException(method + CR + ite.getTargetException(), ite);\n        }\n    }\n\n    /**\n     * Invoke the specified method with the specified parameters.\n     * Return its result.\n     * If the method throws an exception, rethrow that exception.\n     * Convert all other exceptions to RuntimeExceptions.\n     */\n    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters) throws Throwable {\n        try {\n            return method.invoke(receiver, parameters);\n        } catch (IllegalAccessException iae) {\n            throw new RuntimeException(iae + CR + method, iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause == null) {\n                throw new RuntimeException(method.toString(), ite);\n            }\n            throw cause;\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a zero-argument static method,\n     * given the class and method name.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName) {\n        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Invoke a static method, given the class,\n     * method name, parameter types, and parameters.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Invoke a static method, given the class,\n     * method name, parameter type, and parameter.\n     * Return its result.\n     * Useful for invoking private, package, or protected methods.\n     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)\n     */\n    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {\n        return invokeStaticMethod(javaClass, methodName, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Invoke the specified static method with the specified parameters.\n     * Return its result.\n     * Convert exceptions to RuntimeExceptions.\n     */\n    public static Object invokeStaticMethod(Method method, Object[] parameters) {\n        return invokeMethod(method, null, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {\n        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = null;\n        try {\n            method = javaClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (NoSuchMethodException ex) {\n            Class superclass = javaClass.getSuperclass();\n            if (superclass == null) {\n                throw ex;\n            }\n            // recurse\n            return method(superclass, methodName, parameterTypes);\n        }\n        method.setAccessible(true);\n        return method;\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(javaClass, methodName, new Class[] { parameterType });\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument method for the specified object\n     * and method name. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName) throws NoSuchMethodException {\n        return method(object.getClass(), methodName);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter types. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterTypes);\n    }\n\n    /**\n     * Convenience method.\n     * Return a method for the specified object, method name,\n     * and formal parameter type. If the object's class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {\n        return method(object.getClass(), methodName, parameterType);\n    }\n\n    /**\n     * Convenience method.\n     * Return the specified class (w/o the checked exception).\n     */\n    public static Class classForName(String className) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(className, ex);\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(Class javaClass) {\n        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className) throws ClassNotFoundException {\n        return newInstance(className, null);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * using the class's default (zero-argument) constructor.\n     * Class#newInstance()\n     */\n    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader));\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {\n        try {\n            return attemptNewInstance(javaClass, parameterTypes, parameters);\n        } catch (NoSuchMethodException nsme) {\n            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);\n        }\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {\n        return newInstance(className, parameterTypes, parameters, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter types and parameters.\n     * Class#newInstance(Class[] parameterTypes, Object[] parameters)\n     */\n    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);\n    }\n\n    /**\n     * Convenience method.\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {\n        return newInstance(javaClass, new Class[] { parameterType }, new Object[] { parameter });\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {\n        return newInstance(className, parameterType, parameter, null);\n    }\n\n    /**\n     * Return a new instance of the specified class,\n     * given the constructor parameter type and parameter.\n     * Class#newInstance(Class parameterType, Object parameter)\n     */\n    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {\n        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);\n    }\n\n    /**\n     * Push the declared fields for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredFields(Class javaClass, Stack stack) {\n        Field[] fields = declaredFields(javaClass);\n        for (int i = fields.length - 1; i >= 0; i--) {\n            stack.push(fields[i]);\n        }\n    }\n\n    /**\n     * Push the declared methods for the specified class\n     * onto the top of the stack.\n     */\n    private static void pushDeclaredMethods(Class javaClass, Stack stack) {\n        Method[] methods = declaredMethods(javaClass);\n        for (int i = methods.length - 1; i >= 0; i--) {\n            stack.push(methods[i]);\n        }\n    }\n\n    /**\n     * Set a field value, given the containing object, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Object#setFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetFieldValue(object, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Set a static field value, given the containing class, field name, and new field value.\n     * Useful for accessing private, package, or protected fields.\n     * Class#setStaticFieldValue(String fieldName, Object fieldValue)\n     */\n    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {\n        try {\n            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);\n        } catch (NoSuchFieldException nsfe) {\n            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);\n        }\n    }\n\n    /**\n     * Return the short name of the object's class.\n     * Class#getShortName()\n     */\n    public static String shortClassNameForObject(Object object) {\n        return shortNameFor(object.getClass());\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the short name of the class (e.g. \"Object\").\n     * Class#getShortName()\n     */\n    public static String shortNameFor(Class javaClass) {\n        return shortNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the nested name of the object's class.\n     * Class#getNestedName()\n     */\n    public static String nestedClassNameForObject(Object object) {\n        return nestedNameFor(object.getClass());\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameForClassNamed(String className) {\n        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);\n    }\n\n    /**\n     * Return the nested name of the class (e.g. \"Entry\").\n     * Class#getNestedName()\n     */\n    public static String nestedNameFor(Class javaClass) {\n        return nestedNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the \"toString()\" name of the object's class.\n     */\n    public static String toStringClassNameForObject(Object object) {\n        return toStringNameFor(object.getClass());\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     * \"Member\" classes will return only the final name:\n     *     \"com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass\"\n     *         => \"NestedMemberClass\"\n     * \"Local\" and \"anonymous\" classes will still return the embedded '$'s:\n     *     \"com.foo.bar.TopLevelClass$1LocalClass\"\n     *         => \"TopLevelClass$1LocalClass\"\n     *     \"com.foo.bar.TopLevelClass$1\"\n     *         => \"TopLevelClass$1\"\n     */\n    public static String toStringNameForClassNamed(String className) {\n        return classNamedIsMember(className) ? className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1) : className.substring(className.lastIndexOf('.') + 1);\n    }\n\n    /**\n     * Return the \"toString()\" name of the class.\n     */\n    public static String toStringNameFor(Class javaClass) {\n        return toStringNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameFor(Class javaClass) {\n        return packageNameForClassNamed(javaClass.getName());\n    }\n\n    /**\n     * Return the package name of the class (e.g. \"java.lang\").\n     * Class#getPackageName()\n     */\n    public static String packageNameForClassNamed(String className) {\n        int lastPeriod = className.lastIndexOf('.');\n        if (lastPeriod == -1) {\n            return \"\";\n        }\n        return className.substring(0, lastPeriod);\n    }\n\n    /**\n     * Return the short name of the class,\n     * followed by its package name (e.g. \"Object (java.lang)\").\n     * Class#getShortNameWithPackage()\n     */\n    public static String shortNameWithPackage(Class javaClass) {\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(shortNameFor(javaClass));\n        if (!javaClass.isPrimitive()) {\n            sb.append(\" (\");\n            sb.append(packageNameFor(javaClass));\n            sb.append(')');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method.\n     * Return a zero-argument, static method for the specified class\n     * and method name. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);\n    }\n\n    /**\n     * Return a static method for the specified class, method name,\n     * and formal parameter types. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {\n        Method method = method(javaClass, methodName, parameterTypes);\n        if (Modifier.isStatic(method.getModifiers())) {\n            return method;\n        }\n        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));\n    }\n\n    /**\n     * Convenience method.\n     * Return a static method for the specified class, method name,\n     * and formal parameter type. If the class does not directly\n     * implement the method, look for it in the class's superclasses.\n     * Set accessible to true, so we can access\n     * private/package/protected methods.\n     */\n    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {\n        return staticMethod(javaClass, methodName, new Class[] { parameterTypes });\n    }\n\n    /**\n     * Return whether the specified class can be \"declared\" in code;\n     * i.e. it is either a \"top-level\" class or a \"member\" class, but it\n     * is not an \"array\" class. This method rolls together all the checks\n     * from the other methods for a bit of a performance tweak.\n     * Class#isDeclarable()\n     */\n    public static boolean classNamedIsDeclarable(String className) {\n        if (className.charAt(0) == ARRAY_INDICATOR) {\n            // it is an \"array\" class\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            // it is a \"top-level\" class\n            return true;\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"top-level\" class,\n     * as opposed to a \"member\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name does NOT contain a '$': \"TopLevelClass\").\n     * Class#isTopLevel()\n     */\n    public static boolean classNamedIsTopLevel(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;\n    }\n\n    /**\n     * Return whether the specified class is a \"member\" class,\n     * as opposed to a \"top-level\", \"local\", or \"anonymous\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name contains at least one '$' and all the names between\n     * each '$' are legal class names:\n     * \"TopLevelClass$MemberClass$NestedMemberClass\").\n     * Class#isMember()\n     */\n    public static boolean classNamedIsMember(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (index == -1) {\n            // it is a \"top-level\" class\n            return false;\n        }\n        do {\n            // the character immediately after each dollar sign cannot be a digit\n            index++;\n            if (Character.isDigit(className.charAt(index))) {\n                return false;\n            }\n            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);\n        } while (index != -1);\n        return true;\n    }\n\n    /**\n     * Return whether the specified class is a \"local\" class,\n     * as opposed to a \"top-level\", \"member\", or \"anonymous\" class,\n     * using the standard jdk (or Eclipse) naming conventions.\n     * In the jdk, the class name ends with '$nnnXXX' where the '$' is\n     * followed by a series of numeric digits which are followed by the\n     * local class name: \"TopLevelClass$1LocalClass\".\n     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is\n     * followed by a series of numeric digits which are separated from\n     * the local class name by another '$': \"TopLevelClass$1$LocalClass\".\n     * Class#isLocal()\n     */\n    public static boolean classNamedIsLocal(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        if (!Character.isDigit(className.charAt(dollar + 1))) {\n            return false;\n        }\n        for (int i = dollar + 2; i < className.length(); i++) {\n            if (Character.isJavaIdentifierStart(className.charAt(i))) {\n                return true;\n            }\n        }\n        // all the characters past the $ are digits (anonymous)\n        return false;\n    }\n\n    /**\n     * Return whether the specified class is an \"anonymous\" class,\n     * as opposed to a \"top-level\", \"member\", or \"local\" class,\n     * using the standard jdk naming conventions (i.e. the class\n     * name ends with '$nnn' where all the characters past the\n     * last '$' are numeric digits: \"TopLevelClass$1\").\n     * Class#isAnonymous()\n     */\n    public static boolean classNamedIsAnonymous(String className) {\n        if (classNamedIsArray(className)) {\n            return false;\n        }\n        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);\n        if (dollar == -1) {\n            return false;\n        }\n        int start = dollar + 1;\n        for (int i = className.length(); i-- > start; ) {\n            if (!Character.isDigit(className.charAt(i))) {\n                return false;\n            }\n        }\n        // all the characters past the $ are digits\n        return true;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthFor(Class javaClass) {\n        int depth = 0;\n        while (javaClass.isArray()) {\n            depth++;\n            javaClass = javaClass.getComponentType();\n        }\n        return depth;\n    }\n\n    /**\n     * Return the \"array depth\" of the specified object.\n     * The depth is the number of dimensions for an array.\n     * Non-arrays have a depth of zero.\n     */\n    public static int arrayDepthForObject(Object object) {\n        return arrayDepthFor(object.getClass());\n    }\n\n    /**\n     * Return the \"array depth\" of the specified class.\n     * The depth is the number of dimensions for an array type.\n     * Non-array types have a depth of zero.\n     * @see java.lang.Class#getName()\n     * Class#getArrayDepth()\n     */\n    public static int arrayDepthForClassNamed(String className) {\n        int depth = 0;\n        while (className.charAt(depth) == ARRAY_INDICATOR) {\n            depth++;\n        }\n        return depth;\n    }\n\n    /**\n     * Return whether the specified class is an array type.\n     * @see java.lang.Class#getName()\n     */\n    public static boolean classNamedIsArray(String className) {\n        return className.charAt(0) == ARRAY_INDICATOR;\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * A non-array type simply returns itself.\n     * Class#getElementType()\n     */\n    public static Class elementTypeFor(Class javaClass) {\n        while (javaClass.isArray()) {\n            javaClass = javaClass.getComponentType();\n        }\n        return javaClass;\n    }\n\n    /**\n     * Return the \"element type\" of the specified object.\n     * The element type is the base type held by an array.\n     * A non-array simply returns its class.\n     */\n    public static Class elementTypeForObject(Object object) {\n        return elementTypeFor(object.getClass());\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * Class#getElementType()\n     */\n    public static String elementTypeNameFor(Class javaClass) {\n        return elementTypeFor(javaClass).getName();\n    }\n\n    /**\n     * Return the \"element type\" of the specified class.\n     * The element type is the base type held by an array type.\n     * Non-array types simply return themselves.\n     * @see java.lang.Class#getName()\n     * Class#getElementType()\n     */\n    public static String elementTypeNameForClassNamed(String className) {\n        int depth = arrayDepthForClassNamed(className);\n        if (depth == 0) {\n            // the name is in the form: \"java.lang.Object\" or \"int\"\n            return className;\n        }\n        int last = className.length() - 1;\n        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {\n            // drop the trailing ';'\n            return className.substring(depth + 1, last);\n        }\n        // the name is in the form: \"[[[I\"\n        return classNameForCode(className.charAt(last));\n    }\n\n    /**\n     * Return whether the specified class is a \"reference\"\n     * class (i.e. not void or one of the primitives).\n     */\n    public static boolean classNamedIsReference(String className) {\n        return !classNamedIsNonReference(className);\n    }\n\n    /**\n     * Return whether the specified class is a \"non-reference\"\n     * class (i.e. void or one of the primitives).\n     */\n    public static boolean classNamedIsNonReference(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(char classCode) {\n        return classForCode(classCode).getName();\n    }\n\n    /**\n     * Return the class name for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static String classNameForCode(int classCode) {\n        return classNameForCode((char) classCode);\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(char classCode) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].code == classCode) {\n                return codes[i].javaClass;\n            }\n        }\n        throw new IllegalArgumentException(String.valueOf(classCode));\n    }\n\n    /**\n     * Return the class for the specified class code.\n     * @see java.lang.Class#getName()\n     */\n    public static Class classForCode(int classCode) {\n        return classForCode((char) classCode);\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClass(Class javaClass) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass == javaClass) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(javaClass.getName());\n    }\n\n    /**\n     * Return the class code for the specified class.\n     * @see java.lang.Class.getName()\n     */\n    public static char codeForClassNamed(String className) {\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(className)) {\n                return codes[i].code;\n            }\n        }\n        throw new IllegalArgumentException(className);\n    }\n\n    /**\n     * Return the class for specified \"type declaration\".\n     */\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {\n        return classForTypeDeclaration(elementTypeName, arrayDepth, null);\n    }\n\n    // see the \"Evaluation\" of jdk bug 6446627 for a discussion of loading classes\n    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {\n        // so check for a primitive class name first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        // non-array\n        if (arrayDepth == 0) {\n            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return Class.forName(sb.toString(), false, classLoader);\n    }\n\n    /**\n     * Return the class name for specified \"type declaration\".\n     */\n    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {\n        // non-array\n        if (arrayDepth == 0) {\n            return elementTypeName;\n        }\n        if (elementTypeName.equals(void.class.getName())) {\n            throw new IllegalArgumentException(\"'void' must have an array depth of zero: \" + arrayDepth + '.');\n        }\n        // array\n        StringBuffer sb = new StringBuffer(100);\n        for (int i = arrayDepth; i-- > 0; ) {\n            sb.append(ARRAY_INDICATOR);\n        }\n        // look for a primitive first\n        PrimitiveClassCode[] codes = getPrimitiveClassCodes();\n        PrimitiveClassCode pcc = null;\n        for (int i = codes.length; i-- > 0; ) {\n            if (codes[i].javaClass.getName().equals(elementTypeName)) {\n                pcc = codes[i];\n                break;\n            }\n        }\n        if (pcc == null) {\n            sb.append(REFERENCE_CLASS_CODE);\n            sb.append(elementTypeName);\n            sb.append(REFERENCE_CLASS_NAME_DELIMITER);\n        } else {\n            sb.append(pcc.code);\n        }\n        return sb.toString();\n    }\n\n    private static PrimitiveClassCode[] getPrimitiveClassCodes() {\n        if (primitiveClassCodes == null) {\n            primitiveClassCodes = buildPrimitiveClassCodes();\n        }\n        return primitiveClassCodes;\n    }\n\n    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {\n        PrimitiveClassCode[] result = new PrimitiveClassCode[9];\n        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);\n        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);\n        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);\n        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);\n        result[4] = new PrimitiveClassCode(INT_CODE, int.class);\n        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);\n        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);\n        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);\n        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);\n        return result;\n    }\n\n    /**\n     * Suppress default constructor, ensuring non-instantiability.\n     */\n    private ClassTools() {\n        super();\n        throw new UnsupportedOperationException();\n    }\n\n    private static class PrimitiveClassCode {\n\n        char code;\n\n        Class javaClass;\n\n        PrimitiveClassCode(char code, Class javaClass) {\n            this.code = code;\n            this.javaClass = javaClass;\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "7a7b8318fe1ee8708edc850e3756a533331a9ffb", "ext": "java", "lang": "Java", "content": "public class ConsumerAuthInterceptor implements HandlerInterceptor {\n\n    private WeChatUserRepository weChatUserRepository;\n\n    @Autowired\n    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {\n        this.weChatUserRepository = weChatUserRepository;\n    }\n\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {\n        this.jwtTokenUtil = jwtTokenUtil;\n    }\n\n    @Override\n    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object) throws NullTokenException, UserNotExistException {\n        // check annotation\n        if (!(object instanceof HandlerMethod)) {\n            return true;\n        }\n        final HandlerMethod handlerMethod = (HandlerMethod) object;\n        final Method method = handlerMethod.getMethod();\n        // request\n        if (method.isAnnotationPresent(WeChatUser.class)) {\n            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);\n            if (!weChatUser.required()) {\n                return true;\n            }\n            // get token\n            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);\n            if (token == null || token.replace(\" \", \"\").equals(\"\")) {\n                throw new NullTokenException(\"Null token.\");\n            }\n            // verify user exist in database\n            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);\n            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);\n            if (wechatUserDoList.isEmpty()) {\n                throw new UserNotExistException();\n            }\n        }\n        return true;\n    }\n}\n", "class_id": 0, "repo": "Kenhuey/freethru", "file": "src/main/java/com/mythsart/freethru/framework/common/interceptor/ConsumerAuthInterceptor.java", "last_update_at": "2021-01-08T18:53:12+00:00", "original_content": "public class ConsumerAuthInterceptor implements HandlerInterceptor {\n\n    private WeChatUserRepository weChatUserRepository;\n\n    @Autowired\n    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {\n        this.weChatUserRepository = weChatUserRepository;\n    }\n\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {\n        this.jwtTokenUtil = jwtTokenUtil;\n    }\n\n    @Override\n    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object) throws NullTokenException, UserNotExistException {\n        // check annotation\n        if (!(object instanceof HandlerMethod)) {\n            return true;\n        }\n        final HandlerMethod handlerMethod = (HandlerMethod) object;\n        final Method method = handlerMethod.getMethod();\n        // request\n        if (method.isAnnotationPresent(WeChatUser.class)) {\n            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);\n            if (!weChatUser.required()) {\n                return true;\n            }\n            // get token\n            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);\n            if (token == null || token.replace(\" \", \"\").equals(\"\")) {\n                throw new NullTokenException(\"Null token.\");\n            }\n            // verify user exist in database\n            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);\n            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);\n            if (wechatUserDoList.isEmpty()) {\n                throw new UserNotExistException();\n            }\n        }\n        return true;\n    }\n}\n", "refactored": false}
{"hexsha": "fa6beaa76b8c1e5865d612bbe2c25921a6e42fb2", "ext": "java", "lang": "Java", "content": "public class S3ArtifactContentProvider implements ArtifactContentProvider {\n\n    private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());\n\n    private final ServerPaths myServerPaths;\n\n    public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {\n        myServerPaths = serverPaths;\n    }\n\n    @NotNull\n    @Override\n    public String getType() {\n        return S3Constants.S3_STORAGE_TYPE;\n    }\n\n    @NotNull\n    @Override\n    public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {\n        final Map<String, String> params;\n        final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();\n        if (artifactData == null) {\n            throw new IOException(\"Invalid artifact data: S3 object path property is not set\");\n        }\n        final String artifactPath = artifactData.getPath();\n        try {\n            params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());\n        } catch (IllegalArgumentException e) {\n            throw new IOException(\"Failed to get artifact \" + artifactPath + \" content: Invalid storage settings \" + e.getMessage(), e);\n        }\n        final String bucketName = S3Util.getBucketName(params);\n        final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;\n        try {\n            return S3Util.withS3Client(ParamUtil.putSslValues(myServerPaths, params), client -> client.getObject(bucketName, key).getObjectContent());\n        } catch (Throwable t) {\n            final AWSException awsException = new AWSException(t);\n            final String details = awsException.getDetails();\n            if (StringUtil.isNotEmpty(details)) {\n                final String message = awsException.getMessage() + details;\n                LOG.warn(message);\n            }\n            throw new IOException(String.format(\"Failed to get artifact '%s' content in bucket '%s': %s\", artifactPath, bucketName, awsException.getMessage()), awsException);\n        }\n    }\n}\n", "class_id": 0, "repo": "ChildOfJustice/teamcity-s3-artifact-storage-plugin", "file": "s3-artifact-storage-server/src/main/java/jetbrains/buildServer/artifacts/s3/S3ArtifactContentProvider.java", "last_update_at": "2021-11-08T09:50:20+00:00", "original_content": "public class S3ArtifactContentProvider implements ArtifactContentProvider {\n\n    private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());\n\n    private final ServerPaths myServerPaths;\n\n    public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {\n        myServerPaths = serverPaths;\n    }\n\n    @NotNull\n    @Override\n    public String getType() {\n        return S3Constants.S3_STORAGE_TYPE;\n    }\n\n    @NotNull\n    @Override\n    public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {\n        final Map<String, String> params;\n        final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();\n        if (artifactData == null) {\n            throw new IOException(\"Invalid artifact data: S3 object path property is not set\");\n        }\n        final String artifactPath = artifactData.getPath();\n        try {\n            params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());\n        } catch (IllegalArgumentException e) {\n            throw new IOException(\"Failed to get artifact \" + artifactPath + \" content: Invalid storage settings \" + e.getMessage(), e);\n        }\n        final String bucketName = S3Util.getBucketName(params);\n        final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;\n        try {\n            return S3Util.withS3Client(ParamUtil.putSslValues(myServerPaths, params), client -> client.getObject(bucketName, key).getObjectContent());\n        } catch (Throwable t) {\n            final AWSException awsException = new AWSException(t);\n            final String details = awsException.getDetails();\n            if (StringUtil.isNotEmpty(details)) {\n                final String message = awsException.getMessage() + details;\n                LOG.warn(message);\n            }\n            throw new IOException(String.format(\"Failed to get artifact '%s' content in bucket '%s': %s\", artifactPath, bucketName, awsException.getMessage()), awsException);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "b73d67eeb7296ad974a93d8acc1f52b681a08a15", "ext": "java", "lang": "Java", "content": "public class AnnotationTest extends RecognationExtended {\n\n    @Test\n    public void testSamePackage() {\n        boolean annotationFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.a.SamePackage\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.a.SamePackage\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(5, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n    }\n\n    @Test\n    public void testOtherPackageA() {\n        boolean annotationFound = false;\n        boolean importFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(7, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            } else if (dependency.type.equals(\"Import\")) {\n                importFound = true;\n                assertEquals(3, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n        assertEquals(true, importFound);\n    }\n\n    @Test\n    public void testOtherPackageB() {\n        boolean annotationFound = false;\n        boolean importFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(7, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            } else if (dependency.type.equals(\"Import\")) {\n                importFound = true;\n                assertEquals(3, dependency.lineNumber);\n                assertEquals(\"annotation.a\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n        assertEquals(true, importFound);\n    }\n\n    @Test\n    public void testOtherPackageC() {\n        boolean annotationFound = false;\n        boolean importFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(7, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            } else if (dependency.type.equals(\"Import\")) {\n                importFound = true;\n                assertEquals(3, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n        assertEquals(true, importFound);\n    }\n}\n", "class_id": 0, "repo": "senkz/HUSACCT", "file": "src/husaccttest/analyse/java/recognition/AnnotationTest.java", "last_update_at": "2021-02-02T12:58:55+00:00", "original_content": "public class AnnotationTest extends RecognationExtended {\n\n    @Test\n    public void testSamePackage() {\n        boolean annotationFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.a.SamePackage\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.a.SamePackage\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(5, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n    }\n\n    @Test\n    public void testOtherPackageA() {\n        boolean annotationFound = false;\n        boolean importFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageA\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(7, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            } else if (dependency.type.equals(\"Import\")) {\n                importFound = true;\n                assertEquals(3, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n        assertEquals(true, importFound);\n    }\n\n    @Test\n    public void testOtherPackageB() {\n        boolean annotationFound = false;\n        boolean importFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageB\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(7, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            } else if (dependency.type.equals(\"Import\")) {\n                importFound = true;\n                assertEquals(3, dependency.lineNumber);\n                assertEquals(\"annotation.a\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n        assertEquals(true, importFound);\n    }\n\n    @Test\n    public void testOtherPackageC() {\n        boolean annotationFound = false;\n        boolean importFound = false;\n        //\t\tDependencyDTO[] dependencies = service.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n        DependencyDTO[] dependencies = super.getDependenciesFrom(\"annotation.b.OtherPackageC\");\n        for (DependencyDTO dependency : dependencies) {\n            if (dependency.type.equals(\"Annotation\")) {\n                annotationFound = true;\n                assertEquals(7, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            } else if (dependency.type.equals(\"Import\")) {\n                importFound = true;\n                assertEquals(3, dependency.lineNumber);\n                assertEquals(\"annotation.a.AnnotationInterface\", dependency.to);\n            }\n        }\n        assertEquals(true, annotationFound);\n        assertEquals(true, importFound);\n    }\n}\n", "refactored": false}
{"hexsha": "ddca8f972e4ef486dd342e78f4884eef0e4fa00e", "ext": "java", "lang": "Java", "content": "@lombok.extern.slf4j.Slf4j\npublic abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C> extends ClientBuilderBase<B, C> {\n\n    public RegionalClientBuilder(Service service) {\n        super(service);\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param region region\n     * @return this builder\n     */\n    public B region(com.oracle.bmc.Region region) {\n        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);\n        if (endpoint.isPresent()) {\n            endpoint(endpoint.get());\n        } else {\n            throw new IllegalArgumentException(\"Endpoint for \" + service + \" is not known in region \" + region);\n        }\n        return (B) this;\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param regionId region\n     * @return this builder\n     */\n    public B region(String regionId) {\n        regionId = regionId.toLowerCase(Locale.ENGLISH);\n        try {\n            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);\n            return region(region);\n        } catch (IllegalArgumentException e) {\n            LOG.info(\"Unknown regionId '{}', falling back to default endpoint format\", regionId);\n            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);\n            return endpoint(endpoint);\n        }\n    }\n}\n", "class_id": 0, "repo": "skichiku/oci-java-sdk", "file": "bmc-common/src/main/java/com/oracle/bmc/common/RegionalClientBuilder.java", "last_update_at": "2021-04-09T18:17:14+00:00", "original_content": "@lombok.extern.slf4j.Slf4j\npublic abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C> extends ClientBuilderBase<B, C> {\n\n    public RegionalClientBuilder(Service service) {\n        super(service);\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param region region\n     * @return this builder\n     */\n    public B region(com.oracle.bmc.Region region) {\n        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);\n        if (endpoint.isPresent()) {\n            endpoint(endpoint.get());\n        } else {\n            throw new IllegalArgumentException(\"Endpoint for \" + service + \" is not known in region \" + region);\n        }\n        return (B) this;\n    }\n\n    /**\n     * Set the region for the client to be created.\n     * @param regionId region\n     * @return this builder\n     */\n    public B region(String regionId) {\n        regionId = regionId.toLowerCase(Locale.ENGLISH);\n        try {\n            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);\n            return region(region);\n        } catch (IllegalArgumentException e) {\n            LOG.info(\"Unknown regionId '{}', falling back to default endpoint format\", regionId);\n            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);\n            return endpoint(endpoint);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "681fd5b93140fff33f986615cacd9efcac085276", "ext": "java", "lang": "Java", "content": "public class DecisionMaker extends Thread {\n\n    // An array that\n    private ArrayList<Integer> preferredPeers = new ArrayList<Integer>();\n\n    // peerInfos.\n    private int optUnchockedPeer = -1;\n\n    private ArrayList<Integer> previousRequestList = new ArrayList<>();\n\n    private ArrayList<Integer> requestingList = new ArrayList<>();\n\n    /**\n     * Update preferred peers\n     */\n    private class updatePreferredPeers extends TimerTask {\n\n        public void run() {\n            synchronized (preferredPeers) {\n                if (PeerProcess.peers.size() > 0) {\n                    preferredPeers.clear();\n                }\n                if (PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {\n                    ArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();\n                    Collections.shuffle(interestedPeers);\n                    for (int peerId : interestedPeers) {\n                        if (preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n                            preferredPeers.add(peerId);\n                        }\n                    }\n                } else {\n                    ArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();\n                    for (int peerId : PeerProcess.getInterestedPeers()) {\n                        peerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));\n                    }\n                    peerId_ChunkCounts.sort(null);\n                    for (PeerId_ChunkCount tuple : peerId_ChunkCounts) {\n                        if (preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n                            preferredPeers.add(tuple.peerId);\n                        }\n                    }\n                    for (DynamicPeerInfo p : PeerProcess.peers) {\n                        p.resetChunkCount();\n                    }\n                }\n                // iterate over all peers to check and send proper choke/unchoke msgs\n                for (DynamicPeerInfo p : PeerProcess.peers) {\n                    if (p.isConnected) {\n                        if (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {\n                            // PeerProcess.write(\"Unchoking peer \" + p.peerId);\n                            PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));\n                            p.isLocalPeerChockingRemotePeer = false;\n                            continue;\n                        }\n                        if (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {\n                            // PeerProcess.write(\"Choking peer \" + p.peerId);\n                            PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));\n                            p.isLocalPeerChockingRemotePeer = true;\n                        }\n                    }\n                }\n                PeerProcess.write(\"has the preferred neighbors \" + preferredPeers);\n            }\n        }\n    }\n\n    /**\n     * Optimistically unchoke a peer\n     */\n    private class optimisiticUnchoke extends TimerTask {\n\n        public void run() {\n            synchronized (preferredPeers) {\n                try {\n                    PeerProcess.checkTermination();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                ArrayList<Integer> chockedList = new ArrayList<>();\n                for (DynamicPeerInfo p : PeerProcess.peers) {\n                    if (p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {\n                        chockedList.add(p.index);\n                    }\n                }\n                if (!chockedList.isEmpty()) {\n                    int index = (int) (Math.random() * chockedList.size());\n                    optUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;\n                    PeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));\n                    PeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;\n                    PeerProcess.write(\"has the optimistically unchoked neighbor \" + optUnchockedPeer);\n                }\n            }\n        }\n    }\n\n    private class requestTimeout extends TimerTask {\n\n        public void run() {\n            synchronized (requestingList) {\n                int i = 0;\n                while (i < previousRequestList.size()) try {\n                    if (requestingList.contains(previousRequestList.get(i))) {\n                        requestingList.remove(Integer.valueOf(previousRequestList.get(i)));\n                    }\n                } finally {\n                    i++;\n                }\n                previousRequestList = requestingList;\n            }\n        }\n    }\n\n    public void removeRequest(int pieceIndex) {\n        synchronized (requestingList) {\n            requestingList.remove(Integer.valueOf(pieceIndex));\n        }\n    }\n\n    public boolean addRequest(int pieceIndex) {\n        synchronized (requestingList) {\n            if (requestingList.contains(pieceIndex)) {\n                return false;\n            } else {\n                requestingList.add(pieceIndex);\n                return true;\n            }\n        }\n    }\n\n    /**\n     * Main method of decision maker as a thread.\n     */\n    @Override\n    public void run() {\n        // create a new Timer\n        Timer timerUpdate = new Timer();\n        Timer timerOptUpdate = new Timer();\n        Timer timerRequestTimeout = new Timer();\n        TimerTask task1 = new optimisiticUnchoke();\n        TimerTask task2 = new updatePreferredPeers();\n        TimerTask task3 = new requestTimeout();\n        timerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);\n        timerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);\n        timerRequestTimeout.schedule(task3, 0, 10000);\n    }\n}\n", "class_id": 0, "repo": "rajatraiuf/BitTorrent-Java-CN5106C", "file": "src/cnt5106C/DecisionMaker.java", "last_update_at": "2021-01-18T18:08:54+00:00", "original_content": "public class DecisionMaker extends Thread {\n\n    // An array that\n    private ArrayList<Integer> preferredPeers = new ArrayList<Integer>();\n\n    // peerInfos.\n    private int optUnchockedPeer = -1;\n\n    private ArrayList<Integer> previousRequestList = new ArrayList<>();\n\n    private ArrayList<Integer> requestingList = new ArrayList<>();\n\n    /**\n     * Update preferred peers\n     */\n    private class updatePreferredPeers extends TimerTask {\n\n        public void run() {\n            synchronized (preferredPeers) {\n                if (PeerProcess.peers.size() > 0) {\n                    preferredPeers.clear();\n                }\n                if (PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {\n                    ArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();\n                    Collections.shuffle(interestedPeers);\n                    for (int peerId : interestedPeers) {\n                        if (preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n                            preferredPeers.add(peerId);\n                        }\n                    }\n                } else {\n                    ArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();\n                    for (int peerId : PeerProcess.getInterestedPeers()) {\n                        peerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));\n                    }\n                    peerId_ChunkCounts.sort(null);\n                    for (PeerId_ChunkCount tuple : peerId_ChunkCounts) {\n                        if (preferredPeers.size() < PeerProcess.preferredNeighborsCount) {\n                            preferredPeers.add(tuple.peerId);\n                        }\n                    }\n                    for (DynamicPeerInfo p : PeerProcess.peers) {\n                        p.resetChunkCount();\n                    }\n                }\n                // iterate over all peers to check and send proper choke/unchoke msgs\n                for (DynamicPeerInfo p : PeerProcess.peers) {\n                    if (p.isConnected) {\n                        if (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {\n                            // PeerProcess.write(\"Unchoking peer \" + p.peerId);\n                            PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));\n                            p.isLocalPeerChockingRemotePeer = false;\n                            continue;\n                        }\n                        if (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {\n                            // PeerProcess.write(\"Choking peer \" + p.peerId);\n                            PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));\n                            p.isLocalPeerChockingRemotePeer = true;\n                        }\n                    }\n                }\n                PeerProcess.write(\"has the preferred neighbors \" + preferredPeers);\n            }\n        }\n    }\n\n    /**\n     * Optimistically unchoke a peer\n     */\n    private class optimisiticUnchoke extends TimerTask {\n\n        public void run() {\n            synchronized (preferredPeers) {\n                try {\n                    PeerProcess.checkTermination();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                ArrayList<Integer> chockedList = new ArrayList<>();\n                for (DynamicPeerInfo p : PeerProcess.peers) {\n                    if (p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {\n                        chockedList.add(p.index);\n                    }\n                }\n                if (!chockedList.isEmpty()) {\n                    int index = (int) (Math.random() * chockedList.size());\n                    optUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;\n                    PeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));\n                    PeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;\n                    PeerProcess.write(\"has the optimistically unchoked neighbor \" + optUnchockedPeer);\n                }\n            }\n        }\n    }\n\n    private class requestTimeout extends TimerTask {\n\n        public void run() {\n            synchronized (requestingList) {\n                for (int i = 0; i < previousRequestList.size(); i++) {\n                    if (requestingList.contains(previousRequestList.get(i))) {\n                        requestingList.remove(Integer.valueOf(previousRequestList.get(i)));\n                    }\n                }\n                previousRequestList = requestingList;\n            }\n        }\n    }\n\n    public void removeRequest(int pieceIndex) {\n        synchronized (requestingList) {\n            requestingList.remove(Integer.valueOf(pieceIndex));\n        }\n    }\n\n    public boolean addRequest(int pieceIndex) {\n        synchronized (requestingList) {\n            if (requestingList.contains(pieceIndex)) {\n                return false;\n            } else {\n                requestingList.add(pieceIndex);\n                return true;\n            }\n        }\n    }\n\n    /**\n     * Main method of decision maker as a thread.\n     */\n    @Override\n    public void run() {\n        // create a new Timer\n        Timer timerUpdate = new Timer();\n        Timer timerOptUpdate = new Timer();\n        Timer timerRequestTimeout = new Timer();\n        TimerTask task1 = new optimisiticUnchoke();\n        TimerTask task2 = new updatePreferredPeers();\n        TimerTask task3 = new requestTimeout();\n        timerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);\n        timerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);\n        timerRequestTimeout.schedule(task3, 0, 10000);\n    }\n}\n", "refactored": true}
{"hexsha": "4998e4e78f75aacee3fa24faf1e1124b33ea528c", "ext": "java", "lang": "Java", "content": "public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {\n\n    public TypeBinding resolveType(BlockScope scope) {\n        this.argumentTypes = Binding.NO_PARAMETERS;\n        if (this.arguments != null) {\n            int argsLength = this.arguments.length;\n            int length = this.arguments.length;\n            this.argumentTypes = new TypeBinding[length];\n            int a = argsLength;\n            while (--a >= 0) try {\n                this.argumentTypes[a] = this.arguments[a].resolveType(scope);\n            } finally {\n            }\n        }\n        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;\n        if (this.enclosingInstance != null) {\n            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);\n            if (enclosingType == null) {\n                // Eg.: new Test<>().new Test<>(#cursor#\n                if (this.enclosingInstance instanceof AllocationExpression) {\n                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;\n                    if (enclosingInstanceType != null) {\n                        enclosingType = enclosingInstanceType.resolvedType;\n                    }\n                }\n            }\n            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {\n                throw new CompletionNodeFound();\n            }\n            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n            if (// handle the anonymous class definition case\n            this.resolvedType.isInterface())\n                this.resolvedType = scope.getJavaLangObject();\n        } else {\n            this.resolvedType = this.type.resolveType(scope, /* check bounds*/\n            true);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n        }\n        throw new CompletionNodeFound(this, this.resolvedType, scope);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        if (this.enclosingInstance == null)\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnAllocationExpression:\");\n        else\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnQualifiedAllocationExpression:\");\n        return super.printExpression(indent, output).append('>');\n    }\n}\n", "class_id": 0, "repo": "masud-technope/ACER-Replication-Package-ASE2017", "file": "corpus/class/eclipse.jdt.core/176.java", "last_update_at": "2021-11-29T08:28:07+00:00", "original_content": "public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {\n\n    public TypeBinding resolveType(BlockScope scope) {\n        this.argumentTypes = Binding.NO_PARAMETERS;\n        if (this.arguments != null) {\n            int argsLength = this.arguments.length;\n            int length = this.arguments.length;\n            this.argumentTypes = new TypeBinding[length];\n            for (int a = argsLength; --a >= 0; ) {\n                this.argumentTypes[a] = this.arguments[a].resolveType(scope);\n            }\n        }\n        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;\n        if (this.enclosingInstance != null) {\n            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);\n            if (enclosingType == null) {\n                // Eg.: new Test<>().new Test<>(#cursor#\n                if (this.enclosingInstance instanceof AllocationExpression) {\n                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;\n                    if (enclosingInstanceType != null) {\n                        enclosingType = enclosingInstanceType.resolvedType;\n                    }\n                }\n            }\n            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {\n                throw new CompletionNodeFound();\n            }\n            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n            if (// handle the anonymous class definition case\n            this.resolvedType.isInterface())\n                this.resolvedType = scope.getJavaLangObject();\n        } else {\n            this.resolvedType = this.type.resolveType(scope, /* check bounds*/\n            true);\n            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {\n                TypeBinding[] inferredTypes = inferElidedTypes(scope);\n                if (inferredTypes != null) {\n                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());\n                } else {\n                    // inference failed. Resolved type will be of the form Test<>\n                    this.bits |= ASTNode.IsDiamond;\n                }\n            }\n            if (!(this.resolvedType instanceof ReferenceBinding))\n                // no need to continue if its an array or base type\n                throw new CompletionNodeFound();\n        }\n        throw new CompletionNodeFound(this, this.resolvedType, scope);\n    }\n\n    public StringBuffer printExpression(int indent, StringBuffer output) {\n        if (this.enclosingInstance == null)\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnAllocationExpression:\");\n        else\n            //$NON-NLS-1$\n            output.append(\"<CompleteOnQualifiedAllocationExpression:\");\n        return super.printExpression(indent, output).append('>');\n    }\n}\n", "refactored": true}
{"hexsha": "6b004f72007f03d3e280511f6add5590dab3610a", "ext": "java", "lang": "Java", "content": "public class Configuration implements Comparable<Configuration> {\n\n    /**\n     * Prefix for instructions for the configurator.\n     */\n    public static final String CONFIGURATOR_PREFIX = \":configurator:\";\n\n    /**\n     * Prefix for special properties which are not configuration properties.\n     */\n    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + \"feature-\";\n\n    /**\n     * This optional configuration property stores the artifact id (mvn id) of the\n     * bundle this configuration belongs to.\n     */\n    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + \"service.bundleLocation\";\n\n    /**\n     * This optional configuration property stores the artifact ids (array) of the\n     * features this configuration has been specified.\n     * @since 1.6\n     */\n    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + \"origins\";\n\n    /**\n     * The pid or name for factory pids.\n     */\n    private final String pid;\n\n    /**\n     * The ordered properties.\n     */\n    private final Dictionary<String, Object> properties = Configurations.newConfiguration();\n\n    /**\n     * Create a new configuration\n     * @param pid The pid\n     * @throws IllegalArgumentException If pid is {@code null}\n     */\n    public Configuration(final String pid) {\n        if (pid == null) {\n            throw new IllegalArgumentException(\"pid must not be null\");\n        }\n        this.pid = pid;\n    }\n\n    @Override\n    public int compareTo(final Configuration o) {\n        return this.pid.compareTo(o.pid);\n    }\n\n    /**\n     * Get the pid.\n     *\n     * @return The pid\n     */\n    public String getPid() {\n        return this.pid;\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @return {@code true} if it's a factory pid\n     * @since 1.3\n     */\n    public boolean isFactoryConfiguration() {\n        return isFactoryConfiguration(this.pid);\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getFactoryPid() {\n        return getFactoryPid(this.pid);\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getName() {\n        return getName(this.pid);\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @param pid The pid\n     * @return {@code true} if it's a factory pid\n     */\n    public static boolean isFactoryConfiguration(final String pid) {\n        return pid.contains(\"~\");\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @param pid The pid\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getFactoryPid(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(0, pos);\n        }\n        return null;\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @param pid The pid\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getName(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(pos + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Get all properties of the configuration. This method returns a mutable\n     * dictionary which can be mutated to alter the properties for this\n     * configuration.\n     *\n     * @return The properties\n     */\n    public Dictionary<String, Object> getProperties() {\n        return this.properties;\n    }\n\n    /**\n     * Get the feature origins - if recorded\n     *\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.6\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins() {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Get the feature origins.\n     * If no origins are recorded, the provided id is returned.\n     *\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.7\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if (list.isEmpty()) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.6\n     */\n    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {\n        if (featureOrigins == null || featureOrigins.isEmpty()) {\n            this.properties.remove(PROP_FEATURE_ORIGINS);\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS, values);\n        }\n    }\n\n    /**\n     * Get the feature origins for a property - if recorded\n     *\n     * @param propertyName The name of the property\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Get the feature origins for a property.\n     * If no origins are recorded, the provided id is returned.\n     *\n     * @param propertyName The name of the property\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if (list.isEmpty()) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins for a property\n     * @param propertyName The name of the property\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.8\n     */\n    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {\n        if (featureOrigins == null || featureOrigins.isEmpty()) {\n            this.properties.remove(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName), values);\n        }\n    }\n\n    /**\n     * Get the configuration properties of the configuration. This configuration\n     * properties are all properties minus properties used to manage the\n     * configuration. Managing properties have to start with\n     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which\n     * represents a snapshot of the properties at the time this method is called.\n     *\n     * @return The configuration properties\n     */\n    public Dictionary<String, Object> getConfigurationProperties() {\n        final Dictionary<String, Object> p = new Hashtable<>();\n        final Enumeration<String> keys = this.properties.keys();\n        for (; keys.hasMoreElements(); ) {\n            final String key = keys.nextElement();\n            if (!key.startsWith(CONFIGURATOR_PREFIX)) {\n                p.put(key, this.properties.get(key));\n            }\n        }\n        return p;\n    }\n\n    /**\n     * Create a copy of the configuration with a provided PID.\n     *\n     * @param aPid The pid of the configuration\n     * @return A copy of this configuration with the given PID\n     */\n    public Configuration copy(final String aPid) {\n        final Configuration result = new Configuration(aPid);\n        final Enumeration<String> keyEnum = this.getProperties().keys();\n        for (; keyEnum.hasMoreElements(); ) {\n            final String key = keyEnum.nextElement();\n            result.getProperties().put(key, this.getProperties().get(key));\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Configuration [pid=\" + pid + \", properties=\" + properties + \"]\";\n    }\n}\n", "class_id": 0, "repo": "hboutemy/sling-org-apache-sling-feature", "file": "src/main/java/org/apache/sling/feature/Configuration.java", "last_update_at": "2021-11-08T14:02:09+00:00", "original_content": "public class Configuration implements Comparable<Configuration> {\n\n    /**\n     * Prefix for instructions for the configurator.\n     */\n    public static final String CONFIGURATOR_PREFIX = \":configurator:\";\n\n    /**\n     * Prefix for special properties which are not configuration properties.\n     */\n    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + \"feature-\";\n\n    /**\n     * This optional configuration property stores the artifact id (mvn id) of the\n     * bundle this configuration belongs to.\n     */\n    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + \"service.bundleLocation\";\n\n    /**\n     * This optional configuration property stores the artifact ids (array) of the\n     * features this configuration has been specified.\n     * @since 1.6\n     */\n    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + \"origins\";\n\n    /**\n     * The pid or name for factory pids.\n     */\n    private final String pid;\n\n    /**\n     * The ordered properties.\n     */\n    private final Dictionary<String, Object> properties = Configurations.newConfiguration();\n\n    /**\n     * Create a new configuration\n     * @param pid The pid\n     * @throws IllegalArgumentException If pid is {@code null}\n     */\n    public Configuration(final String pid) {\n        if (pid == null) {\n            throw new IllegalArgumentException(\"pid must not be null\");\n        }\n        this.pid = pid;\n    }\n\n    @Override\n    public int compareTo(final Configuration o) {\n        return this.pid.compareTo(o.pid);\n    }\n\n    /**\n     * Get the pid.\n     *\n     * @return The pid\n     */\n    public String getPid() {\n        return this.pid;\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @return {@code true} if it's a factory pid\n     * @since 1.3\n     */\n    public boolean isFactoryConfiguration() {\n        return isFactoryConfiguration(this.pid);\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getFactoryPid() {\n        return getFactoryPid(this.pid);\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration()\n     * @since 1.3\n     */\n    public String getName() {\n        return getName(this.pid);\n    }\n\n    /**\n     * Check whether the pid is a factory pid\n     *\n     * @param pid The pid\n     * @return {@code true} if it's a factory pid\n     */\n    public static boolean isFactoryConfiguration(final String pid) {\n        return pid.contains(\"~\");\n    }\n\n    /**\n     * Return the factory pid of a pid if it's a factory configuration\n     *\n     * @param pid The pid\n     * @return The factory pid or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getFactoryPid(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(0, pos);\n        }\n        return null;\n    }\n\n    /**\n     * Return the name for a factory configuration if it is a factory configuration.\n     *\n     * @param pid The pid\n     * @return The name or {@code null}.\n     * @see #isFactoryConfiguration(String)\n     */\n    public static String getName(final String pid) {\n        final int pos = pid.indexOf('~');\n        if (pos != -1) {\n            return pid.substring(pos + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Get all properties of the configuration. This method returns a mutable\n     * dictionary which can be mutated to alter the properties for this\n     * configuration.\n     *\n     * @return The properties\n     */\n    public Dictionary<String, Object> getProperties() {\n        return this.properties;\n    }\n\n    /**\n     * Get the feature origins - if recorded\n     *\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.6\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins() {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Get the feature origins.\n     * If no origins are recorded, the provided id is returned.\n     *\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.7\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if (list.isEmpty()) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.6\n     */\n    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {\n        if (featureOrigins == null || featureOrigins.isEmpty()) {\n            this.properties.remove(PROP_FEATURE_ORIGINS);\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS, values);\n        }\n    }\n\n    /**\n     * Get the feature origins for a property - if recorded\n     *\n     * @param propertyName The name of the property\n     * @return A immutable list of feature artifact ids - list might be empty\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Get the feature origins for a property.\n     * If no origins are recorded, the provided id is returned.\n     *\n     * @param propertyName The name of the property\n     * @param self The id of the current feature\n     * @return A immutable list of feature artifact ids\n     * @since 1.8\n     * @throws IllegalArgumentException If the stored values are not valid artifact ids\n     */\n    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {\n        final List<ArtifactId> list = new ArrayList<>();\n        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        if (origins != null) {\n            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);\n            for (final String v : values) {\n                list.add(ArtifactId.parse(v));\n            }\n        }\n        if (list.isEmpty()) {\n            list.add(self);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Set the feature origins for a property\n     * @param propertyName The name of the property\n     * @param featureOrigins the list of artifact ids or null to remove the info from this object\n     * @since 1.8\n     */\n    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {\n        if (featureOrigins == null || featureOrigins.isEmpty()) {\n            this.properties.remove(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName));\n        } else {\n            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());\n            final String[] values = Converters.standardConverter().convert(list).to(String[].class);\n            this.properties.put(PROP_FEATURE_ORIGINS.concat(\"-\").concat(propertyName), values);\n        }\n    }\n\n    /**\n     * Get the configuration properties of the configuration. This configuration\n     * properties are all properties minus properties used to manage the\n     * configuration. Managing properties have to start with\n     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which\n     * represents a snapshot of the properties at the time this method is called.\n     *\n     * @return The configuration properties\n     */\n    public Dictionary<String, Object> getConfigurationProperties() {\n        final Dictionary<String, Object> p = new Hashtable<>();\n        final Enumeration<String> keys = this.properties.keys();\n        while (keys.hasMoreElements()) {\n            final String key = keys.nextElement();\n            if (!key.startsWith(CONFIGURATOR_PREFIX)) {\n                p.put(key, this.properties.get(key));\n            }\n        }\n        return p;\n    }\n\n    /**\n     * Create a copy of the configuration with a provided PID.\n     *\n     * @param aPid The pid of the configuration\n     * @return A copy of this configuration with the given PID\n     */\n    public Configuration copy(final String aPid) {\n        final Configuration result = new Configuration(aPid);\n        final Enumeration<String> keyEnum = this.getProperties().keys();\n        while (keyEnum.hasMoreElements()) {\n            final String key = keyEnum.nextElement();\n            result.getProperties().put(key, this.getProperties().get(key));\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Configuration [pid=\" + pid + \", properties=\" + properties + \"]\";\n    }\n}\n", "refactored": true}
{"hexsha": "135e2861092daaa6b77ef88ad408f7b6a510cb30", "ext": "java", "lang": "Java", "content": "public class TestMySQLDialect {\n\n    @Test\n    public void testGetLimitString() {\n        MySQLDialect mySQLDialect = new MySQLDialect();\n        String sql = \"select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}\";\n        System.out.println(mySQLDialect.getLimitString(sql, 1, 5));\n        System.out.println(mySQLDialect.getCountString(sql));\n        System.out.print(sql);\n    }\n}\n", "class_id": 0, "repo": "limaofeng/jfantasy-framework", "file": "core/src/test/java/org/jfantasy/framework/dao/mybatis/dialect/TestMySQLDialect.java", "last_update_at": "2021-08-13T15:25:01+00:00", "original_content": "public class TestMySQLDialect {\n\n    @Test\n    public void testGetLimitString() {\n        MySQLDialect mySQLDialect = new MySQLDialect();\n        String sql = \"select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}\";\n        System.out.println(mySQLDialect.getLimitString(sql, 1, 5));\n        System.out.println(mySQLDialect.getCountString(sql));\n        System.out.print(sql);\n    }\n}\n", "refactored": false}
{"hexsha": "89aaa2b36a7cb677b7e7a1d9c911382031ef7316", "ext": "java", "lang": "Java", "content": "public class ExtensionUtility {\n\n    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {\n        Project project = event.getData(PlatformDataKeys.PROJECT);\n        if (project == null) {\n            return null;\n        }\n        DataContext dataContext = event.getDataContext();\n        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n        if (view == null) {\n            return null;\n        }\n        PsiDirectory[] directories = view.getDirectories();\n        if (directories.length == 0) {\n            return null;\n        }\n        return FilesystemUtil.findParentExtensionDirectory(directories[0]);\n    }\n\n    @Nullable\n    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory(\"Classes\");\n        if (classesDirectory == null) {\n            return null;\n        }\n        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);\n        if (composerManifest != null) {\n            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);\n        if (extEmConf != null) {\n            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);\n        if (strings.size() == 0 || strings.get(0).isEmpty()) {\n            return null;\n        }\n        return strings.get(0);\n    }\n\n    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {\n        return new String[0];\n    }\n\n    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {\n        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();\n        phpElementVisitor.visitFile(extEmConf);\n        return phpElementVisitor.getNamespaces();\n    }\n\n    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"ext_emconf.php\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n\n    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {\n        return extensionRootDirectory.findFile(\"ext_emconf.php\");\n    }\n\n    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"composer.json\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n\n    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {\n\n        private List<String> ns;\n\n        @Override\n        public void visitElement(@NotNull PsiElement element) {\n            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(PlatformPatterns.psiElement(ArrayHashElement.class).withParent(PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(PlatformPatterns.or(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"'psr-4'\"), PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"\\\"psr-4\\\"\")))))))).accepts(element)) {\n                if (ns == null) {\n                    ns = new ArrayList<>();\n                }\n                String contents = ((StringLiteralExpression) element).getContents();\n                if (contents.contains(\"\\\\\")) {\n                    contents = contents.replace(\"\\\\\\\\\", \"\\\\\");\n                }\n                if (contents.endsWith(\"\\\\\")) {\n                    ns.add(contents);\n                }\n                ns.add((contents + \"\\\\\"));\n            }\n            super.visitElement(element);\n        }\n\n        public String[] getNamespaces() {\n            if (ns == null) {\n                return new String[0];\n            }\n            return ns.toArray(new String[0]);\n        }\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {\n        return findExtensionKeyFromFile(file.getVirtualFile());\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {\n        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);\n        if (extensionRootFolder == null) {\n            return null;\n        }\n        String extensionKey;\n        VirtualFile composerJsonFile = extensionRootFolder.findChild(\"composer.json\");\n        if (composerJsonFile != null) {\n            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);\n            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);\n        } else {\n            extensionKey = extensionRootFolder.getName();\n        }\n        return extensionKey;\n    }\n}\n", "class_id": 0, "repo": "cedricziel/idea-php-typo3-plugin", "file": "typo3-cms/src/main/java/com/cedricziel/idea/typo3/util/ExtensionUtility.java", "last_update_at": "2021-12-11T18:44:02+00:00", "original_content": "public class ExtensionUtility {\n\n    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {\n        Project project = event.getData(PlatformDataKeys.PROJECT);\n        if (project == null) {\n            return null;\n        }\n        DataContext dataContext = event.getDataContext();\n        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);\n        if (view == null) {\n            return null;\n        }\n        PsiDirectory[] directories = view.getDirectories();\n        if (directories.length == 0) {\n            return null;\n        }\n        return FilesystemUtil.findParentExtensionDirectory(directories[0]);\n    }\n\n    @Nullable\n    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory(\"Classes\");\n        if (classesDirectory == null) {\n            return null;\n        }\n        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);\n        if (composerManifest != null) {\n            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);\n        if (extEmConf != null) {\n            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);\n            if (namespaces.length != 0) {\n                return namespaces[0];\n            }\n        }\n        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);\n        if (strings.size() == 0 || strings.get(0).isEmpty()) {\n            return null;\n        }\n        return strings.get(0);\n    }\n\n    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {\n        return new String[0];\n    }\n\n    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {\n        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();\n        phpElementVisitor.visitFile(extEmConf);\n        return phpElementVisitor.getNamespaces();\n    }\n\n    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"ext_emconf.php\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n\n    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {\n        return extensionRootDirectory.findFile(\"ext_emconf.php\");\n    }\n\n    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {\n        PsiFile file = extensionRootDirectory.findFile(\"composer.json\");\n        if (file == null) {\n            return null;\n        }\n        return file.getVirtualFile();\n    }\n\n    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {\n\n        private List<String> ns;\n\n        @Override\n        public void visitElement(@NotNull PsiElement element) {\n            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(PlatformPatterns.psiElement(ArrayHashElement.class).withParent(PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(PlatformPatterns.or(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"'psr-4'\"), PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText(\"\\\"psr-4\\\"\")))))))).accepts(element)) {\n                if (ns == null) {\n                    ns = new ArrayList<>();\n                }\n                String contents = ((StringLiteralExpression) element).getContents();\n                if (contents.contains(\"\\\\\")) {\n                    contents = contents.replace(\"\\\\\\\\\", \"\\\\\");\n                }\n                if (contents.endsWith(\"\\\\\")) {\n                    ns.add(contents);\n                }\n                ns.add((contents + \"\\\\\"));\n            }\n            super.visitElement(element);\n        }\n\n        public String[] getNamespaces() {\n            if (ns == null) {\n                return new String[0];\n            }\n            return ns.toArray(new String[0]);\n        }\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {\n        return findExtensionKeyFromFile(file.getVirtualFile());\n    }\n\n    @Nullable\n    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {\n        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);\n        if (extensionRootFolder == null) {\n            return null;\n        }\n        String extensionKey;\n        VirtualFile composerJsonFile = extensionRootFolder.findChild(\"composer.json\");\n        if (composerJsonFile != null) {\n            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);\n            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);\n        } else {\n            extensionKey = extensionRootFolder.getName();\n        }\n        return extensionKey;\n    }\n}\n", "refactored": false}
{"hexsha": "12c6b162778cfc33f04b38dd1d9c10eacd9db16e", "ext": "java", "lang": "Java", "content": "public class LocalBoundary {\n\n    private static final int MAX_LOCAL_SEGS = 8;\n\n    private static class Segment {\n\n        /**\n         * Segment start/end\n         */\n        float[] s = new float[6];\n\n        /**\n         * Distance for pruning.\n         */\n        float d;\n    }\n\n    float[] m_center = new float[3];\n\n    List<Segment> m_segs = new ArrayList<>();\n\n    List<Long> m_polys = new ArrayList<>();\n\n    protected LocalBoundary() {\n        m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n    }\n\n    protected void reset() {\n        m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n        m_polys.clear();\n        m_segs.clear();\n    }\n\n    protected void addSegment(float dist, float[] s) {\n        // Insert neighbour based on the distance.\n        Segment seg = new Segment();\n        System.arraycopy(s, 0, seg.s, 0, 6);\n        seg.d = dist;\n        if (m_segs.isEmpty()) {\n            m_segs.add(seg);\n        } else if (dist >= m_segs.get(m_segs.size() - 1).d) {\n            if (m_segs.size() >= MAX_LOCAL_SEGS) {\n                return;\n            }\n            m_segs.add(seg);\n        } else {\n            // Insert inbetween.\n            int i;\n            for (i = 0; i < m_segs.size(); ++i) if (dist <= m_segs.get(i).d)\n                break;\n            m_segs.add(i, seg);\n        }\n        for (; m_segs.size() > MAX_LOCAL_SEGS; ) {\n            m_segs.remove(m_segs.size() - 1);\n        }\n    }\n\n    public void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {\n        if (ref == 0) {\n            reset();\n            return;\n        }\n        vCopy(m_center, pos);\n        // First query non-overlapping polygons.\n        FindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);\n        this.m_polys = res.getRefs();\n        m_segs.clear();\n        // Secondly, store all polygon edges.\n        for (int j = 0; j < m_polys.size(); ++j) {\n            GetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);\n            for (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {\n                float[] s = gpws.getSegmentVerts().get(k);\n                // Skip too distant segments.\n                Tupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);\n                if (distseg.first > sqr(collisionQueryRange))\n                    continue;\n                addSegment(distseg.first, s);\n            }\n        }\n    }\n\n    public boolean isValid(NavMeshQuery navquery, QueryFilter filter) {\n        if (m_polys.isEmpty())\n            return false;\n        // Check that all polygons still pass query filter.\n        for (long ref : m_polys) {\n            if (!navquery.isValidPolyRef(ref, filter))\n                return false;\n        }\n        return true;\n    }\n\n    public float[] getCenter() {\n        return m_center;\n    }\n\n    public float[] getSegment(int j) {\n        return m_segs.get(j).s;\n    }\n\n    public int getSegmentCount() {\n        return m_segs.size();\n    }\n}\n", "class_id": 0, "repo": "Warkdev/recast4j", "file": "detourcrowd/src/main/java/org/recast4j/detour/crowd/LocalBoundary.java", "last_update_at": "2021-06-25T15:46:37+00:00", "original_content": "public class LocalBoundary {\n\n    private static final int MAX_LOCAL_SEGS = 8;\n\n    private static class Segment {\n\n        /**\n         * Segment start/end\n         */\n        float[] s = new float[6];\n\n        /**\n         * Distance for pruning.\n         */\n        float d;\n    }\n\n    float[] m_center = new float[3];\n\n    List<Segment> m_segs = new ArrayList<>();\n\n    List<Long> m_polys = new ArrayList<>();\n\n    protected LocalBoundary() {\n        m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n    }\n\n    protected void reset() {\n        m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;\n        m_polys.clear();\n        m_segs.clear();\n    }\n\n    protected void addSegment(float dist, float[] s) {\n        // Insert neighbour based on the distance.\n        Segment seg = new Segment();\n        System.arraycopy(s, 0, seg.s, 0, 6);\n        seg.d = dist;\n        if (m_segs.isEmpty()) {\n            m_segs.add(seg);\n        } else if (dist >= m_segs.get(m_segs.size() - 1).d) {\n            if (m_segs.size() >= MAX_LOCAL_SEGS) {\n                return;\n            }\n            m_segs.add(seg);\n        } else {\n            // Insert inbetween.\n            int i;\n            for (i = 0; i < m_segs.size(); ++i) if (dist <= m_segs.get(i).d)\n                break;\n            m_segs.add(i, seg);\n        }\n        while (m_segs.size() > MAX_LOCAL_SEGS) {\n            m_segs.remove(m_segs.size() - 1);\n        }\n    }\n\n    public void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {\n        if (ref == 0) {\n            reset();\n            return;\n        }\n        vCopy(m_center, pos);\n        // First query non-overlapping polygons.\n        FindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);\n        this.m_polys = res.getRefs();\n        m_segs.clear();\n        // Secondly, store all polygon edges.\n        for (int j = 0; j < m_polys.size(); ++j) {\n            GetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);\n            for (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {\n                float[] s = gpws.getSegmentVerts().get(k);\n                // Skip too distant segments.\n                Tupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);\n                if (distseg.first > sqr(collisionQueryRange))\n                    continue;\n                addSegment(distseg.first, s);\n            }\n        }\n    }\n\n    public boolean isValid(NavMeshQuery navquery, QueryFilter filter) {\n        if (m_polys.isEmpty())\n            return false;\n        // Check that all polygons still pass query filter.\n        for (long ref : m_polys) {\n            if (!navquery.isValidPolyRef(ref, filter))\n                return false;\n        }\n        return true;\n    }\n\n    public float[] getCenter() {\n        return m_center;\n    }\n\n    public float[] getSegment(int j) {\n        return m_segs.get(j).s;\n    }\n\n    public int getSegmentCount() {\n        return m_segs.size();\n    }\n}\n", "refactored": true}
{"hexsha": "88dd300f77e53e19d8f96d18b70087d68f88fb62", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class InstantiatedLambdasTestRunner extends TestBase {\n\n    static final Class<?> CLASS = InstantiatedLambdasTest.class;\n\n    static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;\n\n    static final String EXPECTED = StringUtils.lines(\"Class implementation\", \"Lambda implementation\");\n\n    private final TestParameters parameters;\n\n    private Path inputJar;\n\n    @Parameters(name = \"{0}\")\n    public static TestParametersCollection data() {\n        return getTestParameters().withAllRuntimesAndApiLevels().build();\n    }\n\n    public InstantiatedLambdasTestRunner(TestParameters parameters) {\n        this.parameters = parameters;\n    }\n\n    @Before\n    public void writeAndRunInputJar() throws IOException {\n        inputJar = temp.getRoot().toPath().resolve(\"input.jar\");\n        ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);\n        for (Class<?> clazz : CLASSES) {\n            buildInput.accept(ByteDataView.of(ToolHelper.getClassAsBytes(clazz)), DescriptorUtils.javaTypeToDescriptor(clazz.getName()), null);\n        }\n        buildInput.finished(null);\n    }\n\n    @Test\n    public void testProguard() throws Exception {\n        assumeTrue(parameters.isCfRuntime());\n        buildAndRunProguard(\"pg.jar\", false);\n    }\n\n    @Test\n    public void testProguardAggressive() throws Exception {\n        assumeTrue(parameters.isCfRuntime());\n        buildAndRunProguard(\"pg-aggressive.jar\", true);\n    }\n\n    @Test\n    public void testR8() throws Exception {\n        testR8(false);\n    }\n\n    @Test\n    public void testR8Aggressive() throws Exception {\n        testR8(true);\n    }\n\n    private void testR8(boolean aggressive) throws Exception {\n        testForR8(parameters.getBackend()).addProgramFiles(inputJar).addKeepMainRule(CLASS).applyIf(aggressive, builder -> builder.addKeepRules(\"-overloadaggressively\")).debug().setMinApi(parameters.getApiLevel()).compile().apply(compileResult -> compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED)).applyIf(parameters.isDexRuntime(), compileResult -> compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());\n    }\n\n    private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {\n        Path pgConfig = writeProguardRules(aggressive);\n        Path outPg = temp.getRoot().toPath().resolve(outName);\n        ProcessResult proguardResult = ToolHelper.runProguard6Raw(inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);\n        System.out.println(proguardResult.stdout);\n        if (proguardResult.exitCode != 0) {\n            System.out.println(proguardResult.stderr);\n        }\n        assertEquals(0, proguardResult.exitCode);\n        ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());\n        assertEquals(0, runPg.exitCode);\n    }\n\n    private Path writeProguardRules(boolean aggressive) throws IOException {\n        Path pgConfig = temp.getRoot().toPath().resolve(\"keep.txt\");\n        FileUtils.writeTextFile(pgConfig, \"-keep public class \" + CLASS.getCanonicalName() + \" {\", \"  public static void main(...);\", \"}\", aggressive ? \"-overloadaggressively\" : \"# Not overloading aggressively\");\n        return pgConfig;\n    }\n}\n", "class_id": 0, "repo": "kami-lang/madex-r8", "file": "src/test/java/com/android/tools/r8/shaking/InstantiatedLambdasTestRunner.java", "last_update_at": "2021-09-01T09:50:44+00:00", "original_content": "@RunWith(Parameterized.class)\npublic class InstantiatedLambdasTestRunner extends TestBase {\n\n    static final Class<?> CLASS = InstantiatedLambdasTest.class;\n\n    static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;\n\n    static final String EXPECTED = StringUtils.lines(\"Class implementation\", \"Lambda implementation\");\n\n    private final TestParameters parameters;\n\n    private Path inputJar;\n\n    @Parameters(name = \"{0}\")\n    public static TestParametersCollection data() {\n        return getTestParameters().withAllRuntimesAndApiLevels().build();\n    }\n\n    public InstantiatedLambdasTestRunner(TestParameters parameters) {\n        this.parameters = parameters;\n    }\n\n    @Before\n    public void writeAndRunInputJar() throws IOException {\n        inputJar = temp.getRoot().toPath().resolve(\"input.jar\");\n        ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);\n        for (Class<?> clazz : CLASSES) {\n            buildInput.accept(ByteDataView.of(ToolHelper.getClassAsBytes(clazz)), DescriptorUtils.javaTypeToDescriptor(clazz.getName()), null);\n        }\n        buildInput.finished(null);\n    }\n\n    @Test\n    public void testProguard() throws Exception {\n        assumeTrue(parameters.isCfRuntime());\n        buildAndRunProguard(\"pg.jar\", false);\n    }\n\n    @Test\n    public void testProguardAggressive() throws Exception {\n        assumeTrue(parameters.isCfRuntime());\n        buildAndRunProguard(\"pg-aggressive.jar\", true);\n    }\n\n    @Test\n    public void testR8() throws Exception {\n        testR8(false);\n    }\n\n    @Test\n    public void testR8Aggressive() throws Exception {\n        testR8(true);\n    }\n\n    private void testR8(boolean aggressive) throws Exception {\n        testForR8(parameters.getBackend()).addProgramFiles(inputJar).addKeepMainRule(CLASS).applyIf(aggressive, builder -> builder.addKeepRules(\"-overloadaggressively\")).debug().setMinApi(parameters.getApiLevel()).compile().apply(compileResult -> compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED)).applyIf(parameters.isDexRuntime(), compileResult -> compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());\n    }\n\n    private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {\n        Path pgConfig = writeProguardRules(aggressive);\n        Path outPg = temp.getRoot().toPath().resolve(outName);\n        ProcessResult proguardResult = ToolHelper.runProguard6Raw(inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);\n        System.out.println(proguardResult.stdout);\n        if (proguardResult.exitCode != 0) {\n            System.out.println(proguardResult.stderr);\n        }\n        assertEquals(0, proguardResult.exitCode);\n        ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());\n        assertEquals(0, runPg.exitCode);\n    }\n\n    private Path writeProguardRules(boolean aggressive) throws IOException {\n        Path pgConfig = temp.getRoot().toPath().resolve(\"keep.txt\");\n        FileUtils.writeTextFile(pgConfig, \"-keep public class \" + CLASS.getCanonicalName() + \" {\", \"  public static void main(...);\", \"}\", aggressive ? \"-overloadaggressively\" : \"# Not overloading aggressively\");\n        return pgConfig;\n    }\n}\n", "refactored": false}
{"hexsha": "176afd6c9a0292ae4cd8a03ac5d1212ccc2d7dc6", "ext": "java", "lang": "Java", "content": "class Arithmatic {\r\n\r\n    public static void main(String[] args) {\r\n        if (args.length != 2) {\r\n            System.out.println(\"Please Enter Values \");\r\n            return;\r\n        }\r\n        // take the numbers from args, would be in string form\r\n        String s1 = args[0];\r\n        String s2 = args[1];\r\n        // convert them into numeric\r\n        double d1 = Double.parseDouble(s1);\r\n        double d2 = Double.parseDouble(s2);\r\n        double d3 = d1 + d2;\r\n        System.out.println(\"The Sum is : \" + d3);\r\n    }\r\n}\r\n", "class_id": 0, "repo": "PRASAD-DANGARE/JAVA", "file": "Command_Line_args2.java", "last_update_at": "2021-07-06T16:41:07+00:00", "original_content": "class Arithmatic {\r\n\r\n    public static void main(String[] args) {\r\n        if (args.length != 2) {\r\n            System.out.println(\"Please Enter Values \");\r\n            return;\r\n        }\r\n        // take the numbers from args, would be in string form\r\n        String s1 = args[0];\r\n        String s2 = args[1];\r\n        // convert them into numeric\r\n        double d1 = Double.parseDouble(s1);\r\n        double d2 = Double.parseDouble(s2);\r\n        double d3 = d1 + d2;\r\n        System.out.println(\"The Sum is : \" + d3);\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "b58650221f683f40085428f04a18ec28d51489f9", "ext": "java", "lang": "Java", "content": "public class c {\n\n    private static final String a;\n\n    static {\n        a = c.class.getSimpleName();\n    }\n\n    public static void a(a aVar) {\n        if (DownloadService.a() == null) {\n            Bundle bundle;\n            Intent intent = new Intent();\n            intent.setClass(BrothersApplication.a(), LoadingActivity.class);\n            intent.addFlags(268435456);\n            intent.addFlags(67108864);\n            if (aVar == null) {\n                bundle = null;\n            } else {\n                bundle = new Bundle();\n                bundle.putString(\"cooperation_url\", aVar.a);\n                bundle.putString(\"cooperation_decode_url\", aVar.b);\n                bundle.putString(\"cooperation_title\", aVar.c);\n                bundle.putInt(\"cooperation_type\", aVar.d);\n                bundle.putInt(\"cooperation_play_time\", aVar.e);\n            }\n            if (bundle != null) {\n                intent.putExtras(bundle);\n            }\n            BrothersApplication.a().startActivity(intent);\n            return;\n        }\n        Object obj;\n        String str = aVar.a;\n        if (str.isEmpty() || !str.endsWith(\".torrent\")) {\n            obj = null;\n        } else {\n            obj = 1;\n        }\n        if (obj == null) {\n            aVar.b = aVar.a;\n            VodUtil.a();\n            VodUtil.a(aVar);\n        } else if (TextUtils.isEmpty(aVar.b)) {\n            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);\n            intent2.putExtra(\"cooperation_url\", aVar.a);\n            intent2.putExtra(\"cooperation_caller_packagename\", aVar.g);\n            intent2.setFlags(268435456);\n            intent2.addFlags(67108864);\n            BrothersApplication.a().startActivity(intent2);\n        } else {\n            VodUtil.a();\n            VodUtil.a(aVar);\n        }\n    }\n\n    public static a a(Intent intent) {\n        if (intent == null) {\n            return null;\n        }\n        a aVar;\n        int intExtra = intent.getIntExtra(\"cooperation_type\", 0);\n        if (b.a(intExtra)) {\n            String stringExtra = intent.getStringExtra(\"cooperation_url\");\n            intent.getStringExtra(\"cooperation_decode_url\");\n            aVar = new a(stringExtra, intent.getStringExtra(\"cooperation_title\"), intExtra, intent.getIntExtra(\"cooperation_play_time\", 0), null);\n        } else {\n            aVar = null;\n        }\n        return aVar;\n    }\n\n    public static String a(int i) {\n        return i == 1 ? \"uc\" : a.d;\n    }\n\n    public static int a(String str) {\n        return \"uc\".equals(str) ? 1 : 0;\n    }\n}\n", "class_id": 0, "repo": "megahertz0/android_thunder", "file": "dex_src/com/xunlei/downloadprovider/vod/a/c.java", "last_update_at": "2021-11-18T02:55:40+00:00", "original_content": "public class c {\n\n    private static final String a;\n\n    static {\n        a = c.class.getSimpleName();\n    }\n\n    public static void a(a aVar) {\n        if (DownloadService.a() == null) {\n            Bundle bundle;\n            Intent intent = new Intent();\n            intent.setClass(BrothersApplication.a(), LoadingActivity.class);\n            intent.addFlags(268435456);\n            intent.addFlags(67108864);\n            if (aVar == null) {\n                bundle = null;\n            } else {\n                bundle = new Bundle();\n                bundle.putString(\"cooperation_url\", aVar.a);\n                bundle.putString(\"cooperation_decode_url\", aVar.b);\n                bundle.putString(\"cooperation_title\", aVar.c);\n                bundle.putInt(\"cooperation_type\", aVar.d);\n                bundle.putInt(\"cooperation_play_time\", aVar.e);\n            }\n            if (bundle != null) {\n                intent.putExtras(bundle);\n            }\n            BrothersApplication.a().startActivity(intent);\n            return;\n        }\n        Object obj;\n        String str = aVar.a;\n        if (str.isEmpty() || !str.endsWith(\".torrent\")) {\n            obj = null;\n        } else {\n            obj = 1;\n        }\n        if (obj == null) {\n            aVar.b = aVar.a;\n            VodUtil.a();\n            VodUtil.a(aVar);\n        } else if (TextUtils.isEmpty(aVar.b)) {\n            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);\n            intent2.putExtra(\"cooperation_url\", aVar.a);\n            intent2.putExtra(\"cooperation_caller_packagename\", aVar.g);\n            intent2.setFlags(268435456);\n            intent2.addFlags(67108864);\n            BrothersApplication.a().startActivity(intent2);\n        } else {\n            VodUtil.a();\n            VodUtil.a(aVar);\n        }\n    }\n\n    public static a a(Intent intent) {\n        if (intent == null) {\n            return null;\n        }\n        a aVar;\n        int intExtra = intent.getIntExtra(\"cooperation_type\", 0);\n        if (b.a(intExtra)) {\n            String stringExtra = intent.getStringExtra(\"cooperation_url\");\n            intent.getStringExtra(\"cooperation_decode_url\");\n            aVar = new a(stringExtra, intent.getStringExtra(\"cooperation_title\"), intExtra, intent.getIntExtra(\"cooperation_play_time\", 0), null);\n        } else {\n            aVar = null;\n        }\n        return aVar;\n    }\n\n    public static String a(int i) {\n        return i == 1 ? \"uc\" : a.d;\n    }\n\n    public static int a(String str) {\n        return \"uc\".equals(str) ? 1 : 0;\n    }\n}\n", "refactored": false}
{"hexsha": "3821c2ca9d58dbb74b7f64e42156ebd845507391", "ext": "java", "lang": "Java", "content": "@Data\r\npublic class RouteClientInit {\r\n\r\n    private final String url;\r\n\r\n    private final int maxContentLength;\r\n\r\n    private final String headerRouteValue;\r\n\r\n    private Channel channel;\r\n\r\n    private CompletableFuture<DefaultFullHttpResponse> response;\r\n\r\n    public RouteClientInit(String url, int maxContentLength, String headerRouteValue) {\r\n        this.url = url;\r\n        this.maxContentLength = maxContentLength;\r\n        this.headerRouteValue = headerRouteValue;\r\n    }\r\n\r\n    public DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {\r\n        init().writeAndFlush(defaultFullHttpRequest);\r\n        return response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    public void call(DefaultFullHttpResponse defaultFullHttpResponse) {\r\n        response.complete(defaultFullHttpResponse);\r\n    }\r\n\r\n    private Channel init() throws InterruptedException {\r\n        response = new CompletableFuture<>();\r\n        if (ChannelUtils.channelIsActive(channel)) {\r\n            return channel;\r\n        }\r\n        channel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue)).channel(NioSocketChannel.class).handler(new RouteClientInitializer(this)).connect(SocketAddressUtils.getInetSocketAddress(url)).sync().channel();\r\n        return channel;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "15662664518/web-route-spring-boot-starter", "file": "web-route-spring-boot-autoconfigure/src/main/java/com/github/thierrysquirrel/web/route/netty/client/init/RouteClientInit.java", "last_update_at": "2021-05-22T03:56:42+00:00", "original_content": "@Data\r\npublic class RouteClientInit {\r\n\r\n    private final String url;\r\n\r\n    private final int maxContentLength;\r\n\r\n    private final String headerRouteValue;\r\n\r\n    private Channel channel;\r\n\r\n    private CompletableFuture<DefaultFullHttpResponse> response;\r\n\r\n    public RouteClientInit(String url, int maxContentLength, String headerRouteValue) {\r\n        this.url = url;\r\n        this.maxContentLength = maxContentLength;\r\n        this.headerRouteValue = headerRouteValue;\r\n    }\r\n\r\n    public DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {\r\n        init().writeAndFlush(defaultFullHttpRequest);\r\n        return response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    public void call(DefaultFullHttpResponse defaultFullHttpResponse) {\r\n        response.complete(defaultFullHttpResponse);\r\n    }\r\n\r\n    private Channel init() throws InterruptedException {\r\n        response = new CompletableFuture<>();\r\n        if (ChannelUtils.channelIsActive(channel)) {\r\n            return channel;\r\n        }\r\n        channel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue)).channel(NioSocketChannel.class).handler(new RouteClientInitializer(this)).connect(SocketAddressUtils.getInetSocketAddress(url)).sync().channel();\r\n        return channel;\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "ff542139117e2ec97abdccaa834b9817bd33a05d", "ext": "java", "lang": "Java", "content": "public class DBController {\n\n    private static final String DB_NAME = \"fruits_db.db\";\n\n    private DaoMaster.DevOpenHelper mHelpler;\n\n    private SQLiteDatabase mDb;\n\n    private DaoMaster mDaoMaster;\n\n    private DaoSession mDaoSession;\n\n    private Context mContext;\n\n    private UserDao mUserDao;\n\n    private HistoryDao mHistoryDao;\n\n    private CollectionDao mCollectionDao;\n\n    private QuickDao mQuickDao;\n\n    private static DBController sDbController;\n\n    public static DBController getInstance(Context context) {\n        if (sDbController == null) {\n            synchronized (DBController.class) {\n                if (sDbController == null) {\n                    sDbController = new DBController(context);\n                }\n            }\n        }\n        return sDbController;\n    }\n\n    public DBController(Context context) {\n        mContext = context;\n        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        mDaoMaster = new DaoMaster(getWrittableDatabase());\n        mDaoSession = mDaoMaster.newSession();\n        mUserDao = mDaoSession.getUserDao();\n        mHistoryDao = mDaoSession.getHistoryDao();\n        mCollectionDao = mDaoSession.getCollectionDao();\n        mQuickDao = mDaoSession.getQuickDao();\n    }\n\n    private SQLiteDatabase getWrittableDatabase() {\n        if (mHelpler == null) {\n            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        }\n        mDb = mHelpler.getWritableDatabase();\n        return mDb;\n    }\n\n    public long insertUser(User user) {\n        return mUserDao.insert(user);\n    }\n\n    public User checkUserAndPassword(String whereUser, String wherePassword) {\n        User user = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser), UserDao.Properties.Password.eq(wherePassword)).build().unique();\n        return user;\n    }\n\n    public boolean checkUserExist(String whereUser) {\n        List<User> users = (List<User>) mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser)).build().list();\n        return !users.isEmpty();\n    }\n\n    public void insertHistory(List<History> histories) {\n        int i = 0;\n        while (i < histories.size()) try {\n            List<History> res = mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()), HistoryDao.Properties.Time.eq(histories.get(i).getTime())).build().list();\n            if (res == null || res.isEmpty()) {\n                mHistoryDao.insert(histories.get(i));\n            } else {\n                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()), HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete().executeDeleteWithoutDetachingEntities();\n                mHistoryDao.insert(histories.get(i));\n            }\n        } finally {\n            i++;\n        }\n    }\n\n    public void deleteAllHistory() {\n        mHistoryDao.deleteAll();\n    }\n\n    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                int i = 0;\n                while (i < historiesToBeDeleted.size()) try {\n                    mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()), HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime())).buildDelete().executeDeleteWithoutDetachingEntities();\n                } finally {\n                    i++;\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public List<History> getAll() {\n        List<History> all = (List<History>) mHistoryDao.queryBuilder().build().list();\n        return all;\n    }\n\n    public List<Collection> getUserCollection(String username) {\n        List<Collection> res = mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username)).build().list();\n        return res;\n    }\n\n    public void addCollection(String username, String url, String title) {\n        List<Collection> exist = mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username), CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title)).build().list();\n        if (exist == null || exist.isEmpty()) {\n            mCollectionDao.insert(new Collection(username, url, title));\n        } else {\n            return;\n        }\n    }\n\n    public void deleteAllCollection(String username) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username)).buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void deleteSelectedCollection(List<Collection> toBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                int i = 0;\n                while (i < toBeDeleted.size()) try {\n                    mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()), CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()), CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle())).buildDelete().executeDeleteWithoutDetachingEntities();\n                } finally {\n                    i++;\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public void changeUsername(String name, String newName) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        if (findUser != null) {\n            findUser.setCustomizeName(newName);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public String getProfile(String name) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        return findUser.getProfile();\n    }\n\n    public void setProfile(String name, String profile) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        if (findUser != null) {\n            findUser.setProfile(profile);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void changePassword(String name, String newPassword) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        if (findUser != null) {\n            findUser.setPassword(newPassword);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void deleteUser(String name) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name)).buildDelete().executeDeleteWithoutDetachingEntities();\n        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public boolean insertQuick(String title, String url) {\n        Quick quick = new Quick(null, title, url);\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).build().unique();\n        if (res != null) {\n            return false;\n        } else {\n            mQuickDao.insert(quick);\n            return true;\n        }\n    }\n\n    public List<Quick> getQuick() {\n        return mQuickDao.loadAll();\n    }\n\n    public void deleteQuick(String title, String url) {\n        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void changeQuick(String title, String url, String newTitle, String newUrl) {\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).build().unique();\n        res.setTitle(newTitle);\n        res.setUrl(newUrl);\n        mQuickDao.update(res);\n    }\n}\n", "class_id": 0, "repo": "HeXavi8/Orange-Browser", "file": "app/src/main/java/com/example/fruit/dao/DBController.java", "last_update_at": "2021-11-28T01:58:02+00:00", "original_content": "public class DBController {\n\n    private static final String DB_NAME = \"fruits_db.db\";\n\n    private DaoMaster.DevOpenHelper mHelpler;\n\n    private SQLiteDatabase mDb;\n\n    private DaoMaster mDaoMaster;\n\n    private DaoSession mDaoSession;\n\n    private Context mContext;\n\n    private UserDao mUserDao;\n\n    private HistoryDao mHistoryDao;\n\n    private CollectionDao mCollectionDao;\n\n    private QuickDao mQuickDao;\n\n    private static DBController sDbController;\n\n    public static DBController getInstance(Context context) {\n        if (sDbController == null) {\n            synchronized (DBController.class) {\n                if (sDbController == null) {\n                    sDbController = new DBController(context);\n                }\n            }\n        }\n        return sDbController;\n    }\n\n    public DBController(Context context) {\n        mContext = context;\n        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        mDaoMaster = new DaoMaster(getWrittableDatabase());\n        mDaoSession = mDaoMaster.newSession();\n        mUserDao = mDaoSession.getUserDao();\n        mHistoryDao = mDaoSession.getHistoryDao();\n        mCollectionDao = mDaoSession.getCollectionDao();\n        mQuickDao = mDaoSession.getQuickDao();\n    }\n\n    private SQLiteDatabase getWrittableDatabase() {\n        if (mHelpler == null) {\n            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);\n        }\n        mDb = mHelpler.getWritableDatabase();\n        return mDb;\n    }\n\n    public long insertUser(User user) {\n        return mUserDao.insert(user);\n    }\n\n    public User checkUserAndPassword(String whereUser, String wherePassword) {\n        User user = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser), UserDao.Properties.Password.eq(wherePassword)).build().unique();\n        return user;\n    }\n\n    public boolean checkUserExist(String whereUser) {\n        List<User> users = (List<User>) mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser)).build().list();\n        return !users.isEmpty();\n    }\n\n    public void insertHistory(List<History> histories) {\n        for (int i = 0; i < histories.size(); i++) {\n            List<History> res = mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()), HistoryDao.Properties.Time.eq(histories.get(i).getTime())).build().list();\n            if (res == null || res.isEmpty()) {\n                mHistoryDao.insert(histories.get(i));\n            } else {\n                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()), HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete().executeDeleteWithoutDetachingEntities();\n                mHistoryDao.insert(histories.get(i));\n            }\n        }\n    }\n\n    public void deleteAllHistory() {\n        mHistoryDao.deleteAll();\n    }\n\n    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < historiesToBeDeleted.size(); i++) {\n                    mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()), HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime())).buildDelete().executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public List<History> getAll() {\n        List<History> all = (List<History>) mHistoryDao.queryBuilder().build().list();\n        return all;\n    }\n\n    public List<Collection> getUserCollection(String username) {\n        List<Collection> res = mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username)).build().list();\n        return res;\n    }\n\n    public void addCollection(String username, String url, String title) {\n        List<Collection> exist = mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username), CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title)).build().list();\n        if (exist == null || exist.isEmpty()) {\n            mCollectionDao.insert(new Collection(username, url, title));\n        } else {\n            return;\n        }\n    }\n\n    public void deleteAllCollection(String username) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username)).buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void deleteSelectedCollection(List<Collection> toBeDeleted) {\n        if (mDb.isOpen()) {\n            try {\n                mDb.beginTransaction();\n                for (int i = 0; i < toBeDeleted.size(); i++) {\n                    mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()), CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()), CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle())).buildDelete().executeDeleteWithoutDetachingEntities();\n                }\n                mDb.setTransactionSuccessful();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                mDb.endTransaction();\n            }\n        }\n    }\n\n    public void changeUsername(String name, String newName) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        if (findUser != null) {\n            findUser.setCustomizeName(newName);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public String getProfile(String name) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        return findUser.getProfile();\n    }\n\n    public void setProfile(String name, String profile) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        if (findUser != null) {\n            findUser.setProfile(profile);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void changePassword(String name, String newPassword) {\n        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();\n        if (findUser != null) {\n            findUser.setPassword(newPassword);\n            mUserDao.update(findUser);\n        }\n    }\n\n    public void deleteUser(String name) {\n        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name)).buildDelete().executeDeleteWithoutDetachingEntities();\n        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public boolean insertQuick(String title, String url) {\n        Quick quick = new Quick(null, title, url);\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).build().unique();\n        if (res != null) {\n            return false;\n        } else {\n            mQuickDao.insert(quick);\n            return true;\n        }\n    }\n\n    public List<Quick> getQuick() {\n        return mQuickDao.loadAll();\n    }\n\n    public void deleteQuick(String title, String url) {\n        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).buildDelete().executeDeleteWithoutDetachingEntities();\n    }\n\n    public void changeQuick(String title, String url, String newTitle, String newUrl) {\n        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).build().unique();\n        res.setTitle(newTitle);\n        res.setUrl(newUrl);\n        mQuickDao.update(res);\n    }\n}\n", "refactored": true}
{"hexsha": "48e6cf123eb4cbfdcdfdd0e229d4bb6928328e8c", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class CommonFloatService {\n\n    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);\n\n    private final CommonFloatRepository commonFloatRepository;\n\n    private final CacheManager cacheManager;\n\n    private final CommonFloatMapper commonFloatMapper;\n\n    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {\n        this.commonFloatRepository = commonFloatRepository;\n        this.cacheManager = cacheManager;\n        this.commonFloatMapper = commonFloatMapper;\n    }\n\n    /**\n     * Save a commonFloat.\n     *\n     * @param commonFloatDTO the entity to save.\n     * @return the persisted entity.\n     */\n    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {\n        log.debug(\"Request to save CommonFloat : {}\", commonFloatDTO);\n        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);\n        commonFloat = commonFloatRepository.save(commonFloat);\n        return commonFloatMapper.toDto(commonFloat);\n    }\n\n    /**\n     * Get all the commonFloats.\n     *\n     * @param pageable the pagination information.\n     * @return the list of entities.\n     */\n    @Transactional(readOnly = true)\n    public Page<CommonFloatDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all CommonFloats\");\n        return commonFloatRepository.findAll(pageable).map(commonFloatMapper::toDto);\n    }\n\n    /**\n     * count all the commonFloats.\n     *\n     * @return the count of entities\n     * by wangxin\n     */\n    @Transactional(readOnly = true)\n    public long count() {\n        log.debug(\"Request to count all CommonFloats\");\n        return commonFloatRepository.count();\n    }\n\n    /**\n     * Get one commonFloat by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Transactional(readOnly = true)\n    public Optional<CommonFloatDTO> findOne(Long id) {\n        log.debug(\"Request to get CommonFloat : {}\", id);\n        return commonFloatRepository.findById(id).map(commonFloatMapper::toDto);\n    }\n\n    /**\n     * Delete the commonFloat by id.\n     *\n     * @param id the id of the entity.\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete CommonFloat : {}\", id);\n        commonFloatRepository.deleteById(id);\n    }\n\n    /**\n     * Update specified fields by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n\n    /**\n     * Update specified field by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO, fieldName));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n}\n", "class_id": 0, "repo": "wangxinxx/jhi-ant-vue", "file": "src/main/java/com/aidriveall/cms/service/CommonFloatService.java", "last_update_at": "2021-08-18T18:54:11+00:00", "original_content": "@Service\n@Transactional\npublic class CommonFloatService {\n\n    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);\n\n    private final CommonFloatRepository commonFloatRepository;\n\n    private final CacheManager cacheManager;\n\n    private final CommonFloatMapper commonFloatMapper;\n\n    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {\n        this.commonFloatRepository = commonFloatRepository;\n        this.cacheManager = cacheManager;\n        this.commonFloatMapper = commonFloatMapper;\n    }\n\n    /**\n     * Save a commonFloat.\n     *\n     * @param commonFloatDTO the entity to save.\n     * @return the persisted entity.\n     */\n    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {\n        log.debug(\"Request to save CommonFloat : {}\", commonFloatDTO);\n        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);\n        commonFloat = commonFloatRepository.save(commonFloat);\n        return commonFloatMapper.toDto(commonFloat);\n    }\n\n    /**\n     * Get all the commonFloats.\n     *\n     * @param pageable the pagination information.\n     * @return the list of entities.\n     */\n    @Transactional(readOnly = true)\n    public Page<CommonFloatDTO> findAll(Pageable pageable) {\n        log.debug(\"Request to get all CommonFloats\");\n        return commonFloatRepository.findAll(pageable).map(commonFloatMapper::toDto);\n    }\n\n    /**\n     * count all the commonFloats.\n     *\n     * @return the count of entities\n     * by wangxin\n     */\n    @Transactional(readOnly = true)\n    public long count() {\n        log.debug(\"Request to count all CommonFloats\");\n        return commonFloatRepository.count();\n    }\n\n    /**\n     * Get one commonFloat by id.\n     *\n     * @param id the id of the entity.\n     * @return the entity.\n     */\n    @Transactional(readOnly = true)\n    public Optional<CommonFloatDTO> findOne(Long id) {\n        log.debug(\"Request to get CommonFloat : {}\", id);\n        return commonFloatRepository.findById(id).map(commonFloatMapper::toDto);\n    }\n\n    /**\n     * Delete the commonFloat by id.\n     *\n     * @param id the id of the entity.\n     */\n    public void delete(Long id) {\n        log.debug(\"Request to delete CommonFloat : {}\", id);\n        commonFloatRepository.deleteById(id);\n    }\n\n    /**\n     * Update specified fields by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n\n    /**\n     * Update specified field by commonFloat\n     */\n    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {\n        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();\n        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO, fieldName));\n        commonFloatDTO = save(commonFloatDTO);\n        return commonFloatDTO;\n    }\n}\n", "refactored": false}
{"hexsha": "a38fec13b412ae11bdd8b5e9e7e1fe1d7cd98108", "ext": "java", "lang": "Java", "content": "public class IndustrialJackhammerItem extends JackhammerItem {\n\n    public IndustrialJackhammerItem() {\n        super(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);\n    }\n\n    // Cycle Inactive, Active 3*3 and Active 5*5\n    private void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {\n        ItemUtils.checkActive(stack, cost, isClient, messageId);\n        if (!ItemUtils.isActive(stack)) {\n            ItemUtils.switchActive(stack, cost, isClient, messageId);\n            stack.getOrCreateTag().putBoolean(\"AOE5\", false);\n            if (isClient) {\n                ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"3*3\"));\n            }\n        } else {\n            if (isAOE5(stack)) {\n                ItemUtils.switchActive(stack, cost, isClient, messageId);\n                stack.getOrCreateTag().putBoolean(\"AOE5\", false);\n            } else {\n                stack.getOrCreateTag().putBoolean(\"AOE5\", true);\n                if (isClient) {\n                    ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"5*5\"));\n                }\n            }\n        }\n    }\n\n    private boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {\n        if (originalPos.equals(pos)) {\n            return false;\n        }\n        BlockState blockState = worldIn.getBlockState(pos);\n        if (blockState.getMaterial() == Material.AIR) {\n            return false;\n        }\n        if (blockState.getMaterial().isLiquid()) {\n            return false;\n        }\n        if (blockState.getBlock() instanceof OreBlock) {\n            return false;\n        }\n        if (blockState.getBlock() instanceof RedstoneOreBlock) {\n            return false;\n        }\n        return (Items.IRON_PICKAXE.isEffectiveOn(blockState));\n    }\n\n    private boolean isAOE5(ItemStack stack) {\n        return !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean(\"AOE5\");\n    }\n\n    // JackhammerItem\n    @Override\n    public boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {\n        if (!ItemUtils.isActive(stack)) {\n            return super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n        }\n        int radius = isAOE5(stack) ? 2 : 1;\n        for (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {\n            if (shouldBreak(worldIn, pos, additionalPos)) {\n                ToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);\n            }\n        }\n        return super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n    }\n\n    // PickaxeItem\n    @Override\n    public float getMiningSpeed(ItemStack stack, BlockState state) {\n        if (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {\n            // x4 diamond mining speed\n            return 32.0F;\n        } else {\n            return 0.5F;\n        }\n    }\n\n    // Item\n    @Override\n    public TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {\n        final ItemStack stack = player.getStackInHand(hand);\n        if (player.isSneaking()) {\n            switchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);\n            return new TypedActionResult<>(ActionResult.SUCCESS, stack);\n        }\n        return new TypedActionResult<>(ActionResult.PASS, stack);\n    }\n\n    @Override\n    public void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {\n        ItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);\n    }\n\n    @Environment(EnvType.CLIENT)\n    @Override\n    public void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {\n        ItemUtils.buildActiveTooltip(stack, tooltip);\n        if (ItemUtils.isActive(stack)) {\n            if (isAOE5(stack)) {\n                tooltip.add(new LiteralText(\"5*5\").formatted(Formatting.RED));\n            } else {\n                tooltip.add(new LiteralText(\"3*3\").formatted(Formatting.RED));\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "PhoneixS/TechReborn", "file": "src/main/java/techreborn/items/tool/industrial/IndustrialJackhammerItem.java", "last_update_at": "2021-03-12T06:48:49+00:00", "original_content": "public class IndustrialJackhammerItem extends JackhammerItem {\n\n    public IndustrialJackhammerItem() {\n        super(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);\n    }\n\n    // Cycle Inactive, Active 3*3 and Active 5*5\n    private void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {\n        ItemUtils.checkActive(stack, cost, isClient, messageId);\n        if (!ItemUtils.isActive(stack)) {\n            ItemUtils.switchActive(stack, cost, isClient, messageId);\n            stack.getOrCreateTag().putBoolean(\"AOE5\", false);\n            if (isClient) {\n                ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"3*3\"));\n            }\n        } else {\n            if (isAOE5(stack)) {\n                ItemUtils.switchActive(stack, cost, isClient, messageId);\n                stack.getOrCreateTag().putBoolean(\"AOE5\", false);\n            } else {\n                stack.getOrCreateTag().putBoolean(\"AOE5\", true);\n                if (isClient) {\n                    ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t(\"techreborn.message.setTo\") + \" \" + Formatting.GOLD + \"5*5\"));\n                }\n            }\n        }\n    }\n\n    private boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {\n        if (originalPos.equals(pos)) {\n            return false;\n        }\n        BlockState blockState = worldIn.getBlockState(pos);\n        if (blockState.getMaterial() == Material.AIR) {\n            return false;\n        }\n        if (blockState.getMaterial().isLiquid()) {\n            return false;\n        }\n        if (blockState.getBlock() instanceof OreBlock) {\n            return false;\n        }\n        if (blockState.getBlock() instanceof RedstoneOreBlock) {\n            return false;\n        }\n        return (Items.IRON_PICKAXE.isEffectiveOn(blockState));\n    }\n\n    private boolean isAOE5(ItemStack stack) {\n        return !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean(\"AOE5\");\n    }\n\n    // JackhammerItem\n    @Override\n    public boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {\n        if (!ItemUtils.isActive(stack)) {\n            return super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n        }\n        int radius = isAOE5(stack) ? 2 : 1;\n        for (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {\n            if (shouldBreak(worldIn, pos, additionalPos)) {\n                ToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);\n            }\n        }\n        return super.postMine(stack, worldIn, stateIn, pos, entityLiving);\n    }\n\n    // PickaxeItem\n    @Override\n    public float getMiningSpeed(ItemStack stack, BlockState state) {\n        if (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {\n            // x4 diamond mining speed\n            return 32.0F;\n        } else {\n            return 0.5F;\n        }\n    }\n\n    // Item\n    @Override\n    public TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {\n        final ItemStack stack = player.getStackInHand(hand);\n        if (player.isSneaking()) {\n            switchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);\n            return new TypedActionResult<>(ActionResult.SUCCESS, stack);\n        }\n        return new TypedActionResult<>(ActionResult.PASS, stack);\n    }\n\n    @Override\n    public void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {\n        ItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);\n    }\n\n    @Environment(EnvType.CLIENT)\n    @Override\n    public void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {\n        ItemUtils.buildActiveTooltip(stack, tooltip);\n        if (ItemUtils.isActive(stack)) {\n            if (isAOE5(stack)) {\n                tooltip.add(new LiteralText(\"5*5\").formatted(Formatting.RED));\n            } else {\n                tooltip.add(new LiteralText(\"3*3\").formatted(Formatting.RED));\n            }\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "0258fec1fbbbd04e532d61c0a501cd3898fe0f43", "ext": "java", "lang": "Java", "content": "public class MockXDSBridge extends XDSBridge {\n\n    /**\n     * Constructs ...\n     *\n     * @param config\n     */\n    public MockXDSBridge(XDSBridgeServiceContext config) {\n        super();\n        XDSBridge.serviceContext = config;\n    }\n\n    /**\n     * Method description\n     *\n     * @param service_name\n     * @param request\n     *\n     * @return\n     *\n     * @throws AxisFault\n     */\n    @Override\n    protected void beginTransaction(String service_name, OMElement request) throws SOAPFaultException {\n        String remoteIP = \"127.0.0.2\";\n        XLogger xlogger = XLogger.getInstance();\n        log_message = xlogger.getNewMessage(remoteIP);\n        log_message.setTestMessage(\"TEST\");\n    }\n\n    /**\n     * Method description\n     *\n     * @return\n     */\n    @Override\n    protected MessageContext getCurrentMessageContext() {\n        return new MockMessageContext();\n    }\n}\n", "class_id": 0, "repo": "kef/hieos", "file": "src/xdsbridge/src/test/java/com/vangent/hieos/services/xds/bridge/mock/MockXDSBridge.java", "last_update_at": "2021-11-27T10:56:53+00:00", "original_content": "public class MockXDSBridge extends XDSBridge {\n\n    /**\n     * Constructs ...\n     *\n     * @param config\n     */\n    public MockXDSBridge(XDSBridgeServiceContext config) {\n        super();\n        XDSBridge.serviceContext = config;\n    }\n\n    /**\n     * Method description\n     *\n     * @param service_name\n     * @param request\n     *\n     * @return\n     *\n     * @throws AxisFault\n     */\n    @Override\n    protected void beginTransaction(String service_name, OMElement request) throws SOAPFaultException {\n        String remoteIP = \"127.0.0.2\";\n        XLogger xlogger = XLogger.getInstance();\n        log_message = xlogger.getNewMessage(remoteIP);\n        log_message.setTestMessage(\"TEST\");\n    }\n\n    /**\n     * Method description\n     *\n     * @return\n     */\n    @Override\n    protected MessageContext getCurrentMessageContext() {\n        return new MockMessageContext();\n    }\n}\n", "refactored": false}
{"hexsha": "9118fce3ef781ce323072a537ba766e7bc58d1c4", "ext": "java", "lang": "Java", "content": "public class EinfacheGui implements ActionListener, KeyListener {\n\n    private JFrame myFrame;\n\n    private Container myContentPane;\n\n    private JButton myButtonClickMich;\n\n    private int height = 350;\n\n    private int width = 350;\n\n    private double factor = 0.3;\n\n    public EinfacheGui() {\n        myFrame = new JFrame(\"Einfache Gui\");\n        myFrame.setSize(width, height);\n        myFrame.setLocationRelativeTo(null);\n        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        myButtonClickMich = new JButton(\"Button\");\n        myButtonClickMich.addActionListener(this);\n        myButtonClickMich.addKeyListener(this);\n        myFrame.add(myButtonClickMich);\n        myFrame.setVisible(true);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        double w = myFrame.getWidth() - myFrame.getWidth() * factor;\n        double h = myFrame.getHeight() - myFrame.getHeight() * factor;\n        if ((w + h) < 150)\n            myFrame.setSize(width, height);\n        else\n            myFrame.setSize((int) w, (int) h);\n        myFrame.setLocationRelativeTo(null);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {\n            JOptionPane.showMessageDialog(myFrame, \"Geschafft\");\n        }\n        System.out.println(e.getExtendedKeyCode() + \" pressed\");\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n    }\n}\n", "class_id": 0, "repo": "thieleju/studium", "file": "Programmiertechnik_II/Workbook4/EinfacheGui.java", "last_update_at": "2021-11-17T12:30:49+00:00", "original_content": "public class EinfacheGui implements ActionListener, KeyListener {\n\n    private JFrame myFrame;\n\n    private Container myContentPane;\n\n    private JButton myButtonClickMich;\n\n    private int height = 350;\n\n    private int width = 350;\n\n    private double factor = 0.3;\n\n    public EinfacheGui() {\n        myFrame = new JFrame(\"Einfache Gui\");\n        myFrame.setSize(width, height);\n        myFrame.setLocationRelativeTo(null);\n        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        myButtonClickMich = new JButton(\"Button\");\n        myButtonClickMich.addActionListener(this);\n        myButtonClickMich.addKeyListener(this);\n        myFrame.add(myButtonClickMich);\n        myFrame.setVisible(true);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        double w = myFrame.getWidth() - myFrame.getWidth() * factor;\n        double h = myFrame.getHeight() - myFrame.getHeight() * factor;\n        if ((w + h) < 150)\n            myFrame.setSize(width, height);\n        else\n            myFrame.setSize((int) w, (int) h);\n        myFrame.setLocationRelativeTo(null);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {\n            JOptionPane.showMessageDialog(myFrame, \"Geschafft\");\n        }\n        System.out.println(e.getExtendedKeyCode() + \" pressed\");\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n    }\n}\n", "refactored": false}
{"hexsha": "895b29ca56c1e747cd96f886c95fd5020c83bf5d", "ext": "java", "lang": "Java", "content": "public class ConnectionOpeningImpl implements IBestPractice {\n\n    @Value(\"${connections.connectionOpening.title}\")\n    private String overviewTitle;\n\n    @Value(\"${connections.connectionOpening.detailedTitle}\")\n    private String detailTitle;\n\n    @Value(\"${connections.connectionOpening.desc}\")\n    private String aboutText;\n\n    @Value(\"${connections.connectionOpening.url}\")\n    private String learnMoreUrl;\n\n    @Value(\"${connections.connectionOpening.selfEvaluation}\")\n    private String textResult;\n\n    @Override\n    public AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {\n        ConnectionOpeningResult result = new ConnectionOpeningResult();\n        result.setSelfTest(true);\n        result.setAboutText(aboutText);\n        result.setDetailTitle(detailTitle);\n        result.setLearnMoreUrl(learnMoreUrl);\n        result.setOverviewTitle(overviewTitle);\n        result.setResultText(textResult);\n        result.setResultType(BPResultType.SELF_TEST);\n        return result;\n    }\n}\n", "class_id": 0, "repo": "j420247/ARO", "file": "5.0.0/ARO.Core/src/main/java/com/att/aro/core/bestpractice/impl/ConnectionOpeningImpl.java", "last_update_at": "2021-11-12T11:34:34+00:00", "original_content": "public class ConnectionOpeningImpl implements IBestPractice {\n\n    @Value(\"${connections.connectionOpening.title}\")\n    private String overviewTitle;\n\n    @Value(\"${connections.connectionOpening.detailedTitle}\")\n    private String detailTitle;\n\n    @Value(\"${connections.connectionOpening.desc}\")\n    private String aboutText;\n\n    @Value(\"${connections.connectionOpening.url}\")\n    private String learnMoreUrl;\n\n    @Value(\"${connections.connectionOpening.selfEvaluation}\")\n    private String textResult;\n\n    @Override\n    public AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {\n        ConnectionOpeningResult result = new ConnectionOpeningResult();\n        result.setSelfTest(true);\n        result.setAboutText(aboutText);\n        result.setDetailTitle(detailTitle);\n        result.setLearnMoreUrl(learnMoreUrl);\n        result.setOverviewTitle(overviewTitle);\n        result.setResultText(textResult);\n        result.setResultType(BPResultType.SELF_TEST);\n        return result;\n    }\n}\n", "refactored": false}
{"hexsha": "b7cad21f3c37603e9f2c3cc34f0e1a6e357d10f3", "ext": "java", "lang": "Java", "content": "public class BulletEffectAttractive implements BulletEffect {\n\n    @Override\n    public String getID() {\n        return \"attractive\";\n    }\n\n    @Override\n    public boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {\n        if (hitEntity instanceof EntityAnimal) {\n            ((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);\n            return true;\n        }\n        return false;\n    }\n\n    @SideOnly(Side.CLIENT)\n    @Override\n    public void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {\n        ParticleBuilder glitter = new ParticleBuilder(10);\n        glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n        glitter.disableMotionCalculation();\n        glitter.setCollision(true);\n        ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {\n            build.setLifetime(RandUtil.nextInt(20, 40));\n            build.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));\n            build.setAlphaFunction(new InterpFadeInOut(0f, 1f));\n            build.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));\n            build.setDeceleration(new Vec3d(0.7, 0.7, 0.7));\n            double radius = 2 * RandUtil.nextFloat();\n            double theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();\n            double x = radius * MathHelper.cos((float) theta);\n            double z = radius * MathHelper.sin((float) theta);\n            build.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));\n        });\n    }\n\n    @SideOnly(Side.CLIENT)\n    @Override\n    public void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {\n        ParticleBuilder glitter = new ParticleBuilder(10);\n        glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n        glitter.setCollision(true);\n        glitter.disableMotionCalculation();\n        glitter.disableRandom();\n        ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {\n            build.setScaleFunction(new InterpScale(0.5f, 0));\n            build.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));\n        });\n    }\n\n    @Override\n    @Nullable\n    public SoundEvent getImpactSound() {\n        return RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;\n    }\n}\n", "class_id": 0, "repo": "Demoniaque/Shotguns-And-Glitter", "file": "src/main/java/com/teamwizardry/shotgunsandglitter/common/effects/BulletEffectAttractive.java", "last_update_at": "2021-01-07T21:18:51+00:00", "original_content": "public class BulletEffectAttractive implements BulletEffect {\n\n    @Override\n    public String getID() {\n        return \"attractive\";\n    }\n\n    @Override\n    public boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {\n        if (hitEntity instanceof EntityAnimal) {\n            ((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);\n            return true;\n        }\n        return false;\n    }\n\n    @SideOnly(Side.CLIENT)\n    @Override\n    public void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {\n        ParticleBuilder glitter = new ParticleBuilder(10);\n        glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n        glitter.disableMotionCalculation();\n        glitter.setCollision(true);\n        ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {\n            build.setLifetime(RandUtil.nextInt(20, 40));\n            build.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));\n            build.setAlphaFunction(new InterpFadeInOut(0f, 1f));\n            build.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));\n            build.setDeceleration(new Vec3d(0.7, 0.7, 0.7));\n            double radius = 2 * RandUtil.nextFloat();\n            double theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();\n            double x = radius * MathHelper.cos((float) theta);\n            double z = radius * MathHelper.sin((float) theta);\n            build.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));\n        });\n    }\n\n    @SideOnly(Side.CLIENT)\n    @Override\n    public void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {\n        ParticleBuilder glitter = new ParticleBuilder(10);\n        glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));\n        glitter.setCollision(true);\n        glitter.disableMotionCalculation();\n        glitter.disableRandom();\n        ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {\n            build.setScaleFunction(new InterpScale(0.5f, 0));\n            build.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));\n        });\n    }\n\n    @Override\n    @Nullable\n    public SoundEvent getImpactSound() {\n        return RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;\n    }\n}\n", "refactored": false}
{"hexsha": "71f70801a9b50116a217f6493cec5ea7f30a0487", "ext": "java", "lang": "Java", "content": "@ServiceComponentRenderer\npublic class CryptoAdapterRegistrationRenderer implements Renderer {\n\n    private final String INLINE_JS = \"function setCryptoKey(key) {\\n\" + \"    var buffer, view;\\n\" + \"    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\\n\" + \"        try {\\n\" + \"            buffer = new ArrayBuffer(key.length);\\n\" + \"            view = new Uint8Array(buffer);\\n\" + \"            view.set(key);\\n\" + \"        } catch (ignored) {}\\n\" + \"    }\\n\" + \"    CryptoAdapter.setKey(buffer);\\n\" + \"}\\n\" + \"debug && $A.log('CryptoAdapter registering');\\n\" + \"var CryptoAdapter = $A.storageService.CryptoAdapter;\\n\" + \"CryptoAdapter.register();\\n\" + \"if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\\n\" + \"    $A.log('CryptoAdapter was not registered');\\n\" + \"    return;\\n\" + \"}\\n\" + \"setCryptoKey(key);\\n\";\n\n    private ConfigAdapter configAdapter;\n\n    @Override\n    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {\n        Boolean debug = (Boolean) component.getAttributes().getValue(\"debugLoggingEnabled\");\n        String key = configAdapter.getEncryptionKey();\n        renderContext.pushScript();\n        renderContext.getCurrent().append(\"(function(debug, key){\\n\").append(INLINE_JS).append(\"\\n}(\").append(String.valueOf(debug)).append(\",\").append(String.valueOf(key)).append(\"));\");\n        renderContext.popScript();\n    }\n\n    @Inject\n    public void setConfigAdapter(ConfigAdapter configAdapter) {\n        this.configAdapter = configAdapter;\n    }\n}\n", "class_id": 0, "repo": "madmax983/aura", "file": "aura-components/src/main/java/org/auraframework/components/aura/CryptoAdapterRegistrationRenderer.java", "last_update_at": "2021-08-11T08:25:14+00:00", "original_content": "@ServiceComponentRenderer\npublic class CryptoAdapterRegistrationRenderer implements Renderer {\n\n    private final String INLINE_JS = \"function setCryptoKey(key) {\\n\" + \"    var buffer, view;\\n\" + \"    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\\n\" + \"        try {\\n\" + \"            buffer = new ArrayBuffer(key.length);\\n\" + \"            view = new Uint8Array(buffer);\\n\" + \"            view.set(key);\\n\" + \"        } catch (ignored) {}\\n\" + \"    }\\n\" + \"    CryptoAdapter.setKey(buffer);\\n\" + \"}\\n\" + \"debug && $A.log('CryptoAdapter registering');\\n\" + \"var CryptoAdapter = $A.storageService.CryptoAdapter;\\n\" + \"CryptoAdapter.register();\\n\" + \"if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\\n\" + \"    $A.log('CryptoAdapter was not registered');\\n\" + \"    return;\\n\" + \"}\\n\" + \"setCryptoKey(key);\\n\";\n\n    private ConfigAdapter configAdapter;\n\n    @Override\n    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {\n        Boolean debug = (Boolean) component.getAttributes().getValue(\"debugLoggingEnabled\");\n        String key = configAdapter.getEncryptionKey();\n        renderContext.pushScript();\n        renderContext.getCurrent().append(\"(function(debug, key){\\n\").append(INLINE_JS).append(\"\\n}(\").append(String.valueOf(debug)).append(\",\").append(String.valueOf(key)).append(\"));\");\n        renderContext.popScript();\n    }\n\n    @Inject\n    public void setConfigAdapter(ConfigAdapter configAdapter) {\n        this.configAdapter = configAdapter;\n    }\n}\n", "refactored": false}
{"hexsha": "99d08e11b8fd9b4837646757477e56f3f5aea269", "ext": "java", "lang": "Java", "content": "public class ForLoopCalculator implements Calculator {\n\n    public long sumUp(long[] numbers) {\n        long total = 0;\n        for (long i : numbers) {\n            total += i;\n        }\n        return total;\n    }\n}\n", "class_id": 0, "repo": "gaohanghang/Java-Concurrency-Multithreading-in-Practice", "file": "doc/doc1/ForLoopCalculator.java", "last_update_at": "2021-11-04T13:49:22+00:00", "original_content": "public class ForLoopCalculator implements Calculator {\n\n    public long sumUp(long[] numbers) {\n        long total = 0;\n        for (long i : numbers) {\n            total += i;\n        }\n        return total;\n    }\n}\n", "refactored": false}
{"hexsha": "3895af397ca10b213eeedd58eb68713c339171f4", "ext": "java", "lang": "Java", "content": "public class BinaryTree {\n\n    private String symbol;\n\n    private int start;\n\n    private int end;\n\n    private BinaryTree leftChild;\n\n    private BinaryTree rightChild;\n\n    private boolean isLexical;\n\n    private BinaryTree parent;\n\n    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode, BinaryTree rightChildNode, boolean isLexical) {\n        this.symbol = symbol;\n        this.start = start;\n        this.end = end;\n        this.leftChild = leftChildNode;\n        this.rightChild = rightChildNode;\n        this.isLexical = isLexical;\n        this.parent = null;\n        if (leftChild != null) {\n            leftChild.parent = this;\n        }\n        if (rightChild != null) {\n            rightChild.parent = this;\n        }\n    }\n\n    private static String canonicalizeTreeString(String newTreeStr) {\n        return newTreeStr.trim().replaceAll(\"\\\\s+\\\\)\", \")\").replaceAll(\"\\\\s+\", \" \");\n    }\n\n    public String getAsOneLineString() {\n        // TODO: speedup.\n        return canonicalizeTreeString(getAsPennTreebankString());\n    }\n\n    /**\n     * Gets a string representation of this parse that looks like the typical\n     * Penn Treebank style parse.\n     *\n     * Example:\n     *  ((ROOT (S (NP (NN time))\n     *           (VP (VBZ flies)\n     *               (PP (IN like)\n     *                   (NP (DT an)\n     *                       (NN arrow)))))))\n     *\n     * @return A string representing this parse.\n     */\n    public String getAsPennTreebankString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        getAsPennTreebankString(1, 1, sb);\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {\n        int numSpaces = indent - numOnLine;\n        int i = 0;\n        while (i < numSpaces) try {\n            sb.append(\" \");\n        } finally {\n            i++;\n        }\n        if (isLexical) {\n            sb.append(getSymbol());\n        } else {\n            sb.append(\"(\");\n            sb.append(getSymbol());\n            // If this is a constant instead, then we have each depth in one column.\n            int numNewChars = 1 + getSymbol().length();\n            if (leftChild != null) {\n                //sb.append(\"\\n\");\n                leftChild.getAsPennTreebankString(indent + numNewChars + 1, indent + numNewChars, sb);\n            }\n            if (rightChild != null) {\n                sb.append(\"\\n\");\n                rightChild.getAsPennTreebankString(indent + numNewChars + 1, 0, sb);\n            }\n            sb.append(\")\");\n        }\n    }\n\n    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Visit this node.\n        function.call(this);\n        // Pre-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.preOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.preOrderTraversal(function);\n        }\n    }\n\n    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // In-order traversal of left child.\n        if (leftChild != null) {\n            leftChild.inOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n        // In-order traversal of right child.\n        if (rightChild != null) {\n            rightChild.inOrderTraversal(function);\n        }\n    }\n\n    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Post-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.postOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.postOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public boolean isLeaf() {\n        return leftChild == null && rightChild == null;\n    }\n\n    public boolean isLexical() {\n        return isLexical;\n    }\n\n    public BinaryTree getLeftChild() {\n        return leftChild;\n    }\n\n    public BinaryTree getRightChild() {\n        return rightChild;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n\n    public void setSymbol(String symbol) {\n        this.symbol = symbol;\n    }\n\n    public BinaryTree getParent() {\n        return parent;\n    }\n\n    /**\n     * Updates all the start end fields, treating the current node as the root.\n     */\n    public void updateStartEnd() {\n        ArrayList<BinaryTree> leaves = getLeaves();\n        int i = 0;\n        while (i < leaves.size()) try {\n            BinaryTree leaf = leaves.get(i);\n            leaf.start = i;\n            leaf.end = i + 1;\n        } finally {\n            i++;\n        }\n        postOrderTraversal(new UpdateStartEnd());\n    }\n\n    /**\n     * Gets the leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLeaves() {\n        LeafCollector leafCollector = new LeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n\n    /**\n     * Gets the lexical leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLexicalLeaves() {\n        LexicalLeafCollector leafCollector = new LexicalLeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n\n    /**\n     * Gets the leaf containing the specified token index.\n     */\n    public BinaryTree getLeafAt(int idx) {\n        BinaryTree leaf = null;\n        for (BinaryTree l : this.getLeaves()) {\n            if (l.start <= idx && idx < l.end) {\n                leaf = l;\n            }\n        }\n        return leaf;\n    }\n\n    /**\n     * Gets the lexical item ids comprising the sentence.\n     */\n    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        int[] sent = new int[leaves.size()];\n        int i = 0;\n        while (i < sent.length) try {\n            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);\n        } finally {\n            i++;\n        }\n        return sent;\n    }\n\n    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> labels = new ArrayList<String>(leaves.size());\n        int i = 0;\n        while (i < leaves.size()) try {\n            labels.add(leaves.get(i).symbol);\n        } finally {\n            i++;\n        }\n        return new Sentence(lexAlphabet, labels);\n    }\n\n    public List<String> getWords() {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> words = new ArrayList<String>(leaves.size());\n        int i = 0;\n        while (i < leaves.size()) try {\n            words.add(leaves.get(i).symbol);\n        } finally {\n            i++;\n        }\n        return words;\n    }\n\n    private class LeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf()) {\n                leaves.add(node);\n            }\n        }\n    }\n\n    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf() && node.isLexical()) {\n                leaves.add(node);\n            }\n        }\n    }\n\n    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {\n\n        @Override\n        public void call(BinaryTree node) {\n            if (!node.isLeaf()) {\n                node.start = node.leftChild.start;\n                if (node.rightChild == null) {\n                    node.end = node.leftChild.end;\n                } else {\n                    node.end = node.rightChild.end;\n                }\n            }\n        }\n    }\n\n    /**\n     * Intern all the strings.\n     */\n    public void intern() {\n        symbol = symbol.intern();\n        if (leftChild != null) {\n            leftChild.intern();\n        }\n        if (rightChild != null) {\n            rightChild.intern();\n        }\n    }\n\n    public NaryTree collapseToNary() {\n        ArrayList<NaryTree> children = null;\n        if (!isLeaf()) {\n            assert (leftChild != null);\n            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();\n            addToQueue(queue, leftChild);\n            addToQueue(queue, rightChild);\n            children = new ArrayList<NaryTree>(queue);\n        }\n        return new NaryTree(symbol, start, end, children, isLexical);\n    }\n\n    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {\n        if (child == null) {\n            return;\n        }\n        String symbolStr = child.getSymbol();\n        if (GrammarConstants.isBinarized(symbolStr)) {\n            addToQueue(queue, child.leftChild);\n            addToQueue(queue, child.rightChild);\n        } else {\n            queue.add(child.collapseToNary());\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"BinaryTreeNode [symbol=\" + getSymbol() + \"_{\" + start + \", \" + end + \"}, leftChildNode=\" + leftChild + \", rightChildNode=\" + rightChild + \"]\";\n    }\n}\n", "class_id": 0, "repo": "mgormley/pacaya", "file": "src/main/java/edu/jhu/pacaya/parse/cky/data/BinaryTree.java", "last_update_at": "2021-07-25T23:58:37+00:00", "original_content": "public class BinaryTree {\n\n    private String symbol;\n\n    private int start;\n\n    private int end;\n\n    private BinaryTree leftChild;\n\n    private BinaryTree rightChild;\n\n    private boolean isLexical;\n\n    private BinaryTree parent;\n\n    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode, BinaryTree rightChildNode, boolean isLexical) {\n        this.symbol = symbol;\n        this.start = start;\n        this.end = end;\n        this.leftChild = leftChildNode;\n        this.rightChild = rightChildNode;\n        this.isLexical = isLexical;\n        this.parent = null;\n        if (leftChild != null) {\n            leftChild.parent = this;\n        }\n        if (rightChild != null) {\n            rightChild.parent = this;\n        }\n    }\n\n    private static String canonicalizeTreeString(String newTreeStr) {\n        return newTreeStr.trim().replaceAll(\"\\\\s+\\\\)\", \")\").replaceAll(\"\\\\s+\", \" \");\n    }\n\n    public String getAsOneLineString() {\n        // TODO: speedup.\n        return canonicalizeTreeString(getAsPennTreebankString());\n    }\n\n    /**\n     * Gets a string representation of this parse that looks like the typical\n     * Penn Treebank style parse.\n     *\n     * Example:\n     *  ((ROOT (S (NP (NN time))\n     *           (VP (VBZ flies)\n     *               (PP (IN like)\n     *                   (NP (DT an)\n     *                       (NN arrow)))))))\n     *\n     * @return A string representing this parse.\n     */\n    public String getAsPennTreebankString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        getAsPennTreebankString(1, 1, sb);\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {\n        int numSpaces = indent - numOnLine;\n        for (int i = 0; i < numSpaces; i++) {\n            sb.append(\" \");\n        }\n        if (isLexical) {\n            sb.append(getSymbol());\n        } else {\n            sb.append(\"(\");\n            sb.append(getSymbol());\n            // If this is a constant instead, then we have each depth in one column.\n            int numNewChars = 1 + getSymbol().length();\n            if (leftChild != null) {\n                //sb.append(\"\\n\");\n                leftChild.getAsPennTreebankString(indent + numNewChars + 1, indent + numNewChars, sb);\n            }\n            if (rightChild != null) {\n                sb.append(\"\\n\");\n                rightChild.getAsPennTreebankString(indent + numNewChars + 1, 0, sb);\n            }\n            sb.append(\")\");\n        }\n    }\n\n    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Visit this node.\n        function.call(this);\n        // Pre-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.preOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.preOrderTraversal(function);\n        }\n    }\n\n    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // In-order traversal of left child.\n        if (leftChild != null) {\n            leftChild.inOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n        // In-order traversal of right child.\n        if (rightChild != null) {\n            rightChild.inOrderTraversal(function);\n        }\n    }\n\n    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {\n        // Post-order traversal of each child.\n        if (leftChild != null) {\n            leftChild.postOrderTraversal(function);\n        }\n        if (rightChild != null) {\n            rightChild.postOrderTraversal(function);\n        }\n        // Visit this node.\n        function.call(this);\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public boolean isLeaf() {\n        return leftChild == null && rightChild == null;\n    }\n\n    public boolean isLexical() {\n        return isLexical;\n    }\n\n    public BinaryTree getLeftChild() {\n        return leftChild;\n    }\n\n    public BinaryTree getRightChild() {\n        return rightChild;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n\n    public void setSymbol(String symbol) {\n        this.symbol = symbol;\n    }\n\n    public BinaryTree getParent() {\n        return parent;\n    }\n\n    /**\n     * Updates all the start end fields, treating the current node as the root.\n     */\n    public void updateStartEnd() {\n        ArrayList<BinaryTree> leaves = getLeaves();\n        for (int i = 0; i < leaves.size(); i++) {\n            BinaryTree leaf = leaves.get(i);\n            leaf.start = i;\n            leaf.end = i + 1;\n        }\n        postOrderTraversal(new UpdateStartEnd());\n    }\n\n    /**\n     * Gets the leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLeaves() {\n        LeafCollector leafCollector = new LeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n\n    /**\n     * Gets the lexical leaves of this tree in left-to-right order.\n     */\n    public ArrayList<BinaryTree> getLexicalLeaves() {\n        LexicalLeafCollector leafCollector = new LexicalLeafCollector();\n        postOrderTraversal(leafCollector);\n        return leafCollector.leaves;\n    }\n\n    /**\n     * Gets the leaf containing the specified token index.\n     */\n    public BinaryTree getLeafAt(int idx) {\n        BinaryTree leaf = null;\n        for (BinaryTree l : this.getLeaves()) {\n            if (l.start <= idx && idx < l.end) {\n                leaf = l;\n            }\n        }\n        return leaf;\n    }\n\n    /**\n     * Gets the lexical item ids comprising the sentence.\n     */\n    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        int[] sent = new int[leaves.size()];\n        for (int i = 0; i < sent.length; i++) {\n            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);\n        }\n        return sent;\n    }\n\n    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> labels = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {\n            labels.add(leaves.get(i).symbol);\n        }\n        return new Sentence(lexAlphabet, labels);\n    }\n\n    public List<String> getWords() {\n        ArrayList<BinaryTree> leaves = getLexicalLeaves();\n        ArrayList<String> words = new ArrayList<String>(leaves.size());\n        for (int i = 0; i < leaves.size(); i++) {\n            words.add(leaves.get(i).symbol);\n        }\n        return words;\n    }\n\n    private class LeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf()) {\n                leaves.add(node);\n            }\n        }\n    }\n\n    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {\n\n        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();\n\n        @Override\n        public void call(BinaryTree node) {\n            if (node.isLeaf() && node.isLexical()) {\n                leaves.add(node);\n            }\n        }\n    }\n\n    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {\n\n        @Override\n        public void call(BinaryTree node) {\n            if (!node.isLeaf()) {\n                node.start = node.leftChild.start;\n                if (node.rightChild == null) {\n                    node.end = node.leftChild.end;\n                } else {\n                    node.end = node.rightChild.end;\n                }\n            }\n        }\n    }\n\n    /**\n     * Intern all the strings.\n     */\n    public void intern() {\n        symbol = symbol.intern();\n        if (leftChild != null) {\n            leftChild.intern();\n        }\n        if (rightChild != null) {\n            rightChild.intern();\n        }\n    }\n\n    public NaryTree collapseToNary() {\n        ArrayList<NaryTree> children = null;\n        if (!isLeaf()) {\n            assert (leftChild != null);\n            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();\n            addToQueue(queue, leftChild);\n            addToQueue(queue, rightChild);\n            children = new ArrayList<NaryTree>(queue);\n        }\n        return new NaryTree(symbol, start, end, children, isLexical);\n    }\n\n    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {\n        if (child == null) {\n            return;\n        }\n        String symbolStr = child.getSymbol();\n        if (GrammarConstants.isBinarized(symbolStr)) {\n            addToQueue(queue, child.leftChild);\n            addToQueue(queue, child.rightChild);\n        } else {\n            queue.add(child.collapseToNary());\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"BinaryTreeNode [symbol=\" + getSymbol() + \"_{\" + start + \", \" + end + \"}, leftChildNode=\" + leftChild + \", rightChildNode=\" + rightChild + \"]\";\n    }\n}\n", "refactored": true}
{"hexsha": "6010ce895b3af2938615bae54d10caa4a458667d", "ext": "java", "lang": "Java", "content": "public class SegmentHandler {\n\n    public LinkedList<vec> segments;\n\n    public LinkedList<EnumFacing> segmentbottomsides;\n\n    public LinkedList<EnumFacing> segmenttopsides;\n\n    public World world;\n\n    public grappleArrow arrow;\n\n    vec prevhookpos = null;\n\n    vec prevplayerpos = null;\n\n    final double bendoffset = 0.05;\n\n    final double intoblock = 0.05;\n\n    public SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {\n        segments = new LinkedList<vec>();\n        segments.add(hookpos);\n        segments.add(playerpos);\n        segmentbottomsides = new LinkedList<EnumFacing>();\n        segmentbottomsides.add(null);\n        segmentbottomsides.add(null);\n        segmenttopsides = new LinkedList<EnumFacing>();\n        segmenttopsides.add(null);\n        segmenttopsides.add(null);\n        this.world = w;\n        this.arrow = arrow;\n        this.prevhookpos = new vec(hookpos);\n        this.prevplayerpos = new vec(playerpos);\n    }\n\n    public void forceSetPos(vec hookpos, vec playerpos) {\n        this.prevhookpos = new vec(hookpos);\n        this.prevplayerpos = new vec(playerpos);\n        this.segments.set(0, new vec(hookpos));\n        this.segments.set(this.segments.size() - 1, new vec(playerpos));\n    }\n\n    double ropelen;\n\n    public void updatepos(vec hookpos, vec playerpos, double ropelen) {\n        segments.set(0, hookpos);\n        segments.set(segments.size() - 1, playerpos);\n        this.ropelen = ropelen;\n    }\n\n    public void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {\n        if (prevhookpos == null) {\n            prevhookpos = hookpos;\n            prevplayerpos = playerpos;\n        }\n        segments.set(0, hookpos);\n        segments.set(segments.size() - 1, playerpos);\n        this.ropelen = ropelen;\n        vec closest = segments.get(segments.size() - 2);\n        while (true) {\n            if (segments.size() == 2) {\n                break;\n            }\n            int index = segments.size() - 2;\n            closest = segments.get(index);\n            EnumFacing bottomside = segmentbottomsides.get(index);\n            EnumFacing topside = segmenttopsides.get(index);\n            vec ropevec = playerpos.sub(closest);\n            vec beforepoint = segments.get(index - 1);\n            vec edgevec = getnormal(bottomside).cross(getnormal(topside));\n            vec planenormal = beforepoint.sub(closest).cross(edgevec);\n            if (ropevec.dot(planenormal) > 0) {\n                this.removesegment(index);\n            } else {\n                break;\n            }\n        }\n        vec farthest = segments.get(1);\n        if (movinghook) {\n            while (true) {\n                if (segments.size() == 2) {\n                    break;\n                }\n                int index = 1;\n                farthest = segments.get(index);\n                EnumFacing bottomside = segmentbottomsides.get(index);\n                EnumFacing topside = segmenttopsides.get(index);\n                vec ropevec = farthest.sub(hookpos);\n                vec beforepoint = segments.get(index + 1);\n                vec edgevec = getnormal(bottomside).cross(getnormal(topside));\n                vec planenormal = beforepoint.sub(farthest).cross(edgevec);\n                if (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {\n                    //\t\t\t\t\tSystem.out.println(\"removed farthest\");\n                    this.removesegment(index);\n                } else {\n                    break;\n                }\n            }\n            while (true) {\n                if (this.getDistToFarthest() > ropelen) {\n                    this.removesegment(1);\n                } else {\n                    break;\n                }\n            }\n        }\n        if (movinghook) {\n            farthest = segments.get(1);\n            vec prevfarthest = farthest;\n            if (segments.size() == 2) {\n                prevfarthest = prevplayerpos;\n            }\n            updatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);\n        }\n        vec prevclosest = closest;\n        if (segments.size() == 2) {\n            prevclosest = prevhookpos;\n        }\n        updatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);\n        prevhookpos = hookpos;\n        prevplayerpos = playerpos;\n    }\n\n    public void removesegment(int index) {\n        segments.remove(index);\n        segmentbottomsides.remove(index);\n        segmenttopsides.remove(index);\n        if (!this.world.isRemote) {\n            SegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);\n            vec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n            grapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n        }\n    }\n\n    public void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {\n        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);\n        // if rope hit block\n        if (bottomraytraceresult != null) {\n            if (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {\n                //        \t\tSystem.out.println(\"Warning: prev collision\");\n                return;\n            }\n            //        \tSystem.out.println(bottomraytraceresult.typeOfHit);\n            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);\n            /*            this.arrow.debugpos = bottomhitvec;\n            this.arrow.debugpos2 = bottom;\n            this.arrow.debugpos3 = top;*/\n            EnumFacing bottomside = bottomraytraceresult.sideHit;\n            vec bottomnormal = this.getnormal(bottomside);\n            //            double ropelen = top.sub(bottom).length();\n            double prevropelen = prevtop.sub(prevbottom).length();\n            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom\n            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));\n            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);\n            /*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option1;\n            \tcornerlinedist = cornerbound1.sub(bound_option1).length();\n            }*/\n            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);\n            /*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option2;\n            \tcornerlinedist = cornerbound1.sub(bound_option2).length();\n            }*/\n            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);\n            //            if (cornerbound2 != null) {\n            for (vec cornerbound2 : new vec[] { bound_option1, bound_option2, bound_option3 }) {\n                if (cornerbound2 == null) {\n                    continue;\n                }\n                // the corner must be in the line (cornerbound2, cornerbound1)\n                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);\n                if (cornerraytraceresult != null) {\n                    vec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);\n                    EnumFacing cornerside = cornerraytraceresult.sideHit;\n                    if (cornerside == bottomside || cornerside.getOpposite() == bottomside) {\n                        //                \t\tSystem.out.println(\"Warning: corner is same or opposite of bottomside\");\n                        continue;\n                    } else {\n                        // add a bend around the corner\n                        vec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));\n                        vec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));\n                        vec topropevec = bend.sub(top);\n                        vec bottomropevec = bend.sub(bottom);\n                        // ignore bends that are too close to another bend\n                        if (topropevec.length() < 0.05) {\n                            if (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {\n                                //                    \t\t\tSystem.out.println(\"Warning: top bend is too close\");\n                                continue;\n                            }\n                        }\n                        if (bottomropevec.length() < 0.05) {\n                            if (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {\n                                //                    \t\t\tSystem.out.println(\"Warning: bottom bend is too close\");\n                                continue;\n                            }\n                        }\n                        this.actuallyaddsegment(index, bend, bottomside, cornerside);\n                        // if not enough rope length left, undo\n                        if (this.getDistToAnchor() + .2 > this.ropelen) {\n                            //                \t\t\tSystem.out.println(\"Warning: not enough length left, removing\");\n                            this.removesegment(index);\n                            continue;\n                        }\n                        // now to recurse on top section of rope\n                        double newropelen = topropevec.length() + bottomropevec.length();\n                        double prevtoptobend = topropevec.length() * prevropelen / newropelen;\n                        vec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));\n                        if (numberrecursions < 10) {\n                            updatesegment(top, prevtop, bend, prevbend, index, numberrecursions + 1);\n                        } else {\n                            System.out.println(\"Warning: number recursions exceeded\");\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    public vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {\n        vec linevec = linepoint2.sub(linepoint1);\n        if (linevec.dot(planenormal) == 0) {\n            return null;\n        }\n        double d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);\n        return linepoint1.add(linevec.mult(d));\n    }\n\n    public vec getnormal(EnumFacing facing) {\n        Vec3i facingvec = facing.getDirectionVec();\n        return new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());\n    }\n\n    public boolean hookpastbend(double ropelen) {\n        return (this.getDistToFarthest() > ropelen);\n    }\n\n    public BlockPos getbendblock(int index) {\n        vec bendpos = this.segments.get(index);\n        bendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));\n        bendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));\n        return new BlockPos(bendpos.x, bendpos.y, bendpos.z);\n    }\n\n    public void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {\n        segments.add(index, bendpoint);\n        segmentbottomsides.add(index, bottomside);\n        segmenttopsides.add(index, topside);\n        if (!this.world.isRemote) {\n            SegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);\n            vec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n            grapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n        }\n    }\n\n    public void print() {\n        int i = 1;\n        while (i < segments.size() - 1) try {\n            System.out.print(i);\n            System.out.print(\" \");\n            System.out.print(segmenttopsides.get(i).toString());\n            System.out.print(\" \");\n            System.out.print(segmentbottomsides.get(i).toString());\n            System.out.print(\" \");\n            segments.get(i).print();\n        } finally {\n            i++;\n        }\n    }\n\n    public vec getclosest(vec hookpos) {\n        segments.set(0, hookpos);\n        return segments.get(segments.size() - 2);\n    }\n\n    public double getDistToAnchor() {\n        double dist = 0;\n        int i = 0;\n        while (i < segments.size() - 2) try {\n            dist += segments.get(i).sub(segments.get(i + 1)).length();\n        } finally {\n            i++;\n        }\n        return dist;\n    }\n\n    public vec getfarthest() {\n        return segments.get(1);\n    }\n\n    public double getDistToFarthest() {\n        double dist = 0;\n        int i = 1;\n        while (i < segments.size() - 1) try {\n            dist += segments.get(i).sub(segments.get(i + 1)).length();\n        } finally {\n            i++;\n        }\n        return dist;\n    }\n\n    public double getDist(vec hookpos, vec playerpos) {\n        segments.set(0, hookpos);\n        segments.set(segments.size() - 1, playerpos);\n        double dist = 0;\n        int i = 0;\n        while (i < segments.size() - 1) try {\n            dist += segments.get(i).sub(segments.get(i + 1)).length();\n        } finally {\n            i++;\n        }\n        return dist;\n    }\n\n    public AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {\n        this.updatepos(hookpos, playerpos, this.ropelen);\n        vec minvec = new vec(hookpos);\n        vec maxvec = new vec(hookpos);\n        int i = 1;\n        while (i < segments.size()) try {\n            vec segpos = segments.get(i);\n            if (segpos.x < minvec.x) {\n                minvec.x = segpos.x;\n            } else if (segpos.x > maxvec.x) {\n                maxvec.x = segpos.x;\n            }\n            if (segpos.y < minvec.y) {\n                minvec.y = segpos.y;\n            } else if (segpos.y > maxvec.y) {\n                maxvec.y = segpos.y;\n            }\n            if (segpos.z < minvec.z) {\n                minvec.z = segpos.z;\n            } else if (segpos.z > maxvec.z) {\n                maxvec.z = segpos.z;\n            }\n        } finally {\n            i++;\n        }\n        AxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);\n        //\t\tSystem.out.println(bb.maxX);\n        return bb;\n    }\n}\n", "class_id": 0, "repo": "Nyfaria/grapplemod", "file": "main/java/com/yyon/grapplinghook/controllers/SegmentHandler.java", "last_update_at": "2021-10-31T06:34:38+00:00", "original_content": "public class SegmentHandler {\n\n    public LinkedList<vec> segments;\n\n    public LinkedList<EnumFacing> segmentbottomsides;\n\n    public LinkedList<EnumFacing> segmenttopsides;\n\n    public World world;\n\n    public grappleArrow arrow;\n\n    vec prevhookpos = null;\n\n    vec prevplayerpos = null;\n\n    final double bendoffset = 0.05;\n\n    final double intoblock = 0.05;\n\n    public SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {\n        segments = new LinkedList<vec>();\n        segments.add(hookpos);\n        segments.add(playerpos);\n        segmentbottomsides = new LinkedList<EnumFacing>();\n        segmentbottomsides.add(null);\n        segmentbottomsides.add(null);\n        segmenttopsides = new LinkedList<EnumFacing>();\n        segmenttopsides.add(null);\n        segmenttopsides.add(null);\n        this.world = w;\n        this.arrow = arrow;\n        this.prevhookpos = new vec(hookpos);\n        this.prevplayerpos = new vec(playerpos);\n    }\n\n    public void forceSetPos(vec hookpos, vec playerpos) {\n        this.prevhookpos = new vec(hookpos);\n        this.prevplayerpos = new vec(playerpos);\n        this.segments.set(0, new vec(hookpos));\n        this.segments.set(this.segments.size() - 1, new vec(playerpos));\n    }\n\n    double ropelen;\n\n    public void updatepos(vec hookpos, vec playerpos, double ropelen) {\n        segments.set(0, hookpos);\n        segments.set(segments.size() - 1, playerpos);\n        this.ropelen = ropelen;\n    }\n\n    public void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {\n        if (prevhookpos == null) {\n            prevhookpos = hookpos;\n            prevplayerpos = playerpos;\n        }\n        segments.set(0, hookpos);\n        segments.set(segments.size() - 1, playerpos);\n        this.ropelen = ropelen;\n        vec closest = segments.get(segments.size() - 2);\n        while (true) {\n            if (segments.size() == 2) {\n                break;\n            }\n            int index = segments.size() - 2;\n            closest = segments.get(index);\n            EnumFacing bottomside = segmentbottomsides.get(index);\n            EnumFacing topside = segmenttopsides.get(index);\n            vec ropevec = playerpos.sub(closest);\n            vec beforepoint = segments.get(index - 1);\n            vec edgevec = getnormal(bottomside).cross(getnormal(topside));\n            vec planenormal = beforepoint.sub(closest).cross(edgevec);\n            if (ropevec.dot(planenormal) > 0) {\n                this.removesegment(index);\n            } else {\n                break;\n            }\n        }\n        vec farthest = segments.get(1);\n        if (movinghook) {\n            while (true) {\n                if (segments.size() == 2) {\n                    break;\n                }\n                int index = 1;\n                farthest = segments.get(index);\n                EnumFacing bottomside = segmentbottomsides.get(index);\n                EnumFacing topside = segmenttopsides.get(index);\n                vec ropevec = farthest.sub(hookpos);\n                vec beforepoint = segments.get(index + 1);\n                vec edgevec = getnormal(bottomside).cross(getnormal(topside));\n                vec planenormal = beforepoint.sub(farthest).cross(edgevec);\n                if (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {\n                    //\t\t\t\t\tSystem.out.println(\"removed farthest\");\n                    this.removesegment(index);\n                } else {\n                    break;\n                }\n            }\n            while (true) {\n                if (this.getDistToFarthest() > ropelen) {\n                    this.removesegment(1);\n                } else {\n                    break;\n                }\n            }\n        }\n        if (movinghook) {\n            farthest = segments.get(1);\n            vec prevfarthest = farthest;\n            if (segments.size() == 2) {\n                prevfarthest = prevplayerpos;\n            }\n            updatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);\n        }\n        vec prevclosest = closest;\n        if (segments.size() == 2) {\n            prevclosest = prevhookpos;\n        }\n        updatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);\n        prevhookpos = hookpos;\n        prevplayerpos = playerpos;\n    }\n\n    public void removesegment(int index) {\n        segments.remove(index);\n        segmentbottomsides.remove(index);\n        segmenttopsides.remove(index);\n        if (!this.world.isRemote) {\n            SegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);\n            vec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n            grapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n        }\n    }\n\n    public void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {\n        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);\n        // if rope hit block\n        if (bottomraytraceresult != null) {\n            if (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {\n                //        \t\tSystem.out.println(\"Warning: prev collision\");\n                return;\n            }\n            //        \tSystem.out.println(bottomraytraceresult.typeOfHit);\n            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);\n            /*            this.arrow.debugpos = bottomhitvec;\n            this.arrow.debugpos2 = bottom;\n            this.arrow.debugpos3 = top;*/\n            EnumFacing bottomside = bottomraytraceresult.sideHit;\n            vec bottomnormal = this.getnormal(bottomside);\n            //            double ropelen = top.sub(bottom).length();\n            double prevropelen = prevtop.sub(prevbottom).length();\n            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom\n            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));\n            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);\n            /*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option1;\n            \tcornerlinedist = cornerbound1.sub(bound_option1).length();\n            }*/\n            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);\n            /*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {\n            \tcornerbound2 = bound_option2;\n            \tcornerlinedist = cornerbound1.sub(bound_option2).length();\n            }*/\n            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);\n            //            if (cornerbound2 != null) {\n            for (vec cornerbound2 : new vec[] { bound_option1, bound_option2, bound_option3 }) {\n                if (cornerbound2 == null) {\n                    continue;\n                }\n                // the corner must be in the line (cornerbound2, cornerbound1)\n                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);\n                if (cornerraytraceresult != null) {\n                    vec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);\n                    EnumFacing cornerside = cornerraytraceresult.sideHit;\n                    if (cornerside == bottomside || cornerside.getOpposite() == bottomside) {\n                        //                \t\tSystem.out.println(\"Warning: corner is same or opposite of bottomside\");\n                        continue;\n                    } else {\n                        // add a bend around the corner\n                        vec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));\n                        vec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));\n                        vec topropevec = bend.sub(top);\n                        vec bottomropevec = bend.sub(bottom);\n                        // ignore bends that are too close to another bend\n                        if (topropevec.length() < 0.05) {\n                            if (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {\n                                //                    \t\t\tSystem.out.println(\"Warning: top bend is too close\");\n                                continue;\n                            }\n                        }\n                        if (bottomropevec.length() < 0.05) {\n                            if (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {\n                                //                    \t\t\tSystem.out.println(\"Warning: bottom bend is too close\");\n                                continue;\n                            }\n                        }\n                        this.actuallyaddsegment(index, bend, bottomside, cornerside);\n                        // if not enough rope length left, undo\n                        if (this.getDistToAnchor() + .2 > this.ropelen) {\n                            //                \t\t\tSystem.out.println(\"Warning: not enough length left, removing\");\n                            this.removesegment(index);\n                            continue;\n                        }\n                        // now to recurse on top section of rope\n                        double newropelen = topropevec.length() + bottomropevec.length();\n                        double prevtoptobend = topropevec.length() * prevropelen / newropelen;\n                        vec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));\n                        if (numberrecursions < 10) {\n                            updatesegment(top, prevtop, bend, prevbend, index, numberrecursions + 1);\n                        } else {\n                            System.out.println(\"Warning: number recursions exceeded\");\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    public vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {\n        vec linevec = linepoint2.sub(linepoint1);\n        if (linevec.dot(planenormal) == 0) {\n            return null;\n        }\n        double d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);\n        return linepoint1.add(linevec.mult(d));\n    }\n\n    public vec getnormal(EnumFacing facing) {\n        Vec3i facingvec = facing.getDirectionVec();\n        return new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());\n    }\n\n    public boolean hookpastbend(double ropelen) {\n        return (this.getDistToFarthest() > ropelen);\n    }\n\n    public BlockPos getbendblock(int index) {\n        vec bendpos = this.segments.get(index);\n        bendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));\n        bendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));\n        return new BlockPos(bendpos.x, bendpos.y, bendpos.z);\n    }\n\n    public void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {\n        segments.add(index, bendpoint);\n        segmentbottomsides.add(index, bottomside);\n        segmenttopsides.add(index, topside);\n        if (!this.world.isRemote) {\n            SegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);\n            vec playerpoint = vec.positionvec(this.arrow.shootingEntity);\n            grapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));\n        }\n    }\n\n    public void print() {\n        for (int i = 1; i < segments.size() - 1; i++) {\n            System.out.print(i);\n            System.out.print(\" \");\n            System.out.print(segmenttopsides.get(i).toString());\n            System.out.print(\" \");\n            System.out.print(segmentbottomsides.get(i).toString());\n            System.out.print(\" \");\n            segments.get(i).print();\n        }\n    }\n\n    public vec getclosest(vec hookpos) {\n        segments.set(0, hookpos);\n        return segments.get(segments.size() - 2);\n    }\n\n    public double getDistToAnchor() {\n        double dist = 0;\n        for (int i = 0; i < segments.size() - 2; i++) {\n            dist += segments.get(i).sub(segments.get(i + 1)).length();\n        }\n        return dist;\n    }\n\n    public vec getfarthest() {\n        return segments.get(1);\n    }\n\n    public double getDistToFarthest() {\n        double dist = 0;\n        for (int i = 1; i < segments.size() - 1; i++) {\n            dist += segments.get(i).sub(segments.get(i + 1)).length();\n        }\n        return dist;\n    }\n\n    public double getDist(vec hookpos, vec playerpos) {\n        segments.set(0, hookpos);\n        segments.set(segments.size() - 1, playerpos);\n        double dist = 0;\n        for (int i = 0; i < segments.size() - 1; i++) {\n            dist += segments.get(i).sub(segments.get(i + 1)).length();\n        }\n        return dist;\n    }\n\n    public AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {\n        this.updatepos(hookpos, playerpos, this.ropelen);\n        vec minvec = new vec(hookpos);\n        vec maxvec = new vec(hookpos);\n        for (int i = 1; i < segments.size(); i++) {\n            vec segpos = segments.get(i);\n            if (segpos.x < minvec.x) {\n                minvec.x = segpos.x;\n            } else if (segpos.x > maxvec.x) {\n                maxvec.x = segpos.x;\n            }\n            if (segpos.y < minvec.y) {\n                minvec.y = segpos.y;\n            } else if (segpos.y > maxvec.y) {\n                maxvec.y = segpos.y;\n            }\n            if (segpos.z < minvec.z) {\n                minvec.z = segpos.z;\n            } else if (segpos.z > maxvec.z) {\n                maxvec.z = segpos.z;\n            }\n        }\n        AxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);\n        //\t\tSystem.out.println(bb.maxX);\n        return bb;\n    }\n}\n", "refactored": true}
{"hexsha": "771fae9bb70c50c42d7f3b36993cef4a89b3c044", "ext": "java", "lang": "Java", "content": "public class Reassociate {\n\n    private static Log log = LogFactory.getLog(Reassociate.class);\n\n    private List<String> errorList = new ArrayList<String>();\n\n    private List<String> msgList = new ArrayList<String>();\n\n    private Map<String, String> locMap = new HashMap<String, String>();\n\n    private Map<String, String> toMap = new HashMap<String, String>();\n\n    InventoryQuery iq = InventoryFactory.getInstance().getQuery();\n\n    InventoryAccess ia = InventoryFactory.getInstance().getAccess();\n\n    private boolean testMode = true;\n\n    private boolean interactive = true;\n\n    //the default, overwrite files\n    private boolean updateMetaOnMissing = false;\n\n    private boolean overwrite = true;\n\n    public void setTestMode(boolean val) {\n        this.testMode = val;\n    }\n\n    public Map<String, Object> productReassociate(Long productId, String toProductType) {\n        interactive = false;\n        Product g = iq.getProductMetadata(productId).getProduct();\n        log.debug(\"From ProductType:\" + g.getPtId());\n        ProductType fromD = iq.fetchProductType(g.getPtId());\n        log.debug(\"To ProductType:\" + toProductType);\n        ProductType toD = iq.fetchProductTypeByPersistentId(toProductType);\n        String toBasePath = null;\n        //make sure locMaps are defined (location policies).\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())) {\n            locMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        //fetch toBasePath\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())) {\n            if (dlp.getType().contains(\"ARCHIVE\"))\n                toBasePath = dlp.getBasePath();\n            toMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        HashMap<String, Object> ret = new HashMap<String, Object>();\n        if (toBasePath == null) {\n            log.info(\"No toBasePath Found. Exiting.\");\n            errorList.add(\"No 'to basepath' found for productType [\" + toProductType + \"]. Failed to reassociate product.\");\n            ret.put(\"type\", \"failure\");\n            ret.put(\"msgs\", errorList);\n            return ret;\n        }\n        log.info(\"Reassociating Product [\" + g.getId() + \":\" + g.getName() + \"]\");\n        reassociateProduct(g, toBasePath, toD, fromD);\n        if (errorList.size() > 0) {\n            log.debug(\"Errors processing reassociate.\");\n            ret.put(\"type\", \"failure\");\n            ret.put(\"msgs\", errorList);\n            return ret;\n        } else {\n            log.debug(\"Successfully processed product\");\n            ret.put(\"type\", \"success\");\n            ret.put(\"msgs\", msgList);\n            return ret;\n        }\n    }\n\n    public void reassociateProducts(ProductType fromD, ProductType toD, String gnp, boolean moveAll) {\n        String toBasePath = null;\n        List<Long> productIds;\n        //get products by name/pattern\n        if (moveAll) {\n            productIds = iq.getProductIdList(fromD.getId());\n        } else {\n            //find the products by pattern...\n            productIds = new ArrayList<Long>();\n            List<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);\n            for (Product g : gList) {\n                productIds.add(g.getId());\n            }\n        }\n        log.info(\"Number of products to reassociate: \" + productIds.size());\n        //fetch fromBasePaths\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())) {\n            locMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        //fetch toBasePath\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())) {\n            if (dlp.getType().contains(\"ARCHIVE\"))\n                toBasePath = dlp.getBasePath();\n            toMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        if (toBasePath == null) {\n            log.info(\"No toBasePath Found. Exiting.\");\n            System.exit(99);\n        }\n        int count = 1;\n        for (Long i : productIds) {\n            Product g = iq.getProductMetadata(i).getProduct();\n            System.out.println(\"Processing product \" + count + \" of \" + productIds.size() + \" [\" + g.getId() + \":\" + g.getName() + \"]\");\n            log.info(\"Processing product \" + count + \" of \" + productIds.size() + \" [\" + g.getId() + \":\" + g.getName() + \"]\");\n            reassociateProduct(g, toBasePath, toD, fromD);\n            ++count;\n        }\n        if (errorList.size() > 0) {\n            System.out.println(\"---------------------------------\");\n            System.out.println(\"Processing completed with errors:\");\n            System.out.println(\"---------------------------------\");\n            for (String s : errorList) {\n                System.out.println(\"\\t\" + s);\n            }\n            log.debug(\"---------------------------------\");\n            log.debug(\"Processing completed with errors:\");\n            log.debug(\"---------------------------------\");\n            for (String s : errorList) {\n                log.debug(\"\\t\" + s);\n            }\n        } else {\n            System.out.println(\"-----------------------------------\");\n            System.out.println(\"Processing completed without errors\");\n            System.out.println(\"-----------------------------------\");\n            log.debug(\"-----------------------------------\");\n            log.debug(\"Processing completed without errors\");\n            log.debug(\"-----------------------------------\");\n        }\n    }\n\n    private void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD) {\n        //move files\n        if (!moveFiles(g, toBasePath)) {\n            //ERROR OCCURED, should we skip the rest?\n            log.warn(\"Error moving files. Product id [\" + g.getId() + \"] will abort processing (metadata has not been changed.\");\n            errorList.add(\"Error moving files. Product id [\" + g.getId() + \"] will abort processing (metadata has not been changed.)\");\n            return;\n        }\n        log.debug(\"Set product root, productType to [\" + toBasePath + \",\" + toD.getId() + \"]\");\n        g.setRootPath(toBasePath);\n        g.setPtId(toD.getId());\n        String at = null;\n        try {\n            at = iq.getProductTypeAccessType(toD.getId());\n        } catch (Exception e) {\n            log.debug(\"error getting productType info.\");\n        }\n        //see if there exists a product for the toProductType already\n        log.debug(\"Delete Checks\");\n        Product exists = iq.fetchProduct(toD.getId(), g.getName());\n        if (exists != null) {\n            log.debug(\"Product exists in destination product type.Removing product[\" + exists.getId() + \"]\");\n            ia.deleteProduct(exists, false);\n        }\n        //UNCOMMENT THIS\n        ia.updateProductInfo(g);\n        //update productRefs\n        log.debug(\"Changing local product reference paths\");\n        //Productelements will need to be mapped to the new DEIDS and updated in the product_* tables\n        log.debug(\"Chagning product elements to use new productType IDs\");\n    }\n\n    /*\n\tprivate void reElement(Product g, ProductType toD, ProductType fromD) {\n\t\t\n\t\tia.reElement(g,toD,fromD);\n//\t\tMap<Integer,String> deIDmapping = new HashMap<Integer,String>();\n//\t\tfor(ProductTypeElement toDE : toD.getProductTypeElementSet()){\n//\t\t\t\n//\t\t\tfor(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){\n//\t\t\t\tif(toDE.getElementDD().equals(fromDE.getElementDD()))\n//\t\t\t\t\tdeIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+\",\"+toDE.getDeId());\n//\t\t\t}\t\n//\t\t}\n//\t\tlog.debug(\"DEID Mappings\");\n//\t\tfor(Entry<Integer,String> me : deIDmapping.entrySet()){\n//\t\t\tString[] ary = me.getValue().split(\",\"); \n//\t\t\tString type = ary[0].trim();\n//\t\t\tInteger deId = Integer.valueOf(ary[1].trim());\n//\t\t\tif(type.equals(\"time\"))\n//\t\t\t\ttype = \"DATETIME\";\n//\t\t\t\n//\t\t\tlog.debug(\"map \"+ me.getKey() + \" to \" + deId + \"[\"+type+\"]\");\n//\t\t\tia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);\n//\t\t}\n\t}\n\n\tprivate void reReference(Product g, Map<String, String> toMap,\n\t\t\tMap<String, String> locMap) {\n\t\tfor(ProductReference ref : g.getProductReferenceSet()){\n\t\t\tif(ref.getType().contains(\"LOCAL\")){\n\t\t\t\tlog.debug(\"from: \" + ref.getPath());\n\t\t\t\t//check to make sure the *Map.gets are not null\n\t\t\t\tString replaceWith = toMap.get(ref.getType());\n\t\t\t\tif(replaceWith == null)\n\t\t\t\t{\n\t\t\t\t\terrorList.add(\"No entry in \\\"toProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString replace = locMap.get(ref.getType());\n\t\t\t\tif(replace == null){\n\t\t\t\t\terrorList.add(\"No entry in \\\"fromProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\t//this should never happen\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString newRef = ref.getPath().replaceAll(replace, replaceWith);\n\t\t\t\tlog.debug(\"newRef: \" + newRef);\n\t\t\t\t//make sure newRef is different that oldRef\n\t\t\t\tif(newRef.equals(ref.getPath())){\n\t\t\t\t\tlog.debug(\"newRef same as oldRef.\");\n\t\t\t\t\terrorList.add(\"product [\"+g.getProductId()+\"] newReference same as old reference.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n   */\n    private boolean moveFiles(Product g, String toBasePath) {\n        boolean noErrors = true;\n        log.debug(\"Product name: \" + g.getName());\n        String fromLoc = null, toLoc = null;\n        for (ProductArchive ga : iq.getProductArchives(g.getId())) {\n            // create old,new file locations\n            fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n            log.debug(\"From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n            toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n            log.debug(\"to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n            if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {\n                errorList.add(\"Error moving product file [\" + fromLoc + \"] to [\" + toLoc + \"]. Run with debug mode for more details.\");\n                noErrors = false;\n            } else\n                log.info(\"Successfully moved product file [\" + fromLoc + \"] to [\" + toLoc + \"].\");\n        }\n        // return true if we had an error.\n        return noErrors;\n    }\n}\n", "class_id": 0, "repo": "dataplumber/horizon", "file": "archive/src/main/java/gov/nasa/horizon/archive/core/Reassociate.java", "last_update_at": "2021-07-02T23:50:52+00:00", "original_content": "public class Reassociate {\n\n    private static Log log = LogFactory.getLog(Reassociate.class);\n\n    private List<String> errorList = new ArrayList<String>();\n\n    private List<String> msgList = new ArrayList<String>();\n\n    private Map<String, String> locMap = new HashMap<String, String>();\n\n    private Map<String, String> toMap = new HashMap<String, String>();\n\n    InventoryQuery iq = InventoryFactory.getInstance().getQuery();\n\n    InventoryAccess ia = InventoryFactory.getInstance().getAccess();\n\n    private boolean testMode = true;\n\n    private boolean interactive = true;\n\n    //the default, overwrite files\n    private boolean updateMetaOnMissing = false;\n\n    private boolean overwrite = true;\n\n    public void setTestMode(boolean val) {\n        this.testMode = val;\n    }\n\n    public Map<String, Object> productReassociate(Long productId, String toProductType) {\n        interactive = false;\n        Product g = iq.getProductMetadata(productId).getProduct();\n        log.debug(\"From ProductType:\" + g.getPtId());\n        ProductType fromD = iq.fetchProductType(g.getPtId());\n        log.debug(\"To ProductType:\" + toProductType);\n        ProductType toD = iq.fetchProductTypeByPersistentId(toProductType);\n        String toBasePath = null;\n        //make sure locMaps are defined (location policies).\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())) {\n            locMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        //fetch toBasePath\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())) {\n            if (dlp.getType().contains(\"ARCHIVE\"))\n                toBasePath = dlp.getBasePath();\n            toMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        HashMap<String, Object> ret = new HashMap<String, Object>();\n        if (toBasePath == null) {\n            log.info(\"No toBasePath Found. Exiting.\");\n            errorList.add(\"No 'to basepath' found for productType [\" + toProductType + \"]. Failed to reassociate product.\");\n            ret.put(\"type\", \"failure\");\n            ret.put(\"msgs\", errorList);\n            return ret;\n        }\n        log.info(\"Reassociating Product [\" + g.getId() + \":\" + g.getName() + \"]\");\n        reassociateProduct(g, toBasePath, toD, fromD);\n        if (errorList.size() > 0) {\n            log.debug(\"Errors processing reassociate.\");\n            ret.put(\"type\", \"failure\");\n            ret.put(\"msgs\", errorList);\n            return ret;\n        } else {\n            log.debug(\"Successfully processed product\");\n            ret.put(\"type\", \"success\");\n            ret.put(\"msgs\", msgList);\n            return ret;\n        }\n    }\n\n    public void reassociateProducts(ProductType fromD, ProductType toD, String gnp, boolean moveAll) {\n        String toBasePath = null;\n        List<Long> productIds;\n        //get products by name/pattern\n        if (moveAll) {\n            productIds = iq.getProductIdList(fromD.getId());\n        } else {\n            //find the products by pattern...\n            productIds = new ArrayList<Long>();\n            List<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);\n            for (Product g : gList) {\n                productIds.add(g.getId());\n            }\n        }\n        log.info(\"Number of products to reassociate: \" + productIds.size());\n        //fetch fromBasePaths\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())) {\n            locMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        //fetch toBasePath\n        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())) {\n            if (dlp.getType().contains(\"ARCHIVE\"))\n                toBasePath = dlp.getBasePath();\n            toMap.put(dlp.getType(), dlp.getBasePath());\n        }\n        if (toBasePath == null) {\n            log.info(\"No toBasePath Found. Exiting.\");\n            System.exit(99);\n        }\n        int count = 1;\n        for (Long i : productIds) {\n            Product g = iq.getProductMetadata(i).getProduct();\n            System.out.println(\"Processing product \" + count + \" of \" + productIds.size() + \" [\" + g.getId() + \":\" + g.getName() + \"]\");\n            log.info(\"Processing product \" + count + \" of \" + productIds.size() + \" [\" + g.getId() + \":\" + g.getName() + \"]\");\n            reassociateProduct(g, toBasePath, toD, fromD);\n            ++count;\n        }\n        if (errorList.size() > 0) {\n            System.out.println(\"---------------------------------\");\n            System.out.println(\"Processing completed with errors:\");\n            System.out.println(\"---------------------------------\");\n            for (String s : errorList) {\n                System.out.println(\"\\t\" + s);\n            }\n            log.debug(\"---------------------------------\");\n            log.debug(\"Processing completed with errors:\");\n            log.debug(\"---------------------------------\");\n            for (String s : errorList) {\n                log.debug(\"\\t\" + s);\n            }\n        } else {\n            System.out.println(\"-----------------------------------\");\n            System.out.println(\"Processing completed without errors\");\n            System.out.println(\"-----------------------------------\");\n            log.debug(\"-----------------------------------\");\n            log.debug(\"Processing completed without errors\");\n            log.debug(\"-----------------------------------\");\n        }\n    }\n\n    private void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD) {\n        //move files\n        if (!moveFiles(g, toBasePath)) {\n            //ERROR OCCURED, should we skip the rest?\n            log.warn(\"Error moving files. Product id [\" + g.getId() + \"] will abort processing (metadata has not been changed.\");\n            errorList.add(\"Error moving files. Product id [\" + g.getId() + \"] will abort processing (metadata has not been changed.)\");\n            return;\n        }\n        log.debug(\"Set product root, productType to [\" + toBasePath + \",\" + toD.getId() + \"]\");\n        g.setRootPath(toBasePath);\n        g.setPtId(toD.getId());\n        String at = null;\n        try {\n            at = iq.getProductTypeAccessType(toD.getId());\n        } catch (Exception e) {\n            log.debug(\"error getting productType info.\");\n        }\n        //see if there exists a product for the toProductType already\n        log.debug(\"Delete Checks\");\n        Product exists = iq.fetchProduct(toD.getId(), g.getName());\n        if (exists != null) {\n            log.debug(\"Product exists in destination product type.Removing product[\" + exists.getId() + \"]\");\n            ia.deleteProduct(exists, false);\n        }\n        //UNCOMMENT THIS\n        ia.updateProductInfo(g);\n        //update productRefs\n        log.debug(\"Changing local product reference paths\");\n        //Productelements will need to be mapped to the new DEIDS and updated in the product_* tables\n        log.debug(\"Chagning product elements to use new productType IDs\");\n    }\n\n    /*\n\tprivate void reElement(Product g, ProductType toD, ProductType fromD) {\n\t\t\n\t\tia.reElement(g,toD,fromD);\n//\t\tMap<Integer,String> deIDmapping = new HashMap<Integer,String>();\n//\t\tfor(ProductTypeElement toDE : toD.getProductTypeElementSet()){\n//\t\t\t\n//\t\t\tfor(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){\n//\t\t\t\tif(toDE.getElementDD().equals(fromDE.getElementDD()))\n//\t\t\t\t\tdeIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+\",\"+toDE.getDeId());\n//\t\t\t}\t\n//\t\t}\n//\t\tlog.debug(\"DEID Mappings\");\n//\t\tfor(Entry<Integer,String> me : deIDmapping.entrySet()){\n//\t\t\tString[] ary = me.getValue().split(\",\"); \n//\t\t\tString type = ary[0].trim();\n//\t\t\tInteger deId = Integer.valueOf(ary[1].trim());\n//\t\t\tif(type.equals(\"time\"))\n//\t\t\t\ttype = \"DATETIME\";\n//\t\t\t\n//\t\t\tlog.debug(\"map \"+ me.getKey() + \" to \" + deId + \"[\"+type+\"]\");\n//\t\t\tia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);\n//\t\t}\n\t}\n\n\tprivate void reReference(Product g, Map<String, String> toMap,\n\t\t\tMap<String, String> locMap) {\n\t\tfor(ProductReference ref : g.getProductReferenceSet()){\n\t\t\tif(ref.getType().contains(\"LOCAL\")){\n\t\t\t\tlog.debug(\"from: \" + ref.getPath());\n\t\t\t\t//check to make sure the *Map.gets are not null\n\t\t\t\tString replaceWith = toMap.get(ref.getType());\n\t\t\t\tif(replaceWith == null)\n\t\t\t\t{\n\t\t\t\t\terrorList.add(\"No entry in \\\"toProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString replace = locMap.get(ref.getType());\n\t\t\t\tif(replace == null){\n\t\t\t\t\terrorList.add(\"No entry in \\\"fromProductType\\\" location policy for:\" + ref.getType());\n\t\t\t\t\t//this should never happen\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString newRef = ref.getPath().replaceAll(replace, replaceWith);\n\t\t\t\tlog.debug(\"newRef: \" + newRef);\n\t\t\t\t//make sure newRef is different that oldRef\n\t\t\t\tif(newRef.equals(ref.getPath())){\n\t\t\t\t\tlog.debug(\"newRef same as oldRef.\");\n\t\t\t\t\terrorList.add(\"product [\"+g.getProductId()+\"] newReference same as old reference.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n   */\n    private boolean moveFiles(Product g, String toBasePath) {\n        boolean noErrors = true;\n        log.debug(\"Product name: \" + g.getName());\n        String fromLoc = null, toLoc = null;\n        for (ProductArchive ga : iq.getProductArchives(g.getId())) {\n            // create old,new file locations\n            fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();\n            log.debug(\"From: \" + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());\n            toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();\n            log.debug(\"to: \" + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());\n            if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {\n                errorList.add(\"Error moving product file [\" + fromLoc + \"] to [\" + toLoc + \"]. Run with debug mode for more details.\");\n                noErrors = false;\n            } else\n                log.info(\"Successfully moved product file [\" + fromLoc + \"] to [\" + toLoc + \"].\");\n        }\n        // return true if we had an error.\n        return noErrors;\n    }\n}\n", "refactored": false}
{"hexsha": "aaf5418ef49cbe5565f0b3cf9c16a929b43a0ec1", "ext": "java", "lang": "Java", "content": "public class BaconHistogram {\r\n\r\n    public static void main(String[] args) {\r\n        SymbolGraph sg = new SymbolGraph(\"movies.txt\", \"/\");\r\n        Graph G = sg.G();\r\n        String source = \"Bacon, Kevin\";\r\n        if (!sg.contains(source)) {\r\n            StdOut.println(source + \"not in database.\");\r\n            return;\r\n        }\r\n        int s = sg.index(source);\r\n        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\r\n        int[] num = new int[G.V()];\r\n        int infinite = 0;\r\n        int v = 0;\r\n        while (v < G.V()) try {\r\n            int distance = bfs.distTo(v);\r\n            if (distance != Integer.MAX_VALUE) {\r\n                num[distance]++;\r\n            } else {\r\n                infinite++;\r\n            }\r\n        } finally {\r\n            v++;\r\n        }\r\n        int i = 0;\r\n        while (i < num.length) try {\r\n            if (num[i] != 0) {\r\n                System.out.println(\"Kevin Bacon = \" + i / 2 + \" : \" + num[i]);\r\n            } else {\r\n                break;\r\n            }\r\n        } finally {\r\n            i += 2;\r\n        }\r\n        System.out.println(\"Infinite(actors and movies): \" + infinite);\r\n    }\r\n}\r\n", "class_id": 0, "repo": "wenghengcong/Algorithms", "file": "cs61b_algo4_other/src/com/luci/algorithms/chapter4_1/BaconHistogram.java", "last_update_at": "2021-12-14T21:17:40+00:00", "original_content": "public class BaconHistogram {\r\n\r\n    public static void main(String[] args) {\r\n        SymbolGraph sg = new SymbolGraph(\"movies.txt\", \"/\");\r\n        Graph G = sg.G();\r\n        String source = \"Bacon, Kevin\";\r\n        if (!sg.contains(source)) {\r\n            StdOut.println(source + \"not in database.\");\r\n            return;\r\n        }\r\n        int s = sg.index(source);\r\n        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);\r\n        int[] num = new int[G.V()];\r\n        int infinite = 0;\r\n        for (int v = 0; v < G.V(); v++) {\r\n            int distance = bfs.distTo(v);\r\n            if (distance != Integer.MAX_VALUE) {\r\n                num[distance]++;\r\n            } else {\r\n                infinite++;\r\n            }\r\n        }\r\n        for (int i = 0; i < num.length; i += 2) {\r\n            if (num[i] != 0) {\r\n                System.out.println(\"Kevin Bacon = \" + i / 2 + \" : \" + num[i]);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        System.out.println(\"Infinite(actors and movies): \" + infinite);\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "bd5b15cd144abcfa59c8caa88db76b914d05a608", "ext": "java", "lang": "Java", "content": "public class CalendarFormatterStressTest {\n\n    private static final int DATE = 0x01;\n\n    private static final int TIME = 0x02;\n\n    private static final int WRAPPER = 0x04;\n\n    private static final int DATESKEL = 0x08;\n\n    private static final int TIMESKEL = 0x10;\n\n    private static final CalendarFormat[] FORMATS = CalendarFormat.values();\n\n    private static final int FORMATS_LEN = FORMATS.length;\n\n    private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();\n\n    private static final int SKELETONS_LEN = SKELETONS.length;\n\n    @Test\n    public void testCalendarFormatter() {\n        StringBuilder buffer = new StringBuilder();\n        long epoch = 1288648500000L;\n        CLDR.Locale[] locales = new CLDR.Locale[] { CLDR.Locale.en_US, CLDR.Locale.am, CLDR.Locale.ar, CLDR.Locale.fr, CLDR.Locale.de, CLDR.Locale.en_GB };\n        ZoneId zoneId = ZoneId.of(\"America/New_York\");\n        ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);\n        for (CLDR.Locale locale : locales) {\n            CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);\n            int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;\n            int inner = FORMATS_LEN * SKELETONS_LEN;\n            int i = 0;\n            while (i < outer) try {\n                int j = 0;\n                while (j < inner) try {\n                    CalendarFormatOptions options = options(i, j);\n                    buffer.setLength(0);\n                    f.format(datetime, options, buffer);\n                } finally {\n                    j++;\n                }\n            } finally {\n                i++;\n            }\n        }\n    }\n\n    private static CalendarFormatOptions options(int flag, int choice) {\n        CalendarFormatOptions opts = new CalendarFormatOptions();\n        if ((flag & DATE) != 0) {\n            opts.setDateFormat(format(choice));\n        }\n        if ((flag & TIME) != 0) {\n            opts.setTimeFormat(format(choice));\n        }\n        if ((flag & WRAPPER) != 0) {\n            opts.setWrapperFormat(format(choice));\n        }\n        if ((flag & DATESKEL) != 0) {\n            opts.setDateSkeleton(skeleton(choice));\n        }\n        if ((flag & TIMESKEL) != 0) {\n            opts.setTimeSkeleton(skeleton(choice));\n        }\n        return opts;\n    }\n\n    private static CalendarFormat format(int choice) {\n        return FORMATS[choice % FORMATS_LEN];\n    }\n\n    private static CalendarSkeleton skeleton(int choice) {\n        return SKELETONS[choice % SKELETONS_LEN];\n    }\n}\n", "class_id": 0, "repo": "Squarespace/cldr", "file": "runtime/src/test/java/com/squarespace/cldr/dates/CalendarFormatterStressTest.java", "last_update_at": "2021-03-10T13:56:40+00:00", "original_content": "public class CalendarFormatterStressTest {\n\n    private static final int DATE = 0x01;\n\n    private static final int TIME = 0x02;\n\n    private static final int WRAPPER = 0x04;\n\n    private static final int DATESKEL = 0x08;\n\n    private static final int TIMESKEL = 0x10;\n\n    private static final CalendarFormat[] FORMATS = CalendarFormat.values();\n\n    private static final int FORMATS_LEN = FORMATS.length;\n\n    private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();\n\n    private static final int SKELETONS_LEN = SKELETONS.length;\n\n    @Test\n    public void testCalendarFormatter() {\n        StringBuilder buffer = new StringBuilder();\n        long epoch = 1288648500000L;\n        CLDR.Locale[] locales = new CLDR.Locale[] { CLDR.Locale.en_US, CLDR.Locale.am, CLDR.Locale.ar, CLDR.Locale.fr, CLDR.Locale.de, CLDR.Locale.en_GB };\n        ZoneId zoneId = ZoneId.of(\"America/New_York\");\n        ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);\n        for (CLDR.Locale locale : locales) {\n            CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);\n            int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;\n            int inner = FORMATS_LEN * SKELETONS_LEN;\n            for (int i = 0; i < outer; i++) {\n                for (int j = 0; j < inner; j++) {\n                    CalendarFormatOptions options = options(i, j);\n                    buffer.setLength(0);\n                    f.format(datetime, options, buffer);\n                }\n            }\n        }\n    }\n\n    private static CalendarFormatOptions options(int flag, int choice) {\n        CalendarFormatOptions opts = new CalendarFormatOptions();\n        if ((flag & DATE) != 0) {\n            opts.setDateFormat(format(choice));\n        }\n        if ((flag & TIME) != 0) {\n            opts.setTimeFormat(format(choice));\n        }\n        if ((flag & WRAPPER) != 0) {\n            opts.setWrapperFormat(format(choice));\n        }\n        if ((flag & DATESKEL) != 0) {\n            opts.setDateSkeleton(skeleton(choice));\n        }\n        if ((flag & TIMESKEL) != 0) {\n            opts.setTimeSkeleton(skeleton(choice));\n        }\n        return opts;\n    }\n\n    private static CalendarFormat format(int choice) {\n        return FORMATS[choice % FORMATS_LEN];\n    }\n\n    private static CalendarSkeleton skeleton(int choice) {\n        return SKELETONS[choice % SKELETONS_LEN];\n    }\n}\n", "refactored": true}
{"hexsha": "2861105d837d7c45ed2e603975d65a33155fbc51", "ext": "java", "lang": "Java", "content": "@ObjectHolder(Reference.MOD_ID)\npublic class ModSoundEvents {\n\n    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();\n\n    static {\n        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS) {\n            Instrument instrument = handHeld.getInstrument();\n            if (!SOUNDS.containsKey(instrument.sounds.timbre)) {\n                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));\n            }\n        }\n    }\n\n    /**\n     * Register a {@link SoundEvent}.\n     *\n     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound\n     *                  resources. Without the prefix it will reference vanilla sound resources.\n     * @return The SoundEvent\n     */\n    @Nullable\n    private static SoundEvent registerSound(String soundName) {\n        final ResourceLocation soundID = new ResourceLocation(soundName);\n        SoundEvent soundEvent;\n        if (soundName.contains(Reference.MOD_DOMAIN))\n            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);\n        else\n            soundEvent = SoundEvent.REGISTRY.getObject(soundID);\n        return soundEvent;\n    }\n\n    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)\n    public static class RegistrationHandler {\n\n        @SubscribeEvent\n        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event) {\n            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));\n        }\n    }\n\n    /**\n     * Get a {@link SoundEvent} by name\n     *\n     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the\n     *                  instruments.json file can be returned. However, in the event a key is not found the default\n     *                  will be the vanilla note block 'pling' sound.\n     * @return The SoundEvent\n     */\n    public static SoundEvent getSound(String soundName) {\n        return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);\n    }\n}\n", "class_id": 0, "repo": "Aeronica/BardMania", "file": "src/main/java/net/aeronica/mods/bard_mania/server/init/ModSoundEvents.java", "last_update_at": "2021-02-28T19:44:44+00:00", "original_content": "@ObjectHolder(Reference.MOD_ID)\npublic class ModSoundEvents {\n\n    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();\n\n    static {\n        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS) {\n            Instrument instrument = handHeld.getInstrument();\n            if (!SOUNDS.containsKey(instrument.sounds.timbre)) {\n                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));\n            }\n        }\n    }\n\n    /**\n     * Register a {@link SoundEvent}.\n     *\n     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound\n     *                  resources. Without the prefix it will reference vanilla sound resources.\n     * @return The SoundEvent\n     */\n    @Nullable\n    private static SoundEvent registerSound(String soundName) {\n        final ResourceLocation soundID = new ResourceLocation(soundName);\n        SoundEvent soundEvent;\n        if (soundName.contains(Reference.MOD_DOMAIN))\n            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);\n        else\n            soundEvent = SoundEvent.REGISTRY.getObject(soundID);\n        return soundEvent;\n    }\n\n    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)\n    public static class RegistrationHandler {\n\n        @SubscribeEvent\n        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event) {\n            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));\n        }\n    }\n\n    /**\n     * Get a {@link SoundEvent} by name\n     *\n     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the\n     *                  instruments.json file can be returned. However, in the event a key is not found the default\n     *                  will be the vanilla note block 'pling' sound.\n     * @return The SoundEvent\n     */\n    public static SoundEvent getSound(String soundName) {\n        return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);\n    }\n}\n", "refactored": false}
{"hexsha": "6ae321693fd396814c3cd664d6f460c3b1c7fca7", "ext": "java", "lang": "Java", "content": "public class ChangePasswordRequestValidator implements Validator {\n\n    static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(new LengthRule(8, 30), new CharacterRule(EnglishCharacterData.UpperCase, 1), new CharacterRule(EnglishCharacterData.LowerCase, 1), new CharacterRule(EnglishCharacterData.Digit, 1), new CharacterRule(EnglishCharacterData.Special, 1), new WhitespaceRule()));\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return ChangePasswordRequest.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors e) {\n        ChangePasswordRequest request = (ChangePasswordRequest) target;\n        if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {\n            e.rejectValue(\"newPasswordAgain\", \"password.mismatch\");\n        }\n        RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));\n        if (!result.isValid()) {\n            List<String> messages = PASSWORD_VALIDATOR.getMessages(result);\n            String messageTemplate = messages.stream().collect(Collectors.joining(\",\"));\n            e.rejectValue(\"newPassword\", messageTemplate);\n        }\n    }\n}\n", "class_id": 0, "repo": "tsvetinakalcheva/air-quality-hackathon-project", "file": "src/main/java/bg/startit/hackathon/airquiality/validation/ChangePasswordRequestValidator.java", "last_update_at": "2021-01-06T18:37:06+00:00", "original_content": "public class ChangePasswordRequestValidator implements Validator {\n\n    static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(new LengthRule(8, 30), new CharacterRule(EnglishCharacterData.UpperCase, 1), new CharacterRule(EnglishCharacterData.LowerCase, 1), new CharacterRule(EnglishCharacterData.Digit, 1), new CharacterRule(EnglishCharacterData.Special, 1), new WhitespaceRule()));\n\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return ChangePasswordRequest.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors e) {\n        ChangePasswordRequest request = (ChangePasswordRequest) target;\n        if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {\n            e.rejectValue(\"newPasswordAgain\", \"password.mismatch\");\n        }\n        RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));\n        if (!result.isValid()) {\n            List<String> messages = PASSWORD_VALIDATOR.getMessages(result);\n            String messageTemplate = messages.stream().collect(Collectors.joining(\",\"));\n            e.rejectValue(\"newPassword\", messageTemplate);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "4cd1cd9c2d1e80e72112eab945a3b2e22ef7b82b", "ext": "java", "lang": "Java", "content": "public class LoginSessionHandler implements MinecraftSessionHandler {\n\n    private final ServerConnection connection;\n\n    private boolean informationForwarded;\n\n    public LoginSessionHandler(ServerConnection connection) {\n        this.connection = connection;\n    }\n\n    @Override\n    public void handle(MinecraftPacket packet) {\n        if (packet instanceof EncryptionRequest) {\n            throw new IllegalStateException(\"Backend server is online-mode!\");\n        } else if (packet instanceof LoginPluginMessage) {\n            LoginPluginMessage message = (LoginPluginMessage) packet;\n            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();\n            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN && message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(true);\n                response.setId(message.getId());\n                response.setData(createForwardingData(configuration.getForwardingSecret(), connection.getProxyPlayer().getRemoteAddress().getHostString(), connection.getProxyPlayer().getProfile()));\n                connection.getMinecraftConnection().write(response);\n                informationForwarded = true;\n            } else {\n                // Don't understand\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(false);\n                response.setId(message.getId());\n                response.setData(Unpooled.EMPTY_BUFFER);\n                connection.getMinecraftConnection().write(response);\n            }\n        } else if (packet instanceof Disconnect) {\n            Disconnect disconnect = (Disconnect) packet;\n            // Do we have an outstanding notification? If so, fulfill it.\n            doNotify(ConnectionRequestResults.forDisconnect(disconnect));\n            connection.disconnect();\n        } else if (packet instanceof SetCompression) {\n            SetCompression sc = (SetCompression) packet;\n            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());\n        } else if (packet instanceof ServerLoginSuccess) {\n            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN && !informationForwarded) {\n                doNotify(ConnectionRequestResults.forDisconnect(TextComponent.of(\"Your server did not send a forwarding request to the proxy. Is it set up correctly?\")));\n                connection.disconnect();\n                return;\n            }\n            // The player has been logged on to the backend server.\n            connection.getMinecraftConnection().setState(StateRegistry.PLAY);\n            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();\n            if (existingConnection == null) {\n                // Strap on the play session handler\n                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));\n            } else {\n                // The previous server connection should become obsolete.\n                existingConnection.disconnect();\n            }\n            doNotify(ConnectionRequestResults.SUCCESSFUL);\n            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));\n            connection.getProxyPlayer().setConnectedServer(connection);\n        }\n    }\n\n    @Override\n    public void exception(Throwable throwable) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel().attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.completeExceptionally(throwable);\n        }\n    }\n\n    private void doNotify(ConnectionRequestBuilder.Result result) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel().attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.complete(result);\n        }\n    }\n\n    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {\n        ByteBuf dataToForward = Unpooled.buffer();\n        ByteBuf finalData = Unpooled.buffer();\n        try {\n            ProtocolUtils.writeString(dataToForward, address);\n            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());\n            ProtocolUtils.writeString(dataToForward, profile.getName());\n            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());\n            for (GameProfile.Property property : profile.getProperties()) {\n                ProtocolUtils.writeString(dataToForward, property.getName());\n                ProtocolUtils.writeString(dataToForward, property.getValue());\n                String signature = property.getSignature();\n                if (signature != null) {\n                    dataToForward.writeBoolean(true);\n                    ProtocolUtils.writeString(dataToForward, signature);\n                } else {\n                    dataToForward.writeBoolean(false);\n                }\n            }\n            SecretKey key = new SecretKeySpec(hmacSecret, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(key);\n            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());\n            byte[] sig = mac.doFinal();\n            finalData.writeBytes(sig);\n            finalData.writeBytes(dataToForward);\n            return finalData;\n        } catch (InvalidKeyException e) {\n            finalData.release();\n            throw new RuntimeException(\"Unable to authenticate data\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen\n            finalData.release();\n            throw new AssertionError(e);\n        } finally {\n            dataToForward.release();\n        }\n    }\n}\n", "class_id": 0, "repo": "phase/Velocity", "file": "proxy/src/main/java/com/velocitypowered/proxy/connection/backend/LoginSessionHandler.java", "last_update_at": "2021-09-24T22:44:49+00:00", "original_content": "public class LoginSessionHandler implements MinecraftSessionHandler {\n\n    private final ServerConnection connection;\n\n    private boolean informationForwarded;\n\n    public LoginSessionHandler(ServerConnection connection) {\n        this.connection = connection;\n    }\n\n    @Override\n    public void handle(MinecraftPacket packet) {\n        if (packet instanceof EncryptionRequest) {\n            throw new IllegalStateException(\"Backend server is online-mode!\");\n        } else if (packet instanceof LoginPluginMessage) {\n            LoginPluginMessage message = (LoginPluginMessage) packet;\n            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();\n            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN && message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(true);\n                response.setId(message.getId());\n                response.setData(createForwardingData(configuration.getForwardingSecret(), connection.getProxyPlayer().getRemoteAddress().getHostString(), connection.getProxyPlayer().getProfile()));\n                connection.getMinecraftConnection().write(response);\n                informationForwarded = true;\n            } else {\n                // Don't understand\n                LoginPluginResponse response = new LoginPluginResponse();\n                response.setSuccess(false);\n                response.setId(message.getId());\n                response.setData(Unpooled.EMPTY_BUFFER);\n                connection.getMinecraftConnection().write(response);\n            }\n        } else if (packet instanceof Disconnect) {\n            Disconnect disconnect = (Disconnect) packet;\n            // Do we have an outstanding notification? If so, fulfill it.\n            doNotify(ConnectionRequestResults.forDisconnect(disconnect));\n            connection.disconnect();\n        } else if (packet instanceof SetCompression) {\n            SetCompression sc = (SetCompression) packet;\n            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());\n        } else if (packet instanceof ServerLoginSuccess) {\n            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN && !informationForwarded) {\n                doNotify(ConnectionRequestResults.forDisconnect(TextComponent.of(\"Your server did not send a forwarding request to the proxy. Is it set up correctly?\")));\n                connection.disconnect();\n                return;\n            }\n            // The player has been logged on to the backend server.\n            connection.getMinecraftConnection().setState(StateRegistry.PLAY);\n            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();\n            if (existingConnection == null) {\n                // Strap on the play session handler\n                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));\n            } else {\n                // The previous server connection should become obsolete.\n                existingConnection.disconnect();\n            }\n            doNotify(ConnectionRequestResults.SUCCESSFUL);\n            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));\n            connection.getProxyPlayer().setConnectedServer(connection);\n        }\n    }\n\n    @Override\n    public void exception(Throwable throwable) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel().attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.completeExceptionally(throwable);\n        }\n    }\n\n    private void doNotify(ConnectionRequestBuilder.Result result) {\n        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel().attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);\n        if (future != null) {\n            future.complete(result);\n        }\n    }\n\n    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {\n        ByteBuf dataToForward = Unpooled.buffer();\n        ByteBuf finalData = Unpooled.buffer();\n        try {\n            ProtocolUtils.writeString(dataToForward, address);\n            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());\n            ProtocolUtils.writeString(dataToForward, profile.getName());\n            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());\n            for (GameProfile.Property property : profile.getProperties()) {\n                ProtocolUtils.writeString(dataToForward, property.getName());\n                ProtocolUtils.writeString(dataToForward, property.getValue());\n                String signature = property.getSignature();\n                if (signature != null) {\n                    dataToForward.writeBoolean(true);\n                    ProtocolUtils.writeString(dataToForward, signature);\n                } else {\n                    dataToForward.writeBoolean(false);\n                }\n            }\n            SecretKey key = new SecretKeySpec(hmacSecret, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(key);\n            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());\n            byte[] sig = mac.doFinal();\n            finalData.writeBytes(sig);\n            finalData.writeBytes(dataToForward);\n            return finalData;\n        } catch (InvalidKeyException e) {\n            finalData.release();\n            throw new RuntimeException(\"Unable to authenticate data\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // Should never happen\n            finalData.release();\n            throw new AssertionError(e);\n        } finally {\n            dataToForward.release();\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "e221bba277ec3b7366089248282c8d030b848dd5", "ext": "java", "lang": "Java", "content": "public class GtidSet {\n\n    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();\n\n    /**\n     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).\n     */\n    public GtidSet(String gtidSet) {\n        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(\",\");\n        for (String uuidSet : uuidSets) {\n            int uuidSeparatorIndex = uuidSet.indexOf(\":\");\n            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);\n            List<Interval> intervals = new ArrayList<Interval>();\n            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(\":\");\n            for (String interval : rawIntervals) {\n                String[] is = interval.split(\"-\");\n                long[] split = new long[is.length];\n                for (int i = 0, e = is.length; i < e; i++) {\n                    split[i] = Long.parseLong(is[i]);\n                }\n                if (split.length == 1) {\n                    split = new long[] { split[0], split[0] };\n                }\n                intervals.add(new Interval(split[0], split[1]));\n            }\n            map.put(sourceId, new UUIDSet(sourceId, intervals));\n        }\n    }\n\n    public Collection<UUIDSet> getUUIDSets() {\n        return map.values();\n    }\n\n    /**\n     * @param gtid GTID (\"source_id:transaction_id\")\n     * @return whether or not gtid was added to the set (false if it was already there)\n     */\n    public boolean add(String gtid) {\n        String[] split = gtid.split(\":\");\n        String sourceId = split[0];\n        long transactionId = Long.parseLong(split[1]);\n        UUIDSet uuidSet = map.get(sourceId);\n        if (uuidSet == null) {\n            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));\n        }\n        List<Interval> intervals = (List<Interval>) uuidSet.intervals;\n        int index = findInterval(intervals, transactionId);\n        boolean addedToExisting = false;\n        if (index < intervals.size()) {\n            Interval interval = intervals.get(index);\n            if (interval.start == transactionId + 1) {\n                interval.start = transactionId;\n                addedToExisting = true;\n            } else if (interval.end + 1 == transactionId) {\n                interval.end = transactionId;\n                addedToExisting = true;\n            } else if (interval.start <= transactionId && transactionId <= interval.end) {\n                return false;\n            }\n        }\n        if (!addedToExisting) {\n            intervals.add(index, new Interval(transactionId, transactionId));\n        }\n        if (intervals.size() > 1) {\n            joinAdjacentIntervals(intervals, index);\n        }\n        return true;\n    }\n\n    /**\n     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).\n     */\n    private void joinAdjacentIntervals(List<Interval> intervals, int index) {\n        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {\n            Interval a = intervals.get(i - 1), b = intervals.get(i);\n            if (a.end + 1 == b.start) {\n                a.end = b.end;\n                intervals.remove(i);\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        List<String> gtids = new ArrayList<String>();\n        for (UUIDSet uuidSet : map.values()) {\n            gtids.add(uuidSet.getUUID() + \":\" + join(uuidSet.intervals, \":\"));\n        }\n        return join(gtids, \",\");\n    }\n\n    /**\n     * @return index which is either a pointer to the interval containing v or a position at which v can be added\n     */\n    private static int findInterval(List<Interval> ii, long v) {\n        int l = 0, p = 0, r = ii.size();\n        for (; l < r; ) {\n            p = (l + r) / 2;\n            Interval i = ii.get(p);\n            if (i.end < v) {\n                l = p + 1;\n            } else if (v < i.start) {\n                r = p;\n            } else {\n                return p;\n            }\n        }\n        if (!ii.isEmpty() && ii.get(p).end < v) {\n            p++;\n        }\n        return p;\n    }\n\n    private String join(Collection o, String delimiter) {\n        if (o.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Object o1 : o) {\n            sb.append(o1).append(delimiter);\n        }\n        return sb.substring(0, sb.length() - delimiter.length());\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class UUIDSet {\n\n        private String uuid;\n\n        private Collection<Interval> intervals;\n\n        private UUIDSet(String uuid, Collection<Interval> intervals) {\n            this.uuid = uuid;\n            this.intervals = intervals;\n        }\n\n        public String getUUID() {\n            return uuid;\n        }\n\n        public Collection<Interval> getIntervals() {\n            return intervals;\n        }\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class Interval implements Comparable<Interval> {\n\n        private long start;\n\n        private long end;\n\n        private Interval(long start, long end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        public long getStart() {\n            return start;\n        }\n\n        public long getEnd() {\n            return end;\n        }\n\n        @Override\n        public String toString() {\n            return start + \"-\" + end;\n        }\n\n        @Override\n        public int compareTo(Interval o) {\n            return saturatedCast(this.start - o.start);\n        }\n\n        private static int saturatedCast(long value) {\n            if (value > Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n            if (value < Integer.MIN_VALUE) {\n                return Integer.MIN_VALUE;\n            }\n            return (int) value;\n        }\n    }\n}\n", "class_id": 0, "repo": "rong360/cdc", "file": "src/main/java/com/github/shyiko/mysql/binlog/GtidSet.java", "last_update_at": "2021-07-20T01:41:18+00:00", "original_content": "public class GtidSet {\n\n    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();\n\n    /**\n     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).\n     */\n    public GtidSet(String gtidSet) {\n        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(\",\");\n        for (String uuidSet : uuidSets) {\n            int uuidSeparatorIndex = uuidSet.indexOf(\":\");\n            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);\n            List<Interval> intervals = new ArrayList<Interval>();\n            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(\":\");\n            for (String interval : rawIntervals) {\n                String[] is = interval.split(\"-\");\n                long[] split = new long[is.length];\n                for (int i = 0, e = is.length; i < e; i++) {\n                    split[i] = Long.parseLong(is[i]);\n                }\n                if (split.length == 1) {\n                    split = new long[] { split[0], split[0] };\n                }\n                intervals.add(new Interval(split[0], split[1]));\n            }\n            map.put(sourceId, new UUIDSet(sourceId, intervals));\n        }\n    }\n\n    public Collection<UUIDSet> getUUIDSets() {\n        return map.values();\n    }\n\n    /**\n     * @param gtid GTID (\"source_id:transaction_id\")\n     * @return whether or not gtid was added to the set (false if it was already there)\n     */\n    public boolean add(String gtid) {\n        String[] split = gtid.split(\":\");\n        String sourceId = split[0];\n        long transactionId = Long.parseLong(split[1]);\n        UUIDSet uuidSet = map.get(sourceId);\n        if (uuidSet == null) {\n            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));\n        }\n        List<Interval> intervals = (List<Interval>) uuidSet.intervals;\n        int index = findInterval(intervals, transactionId);\n        boolean addedToExisting = false;\n        if (index < intervals.size()) {\n            Interval interval = intervals.get(index);\n            if (interval.start == transactionId + 1) {\n                interval.start = transactionId;\n                addedToExisting = true;\n            } else if (interval.end + 1 == transactionId) {\n                interval.end = transactionId;\n                addedToExisting = true;\n            } else if (interval.start <= transactionId && transactionId <= interval.end) {\n                return false;\n            }\n        }\n        if (!addedToExisting) {\n            intervals.add(index, new Interval(transactionId, transactionId));\n        }\n        if (intervals.size() > 1) {\n            joinAdjacentIntervals(intervals, index);\n        }\n        return true;\n    }\n\n    /**\n     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).\n     */\n    private void joinAdjacentIntervals(List<Interval> intervals, int index) {\n        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {\n            Interval a = intervals.get(i - 1), b = intervals.get(i);\n            if (a.end + 1 == b.start) {\n                a.end = b.end;\n                intervals.remove(i);\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        List<String> gtids = new ArrayList<String>();\n        for (UUIDSet uuidSet : map.values()) {\n            gtids.add(uuidSet.getUUID() + \":\" + join(uuidSet.intervals, \":\"));\n        }\n        return join(gtids, \",\");\n    }\n\n    /**\n     * @return index which is either a pointer to the interval containing v or a position at which v can be added\n     */\n    private static int findInterval(List<Interval> ii, long v) {\n        int l = 0, p = 0, r = ii.size();\n        while (l < r) {\n            p = (l + r) / 2;\n            Interval i = ii.get(p);\n            if (i.end < v) {\n                l = p + 1;\n            } else if (v < i.start) {\n                r = p;\n            } else {\n                return p;\n            }\n        }\n        if (!ii.isEmpty() && ii.get(p).end < v) {\n            p++;\n        }\n        return p;\n    }\n\n    private String join(Collection o, String delimiter) {\n        if (o.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Object o1 : o) {\n            sb.append(o1).append(delimiter);\n        }\n        return sb.substring(0, sb.length() - delimiter.length());\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class UUIDSet {\n\n        private String uuid;\n\n        private Collection<Interval> intervals;\n\n        private UUIDSet(String uuid, Collection<Interval> intervals) {\n            this.uuid = uuid;\n            this.intervals = intervals;\n        }\n\n        public String getUUID() {\n            return uuid;\n        }\n\n        public Collection<Interval> getIntervals() {\n            return intervals;\n        }\n    }\n\n    /**\n     * @see GtidSet\n     */\n    public static final class Interval implements Comparable<Interval> {\n\n        private long start;\n\n        private long end;\n\n        private Interval(long start, long end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        public long getStart() {\n            return start;\n        }\n\n        public long getEnd() {\n            return end;\n        }\n\n        @Override\n        public String toString() {\n            return start + \"-\" + end;\n        }\n\n        @Override\n        public int compareTo(Interval o) {\n            return saturatedCast(this.start - o.start);\n        }\n\n        private static int saturatedCast(long value) {\n            if (value > Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE;\n            }\n            if (value < Integer.MIN_VALUE) {\n                return Integer.MIN_VALUE;\n            }\n            return (int) value;\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "76a729674dee4fe36c1fccda5f23c96fd9c3eae6", "ext": "java", "lang": "Java", "content": "public class ECSTaskTemplateTest {\n\n    @Test\n    public void shouldMerge() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\"parent-name\", \"parent-label\", null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnSettingsFromParent() throws Exception {\n        ECSTaskTemplate child = new // image is set to null\n        // image is set to null\n        ECSTaskTemplate(// image is set to null\n        \"child-name\", // image is set to null\n        \"child-label\", // image is set to null\n        null, // image is set to null\n        null, // image is set to null\n        \"child-repository-credentials\", // image is set to null\n        \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\"parent-name\", \"parent-label\", null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"parent-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnChildIfNoParent() throws Exception {\n        ECSTaskTemplate child = new // inheritFrom is null\n        // inheritFrom is null\n        ECSTaskTemplate(// inheritFrom is null\n        \"child-name\", // inheritFrom is null\n        \"child-label\", // inheritFrom is null\n        null, // inheritFrom is null\n        \"child-image\", // inheritFrom is null\n        \"child-repository-credentials\", // inheritFrom is null\n        \"EC2\", // inheritFrom is null\n        \"child-network-mode\", // inheritFrom is null\n        \"child-remoteFSRoot\", // inheritFrom is null\n        0, // inheritFrom is null\n        0, // inheritFrom is null\n        0, // inheritFrom is null\n        null, // inheritFrom is null\n        null, // inheritFrom is null\n        false, // inheritFrom is null\n        false, // inheritFrom is null\n        \"child-containerUser\", // inheritFrom is null\n        null, // inheritFrom is null\n        null, // inheritFrom is null\n        null, // inheritFrom is null\n        null, // inheritFrom is null\n        null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(null);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n}\n", "class_id": 0, "repo": "kdvy/amazon-ecs-plugin", "file": "src/test/java/com/cloudbees/jenkins/plugins/amazonecs/ECSTaskTemplateTest.java", "last_update_at": "2021-04-11T06:11:28+00:00", "original_content": "public class ECSTaskTemplateTest {\n\n    @Test\n    public void shouldMerge() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\"parent-name\", \"parent-label\", null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnSettingsFromParent() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\"child-name\", \"child-label\", // image is set to null\n        null, // image is set to null\n        null, // image is set to null\n        \"child-repository-credentials\", // image is set to null\n        \"EC2\", // image is set to null\n        \"child-network-mode\", // image is set to null\n        \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, \"parent\");\n        ECSTaskTemplate parent = new ECSTaskTemplate(\"parent-name\", \"parent-label\", null, \"parent-image\", \"parent-repository-credentials\", \"FARGATE\", \"parent-network-mode\", \"parent-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"parent-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"parent-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(parent);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n\n    @Test\n    public void shouldReturnChildIfNoParent() throws Exception {\n        ECSTaskTemplate child = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, // inheritFrom is null\n        null);\n        ECSTaskTemplate expected = new ECSTaskTemplate(\"child-name\", \"child-label\", null, \"child-image\", \"child-repository-credentials\", \"EC2\", \"child-network-mode\", \"child-remoteFSRoot\", 0, 0, 0, null, null, false, false, \"child-containerUser\", null, null, null, null, null, null, null);\n        ECSTaskTemplate result = child.merge(null);\n        assertTrue(EqualsBuilder.reflectionEquals(expected, result));\n    }\n}\n", "refactored": false}
{"hexsha": "21acef61c95ebaa70ee8aa8170419592df0fc1f2", "ext": "java", "lang": "Java", "content": "public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {\n\n    private HttpServletResponse response;\n\n    private MessageBodyWriter<Object> wrapped;\n\n    //\n    @SuppressWarnings(\"unchecked\")\n    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {\n        this.response = response;\n        this.wrapped = (MessageBodyWriter<Object>) writer;\n    }\n\n    //\n    @Override\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.isWriteable(type, genericType, annotations, mediaType);\n    }\n\n    //\n    @Override\n    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.getSize(entity, type, genericType, annotations, mediaType);\n    }\n\n    //\n    @Override\n    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders, new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders, new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    private static class HeadersWriterOutputStream extends FilterOutputStream {\n\n        private static final Http HTTP = new Http();\n\n        private boolean done;\n\n        private HttpServletResponse response;\n\n        private MultivaluedMap<String, Object> httpHeaders;\n\n        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {\n            super(out);\n            this.response = response;\n            this.httpHeaders = httpHeaders;\n        }\n\n        private void writeHeaders() {\n            if (done) {\n                return;\n            }\n            done = true;\n            if (httpHeaders == null) {\n                return;\n            }\n            HTTP.writeHeaders(response, httpHeaders);\n        }\n\n        //\n        @Override\n        public void write(int b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        //\n        @Override\n        public void write(byte[] b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        //\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeHeaders();\n            super.write(b, off, len);\n        }\n\n        //\n        @Override\n        public void flush() throws IOException {\n            writeHeaders();\n            super.flush();\n        }\n\n        //\n        @Override\n        public void close() throws IOException {\n            writeHeaders();\n            super.close();\n        }\n    }\n}\n", "class_id": 0, "repo": "Gmugra/net.cactusthorn.routing", "file": "core/src/main/java/net/cactusthorn/routing/body/writer/MessageBodyHeadersWriter.java", "last_update_at": "2021-08-30T09:07:33+00:00", "original_content": "public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {\n\n    private HttpServletResponse response;\n\n    private MessageBodyWriter<Object> wrapped;\n\n    //\n    @SuppressWarnings(\"unchecked\")\n    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {\n        this.response = response;\n        this.wrapped = (MessageBodyWriter<Object>) writer;\n    }\n\n    //\n    @Override\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.isWriteable(type, genericType, annotations, mediaType);\n    }\n\n    //\n    @Override\n    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return wrapped.getSize(entity, type, genericType, annotations, mediaType);\n    }\n\n    //\n    @Override\n    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders, new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders, new HeadersWriterOutputStream(entityStream, response, httpHeaders));\n    }\n\n    private static class HeadersWriterOutputStream extends FilterOutputStream {\n\n        private static final Http HTTP = new Http();\n\n        private boolean done;\n\n        private HttpServletResponse response;\n\n        private MultivaluedMap<String, Object> httpHeaders;\n\n        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {\n            super(out);\n            this.response = response;\n            this.httpHeaders = httpHeaders;\n        }\n\n        private void writeHeaders() {\n            if (done) {\n                return;\n            }\n            done = true;\n            if (httpHeaders == null) {\n                return;\n            }\n            HTTP.writeHeaders(response, httpHeaders);\n        }\n\n        //\n        @Override\n        public void write(int b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        //\n        @Override\n        public void write(byte[] b) throws IOException {\n            writeHeaders();\n            super.write(b);\n        }\n\n        //\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeHeaders();\n            super.write(b, off, len);\n        }\n\n        //\n        @Override\n        public void flush() throws IOException {\n            writeHeaders();\n            super.flush();\n        }\n\n        //\n        @Override\n        public void close() throws IOException {\n            writeHeaders();\n            super.close();\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "94049e169d9faa662dadee598b08f54cfa434623", "ext": "java", "lang": "Java", "content": "public class FilesTest {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        // ??????\r\n        String workDir = System.getProperty(\"user.dir\");\r\n        // ????\r\n        String className = Thread.currentThread().getStackTrace()[1].getClassName();\r\n        // ????\r\n        String classPath = workDir + \"\\\\src\\\\main\\\\java\\\\\" + className;\r\n        // ??????\".\"\r\n        String currentClass = classPath.replace(\".\", \"\\\\\") + \".java\";\r\n        // ??????currentClass?????files.txt\r\n        Files.copy(Paths.get(currentClass), new FileOutputStream(\"testFile\\\\files.txt\"));\r\n        // ??FilesTest.java???????\r\n        System.out.println(Files.isHidden(Paths.get(currentClass)));\r\n        // ?????FilesTest.java??????\r\n        List<String> lines = Files.readAllLines(Paths.get(currentClass), Charset.forName(\"UTF-8\"));\r\n        System.out.println(lines);\r\n        // ?????????\r\n        System.out.println(\"FilesTest.java?????\" + Files.size(Paths.get(currentClass)));\r\n        List<String> poem = new ArrayList<String>();\r\n        poem.add(\"?????\");\r\n        poem.add(\"?????\");\r\n        // ??????????????files.txt?\r\n        Files.write(Paths.get(\"testFile\\\\files.txt\"), poem, Charset.forName(\"UTF-8\"));\r\n        // ??C??????????\r\n        FileStore cStore = Files.getFileStore(Paths.get(currentClass));\r\n        System.out.println(\"C??????\" + cStore.getTotalSpace());\r\n        System.out.println(\"C???????\" + cStore.getUsableSpace());\r\n    }\r\n}\r\n", "class_id": 0, "repo": "longjiazuo/j2se-project", "file": "j2se-project/java-nio/src/main/java/org/light4j/nio/nio2/FilesTest.java", "last_update_at": "2021-03-01T09:19:06+00:00", "original_content": "public class FilesTest {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        // ??????\r\n        String workDir = System.getProperty(\"user.dir\");\r\n        // ????\r\n        String className = Thread.currentThread().getStackTrace()[1].getClassName();\r\n        // ????\r\n        String classPath = workDir + \"\\\\src\\\\main\\\\java\\\\\" + className;\r\n        // ??????\".\"\r\n        String currentClass = classPath.replace(\".\", \"\\\\\") + \".java\";\r\n        // ??????currentClass?????files.txt\r\n        Files.copy(Paths.get(currentClass), new FileOutputStream(\"testFile\\\\files.txt\"));\r\n        // ??FilesTest.java???????\r\n        System.out.println(Files.isHidden(Paths.get(currentClass)));\r\n        // ?????FilesTest.java??????\r\n        List<String> lines = Files.readAllLines(Paths.get(currentClass), Charset.forName(\"UTF-8\"));\r\n        System.out.println(lines);\r\n        // ?????????\r\n        System.out.println(\"FilesTest.java?????\" + Files.size(Paths.get(currentClass)));\r\n        List<String> poem = new ArrayList<String>();\r\n        poem.add(\"?????\");\r\n        poem.add(\"?????\");\r\n        // ??????????????files.txt?\r\n        Files.write(Paths.get(\"testFile\\\\files.txt\"), poem, Charset.forName(\"UTF-8\"));\r\n        // ??C??????????\r\n        FileStore cStore = Files.getFileStore(Paths.get(currentClass));\r\n        System.out.println(\"C??????\" + cStore.getTotalSpace());\r\n        System.out.println(\"C???????\" + cStore.getUsableSpace());\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "d435c5d4df7f64a11710b7026aabff7141738bd6", "ext": "java", "lang": "Java", "content": "public class Check implements Report {\n\n    public static Boolean check() {\n        File epubFile = new File(\"D:\\\\play\\\\epub\\\\public\\\\epub\\\\epub3.0\\\\q.epub\");\n        // simple constructor; errors are printed on stderr stream\n        EpubCheck epubcheck = new EpubCheck(epubFile);\n        // validate() returns true if no errors or warnings are found\n        Boolean result = epubcheck.validate();\n        return result;\n    }\n\n    @Override\n    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {\n    }\n\n    @Override\n    public void message(Message message, EPUBLocation epubLocation, Object... objects) {\n    }\n\n    @Override\n    public void info(String s, FeatureEnum featureEnum, String s2) {\n    }\n\n    @Override\n    public int getErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int getWarningCount() {\n        return 0;\n    }\n\n    @Override\n    public int getFatalErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int generate() {\n        return 0;\n    }\n\n    @Override\n    public void initialize() {\n    }\n\n    @Override\n    public void setEpubFileName(String s) {\n    }\n\n    @Override\n    public String getEpubFileName() {\n        return null;\n    }\n\n    @Override\n    public void setCustomMessageFile(String s) {\n    }\n\n    @Override\n    public String getCustomMessageFile() {\n        return null;\n    }\n\n    @Override\n    public int getReportingLevel() {\n        return 0;\n    }\n\n    @Override\n    public void setReportingLevel(int i) {\n    }\n\n    @Override\n    public void close() {\n    }\n\n    @Override\n    public void setOverrideFile(File file) {\n    }\n\n    @Override\n    public MessageDictionary getDictionary() {\n        return null;\n    }\n}\n", "class_id": 0, "repo": "seaalan/epub", "file": "app/controllers/EPUBCheck/Check.java", "last_update_at": "2021-05-08T11:24:20+00:00", "original_content": "public class Check implements Report {\n\n    public static Boolean check() {\n        File epubFile = new File(\"D:\\\\play\\\\epub\\\\public\\\\epub\\\\epub3.0\\\\q.epub\");\n        // simple constructor; errors are printed on stderr stream\n        EpubCheck epubcheck = new EpubCheck(epubFile);\n        // validate() returns true if no errors or warnings are found\n        Boolean result = epubcheck.validate();\n        return result;\n    }\n\n    @Override\n    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {\n    }\n\n    @Override\n    public void message(Message message, EPUBLocation epubLocation, Object... objects) {\n    }\n\n    @Override\n    public void info(String s, FeatureEnum featureEnum, String s2) {\n    }\n\n    @Override\n    public int getErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int getWarningCount() {\n        return 0;\n    }\n\n    @Override\n    public int getFatalErrorCount() {\n        return 0;\n    }\n\n    @Override\n    public int generate() {\n        return 0;\n    }\n\n    @Override\n    public void initialize() {\n    }\n\n    @Override\n    public void setEpubFileName(String s) {\n    }\n\n    @Override\n    public String getEpubFileName() {\n        return null;\n    }\n\n    @Override\n    public void setCustomMessageFile(String s) {\n    }\n\n    @Override\n    public String getCustomMessageFile() {\n        return null;\n    }\n\n    @Override\n    public int getReportingLevel() {\n        return 0;\n    }\n\n    @Override\n    public void setReportingLevel(int i) {\n    }\n\n    @Override\n    public void close() {\n    }\n\n    @Override\n    public void setOverrideFile(File file) {\n    }\n\n    @Override\n    public MessageDictionary getDictionary() {\n        return null;\n    }\n}\n", "refactored": false}
{"hexsha": "d4b842cf649bd0cd1ede7fa0da8285f1b5d69bd0", "ext": "java", "lang": "Java", "content": "public final class SeaSlater64RNG implements RandomnessSource, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private long stateA, stateB;\n\n    /**\n     * Creates a new generator seeded using two calls to Math.random().\n     */\n    public SeaSlater64RNG() {\n        setState((long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L), (long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));\n    }\n\n    /**\n     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for\n     * the two parts of state this has with {@link #setSeed(long)}.\n     * @param seed a long that will be used to generate both components of state\n     */\n    public SeaSlater64RNG(final long seed) {\n        setSeed(seed);\n    }\n\n    /**\n     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that\n     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).\n     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0\n     * @param stateB the number to use as the second part of the state\n     */\n    public SeaSlater64RNG(final long stateA, final long stateB) {\n        setState(stateA, stateB);\n    }\n\n    @Override\n    public final int next(int bits) {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));\n    }\n\n    /**\n     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.\n     * @return any int, all 32 bits are random\n     */\n    public final int nextInt() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);\n    }\n\n    @Override\n    public final long nextLong() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (result << 12) - (result << 9 | result >>> 55);\n    }\n\n    /**\n     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the\n     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to\n     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.\n     *\n     * @return a copy of this RandomnessSource\n     */\n    @Override\n    public SeaSlater64RNG copy() {\n        return new SeaSlater64RNG(stateA, stateB);\n    }\n\n    /**\n     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get\n     * two longs. If the states would both be 0, state A is assigned 1 instead.\n     * @param seed the long to use to produce this generator's state\n     */\n    public void setSeed(final long seed) {\n        long z = seed;\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateA = z ^ (z >>> 31);\n        z = (seed + 0x9E3779B97F4A7C15L);\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateB = z ^ (z >>> 31);\n    }\n\n    public long getStateA() {\n        return stateA;\n    }\n\n    public void setStateA(long stateA) {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n    }\n\n    public long getStateB() {\n        return stateB;\n    }\n\n    /**\n     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is\n     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateB any int\n     */\n    public void setStateB(long stateB) {\n        this.stateB = stateB;\n        if ((stateB | stateA) == 0)\n            stateA = 1;\n    }\n\n    /**\n     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any\n     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).\n     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)\n     * @param stateB any int\n     */\n    public void setState(long stateA, long stateB) {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n        this.stateB = stateB;\n    }\n\n    @Override\n    public String toString() {\n        return \"SeaSlater32RNG with stateA 0x\" + StringKit.hex(stateA) + \"L and stateB 0x\" + StringKit.hex(stateB) + 'L';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;\n        if (stateA != seaSlater64RNG.stateA)\n            return false;\n        return stateB == seaSlater64RNG.stateB;\n    }\n\n    @Override\n    public int hashCode() {\n        final long h = (31L * stateA + stateB);\n        return (int) (h ^ h >>> 32);\n    }\n}\n", "class_id": 0, "repo": "Solido/sarong", "file": "src/main/java/sarong/SeaSlater64RNG.java", "last_update_at": "2021-07-24T14:10:33+00:00", "original_content": "public final class SeaSlater64RNG implements RandomnessSource, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private long stateA, stateB;\n\n    /**\n     * Creates a new generator seeded using two calls to Math.random().\n     */\n    public SeaSlater64RNG() {\n        setState((long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L), (long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));\n    }\n\n    /**\n     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for\n     * the two parts of state this has with {@link #setSeed(long)}.\n     * @param seed a long that will be used to generate both components of state\n     */\n    public SeaSlater64RNG(final long seed) {\n        setSeed(seed);\n    }\n\n    /**\n     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that\n     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).\n     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0\n     * @param stateB the number to use as the second part of the state\n     */\n    public SeaSlater64RNG(final long stateA, final long stateB) {\n        setState(stateA, stateB);\n    }\n\n    @Override\n    public final int next(int bits) {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));\n    }\n\n    /**\n     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.\n     * @return any int, all 32 bits are random\n     */\n    public final int nextInt() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);\n    }\n\n    @Override\n    public final long nextLong() {\n        final long s0 = stateA;\n        final long s1 = stateB ^ s0;\n        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);\n        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);\n        stateB = (s1 << 37 | s1 >>> 27);\n        return (result << 12) - (result << 9 | result >>> 55);\n    }\n\n    /**\n     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the\n     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to\n     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.\n     *\n     * @return a copy of this RandomnessSource\n     */\n    @Override\n    public SeaSlater64RNG copy() {\n        return new SeaSlater64RNG(stateA, stateB);\n    }\n\n    /**\n     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get\n     * two longs. If the states would both be 0, state A is assigned 1 instead.\n     * @param seed the long to use to produce this generator's state\n     */\n    public void setSeed(final long seed) {\n        long z = seed;\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateA = z ^ (z >>> 31);\n        z = (seed + 0x9E3779B97F4A7C15L);\n        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;\n        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;\n        stateB = z ^ (z >>> 31);\n    }\n\n    public long getStateA() {\n        return stateA;\n    }\n\n    public void setStateA(long stateA) {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n    }\n\n    public long getStateB() {\n        return stateB;\n    }\n\n    /**\n     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is\n     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you\n     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call\n     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().\n     * @param stateB any int\n     */\n    public void setStateB(long stateB) {\n        this.stateB = stateB;\n        if ((stateB | stateA) == 0)\n            stateA = 1;\n    }\n\n    /**\n     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any\n     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).\n     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)\n     * @param stateB any int\n     */\n    public void setState(long stateA, long stateB) {\n        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;\n        this.stateB = stateB;\n    }\n\n    @Override\n    public String toString() {\n        return \"SeaSlater32RNG with stateA 0x\" + StringKit.hex(stateA) + \"L and stateB 0x\" + StringKit.hex(stateB) + 'L';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;\n        if (stateA != seaSlater64RNG.stateA)\n            return false;\n        return stateB == seaSlater64RNG.stateB;\n    }\n\n    @Override\n    public int hashCode() {\n        final long h = (31L * stateA + stateB);\n        return (int) (h ^ h >>> 32);\n    }\n}\n", "refactored": false}
{"hexsha": "4f01c8a8bfaf6520ab50b8203cdbd576b2539387", "ext": "java", "lang": "Java", "content": "@TypeCapability(inputs = { \"de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS\" })\npublic class POSTokenRatio extends FeatureExtractorResource_ImplBase implements FeatureExtractor {\n\n    public static final String FN_NounRatio = \"NounRatio\";\n\n    public static final String FN_VerbRatio = \"VerbRatio\";\n\n    public static final String FN_AdjectivRatio = \"AdjectivRatio\";\n\n    @Override\n    public Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget) throws TextClassificationException {\n        int numberOfTokens = JCasUtil.select(jcas, POS.class).size();\n        //Nouns, Verbs\n        int numberOfNouns = 0;\n        int numberOfVerbs = 0;\n        int numberOfAdjectives = 0;\n        for (POS pos : JCasUtil.select(jcas, POS.class)) {\n            System.out.println(pos.getCoarseValue());\n            if (pos.getCoarseValue().startsWith(\"N\")) {\n                numberOfNouns++;\n            }\n            if (pos.getCoarseValue().equals(\"VERB\")) {\n                numberOfVerbs++;\n            }\n            if (pos.getCoarseValue().equals(\"ADJ\")) {\n                numberOfAdjectives++;\n            }\n        }\n        double nr = (1.0 * numberOfNouns) / numberOfTokens;\n        double vr = (1.0 * numberOfVerbs) / numberOfTokens;\n        double ar = (1.0 * numberOfAdjectives) / numberOfTokens;\n        Set<Feature> features = new HashSet<Feature>();\n        features.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));\n        features.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));\n        features.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));\n        return features;\n    }\n}\n", "class_id": 0, "repo": "ltl-ude/escrito", "file": "de.unidue.ltl.escrito/de.unidue.ltl.escrito.features/src/main/java/de/unidue/ltl/escrito/features/complexity/POSTokenRatio.java", "last_update_at": "2021-04-17T16:57:54+00:00", "original_content": "@TypeCapability(inputs = { \"de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS\" })\npublic class POSTokenRatio extends FeatureExtractorResource_ImplBase implements FeatureExtractor {\n\n    public static final String FN_NounRatio = \"NounRatio\";\n\n    public static final String FN_VerbRatio = \"VerbRatio\";\n\n    public static final String FN_AdjectivRatio = \"AdjectivRatio\";\n\n    @Override\n    public Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget) throws TextClassificationException {\n        int numberOfTokens = JCasUtil.select(jcas, POS.class).size();\n        //Nouns, Verbs\n        int numberOfNouns = 0;\n        int numberOfVerbs = 0;\n        int numberOfAdjectives = 0;\n        for (POS pos : JCasUtil.select(jcas, POS.class)) {\n            System.out.println(pos.getCoarseValue());\n            if (pos.getCoarseValue().startsWith(\"N\")) {\n                numberOfNouns++;\n            }\n            if (pos.getCoarseValue().equals(\"VERB\")) {\n                numberOfVerbs++;\n            }\n            if (pos.getCoarseValue().equals(\"ADJ\")) {\n                numberOfAdjectives++;\n            }\n        }\n        double nr = (1.0 * numberOfNouns) / numberOfTokens;\n        double vr = (1.0 * numberOfVerbs) / numberOfTokens;\n        double ar = (1.0 * numberOfAdjectives) / numberOfTokens;\n        Set<Feature> features = new HashSet<Feature>();\n        features.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));\n        features.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));\n        features.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));\n        return features;\n    }\n}\n", "refactored": false}
{"hexsha": "0b6a14048aa7baf6a73dc2a1cc1f8a4284ce3354", "ext": "java", "lang": "Java", "content": "@TestPropertySource(\"classpath:testFm.properties\")\npublic class DgFmTest extends AbstractWebTest {\n\n    @Autowired\n    private DgFmService fmService;\n\n    @Test\n    public void testFmInit() {\n        assertTrue(\"Must have at least one feature\", fmService.featuresCount() > 0);\n    }\n\n    @Test\n    public void testBasics() {\n        assertThatFeature(\"defaults\", allOf(visible(), enabled(), not(mandatory())));\n        assertThatFeature(\"allEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"allDisabled\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"reverseDefaults\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testMixins() {\n        assertThatFeature(\"allDisabledMixin\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"mandatoryWithAllDisabledMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mandatoryWithAllDisabledChainedMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mixingInAllEnabled\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testVisibleDeps() {\n        assertThatFeature(\"visibleDepsAllDisabled\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllDisabledChained\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllEnabled\", allOf(not(visible()), enabled(), not(mandatory())));\n    }\n\n    @Test\n    public void testMandatoryDeps() {\n        assertThatFeature(\"mandatoryDepsAllDisabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabledChained\", allOf(visible(), enabled(), mandatory()));\n    }\n\n    @Test\n    public void testEnabledDeps() {\n        assertThatFeature(\"enabledDepsAllDisabled\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllDisabledChained\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllEnabled\", allOf(visible(), not(enabled()), not(mandatory())));\n    }\n\n    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {\n        assertThat(fmService.getFeature(featureName), matcher);\n    }\n\n    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {\n        assertEquals(fmService.isFeatureVisible(featureName), visible);\n        assertEquals(fmService.isFeatureEnabled(featureName), enabled);\n        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);\n    }\n\n    private Matcher<DgFeature> visible() {\n        return describedAs(\"visible\", hasProperty(\"visible\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> mandatory() {\n        return describedAs(\"mandatory\", hasProperty(\"mandatory\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> enabled() {\n        return describedAs(\"enabled\", hasProperty(\"enabled\", equalTo(true)));\n    }\n}\n", "class_id": 0, "repo": "devgateway/ocportal", "file": "web/src/test/java/org/devgateway/toolkit/web/fm/DgFmTest.java", "last_update_at": "2021-11-06T19:24:23+00:00", "original_content": "@TestPropertySource(\"classpath:testFm.properties\")\npublic class DgFmTest extends AbstractWebTest {\n\n    @Autowired\n    private DgFmService fmService;\n\n    @Test\n    public void testFmInit() {\n        assertTrue(\"Must have at least one feature\", fmService.featuresCount() > 0);\n    }\n\n    @Test\n    public void testBasics() {\n        assertThatFeature(\"defaults\", allOf(visible(), enabled(), not(mandatory())));\n        assertThatFeature(\"allEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"allDisabled\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"reverseDefaults\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testMixins() {\n        assertThatFeature(\"allDisabledMixin\", allOf(not(visible()), not(enabled()), not(mandatory())));\n        assertThatFeature(\"mandatoryWithAllDisabledMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mandatoryWithAllDisabledChainedMixin\", allOf(not(visible()), not(enabled()), mandatory()));\n        assertThatFeature(\"mixingInAllEnabled\", allOf(not(visible()), not(enabled()), mandatory()));\n    }\n\n    @Test\n    public void testVisibleDeps() {\n        assertThatFeature(\"visibleDepsAllDisabled\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllDisabledChained\", allOf(not(visible()), enabled(), not(mandatory())));\n        assertThatFeature(\"visibleDepsAllEnabled\", allOf(not(visible()), enabled(), not(mandatory())));\n    }\n\n    @Test\n    public void testMandatoryDeps() {\n        assertThatFeature(\"mandatoryDepsAllDisabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabled\", allOf(visible(), enabled(), mandatory()));\n        assertThatFeature(\"mandatoryDepsAllEnabledChained\", allOf(visible(), enabled(), mandatory()));\n    }\n\n    @Test\n    public void testEnabledDeps() {\n        assertThatFeature(\"enabledDepsAllDisabled\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllDisabledChained\", allOf(visible(), not(enabled()), not(mandatory())));\n        assertThatFeature(\"enabledDepsAllEnabled\", allOf(visible(), not(enabled()), not(mandatory())));\n    }\n\n    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {\n        assertThat(fmService.getFeature(featureName), matcher);\n    }\n\n    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {\n        assertEquals(fmService.isFeatureVisible(featureName), visible);\n        assertEquals(fmService.isFeatureEnabled(featureName), enabled);\n        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);\n    }\n\n    private Matcher<DgFeature> visible() {\n        return describedAs(\"visible\", hasProperty(\"visible\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> mandatory() {\n        return describedAs(\"mandatory\", hasProperty(\"mandatory\", equalTo(true)));\n    }\n\n    private Matcher<DgFeature> enabled() {\n        return describedAs(\"enabled\", hasProperty(\"enabled\", equalTo(true)));\n    }\n}\n", "refactored": false}
{"hexsha": "65080318e0435ec7c0c7d4789c2b76ffc5799d38", "ext": "java", "lang": "Java", "content": "public class CSSRule {\n\n    private Set<String> selectors;\n\n    private Map<String, String> properties;\n\n    public CSSRule() {\n        this.selectors = new HashSet<>();\n        this.properties = new HashMap<>();\n    }\n\n    public CSSRule(Set<String> selectors, Map<String, String> properties) {\n        this.selectors = selectors;\n        this.properties = properties;\n    }\n\n    public static List<CSSRule> fromString(String text) {\n        List<CSSRule> rep = new ArrayList<>();\n        text = text.replaceAll(\"\\\\s+\", \"\");\n        String[] declarations = text.split(\"}\");\n        for (String declaration : declarations) {\n            Set<String> selectors = new HashSet<>();\n            Map<String, String> properties = new HashMap<>();\n            CSSRule current = new CSSRule(selectors, properties);\n            String[] strings = declaration.split(\"\\\\{\");\n            if (strings.length < 2) {\n                continue;\n            }\n            String[] selectorsStr = strings[0].split(\",\");\n            String[] propertiesStr = strings[1].split(\";\");\n            selectors.addAll(Arrays.asList(selectorsStr));\n            for (String property : propertiesStr) {\n                String[] parts = property.split(\":\");\n                properties.put(parts[0], parts[1]);\n            }\n            rep.add(current);\n        }\n        return rep;\n    }\n\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    public boolean hasStyle(String style) {\n        return hasProperty(style);\n    }\n\n    public String getPropertyValue(String name) {\n        return properties.get(name);\n    }\n\n    public void setProperty(String name, String value) {\n        properties.put(name, value);\n    }\n\n    public Set<String> getSelectors() {\n        return selectors;\n    }\n\n    public void addSelector(String selector) {\n        this.selectors.add(selector);\n    }\n\n    public boolean hasSelector(String selector) {\n        return selectors.contains(selector);\n    }\n\n    public boolean hasClass(String clazz) {\n        return selectors.contains(\".\" + clazz);\n    }\n\n    public String toString(int indent) {\n        StringBuilder rep = new StringBuilder();\n        rep.append(spaces(indent)).append(String.join(\", \", selectors)).append(\" {\").append(\"\\n\");\n        for (Map.Entry<String, String> entry : properties.entrySet()) {\n            rep.append(spaces(indent + 2)).append(entry.getKey()).append(\": \").append(entry.getValue()).append(\";\\n\");\n        }\n        rep.append(spaces(indent)).append(\"}\\n\");\n        return rep.toString();\n    }\n\n    @Override\n    public String toString() {\n        return toString(0);\n    }\n\n    @Override\n    public CSSRule clone() {\n        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));\n    }\n}\n", "class_id": 0, "repo": "Feavy/Fea-XML-CSS-Parser", "file": "src/main/java/fr/feavy/xml/CSSRule.java", "last_update_at": "2021-04-20T20:07:40+00:00", "original_content": "public class CSSRule {\n\n    private Set<String> selectors;\n\n    private Map<String, String> properties;\n\n    public CSSRule() {\n        this.selectors = new HashSet<>();\n        this.properties = new HashMap<>();\n    }\n\n    public CSSRule(Set<String> selectors, Map<String, String> properties) {\n        this.selectors = selectors;\n        this.properties = properties;\n    }\n\n    public static List<CSSRule> fromString(String text) {\n        List<CSSRule> rep = new ArrayList<>();\n        text = text.replaceAll(\"\\\\s+\", \"\");\n        String[] declarations = text.split(\"}\");\n        for (String declaration : declarations) {\n            Set<String> selectors = new HashSet<>();\n            Map<String, String> properties = new HashMap<>();\n            CSSRule current = new CSSRule(selectors, properties);\n            String[] strings = declaration.split(\"\\\\{\");\n            if (strings.length < 2) {\n                continue;\n            }\n            String[] selectorsStr = strings[0].split(\",\");\n            String[] propertiesStr = strings[1].split(\";\");\n            selectors.addAll(Arrays.asList(selectorsStr));\n            for (String property : propertiesStr) {\n                String[] parts = property.split(\":\");\n                properties.put(parts[0], parts[1]);\n            }\n            rep.add(current);\n        }\n        return rep;\n    }\n\n    public Map<String, String> getProperties() {\n        return properties;\n    }\n\n    public boolean hasProperty(String name) {\n        return properties.containsKey(name);\n    }\n\n    public boolean hasStyle(String style) {\n        return hasProperty(style);\n    }\n\n    public String getPropertyValue(String name) {\n        return properties.get(name);\n    }\n\n    public void setProperty(String name, String value) {\n        properties.put(name, value);\n    }\n\n    public Set<String> getSelectors() {\n        return selectors;\n    }\n\n    public void addSelector(String selector) {\n        this.selectors.add(selector);\n    }\n\n    public boolean hasSelector(String selector) {\n        return selectors.contains(selector);\n    }\n\n    public boolean hasClass(String clazz) {\n        return selectors.contains(\".\" + clazz);\n    }\n\n    public String toString(int indent) {\n        StringBuilder rep = new StringBuilder();\n        rep.append(spaces(indent)).append(String.join(\", \", selectors)).append(\" {\").append(\"\\n\");\n        for (Map.Entry<String, String> entry : properties.entrySet()) {\n            rep.append(spaces(indent + 2)).append(entry.getKey()).append(\": \").append(entry.getValue()).append(\";\\n\");\n        }\n        rep.append(spaces(indent)).append(\"}\\n\");\n        return rep.toString();\n    }\n\n    @Override\n    public String toString() {\n        return toString(0);\n    }\n\n    @Override\n    public CSSRule clone() {\n        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));\n    }\n}\n", "refactored": false}
{"hexsha": "60326de5da5cf57c599ba2b10b06462f073332a3", "ext": "java", "lang": "Java", "content": "public class APIResponse {\n\n    private String responseMessage;\n\n    private int responseCode;\n\n    private String body;\n\n    APIResponse(int responseCode, String responseMessage, String body) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.body = body;\n    }\n\n    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {\n        final int responseCode = conn.getResponseCode();\n        final String responseMessage = conn.getResponseMessage();\n        String body;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            body = read(conn.getInputStream());\n        } else {\n            body = read(conn.getErrorStream());\n        }\n        return new APIResponse(responseCode, responseMessage, body);\n    }\n\n    public String getResponseMessage() {\n        return responseMessage;\n    }\n\n    public int getResponseCode() {\n        return responseCode;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public boolean isOK() {\n        return responseCode == HttpURLConnection.HTTP_OK;\n    }\n\n    public boolean isNotFound() {\n        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;\n    }\n\n    public boolean isError() {\n        return !isOK();\n    }\n\n    /**\n     * Read an input stream to a String.\n     *\n     * @param is The input stream.\n     * @return The data from the input stream as a String.\n     */\n    private static String read(InputStream is) {\n        if (is == null) {\n            return \"\";\n        }\n        Scanner scanner = new Scanner(is);\n        StringBuilder sb = new StringBuilder();\n        for (; scanner.hasNextLine(); ) {\n            sb.append(scanner.nextLine());\n        }\n        return sb.toString();\n    }\n}\n", "class_id": 0, "repo": "dalelane/ML4K-AI-Extension", "file": "src/com/kylecorry/ml4k/APIResponse.java", "last_update_at": "2021-12-05T13:30:19+00:00", "original_content": "public class APIResponse {\n\n    private String responseMessage;\n\n    private int responseCode;\n\n    private String body;\n\n    APIResponse(int responseCode, String responseMessage, String body) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.body = body;\n    }\n\n    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {\n        final int responseCode = conn.getResponseCode();\n        final String responseMessage = conn.getResponseMessage();\n        String body;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            body = read(conn.getInputStream());\n        } else {\n            body = read(conn.getErrorStream());\n        }\n        return new APIResponse(responseCode, responseMessage, body);\n    }\n\n    public String getResponseMessage() {\n        return responseMessage;\n    }\n\n    public int getResponseCode() {\n        return responseCode;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public boolean isOK() {\n        return responseCode == HttpURLConnection.HTTP_OK;\n    }\n\n    public boolean isNotFound() {\n        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;\n    }\n\n    public boolean isError() {\n        return !isOK();\n    }\n\n    /**\n     * Read an input stream to a String.\n     *\n     * @param is The input stream.\n     * @return The data from the input stream as a String.\n     */\n    private static String read(InputStream is) {\n        if (is == null) {\n            return \"\";\n        }\n        Scanner scanner = new Scanner(is);\n        StringBuilder sb = new StringBuilder();\n        while (scanner.hasNextLine()) {\n            sb.append(scanner.nextLine());\n        }\n        return sb.toString();\n    }\n}\n", "refactored": true}
{"hexsha": "c100f09e24353bbe744b998aaca1669e27678b45", "ext": "java", "lang": "Java", "content": "public class exercicio5 {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Ol?! Por favor informe qual o valor do seu sal?rio: R$ \");\n        Double salario = scanner.nextDouble();\n        final Double salarioMinimo = 788.0;\n        Double quantidadeSalariosMinimos = salario / salarioMinimo;\n        DecimalFormat df = new DecimalFormat(\"##.##\");\n        System.out.println(\"A quantidade de sal?rios m?nimos ?: \" + df.format(quantidadeSalariosMinimos));\n        scanner.close();\n    }\n}\n", "class_id": 0, "repo": "jpshimidt/Estudojava", "file": "ListaExercicios/ListaExercicios/src/exercicio5.java", "last_update_at": "2021-04-03T04:11:55+00:00", "original_content": "public class exercicio5 {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Ol?! Por favor informe qual o valor do seu sal?rio: R$ \");\n        Double salario = scanner.nextDouble();\n        final Double salarioMinimo = 788.0;\n        Double quantidadeSalariosMinimos = salario / salarioMinimo;\n        DecimalFormat df = new DecimalFormat(\"##.##\");\n        System.out.println(\"A quantidade de sal?rios m?nimos ?: \" + df.format(quantidadeSalariosMinimos));\n        scanner.close();\n    }\n}\n", "refactored": false}
{"hexsha": "225847a731ab9bc895536af2abea87cf195f916c", "ext": "java", "lang": "Java", "content": "@DynamicSerialize\npublic class FFMPBasinData {\n\n    public static final double GUIDANCE_MISSING = -999999.0;\n\n    // defaults\n    @DynamicSerializeElement\n    private String hucLevel;\n\n    @DynamicSerializeElement\n    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();\n\n    /**\n     * Pending load tasks that need to be run to fully populate basins\n     */\n    private final List<LoadTask> tasks = new ArrayList<LoadTask>();\n\n    /**\n     * Cache of basins in order for easy population from Load Tasks.\n     */\n    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();\n\n    /**\n     * Shared factory for efficient storage of data in basins.\n     */\n    private BasinMapFactory<Date> mapFactory = null;\n\n    /**\n     * Public one arg constructor\n     *\n     * @param huc_level\n     */\n    public FFMPBasinData(String hucLevel) {\n        setHucLevel(hucLevel);\n    }\n\n    /**\n     * No arg hibernate constructor\n     */\n    public FFMPBasinData() {\n    }\n\n    /**\n     * get the basin map\n     *\n     * @return\n     */\n    public Map<Long, FFMPBasin> getBasins() {\n        if (!tasks.isEmpty()) {\n            loadNow();\n        }\n        return basins;\n    }\n\n    /**\n     * Sets the basin map\n     *\n     * @param basins\n     */\n    public void setBasins(Map<Long, FFMPBasin> basins) {\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n        this.basins = basins;\n    }\n\n    /**\n     * Gets the HUC Level for this map\n     *\n     * @return\n     */\n    public String getHucLevel() {\n        return hucLevel;\n    }\n\n    /**\n     * Sets the HUC Level for this map\n     */\n    public void setHucLevel(String hucLevel) {\n        this.hucLevel = hucLevel;\n    }\n\n    /**\n     * Add to the hash\n     *\n     * @param key\n     * @param basin\n     */\n    public void put(Long key, FFMPBasin basin) {\n        getBasins().put(key, basin);\n    }\n\n    /**\n     * Gets the FFMPBasin from the hash\n     *\n     * @param key\n     * @return\n     */\n    public FFMPBasin get(Long key) {\n        return getBasins().get(key);\n    }\n\n    /**\n     * Gets a list of pfaf ids from the keys\n     *\n     * @return\n     */\n    public List<Long> getPfafIds() {\n        return new ArrayList<Long>(getBasins().keySet());\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param startDate\n     * @param finishDate\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate, Date afterDate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(beforeDate, afterDate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param exact\n     *            date\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(date);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param date\n     * @param expirationTime\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date, long epirationTime) {\n        float tvalue = 0.0f;\n        int i = 0;\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = getBasins().get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAverageValue(date, epirationTime);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins with areal\n     * weighting\n     *\n     * @param pfaf_ids\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, ArrayList<Double> areas) {\n        float tvalue = 0.0f;\n        float tarea = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                if (basin.getValue() != FFMPUtils.MISSING) {\n                    tvalue += (basin.getValue() * areas.get(i));\n                    tarea += areas.get(i);\n                }\n            }\n        }\n        if (tvalue < 0.0f) {\n            tvalue = FFMPUtils.MISSING;\n        } else {\n            tvalue = tvalue / tarea;\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins to a given time\n     *\n     * @param pfaf_ids\n     * @return\n     */\n    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAccumValue(beforeDate, afterDate, expirationTime, rate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a range of times in an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate, Date afterDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(beforeDate, afterDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     *\n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(List<Long> pfaf_ids, Date date, long expiration) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(date, expiration);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     *\n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate, Date beforeDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(afterDate, beforeDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a specific time in an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(List<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(date);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Average Guidance\n     *\n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getAverageGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, float guidance, List<Long> forcedPfafs, long expiration) {\n        float tvalue = 0.0f;\n        float value;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin == null) {\n                return guidance;\n            }\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (forcedPfafs.contains(pfaf)) {\n                    if (interpolation.isInterpolate()) {\n                        value = fgb.getInterpolatedValue(interpolation, expiration);\n                    } else {\n                        value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);\n                    }\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    tvalue += value;\n                    i++;\n                } else {\n                    if (interpolation.isInterpolate()) {\n                        float nvalue;\n                        if (new Float(guidance).isNaN()) {\n                            nvalue = fgb.getInterpolatedValue(interpolation, expiration);\n                        } else {\n                            nvalue = guidance;\n                        }\n                        if (nvalue > 0.0f) {\n                            tvalue += nvalue;\n                        }\n                        i++;\n                    } else {\n                        if (new Float(guidance).isNaN()) {\n                            value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);\n                        } else {\n                            value = guidance;\n                        }\n                        if (value > 0.0f) {\n                            tvalue += value;\n                        }\n                        i++;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            return Float.NaN;\n        }\n        return tvalue / i;\n    }\n\n    /**\n     * Extracts the Max value for a guidance aggregation of basins THIS IS\n     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse\n     *\n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getMaxGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration, long parentPfaf) {\n        float tvalue = Float.NaN;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                fgb.setCountyFips(parentPfaf);\n                if (interpolation.isInterpolate()) {\n                    float nvalue = fgb.getInterpolatedValue(interpolation, expiration);\n                    // ignore missing values\n                    if (nvalue < -999) {\n                        continue;\n                    }\n                    if (((nvalue < tvalue) && (nvalue > 0.0f)) || Float.isNaN(tvalue)) {\n                        tvalue = nvalue;\n                    }\n                } else {\n                    float value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    if (((value < tvalue) && (value > 0.0f)) || Float.isNaN(tvalue)) {\n                        tvalue = value;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            tvalue = Float.NaN;\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Accumulated Max value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @return\n     */\n    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                float val = basin.getAccumValue(afterDate, beforeDate, expirationTime, rate);\n                if (val > tvalue) {\n                    tvalue = val;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     *\n     * @param pfaf_ids\n     * @param interpolation\n     * @return\n     */\n    public List<Float> getGuidanceValues(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (interpolation.isInterpolate()) {\n                    values.add(fgb.getInterpolatedValue(interpolation, expiration));\n                } else {\n                    values.add(fgb.getValue(interpolation.getStandardSource(), interpolation, expiration));\n                }\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Gets the average guidance value for an aggregate basin\n     *\n     * @param pfaf_ids\n     * @param interpolation\n     * @param expiration\n     * @return\n     */\n    public Float getAverageGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration) {\n        float tvalue = 0.0f;\n        int i = 0;\n        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation, expiration);\n        if (vals != null) {\n            for (Float val : vals) {\n                tvalue += val;\n                i++;\n            }\n        } else {\n            return null;\n        }\n        return tvalue / i;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     *\n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @param rate\n     * @return\n     */\n    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                values.add(basin.getAccumValue(beforeDate, afterDate, expirationTime, rate));\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Purge out old data\n     *\n     * @param date\n     */\n    public void purgeData(Date date) {\n        // cause them to run\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                Iterator<LoadTask> itr = tasks.iterator();\n                {\n                    for (; itr.hasNext(); ) {\n                        LoadTask task = itr.next();\n                        if (task instanceof LoadMapTask) {\n                            LoadMapTask mtask = (LoadMapTask) task;\n                            if (mtask.date.before(date)) {\n                                itr.remove();\n                            }\n                        }\n                    }\n                }\n                if (tasks.isEmpty()) {\n                    orderedBasinsCache.clear();\n                }\n            }\n        }\n        for (FFMPBasin basin : basins.values()) {\n            basin.purgeData(date);\n        }\n    }\n\n    /**\n     * deserialize data from the aggregate record\n     *\n     * @param times\n     */\n    public void populate(List<Long> times) {\n        if (mapFactory == null) {\n            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(), getBasins().size());\n        }\n        long[] timesArr = new long[times.size()];\n        for (int i = 0; i < timesArr.length; i += 1) {\n            timesArr[i] = times.get(i);\n        }\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.deserialize(timesArr, mapFactory);\n        }\n    }\n\n    /**\n     * populates the serialized array/objects\n     */\n    public void serialize() {\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.serialize();\n        }\n    }\n\n    /**\n     * Add basins some basins from a datastoreFile. The basins will not be\n     * loaded immediately, they will be loaded when they are needed.\n     *\n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param siteKey\n     *            - siteKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param huc\n     *            - huc to load\n     * @param sourceName\n     *            - the sourceName for the data.\n     * @param date\n     *            - the date of the data.\n     * @param orderedPfafs\n     *            - a collection of Longs which is in the same order as the data\n     *            in the dataStore.\n     * @param aggregate\n     */\n    public void addBasins(File datastoreFile, String uri, String siteKey, String cwa, String huc, String sourceName, Date date, Collection<Long> orderedPfafs, boolean aggregate) {\n        SourceXML source = FFMPSourceConfigurationManager.getInstance().getSource(sourceName);\n        boolean guidance = source.getSourceType().equals(SOURCE_TYPE.GUIDANCE.getSourceType());\n        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa + DataStoreFactory.DEF_SEPARATOR + huc;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedPfafs.size()];\n                int j = 0;\n                for (Long pfaf : orderedPfafs) {\n                    FFMPBasin basin = this.basins.get(pfaf);\n                    if (basin == null) {\n                        if (guidance) {\n                            basin = new FFMPGuidanceBasin(pfaf, aggregate);\n                        } else {\n                            if (mapFactory == null) {\n                                mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(), orderedPfafs.size());\n                            }\n                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);\n                        }\n                        this.basins.put(pfaf, basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            if (guidance) {\n                tasks.add(new LoadGuidanceMapTask(datastoreFile, datasetGroupPath, basins, date, sourceName));\n            } else {\n                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath, basins, date));\n            }\n        }\n    }\n\n    /**\n     * Add virtual basins from a datastoreFile. The basins will not be loaded\n     * immediately, they will be loaded when they are needed.\n     *\n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param dataKey\n     *            - dataKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param date\n     *            - the date of the data.\n     * @param orderedMetadata\n     *            - a collection of FFMPVirtualGageBasinMetaData which is in the\n     *            same order as the data in the dataStore.\n     */\n    public void addVirtualBasins(File datastoreFile, String uri, String dataKey, String cwa, Date date, Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {\n        String basinsKey = dataKey + ' ' + cwa;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedMetadata.size()];\n                int j = 0;\n                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {\n                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());\n                    if (basin == null) {\n                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(), fvgbmd.getParentPfaf(), false);\n                        this.basins.put(fvgbmd.getLookupId(), basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath, basins, date));\n        }\n    }\n\n    /**\n     * Returns whether or not any basins have been put in the basins map. Faster\n     * than calling getBasins().size() or getBasins().isEmpty().\n     *\n     * @return\n     */\n    public boolean hasAnyBasins() {\n        return !basins.isEmpty();\n    }\n\n    /**\n     * Load now.\n     */\n    public void loadNow() {\n        synchronized (tasks) {\n            if (!tasks.isEmpty()) {\n                FFMPDataRecordLoader.loadRecords(tasks);\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n    }\n\n    /**\n     * Base task for loading data from a dataRecord into FFMPBasins\n     */\n    private class LoadMapTask extends LoadTask {\n\n        protected final FFMPBasin[] basins;\n\n        protected final Date date;\n\n        public LoadMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath);\n            this.basins = basins;\n            this.date = date;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void process(FloatDataRecord record) {\n            float[] values = record.getFloatData();\n            for (int j = 0; j < values.length; j += 1) {\n                applyValue(basins[j], values[j]);\n            }\n        }\n\n        /**\n         * Apply the value to the basin/\n         */\n        protected void applyValue(FFMPBasin basin, float value) {\n            if (basin.contains(date)) {\n                float curval = basin.getValue(date);\n                // These are QPF and QPE so, 0.0 is a valid amount\n                if (curval >= 0.0f && value >= 0.0f) {\n                    basin.setValue(date, (curval + value) / 2);\n                } else if (value >= 0.0f) {\n                    basin.setValue(date, value);\n                }\n            } else {\n                // no value at time exists, write regardless\n                basin.setValue(date, value);\n            }\n        }\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPGuidanceBasins\n     */\n    private class LoadGuidanceMapTask extends LoadMapTask {\n\n        private final String sourceName;\n\n        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date, String sourceName) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n            this.sourceName = sourceName;\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;\n            Float curval = gBasin.getValue(date, sourceName);\n            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {\n                // average of original and new value\n                if (curval > 0.0f && value > 0.0f) {\n                    gBasin.setValue(sourceName, date, (curval + value) / 2);\n                } else {\n                    // curval zero, overwrite original value\n                    if (curval == 0.0f) {\n                        gBasin.setValue(sourceName, date, value);\n                    }\n                }\n            } else {\n                // curval NaN or MISSING, Overwrite original value\n                gBasin.setValue(sourceName, date, value);\n            }\n        }\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPVirtualGageBasins\n     */\n    private class LoadVirtualMapTask extends LoadMapTask {\n\n        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            basin.setValue(date, value);\n        }\n    }\n}\n", "class_id": 0, "repo": "srcarter3/awips2", "file": "edexOsgi/com.raytheon.uf.common.dataplugin.ffmp/src/com/raytheon/uf/common/dataplugin/ffmp/FFMPBasinData.java", "last_update_at": "2021-10-30T00:03:05+00:00", "original_content": "@DynamicSerialize\npublic class FFMPBasinData {\n\n    public static final double GUIDANCE_MISSING = -999999.0;\n\n    // defaults\n    @DynamicSerializeElement\n    private String hucLevel;\n\n    @DynamicSerializeElement\n    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();\n\n    /**\n     * Pending load tasks that need to be run to fully populate basins\n     */\n    private final List<LoadTask> tasks = new ArrayList<LoadTask>();\n\n    /**\n     * Cache of basins in order for easy population from Load Tasks.\n     */\n    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();\n\n    /**\n     * Shared factory for efficient storage of data in basins.\n     */\n    private BasinMapFactory<Date> mapFactory = null;\n\n    /**\n     * Public one arg constructor\n     *\n     * @param huc_level\n     */\n    public FFMPBasinData(String hucLevel) {\n        setHucLevel(hucLevel);\n    }\n\n    /**\n     * No arg hibernate constructor\n     */\n    public FFMPBasinData() {\n    }\n\n    /**\n     * get the basin map\n     *\n     * @return\n     */\n    public Map<Long, FFMPBasin> getBasins() {\n        if (!tasks.isEmpty()) {\n            loadNow();\n        }\n        return basins;\n    }\n\n    /**\n     * Sets the basin map\n     *\n     * @param basins\n     */\n    public void setBasins(Map<Long, FFMPBasin> basins) {\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n        this.basins = basins;\n    }\n\n    /**\n     * Gets the HUC Level for this map\n     *\n     * @return\n     */\n    public String getHucLevel() {\n        return hucLevel;\n    }\n\n    /**\n     * Sets the HUC Level for this map\n     */\n    public void setHucLevel(String hucLevel) {\n        this.hucLevel = hucLevel;\n    }\n\n    /**\n     * Add to the hash\n     *\n     * @param key\n     * @param basin\n     */\n    public void put(Long key, FFMPBasin basin) {\n        getBasins().put(key, basin);\n    }\n\n    /**\n     * Gets the FFMPBasin from the hash\n     *\n     * @param key\n     * @return\n     */\n    public FFMPBasin get(Long key) {\n        return getBasins().get(key);\n    }\n\n    /**\n     * Gets a list of pfaf ids from the keys\n     *\n     * @return\n     */\n    public List<Long> getPfafIds() {\n        return new ArrayList<Long>(getBasins().keySet());\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param startDate\n     * @param finishDate\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate, Date afterDate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(beforeDate, afterDate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param exact\n     *            date\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getValue(date);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param date\n     * @param expirationTime\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date, long epirationTime) {\n        float tvalue = 0.0f;\n        int i = 0;\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = getBasins().get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAverageValue(date, epirationTime);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins with areal\n     * weighting\n     *\n     * @param pfaf_ids\n     * @return\n     */\n    public float getAverageValue(ArrayList<Long> pfaf_ids, ArrayList<Double> areas) {\n        float tvalue = 0.0f;\n        float tarea = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                if (basin.getValue() != FFMPUtils.MISSING) {\n                    tvalue += (basin.getValue() * areas.get(i));\n                    tarea += areas.get(i);\n                }\n            }\n        }\n        if (tvalue < 0.0f) {\n            tvalue = FFMPUtils.MISSING;\n        } else {\n            tvalue = tvalue / tarea;\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the average value for an aggregation of basins to a given time\n     *\n     * @param pfaf_ids\n     * @return\n     */\n    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                tvalue += basin.getAccumValue(beforeDate, afterDate, expirationTime, rate);\n                i++;\n            }\n        }\n        tvalue = tvalue / i;\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a range of times in an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate, Date afterDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(beforeDate, afterDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     *\n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(List<Long> pfaf_ids, Date date, long expiration) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(date, expiration);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Used for mosaic sources\n     *\n     * @param pfaf_ids\n     * @param date\n     * @param expiration\n     * @return\n     */\n    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate, Date beforeDate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getAverageValue(afterDate, beforeDate);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Max value for a specific time in an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param hour\n     * @return\n     */\n    public float getMaxValue(List<Long> pfaf_ids, Date date) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                Float value = basin.getValue(date);\n                if (value > tvalue) {\n                    tvalue = value;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * Average Guidance\n     *\n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getAverageGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, float guidance, List<Long> forcedPfafs, long expiration) {\n        float tvalue = 0.0f;\n        float value;\n        int i = 0;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin == null) {\n                return guidance;\n            }\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (forcedPfafs.contains(pfaf)) {\n                    if (interpolation.isInterpolate()) {\n                        value = fgb.getInterpolatedValue(interpolation, expiration);\n                    } else {\n                        value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);\n                    }\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    tvalue += value;\n                    i++;\n                } else {\n                    if (interpolation.isInterpolate()) {\n                        float nvalue;\n                        if (new Float(guidance).isNaN()) {\n                            nvalue = fgb.getInterpolatedValue(interpolation, expiration);\n                        } else {\n                            nvalue = guidance;\n                        }\n                        if (nvalue > 0.0f) {\n                            tvalue += nvalue;\n                        }\n                        i++;\n                    } else {\n                        if (new Float(guidance).isNaN()) {\n                            value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);\n                        } else {\n                            value = guidance;\n                        }\n                        if (value > 0.0f) {\n                            tvalue += value;\n                        }\n                        i++;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            return Float.NaN;\n        }\n        return tvalue / i;\n    }\n\n    /**\n     * Extracts the Max value for a guidance aggregation of basins THIS IS\n     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse\n     *\n     * @param pfaf_ids\n     * @param sourceName\n     * @return\n     */\n    public float getMaxGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration, long parentPfaf) {\n        float tvalue = Float.NaN;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                fgb.setCountyFips(parentPfaf);\n                if (interpolation.isInterpolate()) {\n                    float nvalue = fgb.getInterpolatedValue(interpolation, expiration);\n                    // ignore missing values\n                    if (nvalue < -999) {\n                        continue;\n                    }\n                    if (((nvalue < tvalue) && (nvalue > 0.0f)) || Float.isNaN(tvalue)) {\n                        tvalue = nvalue;\n                    }\n                } else {\n                    float value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);\n                    // ignore missing values\n                    if (value < -999) {\n                        continue;\n                    }\n                    if (((value < tvalue) && (value > 0.0f)) || Float.isNaN(tvalue)) {\n                        tvalue = value;\n                    }\n                }\n            }\n        }\n        if (tvalue == 0.0f) {\n            tvalue = Float.NaN;\n        }\n        return tvalue;\n    }\n\n    /**\n     * Extracts the Accumulated Max value for an aggregation of basins\n     *\n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @return\n     */\n    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {\n        float tvalue = 0.0f;\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                float val = basin.getAccumValue(afterDate, beforeDate, expirationTime, rate);\n                if (val > tvalue) {\n                    tvalue = val;\n                }\n            }\n        }\n        return tvalue;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     *\n     * @param pfaf_ids\n     * @param interpolation\n     * @return\n     */\n    public List<Float> getGuidanceValues(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;\n                if (interpolation.isInterpolate()) {\n                    values.add(fgb.getInterpolatedValue(interpolation, expiration));\n                } else {\n                    values.add(fgb.getValue(interpolation.getStandardSource(), interpolation, expiration));\n                }\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Gets the average guidance value for an aggregate basin\n     *\n     * @param pfaf_ids\n     * @param interpolation\n     * @param expiration\n     * @return\n     */\n    public Float getAverageGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration) {\n        float tvalue = 0.0f;\n        int i = 0;\n        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation, expiration);\n        if (vals != null) {\n            for (Float val : vals) {\n                tvalue += val;\n                i++;\n            }\n        } else {\n            return null;\n        }\n        return tvalue / i;\n    }\n\n    /**\n     * used for max ratio and diff calcs\n     *\n     * @param pfaf_ids\n     * @param beforeDate\n     * @param afterDate\n     * @param rate\n     * @return\n     */\n    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {\n        List<Float> values = new ArrayList<Float>();\n        Map<Long, FFMPBasin> localBasins = getBasins();\n        for (Long pfaf : pfaf_ids) {\n            FFMPBasin basin = localBasins.get(pfaf);\n            if (basin != null) {\n                values.add(basin.getAccumValue(beforeDate, afterDate, expirationTime, rate));\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Purge out old data\n     *\n     * @param date\n     */\n    public void purgeData(Date date) {\n        // cause them to run\n        if (!tasks.isEmpty()) {\n            synchronized (tasks) {\n                Iterator<LoadTask> itr = tasks.iterator();\n                {\n                    while (itr.hasNext()) {\n                        LoadTask task = itr.next();\n                        if (task instanceof LoadMapTask) {\n                            LoadMapTask mtask = (LoadMapTask) task;\n                            if (mtask.date.before(date)) {\n                                itr.remove();\n                            }\n                        }\n                    }\n                }\n                if (tasks.isEmpty()) {\n                    orderedBasinsCache.clear();\n                }\n            }\n        }\n        for (FFMPBasin basin : basins.values()) {\n            basin.purgeData(date);\n        }\n    }\n\n    /**\n     * deserialize data from the aggregate record\n     *\n     * @param times\n     */\n    public void populate(List<Long> times) {\n        if (mapFactory == null) {\n            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(), getBasins().size());\n        }\n        long[] timesArr = new long[times.size()];\n        for (int i = 0; i < timesArr.length; i += 1) {\n            timesArr[i] = times.get(i);\n        }\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.deserialize(timesArr, mapFactory);\n        }\n    }\n\n    /**\n     * populates the serialized array/objects\n     */\n    public void serialize() {\n        for (FFMPBasin basin : getBasins().values()) {\n            basin.serialize();\n        }\n    }\n\n    /**\n     * Add basins some basins from a datastoreFile. The basins will not be\n     * loaded immediately, they will be loaded when they are needed.\n     *\n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param siteKey\n     *            - siteKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param huc\n     *            - huc to load\n     * @param sourceName\n     *            - the sourceName for the data.\n     * @param date\n     *            - the date of the data.\n     * @param orderedPfafs\n     *            - a collection of Longs which is in the same order as the data\n     *            in the dataStore.\n     * @param aggregate\n     */\n    public void addBasins(File datastoreFile, String uri, String siteKey, String cwa, String huc, String sourceName, Date date, Collection<Long> orderedPfafs, boolean aggregate) {\n        SourceXML source = FFMPSourceConfigurationManager.getInstance().getSource(sourceName);\n        boolean guidance = source.getSourceType().equals(SOURCE_TYPE.GUIDANCE.getSourceType());\n        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa + DataStoreFactory.DEF_SEPARATOR + huc;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedPfafs.size()];\n                int j = 0;\n                for (Long pfaf : orderedPfafs) {\n                    FFMPBasin basin = this.basins.get(pfaf);\n                    if (basin == null) {\n                        if (guidance) {\n                            basin = new FFMPGuidanceBasin(pfaf, aggregate);\n                        } else {\n                            if (mapFactory == null) {\n                                mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(), orderedPfafs.size());\n                            }\n                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);\n                        }\n                        this.basins.put(pfaf, basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            if (guidance) {\n                tasks.add(new LoadGuidanceMapTask(datastoreFile, datasetGroupPath, basins, date, sourceName));\n            } else {\n                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath, basins, date));\n            }\n        }\n    }\n\n    /**\n     * Add virtual basins from a datastoreFile. The basins will not be loaded\n     * immediately, they will be loaded when they are needed.\n     *\n     * @param datastoreFile\n     *            - the file containing data.\n     * @param uri\n     *            - datauri of record to load\n     * @param dataKey\n     *            - dataKey to load\n     * @param cwa\n     *            - cwa to load\n     * @param date\n     *            - the date of the data.\n     * @param orderedMetadata\n     *            - a collection of FFMPVirtualGageBasinMetaData which is in the\n     *            same order as the data in the dataStore.\n     */\n    public void addVirtualBasins(File datastoreFile, String uri, String dataKey, String cwa, Date date, Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {\n        String basinsKey = dataKey + ' ' + cwa;\n        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;\n        synchronized (tasks) {\n            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);\n            if (basins == null) {\n                basins = new FFMPBasin[orderedMetadata.size()];\n                int j = 0;\n                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {\n                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());\n                    if (basin == null) {\n                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(), fvgbmd.getParentPfaf(), false);\n                        this.basins.put(fvgbmd.getLookupId(), basin);\n                    }\n                    basins[j++] = basin;\n                }\n                this.orderedBasinsCache.put(basinsKey, basins);\n            }\n            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath, basins, date));\n        }\n    }\n\n    /**\n     * Returns whether or not any basins have been put in the basins map. Faster\n     * than calling getBasins().size() or getBasins().isEmpty().\n     *\n     * @return\n     */\n    public boolean hasAnyBasins() {\n        return !basins.isEmpty();\n    }\n\n    /**\n     * Load now.\n     */\n    public void loadNow() {\n        synchronized (tasks) {\n            if (!tasks.isEmpty()) {\n                FFMPDataRecordLoader.loadRecords(tasks);\n                tasks.clear();\n                orderedBasinsCache.clear();\n            }\n        }\n    }\n\n    /**\n     * Base task for loading data from a dataRecord into FFMPBasins\n     */\n    private class LoadMapTask extends LoadTask {\n\n        protected final FFMPBasin[] basins;\n\n        protected final Date date;\n\n        public LoadMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath);\n            this.basins = basins;\n            this.date = date;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void process(FloatDataRecord record) {\n            float[] values = record.getFloatData();\n            for (int j = 0; j < values.length; j += 1) {\n                applyValue(basins[j], values[j]);\n            }\n        }\n\n        /**\n         * Apply the value to the basin/\n         */\n        protected void applyValue(FFMPBasin basin, float value) {\n            if (basin.contains(date)) {\n                float curval = basin.getValue(date);\n                // These are QPF and QPE so, 0.0 is a valid amount\n                if (curval >= 0.0f && value >= 0.0f) {\n                    basin.setValue(date, (curval + value) / 2);\n                } else if (value >= 0.0f) {\n                    basin.setValue(date, value);\n                }\n            } else {\n                // no value at time exists, write regardless\n                basin.setValue(date, value);\n            }\n        }\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPGuidanceBasins\n     */\n    private class LoadGuidanceMapTask extends LoadMapTask {\n\n        private final String sourceName;\n\n        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date, String sourceName) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n            this.sourceName = sourceName;\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;\n            Float curval = gBasin.getValue(date, sourceName);\n            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {\n                // average of original and new value\n                if (curval > 0.0f && value > 0.0f) {\n                    gBasin.setValue(sourceName, date, (curval + value) / 2);\n                } else {\n                    // curval zero, overwrite original value\n                    if (curval == 0.0f) {\n                        gBasin.setValue(sourceName, date, value);\n                    }\n                }\n            } else {\n                // curval NaN or MISSING, Overwrite original value\n                gBasin.setValue(sourceName, date, value);\n            }\n        }\n    }\n\n    /**\n     * Task for loading data from a dataRecord into FFMPVirtualGageBasins\n     */\n    private class LoadVirtualMapTask extends LoadMapTask {\n\n        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date) {\n            super(datastoreFile, datasetGroupPath, basins, date);\n        }\n\n        @Override\n        protected void applyValue(FFMPBasin basin, float value) {\n            basin.setValue(date, value);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "e32741ad1544b9465ebc4976051bd0b87f903644", "ext": "java", "lang": "Java", "content": "public class SupplierCompileCompletionTest extends OfficeFrameTestCase {\n\n    /**\n     * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.\n     */\n    public void testOfficeFloorCompileScope() {\n        // Capture the sources\n        CompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n        // Provide sources to capture the profiles\n        MockManagedObjectSource officeFloorMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();\n        MockTeamSource team = new MockTeamSource();\n        MockExecutiveSource executive = new MockExecutiveSource();\n        MockManagedObjectSource officeMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n        MockSupplierSource officeSupplier = new MockSupplierSource();\n        MockAdministrationSource admin = new MockAdministrationSource();\n        MockGovernanceSource govern = new MockGovernanceSource();\n        MockManagedObjectSource sectionMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n        MockManagedFunctionSource function = new MockManagedFunctionSource();\n        // Compile\n        CompileOfficeFloor compiler = new CompileOfficeFloor();\n        compiler.officeFloor((context) -> {\n            OfficeFloorDeployer deployer = context.getOfficeFloorDeployer();\n            DeployedOffice office = context.getDeployedOffice();\n            // Managed Object\n            OfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource(\"MOS\", officeFloorMos);\n            deployer.link(mos.getManagingOffice(), office);\n            mos.addOfficeFloorManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            OfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool(\"POOL\", officeFloorPool);\n            deployer.link(mos, pool);\n            // Team\n            deployer.addTeam(\"TEAM\", team);\n            // Executive\n            deployer.setExecutive(executive);\n            // Supplier\n            deployer.addSupplier(\"SUPPLIER\", completeSupplier);\n            // (Note compiling of added items happens after OfficeFloor sourcing)\n            assertNull(\"Supplier should yet be created\", compileScopedSources.get());\n        });\n        compiler.office((context) -> {\n            OfficeArchitect office = context.getOfficeArchitect();\n            // Ensure the supplier is now available\n            assertNotNull(\"Supplier should have setup context\", compileScopedSources.get());\n            // Managed Object\n            OfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n            mos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            OfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n            office.link(mos, pool);\n            // Supplier\n            office.addSupplier(\"SUPPLIER\", officeSupplier);\n            // Administration\n            OfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n            OfficeSection section = office.getOfficeSection(\"SECTION\");\n            section.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n            // Governance\n            office.addOfficeGovernance(\"GOVERNANCE\", govern);\n        });\n        compiler.section((context) -> {\n            SectionDesigner designer = context.getSectionDesigner();\n            // Managed Object\n            SectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n            mos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            SectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n            designer.link(mos, pool);\n            // Function\n            designer.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n        });\n        // Undertake compiling with clean state\n        compileScopedSources.remove();\n        try (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n            // Ensure complete supplier source context\n            assertCompletedSupplierCompileContext(completeSupplier.initialContext);\n            assertCompletedSupplierCompileContext(completeSupplier.completeContext);\n            // Ensure all functionality are added\n            assertTrue(\"Missing (OfficeFloor) supplier\", completeSupplier.completed.contains(completeSupplier));\n            assertTrue(\"Missing (OfficeFloor) managed object\", completeSupplier.completed.contains(officeFloorMos));\n            assertTrue(\"Missing (OfficeFloor) managed object pool\", completeSupplier.completed.contains(officeFloorPool));\n            assertTrue(\"Missing team\", completeSupplier.completed.contains(team));\n            assertTrue(\"Missing executive\", completeSupplier.completed.contains(executive));\n            assertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n            assertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n            assertTrue(\"Missing (office) supplier\", completeSupplier.completed.contains(officeSupplier));\n            assertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n            assertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n            assertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n            assertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n            assertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n            assertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 13, completeSupplier.completed.size());\n        } catch (Exception ex) {\n            throw fail(ex);\n        }\n    }\n\n    /**\n     * Ensure capture {@link Office} scope for {@link SupplierSource}.\n     */\n    public void testOfficeCompileScope() {\n        // Capture the sources\n        CompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n        // Provide sources to capture the profiles\n        MockManagedObjectSource officeMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n        MockAdministrationSource admin = new MockAdministrationSource();\n        MockGovernanceSource govern = new MockGovernanceSource();\n        MockManagedObjectSource sectionMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n        MockManagedFunctionSource function = new MockManagedFunctionSource();\n        // Compile\n        CompileOfficeFloor compiler = new CompileOfficeFloor();\n        compiler.office((context) -> {\n            OfficeArchitect office = context.getOfficeArchitect();\n            // Managed Object\n            OfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n            mos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            OfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n            office.link(mos, pool);\n            // Administration\n            OfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n            OfficeSection section = office.getOfficeSection(\"SECTION\");\n            section.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n            // Governance\n            office.addOfficeGovernance(\"GOVERNANCE\", govern);\n            // Supplier\n            office.addSupplier(\"SUPPLIER\", completeSupplier);\n            // (Note compiling of added items happens after Office sourcing)\n            assertNull(\"Supplier should yet be created\", compileScopedSources.get());\n        });\n        compiler.section((context) -> {\n            SectionDesigner designer = context.getSectionDesigner();\n            // Managed Object\n            SectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n            mos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            SectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n            designer.link(mos, pool);\n            // Function\n            designer.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n        });\n        // Undertake compiling with clean state\n        compileScopedSources.remove();\n        try (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n            // Ensure complete supplier source context\n            assertCompletedSupplierCompileContext(completeSupplier.initialContext);\n            assertCompletedSupplierCompileContext(completeSupplier.completeContext);\n            // Ensure all functionality are added\n            assertTrue(\"Missing supplier\", completeSupplier.completed.contains(completeSupplier));\n            assertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n            assertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n            assertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n            assertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n            assertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n            assertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n            assertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n            assertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 8, completeSupplier.completed.size());\n        } catch (Exception ex) {\n            throw fail(ex);\n        }\n    }\n\n    private static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {\n        assertIllegalStateException(() -> context.addManagedObjectSource(null, null, null), \"Unable to add further ManagedObject as SupplierSource loaded\");\n        assertIllegalStateException(() -> context.addSupplierThreadLocal(null, null), \"Unable to add further SupplierThreadLocal as SupplierSource loaded\");\n        assertIllegalStateException(() -> context.addThreadSynchroniser(null), \"Unable to add further ThreadSynchroniser as SupplierSource loaded\");\n        assertIllegalStateException(() -> context.addInternalSupplier(null), \"Unable to add further InternalSupplier as SupplierSource loaded\");\n        assertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null), \"Unable to add further SupplierCompileCompletion as SupplierSource completing\");\n    }\n\n    private static void assertIllegalStateException(Runnable logic, String message) {\n        try {\n            logic.run();\n            fail(\"Should not be successful. \" + message);\n        } catch (IllegalStateException ex) {\n            assertEquals(\"Incorrect cause\", message, ex.getMessage());\n        }\n    }\n\n    private static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();\n\n    @TestSource\n    private static class CompleteSupplierSource extends AbstractSupplierSource {\n\n        private final List<Object> completed = new ArrayList<>();\n\n        /**\n         * Initial {@link SupplierSourceContext}.\n         */\n        private SupplierSourceContext initialContext;\n\n        /**\n         * Completion {@link SupplierCompileContext}.\n         */\n        private SupplierCompileContext completeContext;\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public void supply(SupplierSourceContext context) throws Exception {\n            this.initialContext = context;\n            // Clear scoped objects\n            LinkedList<Object> sources = new LinkedList<>();\n            sources.add(this);\n            compileScopedSources.set(sources);\n            // Capture sources on completion\n            context.addCompileCompletion((completion) -> {\n                this.completeContext = completion;\n                this.completed.addAll(compileScopedSources.get());\n            });\n        }\n\n        @Override\n        public void terminate() {\n        }\n    }\n\n    @TestSource\n    private static class MockSupplierSource extends AbstractSupplierSource {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public void supply(SupplierSourceContext context) throws Exception {\n            compileScopedSources.get().add(this);\n        }\n\n        @Override\n        public void terminate() {\n        }\n    }\n\n    @TestSource\n    private static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext<None, None> context) throws Exception {\n            context.setObjectClass(Object.class);\n            compileScopedSources.get().add(this);\n        }\n\n        @Override\n        protected ManagedObject getManagedObject() throws Throwable {\n            fail(\"Should not be run\");\n            return null;\n        }\n    }\n\n    @TestSource\n    private static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource implements ManagedObjectPoolFactory {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext context) throws Exception {\n            context.setPooledObjectType(Object.class);\n            context.setManagedObjectPoolFactory(this);\n            compileScopedSources.get().add(this);\n        }\n\n        @Override\n        public ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext) throws Throwable {\n            return null;\n        }\n    }\n\n    @TestSource\n    private static class MockTeamSource extends AbstractTeamSource implements Team {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public Team createTeam(TeamSourceContext context) throws Exception {\n            compileScopedSources.get().add(this);\n            return this;\n        }\n\n        @Override\n        public void startWorking() {\n        }\n\n        @Override\n        public void assignJob(Job job) throws TeamOverloadException, Exception {\n            fail(\"Should not run\");\n        }\n\n        @Override\n        public void stopWorking() {\n        }\n    }\n\n    @TestSource\n    private static class MockExecutiveSource extends DefaultExecutive {\n\n        @Override\n        public Executive createExecutive(ExecutiveSourceContext context) throws Exception {\n            compileScopedSources.get().add(this);\n            return super.createExecutive(context);\n        }\n    }\n\n    @TestSource\n    private static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {\n            context.setExtensionInterface(Object.class);\n            context.setAdministrationFactory(() -> (adminContext) -> {\n            });\n            compileScopedSources.get().add(this);\n        }\n    }\n\n    @TestSource\n    private static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {\n            context.setExtensionInterface(Object.class);\n            context.setGovernanceFactory(() -> null);\n            compileScopedSources.get().add(this);\n        }\n    }\n\n    @TestSource\n    private static class MockManagedFunctionSource extends AbstractManagedFunctionSource {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder, ManagedFunctionSourceContext context) throws Exception {\n            functionNamespaceTypeBuilder.addManagedFunctionType(\"function\", None.class, None.class).setFunctionFactory(() -> (mfContext) -> {\n            });\n            compileScopedSources.get().add(this);\n        }\n    }\n}\n", "class_id": 0, "repo": "officefloor/OfficeFloor", "file": "officefloor/core/officecompiler/src/test/java/net/officefloor/compile/impl/supplier/SupplierCompileCompletionTest.java", "last_update_at": "2021-12-20T04:51:03+00:00", "original_content": "public class SupplierCompileCompletionTest extends OfficeFrameTestCase {\n\n    /**\n     * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.\n     */\n    public void testOfficeFloorCompileScope() {\n        // Capture the sources\n        CompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n        // Provide sources to capture the profiles\n        MockManagedObjectSource officeFloorMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();\n        MockTeamSource team = new MockTeamSource();\n        MockExecutiveSource executive = new MockExecutiveSource();\n        MockManagedObjectSource officeMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n        MockSupplierSource officeSupplier = new MockSupplierSource();\n        MockAdministrationSource admin = new MockAdministrationSource();\n        MockGovernanceSource govern = new MockGovernanceSource();\n        MockManagedObjectSource sectionMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n        MockManagedFunctionSource function = new MockManagedFunctionSource();\n        // Compile\n        CompileOfficeFloor compiler = new CompileOfficeFloor();\n        compiler.officeFloor((context) -> {\n            OfficeFloorDeployer deployer = context.getOfficeFloorDeployer();\n            DeployedOffice office = context.getDeployedOffice();\n            // Managed Object\n            OfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource(\"MOS\", officeFloorMos);\n            deployer.link(mos.getManagingOffice(), office);\n            mos.addOfficeFloorManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            OfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool(\"POOL\", officeFloorPool);\n            deployer.link(mos, pool);\n            // Team\n            deployer.addTeam(\"TEAM\", team);\n            // Executive\n            deployer.setExecutive(executive);\n            // Supplier\n            deployer.addSupplier(\"SUPPLIER\", completeSupplier);\n            // (Note compiling of added items happens after OfficeFloor sourcing)\n            assertNull(\"Supplier should yet be created\", compileScopedSources.get());\n        });\n        compiler.office((context) -> {\n            OfficeArchitect office = context.getOfficeArchitect();\n            // Ensure the supplier is now available\n            assertNotNull(\"Supplier should have setup context\", compileScopedSources.get());\n            // Managed Object\n            OfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n            mos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            OfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n            office.link(mos, pool);\n            // Supplier\n            office.addSupplier(\"SUPPLIER\", officeSupplier);\n            // Administration\n            OfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n            OfficeSection section = office.getOfficeSection(\"SECTION\");\n            section.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n            // Governance\n            office.addOfficeGovernance(\"GOVERNANCE\", govern);\n        });\n        compiler.section((context) -> {\n            SectionDesigner designer = context.getSectionDesigner();\n            // Managed Object\n            SectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n            mos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            SectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n            designer.link(mos, pool);\n            // Function\n            designer.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n        });\n        // Undertake compiling with clean state\n        compileScopedSources.remove();\n        try (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n            // Ensure complete supplier source context\n            assertCompletedSupplierCompileContext(completeSupplier.initialContext);\n            assertCompletedSupplierCompileContext(completeSupplier.completeContext);\n            // Ensure all functionality are added\n            assertTrue(\"Missing (OfficeFloor) supplier\", completeSupplier.completed.contains(completeSupplier));\n            assertTrue(\"Missing (OfficeFloor) managed object\", completeSupplier.completed.contains(officeFloorMos));\n            assertTrue(\"Missing (OfficeFloor) managed object pool\", completeSupplier.completed.contains(officeFloorPool));\n            assertTrue(\"Missing team\", completeSupplier.completed.contains(team));\n            assertTrue(\"Missing executive\", completeSupplier.completed.contains(executive));\n            assertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n            assertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n            assertTrue(\"Missing (office) supplier\", completeSupplier.completed.contains(officeSupplier));\n            assertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n            assertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n            assertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n            assertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n            assertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n            assertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 13, completeSupplier.completed.size());\n        } catch (Exception ex) {\n            throw fail(ex);\n        }\n    }\n\n    /**\n     * Ensure capture {@link Office} scope for {@link SupplierSource}.\n     */\n    public void testOfficeCompileScope() {\n        // Capture the sources\n        CompleteSupplierSource completeSupplier = new CompleteSupplierSource();\n        // Provide sources to capture the profiles\n        MockManagedObjectSource officeMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();\n        MockAdministrationSource admin = new MockAdministrationSource();\n        MockGovernanceSource govern = new MockGovernanceSource();\n        MockManagedObjectSource sectionMos = new MockManagedObjectSource();\n        MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();\n        MockManagedFunctionSource function = new MockManagedFunctionSource();\n        // Compile\n        CompileOfficeFloor compiler = new CompileOfficeFloor();\n        compiler.office((context) -> {\n            OfficeArchitect office = context.getOfficeArchitect();\n            // Managed Object\n            OfficeManagedObjectSource mos = office.addOfficeManagedObjectSource(\"MOS\", officeMos);\n            mos.addOfficeManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            OfficeManagedObjectPool pool = office.addManagedObjectPool(\"POOL\", officePool);\n            office.link(mos, pool);\n            // Administration\n            OfficeAdministration administration = office.addOfficeAdministration(\"ADMIN\", admin);\n            OfficeSection section = office.getOfficeSection(\"SECTION\");\n            section.getOfficeSectionFunction(\"function\").addPreAdministration(administration);\n            // Governance\n            office.addOfficeGovernance(\"GOVERNANCE\", govern);\n            // Supplier\n            office.addSupplier(\"SUPPLIER\", completeSupplier);\n            // (Note compiling of added items happens after Office sourcing)\n            assertNull(\"Supplier should yet be created\", compileScopedSources.get());\n        });\n        compiler.section((context) -> {\n            SectionDesigner designer = context.getSectionDesigner();\n            // Managed Object\n            SectionManagedObjectSource mos = designer.addSectionManagedObjectSource(\"MOS\", sectionMos);\n            mos.addSectionManagedObject(\"MO\", ManagedObjectScope.THREAD);\n            // Managed Object Pool\n            SectionManagedObjectPool pool = designer.addManagedObjectPool(\"POOL\", sectionPool);\n            designer.link(mos, pool);\n            // Function\n            designer.addSectionFunctionNamespace(\"FUNCTION\", function).addSectionFunction(\"function\", \"function\");\n        });\n        // Undertake compiling with clean state\n        compileScopedSources.remove();\n        try (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {\n            // Ensure complete supplier source context\n            assertCompletedSupplierCompileContext(completeSupplier.initialContext);\n            assertCompletedSupplierCompileContext(completeSupplier.completeContext);\n            // Ensure all functionality are added\n            assertTrue(\"Missing supplier\", completeSupplier.completed.contains(completeSupplier));\n            assertTrue(\"Missing (office) managed object\", completeSupplier.completed.contains(officeMos));\n            assertTrue(\"Missing (office) managed object pool\", completeSupplier.completed.contains(officePool));\n            assertTrue(\"Missing administration\", completeSupplier.completed.contains(admin));\n            assertTrue(\"Missing governance\", completeSupplier.completed.contains(govern));\n            assertTrue(\"Missing (section) managed object\", completeSupplier.completed.contains(sectionMos));\n            assertTrue(\"Missing (section) managed object pool\", completeSupplier.completed.contains(sectionPool));\n            assertTrue(\"Missing function\", completeSupplier.completed.contains(function));\n            assertEquals(\"Incorrect number of sources in scope: \" + completeSupplier.completed, 8, completeSupplier.completed.size());\n        } catch (Exception ex) {\n            throw fail(ex);\n        }\n    }\n\n    private static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {\n        assertIllegalStateException(() -> context.addManagedObjectSource(null, null, null), \"Unable to add further ManagedObject as SupplierSource loaded\");\n        assertIllegalStateException(() -> context.addSupplierThreadLocal(null, null), \"Unable to add further SupplierThreadLocal as SupplierSource loaded\");\n        assertIllegalStateException(() -> context.addThreadSynchroniser(null), \"Unable to add further ThreadSynchroniser as SupplierSource loaded\");\n        assertIllegalStateException(() -> context.addInternalSupplier(null), \"Unable to add further InternalSupplier as SupplierSource loaded\");\n        assertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null), \"Unable to add further SupplierCompileCompletion as SupplierSource completing\");\n    }\n\n    private static void assertIllegalStateException(Runnable logic, String message) {\n        try {\n            logic.run();\n            fail(\"Should not be successful. \" + message);\n        } catch (IllegalStateException ex) {\n            assertEquals(\"Incorrect cause\", message, ex.getMessage());\n        }\n    }\n\n    private static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();\n\n    @TestSource\n    private static class CompleteSupplierSource extends AbstractSupplierSource {\n\n        private final List<Object> completed = new ArrayList<>();\n\n        /**\n         * Initial {@link SupplierSourceContext}.\n         */\n        private SupplierSourceContext initialContext;\n\n        /**\n         * Completion {@link SupplierCompileContext}.\n         */\n        private SupplierCompileContext completeContext;\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public void supply(SupplierSourceContext context) throws Exception {\n            this.initialContext = context;\n            // Clear scoped objects\n            LinkedList<Object> sources = new LinkedList<>();\n            sources.add(this);\n            compileScopedSources.set(sources);\n            // Capture sources on completion\n            context.addCompileCompletion((completion) -> {\n                this.completeContext = completion;\n                this.completed.addAll(compileScopedSources.get());\n            });\n        }\n\n        @Override\n        public void terminate() {\n        }\n    }\n\n    @TestSource\n    private static class MockSupplierSource extends AbstractSupplierSource {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public void supply(SupplierSourceContext context) throws Exception {\n            compileScopedSources.get().add(this);\n        }\n\n        @Override\n        public void terminate() {\n        }\n    }\n\n    @TestSource\n    private static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext<None, None> context) throws Exception {\n            context.setObjectClass(Object.class);\n            compileScopedSources.get().add(this);\n        }\n\n        @Override\n        protected ManagedObject getManagedObject() throws Throwable {\n            fail(\"Should not be run\");\n            return null;\n        }\n    }\n\n    @TestSource\n    private static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource implements ManagedObjectPoolFactory {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext context) throws Exception {\n            context.setPooledObjectType(Object.class);\n            context.setManagedObjectPoolFactory(this);\n            compileScopedSources.get().add(this);\n        }\n\n        @Override\n        public ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext) throws Throwable {\n            return null;\n        }\n    }\n\n    @TestSource\n    private static class MockTeamSource extends AbstractTeamSource implements Team {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public Team createTeam(TeamSourceContext context) throws Exception {\n            compileScopedSources.get().add(this);\n            return this;\n        }\n\n        @Override\n        public void startWorking() {\n        }\n\n        @Override\n        public void assignJob(Job job) throws TeamOverloadException, Exception {\n            fail(\"Should not run\");\n        }\n\n        @Override\n        public void stopWorking() {\n        }\n    }\n\n    @TestSource\n    private static class MockExecutiveSource extends DefaultExecutive {\n\n        @Override\n        public Executive createExecutive(ExecutiveSourceContext context) throws Exception {\n            compileScopedSources.get().add(this);\n            return super.createExecutive(context);\n        }\n    }\n\n    @TestSource\n    private static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {\n            context.setExtensionInterface(Object.class);\n            context.setAdministrationFactory(() -> (adminContext) -> {\n            });\n            compileScopedSources.get().add(this);\n        }\n    }\n\n    @TestSource\n    private static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        protected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {\n            context.setExtensionInterface(Object.class);\n            context.setGovernanceFactory(() -> null);\n            compileScopedSources.get().add(this);\n        }\n    }\n\n    @TestSource\n    private static class MockManagedFunctionSource extends AbstractManagedFunctionSource {\n\n        @Override\n        protected void loadSpecification(SpecificationContext context) {\n        }\n\n        @Override\n        public void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder, ManagedFunctionSourceContext context) throws Exception {\n            functionNamespaceTypeBuilder.addManagedFunctionType(\"function\", None.class, None.class).setFunctionFactory(() -> (mfContext) -> {\n            });\n            compileScopedSources.get().add(this);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "d620dafeb60e8e45312cbc5cd34054b25cd5a7e5", "ext": "java", "lang": "Java", "content": "public class Conta {\n\n    private static int chave_conta;\n\n    private String nome;\n\n    private String descricao;\n\n    private String senha;\n\n    private Pessoa pessoa;\n\n    private java.util.Date data;\n\n    public Conta() {\n        Conta.chave_conta++;\n    }\n\n    public Conta(String nome) {\n        this.nome = nome;\n        Conta.chave_conta++;\n    }\n\n    public static int CHAVE_CONTA() {\n        return Conta.chave_conta;\n    }\n\n    public String getNome() {\n        return this.nome;\n    }\n\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n\n    public String getDescricao() {\n        return this.descricao;\n    }\n\n    public void setDescricao(String descricao) {\n        this.descricao = descricao;\n    }\n\n    public String getSenha() {\n        return this.senha;\n    }\n\n    public void setSenha(String senha) {\n        this.senha = senha;\n    }\n\n    public Pessoa getPessoa() {\n        return this.pessoa;\n    }\n\n    public void setPessoa(Pessoa pessoa) {\n        this.pessoa = pessoa;\n    }\n\n    public java.util.Date getData() {\n        return this.data;\n    }\n\n    public void setData(java.util.Date data) {\n        GregorianCalendar gc = new GregorianCalendar(2021, 2, 31);\n        if (data.equals(gc.getTime())) {\n            this.data = null;\n        }\n        this.data = data;\n    }\n}\n", "class_id": 0, "repo": "RyanCasf/Java", "file": "src/main/java/br/com/estatico/aplication/Conta.java", "last_update_at": "2021-08-02T22:32:24+00:00", "original_content": "public class Conta {\n\n    private static int chave_conta;\n\n    private String nome;\n\n    private String descricao;\n\n    private String senha;\n\n    private Pessoa pessoa;\n\n    private java.util.Date data;\n\n    public Conta() {\n        Conta.chave_conta++;\n    }\n\n    public Conta(String nome) {\n        this.nome = nome;\n        Conta.chave_conta++;\n    }\n\n    public static int CHAVE_CONTA() {\n        return Conta.chave_conta;\n    }\n\n    public String getNome() {\n        return this.nome;\n    }\n\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n\n    public String getDescricao() {\n        return this.descricao;\n    }\n\n    public void setDescricao(String descricao) {\n        this.descricao = descricao;\n    }\n\n    public String getSenha() {\n        return this.senha;\n    }\n\n    public void setSenha(String senha) {\n        this.senha = senha;\n    }\n\n    public Pessoa getPessoa() {\n        return this.pessoa;\n    }\n\n    public void setPessoa(Pessoa pessoa) {\n        this.pessoa = pessoa;\n    }\n\n    public java.util.Date getData() {\n        return this.data;\n    }\n\n    public void setData(java.util.Date data) {\n        GregorianCalendar gc = new GregorianCalendar(2021, 2, 31);\n        if (data.equals(gc.getTime())) {\n            this.data = null;\n        }\n        this.data = data;\n    }\n}\n", "refactored": false}
{"hexsha": "3f156fc483ff7ed9a55cefd3b01cbbcdd2d04d3a", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/passwordSecurityPolicy\")\n@Extension\n@Tag(name = \"passwordSecurityPolicy\")\n@ProtectedREST\n@OperationsInside\npublic class PasswordSecurityPolicyController implements Plugin {\n\n    @Autowired\n    private PasswordSecurityPolicyService passwordSecurityPolicyService;\n\n    @PostMapping(\"/create\")\n    @Operation(description = \"creates Security Policy\", summary = \"creates Security Policy\")\n    public PasswordSecurityPolicy create(@RequestHeader(value = \"authenticationKey\", required = false) String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext) {\n        passwordSecurityPolicyService.validate(securityPolicyCreate, securityContext);\n        return passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate, securityContext);\n    }\n\n    @PostMapping(\"/getAll\")\n    @Operation(description = \"returns Security Policies\", summary = \"returns Security Policies\")\n    public PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = \"authenticationKey\", required = false) String key, @RequestBody PasswordSecurityPolicyFilter securityPolicyFilter, @RequestAttribute SecurityContextBase securityContext) {\n        passwordSecurityPolicyService.validate(securityPolicyFilter, securityContext);\n        return passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter, securityContext);\n    }\n\n    @PutMapping(\"/update\")\n    @Operation(description = \"updates Security Policies\", summary = \"updates Security Policies\")\n    public PasswordSecurityPolicy update(@RequestHeader(value = \"authenticationKey\", required = false) String key, @RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext) {\n        String id = securityPolicyUpdate.getId();\n        PasswordSecurityPolicy passwordSecurityPolicy = id != null ? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id, PasswordSecurityPolicy.class, securityContext) : null;\n        if (passwordSecurityPolicy == null) {\n            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"no PasswordSecurityPolicy user with id \" + id);\n        }\n        securityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);\n        passwordSecurityPolicyService.validate(securityPolicyUpdate, securityContext);\n        return passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate, securityContext);\n    }\n}\n", "class_id": 0, "repo": "wizzdi/flexicore-base-service", "file": "src/main/java/com/flexicore/rest/PasswordSecurityPolicyController.java", "last_update_at": "2021-06-11T04:13:36+00:00", "original_content": "@RestController\n@RequestMapping(\"/passwordSecurityPolicy\")\n@Extension\n@Tag(name = \"passwordSecurityPolicy\")\n@ProtectedREST\n@OperationsInside\npublic class PasswordSecurityPolicyController implements Plugin {\n\n    @Autowired\n    private PasswordSecurityPolicyService passwordSecurityPolicyService;\n\n    @PostMapping(\"/create\")\n    @Operation(description = \"creates Security Policy\", summary = \"creates Security Policy\")\n    public PasswordSecurityPolicy create(@RequestHeader(value = \"authenticationKey\", required = false) String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext) {\n        passwordSecurityPolicyService.validate(securityPolicyCreate, securityContext);\n        return passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate, securityContext);\n    }\n\n    @PostMapping(\"/getAll\")\n    @Operation(description = \"returns Security Policies\", summary = \"returns Security Policies\")\n    public PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = \"authenticationKey\", required = false) String key, @RequestBody PasswordSecurityPolicyFilter securityPolicyFilter, @RequestAttribute SecurityContextBase securityContext) {\n        passwordSecurityPolicyService.validate(securityPolicyFilter, securityContext);\n        return passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter, securityContext);\n    }\n\n    @PutMapping(\"/update\")\n    @Operation(description = \"updates Security Policies\", summary = \"updates Security Policies\")\n    public PasswordSecurityPolicy update(@RequestHeader(value = \"authenticationKey\", required = false) String key, @RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext) {\n        String id = securityPolicyUpdate.getId();\n        PasswordSecurityPolicy passwordSecurityPolicy = id != null ? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id, PasswordSecurityPolicy.class, securityContext) : null;\n        if (passwordSecurityPolicy == null) {\n            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"no PasswordSecurityPolicy user with id \" + id);\n        }\n        securityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);\n        passwordSecurityPolicyService.validate(securityPolicyUpdate, securityContext);\n        return passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate, securityContext);\n    }\n}\n", "refactored": false}
{"hexsha": "18b49af96dd5814b6f008015faacfeda2a05682a", "ext": "java", "lang": "Java", "content": "@Component\n@Description(\"Ends execution of entity event.\")\npublic class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {\n\n    public static final String PROCESSOR_NAME = \"entity-event-end-processor\";\n\n    //\n    @Autowired\n    private IdmEntityEventService service;\n\n    public EntityEventEndProcessor() {\n        super(EntityEventType.EXECUTE);\n    }\n\n    @Override\n    public String getName() {\n        return PROCESSOR_NAME;\n    }\n\n    @Override\n    public EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {\n        IdmEntityEventDto entityEvent = event.getContent();\n        entityEvent.setEventEnded(ZonedDateTime.now());\n        entityEvent = service.save(entityEvent);\n        event.setContent(entityEvent);\n        //\n        return new DefaultEventResult<>(event, this);\n    }\n\n    /**\n     * Asynchronous processing can be disabled\n     */\n    @Override\n    public boolean conditional(EntityEvent<IdmEntityEventDto> event) {\n        return event.getContent().getId() != null;\n    }\n\n    @Override\n    public int getOrder() {\n        // after process\n        return 1000;\n    }\n}\n", "class_id": 0, "repo": "piougy/CzechIdMng", "file": "Realization/backend/core/core-impl/src/main/java/eu/bcvsolutions/idm/core/model/event/processor/event/EntityEventEndProcessor.java", "last_update_at": "2021-08-06T19:55:05+00:00", "original_content": "@Component\n@Description(\"Ends execution of entity event.\")\npublic class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {\n\n    public static final String PROCESSOR_NAME = \"entity-event-end-processor\";\n\n    //\n    @Autowired\n    private IdmEntityEventService service;\n\n    public EntityEventEndProcessor() {\n        super(EntityEventType.EXECUTE);\n    }\n\n    @Override\n    public String getName() {\n        return PROCESSOR_NAME;\n    }\n\n    @Override\n    public EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {\n        IdmEntityEventDto entityEvent = event.getContent();\n        entityEvent.setEventEnded(ZonedDateTime.now());\n        entityEvent = service.save(entityEvent);\n        event.setContent(entityEvent);\n        //\n        return new DefaultEventResult<>(event, this);\n    }\n\n    /**\n     * Asynchronous processing can be disabled\n     */\n    @Override\n    public boolean conditional(EntityEvent<IdmEntityEventDto> event) {\n        return event.getContent().getId() != null;\n    }\n\n    @Override\n    public int getOrder() {\n        // after process\n        return 1000;\n    }\n}\n", "refactored": false}
{"hexsha": "2b5d7a6df824e402ae1c26cbf10970eb75941eb6", "ext": "java", "lang": "Java", "content": "public class PlaceLocation {\n\n    public String name;\n\n    public String address;\n\n    public boolean isNotInUsa() {\n        return address != null && !address.endsWith(\"USA\") && !address.endsWith(\"United States\");\n    }\n\n    public String country() {\n        if (address == null) {\n            return null;\n        }\n        String countryMatch = address.substring(address.lastIndexOf(\"\\n\") + 1);\n        String trimmedCountry;\n        if (!countryMatch.contains(\",\")) {\n            trimmedCountry = countryMatch.trim();\n        } else {\n            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(\",\") + 1).trim();\n        }\n        switch(trimmedCountry) {\n            case \"United States\":\n                return \"USA\";\n            case \"Italia\":\n                return \"Italy\";\n            case \"Tanz?nie\":\n                return \"Tanzania\";\n            case \"?ire\":\n                return \"Ireland\";\n            case \"United Kingdom\":\n                return \"UK\";\n            default:\n                return trimmedCountry;\n        }\n    }\n}\n", "class_id": 0, "repo": "vmware/workflowTools", "file": "core/src/test/java/PlaceLocation.java", "last_update_at": "2021-12-06T22:26:15+00:00", "original_content": "public class PlaceLocation {\n\n    public String name;\n\n    public String address;\n\n    public boolean isNotInUsa() {\n        return address != null && !address.endsWith(\"USA\") && !address.endsWith(\"United States\");\n    }\n\n    public String country() {\n        if (address == null) {\n            return null;\n        }\n        String countryMatch = address.substring(address.lastIndexOf(\"\\n\") + 1);\n        String trimmedCountry;\n        if (!countryMatch.contains(\",\")) {\n            trimmedCountry = countryMatch.trim();\n        } else {\n            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(\",\") + 1).trim();\n        }\n        switch(trimmedCountry) {\n            case \"United States\":\n                return \"USA\";\n            case \"Italia\":\n                return \"Italy\";\n            case \"Tanz?nie\":\n                return \"Tanzania\";\n            case \"?ire\":\n                return \"Ireland\";\n            case \"United Kingdom\":\n                return \"UK\";\n            default:\n                return trimmedCountry;\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "d337b228a1e219df9c9fd234cc3062ebe9e0e205", "ext": "java", "lang": "Java", "content": "public class InMemoryBulkDataSorterTest {\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n\n    /* A counter of tuple files */\n    private int counter = 0;\n\n    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>() {\n\n        @Override\n        public int compare(Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2) {\n            return o1.getKey().compareTo(o2.getKey());\n        }\n    };\n\n    @Test\n    public void testSortedFileCount() throws IOException {\n        int count = 7;\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile(\"tuple.data\");\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(dataFile));\n        Tuple<Integer, Integer>[] arr = (Tuple<Integer, Integer>[]) Array.newInstance(Tuple.class, count);\n        int i = 0;\n        while (i < count) try {\n            int x = random.nextInt(100);\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>(x, x);\n            arr[i] = t;\n            itrw.storeSortedTuple(t, out);\n        } finally {\n            i++;\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(itrw, tupleComp, 4);\n        bds.sort(dataFile);\n        assertEquals(2, bds.getWorkDir().list().length);\n        deleteDir(bds.getWorkDir());\n    }\n\n    @Test\n    public void testSortedFileMerge() throws IOException {\n        testSortedFileMerge(10, 2);\n        testSortedFileMerge(100, 7);\n        testSortedFileMerge(1000, 25);\n        testSortedFileMerge(10000, 100);\n        testSortedFileMerge(10000, 101);\n        testSortedFileMerge(100000, 501);\n    }\n\n    private void testSortedFileMerge(int count, int splitAfter) throws IOException {\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile(\"tuple.data\" + counter);\n        counter++;\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(dataFile));\n        Tuple<Integer, Integer>[] arr = (Tuple<Integer, Integer>[]) Array.newInstance(Tuple.class, count);\n        int randUpper = count;\n        if (count < 100) {\n            randUpper = 100;\n        }\n        int i = 0;\n        while (i < count) try {\n            int x = random.nextInt(randUpper);\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>(x, x);\n            arr[i] = t;\n            itrw.storeSortedTuple(t, out);\n        } finally {\n            i++;\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(itrw, tupleComp, splitAfter);\n        bds.sort(dataFile);\n        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();\n        Integer prev = null;\n        while (itr.hasNext()) {\n            Tuple<Integer, Integer> t = itr.next();\n            if (prev == null) {\n                prev = t.getKey();\n            } else {\n                assertTrue(prev <= t.getKey());\n            }\n        }\n        deleteDir(bds.getWorkDir());\n    }\n\n    private void deleteDir(File dir) {\n        if (dir.isFile()) {\n            dir.delete();\n        }\n        File[] files = dir.listFiles();\n        for (File f : files) {\n            f.delete();\n        }\n        dir.delete();\n    }\n}\n", "class_id": 0, "repo": "kupl/starlab-benchmarks", "file": "Benchmarks_with_Safety_Bugs/Java/directory-mavibot/src/mavibot/src/test/java/org/apache/directory/mavibot/btree/InMemoryBulkDataSorterTest.java", "last_update_at": "2021-11-08T13:39:38+00:00", "original_content": "public class InMemoryBulkDataSorterTest {\n\n    @Rule\n    public TemporaryFolder tempFolder = new TemporaryFolder();\n\n    /* A counter of tuple files */\n    private int counter = 0;\n\n    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>() {\n\n        @Override\n        public int compare(Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2) {\n            return o1.getKey().compareTo(o2.getKey());\n        }\n    };\n\n    @Test\n    public void testSortedFileCount() throws IOException {\n        int count = 7;\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile(\"tuple.data\");\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(dataFile));\n        Tuple<Integer, Integer>[] arr = (Tuple<Integer, Integer>[]) Array.newInstance(Tuple.class, count);\n        for (int i = 0; i < count; i++) {\n            int x = random.nextInt(100);\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>(x, x);\n            arr[i] = t;\n            itrw.storeSortedTuple(t, out);\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(itrw, tupleComp, 4);\n        bds.sort(dataFile);\n        assertEquals(2, bds.getWorkDir().list().length);\n        deleteDir(bds.getWorkDir());\n    }\n\n    @Test\n    public void testSortedFileMerge() throws IOException {\n        testSortedFileMerge(10, 2);\n        testSortedFileMerge(100, 7);\n        testSortedFileMerge(1000, 25);\n        testSortedFileMerge(10000, 100);\n        testSortedFileMerge(10000, 101);\n        testSortedFileMerge(100000, 501);\n    }\n\n    private void testSortedFileMerge(int count, int splitAfter) throws IOException {\n        IntTupleReaderWriter itrw = new IntTupleReaderWriter();\n        Random random = new Random();\n        File dataFile = tempFolder.newFile(\"tuple.data\" + counter);\n        counter++;\n        dataFile.deleteOnExit();\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(dataFile));\n        Tuple<Integer, Integer>[] arr = (Tuple<Integer, Integer>[]) Array.newInstance(Tuple.class, count);\n        int randUpper = count;\n        if (count < 100) {\n            randUpper = 100;\n        }\n        for (int i = 0; i < count; i++) {\n            int x = random.nextInt(randUpper);\n            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>(x, x);\n            arr[i] = t;\n            itrw.storeSortedTuple(t, out);\n        }\n        out.close();\n        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(itrw, tupleComp, splitAfter);\n        bds.sort(dataFile);\n        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();\n        Integer prev = null;\n        while (itr.hasNext()) {\n            Tuple<Integer, Integer> t = itr.next();\n            if (prev == null) {\n                prev = t.getKey();\n            } else {\n                assertTrue(prev <= t.getKey());\n            }\n        }\n        deleteDir(bds.getWorkDir());\n    }\n\n    private void deleteDir(File dir) {\n        if (dir.isFile()) {\n            dir.delete();\n        }\n        File[] files = dir.listFiles();\n        for (File f : files) {\n            f.delete();\n        }\n        dir.delete();\n    }\n}\n", "refactored": true}
{"hexsha": "7bdc9937970a43098edff3a966f21a3d4997caf4", "ext": "java", "lang": "Java", "content": "public class HomePage extends TestBase {\n\n    @Override\n    public void excute() throws Exception {\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(\"http://atealxt.appspot.com/guestbook\");\n        Assert.assertEquals(\"Guestbook - Hero's Grave\", page.getTitleText());\n        // ?????????????????????????????\n        String pageAsXml = page.asXml();\n        Assert.assertTrue(pageAsXml.contains(\"<script src=\\\"/javascripts/guestbook.js\\\" type=\\\"text/javascript\\\">\"));\n        logger.info(pageAsXml);\n        String pageAsText = page.asText();\n        Assert.assertTrue(pageAsText.contains(\"Welcome to my personal website, hope you to find out your own territory!\"));\n        logger.info(pageAsText);\n        webClient.closeAllWindows();\n    }\n}\n", "class_id": 0, "repo": "atealxt/work-workspaces", "file": "HtmlUnitDemo/test/htmlunitdemo/test/getstarted/HomePage.java", "last_update_at": "2021-12-18T18:17:34+00:00", "original_content": "public class HomePage extends TestBase {\n\n    @Override\n    public void excute() throws Exception {\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(\"http://atealxt.appspot.com/guestbook\");\n        Assert.assertEquals(\"Guestbook - Hero's Grave\", page.getTitleText());\n        // ?????????????????????????????\n        String pageAsXml = page.asXml();\n        Assert.assertTrue(pageAsXml.contains(\"<script src=\\\"/javascripts/guestbook.js\\\" type=\\\"text/javascript\\\">\"));\n        logger.info(pageAsXml);\n        String pageAsText = page.asText();\n        Assert.assertTrue(pageAsText.contains(\"Welcome to my personal website, hope you to find out your own territory!\"));\n        logger.info(pageAsText);\n        webClient.closeAllWindows();\n    }\n}\n", "refactored": false}
{"hexsha": "919def75c26c20661ebc949f53445ab95efa46ca", "ext": "java", "lang": "Java", "content": "@Service\npublic class LinkManager implements LinkService {\n\n    private LinkDao linkDao;\n\n    @Autowired\n    public LinkManager(LinkDao linkDao) {\n        super();\n        this.linkDao = linkDao;\n    }\n\n    @Override\n    public Result add(Link link) {\n        var result = this.linkDao.save(link);\n        if (result != null) {\n            return new SuccessResult(\"link add ok\");\n        }\n        return new ErrorResult(\"link add NOT ok\");\n    }\n\n    @Override\n    public DataResult<List<Link>> getAll() {\n        var result = this.linkDao.findAll();\n        if (result != null) {\n            return new SuccessDataResult<List<Link>>(result, \"links get ok\");\n        }\n        return new ErrorDataResult<List<Link>>(\"links get NOT ok\");\n    }\n\n    @Override\n    public DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {\n        var result = this.linkDao.getByJobSeekerId(jobSeekerId);\n        if (result != null) {\n            return new SuccessDataResult<List<Link>>(result, \"links get by jobSeeker Id ok\");\n        }\n        return new ErrorDataResult<List<Link>>(\"links get by jobSeeker Id NOT ok\");\n    }\n}\n", "class_id": 0, "repo": "CerenSusuz/HRMS", "file": "hrms/src/main/java/com/hrms/business/concretes/LinkManager.java", "last_update_at": "2021-08-18T23:17:34+00:00", "original_content": "@Service\npublic class LinkManager implements LinkService {\n\n    private LinkDao linkDao;\n\n    @Autowired\n    public LinkManager(LinkDao linkDao) {\n        super();\n        this.linkDao = linkDao;\n    }\n\n    @Override\n    public Result add(Link link) {\n        var result = this.linkDao.save(link);\n        if (result != null) {\n            return new SuccessResult(\"link add ok\");\n        }\n        return new ErrorResult(\"link add NOT ok\");\n    }\n\n    @Override\n    public DataResult<List<Link>> getAll() {\n        var result = this.linkDao.findAll();\n        if (result != null) {\n            return new SuccessDataResult<List<Link>>(result, \"links get ok\");\n        }\n        return new ErrorDataResult<List<Link>>(\"links get NOT ok\");\n    }\n\n    @Override\n    public DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {\n        var result = this.linkDao.getByJobSeekerId(jobSeekerId);\n        if (result != null) {\n            return new SuccessDataResult<List<Link>>(result, \"links get by jobSeeker Id ok\");\n        }\n        return new ErrorDataResult<List<Link>>(\"links get by jobSeeker Id NOT ok\");\n    }\n}\n", "refactored": false}
{"hexsha": "fe322982427c837c12bccb9a2b78b51af11bbe10", "ext": "java", "lang": "Java", "content": "public class DefaultDockerImageMigrationHandlerTest {\n\n    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"bar\").saveNode();\n\n    @Test\n    public void invalidConstructorInput() {\n        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler(null));\n    }\n\n    @Test\n    public void noopMigrationScript() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE);\n    }\n\n    @Test\n    public void effectiveMigration() {\n        URL url = TestURLBuilder.forContent(script(\"input.foo = 'baz';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"foo\", \"baz\"));\n    }\n\n    @Test\n    public void globalStateMustBeCleared() {\n        URL url = TestURLBuilder.forContent(\"var globalVar = 0;\" + script(\"input.cpt = globalVar; globalVar++;\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n        result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n    }\n\n    @Test\n    public void mustHandleJSONEscapeCharacters() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"{\\\"\\':\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void mustHandleMultiByteCharSequences() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"?\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void invalidScriptMustThrowException() {\n        URL url = TestURLBuilder.forContent(script(\"throw 'invalid script';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));\n    }\n\n    private String noopScript() {\n        return script(\"\");\n    }\n\n    private String script(String content) {\n        return \"module.exports = function(input) { \" + content + \"};\";\n    }\n}\n", "class_id": 0, "repo": "JeanRev/TeamcityDockerCloudPlugin", "file": "server/src/test/java/run/var/teamcity/cloud/docker/DefaultDockerImageMigrationHandlerTest.java", "last_update_at": "2021-10-14T10:42:50+00:00", "original_content": "public class DefaultDockerImageMigrationHandlerTest {\n\n    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"bar\").saveNode();\n\n    @Test\n    public void invalidConstructorInput() {\n        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler(null));\n    }\n\n    @Test\n    public void noopMigrationScript() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE);\n    }\n\n    @Test\n    public void effectiveMigration() {\n        URL url = TestURLBuilder.forContent(script(\"input.foo = 'baz';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"foo\", \"baz\"));\n    }\n\n    @Test\n    public void globalStateMustBeCleared() {\n        URL url = TestURLBuilder.forContent(\"var globalVar = 0;\" + script(\"input.cpt = globalVar; globalVar++;\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n        result = migrationHandler.performMigration(TEST_NODE);\n        assertThat(result).isEqualTo(TEST_NODE.editNode().put(\"cpt\", 0));\n    }\n\n    @Test\n    public void mustHandleJSONEscapeCharacters() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"{\\\"\\':\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void mustHandleMultiByteCharSequences() {\n        URL url = TestURLBuilder.forContent(noopScript()).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        Node testNode = Node.EMPTY_OBJECT.editNode().put(\"foo\", \"?\").saveNode();\n        Node result = migrationHandler.performMigration(testNode);\n        assertThat(result).isEqualTo(testNode);\n    }\n\n    @Test\n    public void invalidScriptMustThrowException() {\n        URL url = TestURLBuilder.forContent(script(\"throw 'invalid script';\")).build();\n        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);\n        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));\n    }\n\n    private String noopScript() {\n        return script(\"\");\n    }\n\n    private String script(String content) {\n        return \"module.exports = function(input) { \" + content + \"};\";\n    }\n}\n", "refactored": false}
{"hexsha": "312f282becf9715a6ec29fbea270e619ab8bcb3b", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({ \"SpringJavaAutowiringInspection\" })\npublic abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {\n\n    protected AbstractApplicationContext appContext;\n\n    protected Class<? extends T> targetArgsClass;\n\n    protected Class<? extends U> targetReturnTypeClass;\n\n    protected boolean resolveArgs;\n\n    protected boolean handleReturnValue;\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);\n\n    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs, boolean handleReturnValue) {\n        this.targetArgsClass = targetArgsClass;\n        this.targetReturnTypeClass = targetReturnTypeClass;\n        this.resolveArgs = resolveArgs;\n        this.handleReturnValue = handleReturnValue;\n    }\n\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter methodParam) {\n        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);\n    }\n\n    @Override\n    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).\", ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(), ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));\n    }\n\n    @Nullable\n    @Override\n    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).\", ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(), ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));\n        return argObj;\n    }\n\n    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n    }\n\n    @Nullable\n    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext appContext) throws BeansException {\n        this.appContext = (AbstractApplicationContext) appContext;\n    }\n}\n", "class_id": 0, "repo": "elizabethso/direct-certificate-discovery-tool", "file": "dcdt-web/src/main/java/gov/hhs/onc/dcdt/web/handler/impl/AbstractToolHandlerMethodProcessor.java", "last_update_at": "2021-06-25T19:17:50+00:00", "original_content": "@SuppressWarnings({ \"SpringJavaAutowiringInspection\" })\npublic abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {\n\n    protected AbstractApplicationContext appContext;\n\n    protected Class<? extends T> targetArgsClass;\n\n    protected Class<? extends U> targetReturnTypeClass;\n\n    protected boolean resolveArgs;\n\n    protected boolean handleReturnValue;\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);\n\n    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs, boolean handleReturnValue) {\n        this.targetArgsClass = targetArgsClass;\n        this.targetReturnTypeClass = targetReturnTypeClass;\n        this.resolveArgs = resolveArgs;\n        this.handleReturnValue = handleReturnValue;\n    }\n\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter methodParam) {\n        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);\n    }\n\n    @Override\n    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).\", ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(), ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));\n    }\n\n    @Nullable\n    @Override\n    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);\n        LOGGER.trace(String.format(\"Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).\", ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(), ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));\n        return argObj;\n    }\n\n    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n    }\n\n    @Nullable\n    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext appContext) throws BeansException {\n        this.appContext = (AbstractApplicationContext) appContext;\n    }\n}\n", "refactored": false}
{"hexsha": "82ffa0c5c43034bbc57a5c1a00a6cd9ed811d54a", "ext": "java", "lang": "Java", "content": "public class AWSV4AuthParser implements AWSAuthParser {\n\n    private final static Logger LOG = LoggerFactory.getLogger(AWSV4AuthParser.class);\n\n    private MultivaluedMap<String, String> headerMap;\n\n    private MultivaluedMap<String, String> queryMap;\n\n    private String uri;\n\n    private String method;\n\n    private AuthorizationHeaderV4 v4Header;\n\n    private String stringToSign;\n\n    private String amzContentPayload;\n\n    public AWSV4AuthParser(ContainerRequestContext context) throws OS3Exception {\n        this.headerMap = context.getHeaders();\n        this.queryMap = context.getUriInfo().getQueryParameters();\n        try {\n            this.uri = new URI(context.getUriInfo().getRequestUri().getPath().replaceAll(\"\\\\/+\", \"/\")).normalize().getPath();\n        } catch (URISyntaxException e) {\n            throw S3_TOKEN_CREATION_ERROR;\n        }\n        this.method = context.getMethod();\n        v4Header = new AuthorizationHeaderV4(headerMap.getFirst(AUTHORIZATION_HEADER));\n    }\n\n    public void parse() throws Exception {\n        StringBuilder strToSign = new StringBuilder();\n        //    HashedCanonicalRequest\n        String algorithm, requestDateTime, credentialScope, canonicalRequest;\n        algorithm = v4Header.getAlgorithm();\n        requestDateTime = headerMap.getFirst(X_AMAZ_DATE);\n        Credential credential = v4Header.getCredentialObj();\n        credentialScope = String.format(\"%s/%s/%s/%s\", credential.getDate(), credential.getAwsRegion(), credential.getAwsService(), credential.getAwsRequest());\n        // If the absolute path is empty, use a forward slash (/)\n        uri = (uri.trim().length() > 0) ? uri : \"/\";\n        // Encode URI and preserve forward slashes\n        strToSign.append(algorithm + NEWLINE);\n        strToSign.append(requestDateTime + NEWLINE);\n        strToSign.append(credentialScope + NEWLINE);\n        canonicalRequest = buildCanonicalRequest();\n        strToSign.append(hash(canonicalRequest));\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n        }\n        if (LOG.isTraceEnabled()) {\n            headerMap.keySet().forEach(k -> LOG.trace(\"Header:{},value:{}\", k, headerMap.get(k)));\n        }\n        LOG.debug(\"StringToSign:[{}]\", strToSign);\n        stringToSign = strToSign.toString();\n    }\n\n    private String buildCanonicalRequest() throws OS3Exception {\n        Iterable<String> parts = split(\"/\", uri);\n        List<String> encParts = new ArrayList<>();\n        for (String p : parts) {\n            encParts.add(urlEncode(p));\n        }\n        String canonicalUri = join(\"/\", encParts);\n        String canonicalQueryStr = getQueryParamString();\n        StringBuilder canonicalHeaders = new StringBuilder();\n        for (String header : v4Header.getSignedHeaders()) {\n            List<String> headerValue = new ArrayList<>();\n            canonicalHeaders.append(header.toLowerCase());\n            canonicalHeaders.append(\":\");\n            for (String originalHeader : headerMap.keySet()) {\n                if (originalHeader.toLowerCase().equals(header)) {\n                    headerValue.add(headerMap.getFirst(originalHeader).trim());\n                }\n            }\n            if (headerValue.size() == 0) {\n                throw new RuntimeException(\"Header \" + header + \" not present in \" + \"request\");\n            }\n            if (headerValue.size() > 1) {\n                Collections.sort(headerValue);\n            }\n            // Set for testing purpose only to skip date and host validation.\n            validateSignedHeader(header, headerValue.get(0));\n            canonicalHeaders.append(join(\",\", headerValue));\n            canonicalHeaders.append(NEWLINE);\n        }\n        String payloadHash;\n        if (UNSIGNED_PAYLOAD.equals(headerMap.get(X_AMZ_CONTENT_SHA256))) {\n            payloadHash = UNSIGNED_PAYLOAD;\n        } else {\n            payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);\n        }\n        String signedHeaderStr = v4Header.getSignedHeaderString();\n        String canonicalRequest = method + NEWLINE + canonicalUri + NEWLINE + canonicalQueryStr + NEWLINE + canonicalHeaders + NEWLINE + signedHeaderStr + NEWLINE + payloadHash;\n        return canonicalRequest;\n    }\n\n    @VisibleForTesting\n    void validateSignedHeader(String header, String headerValue) throws OS3Exception {\n        switch(header) {\n            case HOST:\n                try {\n                    URI hostUri = new URI(headerValue);\n                    InetAddress.getByName(hostUri.getHost());\n                } catch (UnknownHostException | URISyntaxException e) {\n                    LOG.error(\"Host value mentioned in signed header is not valid. \" + \"Host:{}\", headerValue);\n                    throw S3_TOKEN_CREATION_ERROR;\n                }\n                break;\n            case X_AMAZ_DATE:\n                LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);\n                LocalDate now = LocalDate.now();\n                if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS)) || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))) {\n                    LOG.error(\"AWS date not in valid range. Request timestamp:{} should \" + \"not be older than {} seconds.\", headerValue, PRESIGN_URL_MAX_EXPIRATION_SECONDS);\n                    throw S3_TOKEN_CREATION_ERROR;\n                }\n                break;\n            case X_AMZ_CONTENT_SHA256:\n                // TODO: Construct request payload and match HEX(SHA256(requestPayload))\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * String join that also works with empty strings.\n     *\n     * @return joined string\n     */\n    private static String join(String glue, List<String> parts) {\n        StringBuilder result = new StringBuilder();\n        boolean addSeparator = false;\n        for (String p : parts) {\n            if (addSeparator) {\n                result.append(glue);\n            }\n            result.append(p);\n            addSeparator = true;\n        }\n        return result.toString();\n    }\n\n    /**\n     * Returns matching strings.\n     *\n     * @param regex Regular expression to split by\n     * @param whole The string to split\n     * @return pieces\n     */\n    private static Iterable<String> split(String regex, String whole) {\n        Pattern p = Pattern.compile(regex);\n        Matcher m = p.matcher(whole);\n        List<String> result = new ArrayList<>();\n        int pos = 0;\n        for (; m.find(); ) {\n            result.add(whole.substring(pos, m.start()));\n            pos = m.end();\n        }\n        result.add(whole.substring(pos));\n        return result;\n    }\n\n    private String urlEncode(String str) {\n        try {\n            return URLEncoder.encode(str, UTF_8.name()).replaceAll(\"\\\\+\", \"%20\").replaceAll(\"%7E\", \"~\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String getQueryParamString() {\n        List<String> params = new ArrayList<>(queryMap.keySet());\n        // Sort by name, then by value\n        Collections.sort(params, (o1, o2) -> o1.equals(o2) ? queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) : o1.compareTo(o2));\n        StringBuilder result = new StringBuilder();\n        for (String p : params) {\n            if (result.length() > 0) {\n                result.append(\"&\");\n            }\n            result.append(urlEncode(p));\n            result.append('=');\n            result.append(urlEncode(queryMap.getFirst(p)));\n        }\n        return result.toString();\n    }\n\n    public static String hash(String payload) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(payload.getBytes(UTF_8));\n        return Hex.encode(md.digest()).toLowerCase();\n    }\n\n    public String getAwsAccessId() {\n        return v4Header.getAccessKeyID();\n    }\n\n    public String getSignature() {\n        return v4Header.getSignature();\n    }\n\n    public String getStringToSign() throws Exception {\n        return stringToSign;\n    }\n}\n", "class_id": 0, "repo": "mohammadjkhan/hadoop-ozone", "file": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/AWSV4AuthParser.java", "last_update_at": "2021-09-02T16:12:45+00:00", "original_content": "public class AWSV4AuthParser implements AWSAuthParser {\n\n    private final static Logger LOG = LoggerFactory.getLogger(AWSV4AuthParser.class);\n\n    private MultivaluedMap<String, String> headerMap;\n\n    private MultivaluedMap<String, String> queryMap;\n\n    private String uri;\n\n    private String method;\n\n    private AuthorizationHeaderV4 v4Header;\n\n    private String stringToSign;\n\n    private String amzContentPayload;\n\n    public AWSV4AuthParser(ContainerRequestContext context) throws OS3Exception {\n        this.headerMap = context.getHeaders();\n        this.queryMap = context.getUriInfo().getQueryParameters();\n        try {\n            this.uri = new URI(context.getUriInfo().getRequestUri().getPath().replaceAll(\"\\\\/+\", \"/\")).normalize().getPath();\n        } catch (URISyntaxException e) {\n            throw S3_TOKEN_CREATION_ERROR;\n        }\n        this.method = context.getMethod();\n        v4Header = new AuthorizationHeaderV4(headerMap.getFirst(AUTHORIZATION_HEADER));\n    }\n\n    public void parse() throws Exception {\n        StringBuilder strToSign = new StringBuilder();\n        //    HashedCanonicalRequest\n        String algorithm, requestDateTime, credentialScope, canonicalRequest;\n        algorithm = v4Header.getAlgorithm();\n        requestDateTime = headerMap.getFirst(X_AMAZ_DATE);\n        Credential credential = v4Header.getCredentialObj();\n        credentialScope = String.format(\"%s/%s/%s/%s\", credential.getDate(), credential.getAwsRegion(), credential.getAwsService(), credential.getAwsRequest());\n        // If the absolute path is empty, use a forward slash (/)\n        uri = (uri.trim().length() > 0) ? uri : \"/\";\n        // Encode URI and preserve forward slashes\n        strToSign.append(algorithm + NEWLINE);\n        strToSign.append(requestDateTime + NEWLINE);\n        strToSign.append(credentialScope + NEWLINE);\n        canonicalRequest = buildCanonicalRequest();\n        strToSign.append(hash(canonicalRequest));\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n        }\n        if (LOG.isTraceEnabled()) {\n            headerMap.keySet().forEach(k -> LOG.trace(\"Header:{},value:{}\", k, headerMap.get(k)));\n        }\n        LOG.debug(\"StringToSign:[{}]\", strToSign);\n        stringToSign = strToSign.toString();\n    }\n\n    private String buildCanonicalRequest() throws OS3Exception {\n        Iterable<String> parts = split(\"/\", uri);\n        List<String> encParts = new ArrayList<>();\n        for (String p : parts) {\n            encParts.add(urlEncode(p));\n        }\n        String canonicalUri = join(\"/\", encParts);\n        String canonicalQueryStr = getQueryParamString();\n        StringBuilder canonicalHeaders = new StringBuilder();\n        for (String header : v4Header.getSignedHeaders()) {\n            List<String> headerValue = new ArrayList<>();\n            canonicalHeaders.append(header.toLowerCase());\n            canonicalHeaders.append(\":\");\n            for (String originalHeader : headerMap.keySet()) {\n                if (originalHeader.toLowerCase().equals(header)) {\n                    headerValue.add(headerMap.getFirst(originalHeader).trim());\n                }\n            }\n            if (headerValue.size() == 0) {\n                throw new RuntimeException(\"Header \" + header + \" not present in \" + \"request\");\n            }\n            if (headerValue.size() > 1) {\n                Collections.sort(headerValue);\n            }\n            // Set for testing purpose only to skip date and host validation.\n            validateSignedHeader(header, headerValue.get(0));\n            canonicalHeaders.append(join(\",\", headerValue));\n            canonicalHeaders.append(NEWLINE);\n        }\n        String payloadHash;\n        if (UNSIGNED_PAYLOAD.equals(headerMap.get(X_AMZ_CONTENT_SHA256))) {\n            payloadHash = UNSIGNED_PAYLOAD;\n        } else {\n            payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);\n        }\n        String signedHeaderStr = v4Header.getSignedHeaderString();\n        String canonicalRequest = method + NEWLINE + canonicalUri + NEWLINE + canonicalQueryStr + NEWLINE + canonicalHeaders + NEWLINE + signedHeaderStr + NEWLINE + payloadHash;\n        return canonicalRequest;\n    }\n\n    @VisibleForTesting\n    void validateSignedHeader(String header, String headerValue) throws OS3Exception {\n        switch(header) {\n            case HOST:\n                try {\n                    URI hostUri = new URI(headerValue);\n                    InetAddress.getByName(hostUri.getHost());\n                } catch (UnknownHostException | URISyntaxException e) {\n                    LOG.error(\"Host value mentioned in signed header is not valid. \" + \"Host:{}\", headerValue);\n                    throw S3_TOKEN_CREATION_ERROR;\n                }\n                break;\n            case X_AMAZ_DATE:\n                LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);\n                LocalDate now = LocalDate.now();\n                if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS)) || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))) {\n                    LOG.error(\"AWS date not in valid range. Request timestamp:{} should \" + \"not be older than {} seconds.\", headerValue, PRESIGN_URL_MAX_EXPIRATION_SECONDS);\n                    throw S3_TOKEN_CREATION_ERROR;\n                }\n                break;\n            case X_AMZ_CONTENT_SHA256:\n                // TODO: Construct request payload and match HEX(SHA256(requestPayload))\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * String join that also works with empty strings.\n     *\n     * @return joined string\n     */\n    private static String join(String glue, List<String> parts) {\n        StringBuilder result = new StringBuilder();\n        boolean addSeparator = false;\n        for (String p : parts) {\n            if (addSeparator) {\n                result.append(glue);\n            }\n            result.append(p);\n            addSeparator = true;\n        }\n        return result.toString();\n    }\n\n    /**\n     * Returns matching strings.\n     *\n     * @param regex Regular expression to split by\n     * @param whole The string to split\n     * @return pieces\n     */\n    private static Iterable<String> split(String regex, String whole) {\n        Pattern p = Pattern.compile(regex);\n        Matcher m = p.matcher(whole);\n        List<String> result = new ArrayList<>();\n        int pos = 0;\n        while (m.find()) {\n            result.add(whole.substring(pos, m.start()));\n            pos = m.end();\n        }\n        result.add(whole.substring(pos));\n        return result;\n    }\n\n    private String urlEncode(String str) {\n        try {\n            return URLEncoder.encode(str, UTF_8.name()).replaceAll(\"\\\\+\", \"%20\").replaceAll(\"%7E\", \"~\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String getQueryParamString() {\n        List<String> params = new ArrayList<>(queryMap.keySet());\n        // Sort by name, then by value\n        Collections.sort(params, (o1, o2) -> o1.equals(o2) ? queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) : o1.compareTo(o2));\n        StringBuilder result = new StringBuilder();\n        for (String p : params) {\n            if (result.length() > 0) {\n                result.append(\"&\");\n            }\n            result.append(urlEncode(p));\n            result.append('=');\n            result.append(urlEncode(queryMap.getFirst(p)));\n        }\n        return result.toString();\n    }\n\n    public static String hash(String payload) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(payload.getBytes(UTF_8));\n        return Hex.encode(md.digest()).toLowerCase();\n    }\n\n    public String getAwsAccessId() {\n        return v4Header.getAccessKeyID();\n    }\n\n    public String getSignature() {\n        return v4Header.getSignature();\n    }\n\n    public String getStringToSign() throws Exception {\n        return stringToSign;\n    }\n}\n", "refactored": true}
{"hexsha": "f162c0c0620935df0e24658be449595dcc99b9e7", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n// ?????\n@SpringBootTest(classes = { ShiroAdminApplication.class })\npublic class MonsterlanApplicationTests {\n\n    @Autowired\n    DataSourceProperties dataSourceProperties;\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    @Test\n    public void contextLoads() {\n        // ????????\n        DataSource dataSource = applicationContext.getBean(DataSource.class);\n        //System.out.println(data/Source.getClass().getName());\n        System.out.println(dataSourceProperties.getUrl());\n    }\n}\n", "class_id": 0, "repo": "supertonsystem/project_management", "file": "shiro-admin/src/test/java/com/suteng/shiro/MonsterlanApplicationTests.java", "last_update_at": "2021-09-24T14:40:48+00:00", "original_content": "@RunWith(SpringRunner.class)\n// ?????\n@SpringBootTest(classes = { ShiroAdminApplication.class })\npublic class MonsterlanApplicationTests {\n\n    @Autowired\n    DataSourceProperties dataSourceProperties;\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    @Test\n    public void contextLoads() {\n        // ????????\n        DataSource dataSource = applicationContext.getBean(DataSource.class);\n        //System.out.println(data/Source.getClass().getName());\n        System.out.println(dataSourceProperties.getUrl());\n    }\n}\n", "refactored": false}
{"hexsha": "5d1826baaf2a8d3a3ee04fea5ba7cdaf784abf75", "ext": "java", "lang": "Java", "content": "public class PaymentPlansApi {\n\n    private ApiClient apiClient;\n\n    public PaymentPlansApi() {\n        this(Environment.getGlobalEnv().getApiClient());\n    }\n\n    public PaymentPlansApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    /**\n     * Build call for paymentPlansGet\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"count\", count));\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"offset\", offset));\n        if (fields != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"fields\", fields));\n        if (q != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"q\", q));\n        if (sort != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"sort\", sort));\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {};\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        return paymentPlansGetCall(count, offset, fields, q, sort);\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return PaymentPlansList\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return ApiResponse&lt;PaymentPlansList&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans (asynchronously)\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansGetById\n     * @param paymentPlanId Payment plan id (required)\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\".replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {};\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)\");\n        }\n        return paymentPlansGetByIdCall(paymentPlanId);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId} (asynchronously)\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPatch\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\".replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = { \"application/json\" };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)\");\n        }\n        return paymentPlansPatchCall(paymentPlanId, body);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPost\n     * @param body Payment plan properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = { \"application/json\" };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {\n        return paymentPlansPostCall(body);\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);\n        return resp.getData();\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * POST Payment/Plans (asynchronously)\n     * Add new plan\n     * @param body Payment plan properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPut\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\".replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = { \"application/json\" };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)\");\n        }\n        return paymentPlansPutCall(paymentPlanId, body);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}\n", "class_id": 0, "repo": "secuconnect/secuconnect-java-sdk", "file": "src/main/java/com/secuconnect/client/api/PaymentPlansApi.java", "last_update_at": "2021-12-13T21:45:02+00:00", "original_content": "public class PaymentPlansApi {\n\n    private ApiClient apiClient;\n\n    public PaymentPlansApi() {\n        this(Environment.getGlobalEnv().getApiClient());\n    }\n\n    public PaymentPlansApi(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    public ApiClient getApiClient() {\n        return apiClient;\n    }\n\n    public void setApiClient(ApiClient apiClient) {\n        this.apiClient = apiClient;\n    }\n\n    /**\n     * Build call for paymentPlansGet\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        if (count != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"count\", count));\n        if (offset != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"offset\", offset));\n        if (fields != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"fields\", fields));\n        if (q != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"q\", q));\n        if (sort != null)\n            localVarQueryParams.addAll(apiClient.parameterToPair(\"sort\", sort));\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {};\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        return paymentPlansGetCall(count, offset, fields, q, sort);\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return PaymentPlansList\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @return ApiResponse&lt;PaymentPlansList&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans (asynchronously)\n     * Get a list of payment plans\n     * @param count The maximum number of items to return\n     * @param offset The position within the whole result set to start returning items (zero-based)\n     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.\n     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;\n     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {\n        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);\n        Type localVarReturnType = new TypeToken<PaymentPlansList>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansGetById\n     * @param paymentPlanId Payment plan id (required)\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {\n        Object localVarPostBody = null;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\".replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = {};\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)\");\n        }\n        return paymentPlansGetByIdCall(paymentPlanId);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);\n        return resp.getData();\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId}\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * GET Payment/Plans/{paymentPlanId} (asynchronously)\n     * Get payment plan by id\n     * @param paymentPlanId Payment plan id (required)\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPatch\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\".replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = { \"application/json\" };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)\");\n        }\n        return paymentPlansPatchCall(paymentPlanId, body);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId}\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan (partial)\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPost\n     * @param body Payment plan properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans\";\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = { \"application/json\" };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {\n        return paymentPlansPostCall(body);\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);\n        return resp.getData();\n    }\n\n    /**\n     * POST Payment/Plans\n     * Add new plan\n     * @param body Payment plan properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * POST Payment/Plans (asynchronously)\n     * Add new plan\n     * @param body Payment plan properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPostValidateBeforeCall(body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n\n    /**\n     * Build call for paymentPlansPut\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return Call to execute\n     * @throws ApiException If fail to serialize the request body object\n     */\n    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Object localVarPostBody = body;\n        // create path and map variables\n        String localVarPath = \"/Payment/Plans/{paymentPlanId}\".replaceAll(\"\\\\{\" + \"paymentPlanId\" + \"\\\\}\", apiClient.escapeString(paymentPlanId.toString()));\n        List<Pair> localVarQueryParams = new ArrayList<Pair>();\n        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n        Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n        Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n        final String[] localVarAccepts = { \"application/json\" };\n        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n        if (localVarAccept != null)\n            localVarHeaderParams.put(\"Accept\", localVarAccept);\n        final String[] localVarContentTypes = { \"application/json\" };\n        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n        localVarHeaderParams.put(\"Content-Type\", localVarContentType);\n        String[] localVarAuthNames = new String[] { \"oauth_token\" };\n        return apiClient.buildCall(localVarPath, \"PUT\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        // verify the required parameter 'paymentPlanId' is set\n        if (paymentPlanId == null) {\n            throw new ApiException(\"Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)\");\n        }\n        return paymentPlansPutCall(paymentPlanId, body);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return PaymentPlansProductModel\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);\n        return resp.getData();\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId}\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @return ApiResponse&lt;PaymentPlansProductModel&gt;\n     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body\n     */\n    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n\n    /**\n     * PUT Payment/Plans/{paymentPlanId} (asynchronously)\n     * Updates an existing plan\n     * @param paymentPlanId Payment plan id (required)\n     * @param body Payment plans properties\n     * @param callback The callback to be executed when the API call finishes\n     * @return The request call\n     * @throws ApiException If fail to process the API call, e.g. serializing the request body object\n     */\n    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {\n        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);\n        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {\n        }.getType();\n        apiClient.executeAsync(call, localVarReturnType, callback);\n        return call;\n    }\n}\n", "refactored": false}
{"hexsha": "343375c62eaba4f174329b4d7593ae534bc80666", "ext": "java", "lang": "Java", "content": "public class IOHelper {\n\n    public static void copy(Reader in, Writer out) throws IOException {\n        int c = -1;\n        for (; (c = in.read()) != -1; ) {\n            out.write(c);\n        }\n    }\n\n    public static String readFile(File file) throws IOException {\n        Reader in = new FileReader(file);\n        StringWriter out = new StringWriter();\n        copy(in, out);\n        return out.toString();\n    }\n\n    public static void saveFile(File file, String content) throws IOException {\n        Writer writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n}\n", "class_id": 0, "repo": "uupu/CodeWrench", "file": "src/main/java/com/uupu/wrench/util/IOHelper.java", "last_update_at": "2021-11-25T09:58:54+00:00", "original_content": "public class IOHelper {\n\n    public static void copy(Reader in, Writer out) throws IOException {\n        int c = -1;\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    }\n\n    public static String readFile(File file) throws IOException {\n        Reader in = new FileReader(file);\n        StringWriter out = new StringWriter();\n        copy(in, out);\n        return out.toString();\n    }\n\n    public static void saveFile(File file, String content) throws IOException {\n        Writer writer = new FileWriter(file);\n        writer.write(content);\n        writer.close();\n    }\n}\n", "refactored": true}
{"hexsha": "5494e9ba86572e92df36c029d9a6c0fb67dd4722", "ext": "java", "lang": "Java", "content": "@XmlRootElement\npublic class IssueUpdates {\n\n    @XmlElement(name = \"issueUpdate\")\n    public final List<IssueUpdate> issueUpdates = new ArrayList<>();\n\n    @Override\n    public boolean equals(Object otherObject) {\n        return this == otherObject || (otherObject instanceof IssueUpdates && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(issueUpdates);\n    }\n\n    public static class IssueUpdate {\n\n        @Nullable\n        public String issueKey;\n\n        @Nullable\n        public Issue issue;\n\n        @Override\n        public boolean equals(@Nullable Object otherObject) {\n            if (this == otherObject) {\n                return true;\n            } else if (otherObject == null || getClass() != otherObject.getClass()) {\n                return false;\n            }\n            IssueUpdate other = (IssueUpdate) otherObject;\n            return Objects.equals(issueKey, other.issueKey) && Objects.equals(issue, other.issue);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(issueKey, issue);\n        }\n    }\n}\n", "class_id": 0, "repo": "fschopp/asana-to-youtrack", "file": "issue-tracking-youtrack/src/main/java/net/florianschoppmann/issuetracking/youtrack/IssueUpdates.java", "last_update_at": "2021-12-07T18:28:16+00:00", "original_content": "@XmlRootElement\npublic class IssueUpdates {\n\n    @XmlElement(name = \"issueUpdate\")\n    public final List<IssueUpdate> issueUpdates = new ArrayList<>();\n\n    @Override\n    public boolean equals(Object otherObject) {\n        return this == otherObject || (otherObject instanceof IssueUpdates && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(issueUpdates);\n    }\n\n    public static class IssueUpdate {\n\n        @Nullable\n        public String issueKey;\n\n        @Nullable\n        public Issue issue;\n\n        @Override\n        public boolean equals(@Nullable Object otherObject) {\n            if (this == otherObject) {\n                return true;\n            } else if (otherObject == null || getClass() != otherObject.getClass()) {\n                return false;\n            }\n            IssueUpdate other = (IssueUpdate) otherObject;\n            return Objects.equals(issueKey, other.issueKey) && Objects.equals(issue, other.issue);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(issueKey, issue);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "4731e4fd483b82796b665b993ea78c300897dbb5", "ext": "java", "lang": "Java", "content": "public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {\n\n    /**\n     * the logging facility provided by log4j\n     */\n    private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,\n     *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n     */\n    @Override\n    public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n        return type.equals(MediaPackageElement.Type.Track);\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)\n     */\n    @Override\n    public boolean accept(Node elementNode) {\n        String name = elementNode.getNodeName();\n        if (name.contains(\":\")) {\n            name = name.substring(name.indexOf(\":\") + 1);\n        }\n        return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,\n     *      org.opencastproject.mediapackage.MediaPackageElement.Type,\n     *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n     */\n    @Override\n    public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n        return MediaPackageElement.Type.Track.equals(type);\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)\n     */\n    @Override\n    public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {\n        logger.trace(\"Creating track from \" + uri);\n        Track track = TrackImpl.fromURI(uri);\n        return track;\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type\n     *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)\n     */\n    @Override\n    public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n        Track track = new TrackImpl();\n        track.setFlavor(flavor);\n        return track;\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,\n     *      org.opencastproject.mediapackage.MediaPackageSerializer)\n     */\n    @Override\n    public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer) throws UnsupportedElementException {\n        String id = null;\n        MimeType mimeType = null;\n        MediaPackageElementFlavor flavor = null;\n        TrackImpl.StreamingProtocol transport = null;\n        String reference = null;\n        URI url = null;\n        long size = -1;\n        Checksum checksum = null;\n        try {\n            // id\n            id = (String) xpath.evaluate(\"@id\", elementNode, XPathConstants.STRING);\n            // url\n            url = serializer.decodeURI(new URI(xpath.evaluate(\"url/text()\", elementNode).trim()));\n            // reference\n            reference = (String) xpath.evaluate(\"@ref\", elementNode, XPathConstants.STRING);\n            // size\n            String trackSize = xpath.evaluate(\"size/text()\", elementNode).trim();\n            if (!\"\".equals(trackSize))\n                size = Long.parseLong(trackSize);\n            // flavor\n            String flavorValue = (String) xpath.evaluate(\"@type\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(flavorValue))\n                flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);\n            // transport\n            String transportValue = (String) xpath.evaluate(\"@transport\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(transportValue))\n                transport = TrackImpl.StreamingProtocol.valueOf(transportValue);\n            // checksum\n            String checksumValue = (String) xpath.evaluate(\"checksum/text()\", elementNode, XPathConstants.STRING);\n            String checksumType = (String) xpath.evaluate(\"checksum/@type\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)\n                checksum = Checksum.create(checksumType.trim(), checksumValue.trim());\n            // mimetype\n            String mimeTypeValue = (String) xpath.evaluate(\"mimetype/text()\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(mimeTypeValue))\n                mimeType = MimeTypes.parseMimeType(mimeTypeValue);\n            TrackImpl track = TrackImpl.fromURI(url);\n            if (StringUtils.isNotBlank(id))\n                track.setIdentifier(id);\n            // Add url\n            track.setURI(url);\n            // Add reference\n            if (StringUtils.isNotEmpty(reference))\n                track.referTo(MediaPackageReferenceImpl.fromString(reference));\n            // Set size\n            if (size > 0)\n                track.setSize(size);\n            // Set checksum\n            if (checksum != null)\n                track.setChecksum(checksum);\n            // Set mimetpye\n            if (mimeType != null)\n                track.setMimeType(mimeType);\n            if (flavor != null)\n                track.setFlavor(flavor);\n            //set transport\n            if (transport != null)\n                track.setTransport(transport);\n            // description\n            String description = (String) xpath.evaluate(\"description/text()\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotBlank(description))\n                track.setElementDescription(description.trim());\n            // tags\n            NodeList tagNodes = (NodeList) xpath.evaluate(\"tags/tag\", elementNode, XPathConstants.NODESET);\n            int i = 0;\n            while (i < tagNodes.getLength()) try {\n                track.addTag(tagNodes.item(i).getTextContent());\n            } finally {\n                i++;\n            }\n            // duration\n            try {\n                String strDuration = (String) xpath.evaluate(\"duration/text()\", elementNode, XPathConstants.STRING);\n                if (StringUtils.isNotEmpty(strDuration)) {\n                    long duration = Long.parseLong(strDuration.trim());\n                    track.setDuration(duration);\n                }\n            } catch (NumberFormatException e) {\n                throw new UnsupportedElementException(\"Duration of track \" + url + \" is malformatted\");\n            }\n            // is live\n            String strLive = (String) xpath.evaluate(\"live/text()\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(strLive)) {\n                boolean live = Boolean.parseBoolean(strLive.trim());\n                track.setLive(live);\n            }\n            // audio settings\n            Node audioSettingsNode = (Node) xpath.evaluate(\"audio\", elementNode, XPathConstants.NODE);\n            if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {\n                try {\n                    AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);\n                    track.addStream(as);\n                } catch (IllegalStateException e) {\n                    throw new UnsupportedElementException(\"Illegal state encountered while reading audio settings from \" + url + \": \" + e.getMessage());\n                } catch (XPathException e) {\n                    throw new UnsupportedElementException(\"Error while parsing audio settings from \" + url + \": \" + e.getMessage());\n                }\n            }\n            // video settings\n            Node videoSettingsNode = (Node) xpath.evaluate(\"video\", elementNode, XPathConstants.NODE);\n            if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {\n                try {\n                    VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);\n                    track.addStream(vs);\n                } catch (IllegalStateException e) {\n                    throw new UnsupportedElementException(\"Illegal state encountered while reading video settings from \" + url + \": \" + e.getMessage());\n                } catch (XPathException e) {\n                    throw new UnsupportedElementException(\"Error while parsing video settings from \" + url + \": \" + e.getMessage());\n                }\n            }\n            return track;\n        } catch (XPathExpressionException e) {\n            throw new UnsupportedElementException(\"Error while reading track information from manifest: \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            throw new UnsupportedElementException(\"Unsupported digest algorithm: \" + e.getMessage());\n        } catch (URISyntaxException e) {\n            throw new UnsupportedElementException(\"Error while reading presenter track \" + url + \": \" + e.getMessage());\n        }\n    }\n\n    private String createStreamID(Track track) {\n        return \"stream-\" + (track.getStreams().length + 1);\n    }\n\n    @Override\n    public String toString() {\n        return \"Track Builder Plugin\";\n    }\n}\n", "class_id": 0, "repo": "Rillke/opencast", "file": "modules/common/src/main/java/org/opencastproject/mediapackage/elementbuilder/TrackBuilderPlugin.java", "last_update_at": "2021-07-10T13:16:24+00:00", "original_content": "public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {\n\n    /**\n     * the logging facility provided by log4j\n     */\n    private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,\n     *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n     */\n    @Override\n    public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n        return type.equals(MediaPackageElement.Type.Track);\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)\n     */\n    @Override\n    public boolean accept(Node elementNode) {\n        String name = elementNode.getNodeName();\n        if (name.contains(\":\")) {\n            name = name.substring(name.indexOf(\":\") + 1);\n        }\n        return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,\n     *      org.opencastproject.mediapackage.MediaPackageElement.Type,\n     *      org.opencastproject.mediapackage.MediaPackageElementFlavor)\n     */\n    @Override\n    public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n        return MediaPackageElement.Type.Track.equals(type);\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)\n     */\n    @Override\n    public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {\n        logger.trace(\"Creating track from \" + uri);\n        Track track = TrackImpl.fromURI(uri);\n        return track;\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type\n     *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)\n     */\n    @Override\n    public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n        Track track = new TrackImpl();\n        track.setFlavor(flavor);\n        return track;\n    }\n\n    /**\n     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,\n     *      org.opencastproject.mediapackage.MediaPackageSerializer)\n     */\n    @Override\n    public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer) throws UnsupportedElementException {\n        String id = null;\n        MimeType mimeType = null;\n        MediaPackageElementFlavor flavor = null;\n        TrackImpl.StreamingProtocol transport = null;\n        String reference = null;\n        URI url = null;\n        long size = -1;\n        Checksum checksum = null;\n        try {\n            // id\n            id = (String) xpath.evaluate(\"@id\", elementNode, XPathConstants.STRING);\n            // url\n            url = serializer.decodeURI(new URI(xpath.evaluate(\"url/text()\", elementNode).trim()));\n            // reference\n            reference = (String) xpath.evaluate(\"@ref\", elementNode, XPathConstants.STRING);\n            // size\n            String trackSize = xpath.evaluate(\"size/text()\", elementNode).trim();\n            if (!\"\".equals(trackSize))\n                size = Long.parseLong(trackSize);\n            // flavor\n            String flavorValue = (String) xpath.evaluate(\"@type\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(flavorValue))\n                flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);\n            // transport\n            String transportValue = (String) xpath.evaluate(\"@transport\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(transportValue))\n                transport = TrackImpl.StreamingProtocol.valueOf(transportValue);\n            // checksum\n            String checksumValue = (String) xpath.evaluate(\"checksum/text()\", elementNode, XPathConstants.STRING);\n            String checksumType = (String) xpath.evaluate(\"checksum/@type\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)\n                checksum = Checksum.create(checksumType.trim(), checksumValue.trim());\n            // mimetype\n            String mimeTypeValue = (String) xpath.evaluate(\"mimetype/text()\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(mimeTypeValue))\n                mimeType = MimeTypes.parseMimeType(mimeTypeValue);\n            TrackImpl track = TrackImpl.fromURI(url);\n            if (StringUtils.isNotBlank(id))\n                track.setIdentifier(id);\n            // Add url\n            track.setURI(url);\n            // Add reference\n            if (StringUtils.isNotEmpty(reference))\n                track.referTo(MediaPackageReferenceImpl.fromString(reference));\n            // Set size\n            if (size > 0)\n                track.setSize(size);\n            // Set checksum\n            if (checksum != null)\n                track.setChecksum(checksum);\n            // Set mimetpye\n            if (mimeType != null)\n                track.setMimeType(mimeType);\n            if (flavor != null)\n                track.setFlavor(flavor);\n            //set transport\n            if (transport != null)\n                track.setTransport(transport);\n            // description\n            String description = (String) xpath.evaluate(\"description/text()\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotBlank(description))\n                track.setElementDescription(description.trim());\n            // tags\n            NodeList tagNodes = (NodeList) xpath.evaluate(\"tags/tag\", elementNode, XPathConstants.NODESET);\n            for (int i = 0; i < tagNodes.getLength(); i++) {\n                track.addTag(tagNodes.item(i).getTextContent());\n            }\n            // duration\n            try {\n                String strDuration = (String) xpath.evaluate(\"duration/text()\", elementNode, XPathConstants.STRING);\n                if (StringUtils.isNotEmpty(strDuration)) {\n                    long duration = Long.parseLong(strDuration.trim());\n                    track.setDuration(duration);\n                }\n            } catch (NumberFormatException e) {\n                throw new UnsupportedElementException(\"Duration of track \" + url + \" is malformatted\");\n            }\n            // is live\n            String strLive = (String) xpath.evaluate(\"live/text()\", elementNode, XPathConstants.STRING);\n            if (StringUtils.isNotEmpty(strLive)) {\n                boolean live = Boolean.parseBoolean(strLive.trim());\n                track.setLive(live);\n            }\n            // audio settings\n            Node audioSettingsNode = (Node) xpath.evaluate(\"audio\", elementNode, XPathConstants.NODE);\n            if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {\n                try {\n                    AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);\n                    track.addStream(as);\n                } catch (IllegalStateException e) {\n                    throw new UnsupportedElementException(\"Illegal state encountered while reading audio settings from \" + url + \": \" + e.getMessage());\n                } catch (XPathException e) {\n                    throw new UnsupportedElementException(\"Error while parsing audio settings from \" + url + \": \" + e.getMessage());\n                }\n            }\n            // video settings\n            Node videoSettingsNode = (Node) xpath.evaluate(\"video\", elementNode, XPathConstants.NODE);\n            if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {\n                try {\n                    VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);\n                    track.addStream(vs);\n                } catch (IllegalStateException e) {\n                    throw new UnsupportedElementException(\"Illegal state encountered while reading video settings from \" + url + \": \" + e.getMessage());\n                } catch (XPathException e) {\n                    throw new UnsupportedElementException(\"Error while parsing video settings from \" + url + \": \" + e.getMessage());\n                }\n            }\n            return track;\n        } catch (XPathExpressionException e) {\n            throw new UnsupportedElementException(\"Error while reading track information from manifest: \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            throw new UnsupportedElementException(\"Unsupported digest algorithm: \" + e.getMessage());\n        } catch (URISyntaxException e) {\n            throw new UnsupportedElementException(\"Error while reading presenter track \" + url + \": \" + e.getMessage());\n        }\n    }\n\n    private String createStreamID(Track track) {\n        return \"stream-\" + (track.getStreams().length + 1);\n    }\n\n    @Override\n    public String toString() {\n        return \"Track Builder Plugin\";\n    }\n}\n", "refactored": true}
{"hexsha": "cd257f0dce4bba1a21fbdb15fd284702dd48600f", "ext": "java", "lang": "Java", "content": "public class SimpleBlockingQueueTest {\n\n    @Test\n    public void whenUseBlockingQueue() {\n    }\n}\n", "class_id": 0, "repo": "NURGALIMOV/inurgalimov", "file": "level_junior_002/src/test/java/ru/inurgalimov/wait/SimpleBlockingQueueTest.java", "last_update_at": "2021-12-14T21:18:26+00:00", "original_content": "public class SimpleBlockingQueueTest {\n\n    @Test\n    public void whenUseBlockingQueue() {\n    }\n}\n", "refactored": false}
{"hexsha": "2fdee659338464d3cee41b3776ec8893a1c5cafb", "ext": "java", "lang": "Java", "content": "public class HttpClientUtils {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);\n\n    public static CloseableHttpClient getHttpClient(HasProxySettings proxySetting) {\n        CloseableHttpClient httpclient = null;\n        if (proxySetting != null && proxySetting.isActive()) {\n            logger.info(\"Set the http proxy (\" + proxySetting.getHost() + \":\" + proxySetting.getPort() + \")\");\n            CredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider());\n            HttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());\n            DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);\n            httpclient = HttpClients.custom().setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider).build();\n        } else {\n            httpclient = HttpClients.createDefault();\n        }\n        return httpclient;\n    }\n}\n", "class_id": 0, "repo": "hjg0706/google_Drive", "file": "src/main/java/io/uploader/drive/drive/largefile/HttpClientUtils.java", "last_update_at": "2021-11-27T05:58:07+00:00", "original_content": "public class HttpClientUtils {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);\n\n    public static CloseableHttpClient getHttpClient(HasProxySettings proxySetting) {\n        CloseableHttpClient httpclient = null;\n        if (proxySetting != null && proxySetting.isActive()) {\n            logger.info(\"Set the http proxy (\" + proxySetting.getHost() + \":\" + proxySetting.getPort() + \")\");\n            CredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider());\n            HttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());\n            DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);\n            httpclient = HttpClients.custom().setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider).build();\n        } else {\n            httpclient = HttpClients.createDefault();\n        }\n        return httpclient;\n    }\n}\n", "refactored": false}
{"hexsha": "382e9cd082afd4101e37c36d08eb9143aed3b34e", "ext": "java", "lang": "Java", "content": "public class Resources {\n\n    public static Path getResourcePath(String path) throws URISyntaxException {\n        ClassLoader classLoader = Stream.of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null).findFirst().get();\n        return Paths.get(classLoader.getResource(path).toURI());\n    }\n\n    public static String getResource(String file) throws IOException, URISyntaxException {\n        Path path = getResourcePath(file);\n        return new String(Files.readAllBytes(path));\n    }\n\n    public static List<String> listResources(String dir) throws IOException, URISyntaxException {\n        Path dirpath = getResourcePath(dir);\n        List<String> filenames = null;\n        try (Stream<Path> walk = Files.walk(dirpath)) {\n            filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString()).collect(Collectors.toList());\n        } catch (IOException e) {\n            throw e;\n        }\n        return filenames;\n    }\n}\n", "class_id": 0, "repo": "craft-ai/craft-ai-client-java", "file": "src/test/java/com/craft_ai/interpreter/tools/Resources.java", "last_update_at": "2021-12-09T21:16:39+00:00", "original_content": "public class Resources {\n\n    public static Path getResourcePath(String path) throws URISyntaxException {\n        ClassLoader classLoader = Stream.of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null).findFirst().get();\n        return Paths.get(classLoader.getResource(path).toURI());\n    }\n\n    public static String getResource(String file) throws IOException, URISyntaxException {\n        Path path = getResourcePath(file);\n        return new String(Files.readAllBytes(path));\n    }\n\n    public static List<String> listResources(String dir) throws IOException, URISyntaxException {\n        Path dirpath = getResourcePath(dir);\n        List<String> filenames = null;\n        try (Stream<Path> walk = Files.walk(dirpath)) {\n            filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString()).collect(Collectors.toList());\n        } catch (IOException e) {\n            throw e;\n        }\n        return filenames;\n    }\n}\n", "refactored": false}
{"hexsha": "1933efc9aa1b1d5e9b432865d575e9d6ff573c10", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"api/v1\")\npublic class CollaboratorController {\n\n    @Autowired\n    CollaboratorService collaboratorServ;\n\n    @ApiOperation(value = \"Get All the Collaborators\")\n    @GetMapping(\"/collaborators\")\n    public ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators() {\n        List<Collaborator> collaborators = collaboratorServ.getCollaborators();\n        List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n        return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n    }\n\n    @ApiOperation(value = \"Get Collaborators by Organization\")\n    @GetMapping(\"/collaborators/organization_id/{org_id}\")\n    public ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable(\"org_id\") Long org_id) {\n        List<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);\n        List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n        return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n    }\n\n    @ApiOperation(value = \"Get All the Collaborator Types\")\n    @GetMapping(\"/collaborators/type\")\n    public ResponseEntity<List<CollaboratorType>> getCollaboratorTypes() {\n        List<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();\n        return ResponseEntity.status(HttpStatus.OK).body(types);\n    }\n\n    @ApiOperation(value = \"Get one Collaborator\")\n    @GetMapping(\"/collaborator/{id}\")\n    public ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable(\"id\") Long id) {\n        CollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));\n        return ResponseEntity.status(HttpStatus.OK).body(collaborator);\n    }\n\n    @ApiOperation(value = \"Get one Main Contact\")\n    @GetMapping(\"/main_contact/{id}\")\n    public ResponseEntity<MainContactResponse> getMainContactId(@PathVariable(\"id\") Long id) {\n        MainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));\n        return ResponseEntity.status(HttpStatus.OK).body(collaborator);\n    }\n\n    @ApiOperation(value = \"Create a Collaborator\")\n    @PostMapping(\"/collaborator\")\n    public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator) {\n        Collaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);\n        return ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);\n    }\n\n    @ApiOperation(value = \"Create a Main Contact\")\n    @PostMapping(\"/main_contact\")\n    public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact) {\n        Collaborator new_main_contact = collaboratorServ.createMainContact(main_contact);\n        return ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);\n    }\n\n    @ApiOperation(value = \"Update a Collaborator\")\n    @PatchMapping(\"/collaborator/{id}\")\n    public ResponseEntity<Collaborator> updateCollaborator(@PathVariable(\"id\") Long id, @RequestBody Collaborator collaborator) {\n        Collaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);\n        return ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);\n    }\n\n    @ApiOperation(value = \"Delete a Collaborator\")\n    @DeleteMapping(\"/collaborator/{id}\")\n    public ResponseEntity<?> deleteCollaborator(@PathVariable(\"id\") Long id) {\n        collaboratorServ.deleteCollaborator(id);\n        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"Delete Collaborator with ID: \" + id);\n    }\n\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getAllErrors().forEach((error) -> {\n            String fieldName = ((FieldError) error).getField();\n            String errorMessage = error.getDefaultMessage();\n            errors.put(fieldName, errorMessage);\n        });\n        return errors;\n    }\n}\n", "class_id": 0, "repo": "Mongen-Initiative/mongen-core", "file": "src/main/java/org/mongen/core/controller/CollaboratorController.java", "last_update_at": "2021-03-12T01:49:51+00:00", "original_content": "@RestController\n@RequestMapping(\"api/v1\")\npublic class CollaboratorController {\n\n    @Autowired\n    CollaboratorService collaboratorServ;\n\n    @ApiOperation(value = \"Get All the Collaborators\")\n    @GetMapping(\"/collaborators\")\n    public ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators() {\n        List<Collaborator> collaborators = collaboratorServ.getCollaborators();\n        List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n        return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n    }\n\n    @ApiOperation(value = \"Get Collaborators by Organization\")\n    @GetMapping(\"/collaborators/organization_id/{org_id}\")\n    public ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable(\"org_id\") Long org_id) {\n        List<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);\n        List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);\n        return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);\n    }\n\n    @ApiOperation(value = \"Get All the Collaborator Types\")\n    @GetMapping(\"/collaborators/type\")\n    public ResponseEntity<List<CollaboratorType>> getCollaboratorTypes() {\n        List<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();\n        return ResponseEntity.status(HttpStatus.OK).body(types);\n    }\n\n    @ApiOperation(value = \"Get one Collaborator\")\n    @GetMapping(\"/collaborator/{id}\")\n    public ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable(\"id\") Long id) {\n        CollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));\n        return ResponseEntity.status(HttpStatus.OK).body(collaborator);\n    }\n\n    @ApiOperation(value = \"Get one Main Contact\")\n    @GetMapping(\"/main_contact/{id}\")\n    public ResponseEntity<MainContactResponse> getMainContactId(@PathVariable(\"id\") Long id) {\n        MainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));\n        return ResponseEntity.status(HttpStatus.OK).body(collaborator);\n    }\n\n    @ApiOperation(value = \"Create a Collaborator\")\n    @PostMapping(\"/collaborator\")\n    public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator) {\n        Collaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);\n        return ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);\n    }\n\n    @ApiOperation(value = \"Create a Main Contact\")\n    @PostMapping(\"/main_contact\")\n    public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact) {\n        Collaborator new_main_contact = collaboratorServ.createMainContact(main_contact);\n        return ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);\n    }\n\n    @ApiOperation(value = \"Update a Collaborator\")\n    @PatchMapping(\"/collaborator/{id}\")\n    public ResponseEntity<Collaborator> updateCollaborator(@PathVariable(\"id\") Long id, @RequestBody Collaborator collaborator) {\n        Collaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);\n        return ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);\n    }\n\n    @ApiOperation(value = \"Delete a Collaborator\")\n    @DeleteMapping(\"/collaborator/{id}\")\n    public ResponseEntity<?> deleteCollaborator(@PathVariable(\"id\") Long id) {\n        collaboratorServ.deleteCollaborator(id);\n        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"Delete Collaborator with ID: \" + id);\n    }\n\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getAllErrors().forEach((error) -> {\n            String fieldName = ((FieldError) error).getField();\n            String errorMessage = error.getDefaultMessage();\n            errors.put(fieldName, errorMessage);\n        });\n        return errors;\n    }\n}\n", "refactored": false}
{"hexsha": "359cc5c8d7ac575f7adc9a4e147dd319b2dcdb15", "ext": "java", "lang": "Java", "content": "public class GetFilingPackageSD {\n\n    private final OauthService oauthService;\n\n    private final SubmissionService submissionService;\n\n    private final UUID actualTransactionId;\n\n    private UserIdentity actualUserIdentity;\n\n    private Response actualFilingPackageResponse;\n\n    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);\n\n    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {\n        this.oauthService = oauthService;\n        this.submissionService = submissionService;\n        actualTransactionId = UUID.randomUUID();\n    }\n\n    @Given(\"valid user account is authenticated\")\n    public void validAdminAccountThatAuthenticated() {\n        actualUserIdentity = oauthService.getUserIdentity();\n    }\n\n    @When(\"user submits request to get filing package information\")\n    public void filingPackageRequest() throws IOException {\n        logger.info(\"Submitting get filing package request\");\n        File resource = new ClassPathResource(MessageFormat.format(\"data/{0}\", Keys.TEST_DOCUMENT_PDF)).getFile();\n        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, \"text/application.pdf\");\n        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualUserIdentity.getUniversalId(), fileSpec);\n        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);\n        // Generate Url Response\n        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(), actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);\n        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualSubmissionId, Keys.FILING_PACKAGE_PATH);\n        logger.info(\"Api response status code: {}\", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));\n        logger.info(\"Api response: {}\", actualFilingPackageResponse.asString());\n    }\n\n    @Then(\"a valid filing package information is returned\")\n    public void getFilingPackageResults() {\n        logger.info(\"Asserting get filing package response\");\n        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"submissionFeeAmount\"));\n        Assert.assertEquals(\"1211\", filingPackageJsonPath.get(\"court.location\"));\n        Assert.assertEquals(\"P\", filingPackageJsonPath.get(\"court.level\"));\n        Assert.assertEquals(\"F\", filingPackageJsonPath.get(\"court.courtClass\"));\n        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get(\"court.agencyId\"));\n        Assert.assertEquals(\"Imma Court\", filingPackageJsonPath.get(\"court.locationDescription\"));\n        Assert.assertEquals(\"Imma Level\", filingPackageJsonPath.get(\"court.levelDescription\"));\n        Assert.assertEquals(\"Imma Class\", filingPackageJsonPath.get(\"court.classDescription\"));\n        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get(\"documents.documentProperties.name[0]\"));\n        Assert.assertEquals(\"AFF\", filingPackageJsonPath.get(\"documents.documentProperties.type[0]\"));\n        Assert.assertEquals(\"This is a doc\", filingPackageJsonPath.get(\"documents.description[0]\"));\n        Assert.assertEquals(\"application/pdf\", filingPackageJsonPath.get(\"documents.mimeType[0]\"));\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"documents.statutoryFeeAmount[0]\"));\n        Assert.assertEquals(\"first\", filingPackageJsonPath.get(\"parties.firstName[0]\"));\n        Assert.assertEquals(\"middle\", filingPackageJsonPath.get(\"parties.middleName[0]\"));\n        Assert.assertEquals(\"last\", filingPackageJsonPath.get(\"parties.lastName[0]\"));\n        logger.info(\"Response matches the requirements\");\n    }\n}\n", "class_id": 0, "repo": "yousiefc/jag-file-submission", "file": "tests/src/test/java/ca/bc/gov/open/jag/efiling/stepDefinitions/GetFilingPackageSD.java", "last_update_at": "2021-12-13T16:25:39+00:00", "original_content": "public class GetFilingPackageSD {\n\n    private final OauthService oauthService;\n\n    private final SubmissionService submissionService;\n\n    private final UUID actualTransactionId;\n\n    private UserIdentity actualUserIdentity;\n\n    private Response actualFilingPackageResponse;\n\n    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);\n\n    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {\n        this.oauthService = oauthService;\n        this.submissionService = submissionService;\n        actualTransactionId = UUID.randomUUID();\n    }\n\n    @Given(\"valid user account is authenticated\")\n    public void validAdminAccountThatAuthenticated() {\n        actualUserIdentity = oauthService.getUserIdentity();\n    }\n\n    @When(\"user submits request to get filing package information\")\n    public void filingPackageRequest() throws IOException {\n        logger.info(\"Submitting get filing package request\");\n        File resource = new ClassPathResource(MessageFormat.format(\"data/{0}\", Keys.TEST_DOCUMENT_PDF)).getFile();\n        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, \"text/application.pdf\");\n        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualUserIdentity.getUniversalId(), fileSpec);\n        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);\n        // Generate Url Response\n        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(), actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);\n        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualSubmissionId, Keys.FILING_PACKAGE_PATH);\n        logger.info(\"Api response status code: {}\", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));\n        logger.info(\"Api response: {}\", actualFilingPackageResponse.asString());\n    }\n\n    @Then(\"a valid filing package information is returned\")\n    public void getFilingPackageResults() {\n        logger.info(\"Asserting get filing package response\");\n        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"submissionFeeAmount\"));\n        Assert.assertEquals(\"1211\", filingPackageJsonPath.get(\"court.location\"));\n        Assert.assertEquals(\"P\", filingPackageJsonPath.get(\"court.level\"));\n        Assert.assertEquals(\"F\", filingPackageJsonPath.get(\"court.courtClass\"));\n        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get(\"court.agencyId\"));\n        Assert.assertEquals(\"Imma Court\", filingPackageJsonPath.get(\"court.locationDescription\"));\n        Assert.assertEquals(\"Imma Level\", filingPackageJsonPath.get(\"court.levelDescription\"));\n        Assert.assertEquals(\"Imma Class\", filingPackageJsonPath.get(\"court.classDescription\"));\n        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get(\"documents.documentProperties.name[0]\"));\n        Assert.assertEquals(\"AFF\", filingPackageJsonPath.get(\"documents.documentProperties.type[0]\"));\n        Assert.assertEquals(\"This is a doc\", filingPackageJsonPath.get(\"documents.description[0]\"));\n        Assert.assertEquals(\"application/pdf\", filingPackageJsonPath.get(\"documents.mimeType[0]\"));\n        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get(\"documents.statutoryFeeAmount[0]\"));\n        Assert.assertEquals(\"first\", filingPackageJsonPath.get(\"parties.firstName[0]\"));\n        Assert.assertEquals(\"middle\", filingPackageJsonPath.get(\"parties.middleName[0]\"));\n        Assert.assertEquals(\"last\", filingPackageJsonPath.get(\"parties.lastName[0]\"));\n        logger.info(\"Response matches the requirements\");\n    }\n}\n", "refactored": false}
{"hexsha": "86b5e913c45589f56c85f9e8a132f6c76a82df60", "ext": "java", "lang": "Java", "content": "public final class ConverterStore {\r\n\r\n    private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] { new ArrayConverter(), new CollectionConverter(), new MapConverter(), new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(), new BooleanConverter(), new CharacterConverter(), new DateConverter(), new CalendarConverter() };\r\n\r\n    private final List<ConditionalConverter<?, ?>> converters;\r\n\r\n    public ConverterStore() {\r\n        this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));\r\n    }\r\n\r\n    ConverterStore(List<ConditionalConverter<?, ?>> converters) {\r\n        this.converters = converters;\r\n    }\r\n\r\n    /**\r\n     * Returns the first converter that supports converting from {@code sourceType} to\r\n     * {@code destinationType}. It will select converter that was full match first.\r\n     * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter\r\n     * exists.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType, Class<?> destinationType) {\r\n        ConditionalConverter<S, D> firstPartialMatchConverter = null;\r\n        for (ConditionalConverter<?, ?> converter : converters) {\r\n            MatchResult matchResult = converter.match(sourceType, destinationType);\r\n            if (matchResult == MatchResult.FULL)\r\n                return (ConditionalConverter<S, D>) converter;\r\n            if (firstPartialMatchConverter == null && matchResult == MatchResult.PARTIAL)\r\n                firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;\r\n        }\r\n        return firstPartialMatchConverter;\r\n    }\r\n\r\n    public List<ConditionalConverter<?, ?>> getConverters() {\r\n        return converters;\r\n    }\r\n\r\n    public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n        ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);\r\n        if (matchConverter != null)\r\n            converters.remove(matchConverter);\r\n        return this;\r\n    }\r\n\r\n    public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n        return getConverterByType(converterClass) != null;\r\n    }\r\n\r\n    public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {\r\n        converters.add(converter);\r\n        return this;\r\n    }\r\n\r\n    private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n        for (ConditionalConverter<?, ?> converter : converters) {\r\n            if (converter.getClass().equals(converterClass))\r\n                return converter;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "codehumane/modelmapper", "file": "core/src/main/java/org/modelmapper/internal/converter/ConverterStore.java", "last_update_at": "2021-01-27T15:06:18+00:00", "original_content": "public final class ConverterStore {\r\n\r\n    private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] { new ArrayConverter(), new CollectionConverter(), new MapConverter(), new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(), new BooleanConverter(), new CharacterConverter(), new DateConverter(), new CalendarConverter() };\r\n\r\n    private final List<ConditionalConverter<?, ?>> converters;\r\n\r\n    public ConverterStore() {\r\n        this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));\r\n    }\r\n\r\n    ConverterStore(List<ConditionalConverter<?, ?>> converters) {\r\n        this.converters = converters;\r\n    }\r\n\r\n    /**\r\n     * Returns the first converter that supports converting from {@code sourceType} to\r\n     * {@code destinationType}. It will select converter that was full match first.\r\n     * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter\r\n     * exists.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType, Class<?> destinationType) {\r\n        ConditionalConverter<S, D> firstPartialMatchConverter = null;\r\n        for (ConditionalConverter<?, ?> converter : converters) {\r\n            MatchResult matchResult = converter.match(sourceType, destinationType);\r\n            if (matchResult == MatchResult.FULL)\r\n                return (ConditionalConverter<S, D>) converter;\r\n            if (firstPartialMatchConverter == null && matchResult == MatchResult.PARTIAL)\r\n                firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;\r\n        }\r\n        return firstPartialMatchConverter;\r\n    }\r\n\r\n    public List<ConditionalConverter<?, ?>> getConverters() {\r\n        return converters;\r\n    }\r\n\r\n    public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n        ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);\r\n        if (matchConverter != null)\r\n            converters.remove(matchConverter);\r\n        return this;\r\n    }\r\n\r\n    public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n        return getConverterByType(converterClass) != null;\r\n    }\r\n\r\n    public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {\r\n        converters.add(converter);\r\n        return this;\r\n    }\r\n\r\n    private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {\r\n        for (ConditionalConverter<?, ?> converter : converters) {\r\n            if (converter.getClass().equals(converterClass))\r\n                return converter;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "538720e56e824c6567f939adc18ccbf7ee54aa80", "ext": "java", "lang": "Java", "content": "public class LevelSelectFragment extends Fragment implements View.OnClickListener {\n\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_level_select, container, false);\n        view.findViewById(R.id.button_one).setOnClickListener(this);\n        view.findViewById(R.id.button_two).setOnClickListener(this);\n        view.findViewById(R.id.button_three).setOnClickListener(this);\n        view.findViewById(R.id.button_four).setOnClickListener(this);\n        view.findViewById(R.id.button_five).setOnClickListener(this);\n        view.findViewById(R.id.button_six).setOnClickListener(this);\n        view.findViewById(R.id.button_seven).setOnClickListener(this);\n        view.findViewById(R.id.button_eight).setOnClickListener(this);\n        view.findViewById(R.id.button_nine).setOnClickListener(this);\n        view.findViewById(R.id.button_ten).setOnClickListener(this);\n        view.findViewById(R.id.button_eleven).setOnClickListener(this);\n        view.findViewById(R.id.button_twelve).setOnClickListener(this);\n        view.findViewById(R.id.button_thirteen).setOnClickListener(this);\n        view.findViewById(R.id.button_fourteen).setOnClickListener(this);\n        view.findViewById(R.id.button_fifteen).setOnClickListener(this);\n        return view;\n    }\n\n    @Override\n    public void onClick(View v) {\n        int level = Integer.parseInt(v.getTag().toString());\n        int sizeColumns = level + 3;\n        int sizeRows = (int) (sizeColumns * 4 / 3);\n        System.out.println(\"v.getTag='\" + v.getTag() + \"', level = \" + level);\n        MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);\n        FragmentTransaction ft = getFragmentManager().beginTransaction();\n        ft.addToBackStack(MazeFragment.class.getSimpleName());\n        ft.replace(R.id.fragment_container, maze).commit();\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n    }\n}\n", "class_id": 0, "repo": "edubois9119/a-maze-ballz", "file": "app/src/main/java/com/ericadubois/amazeballz/controller/LevelSelectFragment.java", "last_update_at": "2021-11-28T22:43:26+00:00", "original_content": "public class LevelSelectFragment extends Fragment implements View.OnClickListener {\n\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_level_select, container, false);\n        view.findViewById(R.id.button_one).setOnClickListener(this);\n        view.findViewById(R.id.button_two).setOnClickListener(this);\n        view.findViewById(R.id.button_three).setOnClickListener(this);\n        view.findViewById(R.id.button_four).setOnClickListener(this);\n        view.findViewById(R.id.button_five).setOnClickListener(this);\n        view.findViewById(R.id.button_six).setOnClickListener(this);\n        view.findViewById(R.id.button_seven).setOnClickListener(this);\n        view.findViewById(R.id.button_eight).setOnClickListener(this);\n        view.findViewById(R.id.button_nine).setOnClickListener(this);\n        view.findViewById(R.id.button_ten).setOnClickListener(this);\n        view.findViewById(R.id.button_eleven).setOnClickListener(this);\n        view.findViewById(R.id.button_twelve).setOnClickListener(this);\n        view.findViewById(R.id.button_thirteen).setOnClickListener(this);\n        view.findViewById(R.id.button_fourteen).setOnClickListener(this);\n        view.findViewById(R.id.button_fifteen).setOnClickListener(this);\n        return view;\n    }\n\n    @Override\n    public void onClick(View v) {\n        int level = Integer.parseInt(v.getTag().toString());\n        int sizeColumns = level + 3;\n        int sizeRows = (int) (sizeColumns * 4 / 3);\n        System.out.println(\"v.getTag='\" + v.getTag() + \"', level = \" + level);\n        MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);\n        FragmentTransaction ft = getFragmentManager().beginTransaction();\n        ft.addToBackStack(MazeFragment.class.getSimpleName());\n        ft.replace(R.id.fragment_container, maze).commit();\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n    }\n}\n", "refactored": false}
{"hexsha": "e94bc548a7921195722fe2cbedc8ac5317dc5070", "ext": "java", "lang": "Java", "content": "public class Location {\n\n    private static Pattern pattern = Pattern.compile(\"(\\\\S+), (\\\\S+), (\\\\S+)\");\n\n    private double x;\n\n    private double y;\n\n    private double z;\n\n    Location(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    private Location(String x, String y, String z) {\n        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));\n    }\n\n    /**\n     * Construct Location object from comma separated string\n     *\n     * @param str comma separated string, e.g. 1.0, 2.0, 3.0\n     * @return Location object from string data\n     */\n    public static Location fromString(String str) {\n        if (str == null)\n            throw new IllegalArgumentException(\"str must not be null\");\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));\n        }\n        return null;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public void setX(long x) {\n        this.x = x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setY(long y) {\n        this.y = y;\n    }\n\n    public double getZ() {\n        return z;\n    }\n\n    public void setZ(long z) {\n        this.z = z;\n    }\n\n    @Override\n    public String toString() {\n        return this.x + \", \" + this.y + \", \" + this.z;\n    }\n}\n", "class_id": 0, "repo": "Trikolon/GitHubTickets", "file": "src/main/java/com/tallcraft/githubtickets/ticket/Location.java", "last_update_at": "2021-04-21T18:39:59+00:00", "original_content": "public class Location {\n\n    private static Pattern pattern = Pattern.compile(\"(\\\\S+), (\\\\S+), (\\\\S+)\");\n\n    private double x;\n\n    private double y;\n\n    private double z;\n\n    Location(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    private Location(String x, String y, String z) {\n        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));\n    }\n\n    /**\n     * Construct Location object from comma separated string\n     *\n     * @param str comma separated string, e.g. 1.0, 2.0, 3.0\n     * @return Location object from string data\n     */\n    public static Location fromString(String str) {\n        if (str == null)\n            throw new IllegalArgumentException(\"str must not be null\");\n        Matcher matcher = pattern.matcher(str);\n        if (matcher.find()) {\n            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));\n        }\n        return null;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public void setX(long x) {\n        this.x = x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setY(long y) {\n        this.y = y;\n    }\n\n    public double getZ() {\n        return z;\n    }\n\n    public void setZ(long z) {\n        this.z = z;\n    }\n\n    @Override\n    public String toString() {\n        return this.x + \", \" + this.y + \", \" + this.z;\n    }\n}\n", "refactored": false}
{"hexsha": "b194a3017d75dc57bcc64346c80eb6e40c252975", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2022-01-08T01:37:46.955Z\")\npublic class RegisterTopicExample {\n\n    @SerializedName(\"id\")\n    private String id = null;\n\n    @SerializedName(\"kind\")\n    private String kind = null;\n\n    @SerializedName(\"op\")\n    private String op = null;\n\n    public RegisterTopicExample id(String id) {\n        this.id = id;\n        return this;\n    }\n\n    /**\n     * Get id\n     * @return id\n     */\n    @ApiModelProperty(example = \"common:test:123\", value = \"\")\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public RegisterTopicExample kind(String kind) {\n        this.kind = kind;\n        return this;\n    }\n\n    /**\n     * Get kind\n     * @return kind\n     */\n    @ApiModelProperty(example = \"common:source:type:1.0.0\", value = \"\")\n    public String getKind() {\n        return kind;\n    }\n\n    public void setKind(String kind) {\n        this.kind = kind;\n    }\n\n    public RegisterTopicExample op(String op) {\n        this.op = op;\n        return this;\n    }\n\n    /**\n     * Get op\n     * @return op\n     */\n    @ApiModelProperty(example = \"deleted\", value = \"\")\n    public String getOp() {\n        return op;\n    }\n\n    public void setOp(String op) {\n        this.op = op;\n    }\n\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;\n        return Objects.equals(this.id, registerTopicExample.id) && Objects.equals(this.kind, registerTopicExample.kind) && Objects.equals(this.op, registerTopicExample.op);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, kind, op);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class RegisterTopicExample {\\n\");\n        sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n        sb.append(\"    kind: \").append(toIndentedString(kind)).append(\"\\n\");\n        sb.append(\"    op: \").append(toIndentedString(op)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "class_id": 0, "repo": "mstest123/self-managed-osdu_from_Daniel", "file": "src/sdk/java/src/main/java/osdu/client/model/RegisterTopicExample.java", "last_update_at": "2021-11-23T23:02:29+00:00", "original_content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2022-01-08T01:37:46.955Z\")\npublic class RegisterTopicExample {\n\n    @SerializedName(\"id\")\n    private String id = null;\n\n    @SerializedName(\"kind\")\n    private String kind = null;\n\n    @SerializedName(\"op\")\n    private String op = null;\n\n    public RegisterTopicExample id(String id) {\n        this.id = id;\n        return this;\n    }\n\n    /**\n     * Get id\n     * @return id\n     */\n    @ApiModelProperty(example = \"common:test:123\", value = \"\")\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public RegisterTopicExample kind(String kind) {\n        this.kind = kind;\n        return this;\n    }\n\n    /**\n     * Get kind\n     * @return kind\n     */\n    @ApiModelProperty(example = \"common:source:type:1.0.0\", value = \"\")\n    public String getKind() {\n        return kind;\n    }\n\n    public void setKind(String kind) {\n        this.kind = kind;\n    }\n\n    public RegisterTopicExample op(String op) {\n        this.op = op;\n        return this;\n    }\n\n    /**\n     * Get op\n     * @return op\n     */\n    @ApiModelProperty(example = \"deleted\", value = \"\")\n    public String getOp() {\n        return op;\n    }\n\n    public void setOp(String op) {\n        this.op = op;\n    }\n\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;\n        return Objects.equals(this.id, registerTopicExample.id) && Objects.equals(this.kind, registerTopicExample.kind) && Objects.equals(this.op, registerTopicExample.op);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, kind, op);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class RegisterTopicExample {\\n\");\n        sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n        sb.append(\"    kind: \").append(toIndentedString(kind)).append(\"\\n\");\n        sb.append(\"    op: \").append(toIndentedString(op)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "refactored": false}
{"hexsha": "dcd97519c9fc5f4a154226ba966b44b05e8970d2", "ext": "java", "lang": "Java", "content": "public final class Counters {\n\n    private Counters() {\n        throw new IllegalAccessError();\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n     *\n     * @param <T>   the component type of the counter\n     * @param items the items to add to the counter\n     * @return the counter\n     */\n    @SafeVarargs\n    public static <T> Counter<T> newCounter(T... items) {\n        Counter<T> counter = new HashMapCounter<>();\n        if (items != null) {\n            counter.incrementAll(Arrays.asList(items));\n        }\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n     *\n     * @param <T>      the component type of the counter\n     * @param iterable the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {\n        Counter<T> counter = new HashMapCounter<>();\n        counter.incrementAll(iterable);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n     *\n     * @param <T>    the component type of the counter\n     * @param stream the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Stream<? extends T> stream) {\n        Counter<T> counter = new HashMapCounter<>();\n        stream.forEach(counter::increment);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>\n     *\n     * @param <T> the component type of the counter\n     * @param map the items and counts to merge with counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {\n        Counter<T> counter = new HashMapCounter<>();\n        counter.merge(map);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>\n     *\n     * @param <T>   the component type of the counter\n     * @param other the items and counts to merge with counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Counter<? extends T> other) {\n        Counter<T> counter = new HashMapCounter<>();\n        counter.merge(other);\n        return counter;\n    }\n\n    /**\n     * <p>Reads a counter from a CSV file.</p>\n     *\n     * @param <TYPE>   the component type of the counter\n     * @param resource the resource that the counter values are read from.\n     * @param keyClass the class of the item type\n     * @return the counter\n     * @throws IOException Something went wrong reading in the counter.\n     */\n    public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {\n        Counter<TYPE> counter = Counters.newCounter();\n        try (CSVReader reader = CSV.builder().reader(resource)) {\n            reader.forEach(row -> {\n                if (row.size() >= 2) {\n                    counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));\n                }\n            });\n        }\n        return counter;\n    }\n\n    /**\n     * <p>Wraps a counter making each method call synchronized.</p>\n     *\n     * @param <TYPE>  the item type\n     * @param counter the counter to wrap\n     * @return the wrapped counter\n     */\n    public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {\n        return new ConcurrentHashMapCounter<TYPE>().merge(counter);\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n     *\n     * @param <T>   the component type of the counter\n     * @param items the items to add to the counter\n     * @return the counter\n     */\n    @SafeVarargs\n    public static <T> Counter<T> newConcurrentCounter(T... items) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        if (items != null) {\n            counter.incrementAll(Arrays.asList(items));\n        }\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>\n     *\n     * @param <T> the component type of the counter\n     * @param map the items and counts to merge with counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        counter.merge(map);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n     *\n     * @param <T>      the component type of the counter\n     * @param iterable the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        counter.incrementAll(iterable);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n     *\n     * @param <T>    the component type of the counter\n     * @param stream the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        stream.forEach(counter::increment);\n        return counter;\n    }\n}\n", "class_id": 0, "repo": "gengoai/mono-repo", "file": "mango/src/main/java/com/gengoai/collection/counter/Counters.java", "last_update_at": "2021-03-15T12:12:38+00:00", "original_content": "public final class Counters {\n\n    private Counters() {\n        throw new IllegalAccessError();\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n     *\n     * @param <T>   the component type of the counter\n     * @param items the items to add to the counter\n     * @return the counter\n     */\n    @SafeVarargs\n    public static <T> Counter<T> newCounter(T... items) {\n        Counter<T> counter = new HashMapCounter<>();\n        if (items != null) {\n            counter.incrementAll(Arrays.asList(items));\n        }\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n     *\n     * @param <T>      the component type of the counter\n     * @param iterable the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {\n        Counter<T> counter = new HashMapCounter<>();\n        counter.incrementAll(iterable);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>\n     *\n     * @param <T>    the component type of the counter\n     * @param stream the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Stream<? extends T> stream) {\n        Counter<T> counter = new HashMapCounter<>();\n        stream.forEach(counter::increment);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>\n     *\n     * @param <T> the component type of the counter\n     * @param map the items and counts to merge with counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {\n        Counter<T> counter = new HashMapCounter<>();\n        counter.merge(map);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>\n     *\n     * @param <T>   the component type of the counter\n     * @param other the items and counts to merge with counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newCounter(Counter<? extends T> other) {\n        Counter<T> counter = new HashMapCounter<>();\n        counter.merge(other);\n        return counter;\n    }\n\n    /**\n     * <p>Reads a counter from a CSV file.</p>\n     *\n     * @param <TYPE>   the component type of the counter\n     * @param resource the resource that the counter values are read from.\n     * @param keyClass the class of the item type\n     * @return the counter\n     * @throws IOException Something went wrong reading in the counter.\n     */\n    public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {\n        Counter<TYPE> counter = Counters.newCounter();\n        try (CSVReader reader = CSV.builder().reader(resource)) {\n            reader.forEach(row -> {\n                if (row.size() >= 2) {\n                    counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));\n                }\n            });\n        }\n        return counter;\n    }\n\n    /**\n     * <p>Wraps a counter making each method call synchronized.</p>\n     *\n     * @param <TYPE>  the item type\n     * @param counter the counter to wrap\n     * @return the wrapped counter\n     */\n    public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {\n        return new ConcurrentHashMapCounter<TYPE>().merge(counter);\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n     *\n     * @param <T>   the component type of the counter\n     * @param items the items to add to the counter\n     * @return the counter\n     */\n    @SafeVarargs\n    public static <T> Counter<T> newConcurrentCounter(T... items) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        if (items != null) {\n            counter.incrementAll(Arrays.asList(items));\n        }\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>\n     *\n     * @param <T> the component type of the counter\n     * @param map the items and counts to merge with counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        counter.merge(map);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n     *\n     * @param <T>      the component type of the counter\n     * @param iterable the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        counter.incrementAll(iterable);\n        return counter;\n    }\n\n    /**\n     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>\n     *\n     * @param <T>    the component type of the counter\n     * @param stream the items to add to the counter\n     * @return the counter\n     */\n    public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {\n        Counter<T> counter = new ConcurrentHashMapCounter<>();\n        stream.forEach(counter::increment);\n        return counter;\n    }\n}\n", "refactored": false}
{"hexsha": "9956ea19059eb59ded74335da5da93cfd5fb1e69", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class FillStyleCellWriteHandler implements CellWriteHandler {\n\n    @Override\n    public int order() {\n        return OrderConstant.FILL_STYLE;\n    }\n\n    @Override\n    public void afterCellDispose(CellWriteHandlerContext context) {\n        List<WriteCellData<?>> cellDataList = context.getCellDataList();\n        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {\n            return;\n        }\n        WriteCellData<?> cellData = cellDataList.get(0);\n        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();\n        if (writeCellStyle == null) {\n            return;\n        }\n        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();\n        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));\n    }\n}\n", "class_id": 0, "repo": "syshenyao/easyexcel", "file": "src/main/java/com/alibaba/excel/write/handler/impl/FillStyleCellWriteHandler.java", "last_update_at": "2021-09-25T02:20:47+00:00", "original_content": "@Slf4j\npublic class FillStyleCellWriteHandler implements CellWriteHandler {\n\n    @Override\n    public int order() {\n        return OrderConstant.FILL_STYLE;\n    }\n\n    @Override\n    public void afterCellDispose(CellWriteHandlerContext context) {\n        List<WriteCellData<?>> cellDataList = context.getCellDataList();\n        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {\n            return;\n        }\n        WriteCellData<?> cellData = cellDataList.get(0);\n        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();\n        if (writeCellStyle == null) {\n            return;\n        }\n        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();\n        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));\n    }\n}\n", "refactored": false}
{"hexsha": "90d3f4bd6f2d6ccb83b96ee0b6950067be328447", "ext": "java", "lang": "Java", "content": "public class ForcedRevival extends AbstractNormaAttentiveCard {\n\n    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());\n\n    public static final String IMG = makeCardPath(\"ForcedRevival.png\");\n\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n\n    private static final CardRarity RARITY = CardRarity.UNCOMMON;\n\n    private static final CardTarget TARGET = CardTarget.SELF;\n\n    private static final CardType TYPE = CardType.SKILL;\n\n    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;\n\n    private static final int COST = 0;\n\n    private static final int HEAL = 4;\n\n    private static final int UPGRADE_PLUS_HEAL = 2;\n\n    private static final int ENERGY = 1;\n\n    private static final int UPGRADE_PLUS_ENERGY = 1;\n\n    private static final int DEBUFF = 2;\n\n    private static final Integer[] NORMA_LEVELS = { 3 };\n\n    public ForcedRevival() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);\n        magicNumber = baseMagicNumber = HEAL;\n        secondMagicNumber = baseSecondMagicNumber = ENERGY;\n        invertedNumber = baseInvertedNumber = DEBUFF;\n        exhaust = true;\n        this.tags.add(CardTags.HEALING);\n        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));\n    }\n\n    // Actions the card should do.\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        this.addToBot(new HealAction(p, p, this.magicNumber));\n        this.addToBot(new GainEnergyAction(this.secondMagicNumber));\n        if (invertedNumber > 0) {\n            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));\n        }\n    }\n\n    // Upgraded stats.\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n            rawDescription = UPGRADE_DESCRIPTION;\n            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);\n            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);\n            this.initializeDescription();\n        }\n    }\n}\n", "class_id": 0, "repo": "MistressAlison/OrangeJuiceTheSpire", "file": "OrangeJuiceTheSpire/src/main/java/Moonworks/cards/ForcedRevival.java", "last_update_at": "2021-03-04T15:26:37+00:00", "original_content": "public class ForcedRevival extends AbstractNormaAttentiveCard {\n\n    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());\n\n    public static final String IMG = makeCardPath(\"ForcedRevival.png\");\n\n    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);\n\n    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;\n\n    private static final CardRarity RARITY = CardRarity.UNCOMMON;\n\n    private static final CardTarget TARGET = CardTarget.SELF;\n\n    private static final CardType TYPE = CardType.SKILL;\n\n    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;\n\n    private static final int COST = 0;\n\n    private static final int HEAL = 4;\n\n    private static final int UPGRADE_PLUS_HEAL = 2;\n\n    private static final int ENERGY = 1;\n\n    private static final int UPGRADE_PLUS_ENERGY = 1;\n\n    private static final int DEBUFF = 2;\n\n    private static final Integer[] NORMA_LEVELS = { 3 };\n\n    public ForcedRevival() {\n        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);\n        magicNumber = baseMagicNumber = HEAL;\n        secondMagicNumber = baseSecondMagicNumber = ENERGY;\n        invertedNumber = baseInvertedNumber = DEBUFF;\n        exhaust = true;\n        this.tags.add(CardTags.HEALING);\n        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));\n    }\n\n    // Actions the card should do.\n    @Override\n    public void use(AbstractPlayer p, AbstractMonster m) {\n        this.addToBot(new HealAction(p, p, this.magicNumber));\n        this.addToBot(new GainEnergyAction(this.secondMagicNumber));\n        if (invertedNumber > 0) {\n            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));\n        }\n    }\n\n    // Upgraded stats.\n    @Override\n    public void upgrade() {\n        if (!this.upgraded) {\n            this.upgradeName();\n            rawDescription = UPGRADE_DESCRIPTION;\n            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);\n            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);\n            this.initializeDescription();\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "1b569ade89bcace5a09d197649bb5d25efd82337", "ext": "java", "lang": "Java", "content": "public class StatePatternTest {\n\n    /**\n     * Main driver.\n     * @param args arguments from command line\n     */\n    public static void main(String[] args) {\n        Card pncCard = new Card(1005, 10000);\n        AtmMachine atm = new AtmMachine();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n        System.out.println();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n    }\n}\n", "class_id": 0, "repo": "Ziang-Lu/Design-Patterns", "file": "4-Behavioral Patterns/5-State Pattern/ATM Example/Java/runner/StatePatternTest.java", "last_update_at": "2021-04-12T14:19:34+00:00", "original_content": "public class StatePatternTest {\n\n    /**\n     * Main driver.\n     * @param args arguments from command line\n     */\n    public static void main(String[] args) {\n        Card pncCard = new Card(1005, 10000);\n        AtmMachine atm = new AtmMachine();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n        System.out.println();\n        atm.insertCard(pncCard);\n        atm.enterPin(1005);\n        atm.checkBalance();\n        atm.requestCash(1500);\n        atm.ejectCard();\n    }\n}\n", "refactored": false}
{"hexsha": "c59136849f7b5690912dca34634682593abcced3", "ext": "java", "lang": "Java", "content": "@Data\n@AllArgsConstructor\n//@EqualsAndHashCode\n@NoArgsConstructor\npublic class MethodEntity implements Serializable {\n\n    private String fullName;\n\n    private String methodName;\n\n    private String className;\n\n    private String packageName;\n\n    private List<String> parameters;\n\n    //    private List<String> callingLists;\n    private HashSet<String> callingSets;\n\n    //    private List<String> throwsName;\n    private Set<String> throwsName;\n\n    //    private List<String> catchName;\n    private Set<String> catchName;\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"fullName: \").append(fullName);\n        if (parameters != null) {\n            builder.append(\"\\nparameters: \\n\");\n            if (parameters.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else\n                for (Object para : parameters) {\n                    //                System.out.println(para);\n                    builder.append(\"\\t\").append((String) para).append(\"\\n\");\n                }\n        }\n        //\n        builder.append(\"\\ncallingSets: \\n\");\n        if (callingSets == null || callingSets.isEmpty()) {\n            builder.append(\"\\tEmpty.\");\n        } else\n            for (Object m : callingSets) {\n                builder.append(\"\\t\").append(m).append(\"\\n\");\n            }\n        //        }\n        if (throwsName != null) {\n            builder.append(\"\\nthrowsName:\\n\");\n            if (throwsName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else\n                for (Object s : throwsName) {\n                    //                builder.append(\"\\t\").append(((SimpleType) s).getName().getFullyQualifiedName()).append(\"\\n\");\n                    builder.append(\"\\t\").append((String) s).append(\"\\n\");\n                }\n        }\n        if (catchName != null) {\n            builder.append(\"\\ncatchName:\\n\");\n            if (catchName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else\n                for (String s : catchName) {\n                    if (!s.equals(\"\"))\n                        builder.append(\"\\t\").append(s).append(\"\\n\");\n                }\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        return fullName.hashCode() + parameters.hashCode();\n    }\n}\n", "class_id": 0, "repo": "jiaxy/EHAdviser", "file": "replication/Graph/src/main/java/com/tcl/old/entity/MethodEntity.java", "last_update_at": "2021-09-11T21:23:39+00:00", "original_content": "@Data\n@AllArgsConstructor\n//@EqualsAndHashCode\n@NoArgsConstructor\npublic class MethodEntity implements Serializable {\n\n    private String fullName;\n\n    private String methodName;\n\n    private String className;\n\n    private String packageName;\n\n    private List<String> parameters;\n\n    //    private List<String> callingLists;\n    private HashSet<String> callingSets;\n\n    //    private List<String> throwsName;\n    private Set<String> throwsName;\n\n    //    private List<String> catchName;\n    private Set<String> catchName;\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"fullName: \").append(fullName);\n        if (parameters != null) {\n            builder.append(\"\\nparameters: \\n\");\n            if (parameters.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else\n                for (Object para : parameters) {\n                    //                System.out.println(para);\n                    builder.append(\"\\t\").append((String) para).append(\"\\n\");\n                }\n        }\n        //\n        builder.append(\"\\ncallingSets: \\n\");\n        if (callingSets == null || callingSets.isEmpty()) {\n            builder.append(\"\\tEmpty.\");\n        } else\n            for (Object m : callingSets) {\n                builder.append(\"\\t\").append(m).append(\"\\n\");\n            }\n        //        }\n        if (throwsName != null) {\n            builder.append(\"\\nthrowsName:\\n\");\n            if (throwsName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else\n                for (Object s : throwsName) {\n                    //                builder.append(\"\\t\").append(((SimpleType) s).getName().getFullyQualifiedName()).append(\"\\n\");\n                    builder.append(\"\\t\").append((String) s).append(\"\\n\");\n                }\n        }\n        if (catchName != null) {\n            builder.append(\"\\ncatchName:\\n\");\n            if (catchName.isEmpty()) {\n                builder.append(\"\\tEmpty.\");\n            } else\n                for (String s : catchName) {\n                    if (!s.equals(\"\"))\n                        builder.append(\"\\t\").append(s).append(\"\\n\");\n                }\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        return fullName.hashCode() + parameters.hashCode();\n    }\n}\n", "refactored": false}
{"hexsha": "f32ebfdbffc4b4b0bf2bdc7964404d3ed28b32b8", "ext": "java", "lang": "Java", "content": "public final class EventSms extends Event {\n\n    public static final String TYPE = \"type_sms\";\n\n    public static final String EXTRA_TIME = \"extra_time\";\n\n    public static final String EXTRA_DIRECTION = \"extra_direction\";\n\n    public static final String EXTRA_PHONE_NUMBER = \"extra_phone_number\";\n\n    public static final String EXTRA_DATA = \"extra_message_body\";\n\n    public static final String EXTRA_CONTACT_NAME = \"extra_contact_name\";\n\n    private long _id;\n\n    private long time;\n\n    private short direction;\n\n    private String phonenumber;\n\n    private String data;\n\n    private String contactName;\n\n    public EventSms() {\n    }\n\n    /**\n     * This constructor is suitable for create a new object\n     */\n    public EventSms(long time, short direction, String phonenumber, String data, String remoteparty) {\n        this.type = Event.TYPE_SMS;\n        this.rowId = Event.ROWID_UNKNOWN;\n        this.identifier = generateIdentifier();\n        this.sendAttempts = 0;\n        this.time = time;\n        this.direction = direction;\n        this.phonenumber = phonenumber;\n        this.data = data;\n        this.contactName = remoteparty;\n    }\n\n    /**\n     * This constructor is suitable for instantiate from database,\n     * where you already got all important information\n     */\n    public EventSms(int rowId, int identifier, int sendAttempts, long time, short direction, String phonenumber, String data, String remoteparty) {\n        this.type = Event.TYPE_SMS;\n        this.rowId = rowId;\n        this.identifier = identifier;\n        this.sendAttempts = sendAttempts;\n        this.time = time;\n        this.direction = direction;\n        this.phonenumber = phonenumber;\n        this.data = data;\n        this.contactName = remoteparty;\n    }\n\n    public String toString() {\n        String singleLineFormat = String.format(\"EventSMS = { \" + \"Error = %1$b; ErrorMessage = %2$s; \" + \"Type = %3$d; RowId = %4$d; \" + \"Indentifier = %5$d; SendAttempts = %6$d; \" + \"Time = %7$s; Direction = %8$d; \" + \"Phonenumber = %9$s; Data = %10$s; \" + \"Remoteparty = %11$s }\", this.error, this.errorMessage, this.type, this.rowId, this.identifier, this.sendAttempts, GeneralUtil.getDateFormatter().format(new Date(time)), this.direction, this.phonenumber, this.data.replace(\"\\n\", \"\"), this.contactName);\n        return singleLineFormat;\n    }\n\n    public ContentValues getContentValues() {\n        ContentValues contentValues = new ContentValues();\n        contentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());\n        contentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());\n        contentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());\n        contentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());\n        contentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());\n        contentValues.put(EventDatabaseMetadata.Sms.DATA, getData());\n        contentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());\n        return contentValues;\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    public short getDirection() {\n        return direction;\n    }\n\n    public void setPhoneNumber(String number) {\n        this.phonenumber = number;\n    }\n\n    public String getPhonenumber() {\n        return phonenumber;\n    }\n\n    public void setDate(String data) {\n        this.data = data;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n    public String getContactName() {\n        return contactName;\n    }\n\n    public void setId(long id) {\n        _id = id;\n    }\n\n    public long getId() {\n        return _id;\n    }\n\n    @Override\n    public String getShortDescription() {\n        return String.format(\"SMS number: %s, contactName: %s, msg: %s, time: %s\", phonenumber, contactName, data, time);\n    }\n}\n", "class_id": 0, "repo": "010001111/Vx-Suites", "file": "Win32.FlexiSpy/Android/1.04.1/src/com/fx/dalvik/event/EventSms.java", "last_update_at": "2021-07-28T10:02:10+00:00", "original_content": "public final class EventSms extends Event {\n\n    public static final String TYPE = \"type_sms\";\n\n    public static final String EXTRA_TIME = \"extra_time\";\n\n    public static final String EXTRA_DIRECTION = \"extra_direction\";\n\n    public static final String EXTRA_PHONE_NUMBER = \"extra_phone_number\";\n\n    public static final String EXTRA_DATA = \"extra_message_body\";\n\n    public static final String EXTRA_CONTACT_NAME = \"extra_contact_name\";\n\n    private long _id;\n\n    private long time;\n\n    private short direction;\n\n    private String phonenumber;\n\n    private String data;\n\n    private String contactName;\n\n    public EventSms() {\n    }\n\n    /**\n     * This constructor is suitable for create a new object\n     */\n    public EventSms(long time, short direction, String phonenumber, String data, String remoteparty) {\n        this.type = Event.TYPE_SMS;\n        this.rowId = Event.ROWID_UNKNOWN;\n        this.identifier = generateIdentifier();\n        this.sendAttempts = 0;\n        this.time = time;\n        this.direction = direction;\n        this.phonenumber = phonenumber;\n        this.data = data;\n        this.contactName = remoteparty;\n    }\n\n    /**\n     * This constructor is suitable for instantiate from database,\n     * where you already got all important information\n     */\n    public EventSms(int rowId, int identifier, int sendAttempts, long time, short direction, String phonenumber, String data, String remoteparty) {\n        this.type = Event.TYPE_SMS;\n        this.rowId = rowId;\n        this.identifier = identifier;\n        this.sendAttempts = sendAttempts;\n        this.time = time;\n        this.direction = direction;\n        this.phonenumber = phonenumber;\n        this.data = data;\n        this.contactName = remoteparty;\n    }\n\n    public String toString() {\n        String singleLineFormat = String.format(\"EventSMS = { \" + \"Error = %1$b; ErrorMessage = %2$s; \" + \"Type = %3$d; RowId = %4$d; \" + \"Indentifier = %5$d; SendAttempts = %6$d; \" + \"Time = %7$s; Direction = %8$d; \" + \"Phonenumber = %9$s; Data = %10$s; \" + \"Remoteparty = %11$s }\", this.error, this.errorMessage, this.type, this.rowId, this.identifier, this.sendAttempts, GeneralUtil.getDateFormatter().format(new Date(time)), this.direction, this.phonenumber, this.data.replace(\"\\n\", \"\"), this.contactName);\n        return singleLineFormat;\n    }\n\n    public ContentValues getContentValues() {\n        ContentValues contentValues = new ContentValues();\n        contentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());\n        contentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());\n        contentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());\n        contentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());\n        contentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());\n        contentValues.put(EventDatabaseMetadata.Sms.DATA, getData());\n        contentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());\n        return contentValues;\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    public short getDirection() {\n        return direction;\n    }\n\n    public void setPhoneNumber(String number) {\n        this.phonenumber = number;\n    }\n\n    public String getPhonenumber() {\n        return phonenumber;\n    }\n\n    public void setDate(String data) {\n        this.data = data;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n    public String getContactName() {\n        return contactName;\n    }\n\n    public void setId(long id) {\n        _id = id;\n    }\n\n    public long getId() {\n        return _id;\n    }\n\n    @Override\n    public String getShortDescription() {\n        return String.format(\"SMS number: %s, contactName: %s, msg: %s, time: %s\", phonenumber, contactName, data, time);\n    }\n}\n", "refactored": false}
{"hexsha": "6dcf5fe7919988d61c0342c48991b47067c19326", "ext": "java", "lang": "Java", "content": "public class PointToPointIntentCompiler extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {\n\n    private final ITopologyService topologyService;\n\n    /**\n     * Constructs an intent compiler for {@link PointToPointIntent} with the specified\n     * ID generator and topology service.\n     *\n     * @param intentIdGenerator intent ID generator\n     * @param topologyService topology service\n     */\n    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator, IdGenerator<FlowId> flowIdGenerator, ITopologyService topologyService) {\n        super(intentIdGenerator, flowIdGenerator);\n        this.topologyService = checkNotNull(topologyService);\n    }\n\n    @Override\n    public List<Intent> compile(PointToPointIntent intent) {\n        Match match = intent.getMatch();\n        if (!(match instanceof PacketMatch)) {\n            throw new IntentCompilationException(\"intent has unsupported type of match object: \" + match);\n        }\n        SwitchPort ingress = intent.getIngressPort();\n        SwitchPort egress = intent.getEgressPort();\n        FlowId flowId = getNextFlowId();\n        Path path = calculatePath(ingress, egress);\n        List<Action> actions = packActions(intent, intent.getEgressPort());\n        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match, ingress.getPortNumber(), path, actions, 0, 0);\n        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));\n    }\n\n    /**\n     * Calculates a path between the specified ingress port and the specified egress port.\n     * @param ingress ingress port\n     * @param egress egress port\n     * @return path\n     */\n    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {\n        BaseTopology topology = topologyService.getTopology();\n        Switch source = topology.getSwitch(ingress.getDpid());\n        Switch destination = topology.getSwitch(egress.getDpid());\n        if (source == null) {\n            throw new PathNotFoundException(\"source switch not found: \" + ingress.getDpid());\n        }\n        if (destination == null) {\n            throw new PathNotFoundException(\"destination switch not found: \" + egress.getDpid());\n        }\n        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);\n        net.onrc.onos.core.intent.Path path = tree.getPath(destination);\n        return convertPath(path);\n    }\n\n    /**\n     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.\n     *\n     * @param path original {@link net.onrc.onos.core.intent.Path}\n     * @return converted {@link Path}\n     */\n    static Path convertPath(net.onrc.onos.core.intent.Path path) {\n        // TODO: replace with transform when the above issue is resolved\n        ImmutableList<LinkData> dataEntries = FluentIterable.from(path).filter(Predicates.notNull()).toList();\n        Path converted = new Path();\n        for (LinkData data : dataEntries) {\n            converted.add(new FlowLink(data.getSrc(), data.getDst()));\n        }\n        return converted;\n    }\n}\n", "class_id": 0, "repo": "opennetworkinglab/spring-open", "file": "src/main/java/net/onrc/onos/core/newintent/PointToPointIntentCompiler.java", "last_update_at": "2021-11-09T10:56:04+00:00", "original_content": "public class PointToPointIntentCompiler extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {\n\n    private final ITopologyService topologyService;\n\n    /**\n     * Constructs an intent compiler for {@link PointToPointIntent} with the specified\n     * ID generator and topology service.\n     *\n     * @param intentIdGenerator intent ID generator\n     * @param topologyService topology service\n     */\n    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator, IdGenerator<FlowId> flowIdGenerator, ITopologyService topologyService) {\n        super(intentIdGenerator, flowIdGenerator);\n        this.topologyService = checkNotNull(topologyService);\n    }\n\n    @Override\n    public List<Intent> compile(PointToPointIntent intent) {\n        Match match = intent.getMatch();\n        if (!(match instanceof PacketMatch)) {\n            throw new IntentCompilationException(\"intent has unsupported type of match object: \" + match);\n        }\n        SwitchPort ingress = intent.getIngressPort();\n        SwitchPort egress = intent.getEgressPort();\n        FlowId flowId = getNextFlowId();\n        Path path = calculatePath(ingress, egress);\n        List<Action> actions = packActions(intent, intent.getEgressPort());\n        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match, ingress.getPortNumber(), path, actions, 0, 0);\n        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));\n    }\n\n    /**\n     * Calculates a path between the specified ingress port and the specified egress port.\n     * @param ingress ingress port\n     * @param egress egress port\n     * @return path\n     */\n    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {\n        BaseTopology topology = topologyService.getTopology();\n        Switch source = topology.getSwitch(ingress.getDpid());\n        Switch destination = topology.getSwitch(egress.getDpid());\n        if (source == null) {\n            throw new PathNotFoundException(\"source switch not found: \" + ingress.getDpid());\n        }\n        if (destination == null) {\n            throw new PathNotFoundException(\"destination switch not found: \" + egress.getDpid());\n        }\n        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);\n        net.onrc.onos.core.intent.Path path = tree.getPath(destination);\n        return convertPath(path);\n    }\n\n    /**\n     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.\n     *\n     * @param path original {@link net.onrc.onos.core.intent.Path}\n     * @return converted {@link Path}\n     */\n    static Path convertPath(net.onrc.onos.core.intent.Path path) {\n        // TODO: replace with transform when the above issue is resolved\n        ImmutableList<LinkData> dataEntries = FluentIterable.from(path).filter(Predicates.notNull()).toList();\n        Path converted = new Path();\n        for (LinkData data : dataEntries) {\n            converted.add(new FlowLink(data.getSrc(), data.getDst()));\n        }\n        return converted;\n    }\n}\n", "refactored": false}
{"hexsha": "d65782fcc75a5c257b78c54d73583aacf09dfa5d", "ext": "java", "lang": "Java", "content": "@Component\npublic class SmsRabbitListener {\n\n    @Resource\n    private AliyunSmsUtil aliyunSmsUtil;\n\n    /**\n     * ??????????\n     * <p>map????:</p>\n     * <pre>\n     * Map<String, Object> map = new LinkedHashMap<>();\n     * //??????????\n     * map.put(\"code\", 785964);\n     * //?????????????,???1000?????\n     * map.put(\"phone\", Arrays.asList(\"13012341234\", \"13812347894\"));\n     * //????\n     * sendSms(map);\n     * </pre>\n     *\n     * @param map ??map\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(value = \"LEJING.SMS.QUEUE\", durable = \"true\"), exchange = @Exchange(value = \"LEJING.SMS.EXCHANGE\", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = \"true\"), key = { \"sms.verify.code\" }))\n    public void sendSms(Map<String, Object> map) {\n        boolean flag = CollectionUtils.isEmpty(map) || Objects.isNull(map.get(\"phone\")) || Objects.isNull(map.get(\"code\")) || StringUtils.isBlank(map.get(\"phone\").toString()) || StringUtils.isBlank(map.get(\"code\").toString());\n        if (flag) {\n            return;\n        }\n        aliyunSmsUtil.sendSms(map);\n    }\n}\n", "class_id": 0, "repo": "newcardriver/lejing-mall", "file": "lejing-third-party/src/main/java/cn/alphahub/mall/thirdparty/sms/listener/SmsRabbitListener.java", "last_update_at": "2021-12-10T04:17:41+00:00", "original_content": "@Component\npublic class SmsRabbitListener {\n\n    @Resource\n    private AliyunSmsUtil aliyunSmsUtil;\n\n    /**\n     * ??????????\n     * <p>map????:</p>\n     * <pre>\n     * Map<String, Object> map = new LinkedHashMap<>();\n     * //??????????\n     * map.put(\"code\", 785964);\n     * //?????????????,???1000?????\n     * map.put(\"phone\", Arrays.asList(\"13012341234\", \"13812347894\"));\n     * //????\n     * sendSms(map);\n     * </pre>\n     *\n     * @param map ??map\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(value = \"LEJING.SMS.QUEUE\", durable = \"true\"), exchange = @Exchange(value = \"LEJING.SMS.EXCHANGE\", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = \"true\"), key = { \"sms.verify.code\" }))\n    public void sendSms(Map<String, Object> map) {\n        boolean flag = CollectionUtils.isEmpty(map) || Objects.isNull(map.get(\"phone\")) || Objects.isNull(map.get(\"code\")) || StringUtils.isBlank(map.get(\"phone\").toString()) || StringUtils.isBlank(map.get(\"code\").toString());\n        if (flag) {\n            return;\n        }\n        aliyunSmsUtil.sendSms(map);\n    }\n}\n", "refactored": false}
{"hexsha": "7c2ea552d6b33724625ffb28255f80ebf777d7a2", "ext": "java", "lang": "Java", "content": "public abstract class LogicProgramArtifact {\n\n    private List<String> comments = null;\n\n    public void addComment(String comment) {\n        if (comments == null)\n            comments = new ArrayList<String>();\n        comments.add(comment);\n    }\n\n    public void writeTo(BufferedWriter out) throws IOException {\n        if (comments == null)\n            return;\n        for (String comment : comments) out.write(\"% \" + comment + \"\\n\");\n    }\n\n    public void copyComments(LogicProgramArtifact other) {\n        if (other.comments == null)\n            return;\n        if (this.comments == null)\n            comments = new ArrayList<String>();\n        this.comments.addAll(other.comments);\n    }\n}\n", "class_id": 0, "repo": "soniabaee/ALM-Compiler", "file": "Java-Implementation/src/edu/ttu/krlab/alm/datastruct/LogicProgramArtifact.java", "last_update_at": "2021-01-08T19:22:49+00:00", "original_content": "public abstract class LogicProgramArtifact {\n\n    private List<String> comments = null;\n\n    public void addComment(String comment) {\n        if (comments == null)\n            comments = new ArrayList<String>();\n        comments.add(comment);\n    }\n\n    public void writeTo(BufferedWriter out) throws IOException {\n        if (comments == null)\n            return;\n        for (String comment : comments) out.write(\"% \" + comment + \"\\n\");\n    }\n\n    public void copyComments(LogicProgramArtifact other) {\n        if (other.comments == null)\n            return;\n        if (this.comments == null)\n            comments = new ArrayList<String>();\n        this.comments.addAll(other.comments);\n    }\n}\n", "refactored": false}
{"hexsha": "26dda56691b09a01ad828c280432170a49807b73", "ext": "java", "lang": "Java", "content": "public class LineSegment {\n\n    private Point start;\n\n    private Point end;\n\n    private double dX;\n\n    private double dY;\n\n    /**\n     * Constructor LineSegment\n     * @param start point\n     * @param end point\n     * @return new LineSegment Object\n     */\n    public LineSegment(Point start, Point end) throws Exception {\n        this.start = start;\n        this.end = end;\n        this.dX = this.start.getX() - this.end.getX();\n        this.dY = this.start.getY() - this.end.getY();\n    }\n\n    /**\n     * getStart\n     * @return this line's start point\n     * @throws Exception\n     */\n    public Point getStart() throws Exception {\n        return this.start;\n    }\n\n    /**\n     * getEnd\n     * @return this line's end point\n     * @throws Exception\n     */\n    public Point getEnd() throws Exception {\n        return this.end;\n    }\n\n    /**\n     * equal\n     * @param line\n     * @return true if lines are equivalent and false otherwise\n     * @throws Exception\n     */\n    public boolean equal(LineSegment line) throws Exception {\n        if (this.start.equal(line.start) == true && this.end.equal(line.end) == true) {\n            return true;\n        }\n        if (this.start.equal(line.end) == true && this.end.equal(line.start) == true) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * getLength\n     * @return the line segment's length\n     * @throws Exception\n     */\n    public double getLength() throws Exception {\n        return this.start.getDistance(this.end);\n    }\n\n    /**\n     * getSlope\n     * @return this line's slope\n     * @throws Exception\n     */\n    public double getSlope() throws Exception {\n        return (this.start.getY() - this.end.getY()) / (this.start.getX() - this.end.getX());\n    }\n\n    /**\n     * getDirection\n     * @return this line's direction [-180 ... 180]\n     * @throws Exception\n     */\n    public double getDirection() throws Exception {\n        return Math.toDegrees(Math.atan2(this.end.getX() - this.start.getX(), this.end.getY() - this.start.getY()));\n    }\n\n    /**\n     * getDirectionDelta\n     * @param line\n     * @return the delta direction between this line and the param line\n     * @throws Exception\n     */\n    public double getDirectionDelta(LineSegment line) throws Exception {\n        double deltaDir = Math.abs(this.getDirection() - line.getDirection());\n        if (deltaDir > 180) {\n            deltaDir = 360 - deltaDir;\n        }\n        return deltaDir;\n    }\n\n    /**\n     * isPointOnLine\n     * @param point\n     * @return true if param point is on this line and false otherwise\n     * @throws Exception\n     */\n    public boolean isPointOnLine(Point point) throws Exception {\n        if (this.start.equal(point) == true || this.end.equal(point) == true) {\n            return true;\n        }\n        if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX()) && point.getX() >= Math.min(this.start.getX(), this.end.getX()))) {\n            return false;\n        }\n        if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY()) && point.getY() >= Math.min(this.start.getY(), this.end.getY()))) {\n            return false;\n        }\n        LineSegment testLine = new LineSegment(point, this.start);\n        if (this.getSlope() != testLine.getSlope()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * getNearestPointOnLine\n     * @param point\n     * @return nearest point on this line to param point\n     * @throws Exception\n     */\n    public Point getNearestPointOnLine(Point point) throws Exception {\n        if (this.isPointOnLine(point) == true) {\n            return point;\n        }\n        double u = ((point.getX() - this.end.getX()) * this.dX + (point.getY() - this.end.getY()) * this.dY) / (this.dX * this.dX + this.dY * this.dY);\n        if (u < 0.0) {\n            return this.end;\n        } else if (u > 1.0) {\n            return this.start;\n        } else {\n            return new Point(this.end.getX() + u * this.dX, this.end.getY() + u * this.dY);\n        }\n    }\n\n    /**\n     * getMinDistance\n     * @param point\n     * @return minimum distance between param point and this line\n     * @throws Exception\n     */\n    public double getMinDistance(Point point) throws Exception {\n        return point.getDistance(this.getNearestPointOnLine(point));\n    }\n\n    /**\n     * getIntersectionPoint\n     * @param line\n     * @return returns the point where this line and param line intersects and\n     *           null otherwise\n     * @throws Exception\n     */\n    public Point getIntersectionPoint(LineSegment line) throws Exception {\n        StraightLine lineOne = new StraightLine(line);\n        StraightLine lineTwo = new StraightLine(this);\n        Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);\n        if (intersectionPoint == null) {\n            return null;\n        }\n        if (this.isPointOnLine(intersectionPoint) == true) {\n            return intersectionPoint;\n        }\n        return null;\n    }\n\n    /**\n     * projectionInRange\n     * @param point\n     * @return true if the point's projection intersects with this line and\n     *           false otherwise\n     * @throws Exception\n     */\n    public boolean pointProjectionInRange(Point point) throws Exception {\n        double dx = this.end.getX() - this.start.getX();\n        double dy = this.end.getY() - this.start.getY();\n        double innerProduct = (point.getX() - this.start.getX()) * dx + (point.getY() - this.start.getY()) * dy;\n        return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;\n    }\n\n    @Override\n    public String toString() {\n        return \"LineSegment: Start: \" + this.start.toString() + \" End: \" + this.end.toString();\n    }\n}\n", "class_id": 0, "repo": "vangav/vos_backend", "file": "src/com/vangav/backend/math/geometry/LineSegment.java", "last_update_at": "2021-08-09T19:54:45+00:00", "original_content": "public class LineSegment {\n\n    private Point start;\n\n    private Point end;\n\n    private double dX;\n\n    private double dY;\n\n    /**\n     * Constructor LineSegment\n     * @param start point\n     * @param end point\n     * @return new LineSegment Object\n     */\n    public LineSegment(Point start, Point end) throws Exception {\n        this.start = start;\n        this.end = end;\n        this.dX = this.start.getX() - this.end.getX();\n        this.dY = this.start.getY() - this.end.getY();\n    }\n\n    /**\n     * getStart\n     * @return this line's start point\n     * @throws Exception\n     */\n    public Point getStart() throws Exception {\n        return this.start;\n    }\n\n    /**\n     * getEnd\n     * @return this line's end point\n     * @throws Exception\n     */\n    public Point getEnd() throws Exception {\n        return this.end;\n    }\n\n    /**\n     * equal\n     * @param line\n     * @return true if lines are equivalent and false otherwise\n     * @throws Exception\n     */\n    public boolean equal(LineSegment line) throws Exception {\n        if (this.start.equal(line.start) == true && this.end.equal(line.end) == true) {\n            return true;\n        }\n        if (this.start.equal(line.end) == true && this.end.equal(line.start) == true) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * getLength\n     * @return the line segment's length\n     * @throws Exception\n     */\n    public double getLength() throws Exception {\n        return this.start.getDistance(this.end);\n    }\n\n    /**\n     * getSlope\n     * @return this line's slope\n     * @throws Exception\n     */\n    public double getSlope() throws Exception {\n        return (this.start.getY() - this.end.getY()) / (this.start.getX() - this.end.getX());\n    }\n\n    /**\n     * getDirection\n     * @return this line's direction [-180 ... 180]\n     * @throws Exception\n     */\n    public double getDirection() throws Exception {\n        return Math.toDegrees(Math.atan2(this.end.getX() - this.start.getX(), this.end.getY() - this.start.getY()));\n    }\n\n    /**\n     * getDirectionDelta\n     * @param line\n     * @return the delta direction between this line and the param line\n     * @throws Exception\n     */\n    public double getDirectionDelta(LineSegment line) throws Exception {\n        double deltaDir = Math.abs(this.getDirection() - line.getDirection());\n        if (deltaDir > 180) {\n            deltaDir = 360 - deltaDir;\n        }\n        return deltaDir;\n    }\n\n    /**\n     * isPointOnLine\n     * @param point\n     * @return true if param point is on this line and false otherwise\n     * @throws Exception\n     */\n    public boolean isPointOnLine(Point point) throws Exception {\n        if (this.start.equal(point) == true || this.end.equal(point) == true) {\n            return true;\n        }\n        if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX()) && point.getX() >= Math.min(this.start.getX(), this.end.getX()))) {\n            return false;\n        }\n        if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY()) && point.getY() >= Math.min(this.start.getY(), this.end.getY()))) {\n            return false;\n        }\n        LineSegment testLine = new LineSegment(point, this.start);\n        if (this.getSlope() != testLine.getSlope()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * getNearestPointOnLine\n     * @param point\n     * @return nearest point on this line to param point\n     * @throws Exception\n     */\n    public Point getNearestPointOnLine(Point point) throws Exception {\n        if (this.isPointOnLine(point) == true) {\n            return point;\n        }\n        double u = ((point.getX() - this.end.getX()) * this.dX + (point.getY() - this.end.getY()) * this.dY) / (this.dX * this.dX + this.dY * this.dY);\n        if (u < 0.0) {\n            return this.end;\n        } else if (u > 1.0) {\n            return this.start;\n        } else {\n            return new Point(this.end.getX() + u * this.dX, this.end.getY() + u * this.dY);\n        }\n    }\n\n    /**\n     * getMinDistance\n     * @param point\n     * @return minimum distance between param point and this line\n     * @throws Exception\n     */\n    public double getMinDistance(Point point) throws Exception {\n        return point.getDistance(this.getNearestPointOnLine(point));\n    }\n\n    /**\n     * getIntersectionPoint\n     * @param line\n     * @return returns the point where this line and param line intersects and\n     *           null otherwise\n     * @throws Exception\n     */\n    public Point getIntersectionPoint(LineSegment line) throws Exception {\n        StraightLine lineOne = new StraightLine(line);\n        StraightLine lineTwo = new StraightLine(this);\n        Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);\n        if (intersectionPoint == null) {\n            return null;\n        }\n        if (this.isPointOnLine(intersectionPoint) == true) {\n            return intersectionPoint;\n        }\n        return null;\n    }\n\n    /**\n     * projectionInRange\n     * @param point\n     * @return true if the point's projection intersects with this line and\n     *           false otherwise\n     * @throws Exception\n     */\n    public boolean pointProjectionInRange(Point point) throws Exception {\n        double dx = this.end.getX() - this.start.getX();\n        double dy = this.end.getY() - this.start.getY();\n        double innerProduct = (point.getX() - this.start.getX()) * dx + (point.getY() - this.start.getY()) * dy;\n        return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;\n    }\n\n    @Override\n    public String toString() {\n        return \"LineSegment: Start: \" + this.start.toString() + \" End: \" + this.end.toString();\n    }\n}\n", "refactored": false}
{"hexsha": "aa0633d649b8023aede213d3d74bbd8b265feda2", "ext": "java", "lang": "Java", "content": "public class Configuration {\n\n    /* private constructor: static class */\n    private Configuration() {\n    }\n\n    /**\n     * Version number of the tool\n     */\n    public static final String VERSION = \"1.0\";\n\n    /**\n     * General short description text to be encapsulated\n     */\n    public static final String TOOL_DESCRIPTION = \"The PeriCAT - PERICLES Content Aggregation Tool, version \" + VERSION + \", was used to encapsulate these information.\";\n\n    /**\n     * Directory for test data. This is for the unit tests.\n     */\n    public static final String TEST_DIRECTORY = \"src\" + File.separator + \"test\" + File.separator + \"resources\" + File.separator;\n\n    /**\n     * The directory where the projects directory will be created.\n     */\n    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + \"test_directory\" + File.separator;\n\n    /**\n     * The result files of encapsulation processes will be stored here\n     */\n    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"output\" + File.separator;\n\n    /**\n     * If encapsulated files are restored, they will be stored here\n     */\n    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + \"restored\" + File.separator;\n\n    /**\n     * Directory where the scenarios or roles are stored\n     */\n    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"scenarios\" + File.separator;\n\n    /**\n     * Directory in which external libraries are stored\n     */\n    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + \"PeriCAT_libs\" + File.separator;\n\n    /**\n     * Image icon, for add buttons\n     */\n    public static final Icon ADD_ICON = new ImageIcon(getImage(\"/images/add.png\"));\n\n    /**\n     * Image icon for delete buttons\n     */\n    public static final Icon DELETE_ICON = new ImageIcon(getImage(\"/images/delete.png\"));\n\n    /**\n     * Image icon for save buttons\n     */\n    public static final Icon SAVE_ICON = new ImageIcon(getImage(\"/images/disk.png\"));\n\n    /**\n     * Image icon for buttons that start a process\n     */\n    public static final Icon START_ICON = new ImageIcon(getImage(\"/images/control_play_blue.png\"));\n\n    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();\n\n    /**\n     * Configures the constants of the projects directories.\n     */\n    public static void createEncapsulationConstants() {\n        WORKING_DIRECTORY = getCurrentJarFolder() + File.separator;\n        if (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {\n            OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_output\" + File.separator;\n        }\n        if (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {\n            RESTORED_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_restored\" + File.separator;\n        }\n        SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_scenarios\" + File.separator;\n        LIBRARY_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_libs\" + File.separator;\n        createProjectDirectories();\n    }\n\n    /**\n     * Load an image icon to be displayed on a button.\n     *\n     * @param path\n     * @return image for a button\n     */\n    public static Image getImage(String path) {\n        URL url = Configuration.class.getResource(path);\n        if (url == null) {\n            return null;\n        }\n        return Toolkit.getDefaultToolkit().getImage(url);\n    }\n\n    /**\n     * Creates the project directories. To be called on tool start.\n     */\n    public static void createProjectDirectories() {\n        try {\n            FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));\n            FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));\n            FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));\n            FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Gets the location of the .jar, to figure out where to create the project\n     * directory.\n     *\n     * @return File with path to jar directory\n     */\n    private static File getCurrentJarFolder() {\n        try {\n            File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getParentFile();\n            if (file.exists() && file.isDirectory()) {\n                return file;\n            }\n        } catch (URISyntaxException e) {\n            System.err.println(\"Exception while getting the locatio of the .jar. for the creation of the projects directory.\");\n        }\n        return new File(\"./\");\n    }\n\n    /**\n     * Get the list of available algorithms\n     *\n     * Add here further algorithms, and comment out the \"not yet finished\"\n     * algorithms.\n     *\n     * @return algorithms for information encapsulation\n     */\n    public static List<AbstractAlgorithm> getAlgorithms() {\n        if (algorithms.size() == 0) {\n            algorithms.add(new TextInformationFrame());\n            algorithms.add(new OpenStegoRandomLSBSteganography());\n            algorithms.add(new F5Steganography());\n            algorithms.add(new BagItPackaging());\n            algorithms.add(new PNGChunkAdding());\n            algorithms.add(new JPEGTextAdding());\n            algorithms.add(new PDFFileAttacher());\n            algorithms.add(new ZipPackaging());\n            algorithms.add(new TarPackaging());\n            algorithms.add(new OaiOreSubmissionInformationPackage());\n            algorithms.add(new MetsSubmissionInformationPackage());\n            algorithms.add(new QRCodeWatermarking());\n            algorithms.add(new ImageImageFrameExpanding());\n            algorithms.add(new ImageInformationEmbeddingFrame());\n        }\n        return algorithms;\n    }\n}\n", "class_id": 0, "repo": "pericles-project/PeriCAT", "file": "src/main/java/main/Configuration.java", "last_update_at": "2021-04-26T20:56:53+00:00", "original_content": "public class Configuration {\n\n    /* private constructor: static class */\n    private Configuration() {\n    }\n\n    /**\n     * Version number of the tool\n     */\n    public static final String VERSION = \"1.0\";\n\n    /**\n     * General short description text to be encapsulated\n     */\n    public static final String TOOL_DESCRIPTION = \"The PeriCAT - PERICLES Content Aggregation Tool, version \" + VERSION + \", was used to encapsulate these information.\";\n\n    /**\n     * Directory for test data. This is for the unit tests.\n     */\n    public static final String TEST_DIRECTORY = \"src\" + File.separator + \"test\" + File.separator + \"resources\" + File.separator;\n\n    /**\n     * The directory where the projects directory will be created.\n     */\n    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + \"test_directory\" + File.separator;\n\n    /**\n     * The result files of encapsulation processes will be stored here\n     */\n    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"output\" + File.separator;\n\n    /**\n     * If encapsulated files are restored, they will be stored here\n     */\n    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + \"restored\" + File.separator;\n\n    /**\n     * Directory where the scenarios or roles are stored\n     */\n    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"scenarios\" + File.separator;\n\n    /**\n     * Directory in which external libraries are stored\n     */\n    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + \"PeriCAT_libs\" + File.separator;\n\n    /**\n     * Image icon, for add buttons\n     */\n    public static final Icon ADD_ICON = new ImageIcon(getImage(\"/images/add.png\"));\n\n    /**\n     * Image icon for delete buttons\n     */\n    public static final Icon DELETE_ICON = new ImageIcon(getImage(\"/images/delete.png\"));\n\n    /**\n     * Image icon for save buttons\n     */\n    public static final Icon SAVE_ICON = new ImageIcon(getImage(\"/images/disk.png\"));\n\n    /**\n     * Image icon for buttons that start a process\n     */\n    public static final Icon START_ICON = new ImageIcon(getImage(\"/images/control_play_blue.png\"));\n\n    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();\n\n    /**\n     * Configures the constants of the projects directories.\n     */\n    public static void createEncapsulationConstants() {\n        WORKING_DIRECTORY = getCurrentJarFolder() + File.separator;\n        if (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {\n            OUTPUT_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_output\" + File.separator;\n        }\n        if (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {\n            RESTORED_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_restored\" + File.separator;\n        }\n        SCENARIO_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_scenarios\" + File.separator;\n        LIBRARY_DIRECTORY = WORKING_DIRECTORY + \"PeriCAT_libs\" + File.separator;\n        createProjectDirectories();\n    }\n\n    /**\n     * Load an image icon to be displayed on a button.\n     *\n     * @param path\n     * @return image for a button\n     */\n    public static Image getImage(String path) {\n        URL url = Configuration.class.getResource(path);\n        if (url == null) {\n            return null;\n        }\n        return Toolkit.getDefaultToolkit().getImage(url);\n    }\n\n    /**\n     * Creates the project directories. To be called on tool start.\n     */\n    public static void createProjectDirectories() {\n        try {\n            FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));\n            FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));\n            FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));\n            FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Gets the location of the .jar, to figure out where to create the project\n     * directory.\n     *\n     * @return File with path to jar directory\n     */\n    private static File getCurrentJarFolder() {\n        try {\n            File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getParentFile();\n            if (file.exists() && file.isDirectory()) {\n                return file;\n            }\n        } catch (URISyntaxException e) {\n            System.err.println(\"Exception while getting the locatio of the .jar. for the creation of the projects directory.\");\n        }\n        return new File(\"./\");\n    }\n\n    /**\n     * Get the list of available algorithms\n     *\n     * Add here further algorithms, and comment out the \"not yet finished\"\n     * algorithms.\n     *\n     * @return algorithms for information encapsulation\n     */\n    public static List<AbstractAlgorithm> getAlgorithms() {\n        if (algorithms.size() == 0) {\n            algorithms.add(new TextInformationFrame());\n            algorithms.add(new OpenStegoRandomLSBSteganography());\n            algorithms.add(new F5Steganography());\n            algorithms.add(new BagItPackaging());\n            algorithms.add(new PNGChunkAdding());\n            algorithms.add(new JPEGTextAdding());\n            algorithms.add(new PDFFileAttacher());\n            algorithms.add(new ZipPackaging());\n            algorithms.add(new TarPackaging());\n            algorithms.add(new OaiOreSubmissionInformationPackage());\n            algorithms.add(new MetsSubmissionInformationPackage());\n            algorithms.add(new QRCodeWatermarking());\n            algorithms.add(new ImageImageFrameExpanding());\n            algorithms.add(new ImageInformationEmbeddingFrame());\n        }\n        return algorithms;\n    }\n}\n", "refactored": false}
{"hexsha": "4d4c08f2c43d46e7c3aa9a89f65e3118d5a52e33", "ext": "java", "lang": "Java", "content": "@Slf4j\nclass DiRowStructVisitorTest extends VisitorsTest {\n\n    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {\n        final DynamicMetadata meta = new DynamicMetadata();\n        meta.setName(name);\n        meta.setType(type);\n        dynamic.metadatas.add(meta);\n        dynamic.addColumnValue(value);\n    }\n\n    @Test\n    void visit() {\n        final RowStruct rowStruct = new RowStruct();\n        rowStruct.id = \":testing:\";\n        rowStruct.name = NAME;\n        rowStruct.shortP = SHORT;\n        rowStruct.shortC = SHORT;\n        rowStruct.intP = INT;\n        rowStruct.intC = INT;\n        rowStruct.longP = LONG;\n        rowStruct.longC = LONG;\n        rowStruct.floatP = FLOAT;\n        rowStruct.floatC = FLOAT;\n        rowStruct.doubleP = DOUBLE;\n        rowStruct.doubleC = DOUBLE;\n        rowStruct.bytes0 = BYTES0;\n        rowStruct.date0 = DATE;\n        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());\n        rowStruct.bigDecimal0 = BIGDEC;\n        rowStruct.bool1 = Boolean.TRUE;\n        rowStruct.array0 = INTEGERS;\n        rowStruct.object0 = new Rcd();\n        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;\n        rowStruct.h = NAME;\n        // dynamic\n        final Dynamic dynamic = new Dynamic();\n        createMetadata(dynamic, \"dynString\", \"id_String\", \"stringy\");\n        createMetadata(dynamic, \"dynInteger\", \"id_Integer\", INT);\n        createMetadata(dynamic, \"dynDouble\", \"id_Double\", DOUBLE);\n        createMetadata(dynamic, \"dynBytes\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesArray\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesBuffer\", \"id_byte[]\", ByteBuffer.allocate(100).wrap(BYTES0));\n        createMetadata(dynamic, \"dynBytesWString\", \"id_byte[]\", String.valueOf(BYTES0));\n        createMetadata(dynamic, \"dynBigDecimal\", \"id_BigDecimal\", BIGDEC);\n        createMetadata(dynamic, \"dynObject\", \"id_Object\", new Rcd());\n        createMetadata(dynamic, \"STRINGS\", \"id_List\", STRINGS);\n        createMetadata(dynamic, \"LONGS\", \"id_List\", LONGS);\n        createMetadata(dynamic, \"FLOATS\", \"id_List\", FLOATS);\n        createMetadata(dynamic, \"DOUBLES\", \"id_List\", DOUBLES);\n        createMetadata(dynamic, \"BOOLEANS\", \"id_List\", BOOLEANS);\n        createMetadata(dynamic, \"BYTES\", \"id_List\", BYTES);\n        createMetadata(dynamic, \"DATES\", \"id_List\", DATES);\n        createMetadata(dynamic, \"RECORDS\", \"id_List\", RECORDS);\n        rowStruct.dynamic = dynamic;\n        //\n        final DiRowStructVisitor visitor = new DiRowStructVisitor();\n        final Record record = visitor.get(rowStruct, factory);\n        final Schema schema = record.getSchema();\n        // should have 3 excluded fields\n        assertEquals(42, schema.getEntries().size());\n        // asserts Record\n        log.info(\"[visit] values: {}\", record);\n        assertEquals(\":testing:\", record.getString(\"id\"));\n        assertEquals(NAME, record.getString(\"name\"));\n        assertEquals(SHORT, record.getInt(\"shortP\"));\n        assertEquals(SHORT, record.getInt(\"shortC\"));\n        assertEquals(INT, record.getInt(\"intP\"));\n        assertEquals(INT, record.getInt(\"intC\"));\n        assertEquals(LONG, record.getLong(\"longP\"));\n        assertEquals(LONG, record.getLong(\"longC\"));\n        assertEquals(FLOAT, record.getFloat(\"floatP\"));\n        assertEquals(FLOAT, record.getFloat(\"floatC\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleP\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleC\"));\n        assertEquals(DATE.toInstant(), record.getDateTime(\"date0\").toInstant());\n        assertNull(record.getDateTime(\"date1\"));\n        assertEquals(ZONED_DATE_TIME, record.getDateTime(\"date2\"));\n        assertEquals(1946, record.getDateTime(\"date2\").getYear());\n        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString(\"bigDecimal0\")).doubleValue());\n        assertEquals(BIGDEC.toString(), record.getString(\"bigDecimal0\"));\n        assertFalse(record.getBoolean(\"bool0\"));\n        assertTrue(record.getBoolean(\"bool1\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"bytes0\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytes\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesArray\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesBuffer\"));\n        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes(\"dynBytesWString\"));\n        assertEquals(BIGDEC.toString(), record.getString(\"dynBigDecimal\"));\n        assertEquals(BIGDEC, new BigDecimal(record.getString(\"dynBigDecimal\")));\n        assertEquals(RECORD.toString(), record.getString(\"object0\"));\n        assertTrue(record.getBoolean(\"hAshcOdEdIrtY\"));\n        assertEquals(NAME, record.getString(\"h\"));\n        assertEquals(RECORD.toString(), record.getString(\"dynObject\"));\n        assertEquals(INTEGERS, record.getArray(Integer.class, \"array0\"));\n        assertEquals(STRINGS, record.getArray(String.class, \"STRINGS\"));\n        assertEquals(LONGS, record.getArray(Long.class, \"LONGS\"));\n        assertEquals(FLOATS, record.getArray(Float.class, \"FLOATS\"));\n        assertEquals(DOUBLES, record.getArray(Double.class, \"DOUBLES\"));\n        assertEquals(BOOLEANS, record.getArray(Boolean.class, \"BOOLEANS\"));\n        assertEquals(BYTES, record.getArray(byte[].class, \"BYTES\"));\n        assertEquals(DATES, record.getArray(ZonedDateTime.class, \"DATES\"));\n        assertEquals(RECORDS, record.getArray(Record.class, \"RECORDS\"));\n        record.getArray(Record.class, \"RECORDS\").forEach(r -> {\n            assertEquals(1, r.getInt(\"ntgr\"));\n            assertEquals(\"one\", r.getString(\"str\"));\n        });\n        assertEquals(3, schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hAshcOdEdIrtY|h|id\")).count());\n        // check we don't have any technical field in our schema/record\n        assertEquals(0, schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hashCodeDirty|loopKey|lookKey\")).count());\n        assertThrows(NullPointerException.class, () -> record.getBoolean(\"hashCodeDirty\"));\n        assertNull(record.getString(\"loopKey\"));\n        assertNull(record.getString(\"lookKey\"));\n    }\n\n    public static class Rcd {\n\n        public String str = \"one\";\n\n        public int ntgr = 1;\n    }\n}\n", "class_id": 0, "repo": "Talend/component-runtime", "file": "component-studio/component-runtime-di/src/test/java/org/talend/sdk/component/runtime/di/record/DiRowStructVisitorTest.java", "last_update_at": "2021-06-05T13:15:05+00:00", "original_content": "@Slf4j\nclass DiRowStructVisitorTest extends VisitorsTest {\n\n    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {\n        final DynamicMetadata meta = new DynamicMetadata();\n        meta.setName(name);\n        meta.setType(type);\n        dynamic.metadatas.add(meta);\n        dynamic.addColumnValue(value);\n    }\n\n    @Test\n    void visit() {\n        final RowStruct rowStruct = new RowStruct();\n        rowStruct.id = \":testing:\";\n        rowStruct.name = NAME;\n        rowStruct.shortP = SHORT;\n        rowStruct.shortC = SHORT;\n        rowStruct.intP = INT;\n        rowStruct.intC = INT;\n        rowStruct.longP = LONG;\n        rowStruct.longC = LONG;\n        rowStruct.floatP = FLOAT;\n        rowStruct.floatC = FLOAT;\n        rowStruct.doubleP = DOUBLE;\n        rowStruct.doubleC = DOUBLE;\n        rowStruct.bytes0 = BYTES0;\n        rowStruct.date0 = DATE;\n        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());\n        rowStruct.bigDecimal0 = BIGDEC;\n        rowStruct.bool1 = Boolean.TRUE;\n        rowStruct.array0 = INTEGERS;\n        rowStruct.object0 = new Rcd();\n        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;\n        rowStruct.h = NAME;\n        // dynamic\n        final Dynamic dynamic = new Dynamic();\n        createMetadata(dynamic, \"dynString\", \"id_String\", \"stringy\");\n        createMetadata(dynamic, \"dynInteger\", \"id_Integer\", INT);\n        createMetadata(dynamic, \"dynDouble\", \"id_Double\", DOUBLE);\n        createMetadata(dynamic, \"dynBytes\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesArray\", \"id_byte[]\", BYTES0);\n        createMetadata(dynamic, \"dynBytesBuffer\", \"id_byte[]\", ByteBuffer.allocate(100).wrap(BYTES0));\n        createMetadata(dynamic, \"dynBytesWString\", \"id_byte[]\", String.valueOf(BYTES0));\n        createMetadata(dynamic, \"dynBigDecimal\", \"id_BigDecimal\", BIGDEC);\n        createMetadata(dynamic, \"dynObject\", \"id_Object\", new Rcd());\n        createMetadata(dynamic, \"STRINGS\", \"id_List\", STRINGS);\n        createMetadata(dynamic, \"LONGS\", \"id_List\", LONGS);\n        createMetadata(dynamic, \"FLOATS\", \"id_List\", FLOATS);\n        createMetadata(dynamic, \"DOUBLES\", \"id_List\", DOUBLES);\n        createMetadata(dynamic, \"BOOLEANS\", \"id_List\", BOOLEANS);\n        createMetadata(dynamic, \"BYTES\", \"id_List\", BYTES);\n        createMetadata(dynamic, \"DATES\", \"id_List\", DATES);\n        createMetadata(dynamic, \"RECORDS\", \"id_List\", RECORDS);\n        rowStruct.dynamic = dynamic;\n        //\n        final DiRowStructVisitor visitor = new DiRowStructVisitor();\n        final Record record = visitor.get(rowStruct, factory);\n        final Schema schema = record.getSchema();\n        // should have 3 excluded fields\n        assertEquals(42, schema.getEntries().size());\n        // asserts Record\n        log.info(\"[visit] values: {}\", record);\n        assertEquals(\":testing:\", record.getString(\"id\"));\n        assertEquals(NAME, record.getString(\"name\"));\n        assertEquals(SHORT, record.getInt(\"shortP\"));\n        assertEquals(SHORT, record.getInt(\"shortC\"));\n        assertEquals(INT, record.getInt(\"intP\"));\n        assertEquals(INT, record.getInt(\"intC\"));\n        assertEquals(LONG, record.getLong(\"longP\"));\n        assertEquals(LONG, record.getLong(\"longC\"));\n        assertEquals(FLOAT, record.getFloat(\"floatP\"));\n        assertEquals(FLOAT, record.getFloat(\"floatC\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleP\"));\n        assertEquals(DOUBLE, record.getDouble(\"doubleC\"));\n        assertEquals(DATE.toInstant(), record.getDateTime(\"date0\").toInstant());\n        assertNull(record.getDateTime(\"date1\"));\n        assertEquals(ZONED_DATE_TIME, record.getDateTime(\"date2\"));\n        assertEquals(1946, record.getDateTime(\"date2\").getYear());\n        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString(\"bigDecimal0\")).doubleValue());\n        assertEquals(BIGDEC.toString(), record.getString(\"bigDecimal0\"));\n        assertFalse(record.getBoolean(\"bool0\"));\n        assertTrue(record.getBoolean(\"bool1\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"bytes0\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytes\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesArray\"));\n        assertArrayEquals(BYTES0, record.getBytes(\"dynBytesBuffer\"));\n        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes(\"dynBytesWString\"));\n        assertEquals(BIGDEC.toString(), record.getString(\"dynBigDecimal\"));\n        assertEquals(BIGDEC, new BigDecimal(record.getString(\"dynBigDecimal\")));\n        assertEquals(RECORD.toString(), record.getString(\"object0\"));\n        assertTrue(record.getBoolean(\"hAshcOdEdIrtY\"));\n        assertEquals(NAME, record.getString(\"h\"));\n        assertEquals(RECORD.toString(), record.getString(\"dynObject\"));\n        assertEquals(INTEGERS, record.getArray(Integer.class, \"array0\"));\n        assertEquals(STRINGS, record.getArray(String.class, \"STRINGS\"));\n        assertEquals(LONGS, record.getArray(Long.class, \"LONGS\"));\n        assertEquals(FLOATS, record.getArray(Float.class, \"FLOATS\"));\n        assertEquals(DOUBLES, record.getArray(Double.class, \"DOUBLES\"));\n        assertEquals(BOOLEANS, record.getArray(Boolean.class, \"BOOLEANS\"));\n        assertEquals(BYTES, record.getArray(byte[].class, \"BYTES\"));\n        assertEquals(DATES, record.getArray(ZonedDateTime.class, \"DATES\"));\n        assertEquals(RECORDS, record.getArray(Record.class, \"RECORDS\"));\n        record.getArray(Record.class, \"RECORDS\").forEach(r -> {\n            assertEquals(1, r.getInt(\"ntgr\"));\n            assertEquals(\"one\", r.getString(\"str\"));\n        });\n        assertEquals(3, schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hAshcOdEdIrtY|h|id\")).count());\n        // check we don't have any technical field in our schema/record\n        assertEquals(0, schema.getEntries().stream().filter(entry -> entry.getName().matches(\"hashCodeDirty|loopKey|lookKey\")).count());\n        assertThrows(NullPointerException.class, () -> record.getBoolean(\"hashCodeDirty\"));\n        assertNull(record.getString(\"loopKey\"));\n        assertNull(record.getString(\"lookKey\"));\n    }\n\n    public static class Rcd {\n\n        public String str = \"one\";\n\n        public int ntgr = 1;\n    }\n}\n", "refactored": false}
{"hexsha": "89a1a2463b6876a99f9253a15a2bbf7c892f989a", "ext": "java", "lang": "Java", "content": "public class JavaDebugImages {\n\n    //$NON-NLS-1$\n    private static String ICONS_PATH = \"$nl$/icons/full/\";\n\n    // The plugin registry\n    private static ImageRegistry fgImageRegistry = null;\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION = \"IMG_OBJS_EXCEPTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_DISABLED = \"IMG_OBJS_EXCEPTION_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_ERROR = \"IMG_OBJS_ERROR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED = \"IMG_OBJS_BREAKPOINT_INSTALLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = \"IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LOCAL_VARIABLE = \"IMG_OBJS_LOCAL_VARIABLE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT = \"IMG_OBJS_METHOD_RESULT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = \"IMG_OBJS_METHOD_RESULT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = \"IMG_OBJS_CONDITIONAL_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = \"IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT = \"IMG_OBJS_SCOPED_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = \"IMG_OBJS_SCOPED_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = \"IMG_OBJS_UNCAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT = \"IMG_OBJS_CAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_SNIPPET_EVALUATING = \"IMG_OBJS_SNIPPET_EVALUATING\";\n\n    //$NON-NLS-1$\n    public static final String IMG_VIEW_ARGUMENTS_TAB = \"IMG_VIEW_ARGUMENTS_TAB\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_MONITOR = \"IMG_OBJS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CONTENDED_MONITOR = \"IMG_OBJS_CONTENDED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_OWNED_MONITOR = \"IMG_OBJS_OWNED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_REFERENCE = \"IMG_OBJS_REFERENCE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNED = \"IMG_OVR_OWNED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNS_MONITOR = \"IMG_OVR_OWNS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION = \"IMG_OVR_IN_CONTENTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = \"IMG_OVR_IN_CONTENTION_FOR_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_DEADLOCK = \"IMG_OVR_IN_DEADLOCK\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = \"IMG_OBJS_EXCEPTION_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LINE_BRKPT_TYPE = \"IMG_OBJS_LINE_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = \"IMG_OBJS_CLASSLOAD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_WATCHPOINT_TYPE = \"IMG_OBJS_WATCHPOINT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_JSP_BRKPT_TYPE = \"IMG_OBJS_JSP_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = \"IMG_OBJS_METHOD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_THREAD_GROUP = \"IMG_OBJS_THREAD_GROUP\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSPATH = \"IMG_OBJS_CLASSPATH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OUT_OF_SYNCH = \"IMG_OVR_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = \"IMG_OVR_MAY_BE_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SYNCHRONIZED = \"IMG_OVR_SYNCHRONIZED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_NEWSCRAPPAGE = \"IMG_WIZBAN_NEWSCRAPPAGE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_LIBRARY = \"IMG_WIZBAN_LIBRARY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET = \"IMG_TOOL_TERMSNIPPET\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_HOVER = \"IMG_TOOL_TERMSNIPPET_HOVER\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = \"IMG_TOOL_TERMSNIPPET_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = \"IMG_OBJ_JAVA_INSPECT_EXPRESSION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_AUTO_FORMAT = \"IMG_ELCL_AUTO_FORMAT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_ALL_REFERENCES = \"IMG_ELCL_ALL_REFERENCES\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_TRIGGER_POINT = \"IMG_OVR_IN_TRIGGER_POINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_TRIGGER_SUPPRESSED = \"IMG_OVR_TRIGGER_SUPPRESSED\";\n\n    //$NON-NLS-1$\n    private static final String T_OBJ = ICONS_PATH + \"obj16/\";\n\n    //$NON-NLS-1$\n    private static final String T_OVR = ICONS_PATH + \"ovr16/\";\n\n    //$NON-NLS-1$\n    private static final String T_WIZBAN = ICONS_PATH + \"wizban/\";\n\n    //$NON-NLS-1$\n    private static final String T_EVIEW = ICONS_PATH + \"eview16/\";\n\n    //$NON-NLS-1$\n    private static final String T_DLCL = ICONS_PATH + \"dtool16/\";\n\n    //$NON-NLS-1$\n    private static final String T_ELCL = ICONS_PATH + \"etool16/\";\n\n    //$NON-NLS-1$\n    private static final String E_LCL = ICONS_PATH + \"elcl16/\";\n\n    /**\n     * Returns the image managed under the given key in this registry.\n     *\n     * @param key the image's key\n     * @return the image managed under the given key\n     */\n    public static Image get(String key) {\n        return getImageRegistry().get(key);\n    }\n\n    /**\n     * Returns the <code>ImageDescriptor</code> identified by the given key,\n     * or <code>null</code> if it does not exist.\n     */\n    public static ImageDescriptor getImageDescriptor(String key) {\n        return getImageRegistry().getDescriptor(key);\n    }\n\n    /* package */\n    static ImageRegistry getImageRegistry() {\n        if (fgImageRegistry == null) {\n            initializeImageRegistry();\n        }\n        return fgImageRegistry;\n    }\n\n    private static void initializeImageRegistry() {\n        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());\n        declareImages();\n    }\n\n    private static void declareImages() {\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + \"jexceptiond_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + \"installed_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + \"installed_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + \"reference_obj.gif\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + \"localvariable_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + \"methodresult_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + \"methodresult_obj_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + \"entry_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + \"entry_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + \"exit_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + \"exit_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + \"conditional_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + \"conditional_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + \"scoped_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + \"scoped_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + \"uncaught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + \"uncaught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + \"caught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + \"caught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + \"jrtexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + \"jsbook_run_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + \"variable_tab.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + \"error_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + \"warning_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + \"sync_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + \"monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNED, T_OVR + \"owned_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + \"ownsmonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + \"contention_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + \"contentionformonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + \"deadlock_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + \"contended_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + \"owned_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + \"threadgroup_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + \"newsbook_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + \"library_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + \"insp_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + \"classpath_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + \"jline_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + \"jload_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + \"jmeth_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + \"jspbrkpt_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + \"jwatch_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + \"autoform_menu.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + \"all_references.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + \"trigger_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + \"trigger_suppressed_ovr.png\");\n    }\n\n    /**\n     * Declare an Image in the registry table.\n     * @param key   The key to use when registering the image\n     * @param path  The path where the image can be found. This path is relative to where\n     *              this plugin class is found (i.e. typically the packages directory)\n     */\n    private static final void declareRegistryImage(String key, String path) {\n        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());\n        URL url = null;\n        if (bundle != null) {\n            url = FileLocator.find(bundle, new Path(path), null);\n            if (url != null) {\n                desc = ImageDescriptor.createFromURL(url);\n            }\n        }\n        fgImageRegistry.put(key, desc);\n    }\n}\n", "class_id": 0, "repo": "masud-technope/BLIZZARD-Replication-Package-ESEC-FSE2018", "file": "Corpus/eclipse.jdt.debug/147.java", "last_update_at": "2021-11-29T08:28:07+00:00", "original_content": "public class JavaDebugImages {\n\n    //$NON-NLS-1$\n    private static String ICONS_PATH = \"$nl$/icons/full/\";\n\n    // The plugin registry\n    private static ImageRegistry fgImageRegistry = null;\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION = \"IMG_OBJS_EXCEPTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_DISABLED = \"IMG_OBJS_EXCEPTION_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_ERROR = \"IMG_OBJS_ERROR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED = \"IMG_OBJS_BREAKPOINT_INSTALLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = \"IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LOCAL_VARIABLE = \"IMG_OBJS_LOCAL_VARIABLE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT = \"IMG_OBJS_METHOD_RESULT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = \"IMG_OBJS_METHOD_RESULT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = \"IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = \"IMG_OBJS_CONDITIONAL_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = \"IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT = \"IMG_OBJS_SCOPED_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = \"IMG_OBJS_SCOPED_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = \"IMG_OBJS_UNCAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT = \"IMG_OBJS_CAUGHT_BREAKPOINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = \"IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_SNIPPET_EVALUATING = \"IMG_OBJS_SNIPPET_EVALUATING\";\n\n    //$NON-NLS-1$\n    public static final String IMG_VIEW_ARGUMENTS_TAB = \"IMG_VIEW_ARGUMENTS_TAB\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_MONITOR = \"IMG_OBJS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CONTENDED_MONITOR = \"IMG_OBJS_CONTENDED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_OWNED_MONITOR = \"IMG_OBJS_OWNED_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_REFERENCE = \"IMG_OBJS_REFERENCE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNED = \"IMG_OVR_OWNED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OWNS_MONITOR = \"IMG_OVR_OWNS_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION = \"IMG_OVR_IN_CONTENTION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = \"IMG_OVR_IN_CONTENTION_FOR_MONITOR\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_DEADLOCK = \"IMG_OVR_IN_DEADLOCK\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = \"IMG_OBJS_EXCEPTION_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_LINE_BRKPT_TYPE = \"IMG_OBJS_LINE_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = \"IMG_OBJS_CLASSLOAD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_WATCHPOINT_TYPE = \"IMG_OBJS_WATCHPOINT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_JSP_BRKPT_TYPE = \"IMG_OBJS_JSP_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = \"IMG_OBJS_METHOD_BRKPT_TYPE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_THREAD_GROUP = \"IMG_OBJS_THREAD_GROUP\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJS_CLASSPATH = \"IMG_OBJS_CLASSPATH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_OUT_OF_SYNCH = \"IMG_OVR_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = \"IMG_OVR_MAY_BE_OUT_OF_SYNCH\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_SYNCHRONIZED = \"IMG_OVR_SYNCHRONIZED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_NEWSCRAPPAGE = \"IMG_WIZBAN_NEWSCRAPPAGE\";\n\n    //$NON-NLS-1$\n    public static final String IMG_WIZBAN_LIBRARY = \"IMG_WIZBAN_LIBRARY\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET = \"IMG_TOOL_TERMSNIPPET\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_HOVER = \"IMG_TOOL_TERMSNIPPET_HOVER\";\n\n    //$NON-NLS-1$\n    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = \"IMG_TOOL_TERMSNIPPET_DISABLED\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = \"IMG_OBJ_JAVA_INSPECT_EXPRESSION\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_AUTO_FORMAT = \"IMG_ELCL_AUTO_FORMAT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_ELCL_ALL_REFERENCES = \"IMG_ELCL_ALL_REFERENCES\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_IN_TRIGGER_POINT = \"IMG_OVR_IN_TRIGGER_POINT\";\n\n    //$NON-NLS-1$\n    public static final String IMG_OVR_TRIGGER_SUPPRESSED = \"IMG_OVR_TRIGGER_SUPPRESSED\";\n\n    //$NON-NLS-1$\n    private static final String T_OBJ = ICONS_PATH + \"obj16/\";\n\n    //$NON-NLS-1$\n    private static final String T_OVR = ICONS_PATH + \"ovr16/\";\n\n    //$NON-NLS-1$\n    private static final String T_WIZBAN = ICONS_PATH + \"wizban/\";\n\n    //$NON-NLS-1$\n    private static final String T_EVIEW = ICONS_PATH + \"eview16/\";\n\n    //$NON-NLS-1$\n    private static final String T_DLCL = ICONS_PATH + \"dtool16/\";\n\n    //$NON-NLS-1$\n    private static final String T_ELCL = ICONS_PATH + \"etool16/\";\n\n    //$NON-NLS-1$\n    private static final String E_LCL = ICONS_PATH + \"elcl16/\";\n\n    /**\n     * Returns the image managed under the given key in this registry.\n     *\n     * @param key the image's key\n     * @return the image managed under the given key\n     */\n    public static Image get(String key) {\n        return getImageRegistry().get(key);\n    }\n\n    /**\n     * Returns the <code>ImageDescriptor</code> identified by the given key,\n     * or <code>null</code> if it does not exist.\n     */\n    public static ImageDescriptor getImageDescriptor(String key) {\n        return getImageRegistry().getDescriptor(key);\n    }\n\n    /* package */\n    static ImageRegistry getImageRegistry() {\n        if (fgImageRegistry == null) {\n            initializeImageRegistry();\n        }\n        return fgImageRegistry;\n    }\n\n    private static void initializeImageRegistry() {\n        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());\n        declareImages();\n    }\n\n    private static void declareImages() {\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + \"jexceptiond_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + \"installed_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + \"installed_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + \"reference_obj.gif\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + \"localvariable_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + \"methodresult_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + \"methodresult_obj_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + \"entry_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + \"entry_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + \"exit_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + \"exit_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + \"conditional_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + \"conditional_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + \"scoped_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + \"scoped_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + \"uncaught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + \"uncaught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + \"caught_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + \"caught_ovr_disabled.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + \"jrtexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + \"jsbook_run_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + \"variable_tab.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + \"error_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + \"warning_co.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + \"sync_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + \"monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNED, T_OVR + \"owned_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + \"ownsmonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + \"contention_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + \"contentionformonitor_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + \"deadlock_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + \"contended_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + \"owned_monitor_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + \"threadgroup_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + \"newsbook_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + \"library_wiz.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + \"term_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + \"insp_sbook.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + \"classpath_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + \"jexception_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + \"jline_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + \"jload_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + \"jmeth_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + \"jspbrkpt_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + \"jwatch_obj.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + \"autoform_menu.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + \"all_references.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + \"trigger_ovr.png\");\n        //$NON-NLS-1$\n        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + \"trigger_suppressed_ovr.png\");\n    }\n\n    /**\n     * Declare an Image in the registry table.\n     * @param key   The key to use when registering the image\n     * @param path  The path where the image can be found. This path is relative to where\n     *              this plugin class is found (i.e. typically the packages directory)\n     */\n    private static final void declareRegistryImage(String key, String path) {\n        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());\n        URL url = null;\n        if (bundle != null) {\n            url = FileLocator.find(bundle, new Path(path), null);\n            if (url != null) {\n                desc = ImageDescriptor.createFromURL(url);\n            }\n        }\n        fgImageRegistry.put(key, desc);\n    }\n}\n", "refactored": false}
{"hexsha": "200206ad1100a42ddac095ef06efa73f03de0dd3", "ext": "java", "lang": "Java", "content": "class Example5_ConcatAndAppend {\n\n    /**\n     * Main Method. This is where the program begins.\n     */\n    public static void main(String[] args) {\n        String united = \"United\";\n        String states = \"States\";\n        String of = \"of\";\n        String america = \"America\";\n        String usa1;\n        //Initializes the usa1 variable by...\n        usa1 = united + \" \" + states + \" \" + of + \" \" + america;\n        //Prints the value of the usa variable\n        System.out.println(\"Example 1: \" + usa1);\n        String usa2;\n        //Assigns the value of united to usa2\n        usa2 = united;\n        //Appends a space to usa2\n        usa2 = usa2 + \" \";\n        //Appends the value of states to usa2\n        usa2 = usa2 + states;\n        //Appends a space to usa2\n        usa2 = usa2 + \" \";\n        //Appends the value of of to usa2\n        usa2 += of;\n        //Appends a sapce to usa2\n        usa2 += \" \";\n        //Appends the value of america to usa2\n        usa2 += america;\n        //Prints the value of usa2 variable\n        System.out.println(\"Example 2: \" + usa2);\n    }\n}\n", "class_id": 0, "repo": "hackettccp/CSCI111", "file": "Modules/Module8/src/java_basics/Example5_ConcatAndAppend.java", "last_update_at": "2021-02-23T04:09:03+00:00", "original_content": "class Example5_ConcatAndAppend {\n\n    /**\n     * Main Method. This is where the program begins.\n     */\n    public static void main(String[] args) {\n        String united = \"United\";\n        String states = \"States\";\n        String of = \"of\";\n        String america = \"America\";\n        String usa1;\n        //Initializes the usa1 variable by...\n        usa1 = united + \" \" + states + \" \" + of + \" \" + america;\n        //Prints the value of the usa variable\n        System.out.println(\"Example 1: \" + usa1);\n        String usa2;\n        //Assigns the value of united to usa2\n        usa2 = united;\n        //Appends a space to usa2\n        usa2 = usa2 + \" \";\n        //Appends the value of states to usa2\n        usa2 = usa2 + states;\n        //Appends a space to usa2\n        usa2 = usa2 + \" \";\n        //Appends the value of of to usa2\n        usa2 += of;\n        //Appends a sapce to usa2\n        usa2 += \" \";\n        //Appends the value of america to usa2\n        usa2 += america;\n        //Prints the value of usa2 variable\n        System.out.println(\"Example 2: \" + usa2);\n    }\n}\n", "refactored": false}
{"hexsha": "be33f2724e1da203f9adeebe11e277cb5a219833", "ext": "java", "lang": "Java", "content": "@Structure(name = \"QSD\", structureType = StructureType.DATATYPE)\npublic class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {\n\n    // The minuend of this difference\n    private ISetComponent<T> m_minuend;\n\n    // The subtrahend of this difference\n    private ISetComponent<T> m_subtrahend;\n\n    /**\n     * Creates a new instance of the QSD{T} class\n     */\n    public QSD() {\n        super();\n    }\n\n    /**\n     * Creates a new instance of the QSD class with the specified minuend and subtrahend\n     * @param minuend The initial value of the minuend\n     * @param subtrahend The initial value of the subtrahend\n     */\n    public QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend) {\n        this.m_minuend = minuend;\n        this.m_subtrahend = subtrahend;\n    }\n\n    /**\n     * Gets the value representing the minuend of the difference expression\n     */\n    @Property(name = \"minuend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n    public ISetComponent<T> getMinuend() {\n        return this.m_minuend;\n    }\n\n    /**\n     * Sets the value representing the minuend of the difference expression\n     */\n    public void setMinuend(ISetComponent<T> value) {\n        this.m_minuend = value;\n    }\n\n    /**\n     * Gets the value representing the subtrahend\n     */\n    @Property(name = \"subtrahend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n    public ISetComponent<T> getSubtrahend() {\n        return this.m_subtrahend;\n    }\n\n    /**\n     * Sets a value representing the subtrahend\n     */\n    public void setSubtrahend(ISetComponent<T> value) {\n        this.m_subtrahend = value;\n    }\n\n    /**\n     * Normalize the expression\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public IGraphable normalize() {\n        QSD<T> retVal = (QSD<T>) this.shallowCopy();\n        if (retVal.m_minuend instanceof SXPR<?>)\n            retVal.m_minuend = ((SXPR<T>) retVal.m_minuend).translateToQSET();\n        if (retVal.m_subtrahend instanceof SXPR<?>)\n            retVal.m_subtrahend = ((SXPR<T>) retVal.m_subtrahend).translateToQSET();\n        return retVal;\n    }\n\n    /**\n     * Get the iterator\n     */\n    @Override\n    public Iterator<ISetComponent<T>> iterator() {\n        ArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();\n        iterable.add(this.m_minuend);\n        iterable.add(this.m_subtrahend);\n        return iterable.iterator();\n    }\n\n    /**\n     * Get the equivalent set operator\n     */\n    @Override\n    protected SetOperator getEquivalentSetOperator() {\n        return SetOperator.Exclusive;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see org.marc.everest.datatypes.ANY#validateEx()\n     */\n    @Override\n    public Collection<IResultDetail> validateEx() {\n        List<IResultDetail> retVal = new ArrayList<IResultDetail>();\n        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));\n        if (this.m_minuend == null || this.m_minuend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Minuend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        if (this.m_subtrahend == null || this.m_subtrahend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Subtrahend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        return retVal;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see org.marc.everest.datatypes.HXIT#validate()\n     */\n    @Override\n    public boolean validate() {\n        boolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());\n        return isValid;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = super.hashCode();\n        result = prime * result + ((m_minuend == null) ? 0 : m_minuend.hashCode());\n        result = prime * result + ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());\n        return result;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (!super.equals(obj))\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        QSD<T> other = (QSD<T>) obj;\n        if (m_minuend == null) {\n            if (other.m_minuend != null)\n                return false;\n        } else if (!m_minuend.equals(other.m_minuend))\n            return false;\n        if (m_subtrahend == null) {\n            if (other.m_subtrahend != null)\n                return false;\n        } else if (!m_subtrahend.equals(other.m_subtrahend))\n            return false;\n        return true;\n    }\n}\n", "class_id": 0, "repo": "santedb/jeverest", "file": "org.marc.everest/src/main/java/org/marc/everest/datatypes/generic/QSD.java", "last_update_at": "2021-12-20T03:13:45+00:00", "original_content": "@Structure(name = \"QSD\", structureType = StructureType.DATATYPE)\npublic class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {\n\n    // The minuend of this difference\n    private ISetComponent<T> m_minuend;\n\n    // The subtrahend of this difference\n    private ISetComponent<T> m_subtrahend;\n\n    /**\n     * Creates a new instance of the QSD{T} class\n     */\n    public QSD() {\n        super();\n    }\n\n    /**\n     * Creates a new instance of the QSD class with the specified minuend and subtrahend\n     * @param minuend The initial value of the minuend\n     * @param subtrahend The initial value of the subtrahend\n     */\n    public QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend) {\n        this.m_minuend = minuend;\n        this.m_subtrahend = subtrahend;\n    }\n\n    /**\n     * Gets the value representing the minuend of the difference expression\n     */\n    @Property(name = \"minuend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n    public ISetComponent<T> getMinuend() {\n        return this.m_minuend;\n    }\n\n    /**\n     * Sets the value representing the minuend of the difference expression\n     */\n    public void setMinuend(ISetComponent<T> value) {\n        this.m_minuend = value;\n    }\n\n    /**\n     * Gets the value representing the subtrahend\n     */\n    @Property(name = \"subtrahend\", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)\n    public ISetComponent<T> getSubtrahend() {\n        return this.m_subtrahend;\n    }\n\n    /**\n     * Sets a value representing the subtrahend\n     */\n    public void setSubtrahend(ISetComponent<T> value) {\n        this.m_subtrahend = value;\n    }\n\n    /**\n     * Normalize the expression\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public IGraphable normalize() {\n        QSD<T> retVal = (QSD<T>) this.shallowCopy();\n        if (retVal.m_minuend instanceof SXPR<?>)\n            retVal.m_minuend = ((SXPR<T>) retVal.m_minuend).translateToQSET();\n        if (retVal.m_subtrahend instanceof SXPR<?>)\n            retVal.m_subtrahend = ((SXPR<T>) retVal.m_subtrahend).translateToQSET();\n        return retVal;\n    }\n\n    /**\n     * Get the iterator\n     */\n    @Override\n    public Iterator<ISetComponent<T>> iterator() {\n        ArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();\n        iterable.add(this.m_minuend);\n        iterable.add(this.m_subtrahend);\n        return iterable.iterator();\n    }\n\n    /**\n     * Get the equivalent set operator\n     */\n    @Override\n    protected SetOperator getEquivalentSetOperator() {\n        return SetOperator.Exclusive;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see org.marc.everest.datatypes.ANY#validateEx()\n     */\n    @Override\n    public Collection<IResultDetail> validateEx() {\n        List<IResultDetail> retVal = new ArrayList<IResultDetail>();\n        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));\n        if (this.m_minuend == null || this.m_minuend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Minuend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        if (this.m_subtrahend == null || this.m_subtrahend.isNull())\n            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, \"QSD\", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, \"Subtrahend\", String.format(\"ISetComponent<{0}>\", \"?\")), null));\n        return retVal;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see org.marc.everest.datatypes.HXIT#validate()\n     */\n    @Override\n    public boolean validate() {\n        boolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());\n        return isValid;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = super.hashCode();\n        result = prime * result + ((m_minuend == null) ? 0 : m_minuend.hashCode());\n        result = prime * result + ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());\n        return result;\n    }\n\n    /**\n     * (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (!super.equals(obj))\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        QSD<T> other = (QSD<T>) obj;\n        if (m_minuend == null) {\n            if (other.m_minuend != null)\n                return false;\n        } else if (!m_minuend.equals(other.m_minuend))\n            return false;\n        if (m_subtrahend == null) {\n            if (other.m_subtrahend != null)\n                return false;\n        } else if (!m_subtrahend.equals(other.m_subtrahend))\n            return false;\n        return true;\n    }\n}\n", "refactored": false}
{"hexsha": "24ef2e880679f1e3b10ea8823a888c5bb2050a57", "ext": "java", "lang": "Java", "content": "public class LocalResourceSimpleAdapterTest extends AndroidTestCase {\n\n    public void testEagerAdapter() {\n        final Context context = getContext();\n        final Resources res = context.getResources();\n        final String[] uris = res.getStringArray(R.array.local_uri_test);\n        Assert.assertNotNull(uris);\n        SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter.getEagerAdapter(context, R.array.local_uri_test);\n        checkSimpleAdapterData(simpleAdapter, uris.length);\n        Assert.assertFalse(simpleAdapter.isLazy());\n    }\n\n    public void testLazyAdapter() {\n        final Context context = getContext();\n        final Resources res = context.getResources();\n        final String[] uris = res.getStringArray(R.array.local_uri_test);\n        Assert.assertNotNull(uris);\n        SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter.getEagerAdapter(context, R.array.local_uri_test);\n        checkSimpleAdapterData(simpleAdapter, uris.length);\n        Assert.assertTrue(simpleAdapter.isLazy());\n    }\n\n    private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {\n        Assert.assertNotNull(simpleAdapter);\n        Assert.assertEquals(10, requestedSize);\n        Assert.assertEquals(simpleAdapter.getSize(), requestedSize);\n        Uri firstUri = simpleAdapter.get(0);\n        assertNotNull(firstUri);\n        assertEquals(Uri.parse(\"http://myserver.com/file1\"), firstUri);\n        Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);\n        assertNotNull(lastUri);\n        assertEquals(Uri.parse(\"http://myserver.com/file10\"), lastUri);\n    }\n}\n", "class_id": 0, "repo": "app9gag/fresco", "file": "samples/scrollperf/src/androidTest/java/com/facebook/samples/scrollperf/data/impl/LocalResourceSimpleAdapterTest.java", "last_update_at": "2021-07-10T00:32:19+00:00", "original_content": "public class LocalResourceSimpleAdapterTest extends AndroidTestCase {\n\n    public void testEagerAdapter() {\n        final Context context = getContext();\n        final Resources res = context.getResources();\n        final String[] uris = res.getStringArray(R.array.local_uri_test);\n        Assert.assertNotNull(uris);\n        SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter.getEagerAdapter(context, R.array.local_uri_test);\n        checkSimpleAdapterData(simpleAdapter, uris.length);\n        Assert.assertFalse(simpleAdapter.isLazy());\n    }\n\n    public void testLazyAdapter() {\n        final Context context = getContext();\n        final Resources res = context.getResources();\n        final String[] uris = res.getStringArray(R.array.local_uri_test);\n        Assert.assertNotNull(uris);\n        SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter.getEagerAdapter(context, R.array.local_uri_test);\n        checkSimpleAdapterData(simpleAdapter, uris.length);\n        Assert.assertTrue(simpleAdapter.isLazy());\n    }\n\n    private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {\n        Assert.assertNotNull(simpleAdapter);\n        Assert.assertEquals(10, requestedSize);\n        Assert.assertEquals(simpleAdapter.getSize(), requestedSize);\n        Uri firstUri = simpleAdapter.get(0);\n        assertNotNull(firstUri);\n        assertEquals(Uri.parse(\"http://myserver.com/file1\"), firstUri);\n        Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);\n        assertNotNull(lastUri);\n        assertEquals(Uri.parse(\"http://myserver.com/file10\"), lastUri);\n    }\n}\n", "refactored": false}
{"hexsha": "0556eb05af9e2291d3785cc5ac51b749d932d51e", "ext": "java", "lang": "Java", "content": "public class HandleResponseImpl implements ResponseHandler<ResponseDto> {\n\n    @Override\n    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {\n        ResponseDto response = new ResponseDto();\n        if (null != httpResponse) {\n            response.setResponse(httpResponse);\n            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());\n            for (Header header : httpResponse.getAllHeaders()) {\n                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));\n            }\n            response.setContentType(response.getHeader(\"Content-Type\"));\n            response.setRequestId(response.getHeader(\"X-Ca-Request-Id\"));\n            response.setErrorMessage(response.getHeader(\"X-Ca-Error-Message\"));\n            if (httpResponse.getEntity() == null) {\n                response.setBody(null);\n            } else {\n                String s = readStreamAsStr(httpResponse.getEntity().getContent());\n                response.setBody(s);\n                response.setErrorMessage(s);\n            }\n        } else {\n            response.setStatusCode(500);\n            response.setErrorMessage(\"No Response\");\n        }\n        return response;\n    }\n\n    public static String readStreamAsStr(InputStream is) throws IOException {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            WritableByteChannel dest = Channels.newChannel(bos);\n            ReadableByteChannel src = Channels.newChannel(is)) {\n            ByteBuffer bb = ByteBuffer.allocate(4096);\n            for (; src.read(bb) != -1; ) {\n                bb.flip();\n                dest.write(bb);\n                bb.clear();\n            }\n            return new String(bos.toByteArray(), StandardCharsets.UTF_8);\n        }\n    }\n}\n", "class_id": 0, "repo": "MasterChenJiaWang/dahua-sdk", "file": "src/main/java/com/daren/chen/dahua/api/utils/HandleResponseImpl.java", "last_update_at": "2021-08-06T12:36:06+00:00", "original_content": "public class HandleResponseImpl implements ResponseHandler<ResponseDto> {\n\n    @Override\n    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {\n        ResponseDto response = new ResponseDto();\n        if (null != httpResponse) {\n            response.setResponse(httpResponse);\n            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());\n            for (Header header : httpResponse.getAllHeaders()) {\n                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));\n            }\n            response.setContentType(response.getHeader(\"Content-Type\"));\n            response.setRequestId(response.getHeader(\"X-Ca-Request-Id\"));\n            response.setErrorMessage(response.getHeader(\"X-Ca-Error-Message\"));\n            if (httpResponse.getEntity() == null) {\n                response.setBody(null);\n            } else {\n                String s = readStreamAsStr(httpResponse.getEntity().getContent());\n                response.setBody(s);\n                response.setErrorMessage(s);\n            }\n        } else {\n            response.setStatusCode(500);\n            response.setErrorMessage(\"No Response\");\n        }\n        return response;\n    }\n\n    public static String readStreamAsStr(InputStream is) throws IOException {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            WritableByteChannel dest = Channels.newChannel(bos);\n            ReadableByteChannel src = Channels.newChannel(is)) {\n            ByteBuffer bb = ByteBuffer.allocate(4096);\n            while (src.read(bb) != -1) {\n                bb.flip();\n                dest.write(bb);\n                bb.clear();\n            }\n            return new String(bos.toByteArray(), StandardCharsets.UTF_8);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "9ef0a07c6c93211f564dd0ee9ac62d005881284a", "ext": "java", "lang": "Java", "content": "public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());\n\n    final static String HTTP_HEADER_NAME = \"Authorization\";\n\n    final static String HTTP_HEADER_VALUE_PREFIX = \"Bearer \";\n\n    final static String OIDC = \"oidc\";\n\n    public ServiceConfiguration conf;\n\n    public ConfigurationCacheService configCache;\n\n    private PulsarAuthorizationProvider defaultProvider;\n\n    private OidcTenantConfig oidcConfig;\n\n    public AuthorizationProviderOidc() {\n    }\n\n    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        initialize(conf, configCache);\n    }\n\n    @Override\n    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        this.conf = conf;\n        this.configCache = configCache;\n        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);\n        this.oidcConfig = new OidcConfig(conf);\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canProduceAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canLookupAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.isSuperUser(role, serviceConfiguration);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {\n        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {\n        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);\n    }\n\n    @Override\n    public void close() throws IOException {\n    }\n\n    @Override\n    public void initialize(ServiceConfiguration config) throws IOException {\n        this.oidcConfig = new OidcConfig(config);\n    }\n\n    @Override\n    public String getAuthMethodName() {\n        return OIDC;\n    }\n\n    @Override\n    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {\n        String biscuit = getJwt(authData);\n        return parseBiscuit(biscuit);\n    }\n\n    private static String validateJwt(final String jwt) throws AuthenticationException {\n        // Key check\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        } else {\n            throw new AuthenticationException(\"Blank biscuit found\");\n        }\n    }\n\n    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {\n        if (authData.hasDataFromCommand()) {\n            // Authenticate Pulsar binary connection\n            return authData.getCommandData();\n        } else if (authData.hasDataFromHttp()) {\n            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx\n            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);\n            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {\n                throw new AuthenticationException(\"Invalid HTTP Authorization header\");\n            }\n            // Remove prefix\n            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());\n            return validateJwt(jwt);\n        } else {\n            throw new AuthenticationException(\"No JWT credentials passed\");\n        }\n    }\n\n    private String parseBiscuit(final String jwt) throws AuthenticationException {\n        LOGGER.info(\"Jwt to parse: {}\", jwt);\n        // TODO\n        return \"\";\n    }\n}\n", "class_id": 0, "repo": "mvniekerk/poc-apache-pulsar-authz-oidc", "file": "src/main/java/za/co/koperfontein/poc/pulsar/oidc/AuthorizationProviderOidc.java", "last_update_at": "2021-11-18T16:58:34+00:00", "original_content": "public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());\n\n    final static String HTTP_HEADER_NAME = \"Authorization\";\n\n    final static String HTTP_HEADER_VALUE_PREFIX = \"Bearer \";\n\n    final static String OIDC = \"oidc\";\n\n    public ServiceConfiguration conf;\n\n    public ConfigurationCacheService configCache;\n\n    private PulsarAuthorizationProvider defaultProvider;\n\n    private OidcTenantConfig oidcConfig;\n\n    public AuthorizationProviderOidc() {\n    }\n\n    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        initialize(conf, configCache);\n    }\n\n    @Override\n    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {\n        this.conf = conf;\n        this.configCache = configCache;\n        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);\n        this.oidcConfig = new OidcConfig(conf);\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canProduceAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.canLookupAsync(topicName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {\n        if (!role.startsWith(\"jwt:\")) {\n            return defaultProvider.isSuperUser(role, serviceConfiguration);\n        }\n        // TODO\n        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();\n        permissionFuture.complete(true);\n        return permissionFuture;\n    }\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {\n        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {\n        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);\n    }\n\n    @Override\n    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {\n        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);\n    }\n\n    @Override\n    public void close() throws IOException {\n    }\n\n    @Override\n    public void initialize(ServiceConfiguration config) throws IOException {\n        this.oidcConfig = new OidcConfig(config);\n    }\n\n    @Override\n    public String getAuthMethodName() {\n        return OIDC;\n    }\n\n    @Override\n    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {\n        String biscuit = getJwt(authData);\n        return parseBiscuit(biscuit);\n    }\n\n    private static String validateJwt(final String jwt) throws AuthenticationException {\n        // Key check\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        } else {\n            throw new AuthenticationException(\"Blank biscuit found\");\n        }\n    }\n\n    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {\n        if (authData.hasDataFromCommand()) {\n            // Authenticate Pulsar binary connection\n            return authData.getCommandData();\n        } else if (authData.hasDataFromHttp()) {\n            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx\n            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);\n            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {\n                throw new AuthenticationException(\"Invalid HTTP Authorization header\");\n            }\n            // Remove prefix\n            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());\n            return validateJwt(jwt);\n        } else {\n            throw new AuthenticationException(\"No JWT credentials passed\");\n        }\n    }\n\n    private String parseBiscuit(final String jwt) throws AuthenticationException {\n        LOGGER.info(\"Jwt to parse: {}\", jwt);\n        // TODO\n        return \"\";\n    }\n}\n", "refactored": false}
{"hexsha": "ac8564a3b708ca4495959d57dc906f61cac2ece9", "ext": "java", "lang": "Java", "content": "public class LeftJoinTest {\n\n    @Test\n    public void testLeftJoin() {\n        HashMap one = new HashMap();\n        one.put(\"kis\", \"pande\");\n        one.put(\"kiss\", \"pan\");\n        one.put(\"kisss\", \"pnde\");\n        one.put(\"kissss\", \"pae\");\n        HashMap two = new HashMap();\n        two.put(\"kis\", \"Sarvin\");\n        two.put(\"kiss\", \"Srvin\");\n        two.put(\"kisss\", \"Savin\");\n        two.put(\"kissss\", \"Sarvn\");\n        HashMap<String, String[]> test = LeftJoin.leftJoin(one, two);\n        assertEquals(\"\", 4, test.size());\n        assertTrue(\"\", test.containsKey(\"kisss\"));\n        assertEquals(\"\", \"pande\", test.get(\"kis\")[0]);\n    }\n}\n", "class_id": 0, "repo": "kishorpan2/data-structures-and-algorithms", "file": "code401Challenges/src/test/java/code401Challenges/hashTable/LeftJoinTest.java", "last_update_at": "2021-05-08T15:13:22+00:00", "original_content": "public class LeftJoinTest {\n\n    @Test\n    public void testLeftJoin() {\n        HashMap one = new HashMap();\n        one.put(\"kis\", \"pande\");\n        one.put(\"kiss\", \"pan\");\n        one.put(\"kisss\", \"pnde\");\n        one.put(\"kissss\", \"pae\");\n        HashMap two = new HashMap();\n        two.put(\"kis\", \"Sarvin\");\n        two.put(\"kiss\", \"Srvin\");\n        two.put(\"kisss\", \"Savin\");\n        two.put(\"kissss\", \"Sarvn\");\n        HashMap<String, String[]> test = LeftJoin.leftJoin(one, two);\n        assertEquals(\"\", 4, test.size());\n        assertTrue(\"\", test.containsKey(\"kisss\"));\n        assertEquals(\"\", \"pande\", test.get(\"kis\")[0]);\n    }\n}\n", "refactored": false}
{"hexsha": "763200963b9fac7b80736eb5620170b19b635e7e", "ext": "java", "lang": "Java", "content": "class TestingComponentD extends Component implements Cloneable {\n\n    @Prop(resType = ResType.NONE, optional = false)\n    int prop1;\n\n    private TestingComponentD(ComponentContext context) {\n        super(\"TestingComponentD\");\n    }\n\n    public static Builder create(ComponentContext context) {\n        return create(context, 0, 0);\n    }\n\n    public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {\n        final Builder builder = new Builder();\n        TestingComponentD instance = new TestingComponentD(context);\n        builder.init(context, defStyleAttr, defStyleRes, instance);\n        return builder;\n    }\n\n    public static class Builder extends Component.Builder<Builder> {\n\n        @Nullable\n        TestingComponentD mLithoComponent;\n\n        ComponentContext mContext;\n\n        private final String[] REQUIRED_PROPS_NAMES = new String[] { \"prop1\" };\n\n        private final int REQUIRED_PROPS_COUNT = 1;\n\n        private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n\n        private void init(ComponentContext context, int defStyleAttr, int defStyleRes, TestingComponentD lithoComponentRef) {\n            super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);\n            mLithoComponent = lithoComponentRef;\n            mContext = context;\n            mRequired.clear();\n        }\n\n        @Override\n        protected void setComponent(Component component) {\n            mLithoComponent = (TestingComponentD) component;\n        }\n\n        public Builder prop1(int prop1) {\n            this.mLithoComponent.prop1 = prop1;\n            mRequired.set(0);\n            return this;\n        }\n\n        @Override\n        @Nullable\n        public TestingComponentD build() {\n            checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n            return mLithoComponent;\n        }\n\n        @Override\n        public Builder getThis() {\n            return this;\n        }\n    }\n}\n", "class_id": 5, "repo": "penguin-wwy/redex", "file": "test/instr/RemoveBuilderPatternTest.java", "last_update_at": "2021-12-28T09:52:33+00:00", "original_content": "class TestingComponentD extends Component implements Cloneable {\n\n    @Prop(resType = ResType.NONE, optional = false)\n    int prop1;\n\n    private TestingComponentD(ComponentContext context) {\n        super(\"TestingComponentD\");\n    }\n\n    public static Builder create(ComponentContext context) {\n        return create(context, 0, 0);\n    }\n\n    public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {\n        final Builder builder = new Builder();\n        TestingComponentD instance = new TestingComponentD(context);\n        builder.init(context, defStyleAttr, defStyleRes, instance);\n        return builder;\n    }\n\n    public static class Builder extends Component.Builder<Builder> {\n\n        @Nullable\n        TestingComponentD mLithoComponent;\n\n        ComponentContext mContext;\n\n        private final String[] REQUIRED_PROPS_NAMES = new String[] { \"prop1\" };\n\n        private final int REQUIRED_PROPS_COUNT = 1;\n\n        private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n\n        private void init(ComponentContext context, int defStyleAttr, int defStyleRes, TestingComponentD lithoComponentRef) {\n            super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);\n            mLithoComponent = lithoComponentRef;\n            mContext = context;\n            mRequired.clear();\n        }\n\n        @Override\n        protected void setComponent(Component component) {\n            mLithoComponent = (TestingComponentD) component;\n        }\n\n        public Builder prop1(int prop1) {\n            this.mLithoComponent.prop1 = prop1;\n            mRequired.set(0);\n            return this;\n        }\n\n        @Override\n        @Nullable\n        public TestingComponentD build() {\n            checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n            return mLithoComponent;\n        }\n\n        @Override\n        public Builder getThis() {\n            return this;\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "23db7ae693e11efffaedcecc41a12084a78574f9", "ext": "java", "lang": "Java", "content": "public class Aufgabe1 {\n\n    public static void aufg() {\n        int[][] data = { { 3, 2, 5, 7 }, { 1, 4, 4, 8 }, { 9, 1, 0, 2 }, { 0, 2, 6, 3 } };\n        // Summe deklarieren\n        int summe = 0;\n        int zeile = 0;\n        while (zeile < data.length) try {\n            int spalte = 0;\n            while (spalte < data[zeile].length) try {\n                summe += data[spalte][zeile];\n            } finally {\n                spalte++;\n            }\n        } finally {\n            zeile++;\n        }\n        // Summe ausgeben\n        System.out.println(\"Summe: \" + summe);\n    }\n}\n", "class_id": 0, "repo": "deanomus/SZUT", "file": "src/de/deanomus/FirstLehrjahr/A20_1_Mehrdimensionale_Arrays/Aufgabe1.java", "last_update_at": "2021-10-13T20:56:24+00:00", "original_content": "public class Aufgabe1 {\n\n    public static void aufg() {\n        int[][] data = { { 3, 2, 5, 7 }, { 1, 4, 4, 8 }, { 9, 1, 0, 2 }, { 0, 2, 6, 3 } };\n        // Summe deklarieren\n        int summe = 0;\n        // Summe berechnen\n        for (int zeile = 0; zeile < data.length; zeile++) {\n            for (int spalte = 0; spalte < data[zeile].length; spalte++) {\n                summe += data[spalte][zeile];\n            }\n        }\n        // Summe ausgeben\n        System.out.println(\"Summe: \" + summe);\n    }\n}\n", "refactored": true}
{"hexsha": "a9493bf8c49764bbd03c7dd221f326510d0d8afa", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class CooldownsTest {\n\n    private static final String ENCHANT_NAME = \"enchantName\";\n\n    private static final UUID USER_ID = UUID.randomUUID();\n\n    @Mock\n    private Clock clock;\n\n    @Mock\n    private CustomEnchantment enchantment;\n\n    @Mock\n    private LivingEntity user;\n\n    @Mock\n    private Settings settings;\n\n    @Before\n    public void setUp() throws Exception {\n        TestUtils.set(Cooldowns.class, \"clock\", clock);\n        when(enchantment.getName()).thenReturn(ENCHANT_NAME);\n        when(user.getUniqueId()).thenReturn(USER_ID);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n\n    @Test\n    public void configure() throws Exception {\n        Cooldowns.configure(settings, 12, 23);\n        verify(settings).set(\"cooldown\", 12, 23);\n    }\n\n    @Test\n    public void secondsLeft() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 14);\n    }\n\n    @Test\n    public void secondsLeft_roundedUp() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1000L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(1.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 1);\n    }\n\n    @Test\n    public void onCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n\n    @Test\n    public void onCooldown_exact() throws Exception {\n        when(clock.millis()).thenReturn(100L, 15100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void onCooldown_offCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduce() throws Exception {\n        when(clock.millis()).thenReturn(100L, 10100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, 6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduceNegative() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, -6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n}\n", "class_id": 0, "repo": "Eniripsa96/EnchantmentAPI", "file": "tst/com/sucy/enchant/api/CooldownsTest.java", "last_update_at": "2021-05-09T13:51:15+00:00", "original_content": "@RunWith(MockitoJUnitRunner.class)\npublic class CooldownsTest {\n\n    private static final String ENCHANT_NAME = \"enchantName\";\n\n    private static final UUID USER_ID = UUID.randomUUID();\n\n    @Mock\n    private Clock clock;\n\n    @Mock\n    private CustomEnchantment enchantment;\n\n    @Mock\n    private LivingEntity user;\n\n    @Mock\n    private Settings settings;\n\n    @Before\n    public void setUp() throws Exception {\n        TestUtils.set(Cooldowns.class, \"clock\", clock);\n        when(enchantment.getName()).thenReturn(ENCHANT_NAME);\n        when(user.getUniqueId()).thenReturn(USER_ID);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n\n    @Test\n    public void configure() throws Exception {\n        Cooldowns.configure(settings, 12, 23);\n        verify(settings).set(\"cooldown\", 12, 23);\n    }\n\n    @Test\n    public void secondsLeft() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 14);\n    }\n\n    @Test\n    public void secondsLeft_roundedUp() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1000L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(1.0);\n        Cooldowns.start(enchantment, user);\n        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);\n        assertEquals(result, 1);\n    }\n\n    @Test\n    public void onCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 1100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n\n    @Test\n    public void onCooldown_exact() throws Exception {\n        when(clock.millis()).thenReturn(100L, 15100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void onCooldown_offCooldown() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduce() throws Exception {\n        when(clock.millis()).thenReturn(100L, 10100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, 6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertFalse(result);\n    }\n\n    @Test\n    public void reduceNegative() throws Exception {\n        when(clock.millis()).thenReturn(100L, 20100L);\n        when(settings.get(\"cooldown\", 2)).thenReturn(15.0);\n        Cooldowns.start(enchantment, user);\n        Cooldowns.reduce(enchantment, user, -6000);\n        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);\n        assertTrue(result);\n    }\n}\n", "refactored": false}
{"hexsha": "13885d2553f83227a07c14f88340bf149ac6a251", "ext": "java", "lang": "Java", "content": "public class IndexBall extends CommandBase {\n\n    FeederSubsystem feeder;\n\n    int targetPositon;\n\n    int incrementTicks;\n\n    boolean reversing;\n\n    boolean isDone;\n\n    boolean maxBalls;\n\n    boolean outputSwitchPressed;\n\n    private final boolean setTalonPosistionEveryCycle = true;\n\n    public IndexBall() {\n        feeder = FeederSubsystem.getInstance();\n        addRequirements(feeder);\n    }\n\n    // Called when the command is initially scheduled.\n    @Override\n    public void initialize() {\n        incrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();\n        int currentPosition = (int) feeder.getCurrentPosition();\n        targetPositon = currentPosition + incrementTicks;\n        reversing = false;\n        isDone = false;\n        if (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {\n            maxBalls = true;\n            this.cancel();\n            return;\n        } else if (FeederSubsystem.isBallAtOutput()) {\n            outputSwitchPressed = true;\n            this.cancel();\n            return;\n        }\n        maxBalls = false;\n        outputSwitchPressed = false;\n        feeder.setFeederPosistion(targetPositon);\n    }\n\n    // Called every time the scheduler runs while the command is scheduled.\n    @Override\n    public void execute() {\n        if (maxBalls == true) {\n            isDone = true;\n            return;\n        } else if (FeederSubsystem.isBallAtOutput()) {\n            outputSwitchPressed = true;\n            isDone = true;\n            return;\n        }\n        int currentPosition = (int) feeder.getCurrentPosition();\n        boolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);\n        int ticksChanged = currentPosition - (targetPositon - incrementTicks);\n        if (currentPosition >= targetPositon || atPosistion) {\n            isDone = true;\n        } else if (reversing) {\n            if (atPosistion) {\n                isDone = true;\n            } else if (setTalonPosistionEveryCycle) {\n                feeder.setFeederPosistion(targetPositon - incrementTicks);\n            }\n        } else if (setTalonPosistionEveryCycle) {\n            feeder.setFeederPosistion(targetPositon);\n        }\n    }\n\n    // Called once the command ends or is interrupted.\n    @Override\n    public void end(boolean interrupted) {\n        if (reversing == false && maxBalls == false && outputSwitchPressed == false) {\n            feeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);\n        }\n        if (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {\n            feeder.setFeederPosistion((int) feeder.getCurrentPosition());\n            feeder.stopFeeder();\n        }\n    }\n\n    // Returns true when the command should end.\n    @Override\n    public boolean isFinished() {\n        return isDone;\n    }\n}\n", "class_id": 0, "repo": "davidliu-2706/2022-Test", "file": "src/main/java/frc/robot/commands/IndexBall.java", "last_update_at": "2021-11-10T21:09:19+00:00", "original_content": "public class IndexBall extends CommandBase {\n\n    FeederSubsystem feeder;\n\n    int targetPositon;\n\n    int incrementTicks;\n\n    boolean reversing;\n\n    boolean isDone;\n\n    boolean maxBalls;\n\n    boolean outputSwitchPressed;\n\n    private final boolean setTalonPosistionEveryCycle = true;\n\n    public IndexBall() {\n        feeder = FeederSubsystem.getInstance();\n        addRequirements(feeder);\n    }\n\n    // Called when the command is initially scheduled.\n    @Override\n    public void initialize() {\n        incrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();\n        int currentPosition = (int) feeder.getCurrentPosition();\n        targetPositon = currentPosition + incrementTicks;\n        reversing = false;\n        isDone = false;\n        if (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {\n            maxBalls = true;\n            this.cancel();\n            return;\n        } else if (FeederSubsystem.isBallAtOutput()) {\n            outputSwitchPressed = true;\n            this.cancel();\n            return;\n        }\n        maxBalls = false;\n        outputSwitchPressed = false;\n        feeder.setFeederPosistion(targetPositon);\n    }\n\n    // Called every time the scheduler runs while the command is scheduled.\n    @Override\n    public void execute() {\n        if (maxBalls == true) {\n            isDone = true;\n            return;\n        } else if (FeederSubsystem.isBallAtOutput()) {\n            outputSwitchPressed = true;\n            isDone = true;\n            return;\n        }\n        int currentPosition = (int) feeder.getCurrentPosition();\n        boolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);\n        int ticksChanged = currentPosition - (targetPositon - incrementTicks);\n        if (currentPosition >= targetPositon || atPosistion) {\n            isDone = true;\n        } else if (reversing) {\n            if (atPosistion) {\n                isDone = true;\n            } else if (setTalonPosistionEveryCycle) {\n                feeder.setFeederPosistion(targetPositon - incrementTicks);\n            }\n        } else if (setTalonPosistionEveryCycle) {\n            feeder.setFeederPosistion(targetPositon);\n        }\n    }\n\n    // Called once the command ends or is interrupted.\n    @Override\n    public void end(boolean interrupted) {\n        if (reversing == false && maxBalls == false && outputSwitchPressed == false) {\n            feeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);\n        }\n        if (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {\n            feeder.setFeederPosistion((int) feeder.getCurrentPosition());\n            feeder.stopFeeder();\n        }\n    }\n\n    // Returns true when the command should end.\n    @Override\n    public boolean isFinished() {\n        return isDone;\n    }\n}\n", "refactored": false}
{"hexsha": "f5cc2e0b1cbf8f1821a97d425e7f630fd91e4d34", "ext": "java", "lang": "Java", "content": "public abstract class ObjProperty extends AbstractParseTreeNode {\n\n    private static final long serialVersionUID = 3384973990326624609L;\n\n    public ObjProperty(StringLiteral name, Expression value) {\n        this(FilePosition.span(name.getFilePosition(), value.getFilePosition()), name, value);\n    }\n\n    public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {\n        super(pos, Expression.class);\n        this.createMutation().appendChild(name).appendChild(value).execute();\n    }\n\n    /**\n     * Provided for reflection.\n     * @param value unused\n     */\n    protected ObjProperty(FilePosition pos, Void value, List<? extends Expression> children) {\n        this(pos, (StringLiteral) children.get(0), children.get(1));\n        assert children.size() == 2;\n    }\n\n    @Override\n    public final Object getValue() {\n        return null;\n    }\n\n    @Override\n    public List<? extends Expression> children() {\n        return childrenAs(Expression.class);\n    }\n\n    public final StringLiteral getPropertyNameNode() {\n        return (StringLiteral) children().get(0);\n    }\n\n    @Override\n    public void childrenChanged() {\n        super.childrenChanged();\n        if (2 != children().size()) {\n            throw new IndexOutOfBoundsException();\n        }\n        getPropertyName();\n    }\n\n    public final String getPropertyName() {\n        return ((StringLiteral) children().get(0)).getUnquotedValue();\n    }\n\n    public boolean isPropertyNameQuoted() {\n        StringLiteral name = (StringLiteral) children().get(0);\n        String rawName = name.getValue();\n        if (rawName.length() == 0) {\n            return false;\n        }\n        char ch0 = rawName.charAt(0);\n        return ch0 == '\"' || ch0 == '\\'';\n    }\n\n    public final TokenConsumer makeRenderer(Appendable out, Callback<IOException> handler) {\n        return new JsPrettyPrinter(new Concatenator(out, handler));\n    }\n\n    protected final void renderPropertyName(RenderContext rc, boolean preferUnquoted) {\n        StringLiteral key = (StringLiteral) children().get(0);\n        TokenConsumer out = rc.getOut();\n        boolean unquoted = preferUnquoted;\n        switch(rc.propertyNameQuotingMode()) {\n            case NO_QUOTES:\n                unquoted = true;\n                break;\n            case PRESERVE_QUOTES:\n                String name = key.getValue();\n                if (name.length() == 0) {\n                    unquoted = true;\n                } else {\n                    char ch = name.charAt(0);\n                    if (ch != '\"' && ch != '\\'') {\n                        unquoted = true;\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n        if (unquoted || preferUnquoted) {\n            String uqVal = key.getUnquotedValue();\n            if (ParserBase.isJavascriptIdentifier(uqVal) && !(\"get\".equals(uqVal) || \"set\".equals(uqVal))) {\n                out.mark(key.getFilePosition());\n                out.consume(uqVal);\n                return;\n            }\n        }\n        key.render(rc);\n    }\n}\n", "class_id": 0, "repo": "michaelfig/caja", "file": "src/com/google/caja/parser/js/ObjProperty.java", "last_update_at": "2021-01-28T19:10:42+00:00", "original_content": "public abstract class ObjProperty extends AbstractParseTreeNode {\n\n    private static final long serialVersionUID = 3384973990326624609L;\n\n    public ObjProperty(StringLiteral name, Expression value) {\n        this(FilePosition.span(name.getFilePosition(), value.getFilePosition()), name, value);\n    }\n\n    public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {\n        super(pos, Expression.class);\n        this.createMutation().appendChild(name).appendChild(value).execute();\n    }\n\n    /**\n     * Provided for reflection.\n     * @param value unused\n     */\n    protected ObjProperty(FilePosition pos, Void value, List<? extends Expression> children) {\n        this(pos, (StringLiteral) children.get(0), children.get(1));\n        assert children.size() == 2;\n    }\n\n    @Override\n    public final Object getValue() {\n        return null;\n    }\n\n    @Override\n    public List<? extends Expression> children() {\n        return childrenAs(Expression.class);\n    }\n\n    public final StringLiteral getPropertyNameNode() {\n        return (StringLiteral) children().get(0);\n    }\n\n    @Override\n    public void childrenChanged() {\n        super.childrenChanged();\n        if (2 != children().size()) {\n            throw new IndexOutOfBoundsException();\n        }\n        getPropertyName();\n    }\n\n    public final String getPropertyName() {\n        return ((StringLiteral) children().get(0)).getUnquotedValue();\n    }\n\n    public boolean isPropertyNameQuoted() {\n        StringLiteral name = (StringLiteral) children().get(0);\n        String rawName = name.getValue();\n        if (rawName.length() == 0) {\n            return false;\n        }\n        char ch0 = rawName.charAt(0);\n        return ch0 == '\"' || ch0 == '\\'';\n    }\n\n    public final TokenConsumer makeRenderer(Appendable out, Callback<IOException> handler) {\n        return new JsPrettyPrinter(new Concatenator(out, handler));\n    }\n\n    protected final void renderPropertyName(RenderContext rc, boolean preferUnquoted) {\n        StringLiteral key = (StringLiteral) children().get(0);\n        TokenConsumer out = rc.getOut();\n        boolean unquoted = preferUnquoted;\n        switch(rc.propertyNameQuotingMode()) {\n            case NO_QUOTES:\n                unquoted = true;\n                break;\n            case PRESERVE_QUOTES:\n                String name = key.getValue();\n                if (name.length() == 0) {\n                    unquoted = true;\n                } else {\n                    char ch = name.charAt(0);\n                    if (ch != '\"' && ch != '\\'') {\n                        unquoted = true;\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n        if (unquoted || preferUnquoted) {\n            String uqVal = key.getUnquotedValue();\n            if (ParserBase.isJavascriptIdentifier(uqVal) && !(\"get\".equals(uqVal) || \"set\".equals(uqVal))) {\n                out.mark(key.getFilePosition());\n                out.consume(uqVal);\n                return;\n            }\n        }\n        key.render(rc);\n    }\n}\n", "refactored": false}
{"hexsha": "0edf3c02e23be62144e02ee6a86e492b3b1ef462", "ext": "java", "lang": "Java", "content": "public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {\n\n    private Spin spin;\n\n    public void setSpin(Spin spin) {\n        this.spin = spin;\n    }\n\n    @Override\n    public void apply(String pluginId) {\n        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);\n        plugin.apply(spin);\n        spin.getPluginContainer().addPlugin(pluginId, plugin);\n    }\n\n    @Override\n    public Object invokeMethod(String name, Object[] args) {\n        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {\n            Object result = tryInvokeMethod(plugin, name, args);\n            if (result != null) {\n                return result;\n            }\n        }\n        throw new NoMethodFoundException(name);\n    }\n}\n", "class_id": 0, "repo": "tianxunaicaoke/LogSpin", "file": "core/src/main/java/org/logSpin/script/DefaultScriptDelegate.java", "last_update_at": "2021-02-03T02:12:13+00:00", "original_content": "public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {\n\n    private Spin spin;\n\n    public void setSpin(Spin spin) {\n        this.spin = spin;\n    }\n\n    @Override\n    public void apply(String pluginId) {\n        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);\n        plugin.apply(spin);\n        spin.getPluginContainer().addPlugin(pluginId, plugin);\n    }\n\n    @Override\n    public Object invokeMethod(String name, Object[] args) {\n        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {\n            Object result = tryInvokeMethod(plugin, name, args);\n            if (result != null) {\n                return result;\n            }\n        }\n        throw new NoMethodFoundException(name);\n    }\n}\n", "refactored": false}
{"hexsha": "4c2bc8c459162886daf755bef05a05afec9240d5", "ext": "java", "lang": "Java", "content": "public class LinkCommand extends RemoteControlCommandBase implements Cloneable {\n\n    @Getter\n    private String repeaterCallsign;\n\n    @Getter\n    private ReconnectType reconnectType;\n\n    @Getter\n    private String reflectorCallsign;\n\n    public LinkCommand() {\n        super(RemoteControlCommandType.LINK);\n    }\n\n    @Override\n    public LinkCommand clone() {\n        LinkCommand copy = null;\n        copy = (LinkCommand) super.clone();\n        copy.repeaterCallsign = repeaterCallsign;\n        copy.reconnectType = reconnectType;\n        copy.reflectorCallsign = reflectorCallsign;\n        return copy;\n    }\n\n    @Override\n    protected String getHeader() {\n        return \"LNK\";\n    }\n\n    @Override\n    protected boolean parseCommand(ByteBuffer srcBuffer) {\n        int dataLength = DSTARDefines.CallsignFullLength + 4 + DSTARDefines.CallsignFullLength;\n        if (srcBuffer == null || srcBuffer.remaining() < dataLength)\n            return false;\n        char[] call = new char[DSTARDefines.CallsignFullLength];\n        int i = 0;\n        while (i < DSTARDefines.CallsignFullLength) try {\n            call[i] = (char) srcBuffer.get();\n        } finally {\n            i++;\n        }\n        repeaterCallsign = String.valueOf(call);\n        int reconnectTypeValue = 0;\n        int i = 0;\n        while (i < 4) try {\n            reconnectTypeValue <<= 8;\n            reconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();\n        } finally {\n            i++;\n        }\n        this.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);\n        int i = 0;\n        while (i < DSTARDefines.CallsignFullLength) try {\n            call[i] = (char) srcBuffer.get();\n        } finally {\n            i++;\n        }\n        reflectorCallsign = String.valueOf(call);\n        return true;\n    }\n\n    @Override\n    protected Optional<byte[]> assembleCommandInt() {\n        return Optional.empty();\n    }\n}\n", "class_id": 0, "repo": "jg1uaa/NoraSeries", "file": "src/NoraCommon/src/main/java/org/jp/illg/dstar/service/remotecontrol/model/command/LinkCommand.java", "last_update_at": "2021-05-03T04:39:05+00:00", "original_content": "public class LinkCommand extends RemoteControlCommandBase implements Cloneable {\n\n    @Getter\n    private String repeaterCallsign;\n\n    @Getter\n    private ReconnectType reconnectType;\n\n    @Getter\n    private String reflectorCallsign;\n\n    public LinkCommand() {\n        super(RemoteControlCommandType.LINK);\n    }\n\n    @Override\n    public LinkCommand clone() {\n        LinkCommand copy = null;\n        copy = (LinkCommand) super.clone();\n        copy.repeaterCallsign = repeaterCallsign;\n        copy.reconnectType = reconnectType;\n        copy.reflectorCallsign = reflectorCallsign;\n        return copy;\n    }\n\n    @Override\n    protected String getHeader() {\n        return \"LNK\";\n    }\n\n    @Override\n    protected boolean parseCommand(ByteBuffer srcBuffer) {\n        int dataLength = DSTARDefines.CallsignFullLength + 4 + DSTARDefines.CallsignFullLength;\n        if (srcBuffer == null || srcBuffer.remaining() < dataLength)\n            return false;\n        char[] call = new char[DSTARDefines.CallsignFullLength];\n        for (int i = 0; i < DSTARDefines.CallsignFullLength; i++) call[i] = (char) srcBuffer.get();\n        repeaterCallsign = String.valueOf(call);\n        int reconnectTypeValue = 0;\n        for (int i = 0; i < 4; i++) {\n            reconnectTypeValue <<= 8;\n            reconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();\n        }\n        this.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);\n        for (int i = 0; i < DSTARDefines.CallsignFullLength; i++) call[i] = (char) srcBuffer.get();\n        reflectorCallsign = String.valueOf(call);\n        return true;\n    }\n\n    @Override\n    protected Optional<byte[]> assembleCommandInt() {\n        return Optional.empty();\n    }\n}\n", "refactored": true}
{"hexsha": "028d0eb48fa34b8302e7d54fb8e8862b7ef0b42c", "ext": "java", "lang": "Java", "content": "public class CustomError {\n\n    private final Logger logger;\n\n    private boolean some_enabled = false;\n\n    // Options\n    private boolean escalate_exceptions = false;\n\n    private boolean equal_is_strict_equal = false;\n\n    private boolean enforce_existing_properties = false;\n\n    private boolean boolean_op_only_boolean_operands = false;\n\n    private boolean arith_op_no_undefined = false;\n\n    private boolean arith_op_no_null = false;\n\n    private boolean arith_op_no_nan = false;\n\n    private boolean arith_op_no_infinity = false;\n\n    private boolean division_op_no_zero = false;\n\n    public CustomError(Logger lgr) {\n        this.logger = lgr;\n    }\n\n    /**\n     * Set an option for this instance.\n     *\n     * @param name Name of the option\n     * @param value Option value\n     */\n    public void setOption(String name, Object value) {\n        try {\n            switch(name) {\n                case \"escalate_exceptions\":\n                    escalate_exceptions = (boolean) value;\n                    logSetOption(name, escalate_exceptions);\n                    break;\n                case \"equal_is_strict_equal\":\n                    equal_is_strict_equal = (boolean) value;\n                    logSetOption(name, equal_is_strict_equal);\n                    break;\n                case \"enforce_existing_properties\":\n                    enforce_existing_properties = (boolean) value;\n                    logSetOption(name, enforce_existing_properties);\n                    break;\n                case \"boolean_op_only_boolean_operands\":\n                    boolean_op_only_boolean_operands = (boolean) value;\n                    logSetOption(name, boolean_op_only_boolean_operands);\n                    break;\n                case \"arith_op_no_undefined\":\n                    arith_op_no_undefined = (boolean) value;\n                    logSetOption(name, arith_op_no_undefined);\n                    break;\n                case \"arith_op_no_null\":\n                    arith_op_no_null = (boolean) value;\n                    logSetOption(name, arith_op_no_null);\n                    break;\n                case \"arith_op_no_nan\":\n                    arith_op_no_nan = (boolean) value;\n                    logSetOption(name, arith_op_no_nan);\n                    break;\n                case \"arith_op_no_infinity\":\n                    arith_op_no_infinity = (boolean) value;\n                    logSetOption(name, arith_op_no_infinity);\n                    break;\n                case \"division_op_no_zero\":\n                    division_op_no_zero = (boolean) value;\n                    logSetOption(name, division_op_no_zero);\n                    break;\n                default:\n                    logger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n            }\n        } catch (ClassCastException cce) {\n            logger.warning(\"CustomError: Cannot cast value for option '\" + name + \"'\");\n        }\n        recalculateSomeEnabled();\n    }\n\n    private void logSetOption(String name, boolean enabled) {\n        if (enabled) {\n            logger.info(\"Custom error class '\" + name + \"' enabled\");\n        } else {\n            logger.info(\"Custom error class '\" + name + \"' disabled\");\n        }\n    }\n\n    /**\n     * Get an option value from the instance.\n     *\n     * @param name Name of the option\n     * @return Option value\n     */\n    public Object getOption(String name) {\n        switch(name) {\n            case \"escalate_exceptions\":\n                return this.escalate_exceptions;\n            case \"equal_is_strict_equal\":\n                return this.equal_is_strict_equal;\n            case \"enforce_existing_properties\":\n                return this.enforce_existing_properties;\n            case \"boolean_op_only_boolean_operands\":\n                return this.boolean_op_only_boolean_operands;\n            case \"arith_op_no_undefined\":\n                return this.arith_op_no_undefined;\n            case \"arith_op_no_null\":\n                return this.arith_op_no_null;\n            case \"arith_op_no_nan\":\n                return this.arith_op_no_nan;\n            case \"arith_op_no_infinity\":\n                return this.arith_op_no_infinity;\n            case \"division_op_no_zero\":\n                return this.division_op_no_zero;\n            default:\n                logger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n                return null;\n        }\n    }\n\n    /**\n     * Check if at least one option is enabled.\n     *\n     * @return true, if at least one custom error class is enabled\n     */\n    public boolean someEnabled() {\n        return this.some_enabled;\n    }\n\n    /**\n     * Recalculate if at least one option is enabled.\n     */\n    private void recalculateSomeEnabled() {\n        this.some_enabled = this.escalate_exceptions || this.equal_is_strict_equal || this.enforce_existing_properties || this.boolean_op_only_boolean_operands || this.arith_op_no_undefined || this.arith_op_no_null || this.arith_op_no_nan || this.arith_op_no_infinity || this.division_op_no_zero;\n    }\n\n    /**\n     * Enable an error class, shorthand for {@link #setOption(String, Object)}.\n     *\n     * @param type Name of the error class\n     */\n    public void enable(String type) {\n        setOption(type, true);\n    }\n\n    /**\n     * Disable an error class, shorthand for {@link #setOption(String, Object)}.\n     *\n     * @param type Name of the error class\n     */\n    public void disable(String type) {\n        setOption(type, false);\n    }\n\n    /**\n     * Central method for inspecting values and firing an {@link EscalatedException}\n     * depending on the return value.\n     *\n     * @param operation_name Operation name\n     * @param value Value of the value...\n     * @param line_num Line number for logging\n     */\n    public void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {\n        switch(operation_name) {\n            case \"JSDivideNodeGen\":\n                inspectDivisionZero(operation_name, value, input_index, line_num);\n            // no break, division is also arithmetic operation\n            case \"JSAddNodeGen\":\n            case \"JSSubtractNodeGen\":\n            case \"JSMultiplyNodeGen\":\n            case \"JSUnaryMinusNodeGen\":\n            case \"JSUnaryPlusNodeGen\":\n            case \"JSModuloNodeGen\":\n            case \"JSAddSubNumericUnitNodeGen\":\n            case \"SqrtNodeGen\":\n            case \"JSExponentiateNodeGen\":\n                inspectArithmeticValues(operation_name, value, line_num);\n                break;\n            case \"JSAndNode\":\n            case \"JSOrNode\":\n            case \"JSNotNodeGen\":\n                if (boolean_op_only_boolean_operands) {\n                    if (!JSGuards.isBoolean(value)) {\n                        logger.info(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands)\");\n                        throw new EscalatedException(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands). [\" + operation_name + \", line \" + line_num + \"]\");\n                    }\n                }\n                break;\n        }\n    }\n\n    private void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {\n        if (division_op_no_zero && input_index == 1) {\n            Object num = JSRuntime.toNumeric(value);\n            if (num instanceof BigInt) {\n                BigInt bigint_num = (BigInt) num;\n                if (bigint_num.equals(BigInt.ZERO)) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else if (num instanceof Integer) {\n                Integer int_num = (Integer) num;\n                if (int_num.equals(0)) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else if (num instanceof SafeInteger) {\n                SafeInteger safeint_num = (SafeInteger) num;\n                if (safeint_num.intValue() == 0) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else if (num instanceof Double) {\n                Double double_num = (Double) num;\n                if (double_num.equals(0.0)) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else {\n                logger.warning(\"CustomError::inspect(): Unexpected value \" + num.toString());\n            }\n        }\n    }\n\n    /**\n     * Central method for inspecting values and firing an {@link EscalatedException}\n     * depending on the return value.\n     *\n     * @param operation_name Operation name\n     * @param value Value of the value...\n     * @param line_num Line number for logging\n     */\n    public void inspectReturnValue(String operation_name, Object value, int line_num) {\n        switch(operation_name) {\n            case \"JSDivideNodeGen\":\n            case \"JSAddNodeGen\":\n            case \"JSSubtractNodeGen\":\n            case \"JSMultiplyNodeGen\":\n            case \"JSUnaryMinusNodeGen\":\n            case \"JSUnaryPlusNodeGen\":\n            case \"JSModuloNodeGen\":\n            case \"JSAddSubNumericUnitNodeGen\":\n            case \"SqrtNodeGen\":\n            case \"JSExponentiateNodeGen\":\n                inspectArithmeticValues(operation_name, value, line_num);\n                break;\n        }\n    }\n\n    private void inspectArithmeticValues(String operation_name, Object value, int line_num) {\n        if (arith_op_no_undefined) {\n            if (JSGuards.isUndefined(value)) {\n                logger.info(\"Detected undefined value for arithmetic operation (arith_op_no_undefined)\");\n                throw new EscalatedException(\"Detected undefined value for arithmetic operation (arith_op_no_undefined). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n        if (arith_op_no_null) {\n            //if (JSGuards.isJSNull(value)) { //TODO does not work\n            if (value.toString().startsWith(\"DynamicObject<null>\")) {\n                logger.info(\"Detected null value for arithmetic operation (arith_op_no_null)\");\n                throw new EscalatedException(\"Detected null value for arithmetic operation (arith_op_no_null). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n        if (arith_op_no_nan) {\n            if (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {\n                logger.info(\"Detected NaN value for arithmetic operation (arith_op_no_nan)\");\n                throw new EscalatedException(\"Detected NaN value for arithmetic operation (arith_op_no_nan). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n        if (arith_op_no_infinity) {\n            if (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {\n                logger.info(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity)\");\n                throw new EscalatedException(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n    }\n\n    /**\n     * @return Value of option \"escalate_exceptions\"\n     */\n    public boolean escalateExceptionsEnabled() {\n        return escalate_exceptions;\n    }\n\n    /**\n     * @return Value of option \"equal_is_strict_equal\"\n     */\n    public boolean equalIsStrictEqualEnabled() {\n        return equal_is_strict_equal;\n    }\n\n    /**\n     * @return Value of option \"enforce_existing_properties\"\n     */\n    public boolean enforceExistingPropertiesEnabled() {\n        return enforce_existing_properties;\n    }\n\n    /**\n     * Create a new Exception that cannot be caught.\n     *\n     * @param message Message of the exception\n     * @return Exception of type \"EscalatedException\"\n     */\n    public static EscalatedException createException(String message) {\n        return new EscalatedException(message);\n    }\n\n    /**\n     * This class should be used whenever an error occurs in the programs execution.\n     * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)\n     * will be caught by a try-catch-statement in the guest language source code.\n     * This exception extends RuntimeException directly and therefore will not be caught\n     * by any safety measures in the guest language. It can only be caught by the Fuzzer\n     * itself.\n     */\n    public static class EscalatedException extends RuntimeException {\n\n        public EscalatedException() {\n            super();\n        }\n\n        public EscalatedException(String message) {\n            super(message);\n        }\n\n        public EscalatedException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        public EscalatedException(Throwable cause) {\n            super(cause);\n        }\n\n        protected EscalatedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n            super(message, cause, enableSuppression, writableStackTrace);\n        }\n    }\n}\n", "class_id": 0, "repo": "rdelhougne/GraalFuzzing", "file": "fuzzingtool/core/src/main/java/org/fuzzingtool/core/components/CustomError.java", "last_update_at": "2021-04-13T15:48:38+00:00", "original_content": "public class CustomError {\n\n    private final Logger logger;\n\n    private boolean some_enabled = false;\n\n    // Options\n    private boolean escalate_exceptions = false;\n\n    private boolean equal_is_strict_equal = false;\n\n    private boolean enforce_existing_properties = false;\n\n    private boolean boolean_op_only_boolean_operands = false;\n\n    private boolean arith_op_no_undefined = false;\n\n    private boolean arith_op_no_null = false;\n\n    private boolean arith_op_no_nan = false;\n\n    private boolean arith_op_no_infinity = false;\n\n    private boolean division_op_no_zero = false;\n\n    public CustomError(Logger lgr) {\n        this.logger = lgr;\n    }\n\n    /**\n     * Set an option for this instance.\n     *\n     * @param name Name of the option\n     * @param value Option value\n     */\n    public void setOption(String name, Object value) {\n        try {\n            switch(name) {\n                case \"escalate_exceptions\":\n                    escalate_exceptions = (boolean) value;\n                    logSetOption(name, escalate_exceptions);\n                    break;\n                case \"equal_is_strict_equal\":\n                    equal_is_strict_equal = (boolean) value;\n                    logSetOption(name, equal_is_strict_equal);\n                    break;\n                case \"enforce_existing_properties\":\n                    enforce_existing_properties = (boolean) value;\n                    logSetOption(name, enforce_existing_properties);\n                    break;\n                case \"boolean_op_only_boolean_operands\":\n                    boolean_op_only_boolean_operands = (boolean) value;\n                    logSetOption(name, boolean_op_only_boolean_operands);\n                    break;\n                case \"arith_op_no_undefined\":\n                    arith_op_no_undefined = (boolean) value;\n                    logSetOption(name, arith_op_no_undefined);\n                    break;\n                case \"arith_op_no_null\":\n                    arith_op_no_null = (boolean) value;\n                    logSetOption(name, arith_op_no_null);\n                    break;\n                case \"arith_op_no_nan\":\n                    arith_op_no_nan = (boolean) value;\n                    logSetOption(name, arith_op_no_nan);\n                    break;\n                case \"arith_op_no_infinity\":\n                    arith_op_no_infinity = (boolean) value;\n                    logSetOption(name, arith_op_no_infinity);\n                    break;\n                case \"division_op_no_zero\":\n                    division_op_no_zero = (boolean) value;\n                    logSetOption(name, division_op_no_zero);\n                    break;\n                default:\n                    logger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n            }\n        } catch (ClassCastException cce) {\n            logger.warning(\"CustomError: Cannot cast value for option '\" + name + \"'\");\n        }\n        recalculateSomeEnabled();\n    }\n\n    private void logSetOption(String name, boolean enabled) {\n        if (enabled) {\n            logger.info(\"Custom error class '\" + name + \"' enabled\");\n        } else {\n            logger.info(\"Custom error class '\" + name + \"' disabled\");\n        }\n    }\n\n    /**\n     * Get an option value from the instance.\n     *\n     * @param name Name of the option\n     * @return Option value\n     */\n    public Object getOption(String name) {\n        switch(name) {\n            case \"escalate_exceptions\":\n                return this.escalate_exceptions;\n            case \"equal_is_strict_equal\":\n                return this.equal_is_strict_equal;\n            case \"enforce_existing_properties\":\n                return this.enforce_existing_properties;\n            case \"boolean_op_only_boolean_operands\":\n                return this.boolean_op_only_boolean_operands;\n            case \"arith_op_no_undefined\":\n                return this.arith_op_no_undefined;\n            case \"arith_op_no_null\":\n                return this.arith_op_no_null;\n            case \"arith_op_no_nan\":\n                return this.arith_op_no_nan;\n            case \"arith_op_no_infinity\":\n                return this.arith_op_no_infinity;\n            case \"division_op_no_zero\":\n                return this.division_op_no_zero;\n            default:\n                logger.warning(\"CustomError: Unknown option '\" + name + \"'\");\n                return null;\n        }\n    }\n\n    /**\n     * Check if at least one option is enabled.\n     *\n     * @return true, if at least one custom error class is enabled\n     */\n    public boolean someEnabled() {\n        return this.some_enabled;\n    }\n\n    /**\n     * Recalculate if at least one option is enabled.\n     */\n    private void recalculateSomeEnabled() {\n        this.some_enabled = this.escalate_exceptions || this.equal_is_strict_equal || this.enforce_existing_properties || this.boolean_op_only_boolean_operands || this.arith_op_no_undefined || this.arith_op_no_null || this.arith_op_no_nan || this.arith_op_no_infinity || this.division_op_no_zero;\n    }\n\n    /**\n     * Enable an error class, shorthand for {@link #setOption(String, Object)}.\n     *\n     * @param type Name of the error class\n     */\n    public void enable(String type) {\n        setOption(type, true);\n    }\n\n    /**\n     * Disable an error class, shorthand for {@link #setOption(String, Object)}.\n     *\n     * @param type Name of the error class\n     */\n    public void disable(String type) {\n        setOption(type, false);\n    }\n\n    /**\n     * Central method for inspecting values and firing an {@link EscalatedException}\n     * depending on the return value.\n     *\n     * @param operation_name Operation name\n     * @param value Value of the value...\n     * @param line_num Line number for logging\n     */\n    public void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {\n        switch(operation_name) {\n            case \"JSDivideNodeGen\":\n                inspectDivisionZero(operation_name, value, input_index, line_num);\n            // no break, division is also arithmetic operation\n            case \"JSAddNodeGen\":\n            case \"JSSubtractNodeGen\":\n            case \"JSMultiplyNodeGen\":\n            case \"JSUnaryMinusNodeGen\":\n            case \"JSUnaryPlusNodeGen\":\n            case \"JSModuloNodeGen\":\n            case \"JSAddSubNumericUnitNodeGen\":\n            case \"SqrtNodeGen\":\n            case \"JSExponentiateNodeGen\":\n                inspectArithmeticValues(operation_name, value, line_num);\n                break;\n            case \"JSAndNode\":\n            case \"JSOrNode\":\n            case \"JSNotNodeGen\":\n                if (boolean_op_only_boolean_operands) {\n                    if (!JSGuards.isBoolean(value)) {\n                        logger.info(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands)\");\n                        throw new EscalatedException(\"Object of type '\" + value.toString() + \"' for boolean operation detected (boolean_op_only_boolean_operands). [\" + operation_name + \", line \" + line_num + \"]\");\n                    }\n                }\n                break;\n        }\n    }\n\n    private void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {\n        if (division_op_no_zero && input_index == 1) {\n            Object num = JSRuntime.toNumeric(value);\n            if (num instanceof BigInt) {\n                BigInt bigint_num = (BigInt) num;\n                if (bigint_num.equals(BigInt.ZERO)) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else if (num instanceof Integer) {\n                Integer int_num = (Integer) num;\n                if (int_num.equals(0)) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else if (num instanceof SafeInteger) {\n                SafeInteger safeint_num = (SafeInteger) num;\n                if (safeint_num.intValue() == 0) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else if (num instanceof Double) {\n                Double double_num = (Double) num;\n                if (double_num.equals(0.0)) {\n                    logger.info(\"Detected zero value for division operation (division_op_no_zero)\");\n                    throw new EscalatedException(\"Detected zero value for division operation (division_op_no_zero). [\" + operation_name + \", line \" + line_num + \"]\");\n                }\n            } else {\n                logger.warning(\"CustomError::inspect(): Unexpected value \" + num.toString());\n            }\n        }\n    }\n\n    /**\n     * Central method for inspecting values and firing an {@link EscalatedException}\n     * depending on the return value.\n     *\n     * @param operation_name Operation name\n     * @param value Value of the value...\n     * @param line_num Line number for logging\n     */\n    public void inspectReturnValue(String operation_name, Object value, int line_num) {\n        switch(operation_name) {\n            case \"JSDivideNodeGen\":\n            case \"JSAddNodeGen\":\n            case \"JSSubtractNodeGen\":\n            case \"JSMultiplyNodeGen\":\n            case \"JSUnaryMinusNodeGen\":\n            case \"JSUnaryPlusNodeGen\":\n            case \"JSModuloNodeGen\":\n            case \"JSAddSubNumericUnitNodeGen\":\n            case \"SqrtNodeGen\":\n            case \"JSExponentiateNodeGen\":\n                inspectArithmeticValues(operation_name, value, line_num);\n                break;\n        }\n    }\n\n    private void inspectArithmeticValues(String operation_name, Object value, int line_num) {\n        if (arith_op_no_undefined) {\n            if (JSGuards.isUndefined(value)) {\n                logger.info(\"Detected undefined value for arithmetic operation (arith_op_no_undefined)\");\n                throw new EscalatedException(\"Detected undefined value for arithmetic operation (arith_op_no_undefined). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n        if (arith_op_no_null) {\n            //if (JSGuards.isJSNull(value)) { //TODO does not work\n            if (value.toString().startsWith(\"DynamicObject<null>\")) {\n                logger.info(\"Detected null value for arithmetic operation (arith_op_no_null)\");\n                throw new EscalatedException(\"Detected null value for arithmetic operation (arith_op_no_null). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n        if (arith_op_no_nan) {\n            if (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {\n                logger.info(\"Detected NaN value for arithmetic operation (arith_op_no_nan)\");\n                throw new EscalatedException(\"Detected NaN value for arithmetic operation (arith_op_no_nan). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n        if (arith_op_no_infinity) {\n            if (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {\n                logger.info(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity)\");\n                throw new EscalatedException(\"Detected Infinity value for arithmetic operation (arith_op_no_infinity). [\" + operation_name + \", line \" + line_num + \"]\");\n            }\n        }\n    }\n\n    /**\n     * @return Value of option \"escalate_exceptions\"\n     */\n    public boolean escalateExceptionsEnabled() {\n        return escalate_exceptions;\n    }\n\n    /**\n     * @return Value of option \"equal_is_strict_equal\"\n     */\n    public boolean equalIsStrictEqualEnabled() {\n        return equal_is_strict_equal;\n    }\n\n    /**\n     * @return Value of option \"enforce_existing_properties\"\n     */\n    public boolean enforceExistingPropertiesEnabled() {\n        return enforce_existing_properties;\n    }\n\n    /**\n     * Create a new Exception that cannot be caught.\n     *\n     * @param message Message of the exception\n     * @return Exception of type \"EscalatedException\"\n     */\n    public static EscalatedException createException(String message) {\n        return new EscalatedException(message);\n    }\n\n    /**\n     * This class should be used whenever an error occurs in the programs execution.\n     * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)\n     * will be caught by a try-catch-statement in the guest language source code.\n     * This exception extends RuntimeException directly and therefore will not be caught\n     * by any safety measures in the guest language. It can only be caught by the Fuzzer\n     * itself.\n     */\n    public static class EscalatedException extends RuntimeException {\n\n        public EscalatedException() {\n            super();\n        }\n\n        public EscalatedException(String message) {\n            super(message);\n        }\n\n        public EscalatedException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        public EscalatedException(Throwable cause) {\n            super(cause);\n        }\n\n        protected EscalatedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\n            super(message, cause, enableSuppression, writableStackTrace);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "63f006d75c343e11e3056f238b16a9c53c97186d", "ext": "java", "lang": "Java", "content": "public class Bounds {\n\n    /**\n     * The position of something.\n     */\n    private final Position position;\n\n    /**\n     * The size of something.\n     */\n    private final Size size;\n\n    public Bounds(Position position, Size size) {\n        this.position = position;\n        this.size = size;\n    }\n\n    /**\n     * Get the position.\n     *\n     * @return position\n     */\n    public Position getPosition() {\n        return position;\n    }\n\n    /**\n     * Get the size.\n     *\n     * @return size\n     */\n    public Size getSize() {\n        return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Bounds bounds = (Bounds) o;\n        if (position != null ? !position.equals(bounds.position) : bounds.position != null)\n            return false;\n        return size != null ? size.equals(bounds.size) : bounds.size == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = position != null ? position.hashCode() : 0;\n        result = 31 * result + (size != null ? size.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s at %s\", getSize().toString(), getPosition().toString());\n    }\n}\n", "class_id": 0, "repo": "badalsarkar/thaw", "file": "util/src/main/java/de/be/thaw/util/Bounds.java", "last_update_at": "2021-12-11T18:05:30+00:00", "original_content": "public class Bounds {\n\n    /**\n     * The position of something.\n     */\n    private final Position position;\n\n    /**\n     * The size of something.\n     */\n    private final Size size;\n\n    public Bounds(Position position, Size size) {\n        this.position = position;\n        this.size = size;\n    }\n\n    /**\n     * Get the position.\n     *\n     * @return position\n     */\n    public Position getPosition() {\n        return position;\n    }\n\n    /**\n     * Get the size.\n     *\n     * @return size\n     */\n    public Size getSize() {\n        return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Bounds bounds = (Bounds) o;\n        if (position != null ? !position.equals(bounds.position) : bounds.position != null)\n            return false;\n        return size != null ? size.equals(bounds.size) : bounds.size == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = position != null ? position.hashCode() : 0;\n        result = 31 * result + (size != null ? size.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s at %s\", getSize().toString(), getPosition().toString());\n    }\n}\n", "refactored": false}
{"hexsha": "24e81dc3f9999e7393ee6e867168fcebaedb04ae", "ext": "java", "lang": "Java", "content": "public class RefeedActionsTest {\n\n    private String toString(RefeedActions.Entry entry) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(entry.getDocumentType() + \".\" + entry.getClusterName() + \":\");\n        builder.append(entry.getServices().stream().map(ServiceInfo::getServiceName).sorted().collect(Collectors.joining(\",\", \"[\", \"]\")));\n        builder.append(entry.getMessages().stream().collect(Collectors.joining(\",\", \"[\", \"]\")));\n        return builder.toString();\n    }\n\n    @Test\n    public void action_with_multiple_reasons() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz][change,other change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_services() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz,qux][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_document_types() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"book.foo:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_clusters() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"music.bar:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n}\n", "class_id": 0, "repo": "gsmcwhirter/vespa", "file": "configserver/src/test/java/com/yahoo/vespa/config/server/configchange/RefeedActionsTest.java", "last_update_at": "2021-01-11T18:37:46+00:00", "original_content": "public class RefeedActionsTest {\n\n    private String toString(RefeedActions.Entry entry) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(entry.getDocumentType() + \".\" + entry.getClusterName() + \":\");\n        builder.append(entry.getServices().stream().map(ServiceInfo::getServiceName).sorted().collect(Collectors.joining(\",\", \"[\", \"]\")));\n        builder.append(entry.getMessages().stream().collect(Collectors.joining(\",\", \"[\", \"]\")));\n        return builder.toString();\n    }\n\n    @Test\n    public void action_with_multiple_reasons() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz][change,other change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_services() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(1));\n        assertThat(toString(entries.get(0)), equalTo(\"music.foo:[baz,qux][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_document_types() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"book.foo:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n\n    @Test\n    public void actions_with_multiple_clusters() {\n        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).build().getRefeedActions().getEntries();\n        assertThat(entries.size(), is(2));\n        assertThat(toString(entries.get(0)), equalTo(\"music.bar:[baz][change]\"));\n        assertThat(toString(entries.get(1)), equalTo(\"music.foo:[baz][change]\"));\n    }\n}\n", "refactored": false}
{"hexsha": "3377317aa98200f51a48ce521cfc82e23fc73437", "ext": "java", "lang": "Java", "content": "public class DeleteObject extends CliCommand<DefaultResult> {\n\n    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);\n\n    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);\n\n    private String bucketName;\n\n    private String objectName;\n\n    private String versionId;\n\n    private boolean allVersions;\n\n    public DeleteObject() {\n    }\n\n    @Override\n    public CliCommand init(final Arguments args) throws Exception {\n        processCommandOptions(requiredArgs, optionalArgs, args);\n        this.bucketName = args.getBucket();\n        this.objectName = args.getObjectName();\n        this.versionId = args.getVersionId();\n        this.allVersions = args.isAllVersions();\n        return this;\n    }\n\n    @Override\n    public DefaultResult call() throws Exception {\n        if (allVersions) {\n            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request().withName(objectName).withBucketId(bucketName);\n            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);\n            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {\n                deleteObject(bucketName, objectName, objectVersion.getId());\n            }\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' and all of it's versions from bucket '\" + this.bucketName + \"'.\");\n        } else {\n            final UUID version;\n            if (versionId != null) {\n                version = UUID.fromString(versionId);\n            } else {\n                version = null;\n            }\n            deleteObject(bucketName, objectName, version);\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' from bucket '\" + this.bucketName + \"'.\");\n        }\n    }\n\n    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {\n        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);\n        if (version != null) {\n            deleteObjectRequest.withVersionId(version);\n        }\n        getClient().deleteObject(deleteObjectRequest);\n    }\n}\n", "class_id": 0, "repo": "RachelTucker/ds3_java_cli", "file": "ds3_java_cli/src/main/java/com/spectralogic/ds3cli/command/DeleteObject.java", "last_update_at": "2021-09-19T19:50:11+00:00", "original_content": "public class DeleteObject extends CliCommand<DefaultResult> {\n\n    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);\n\n    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);\n\n    private String bucketName;\n\n    private String objectName;\n\n    private String versionId;\n\n    private boolean allVersions;\n\n    public DeleteObject() {\n    }\n\n    @Override\n    public CliCommand init(final Arguments args) throws Exception {\n        processCommandOptions(requiredArgs, optionalArgs, args);\n        this.bucketName = args.getBucket();\n        this.objectName = args.getObjectName();\n        this.versionId = args.getVersionId();\n        this.allVersions = args.isAllVersions();\n        return this;\n    }\n\n    @Override\n    public DefaultResult call() throws Exception {\n        if (allVersions) {\n            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request().withName(objectName).withBucketId(bucketName);\n            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);\n            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {\n                deleteObject(bucketName, objectName, objectVersion.getId());\n            }\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' and all of it's versions from bucket '\" + this.bucketName + \"'.\");\n        } else {\n            final UUID version;\n            if (versionId != null) {\n                version = UUID.fromString(versionId);\n            } else {\n                version = null;\n            }\n            deleteObject(bucketName, objectName, version);\n            return new DefaultResult(\"Success: Deleted object '\" + this.objectName + \"' from bucket '\" + this.bucketName + \"'.\");\n        }\n    }\n\n    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {\n        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);\n        if (version != null) {\n            deleteObjectRequest.withVersionId(version);\n        }\n        getClient().deleteObject(deleteObjectRequest);\n    }\n}\n", "refactored": false}
{"hexsha": "4e80fb61037a20340836b0ea84f7505d3b249026", "ext": "java", "lang": "Java", "content": "public class Perspective {\n\n    public static final int LOCAL_COORD_BITS = 7;\n\n    public static final int LOCAL_HALF_TILE_SIZE = 64;\n\n    public static final int LOCAL_TILE_SIZE = 128;\n\n    public static final int SCENE_SIZE = 104;\n\n    public static final double UNIT = Math.PI / 1024d;\n\n    // sine angles for each of the 2048 units, * 65536 and stored as an int\n    public static final int[] SINE = new int[2048];\n\n    // cosine\n    public static final int[] COSINE = new int[2048];\n\n    static {\n        int i = 0;\n        while (i < 2048) try {\n            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n        } finally {\n            ++i;\n        }\n    }\n\n    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {\n        if (string == null) {\n            return null;\n        }\n        Point p = Perspective.localToCanvas(client, localPoint, plane, n);\n        if (p == null) {\n            return null;\n        } else {\n            Log.e(\"Perspective\", p.toString());\n        }\n        return new Point(p.getX(), p.getY());\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {\n        int n3 = client.getPlane();\n        int n4 = localPoint.getX() - n * 128 / 2;\n        int n5 = localPoint.getY() - n * 128 / 2;\n        int n6 = localPoint.getX() + n * 128 / 2;\n        int n7 = localPoint.getY() + n * 128 / 2;\n        byte[][][] tileSettings = client.getTileSettings();\n        int n8 = localPoint.getSceneX();\n        int n9 = localPoint.getSceneY();\n        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {\n            int n10;\n            n = n10 = n3;\n            if (n3 < 3) {\n                n = n10;\n                if ((tileSettings[1][n8][n9] & 2) == 2) {\n                    n = n3 + 1;\n                }\n            }\n            n10 = Perspective.getHeight(client, n4, n5, n);\n            n8 = Perspective.getHeight(client, n6, n5, n);\n            n3 = Perspective.getHeight(client, n6, n7, n);\n            n = Perspective.getHeight(client, n4, n7, n);\n            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);\n            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);\n            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);\n            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);\n            if (p1 != null && p2 != null && p3 != null && p4 != null) {\n                Path path = new Path();\n                path.moveTo((float) ((Point) p1).getX(), (float) ((Point) p1).getY());\n                path.lineTo((float) ((Point) p2).getX(), (float) ((Point) p2).getY());\n                path.lineTo((float) p3.getX(), (float) p3.getY());\n                path.lineTo((float) ((Point) p4).getX(), (float) ((Point) p4).getY());\n                return path;\n            }\n            return null;\n        }\n        return null;\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);\n    }\n\n    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane) {\n        int sceneX = localX >> LOCAL_COORD_BITS;\n        int sceneY = localY >> LOCAL_COORD_BITS;\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {\n            int[][][] tileHeights = client.getTileHeights();\n            int x = localX & (LOCAL_TILE_SIZE - 1);\n            int y = localY & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n\n    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {\n        int sceneX = point.getSceneX();\n        int sceneY = point.getSceneY();\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {\n            byte[][][] tileSettings = client.getTileSettings();\n            int[][][] tileHeights = client.getTileHeights();\n            if (plane < 0)\n                plane = 0;\n            int z1 = plane;\n            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE) {\n                z1 = plane + 1;\n            }\n            int x = point.getX() & (LOCAL_TILE_SIZE - 1);\n            int y = point.getY() & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n\n    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z) {\n        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056) {\n            x -= client.getCameraX();\n            y -= client.getCameraY();\n            z -= client.getCameraZ();\n            int cameraPitch = client.getCameraPitch();\n            int cameraYaw = client.getCameraYaw();\n            int pitchSin = SINE[cameraPitch];\n            int pitchCos = COSINE[cameraPitch];\n            int yawSin = SINE[cameraYaw];\n            int yawCos = COSINE[cameraYaw];\n            int var8 = yawCos * x + y * yawSin >> 16;\n            y = yawCos * y - yawSin * x >> 16;\n            x = var8;\n            var8 = pitchCos * z - y * pitchSin >> 16;\n            y = z * pitchSin + y * pitchCos >> 16;\n            if (y >= 50) {\n                Log.e(\"Points\", \"x:\" + x + \" y:\" + y);\n                double pointX = (double) (client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double) client.getOverlayWidth() / (double) client.getViewportWidth();\n                double pointY = (double) (client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double) client.getOverlayWidth() / (double) client.getViewportWidth();\n                return new Point((int) pointX, (int) pointY);\n            }\n        }\n        return null;\n    }\n\n    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {\n        n = Perspective.getTileHeight(clientAPI, localPoint, n);\n        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);\n    }\n}\n", "class_id": 0, "repo": "Soxs/openosrs-mobile", "file": "runelite-api/src/main/java/net/runelite/api/Perspective.java", "last_update_at": "2021-11-19T15:28:42+00:00", "original_content": "public class Perspective {\n\n    public static final int LOCAL_COORD_BITS = 7;\n\n    public static final int LOCAL_HALF_TILE_SIZE = 64;\n\n    public static final int LOCAL_TILE_SIZE = 128;\n\n    public static final int SCENE_SIZE = 104;\n\n    public static final double UNIT = Math.PI / 1024d;\n\n    // sine angles for each of the 2048 units, * 65536 and stored as an int\n    public static final int[] SINE = new int[2048];\n\n    // cosine\n    public static final int[] COSINE = new int[2048];\n\n    static {\n        for (int i = 0; i < 2048; ++i) {\n            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n        }\n    }\n\n    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {\n        if (string == null) {\n            return null;\n        }\n        Point p = Perspective.localToCanvas(client, localPoint, plane, n);\n        if (p == null) {\n            return null;\n        } else {\n            Log.e(\"Perspective\", p.toString());\n        }\n        return new Point(p.getX(), p.getY());\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);\n    }\n\n    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {\n        int n3 = client.getPlane();\n        int n4 = localPoint.getX() - n * 128 / 2;\n        int n5 = localPoint.getY() - n * 128 / 2;\n        int n6 = localPoint.getX() + n * 128 / 2;\n        int n7 = localPoint.getY() + n * 128 / 2;\n        byte[][][] tileSettings = client.getTileSettings();\n        int n8 = localPoint.getSceneX();\n        int n9 = localPoint.getSceneY();\n        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {\n            int n10;\n            n = n10 = n3;\n            if (n3 < 3) {\n                n = n10;\n                if ((tileSettings[1][n8][n9] & 2) == 2) {\n                    n = n3 + 1;\n                }\n            }\n            n10 = Perspective.getHeight(client, n4, n5, n);\n            n8 = Perspective.getHeight(client, n6, n5, n);\n            n3 = Perspective.getHeight(client, n6, n7, n);\n            n = Perspective.getHeight(client, n4, n7, n);\n            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);\n            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);\n            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);\n            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);\n            if (p1 != null && p2 != null && p3 != null && p4 != null) {\n                Path path = new Path();\n                path.moveTo((float) ((Point) p1).getX(), (float) ((Point) p1).getY());\n                path.lineTo((float) ((Point) p2).getX(), (float) ((Point) p2).getY());\n                path.lineTo((float) p3.getX(), (float) p3.getY());\n                path.lineTo((float) ((Point) p4).getX(), (float) ((Point) p4).getY());\n                return path;\n            }\n            return null;\n        }\n        return null;\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);\n    }\n\n    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {\n        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);\n    }\n\n    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane) {\n        int sceneX = localX >> LOCAL_COORD_BITS;\n        int sceneY = localY >> LOCAL_COORD_BITS;\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {\n            int[][][] tileHeights = client.getTileHeights();\n            int x = localX & (LOCAL_TILE_SIZE - 1);\n            int y = localY & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n\n    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {\n        int sceneX = point.getSceneX();\n        int sceneY = point.getSceneY();\n        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {\n            byte[][][] tileSettings = client.getTileSettings();\n            int[][][] tileHeights = client.getTileHeights();\n            if (plane < 0)\n                plane = 0;\n            int z1 = plane;\n            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE) {\n                z1 = plane + 1;\n            }\n            int x = point.getX() & (LOCAL_TILE_SIZE - 1);\n            int y = point.getY() & (LOCAL_TILE_SIZE - 1);\n            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;\n            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;\n            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;\n        }\n        return 0;\n    }\n\n    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z) {\n        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056) {\n            x -= client.getCameraX();\n            y -= client.getCameraY();\n            z -= client.getCameraZ();\n            int cameraPitch = client.getCameraPitch();\n            int cameraYaw = client.getCameraYaw();\n            int pitchSin = SINE[cameraPitch];\n            int pitchCos = COSINE[cameraPitch];\n            int yawSin = SINE[cameraYaw];\n            int yawCos = COSINE[cameraYaw];\n            int var8 = yawCos * x + y * yawSin >> 16;\n            y = yawCos * y - yawSin * x >> 16;\n            x = var8;\n            var8 = pitchCos * z - y * pitchSin >> 16;\n            y = z * pitchSin + y * pitchCos >> 16;\n            if (y >= 50) {\n                Log.e(\"Points\", \"x:\" + x + \" y:\" + y);\n                double pointX = (double) (client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double) client.getOverlayWidth() / (double) client.getViewportWidth();\n                double pointY = (double) (client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double) client.getOverlayWidth() / (double) client.getViewportWidth();\n                return new Point((int) pointX, (int) pointY);\n            }\n        }\n        return null;\n    }\n\n    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {\n        n = Perspective.getTileHeight(clientAPI, localPoint, n);\n        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);\n    }\n}\n", "refactored": true}
{"hexsha": "3c9b0668c602f3425aef938ddbcd842b6fc11a32", "ext": "java", "lang": "Java", "content": "@Component\n@ConditionalOnProperty(value = \"datasource-observer.sentinelhub.enabled\", havingValue = \"true\")\npublic class SentinelJobFactory implements JobFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);\n\n    @Autowired\n    private ExecutionIntervalConfig intervalConfig;\n\n    @Override\n    public boolean supportsJobDefinition(WacodisJobDefinition job) {\n        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();\n        return count > 0;\n    }\n\n    @Override\n    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data, AbstractSubsetDefinition subsetDefinition) {\n        // this should always be the case\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            LOG.info(\"Preparing SentinelJob JobDetail\");\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            if (copDef.getMaximumCloudCoverage() > 0) {\n                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n            }\n            switch(copDef.getSatellite()) {\n                case _1:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n                    break;\n                case _2:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n                    break;\n                case _3:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n                    break;\n            }\n            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n                int baseDays = period.getDays();\n                if (period.getHours() > 11) {\n                    // round to full days\n                    baseDays++;\n                }\n                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n            }\n            data.put(\"executionInterval\", intervalConfig.getSentinel());\n        }\n        // create the quartz object\n        return JobBuilder.newJob(SentinelJob.class).usingJobData(data);\n    }\n\n    @Override\n    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {\n        return job.getInputs().stream().filter((i -> i instanceof CopernicusSubsetDefinition));\n    }\n\n    @Override\n    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {\n        StringBuilder builder = new StringBuilder(\"\");\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            builder.append(copDef.getSourceType());\n            if (copDef.getSatellite() != null) {\n                builder.append(\"_\" + copDef.getSatellite());\n            }\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public Class getQuartzJobClass() {\n        // TODO Auto-generated method stub\n        return SentinelJob.class;\n    }\n\n    @Override\n    public JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {\n        // here we must do nothing as this Job dies not specify BBOX parameter\n        return jobDetail;\n    }\n}\n", "class_id": 0, "repo": "WaCoDiS/datasource-observer", "file": "sentinel-observer/src/main/java/de/wacodis/sentinel/SentinelJobFactory.java", "last_update_at": "2021-11-15T23:28:04+00:00", "original_content": "@Component\n@ConditionalOnProperty(value = \"datasource-observer.sentinelhub.enabled\", havingValue = \"true\")\npublic class SentinelJobFactory implements JobFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);\n\n    @Autowired\n    private ExecutionIntervalConfig intervalConfig;\n\n    @Override\n    public boolean supportsJobDefinition(WacodisJobDefinition job) {\n        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();\n        return count > 0;\n    }\n\n    @Override\n    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data, AbstractSubsetDefinition subsetDefinition) {\n        // this should always be the case\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            LOG.info(\"Preparing SentinelJob JobDetail\");\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            if (copDef.getMaximumCloudCoverage() > 0) {\n                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());\n            }\n            switch(copDef.getSatellite()) {\n                case _1:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);\n                    break;\n                case _2:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);\n                    break;\n                case _3:\n                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);\n                    break;\n            }\n            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {\n                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());\n                int baseDays = period.getDays();\n                if (period.getHours() > 11) {\n                    // round to full days\n                    baseDays++;\n                }\n                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);\n            }\n            data.put(\"executionInterval\", intervalConfig.getSentinel());\n        }\n        // create the quartz object\n        return JobBuilder.newJob(SentinelJob.class).usingJobData(data);\n    }\n\n    @Override\n    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {\n        return job.getInputs().stream().filter((i -> i instanceof CopernicusSubsetDefinition));\n    }\n\n    @Override\n    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {\n        StringBuilder builder = new StringBuilder(\"\");\n        if (subsetDefinition instanceof CopernicusSubsetDefinition) {\n            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;\n            builder.append(copDef.getSourceType());\n            if (copDef.getSatellite() != null) {\n                builder.append(\"_\" + copDef.getSatellite());\n            }\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public Class getQuartzJobClass() {\n        // TODO Auto-generated method stub\n        return SentinelJob.class;\n    }\n\n    @Override\n    public JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {\n        // here we must do nothing as this Job dies not specify BBOX parameter\n        return jobDetail;\n    }\n}\n", "refactored": false}
{"hexsha": "1ee98f729518a3ab59cc092fb753ccaf548f8923", "ext": "java", "lang": "Java", "content": "public class SqlPagingStrategy {\n\n    public static SqlPaging buildPaging(String databaseProduct) {\n        SqlPaging paging = new SqlPaging();\n        if (databaseProduct.equals(DatabaseProduct.MYSQL)) {\n            //$NON-NLS-1$\n            MySqlPagingDialect dialect = new MySqlPagingDialect();\n            paging.setDialect(dialect);\n        } else if (databaseProduct.equals(DatabaseProduct.PGSQL)) {\n            //$NON-NLS-1$\n            PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();\n            paging.setDialect(dialect);\n        } else if (databaseProduct.equals(DatabaseProduct.H2)) {\n            //$NON-NLS-1$\n            H2PagingDialect dialect = new H2PagingDialect();\n            paging.setDialect(dialect);\n        }\n        return paging;\n    }\n}\n", "class_id": 0, "repo": "obidea/semantika-core", "file": "src/main/java/com/obidea/semantika/queryanswer/paging/SqlPagingStrategy.java", "last_update_at": "2021-03-01T04:33:21+00:00", "original_content": "public class SqlPagingStrategy {\n\n    public static SqlPaging buildPaging(String databaseProduct) {\n        SqlPaging paging = new SqlPaging();\n        if (databaseProduct.equals(DatabaseProduct.MYSQL)) {\n            //$NON-NLS-1$\n            MySqlPagingDialect dialect = new MySqlPagingDialect();\n            paging.setDialect(dialect);\n        } else if (databaseProduct.equals(DatabaseProduct.PGSQL)) {\n            //$NON-NLS-1$\n            PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();\n            paging.setDialect(dialect);\n        } else if (databaseProduct.equals(DatabaseProduct.H2)) {\n            //$NON-NLS-1$\n            H2PagingDialect dialect = new H2PagingDialect();\n            paging.setDialect(dialect);\n        }\n        return paging;\n    }\n}\n", "refactored": false}
{"hexsha": "12958c18f6375a8f2d58b33654f17da5c8df2cff", "ext": "java", "lang": "Java", "content": "public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {\n\n    public static final String ENRICHMENT_ADDED = \"ENRICHMENT_ADDED\";\n\n    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {\n    };\n\n    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);\n\n    /**\n     * Have one of the supplied properties been modified?\n     */\n    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {\n        if (props != null) {\n            for (String propName : props) {\n                try {\n                    Property prop = doc.getProperty(propName);\n                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {\n                        return true;\n                    }\n                } catch (PropertyNotFoundException e) {\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {\n        // TODO: Handle versions here?\n        DocumentModel doc;\n        try {\n            doc = session.getDocument(new IdRef(metadata.context.documentRef));\n        } catch (DocumentNotFoundException e) {\n            log.info(\"Unable to save enrichment data for missing doc \" + metadata.context.documentRef);\n            return null;\n        }\n        Map<String, Object> anItem = metadata.toMap();\n        if (anItem != null) {\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n            if (enrichmentList == null) {\n                enrichmentList = new ArrayList<>(1);\n            }\n            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);\n            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());\n        }\n        return doc;\n    }\n\n    /**\n     * Updates enrichment, ensures we have one enrichment entry per model/version and input\n     */\n    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original, Map<String, Object> item) {\n        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();\n        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));\n        enrichmentByKey.put(uniqueKey(item), item);\n        return enrichmentByKey.values();\n    }\n\n    /**\n     * Generate a unique key for a model/version/input combination\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String uniqueKey(Map<String, Object> suggestion) {\n        String input = \"\";\n        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n        // This is a little big strange, but it adapts to the type and calls the correct join method.\n        if (inputs instanceof Set) {\n            input = String.join(\";\", (Set<String>) inputs);\n        } else if (inputs instanceof String[]) {\n            input = String.join(\";\", (String[]) inputs);\n        }\n        return suggestion.get(ENRICHMENT_MODEL) + input;\n    }\n\n    @Override\n    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model, Serializable oldValue, String comment) {\n        if (!doc.hasFacet(ENRICHMENT_FACET)) {\n            doc.addFacet(ENRICHMENT_FACET);\n        }\n        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());\n        HashMap<String, String> prediction = new HashMap<>();\n        prediction.put(\"xpath\", xPath);\n        prediction.put(\"model\", model);\n        autoProps.add(prediction);\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);\n        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n        if (oldValue != null) {\n            List<AutoHistory> existingHistory = getAutoHistory(doc);\n            // First remove old history if it exists\n            List<AutoHistory> history = existingHistory.stream().filter(h -> !xPath.equals(h.getProperty())).collect(Collectors.toList());\n            history.add(new AutoHistory(xPath, oldValue));\n            setAutoHistory(doc, history);\n        }\n        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);\n        storeAudit(doc, autoField, model, 1L, comment);\n        return doc;\n    }\n\n    @Override\n    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {\n        List<AutoHistory> history = getAutoHistory(doc);\n        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();\n        boolean present = previous.isPresent();\n        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());\n        Set<Map<String, String>> toReset = set.stream().filter(val -> val.get(\"xpath\").equals(xPath)).collect(Collectors.toSet());\n        @SuppressWarnings(\"unchecked\")\n        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);\n        Object previousValue = null;\n        if (set.size() > noOldXpath.size()) {\n            if (present) {\n                previousValue = previous.get().getPreviousValue();\n                history.remove(previous.get());\n                setAutoHistory(doc, history);\n            }\n            //Set the value\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);\n            String comment = \"Resetting \" + xPath + \" property\";\n            toReset.forEach(map -> {\n                storeAudit(doc, autoField, map.get(\"model\"), -1L, comment);\n            });\n            if (resetValue) {\n                doc.setPropertyValue(xPath, (Serializable) previousValue);\n            }\n        }\n        return doc;\n    }\n\n    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {\n        Set<Map<String, String>> autoProps = new HashSet<>(1);\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, autoPropertyName);\n        if (filled != null) {\n            autoProps.addAll(filled);\n        }\n        return autoProps;\n    }\n\n    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {\n        AuditLogger audit = Framework.getService(AuditLogger.class);\n        if (audit != null) {\n            LogEntry logEntry = audit.newLogEntry();\n            logEntry.setCategory(\"AI\");\n            logEntry.setEventId(autoField.eventName());\n            logEntry.setComment(comment);\n            logEntry.setDocUUID(doc.getId());\n            logEntry.setDocPath(doc.getPathAsString());\n            logEntry.setEventDate(new Date());\n            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);\n            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);\n            HashMap<String, ExtendedInfo> infos = new HashMap<>();\n            infos.put(\"model\", modelInfo);\n            infos.put(\"value\", one);\n            logEntry.setExtendedInfos(infos);\n            audit.addLogEntries(Collections.singletonList(logEntry));\n        } else {\n            log.warn(\"Audit Logger is not available\");\n        }\n    }\n\n    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {\n        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(), doc);\n        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());\n        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());\n        String paths = null;\n        if (xPaths != null && !xPaths.isEmpty()) {\n            paths = String.join(\",\", xPaths);\n        }\n        ctx.setProperty(PATHS, paths);\n        if (StringUtils.isEmpty(comment)) {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);\n        } else {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);\n        }\n        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));\n    }\n\n    @Override\n    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n        if (itemsList == null) {\n            return doc;\n        }\n        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());\n        itemsList.forEach(suggestObj -> {\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);\n            List<Map<String, Object>> newSuggestions = suggestions.stream().filter(s -> !xPath.equals(s.get(SUGGESTION_PROPERTY))).collect(Collectors.toList());\n            if (!newSuggestions.isEmpty()) {\n                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);\n                newSuggestList.add(suggestObj);\n            }\n        });\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);\n        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);\n        return doc;\n    }\n\n    @Override\n    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n        if (itemsList == null || itemsList.isEmpty()) {\n            return doc;\n        }\n        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());\n        Set<String> removedTargetProperties = new HashSet<>();\n        itemsList.forEach(entry -> {\n            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));\n            if (hadBeenModified(doc, inputProperties)) {\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);\n                Set<String> targetProps = suggestions.stream().map(s -> (String) s.get(SUGGESTION_PROPERTY)).collect(Collectors.toSet());\n                removedTargetProperties.addAll(targetProps);\n            } else {\n                cleanItemsList.add(entry);\n            }\n        });\n        if (cleanItemsList.size() != itemsList.size()) {\n            //We made some changes lets update\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, \"Dirty inputs\");\n        }\n        return doc;\n    }\n\n    @Override\n    public List<AutoHistory> getAutoHistory(DocumentModel doc) {\n        try {\n            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());\n            if (autoBlob != null) {\n                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to read auto history blob\", e);\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {\n        try {\n            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            String autoHistory = AUTO.HISTORY.lowerName();\n            autoBlob.setFilename(autoHistory + \"_\" + doc.getName() + \".json\");\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);\n        } catch (IOException e) {\n            log.warn(\"Failed to set auto history blob\", e);\n        }\n    }\n}\n", "class_id": 0, "repo": "nuxeo/nuxeo-ai", "file": "nuxeo-ai-core/src/main/java/org/nuxeo/ai/services/DocMetadataServiceImpl.java", "last_update_at": "2021-03-30T03:03:26+00:00", "original_content": "public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {\n\n    public static final String ENRICHMENT_ADDED = \"ENRICHMENT_ADDED\";\n\n    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {\n    };\n\n    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);\n\n    /**\n     * Have one of the supplied properties been modified?\n     */\n    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {\n        if (props != null) {\n            for (String propName : props) {\n                try {\n                    Property prop = doc.getProperty(propName);\n                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {\n                        return true;\n                    }\n                } catch (PropertyNotFoundException e) {\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {\n        // TODO: Handle versions here?\n        DocumentModel doc;\n        try {\n            doc = session.getDocument(new IdRef(metadata.context.documentRef));\n        } catch (DocumentNotFoundException e) {\n            log.info(\"Unable to save enrichment data for missing doc \" + metadata.context.documentRef);\n            return null;\n        }\n        Map<String, Object> anItem = metadata.toMap();\n        if (anItem != null) {\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n            if (enrichmentList == null) {\n                enrichmentList = new ArrayList<>(1);\n            }\n            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);\n            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());\n        }\n        return doc;\n    }\n\n    /**\n     * Updates enrichment, ensures we have one enrichment entry per model/version and input\n     */\n    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original, Map<String, Object> item) {\n        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();\n        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));\n        enrichmentByKey.put(uniqueKey(item), item);\n        return enrichmentByKey.values();\n    }\n\n    /**\n     * Generate a unique key for a model/version/input combination\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String uniqueKey(Map<String, Object> suggestion) {\n        String input = \"\";\n        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n        // This is a little big strange, but it adapts to the type and calls the correct join method.\n        if (inputs instanceof Set) {\n            input = String.join(\";\", (Set<String>) inputs);\n        } else if (inputs instanceof String[]) {\n            input = String.join(\";\", (String[]) inputs);\n        }\n        return suggestion.get(ENRICHMENT_MODEL) + input;\n    }\n\n    @Override\n    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model, Serializable oldValue, String comment) {\n        if (!doc.hasFacet(ENRICHMENT_FACET)) {\n            doc.addFacet(ENRICHMENT_FACET);\n        }\n        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());\n        HashMap<String, String> prediction = new HashMap<>();\n        prediction.put(\"xpath\", xPath);\n        prediction.put(\"model\", model);\n        autoProps.add(prediction);\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);\n        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);\n        if (oldValue != null) {\n            List<AutoHistory> existingHistory = getAutoHistory(doc);\n            // First remove old history if it exists\n            List<AutoHistory> history = existingHistory.stream().filter(h -> !xPath.equals(h.getProperty())).collect(Collectors.toList());\n            history.add(new AutoHistory(xPath, oldValue));\n            setAutoHistory(doc, history);\n        }\n        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);\n        storeAudit(doc, autoField, model, 1L, comment);\n        return doc;\n    }\n\n    @Override\n    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {\n        List<AutoHistory> history = getAutoHistory(doc);\n        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();\n        boolean present = previous.isPresent();\n        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());\n        Set<Map<String, String>> toReset = set.stream().filter(val -> val.get(\"xpath\").equals(xPath)).collect(Collectors.toSet());\n        @SuppressWarnings(\"unchecked\")\n        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);\n        Object previousValue = null;\n        if (set.size() > noOldXpath.size()) {\n            if (present) {\n                previousValue = previous.get().getPreviousValue();\n                history.remove(previous.get());\n                setAutoHistory(doc, history);\n            }\n            //Set the value\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);\n            String comment = \"Resetting \" + xPath + \" property\";\n            toReset.forEach(map -> {\n                storeAudit(doc, autoField, map.get(\"model\"), -1L, comment);\n            });\n            if (resetValue) {\n                doc.setPropertyValue(xPath, (Serializable) previousValue);\n            }\n        }\n        return doc;\n    }\n\n    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {\n        Set<Map<String, String>> autoProps = new HashSet<>(1);\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, autoPropertyName);\n        if (filled != null) {\n            autoProps.addAll(filled);\n        }\n        return autoProps;\n    }\n\n    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {\n        AuditLogger audit = Framework.getService(AuditLogger.class);\n        if (audit != null) {\n            LogEntry logEntry = audit.newLogEntry();\n            logEntry.setCategory(\"AI\");\n            logEntry.setEventId(autoField.eventName());\n            logEntry.setComment(comment);\n            logEntry.setDocUUID(doc.getId());\n            logEntry.setDocPath(doc.getPathAsString());\n            logEntry.setEventDate(new Date());\n            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);\n            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);\n            HashMap<String, ExtendedInfo> infos = new HashMap<>();\n            infos.put(\"model\", modelInfo);\n            infos.put(\"value\", one);\n            logEntry.setExtendedInfos(infos);\n            audit.addLogEntries(Collections.singletonList(logEntry));\n        } else {\n            log.warn(\"Audit Logger is not available\");\n        }\n    }\n\n    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {\n        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(), doc);\n        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());\n        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());\n        String paths = null;\n        if (xPaths != null && !xPaths.isEmpty()) {\n            paths = String.join(\",\", xPaths);\n        }\n        ctx.setProperty(PATHS, paths);\n        if (StringUtils.isEmpty(comment)) {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);\n        } else {\n            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);\n        }\n        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));\n    }\n\n    @Override\n    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n        if (itemsList == null) {\n            return doc;\n        }\n        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());\n        itemsList.forEach(suggestObj -> {\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);\n            List<Map<String, Object>> newSuggestions = suggestions.stream().filter(s -> !xPath.equals(s.get(SUGGESTION_PROPERTY))).collect(Collectors.toList());\n            if (!newSuggestions.isEmpty()) {\n                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);\n                newSuggestList.add(suggestObj);\n            }\n        });\n        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);\n        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);\n        return doc;\n    }\n\n    @Override\n    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);\n        if (itemsList == null || itemsList.isEmpty()) {\n            return doc;\n        }\n        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());\n        Set<String> removedTargetProperties = new HashSet<>();\n        itemsList.forEach(entry -> {\n            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);\n            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));\n            if (hadBeenModified(doc, inputProperties)) {\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);\n                Set<String> targetProps = suggestions.stream().map(s -> (String) s.get(SUGGESTION_PROPERTY)).collect(Collectors.toSet());\n                removedTargetProperties.addAll(targetProps);\n            } else {\n                cleanItemsList.add(entry);\n            }\n        });\n        if (cleanItemsList.size() != itemsList.size()) {\n            //We made some changes lets update\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);\n            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, \"Dirty inputs\");\n        }\n        return doc;\n    }\n\n    @Override\n    public List<AutoHistory> getAutoHistory(DocumentModel doc) {\n        try {\n            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());\n            if (autoBlob != null) {\n                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to read auto history blob\", e);\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {\n        try {\n            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));\n            if (!doc.hasFacet(ENRICHMENT_FACET)) {\n                doc.addFacet(ENRICHMENT_FACET);\n            }\n            String autoHistory = AUTO.HISTORY.lowerName();\n            autoBlob.setFilename(autoHistory + \"_\" + doc.getName() + \".json\");\n            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);\n        } catch (IOException e) {\n            log.warn(\"Failed to set auto history blob\", e);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "2dc0bd87eab86338ed959af6cf2291c34c7fcd29", "ext": "java", "lang": "Java", "content": "@Getter\npublic class OrientedBox {\n\n    protected Vector center;\n\n    protected Vector axisX;\n\n    protected Vector axisY;\n\n    protected Vector axisZ;\n\n    protected float extentX;\n\n    protected float extentY;\n\n    protected float extentZ;\n\n    public OrientedBox(final Vector center, final Vector axisX, final Vector axisY, final Vector axisZ, final float extentX, final float extentY, final float extentZ) {\n        this.center = center;\n        this.axisX = axisX;\n        this.axisY = axisY;\n        this.axisZ = axisZ;\n        this.extentX = extentX;\n        this.extentY = extentY;\n        this.extentZ = extentZ;\n    }\n\n    public OrientedBox(final AxialBox box, final Transform transform) {\n        this.center = transform.rotateTranslateLocalToParent(box.getCenter());\n        this.axisX = transform.rotateLocalToParent(box.getAxisX());\n        this.axisY = transform.rotateLocalToParent(box.getAxisY());\n        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final AxialBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final YawedBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public Vector[] getAxes() {\n        return new Vector[] { axisX, axisY, axisZ };\n    }\n\n    public float[] getExtents() {\n        return new float[] { extentX, extentY, extentZ };\n    }\n\n    public Vector getBase() {\n        return getCenter().subtract(getAxisY().multiply(getExtentY()));\n    }\n\n    public Plane3d getFacePlane(final int whichPlane) {\n        switch(whichPlane) {\n            case 0:\n                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);\n            case 1:\n                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);\n            case 2:\n                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);\n            case 3:\n                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());\n            case 4:\n                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());\n            case 5:\n                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());\n            default:\n                return new Plane3d(Vector.ZERO, Vector.ZERO);\n        }\n    }\n\n    public Vector getCorner(final int whichCorner) {\n        final Vector x = axisX.multiply(extentX);\n        final Vector y = axisY.multiply(extentY);\n        final Vector z = axisZ.multiply(extentZ);\n        switch(whichCorner) {\n            case 0:\n                return center.subtract(x).subtract(y).subtract(z);\n            case 1:\n                return center.add(x).subtract(y).subtract(z);\n            case 2:\n                return center.subtract(x).subtract(y).add(z);\n            case 3:\n                return center.add(x).subtract(y).add(z);\n            case 4:\n                return center.subtract(x).add(y).subtract(z);\n            case 5:\n                return center.add(x).add(y).subtract(z);\n            case 6:\n                return center.subtract(x).add(y).add(z);\n            case 7:\n                return center.add(x).add(y).add(z);\n            default:\n                return Vector.ZERO;\n        }\n    }\n\n    public AxialBox getLocalShape() {\n        return new AxialBox(new Vector(-extentX, -extentY, -extentZ), new Vector(extentX, extentY, extentZ));\n    }\n\n    public Transform getTransformLocalToParent() {\n        final Transform temp = new Transform();\n        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());\n        temp.moveInParentSpace(center);\n        return temp;\n    }\n\n    public Transform getTransformParentToLocal() {\n        final Transform temp = new Transform();\n        temp.invert(getTransformLocalToParent());\n        return temp;\n    }\n\n    public Vector transformToLocal(final Vector vector) {\n        return rotateToLocal(vector.subtract(center));\n    }\n\n    public Vector transformToWorld(final Vector vector) {\n        return rotateToWorld(vector).add(center);\n    }\n\n    public Vector rotateToLocal(final Vector vector) {\n        return new Vector(vector.dot(getAxisX()), vector.dot(getAxisY()), vector.dot(getAxisZ()));\n    }\n\n    public Vector rotateToWorld(final Vector vector) {\n        return Vector.ZERO.add(getAxisX().multiply(vector.x)).add(getAxisY().multiply(vector.y)).add(getAxisZ().multiply(vector.z));\n    }\n}\n", "class_id": 0, "repo": "bacta/pre-cu-archive", "file": "src/main/java/com/ocdsoft/bacta/swg/shared/math/OrientedBox.java", "last_update_at": "2021-09-20T23:01:54+00:00", "original_content": "@Getter\npublic class OrientedBox {\n\n    protected Vector center;\n\n    protected Vector axisX;\n\n    protected Vector axisY;\n\n    protected Vector axisZ;\n\n    protected float extentX;\n\n    protected float extentY;\n\n    protected float extentZ;\n\n    public OrientedBox(final Vector center, final Vector axisX, final Vector axisY, final Vector axisZ, final float extentX, final float extentY, final float extentZ) {\n        this.center = center;\n        this.axisX = axisX;\n        this.axisY = axisY;\n        this.axisZ = axisZ;\n        this.extentX = extentX;\n        this.extentY = extentY;\n        this.extentZ = extentZ;\n    }\n\n    public OrientedBox(final AxialBox box, final Transform transform) {\n        this.center = transform.rotateTranslateLocalToParent(box.getCenter());\n        this.axisX = transform.rotateLocalToParent(box.getAxisX());\n        this.axisY = transform.rotateLocalToParent(box.getAxisY());\n        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final AxialBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public OrientedBox(final YawedBox box) {\n        this.center = box.getCenter();\n        this.axisX = box.getAxisX();\n        this.axisY = box.getAxisY();\n        this.axisZ = box.getAxisZ();\n        this.extentX = box.getExtentX();\n        this.extentY = box.getExtentY();\n        this.extentZ = box.getExtentZ();\n    }\n\n    public Vector[] getAxes() {\n        return new Vector[] { axisX, axisY, axisZ };\n    }\n\n    public float[] getExtents() {\n        return new float[] { extentX, extentY, extentZ };\n    }\n\n    public Vector getBase() {\n        return getCenter().subtract(getAxisY().multiply(getExtentY()));\n    }\n\n    public Plane3d getFacePlane(final int whichPlane) {\n        switch(whichPlane) {\n            case 0:\n                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);\n            case 1:\n                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);\n            case 2:\n                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);\n            case 3:\n                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());\n            case 4:\n                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());\n            case 5:\n                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());\n            default:\n                return new Plane3d(Vector.ZERO, Vector.ZERO);\n        }\n    }\n\n    public Vector getCorner(final int whichCorner) {\n        final Vector x = axisX.multiply(extentX);\n        final Vector y = axisY.multiply(extentY);\n        final Vector z = axisZ.multiply(extentZ);\n        switch(whichCorner) {\n            case 0:\n                return center.subtract(x).subtract(y).subtract(z);\n            case 1:\n                return center.add(x).subtract(y).subtract(z);\n            case 2:\n                return center.subtract(x).subtract(y).add(z);\n            case 3:\n                return center.add(x).subtract(y).add(z);\n            case 4:\n                return center.subtract(x).add(y).subtract(z);\n            case 5:\n                return center.add(x).add(y).subtract(z);\n            case 6:\n                return center.subtract(x).add(y).add(z);\n            case 7:\n                return center.add(x).add(y).add(z);\n            default:\n                return Vector.ZERO;\n        }\n    }\n\n    public AxialBox getLocalShape() {\n        return new AxialBox(new Vector(-extentX, -extentY, -extentZ), new Vector(extentX, extentY, extentZ));\n    }\n\n    public Transform getTransformLocalToParent() {\n        final Transform temp = new Transform();\n        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());\n        temp.moveInParentSpace(center);\n        return temp;\n    }\n\n    public Transform getTransformParentToLocal() {\n        final Transform temp = new Transform();\n        temp.invert(getTransformLocalToParent());\n        return temp;\n    }\n\n    public Vector transformToLocal(final Vector vector) {\n        return rotateToLocal(vector.subtract(center));\n    }\n\n    public Vector transformToWorld(final Vector vector) {\n        return rotateToWorld(vector).add(center);\n    }\n\n    public Vector rotateToLocal(final Vector vector) {\n        return new Vector(vector.dot(getAxisX()), vector.dot(getAxisY()), vector.dot(getAxisZ()));\n    }\n\n    public Vector rotateToWorld(final Vector vector) {\n        return Vector.ZERO.add(getAxisX().multiply(vector.x)).add(getAxisY().multiply(vector.y)).add(getAxisZ().multiply(vector.z));\n    }\n}\n", "refactored": false}
{"hexsha": "cebbdc7523d968d8f24072abc5e1ab3f921ba715", "ext": "java", "lang": "Java", "content": "public class BinaryInput extends AbstractInput {\r\n\r\n    private static final long serialVersionUID = -1467422051075776185L;\r\n\r\n    private final HexEdit hexEdit = new HexEdit(new byte[0]);\r\n\r\n    // model - byte array\r\n    private byte[] buffer;\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    public BinaryInput() {\r\n        super();\r\n        setLayout(new GridLayout(1, 1));\r\n        // set focus\r\n        hexEdit.addAncestorListener(new RequestFocusListener());\r\n        add(hexEdit);\r\n    }\r\n\r\n    /**\r\n     * Sets value to be edited\r\n     *\r\n     * @param buffer\r\n     */\r\n    public void setValue(byte[] buffer) {\r\n        hexEdit.requestFocusInWindow();\r\n        this.buffer = buffer;\r\n        hexEdit.reset(buffer);\r\n    }\r\n\r\n    /**\r\n     * Get edited data\r\n     *\r\n     * @return\r\n     */\r\n    public byte[] getValue() {\r\n        return (buffer);\r\n    }\r\n}\r\n", "class_id": 0, "repo": "metalname/regular", "file": "Common/src/InputHelpers/BinaryInput.java", "last_update_at": "2021-09-12T13:33:15+00:00", "original_content": "public class BinaryInput extends AbstractInput {\r\n\r\n    private static final long serialVersionUID = -1467422051075776185L;\r\n\r\n    private final HexEdit hexEdit = new HexEdit(new byte[0]);\r\n\r\n    // model - byte array\r\n    private byte[] buffer;\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    public BinaryInput() {\r\n        super();\r\n        setLayout(new GridLayout(1, 1));\r\n        // set focus\r\n        hexEdit.addAncestorListener(new RequestFocusListener());\r\n        add(hexEdit);\r\n    }\r\n\r\n    /**\r\n     * Sets value to be edited\r\n     *\r\n     * @param buffer\r\n     */\r\n    public void setValue(byte[] buffer) {\r\n        hexEdit.requestFocusInWindow();\r\n        this.buffer = buffer;\r\n        hexEdit.reset(buffer);\r\n    }\r\n\r\n    /**\r\n     * Get edited data\r\n     *\r\n     * @return\r\n     */\r\n    public byte[] getValue() {\r\n        return (buffer);\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "fd52101a33b5d14359ea4a2449bf8b531284b2c9", "ext": "java", "lang": "Java", "content": "public class NonStartTest {\n\n    private NonStart fixture;\n\n    @BeforeEach\n    public void setUp() {\n        fixture = new NonStart();\n    }\n\n    @Test\n    public void testcase1() {\n        final String strA = \"Hello\";\n        final String strB = \"There\";\n        final String expected = \"ellohere\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase2() {\n        final String strA = \"java\";\n        final String strB = \"code\";\n        final String expected = \"avaode\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase3() {\n        final String strA = \"shotl\";\n        final String strB = \"java\";\n        final String expected = \"hotlava\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreNull() {\n        final String strA = null;\n        final String strB = null;\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreEmpty() {\n        final String strA = \"\";\n        final String strB = \"\";\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {\n        final String strA1 = null;\n        final String strA2 = \"\";\n        final String strB1 = \"\";\n        final String strB2 = null;\n        final String expected = \"\";\n        final String actual1 = fixture.nonStart(strA1, strB1);\n        final String actual2 = fixture.nonStart(strA2, strB2);\n        assertThat(actual1).isEqualTo(expected);\n        assertThat(actual2).isEqualTo(expected);\n    }\n}\n", "class_id": 0, "repo": "the-code-journal/code-challenges-java", "file": "src/test/java/io/codejournal/codingbat/string1/NonStartTest.java", "last_update_at": "2021-06-13T14:03:00+00:00", "original_content": "public class NonStartTest {\n\n    private NonStart fixture;\n\n    @BeforeEach\n    public void setUp() {\n        fixture = new NonStart();\n    }\n\n    @Test\n    public void testcase1() {\n        final String strA = \"Hello\";\n        final String strB = \"There\";\n        final String expected = \"ellohere\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase2() {\n        final String strA = \"java\";\n        final String strB = \"code\";\n        final String expected = \"avaode\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void testcase3() {\n        final String strA = \"shotl\";\n        final String strB = \"java\";\n        final String expected = \"hotlava\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreNull() {\n        final String strA = null;\n        final String strB = null;\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenBothAreEmpty() {\n        final String strA = \"\";\n        final String strB = \"\";\n        final String expected = \"\";\n        final String actual = fixture.nonStart(strA, strB);\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {\n        final String strA1 = null;\n        final String strA2 = \"\";\n        final String strB1 = \"\";\n        final String strB2 = null;\n        final String expected = \"\";\n        final String actual1 = fixture.nonStart(strA1, strB1);\n        final String actual2 = fixture.nonStart(strA2, strB2);\n        assertThat(actual1).isEqualTo(expected);\n        assertThat(actual2).isEqualTo(expected);\n    }\n}\n", "refactored": false}
{"hexsha": "495a13909672c96a7ef84b5eadc8a58384dc2c30", "ext": "java", "lang": "Java", "content": "public class DiffAlgorithm {\r\n\r\n    // XXX: Caution, enabling logging significantly impacts performance\r\n    public static final int VERBOSE_LOGGING = 1;\r\n\r\n    private DocumentModel baseModel, witnessModel;\r\n\r\n    private SymbolTable symbolTable;\r\n\r\n    private Correlator correlator;\r\n\r\n    private DifferenceCollector collector;\r\n\r\n    private DifferenceSet differenceSet;\r\n\r\n    public DifferenceSet diffDocuments(DocumentModel baseModel, DocumentModel witnessModel) {\r\n        if (baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false) {\r\n            SimpleLogger.logError(\"Documents must be tokenized the same way to be comparable.\");\r\n            return null;\r\n        }\r\n        this.baseModel = baseModel;\r\n        this.witnessModel = witnessModel;\r\n        return performDiff();\r\n    }\r\n\r\n    //  perform the actual diff algorithm\r\n    private DifferenceSet performDiff() {\r\n        // create a common symbol table based on the two documents\r\n        symbolTable = new SymbolTable(baseModel, witnessModel);\r\n        // Correlate the contents of the two documents\r\n        correlator = new Correlator(symbolTable);\r\n        // Collect difference information from the correlation data\r\n        collector = new DifferenceCollector(correlator);\r\n        differenceSet = collector.getDifferenceSet();\r\n        return differenceSet;\r\n    }\r\n\r\n    public void updateDifferenceSet(DifferenceSet differenceSet) {\r\n        this.differenceSet = differenceSet;\r\n    }\r\n\r\n    public int getCorrespondingWitnessOffset(int baseOffset, boolean getEnd) {\r\n        int baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);\r\n        FileInfo witnessFileInfo = correlator.getNewInfo();\r\n        // converting to a token and back will do that.\r\n        baseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);\r\n        Iterator i = differenceSet.getDifferenceList().iterator();\r\n        while (i.hasNext()) try {\r\n            Difference difference = (Difference) i.next();\r\n            if ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE))) {\r\n                if (getEnd)\r\n                    return difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);\r\n                else\r\n                    return difference.getOffset(Difference.WITNESS);\r\n            }\r\n        } finally {\r\n        }\r\n        int witnessIndex = 1;\r\n        while (witnessIndex < witnessFileInfo.getSymbolCount() + 1) try {\r\n            if (witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex) {\r\n                if (getEnd)\r\n                    return convertIndexToOffset(witnessIndex, Difference.WITNESS) + witnessFileInfo.getSymbol(witnessIndex + 1).getSymbolLength();\r\n                else\r\n                    return convertIndexToOffset(witnessIndex, Difference.WITNESS);\r\n            }\r\n        } finally {\r\n            witnessIndex++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public int getCorrespondingBaseOffset(int witnessOffset, boolean getEnd) {\r\n        int witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);\r\n        FileInfo baseFileInfo = correlator.getOldInfo();\r\n        // converting to a token and back will do that.\r\n        witnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);\r\n        Iterator i = differenceSet.getDifferenceList().iterator();\r\n        while (i.hasNext()) try {\r\n            Difference difference = (Difference) i.next();\r\n            if ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS))) {\r\n                if (getEnd)\r\n                    return difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);\r\n                else\r\n                    return difference.getOffset(Difference.BASE);\r\n            }\r\n        } finally {\r\n        }\r\n        int baseIndex = 1;\r\n        while (baseIndex < baseFileInfo.getSymbolCount() + 1) try {\r\n            if (baseFileInfo.getCrossIndex(baseIndex) == witnessIndex) {\r\n                if (getEnd)\r\n                    return convertIndexToOffset(baseIndex, Difference.BASE) + baseFileInfo.getSymbol(baseIndex + 1).getSymbolLength();\r\n                else\r\n                    return convertIndexToOffset(baseIndex, Difference.BASE);\r\n            }\r\n        } finally {\r\n            baseIndex++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private int convertIndexToOffset(int index, int type) {\r\n        // For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.\r\n        if (type == Difference.BASE) {\r\n            return symbolTable.getOldInfo().getDocumentOffset(index + 1);\r\n        } else {\r\n            return symbolTable.getNewInfo().getDocumentOffset(index + 1);\r\n        }\r\n    }\r\n\r\n    // so in that case we need to know if we're interested in the token before that or the token after that.\r\n    private int convertOffsetToIndex(int offset, int type, boolean useNext) {\r\n        DocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;\r\n        List<Token> tokenList = targetDocument.getTokenList();\r\n        int i = 0;\r\n        for (Token token : tokenList) {\r\n            int tokenEnd = token.getOffset() + token.getToken().length();\r\n            // Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=\r\n            int fudge = (useNext ? 0 : 1);\r\n            if ((token.getOffset() <= offset - fudge) && (offset <= tokenEnd))\r\n                // Exact match\r\n                return i;\r\n            if (// We've passed the spot, so we must be in the crack between tokens\r\n            token.getOffset() >= offset) {\r\n                if (useNext) {\r\n                    if (i == tokenList.size() - 1)\r\n                        return i;\r\n                    else\r\n                        return i;\r\n                } else\r\n                    return (i - 1 > 0) ? i - 1 : 0;\r\n            }\r\n            i++;\r\n        }\r\n        return (tokenList.size() > 0) ? tokenList.size() - 1 : 0;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "performant-software/juxta-desktop", "file": "src/main/java/edu/virginia/speclab/diff/DiffAlgorithm.java", "last_update_at": "2021-07-17T19:42:48+00:00", "original_content": "public class DiffAlgorithm {\r\n\r\n    // XXX: Caution, enabling logging significantly impacts performance\r\n    public static final int VERBOSE_LOGGING = 1;\r\n\r\n    private DocumentModel baseModel, witnessModel;\r\n\r\n    private SymbolTable symbolTable;\r\n\r\n    private Correlator correlator;\r\n\r\n    private DifferenceCollector collector;\r\n\r\n    private DifferenceSet differenceSet;\r\n\r\n    public DifferenceSet diffDocuments(DocumentModel baseModel, DocumentModel witnessModel) {\r\n        if (baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false) {\r\n            SimpleLogger.logError(\"Documents must be tokenized the same way to be comparable.\");\r\n            return null;\r\n        }\r\n        this.baseModel = baseModel;\r\n        this.witnessModel = witnessModel;\r\n        return performDiff();\r\n    }\r\n\r\n    //  perform the actual diff algorithm\r\n    private DifferenceSet performDiff() {\r\n        // create a common symbol table based on the two documents\r\n        symbolTable = new SymbolTable(baseModel, witnessModel);\r\n        // Correlate the contents of the two documents\r\n        correlator = new Correlator(symbolTable);\r\n        // Collect difference information from the correlation data\r\n        collector = new DifferenceCollector(correlator);\r\n        differenceSet = collector.getDifferenceSet();\r\n        return differenceSet;\r\n    }\r\n\r\n    public void updateDifferenceSet(DifferenceSet differenceSet) {\r\n        this.differenceSet = differenceSet;\r\n    }\r\n\r\n    public int getCorrespondingWitnessOffset(int baseOffset, boolean getEnd) {\r\n        int baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);\r\n        FileInfo witnessFileInfo = correlator.getNewInfo();\r\n        // converting to a token and back will do that.\r\n        baseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);\r\n        for (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); ) {\r\n            Difference difference = (Difference) i.next();\r\n            if ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE))) {\r\n                if (getEnd)\r\n                    return difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);\r\n                else\r\n                    return difference.getOffset(Difference.WITNESS);\r\n            }\r\n        }\r\n        // First, see if there is an exact match for the token. If so, return it.\r\n        for (int witnessIndex = 1; witnessIndex < witnessFileInfo.getSymbolCount() + 1; witnessIndex++) {\r\n            if (witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex) {\r\n                if (getEnd)\r\n                    return convertIndexToOffset(witnessIndex, Difference.WITNESS) + witnessFileInfo.getSymbol(witnessIndex + 1).getSymbolLength();\r\n                else\r\n                    return convertIndexToOffset(witnessIndex, Difference.WITNESS);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public int getCorrespondingBaseOffset(int witnessOffset, boolean getEnd) {\r\n        int witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);\r\n        FileInfo baseFileInfo = correlator.getOldInfo();\r\n        // converting to a token and back will do that.\r\n        witnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);\r\n        for (Iterator i = differenceSet.getDifferenceList().iterator(); i.hasNext(); ) {\r\n            Difference difference = (Difference) i.next();\r\n            if ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS))) {\r\n                if (getEnd)\r\n                    return difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);\r\n                else\r\n                    return difference.getOffset(Difference.BASE);\r\n            }\r\n        }\r\n        // First, see if there is an exact match for the token. If so, return it.\r\n        for (int baseIndex = 1; baseIndex < baseFileInfo.getSymbolCount() + 1; baseIndex++) {\r\n            if (baseFileInfo.getCrossIndex(baseIndex) == witnessIndex) {\r\n                if (getEnd)\r\n                    return convertIndexToOffset(baseIndex, Difference.BASE) + baseFileInfo.getSymbol(baseIndex + 1).getSymbolLength();\r\n                else\r\n                    return convertIndexToOffset(baseIndex, Difference.BASE);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private int convertIndexToOffset(int index, int type) {\r\n        // For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.\r\n        if (type == Difference.BASE) {\r\n            return symbolTable.getOldInfo().getDocumentOffset(index + 1);\r\n        } else {\r\n            return symbolTable.getNewInfo().getDocumentOffset(index + 1);\r\n        }\r\n    }\r\n\r\n    // so in that case we need to know if we're interested in the token before that or the token after that.\r\n    private int convertOffsetToIndex(int offset, int type, boolean useNext) {\r\n        DocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;\r\n        List<Token> tokenList = targetDocument.getTokenList();\r\n        int i = 0;\r\n        for (Token token : tokenList) {\r\n            int tokenEnd = token.getOffset() + token.getToken().length();\r\n            // Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=\r\n            int fudge = (useNext ? 0 : 1);\r\n            if ((token.getOffset() <= offset - fudge) && (offset <= tokenEnd))\r\n                // Exact match\r\n                return i;\r\n            if (// We've passed the spot, so we must be in the crack between tokens\r\n            token.getOffset() >= offset) {\r\n                if (useNext) {\r\n                    if (i == tokenList.size() - 1)\r\n                        return i;\r\n                    else\r\n                        return i;\r\n                } else\r\n                    return (i - 1 > 0) ? i - 1 : 0;\r\n            }\r\n            i++;\r\n        }\r\n        return (tokenList.size() > 0) ? tokenList.size() - 1 : 0;\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "05ef2f68dbf7ba92065c8486bd0b45aff254557c", "ext": "java", "lang": "Java", "content": "public class OrganisationTransformer {\n\n    public static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException {\n        ArrayList<Organization> organizations = new ArrayList<>();\n        for (OpenHR001Organisation source : sources) organizations.add(transform(source));\n        return organizations;\n    }\n\n    public static Organization transform(OpenHR001Organisation source) throws TransformException {\n        OpenHRHelper.ensureDboNotDelete(source);\n        Organization target = new Organization();\n        target.setId(source.getId());\n        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));\n        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))\n            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));\n        target.setActive(source.getCloseDate() == null);\n        if ((source.getOpenDate() != null) || (source.getCloseDate() != null)) {\n            Period period = new Period();\n            if (source.getOpenDate() != null)\n                period.setStart(DateConverter.toDate(source.getOpenDate()));\n            if (source.getCloseDate() != null)\n                period.setEnd(DateConverter.toDate(source.getCloseDate()));\n            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));\n        }\n        target.setName(source.getName());\n        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));\n        if (!StringUtils.isBlank(source.getParentOrganisation()))\n            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));\n        if (!StringUtils.isBlank(source.getMainLocation()))\n            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));\n        return target;\n    }\n}\n", "class_id": 0, "repo": "endeavourhealth/Transforms", "file": "src/main/java/org/endeavourhealth/transform/emis/openhr/transforms/admin/OrganisationTransformer.java", "last_update_at": "2021-08-17T12:29:48+00:00", "original_content": "public class OrganisationTransformer {\n\n    public static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException {\n        ArrayList<Organization> organizations = new ArrayList<>();\n        for (OpenHR001Organisation source : sources) organizations.add(transform(source));\n        return organizations;\n    }\n\n    public static Organization transform(OpenHR001Organisation source) throws TransformException {\n        OpenHRHelper.ensureDboNotDelete(source);\n        Organization target = new Organization();\n        target.setId(source.getId());\n        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));\n        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))\n            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));\n        target.setActive(source.getCloseDate() == null);\n        if ((source.getOpenDate() != null) || (source.getCloseDate() != null)) {\n            Period period = new Period();\n            if (source.getOpenDate() != null)\n                period.setStart(DateConverter.toDate(source.getOpenDate()));\n            if (source.getCloseDate() != null)\n                period.setEnd(DateConverter.toDate(source.getCloseDate()));\n            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));\n        }\n        target.setName(source.getName());\n        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));\n        if (!StringUtils.isBlank(source.getParentOrganisation()))\n            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));\n        if (!StringUtils.isBlank(source.getMainLocation()))\n            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));\n        return target;\n    }\n}\n", "refactored": false}
{"hexsha": "39d74258dd6a75d4e31c7f001884daaab0356310", "ext": "java", "lang": "Java", "content": "public class Do implements Directive {\n\n    Directive _prefix;\n\n    @Override\n    public String script() {\n        return String.format(\"%s do\", _prefix.script());\n    }\n\n    @Override\n    public List<Parameter> parameters() {\n        return _prefix.parameters();\n    }\n\n    public Nothing nothing() {\n        Nothing re = new Nothing();\n        re._prefix = this;\n        return re;\n    }\n\n    public Update update() {\n        Update re = new Update();\n        re._prefix = this;\n        return re;\n    }\n\n    public class Update implements Directive {\n\n        Directive _prefix;\n\n        @Override\n        public String script() {\n            return String.format(\"%s update\", _prefix.script());\n        }\n\n        @Override\n        public List<Parameter> parameters() {\n            return _prefix.parameters();\n        }\n\n        public jaskell.sql.Update.Set set(String field, Directive value) {\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n\n        public jaskell.sql.Update.Set set(Directive field, Directive value) {\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n    }\n}\n", "class_id": 0, "repo": "moonbirdxp/jaskell", "file": "src/main/java/jaskell/sql/Do.java", "last_update_at": "2021-04-29T01:31:42+00:00", "original_content": "public class Do implements Directive {\n\n    Directive _prefix;\n\n    @Override\n    public String script() {\n        return String.format(\"%s do\", _prefix.script());\n    }\n\n    @Override\n    public List<Parameter> parameters() {\n        return _prefix.parameters();\n    }\n\n    public Nothing nothing() {\n        Nothing re = new Nothing();\n        re._prefix = this;\n        return re;\n    }\n\n    public Update update() {\n        Update re = new Update();\n        re._prefix = this;\n        return re;\n    }\n\n    public class Update implements Directive {\n\n        Directive _prefix;\n\n        @Override\n        public String script() {\n            return String.format(\"%s update\", _prefix.script());\n        }\n\n        @Override\n        public List<Parameter> parameters() {\n            return _prefix.parameters();\n        }\n\n        public jaskell.sql.Update.Set set(String field, Directive value) {\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n\n        public jaskell.sql.Update.Set set(Directive field, Directive value) {\n            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);\n            re._prefix = this;\n            return re;\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "8430996939d31d00feb517b1c2345762d39cc91e", "ext": "java", "lang": "Java", "content": "public class PullRequestRescopedActivity extends PullRequestActivity {\n\n    private String fromHash;\n\n    private String previousFromHash;\n\n    private String previousToHash;\n\n    private String toHash;\n\n    private List<Commit> added;\n\n    private List<Commit> removed;\n\n    protected PullRequestRescopedActivity() {\n    }\n\n    public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {\n        this.id = id;\n        this.createdDate = createdDate;\n        this.user = user;\n        this.pullRequestId = pullRequestId;\n        this.fromHash = fromHash;\n        this.previousFromHash = previousFromHash;\n        this.previousToHash = previousToHash;\n        this.toHash = toHash;\n        this.added = ImmutableList.copyOf(added);\n        this.removed = ImmutableList.copyOf(removed);\n        this.actionType = PullRequestActivityActionType.RESCOPED;\n    }\n\n    public String getFromHash() {\n        return fromHash;\n    }\n\n    public String getPreviousFromHash() {\n        return previousFromHash;\n    }\n\n    public String getPreviousToHash() {\n        return previousToHash;\n    }\n\n    public String getToHash() {\n        return toHash;\n    }\n\n    public List<Commit> getAdded() {\n        return added;\n    }\n\n    public List<Commit> getRemoved() {\n        return removed;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        PullRequestRescopedActivity that = (PullRequestRescopedActivity) o;\n        if (pullRequestId != that.pullRequestId)\n            return false;\n        if (fromHash != null ? !fromHash.equals(that.fromHash) : that.fromHash != null)\n            return false;\n        if (previousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)\n            return false;\n        if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)\n            return false;\n        if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null)\n            return false;\n        if (added != null ? !added.equals(that.added) : that.added != null)\n            return false;\n        if (removed != null ? !removed.equals(that.removed) : that.removed != null)\n            return false;\n        if (id != null ? !id.equals(that.id) : that.id != null)\n            return false;\n        if (createdDate != null ? !createdDate.equals(that.createdDate) : that.createdDate != null)\n            return false;\n        if (user != null ? !user.equals(that.user) : that.user != null)\n            return false;\n        return actionType == that.actionType;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = fromHash != null ? fromHash.hashCode() : 0;\n        result = 31 * result + (previousFromHash != null ? previousFromHash.hashCode() : 0);\n        result = 31 * result + (previousToHash != null ? previousToHash.hashCode() : 0);\n        result = 31 * result + (toHash != null ? toHash.hashCode() : 0);\n        result = 31 * result + (added != null ? added.hashCode() : 0);\n        result = 31 * result + (removed != null ? removed.hashCode() : 0);\n        result = 31 * result + (id != null ? id.hashCode() : 0);\n        result = 31 * result + (createdDate != null ? createdDate.hashCode() : 0);\n        result = 31 * result + (user != null ? user.hashCode() : 0);\n        result = 31 * result + (int) (pullRequestId ^ (pullRequestId >>> 32));\n        result = 31 * result + (actionType != null ? actionType.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"PullRequestRescopedActivity{\" + \"fromHash='\" + fromHash + '\\'' + \", previousFromHash='\" + previousFromHash + '\\'' + \", previousToHash='\" + previousToHash + '\\'' + \", toHash='\" + toHash + '\\'' + \", added=\" + added + \", removed=\" + removed + \", id=\" + id + \", createdDate=\" + createdDate + \", user=\" + user + \", pullRequestId=\" + pullRequestId + \", actionType=\" + actionType + '}';\n    }\n}\n", "class_id": 0, "repo": "cornelcreanga/bitbucket-rest-client", "file": "src/main/java/com/ccreanga/bitbucket/rest/client/model/pull/activity/PullRequestRescopedActivity.java", "last_update_at": "2021-06-30T06:37:32+00:00", "original_content": "public class PullRequestRescopedActivity extends PullRequestActivity {\n\n    private String fromHash;\n\n    private String previousFromHash;\n\n    private String previousToHash;\n\n    private String toHash;\n\n    private List<Commit> added;\n\n    private List<Commit> removed;\n\n    protected PullRequestRescopedActivity() {\n    }\n\n    public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {\n        this.id = id;\n        this.createdDate = createdDate;\n        this.user = user;\n        this.pullRequestId = pullRequestId;\n        this.fromHash = fromHash;\n        this.previousFromHash = previousFromHash;\n        this.previousToHash = previousToHash;\n        this.toHash = toHash;\n        this.added = ImmutableList.copyOf(added);\n        this.removed = ImmutableList.copyOf(removed);\n        this.actionType = PullRequestActivityActionType.RESCOPED;\n    }\n\n    public String getFromHash() {\n        return fromHash;\n    }\n\n    public String getPreviousFromHash() {\n        return previousFromHash;\n    }\n\n    public String getPreviousToHash() {\n        return previousToHash;\n    }\n\n    public String getToHash() {\n        return toHash;\n    }\n\n    public List<Commit> getAdded() {\n        return added;\n    }\n\n    public List<Commit> getRemoved() {\n        return removed;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        PullRequestRescopedActivity that = (PullRequestRescopedActivity) o;\n        if (pullRequestId != that.pullRequestId)\n            return false;\n        if (fromHash != null ? !fromHash.equals(that.fromHash) : that.fromHash != null)\n            return false;\n        if (previousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)\n            return false;\n        if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)\n            return false;\n        if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null)\n            return false;\n        if (added != null ? !added.equals(that.added) : that.added != null)\n            return false;\n        if (removed != null ? !removed.equals(that.removed) : that.removed != null)\n            return false;\n        if (id != null ? !id.equals(that.id) : that.id != null)\n            return false;\n        if (createdDate != null ? !createdDate.equals(that.createdDate) : that.createdDate != null)\n            return false;\n        if (user != null ? !user.equals(that.user) : that.user != null)\n            return false;\n        return actionType == that.actionType;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = fromHash != null ? fromHash.hashCode() : 0;\n        result = 31 * result + (previousFromHash != null ? previousFromHash.hashCode() : 0);\n        result = 31 * result + (previousToHash != null ? previousToHash.hashCode() : 0);\n        result = 31 * result + (toHash != null ? toHash.hashCode() : 0);\n        result = 31 * result + (added != null ? added.hashCode() : 0);\n        result = 31 * result + (removed != null ? removed.hashCode() : 0);\n        result = 31 * result + (id != null ? id.hashCode() : 0);\n        result = 31 * result + (createdDate != null ? createdDate.hashCode() : 0);\n        result = 31 * result + (user != null ? user.hashCode() : 0);\n        result = 31 * result + (int) (pullRequestId ^ (pullRequestId >>> 32));\n        result = 31 * result + (actionType != null ? actionType.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"PullRequestRescopedActivity{\" + \"fromHash='\" + fromHash + '\\'' + \", previousFromHash='\" + previousFromHash + '\\'' + \", previousToHash='\" + previousToHash + '\\'' + \", toHash='\" + toHash + '\\'' + \", added=\" + added + \", removed=\" + removed + \", id=\" + id + \", createdDate=\" + createdDate + \", user=\" + user + \", pullRequestId=\" + pullRequestId + \", actionType=\" + actionType + '}';\n    }\n}\n", "refactored": false}
{"hexsha": "cbdaafcd9298f370a6c6ed63c5358f105f12b3e8", "ext": "java", "lang": "Java", "content": "public final class CookieManager extends CookieHandler {\n\n    private static final Logger logger = Logger.getLogger(CookieManager.class.getName());\n\n    private final CookieStore store = new CookieStore();\n\n    /**\n     * Creates a new {@code CookieManager}.\n     */\n    public CookieManager() {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String, List<String>> get(URI uri, Map<String, List<String>> requestHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\", new Object[] { uri, toLogString(requestHeaders) });\n        }\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n        String cookieString = get(uri);\n        Map<String, List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String, List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the cookie string for a given URI.\n     */\n    private String get(URI uri) {\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, returning null\");\n            return null;\n        }\n        host = canonicalize(host);\n        String scheme = uri.getScheme();\n        boolean secureProtocol = \"https\".equalsIgnoreCase(scheme) || \"javascripts\".equalsIgnoreCase(scheme);\n        boolean httpApi = \"http\".equalsIgnoreCase(scheme) || \"https\".equalsIgnoreCase(scheme);\n        List<Cookie> cookieList;\n        synchronized (store) {\n            cookieList = store.get(host, uri.getPath(), secureProtocol, httpApi);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Cookie cookie : cookieList) {\n            if (sb.length() > 0) {\n                sb.append(\"; \");\n            }\n            sb.append(cookie.getName());\n            sb.append('=');\n            sb.append(cookie.getValue());\n        }\n        return sb.length() > 0 ? sb.toString() : null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String, List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\", new Object[] { uri, toLogString(responseHeaders) });\n        }\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n        for (Map.Entry<String, List<String>> entry : responseHeaders.entrySet()) {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it = entry.getValue().listIterator(entry.getValue().size());\n            for (; it.hasPrevious(); ) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }\n\n    /**\n     * Puts an individual cookie.\n     */\n    private void put(URI uri, Cookie cookie) {\n        logger.log(Level.FINEST, \"cookie: {0}\", cookie);\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, ignoring cookie\");\n            return;\n        }\n        host = canonicalize(host);\n        if (PublicSuffixes.isPublicSuffix(cookie.getDomain())) {\n            if (cookie.getDomain().equals(host)) {\n                cookie.setDomain(\"\");\n            } else {\n                logger.log(Level.FINEST, \"Domain is public suffix, \" + \"ignoring cookie\");\n                return;\n            }\n        }\n        if (cookie.getDomain().length() > 0) {\n            if (!Cookie.domainMatches(host, cookie.getDomain())) {\n                logger.log(Level.FINEST, \"Hostname does not match domain, \" + \"ignoring cookie\");\n                return;\n            } else {\n                cookie.setHostOnly(false);\n            }\n        } else {\n            cookie.setHostOnly(true);\n            cookie.setDomain(host);\n        }\n        if (cookie.getPath() == null) {\n            cookie.setPath(Cookie.defaultPath(uri));\n        }\n        boolean httpApi = \"http\".equalsIgnoreCase(uri.getScheme()) || \"https\".equalsIgnoreCase(uri.getScheme());\n        if (cookie.getHttpOnly() && !httpApi) {\n            logger.log(Level.FINEST, \"HttpOnly cookie received from non-HTTP \" + \"API, ignoring cookie\");\n            return;\n        }\n        synchronized (store) {\n            Cookie oldCookie = store.get(cookie);\n            if (oldCookie != null) {\n                if (oldCookie.getHttpOnly() && !httpApi) {\n                    logger.log(Level.FINEST, \"Non-HTTP API attempts to \" + \"overwrite HttpOnly cookie, blocked\");\n                    return;\n                }\n                cookie.setCreationTime(oldCookie.getCreationTime());\n            }\n            store.put(cookie);\n        }\n        logger.log(Level.FINEST, \"Stored: {0}\", cookie);\n    }\n\n    /**\n     * Converts a map of HTTP headers to a string suitable for displaying\n     * in the log.\n     */\n    private static String toLogString(Map<String, List<String>> headers) {\n        if (headers == null) {\n            return null;\n        }\n        if (headers.isEmpty()) {\n            return \"{}\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            String key = entry.getKey();\n            for (String value : entry.getValue()) {\n                sb.append(String.format(\"%n    \"));\n                sb.append(key);\n                sb.append(\": \");\n                sb.append(value);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Canonicalizes a hostname as required by RFC 6265.\n     */\n    private static String canonicalize(String hostname) {\n        // The hostname is already all-ASCII at this point\n        return hostname.toLowerCase();\n    }\n}\n", "class_id": 0, "repo": "likuisuper/Java-Notes", "file": "JavaSourceLearn/javafx-src/com/sun/webkit/network/CookieManager.java", "last_update_at": "2021-01-30T13:44:33+00:00", "original_content": "public final class CookieManager extends CookieHandler {\n\n    private static final Logger logger = Logger.getLogger(CookieManager.class.getName());\n\n    private final CookieStore store = new CookieStore();\n\n    /**\n     * Creates a new {@code CookieManager}.\n     */\n    public CookieManager() {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String, List<String>> get(URI uri, Map<String, List<String>> requestHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\", new Object[] { uri, toLogString(requestHeaders) });\n        }\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n        String cookieString = get(uri);\n        Map<String, List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String, List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the cookie string for a given URI.\n     */\n    private String get(URI uri) {\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, returning null\");\n            return null;\n        }\n        host = canonicalize(host);\n        String scheme = uri.getScheme();\n        boolean secureProtocol = \"https\".equalsIgnoreCase(scheme) || \"javascripts\".equalsIgnoreCase(scheme);\n        boolean httpApi = \"http\".equalsIgnoreCase(scheme) || \"https\".equalsIgnoreCase(scheme);\n        List<Cookie> cookieList;\n        synchronized (store) {\n            cookieList = store.get(host, uri.getPath(), secureProtocol, httpApi);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Cookie cookie : cookieList) {\n            if (sb.length() > 0) {\n                sb.append(\"; \");\n            }\n            sb.append(cookie.getName());\n            sb.append('=');\n            sb.append(cookie.getValue());\n        }\n        return sb.length() > 0 ? sb.toString() : null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String, List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\", new Object[] { uri, toLogString(responseHeaders) });\n        }\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n        for (Map.Entry<String, List<String>> entry : responseHeaders.entrySet()) {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it = entry.getValue().listIterator(entry.getValue().size());\n            while (it.hasPrevious()) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }\n\n    /**\n     * Puts an individual cookie.\n     */\n    private void put(URI uri, Cookie cookie) {\n        logger.log(Level.FINEST, \"cookie: {0}\", cookie);\n        String host = uri.getHost();\n        if (host == null || host.length() == 0) {\n            logger.log(Level.FINEST, \"Null or empty URI host, ignoring cookie\");\n            return;\n        }\n        host = canonicalize(host);\n        if (PublicSuffixes.isPublicSuffix(cookie.getDomain())) {\n            if (cookie.getDomain().equals(host)) {\n                cookie.setDomain(\"\");\n            } else {\n                logger.log(Level.FINEST, \"Domain is public suffix, \" + \"ignoring cookie\");\n                return;\n            }\n        }\n        if (cookie.getDomain().length() > 0) {\n            if (!Cookie.domainMatches(host, cookie.getDomain())) {\n                logger.log(Level.FINEST, \"Hostname does not match domain, \" + \"ignoring cookie\");\n                return;\n            } else {\n                cookie.setHostOnly(false);\n            }\n        } else {\n            cookie.setHostOnly(true);\n            cookie.setDomain(host);\n        }\n        if (cookie.getPath() == null) {\n            cookie.setPath(Cookie.defaultPath(uri));\n        }\n        boolean httpApi = \"http\".equalsIgnoreCase(uri.getScheme()) || \"https\".equalsIgnoreCase(uri.getScheme());\n        if (cookie.getHttpOnly() && !httpApi) {\n            logger.log(Level.FINEST, \"HttpOnly cookie received from non-HTTP \" + \"API, ignoring cookie\");\n            return;\n        }\n        synchronized (store) {\n            Cookie oldCookie = store.get(cookie);\n            if (oldCookie != null) {\n                if (oldCookie.getHttpOnly() && !httpApi) {\n                    logger.log(Level.FINEST, \"Non-HTTP API attempts to \" + \"overwrite HttpOnly cookie, blocked\");\n                    return;\n                }\n                cookie.setCreationTime(oldCookie.getCreationTime());\n            }\n            store.put(cookie);\n        }\n        logger.log(Level.FINEST, \"Stored: {0}\", cookie);\n    }\n\n    /**\n     * Converts a map of HTTP headers to a string suitable for displaying\n     * in the log.\n     */\n    private static String toLogString(Map<String, List<String>> headers) {\n        if (headers == null) {\n            return null;\n        }\n        if (headers.isEmpty()) {\n            return \"{}\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            String key = entry.getKey();\n            for (String value : entry.getValue()) {\n                sb.append(String.format(\"%n    \"));\n                sb.append(key);\n                sb.append(\": \");\n                sb.append(value);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Canonicalizes a hostname as required by RFC 6265.\n     */\n    private static String canonicalize(String hostname) {\n        // The hostname is already all-ASCII at this point\n        return hostname.toLowerCase();\n    }\n}\n", "refactored": true}
{"hexsha": "0652ad2af2a6eb0257e3ffcd905f120ac148e447", "ext": "java", "lang": "Java", "content": "@Component\npublic class PaymentHandler implements PreSubmitCallbackHandler<AsylumCase> {\n\n    private final boolean isfeePaymentEnabled;\n\n    public PaymentHandler(@Value(\"${featureFlag.isfeePaymentEnabled}\") boolean isfeePaymentEnabled) {\n        this.isfeePaymentEnabled = isfeePaymentEnabled;\n    }\n\n    @Override\n    public DispatchPriority getDispatchPriority() {\n        return DispatchPriority.EARLY;\n    }\n\n    public boolean canHandle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {\n        requireNonNull(callbackStage, \"callbackStage must not be null\");\n        requireNonNull(callback, \"callback must not be null\");\n        return callbackStage == PreSubmitCallbackStage.ABOUT_TO_SUBMIT && (callback.getEvent() == Event.PAY_AND_SUBMIT_APPEAL || callback.getEvent() == Event.PAY_FOR_APPEAL || callback.getEvent() == Event.PAYMENT_APPEAL) && isfeePaymentEnabled;\n    }\n\n    public PreSubmitCallbackResponse<AsylumCase> handle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {\n        if (!canHandle(callbackStage, callback)) {\n            throw new IllegalStateException(\"Cannot handle callback\");\n        }\n        final AsylumCase asylumCase = callback.getCaseDetails().getCaseData();\n        boolean isRepJourney = asylumCase.read(AsylumCaseFieldDefinition.JOURNEY_TYPE, JourneyType.class).map(j -> j == JourneyType.REP).orElse(true);\n        // we have to set payment success first before do the payment because later we don't have possibility to change that\n        if (isRepJourney) {\n            asylumCase.write(PAYMENT_STATUS, PAID);\n        }\n        asylumCase.write(AsylumCaseFieldDefinition.IS_FEE_PAYMENT_ENABLED, isfeePaymentEnabled ? YesOrNo.YES : YesOrNo.NO);\n        return new PreSubmitCallbackResponse<>(asylumCase);\n    }\n}\n", "class_id": 0, "repo": "hmcts/iac-case-api", "file": "src/main/java/uk/gov/hmcts/reform/iacaseapi/domain/handlers/presubmit/payment/PaymentHandler.java", "last_update_at": "2021-12-02T09:37:28+00:00", "original_content": "@Component\npublic class PaymentHandler implements PreSubmitCallbackHandler<AsylumCase> {\n\n    private final boolean isfeePaymentEnabled;\n\n    public PaymentHandler(@Value(\"${featureFlag.isfeePaymentEnabled}\") boolean isfeePaymentEnabled) {\n        this.isfeePaymentEnabled = isfeePaymentEnabled;\n    }\n\n    @Override\n    public DispatchPriority getDispatchPriority() {\n        return DispatchPriority.EARLY;\n    }\n\n    public boolean canHandle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {\n        requireNonNull(callbackStage, \"callbackStage must not be null\");\n        requireNonNull(callback, \"callback must not be null\");\n        return callbackStage == PreSubmitCallbackStage.ABOUT_TO_SUBMIT && (callback.getEvent() == Event.PAY_AND_SUBMIT_APPEAL || callback.getEvent() == Event.PAY_FOR_APPEAL || callback.getEvent() == Event.PAYMENT_APPEAL) && isfeePaymentEnabled;\n    }\n\n    public PreSubmitCallbackResponse<AsylumCase> handle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {\n        if (!canHandle(callbackStage, callback)) {\n            throw new IllegalStateException(\"Cannot handle callback\");\n        }\n        final AsylumCase asylumCase = callback.getCaseDetails().getCaseData();\n        boolean isRepJourney = asylumCase.read(AsylumCaseFieldDefinition.JOURNEY_TYPE, JourneyType.class).map(j -> j == JourneyType.REP).orElse(true);\n        // we have to set payment success first before do the payment because later we don't have possibility to change that\n        if (isRepJourney) {\n            asylumCase.write(PAYMENT_STATUS, PAID);\n        }\n        asylumCase.write(AsylumCaseFieldDefinition.IS_FEE_PAYMENT_ENABLED, isfeePaymentEnabled ? YesOrNo.YES : YesOrNo.NO);\n        return new PreSubmitCallbackResponse<>(asylumCase);\n    }\n}\n", "refactored": false}
{"hexsha": "e1ad45857a9b1ea21e59ac0936bf389b3c285f6b", "ext": "java", "lang": "Java", "content": "public class SegmenterTest {\n\n    public static Segmenter.Data dataEmpty;\n\n    static {\n        try {\n            dataEmpty = new Segmenter.Data(new JSONObject(\"{}\"), Collections.emptyList(), null, 0L);\n        } catch (JSONException ex) {\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static Segmenter.Data dataWithInstallation(Segmenter.Data data, JSONObject installation) {\n        return new Segmenter.Data(installation, data.allEvents, data.presenceInfo, data.lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithAllEvents(Segmenter.Data data, List<JSONObject> allEvents) {\n        return new Segmenter.Data(data.installation, allEvents, data.presenceInfo, data.lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithPresenceInfo(Segmenter.Data data, Segmenter.PresenceInfo presenceInfo) {\n        return new Segmenter.Data(data.installation, data.allEvents, presenceInfo, data.lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithLastAppOpenDate(Segmenter.Data data, long lastAppOpenDate) {\n        return new Segmenter.Data(data.installation, data.allEvents, data.presenceInfo, lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithInstallationDiff(Segmenter.Data data, JSONObject installationDiff, boolean nullFieldRemoves) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONUtil.merge(installation, installationDiff, nullFieldRemoves);\n            return dataWithInstallation(data, installation);\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static Segmenter.Data dataWithNewerEvent(Segmenter.Data data, JSONObject newerEvent) {\n        List<JSONObject> allEvents = new ArrayList<>(data.allEvents.size() + 1);\n        String newerEventType = JSONUtil.getString(newerEvent, \"type\");\n        if (newerEventType == null)\n            throw new RuntimeException(\"missing event type\");\n        for (JSONObject event : data.allEvents) {\n            String eventType = JSONUtil.getString(event, \"type\");\n            if (!newerEventType.equals(eventType)) {\n                allEvents.add(event);\n            }\n        }\n        allEvents.add(newerEvent);\n        return dataWithAllEvents(data, allEvents);\n    }\n\n    public static Segmenter.Data dataWithTags(Segmenter.Data data, Set<String> tags) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONObject custom = installation.optJSONObject(\"custom\");\n            if (custom == null) {\n                custom = new JSONObject();\n                installation.put(\"custom\", custom);\n            }\n            custom.put(\"tags\", new JSONArray(tags));\n            return new Segmenter.Data(installation, data.allEvents, data.presenceInfo, data.lastAppOpenDate);\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Test\n    public void testItShouldMatchMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        Segmenter s = new Segmenter(dataEmpty);\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{}\"));\n        assertThat(s.matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqNull() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":null}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[null,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqFalse() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqTrue() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq0() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq00() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq1() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq10() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1.5,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":9223372036854775807}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775808}\"))).matchesInstallation(parsedSegment), is(false));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775806e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775807e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":7.000000000000000512e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999487}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999488}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000001}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000512}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000513}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqBigDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1e300}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1e300,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqBar() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqEmptystring() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqNumber() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        // 1577836800000 is 2020-01-01T00:00:00.000Z\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":1577836800000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqDateString() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":{\\\"date\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":9223372036854775806}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854777000e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":9.223372036854775808e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonIntegers() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonFloats() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonStrings() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonMixed() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonBooleans() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchEventTypeTest() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".bar\\\":{\\\".sub\\\":{\\\"eq\\\":\\\"sub\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchEventInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"nope\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchUser() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"user\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAnd() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"},\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"and\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchOr() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"or\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"to\\\":\\\"to\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchNot() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"not\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldNotMatchUnknownCriterion() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"unknown criterion\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchSubscriptionStatus() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"softOptOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optIn\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchLastActivityDate() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":1000000000000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 999999999999L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000000L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000001L)).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, TimeSync.getTime())).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchPresence() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        long now = TimeSync.getTime();\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        // not present yet, so not present, and it will last 60s, so we pass\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, but leave date is not lte -PT1M\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(true));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, and leave date is gte -PT1M\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 120000, now + 180000, 60000))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, but leave date is gte -PT1M\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchPrefix() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"fo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"f\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"FOO\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAny() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n}\n", "class_id": 0, "repo": "Bitoons/wonderpush-android-sdk", "file": "sdk/src/test/java/com/wonderpush/sdk/segmentation/SegmenterTest.java", "last_update_at": "2021-01-20T17:06:02+00:00", "original_content": "public class SegmenterTest {\n\n    public static Segmenter.Data dataEmpty;\n\n    static {\n        try {\n            dataEmpty = new Segmenter.Data(new JSONObject(\"{}\"), Collections.emptyList(), null, 0L);\n        } catch (JSONException ex) {\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static Segmenter.Data dataWithInstallation(Segmenter.Data data, JSONObject installation) {\n        return new Segmenter.Data(installation, data.allEvents, data.presenceInfo, data.lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithAllEvents(Segmenter.Data data, List<JSONObject> allEvents) {\n        return new Segmenter.Data(data.installation, allEvents, data.presenceInfo, data.lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithPresenceInfo(Segmenter.Data data, Segmenter.PresenceInfo presenceInfo) {\n        return new Segmenter.Data(data.installation, data.allEvents, presenceInfo, data.lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithLastAppOpenDate(Segmenter.Data data, long lastAppOpenDate) {\n        return new Segmenter.Data(data.installation, data.allEvents, data.presenceInfo, lastAppOpenDate);\n    }\n\n    public static Segmenter.Data dataWithInstallationDiff(Segmenter.Data data, JSONObject installationDiff, boolean nullFieldRemoves) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONUtil.merge(installation, installationDiff, nullFieldRemoves);\n            return dataWithInstallation(data, installation);\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public static Segmenter.Data dataWithNewerEvent(Segmenter.Data data, JSONObject newerEvent) {\n        List<JSONObject> allEvents = new ArrayList<>(data.allEvents.size() + 1);\n        String newerEventType = JSONUtil.getString(newerEvent, \"type\");\n        if (newerEventType == null)\n            throw new RuntimeException(\"missing event type\");\n        for (JSONObject event : data.allEvents) {\n            String eventType = JSONUtil.getString(event, \"type\");\n            if (!newerEventType.equals(eventType)) {\n                allEvents.add(event);\n            }\n        }\n        allEvents.add(newerEvent);\n        return dataWithAllEvents(data, allEvents);\n    }\n\n    public static Segmenter.Data dataWithTags(Segmenter.Data data, Set<String> tags) {\n        try {\n            JSONObject installation = new JSONObject(data.installation.toString());\n            JSONObject custom = installation.optJSONObject(\"custom\");\n            if (custom == null) {\n                custom = new JSONObject();\n                installation.put(\"custom\", custom);\n            }\n            custom.put(\"tags\", new JSONArray(tags));\n            return new Segmenter.Data(installation, data.allEvents, data.presenceInfo, data.lastAppOpenDate);\n        } catch (JSONException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Test\n    public void testItShouldMatchMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        Segmenter s = new Segmenter(dataEmpty);\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{}\"));\n        assertThat(s.matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqNull() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":null}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[null,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqFalse() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqTrue() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq0() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq00() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":0.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq1() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEq10() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1.5,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":9223372036854775807}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775808}\"))).matchesInstallation(parsedSegment), is(false));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775806e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775807e18}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":7.000000000000000512e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999487}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":6999999999999999488}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000001}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000512}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":7000000000000000513}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqBigDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":1e300}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.0e300}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[1e300,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqBar() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooEqEmptystring() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"bar\\\",true]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[0,\\\"\\\",true]}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqNumber() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        // 1577836800000 is 2020-01-01T00:00:00.000Z\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":1577836800000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldCustomDateFooEqDateString() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".custom.date_foo\\\":{\\\"eq\\\":{\\\"date\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":false}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"foo\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":1577836800000}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2029-09-09T09:09:09.009+09:09\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T01:00:00.000+01:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00.000\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00:00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01T00\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020-01\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"custom\\\":{\\\"date_foo\\\":\\\"2020Z\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":9223372036854775806}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775806}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775807}\"))).matchesInstallation(parsedSegment), is(true));\n        // When comparing a long with a double, we loose some precision, it's OK\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854775808e18}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9.223372036854777000e18}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":9.223372036854775808e18}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":9223372036854775805}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonIntegers() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":-1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonFloats() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":1.5}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.2}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.5}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1.7}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonStrings() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":\\\"mm\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"m\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"ma\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"MM\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mm\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mma\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"mz\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonMixed() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":0}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchFieldFooComparisonBooleans() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":true}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"lte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gt\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"gte\\\":false}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":true}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchEventTypeTest() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithNewerEvent(dataEmpty, new JSONObject(\"{\\\"type\\\":\\\"@APP_OPEN\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".bar\\\":{\\\".sub\\\":{\\\"eq\\\":\\\"sub\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":{\\\"sub\\\":\\\"sub\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchEventInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"event\\\":{\\\".type\\\":{\\\"eq\\\":\\\"test\\\"},\\\"installation\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"nope\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\")), new JSONObject(\"{\\\"type\\\":\\\"test\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchUser() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"user\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAnd() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"},\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"and\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchOr() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"or\\\":[{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}},{\\\".bar\\\":{\\\"eq\\\":\\\"bar\\\"}}]}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"to\\\":\\\"to\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchNot() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"not\\\":{\\\".foo\\\":{\\\"eq\\\":\\\"foo\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\",\\\"bar\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldNotMatchUnknownCriterion() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"unknown criterion\\\":{}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchSubscriptionStatus() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"softOptOut\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"subscriptionStatus\\\":\\\"optIn\\\"}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":null}}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":null}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optIn\\\"}}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"pushToken\\\":{\\\"data\\\":\\\"FAKE\\\"},\\\"preferences\\\":{\\\"subscriptionStatus\\\":\\\"optOut\\\"}}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchLastActivityDate() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":1000000000000}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 999999999999L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000000L)).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000001L)).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"lastActivityDate\\\":{\\\"gt\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, TimeSync.getTime())).matchesInstallation(parsedSegment), is(true));\n    }\n\n    @Test\n    public void testItShouldMatchPresence() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        long now = TimeSync.getTime();\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));\n        // not present yet, so not present, and it will last 60s, so we pass\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"gt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"elapsedTime\\\":{\\\"lt\\\":1000}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, but leave date is not lte -PT1M\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"lte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(true));\n        // not present yet, so not present\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":false,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, and leave date is gte -PT1M\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 120000, now + 180000, 60000))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\"presence\\\":{\\\"present\\\":true,\\\"sinceDate\\\":{\\\"gte\\\":{\\\"date\\\":\\\"-PT1M\\\"}}}}\"));\n        // no info is considered present since just about now\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(false));\n        // not present yet, but leave date is gte -PT1M\n        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchPrefix() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"fo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"f\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"FOO\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"prefix\\\":\\\"fo\\\"}}\"));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAny() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"any\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n\n    @Test\n    public void testItShouldMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {\n        ASTCriterionNode parsedSegment;\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,\\\"foo\\\"]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,\\\"foo\\\"]}\"))).matchesInstallation(parsedSegment), is(true));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[1,null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject(\"{\\\".foo\\\":{\\\"all\\\":[null]}}\"));\n        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"bar\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":\\\"foo\\\"}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":null}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":false}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":0}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":1}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[]}\"))).matchesInstallation(parsedSegment), is(true));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,null]}\"))).matchesInstallation(parsedSegment), is(false));\n        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject(\"{\\\"foo\\\":[\\\"bar\\\",false,1,null]}\"))).matchesInstallation(parsedSegment), is(false));\n    }\n}\n", "refactored": false}
{"hexsha": "c69772a5d8aa6e768a714070452503874640f029", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class WxMaServiceHttpClientImpl extends BaseWxMaServiceImpl {\n\n    private CloseableHttpClient httpClient;\n\n    private HttpHost httpProxy;\n\n    @Override\n    public void initHttp() {\n        WxMaConfig configStorage = this.getWxMaConfig();\n        ApacheHttpClientBuilder apacheHttpClientBuilder = configStorage.getApacheHttpClientBuilder();\n        if (null == apacheHttpClientBuilder) {\n            apacheHttpClientBuilder = DefaultApacheHttpClientBuilder.get();\n        }\n        apacheHttpClientBuilder.httpProxyHost(configStorage.getHttpProxyHost()).httpProxyPort(configStorage.getHttpProxyPort()).httpProxyUsername(configStorage.getHttpProxyUsername()).httpProxyPassword(configStorage.getHttpProxyPassword());\n        if (configStorage.getHttpProxyHost() != null && configStorage.getHttpProxyPort() > 0) {\n            this.httpProxy = new HttpHost(configStorage.getHttpProxyHost(), configStorage.getHttpProxyPort());\n        }\n        this.httpClient = apacheHttpClientBuilder.build();\n    }\n\n    @Override\n    public CloseableHttpClient getRequestHttpClient() {\n        return httpClient;\n    }\n\n    @Override\n    public HttpHost getRequestHttpProxy() {\n        return httpProxy;\n    }\n\n    @Override\n    public HttpType getRequestType() {\n        return HttpType.APACHE_HTTP;\n    }\n\n    @Override\n    protected String doGetAccessTokenRequest() throws IOException {\n        String url = String.format(WxMaService.GET_ACCESS_TOKEN_URL, this.getWxMaConfig().getAppid(), this.getWxMaConfig().getSecret());\n        HttpGet httpGet = null;\n        CloseableHttpResponse response = null;\n        try {\n            httpGet = new HttpGet(url);\n            if (this.getRequestHttpProxy() != null) {\n                RequestConfig config = RequestConfig.custom().setProxy(this.getRequestHttpProxy()).build();\n                httpGet.setConfig(config);\n            }\n            response = getRequestHttpClient().execute(httpGet);\n            return new BasicResponseHandler().handleResponse(response);\n        } finally {\n            if (httpGet != null) {\n                httpGet.releaseConnection();\n            }\n            if (response != null) {\n                try {\n                    response.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "hahahaha123567/WxJava", "file": "weixin-java-miniapp/src/main/java/cn/binarywang/wx/miniapp/api/impl/WxMaServiceHttpClientImpl.java", "last_update_at": "2021-01-14T03:49:59+00:00", "original_content": "@Slf4j\npublic class WxMaServiceHttpClientImpl extends BaseWxMaServiceImpl {\n\n    private CloseableHttpClient httpClient;\n\n    private HttpHost httpProxy;\n\n    @Override\n    public void initHttp() {\n        WxMaConfig configStorage = this.getWxMaConfig();\n        ApacheHttpClientBuilder apacheHttpClientBuilder = configStorage.getApacheHttpClientBuilder();\n        if (null == apacheHttpClientBuilder) {\n            apacheHttpClientBuilder = DefaultApacheHttpClientBuilder.get();\n        }\n        apacheHttpClientBuilder.httpProxyHost(configStorage.getHttpProxyHost()).httpProxyPort(configStorage.getHttpProxyPort()).httpProxyUsername(configStorage.getHttpProxyUsername()).httpProxyPassword(configStorage.getHttpProxyPassword());\n        if (configStorage.getHttpProxyHost() != null && configStorage.getHttpProxyPort() > 0) {\n            this.httpProxy = new HttpHost(configStorage.getHttpProxyHost(), configStorage.getHttpProxyPort());\n        }\n        this.httpClient = apacheHttpClientBuilder.build();\n    }\n\n    @Override\n    public CloseableHttpClient getRequestHttpClient() {\n        return httpClient;\n    }\n\n    @Override\n    public HttpHost getRequestHttpProxy() {\n        return httpProxy;\n    }\n\n    @Override\n    public HttpType getRequestType() {\n        return HttpType.APACHE_HTTP;\n    }\n\n    @Override\n    protected String doGetAccessTokenRequest() throws IOException {\n        String url = String.format(WxMaService.GET_ACCESS_TOKEN_URL, this.getWxMaConfig().getAppid(), this.getWxMaConfig().getSecret());\n        HttpGet httpGet = null;\n        CloseableHttpResponse response = null;\n        try {\n            httpGet = new HttpGet(url);\n            if (this.getRequestHttpProxy() != null) {\n                RequestConfig config = RequestConfig.custom().setProxy(this.getRequestHttpProxy()).build();\n                httpGet.setConfig(config);\n            }\n            response = getRequestHttpClient().execute(httpGet);\n            return new BasicResponseHandler().handleResponse(response);\n        } finally {\n            if (httpGet != null) {\n                httpGet.releaseConnection();\n            }\n            if (response != null) {\n                try {\n                    response.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "33fbd2d8697786a75b675ce0f67d67aea1d4dc16", "ext": "java", "lang": "Java", "content": "public class SequenceValueGenerator extends AbstractSequenceValueProducer {\r\n\r\n    public static final int DEFAULT_RESERVE_AMOUNT = 100;\r\n\r\n    public static final int DEFAULT_INITIAL_VALUE = 1;\r\n\r\n    public static final int DEFAULT_INCREMENT = 1;\r\n\r\n    private final Repository mRepository;\r\n\r\n    private final Storage<StoredSequence> mStorage;\r\n\r\n    private final StoredSequence mStoredSequence;\r\n\r\n    private final int mIncrement;\r\n\r\n    private final int mReserveAmount;\r\n\r\n    private boolean mHasReservedValues;\r\n\r\n    private long mNextValue;\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist. The initial sequence value is one,\r\n     * and the increment is one.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name) throws RepositoryException {\r\n        this(repo, name, DEFAULT_INITIAL_VALUE, DEFAULT_INCREMENT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment) throws RepositoryException {\r\n        this(repo, name, initialValue, increment, DEFAULT_RESERVE_AMOUNT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     * @param reserveAmount amount of sequence values to reserve\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment, int reserveAmount) throws RepositoryException {\r\n        if (repo == null || name == null || increment < 1 || reserveAmount < 1) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        mRepository = repo;\r\n        mIncrement = increment;\r\n        mReserveAmount = reserveAmount;\r\n        mStorage = repo.storageFor(StoredSequence.class);\r\n        mStoredSequence = mStorage.prepare();\r\n        mStoredSequence.setName(name);\r\n        Transaction txn = repo.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            if (!mStoredSequence.tryLoad()) {\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n                // Try to transfer values from a deprecated sequence.\r\n                com.amazon.carbonado.spi.StoredSequence oldSequence;\r\n                try {\r\n                    oldSequence = repo.storageFor(com.amazon.carbonado.spi.StoredSequence.class).prepare();\r\n                    oldSequence.setName(name);\r\n                    if (oldSequence.tryLoad()) {\r\n                        mStoredSequence.setInitialValue(oldSequence.getInitialValue());\r\n                        mStoredSequence.setNextValue(oldSequence.getNextValue());\r\n                    } else {\r\n                        oldSequence = null;\r\n                    }\r\n                } catch (RepositoryException e) {\r\n                    // Okay, perhaps no old sequence.\r\n                    oldSequence = null;\r\n                }\r\n                if (mStoredSequence.tryInsert()) {\r\n                    if (oldSequence != null) {\r\n                        try {\r\n                            // Get rid of deprecated sequence.\r\n                            oldSequence.tryDelete();\r\n                        } catch (RepositoryException e) {\r\n                        }\r\n                    }\r\n                } else {\r\n                    // A race condition likely. Load again.\r\n                    mStoredSequence.load();\r\n                }\r\n            }\r\n            txn.commit();\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the sequence.\r\n     *\r\n     * @param initialValue first value produced by sequence\r\n     */\r\n    public void reset(int initialValue) throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            Transaction txn = mRepository.enterTopTransaction(null);\r\n            txn.setForUpdate(true);\r\n            try {\r\n                boolean doUpdate = mStoredSequence.tryLoad();\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n                if (doUpdate) {\r\n                    mStoredSequence.update();\r\n                } else {\r\n                    mStoredSequence.insert();\r\n                }\r\n                txn.commit();\r\n                mHasReservedValues = false;\r\n            } finally {\r\n                txn.exit();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is exhausted.\r\n     */\r\n    public long nextLongValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                return nextUnadjustedValue() + Long.MIN_VALUE + mStoredSequence.getInitialValue();\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is\r\n     * exhausted for int values.\r\n     */\r\n    @Override\r\n    public int nextIntValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                long initial = mStoredSequence.getInitialValue();\r\n                if (initial >= 0x100000000L) {\r\n                    throw new PersistException(\"Sequence initial value too large to support 32-bit ints: \" + mStoredSequence.getName() + \", initial: \" + initial);\r\n                }\r\n                long next = nextUnadjustedValue();\r\n                if (next >= Long.MIN_VALUE + 0x100000000L) {\r\n                    // has been lost. This seems fairly benign.\r\n                    throw new PersistException(\"Sequence exhausted for 32-bit ints: \" + mStoredSequence.getName() + \", next: \" + (next + Long.MIN_VALUE + initial));\r\n                }\r\n                return (int) (next + Long.MIN_VALUE + initial);\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allow any unused reserved values to be returned for re-use. If the\r\n     * repository is shared by other processes, then reserved values might not\r\n     * be returnable.\r\n     *\r\n     * <p>This method should be called during the shutdown process of a\r\n     * repository, although calling it does not invalidate this\r\n     * SequenceValueGenerator. If getNextValue is called again, it will reserve\r\n     * values again.\r\n     *\r\n     * @return true if reserved values were returned\r\n     */\r\n    public boolean returnReservedValues() throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            if (mHasReservedValues) {\r\n                Transaction txn = mRepository.enterTopTransaction(null);\r\n                txn.setForUpdate(true);\r\n                try {\r\n                    // one. If same, then reserved values can be returned.\r\n                    StoredSequence current = mStorage.prepare();\r\n                    current.setName(mStoredSequence.getName());\r\n                    if (current.tryLoad() && current.equals(mStoredSequence)) {\r\n                        mStoredSequence.setNextValue(mNextValue + mIncrement);\r\n                        mStoredSequence.update();\r\n                        txn.commit();\r\n                        mHasReservedValues = false;\r\n                        return true;\r\n                    }\r\n                } finally {\r\n                    txn.exit();\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Assumes caller has synchronized on mStoredSequence\r\n    private long nextUnadjustedValue() throws FetchException, PersistException {\r\n        if (mHasReservedValues) {\r\n            long next = mNextValue + mIncrement;\r\n            mNextValue = next;\r\n            if (next < mStoredSequence.getNextValue()) {\r\n                return next;\r\n            }\r\n            mHasReservedValues = false;\r\n        }\r\n        Transaction txn = mRepository.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            // Assume that StoredSequence is stale, so reload.\r\n            mStoredSequence.load();\r\n            long next = mStoredSequence.getNextValue();\r\n            long nextStored = next + mReserveAmount * mIncrement;\r\n            if (next >= 0 && nextStored < 0) {\r\n                // Wrapped around. There might be just a few values left.\r\n                long avail = (Long.MAX_VALUE - next) / mIncrement;\r\n                if (avail > 0) {\r\n                    nextStored = next + avail * mIncrement;\r\n                } else {\r\n                    // insert operations, and inserts can only throw PersistExceptions.\r\n                    throw new PersistException(\"Sequence exhausted: \" + mStoredSequence.getName());\r\n                }\r\n            }\r\n            mStoredSequence.setNextValue(nextStored);\r\n            mStoredSequence.update();\r\n            txn.commit();\r\n            mNextValue = next;\r\n            mHasReservedValues = true;\r\n            return next;\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n}\r\n", "class_id": 0, "repo": "jesterpm/Carbonado", "file": "src/main/java/com/amazon/carbonado/sequence/SequenceValueGenerator.java", "last_update_at": "2021-08-09T07:19:13+00:00", "original_content": "public class SequenceValueGenerator extends AbstractSequenceValueProducer {\r\n\r\n    public static final int DEFAULT_RESERVE_AMOUNT = 100;\r\n\r\n    public static final int DEFAULT_INITIAL_VALUE = 1;\r\n\r\n    public static final int DEFAULT_INCREMENT = 1;\r\n\r\n    private final Repository mRepository;\r\n\r\n    private final Storage<StoredSequence> mStorage;\r\n\r\n    private final StoredSequence mStoredSequence;\r\n\r\n    private final int mIncrement;\r\n\r\n    private final int mReserveAmount;\r\n\r\n    private boolean mHasReservedValues;\r\n\r\n    private long mNextValue;\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist. The initial sequence value is one,\r\n     * and the increment is one.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name) throws RepositoryException {\r\n        this(repo, name, DEFAULT_INITIAL_VALUE, DEFAULT_INCREMENT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment) throws RepositoryException {\r\n        this(repo, name, initialValue, increment, DEFAULT_RESERVE_AMOUNT);\r\n    }\r\n\r\n    /**\r\n     * Construct a new SequenceValueGenerator which might create persistent\r\n     * sequence data if it does not exist.\r\n     *\r\n     * @param repo repository to persist sequence data\r\n     * @param name name of sequence\r\n     * @param initialValue initial sequence value, if sequence needs to be created\r\n     * @param increment amount to increment sequence by\r\n     * @param reserveAmount amount of sequence values to reserve\r\n     */\r\n    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment, int reserveAmount) throws RepositoryException {\r\n        if (repo == null || name == null || increment < 1 || reserveAmount < 1) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        mRepository = repo;\r\n        mIncrement = increment;\r\n        mReserveAmount = reserveAmount;\r\n        mStorage = repo.storageFor(StoredSequence.class);\r\n        mStoredSequence = mStorage.prepare();\r\n        mStoredSequence.setName(name);\r\n        Transaction txn = repo.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            if (!mStoredSequence.tryLoad()) {\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n                // Try to transfer values from a deprecated sequence.\r\n                com.amazon.carbonado.spi.StoredSequence oldSequence;\r\n                try {\r\n                    oldSequence = repo.storageFor(com.amazon.carbonado.spi.StoredSequence.class).prepare();\r\n                    oldSequence.setName(name);\r\n                    if (oldSequence.tryLoad()) {\r\n                        mStoredSequence.setInitialValue(oldSequence.getInitialValue());\r\n                        mStoredSequence.setNextValue(oldSequence.getNextValue());\r\n                    } else {\r\n                        oldSequence = null;\r\n                    }\r\n                } catch (RepositoryException e) {\r\n                    // Okay, perhaps no old sequence.\r\n                    oldSequence = null;\r\n                }\r\n                if (mStoredSequence.tryInsert()) {\r\n                    if (oldSequence != null) {\r\n                        try {\r\n                            // Get rid of deprecated sequence.\r\n                            oldSequence.tryDelete();\r\n                        } catch (RepositoryException e) {\r\n                        }\r\n                    }\r\n                } else {\r\n                    // A race condition likely. Load again.\r\n                    mStoredSequence.load();\r\n                }\r\n            }\r\n            txn.commit();\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the sequence.\r\n     *\r\n     * @param initialValue first value produced by sequence\r\n     */\r\n    public void reset(int initialValue) throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            Transaction txn = mRepository.enterTopTransaction(null);\r\n            txn.setForUpdate(true);\r\n            try {\r\n                boolean doUpdate = mStoredSequence.tryLoad();\r\n                mStoredSequence.setInitialValue(initialValue);\r\n                // Start as small as possible to allow signed long comparisons to work.\r\n                mStoredSequence.setNextValue(Long.MIN_VALUE);\r\n                if (doUpdate) {\r\n                    mStoredSequence.update();\r\n                } else {\r\n                    mStoredSequence.insert();\r\n                }\r\n                txn.commit();\r\n                mHasReservedValues = false;\r\n            } finally {\r\n                txn.exit();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is exhausted.\r\n     */\r\n    public long nextLongValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                return nextUnadjustedValue() + Long.MIN_VALUE + mStoredSequence.getInitialValue();\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next value from the sequence, which may wrap negative if all\r\n     * positive values are exhausted. When sequence wraps back to initial\r\n     * value, the sequence is fully exhausted, and an exception is thrown to\r\n     * indicate this.\r\n     *\r\n     * <p>Note: this method throws PersistException even for fetch failures\r\n     * since this method is called by insert operations. Insert operations can\r\n     * only throw a PersistException.\r\n     *\r\n     * @throws PersistException for fetch/persist failure or if sequence is\r\n     * exhausted for int values.\r\n     */\r\n    @Override\r\n    public int nextIntValue() throws PersistException {\r\n        try {\r\n            synchronized (mStoredSequence) {\r\n                long initial = mStoredSequence.getInitialValue();\r\n                if (initial >= 0x100000000L) {\r\n                    throw new PersistException(\"Sequence initial value too large to support 32-bit ints: \" + mStoredSequence.getName() + \", initial: \" + initial);\r\n                }\r\n                long next = nextUnadjustedValue();\r\n                if (next >= Long.MIN_VALUE + 0x100000000L) {\r\n                    // has been lost. This seems fairly benign.\r\n                    throw new PersistException(\"Sequence exhausted for 32-bit ints: \" + mStoredSequence.getName() + \", next: \" + (next + Long.MIN_VALUE + initial));\r\n                }\r\n                return (int) (next + Long.MIN_VALUE + initial);\r\n            }\r\n        } catch (FetchException e) {\r\n            throw e.toPersistException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allow any unused reserved values to be returned for re-use. If the\r\n     * repository is shared by other processes, then reserved values might not\r\n     * be returnable.\r\n     *\r\n     * <p>This method should be called during the shutdown process of a\r\n     * repository, although calling it does not invalidate this\r\n     * SequenceValueGenerator. If getNextValue is called again, it will reserve\r\n     * values again.\r\n     *\r\n     * @return true if reserved values were returned\r\n     */\r\n    public boolean returnReservedValues() throws FetchException, PersistException {\r\n        synchronized (mStoredSequence) {\r\n            if (mHasReservedValues) {\r\n                Transaction txn = mRepository.enterTopTransaction(null);\r\n                txn.setForUpdate(true);\r\n                try {\r\n                    // one. If same, then reserved values can be returned.\r\n                    StoredSequence current = mStorage.prepare();\r\n                    current.setName(mStoredSequence.getName());\r\n                    if (current.tryLoad() && current.equals(mStoredSequence)) {\r\n                        mStoredSequence.setNextValue(mNextValue + mIncrement);\r\n                        mStoredSequence.update();\r\n                        txn.commit();\r\n                        mHasReservedValues = false;\r\n                        return true;\r\n                    }\r\n                } finally {\r\n                    txn.exit();\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Assumes caller has synchronized on mStoredSequence\r\n    private long nextUnadjustedValue() throws FetchException, PersistException {\r\n        if (mHasReservedValues) {\r\n            long next = mNextValue + mIncrement;\r\n            mNextValue = next;\r\n            if (next < mStoredSequence.getNextValue()) {\r\n                return next;\r\n            }\r\n            mHasReservedValues = false;\r\n        }\r\n        Transaction txn = mRepository.enterTopTransaction(null);\r\n        txn.setForUpdate(true);\r\n        try {\r\n            // Assume that StoredSequence is stale, so reload.\r\n            mStoredSequence.load();\r\n            long next = mStoredSequence.getNextValue();\r\n            long nextStored = next + mReserveAmount * mIncrement;\r\n            if (next >= 0 && nextStored < 0) {\r\n                // Wrapped around. There might be just a few values left.\r\n                long avail = (Long.MAX_VALUE - next) / mIncrement;\r\n                if (avail > 0) {\r\n                    nextStored = next + avail * mIncrement;\r\n                } else {\r\n                    // insert operations, and inserts can only throw PersistExceptions.\r\n                    throw new PersistException(\"Sequence exhausted: \" + mStoredSequence.getName());\r\n                }\r\n            }\r\n            mStoredSequence.setNextValue(nextStored);\r\n            mStoredSequence.update();\r\n            txn.commit();\r\n            mNextValue = next;\r\n            mHasReservedValues = true;\r\n            return next;\r\n        } finally {\r\n            txn.exit();\r\n        }\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "2b46d2e3610792acb1ccf25a6d577dfc0881f980", "ext": "java", "lang": "Java", "content": "public class URLClassLoader extends SecureClassLoader {\n\n    URL[] urls;\n\n    ClassLoaderURLHandler[] handlers;\n\n    private static boolean verbose = false;\n\n    private static void debug(String s) {\n        if (verbose) {\n            System.err.println(s);\n        }\n    }\n\n    private static final Manifest emptyMan = new Manifest();\n\n    private static void permissionCheck() {\n        // Note: we assume that java.net is a restricted package.\n        if (wonka.vm.SecurityConfiguration.ENABLE_SECURITY_CHECKS) {\n            SecurityManager sm = System.getSecurityManager();\n            if (sm != null) {\n                sm.checkPackageAccess(\"java.net\");\n            }\n        }\n    }\n\n    public URLClassLoader(URL[] urls) throws SecurityException {\n        debug(\"Loading: create URL handlers for \" + this);\n        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n        this.urls = urls;\n    }\n\n    public URLClassLoader(URL[] urls, ClassLoader parent) throws SecurityException {\n        super(parent);\n        debug(\"Loading: create URL handlers for \" + this);\n        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n        this.urls = urls;\n    }\n\n    public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) throws SecurityException {\n        super(parent);\n        debug(\"Loading: create URL handlers for \" + this);\n        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n        this.urls = urls;\n    }\n\n    public static URLClassLoader newInstance(final URL[] urls) throws SecurityException {\n        permissionCheck();\n        //TODO: do as a privileged action\n        return new URLClassLoader(urls);\n    }\n\n    public static URLClassLoader newInstance(final URL[] urls, ClassLoader parent) throws SecurityException {\n        permissionCheck();\n        //TODO: do as a privileged action\n        return new URLClassLoader(urls, parent);\n    }\n\n    protected void addURL(URL url) {\n        debug(\"Loading: add URL handler to \" + this);\n        ClassLoaderURLHandler handler = ClassLoaderURLHandler.createClassLoaderURLHandler(url);\n        debug(\"Loading: new URL handler = \" + handler);\n        int length = handlers.length;\n        ClassLoaderURLHandler[] newhandlers = new ClassLoaderURLHandler[length + 1];\n        System.arraycopy(handlers, 0, newhandlers, 0, length);\n        newhandlers[length] = handler;\n        handlers = newhandlers;\n        URL[] newurls = new URL[urls.length + 1];\n        System.arraycopy(urls, 0, newurls, 0, urls.length);\n        newurls[urls.length] = url;\n        urls = newurls;\n    }\n\n    protected Package definePackage(String pname, Manifest man, URL url) throws IllegalArgumentException {\n        Attributes attr = man.getMainAttributes();\n        String specTitle = attr.getValue(\"Specification-Title\");\n        String specVersion = attr.getValue(\"Specification-Version\");\n        String specVendor = attr.getValue(\"Specification-Vendor\");\n        String implTitle = attr.getValue(\"Implementation-Title\");\n        String implVersion = attr.getValue(\"Implementation-Version\");\n        String implVendor = attr.getValue(\"Implementation-Vendor\");\n        return definePackage(pname, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, url);\n    }\n\n    protected Class findClass(String name) throws ClassNotFoundException {\n        String filename = name.replace('.', '/') + \".class\";\n        int l = handlers.length;\n        int i = 0;\n        while (i < l) try {\n            ClassLoaderURLHandler handler = handlers[i];\n            byte[] bytes = handler.getByteArray(filename);\n            if (bytes != null) {\n                URL url = urls[i];\n                int idx = name.lastIndexOf('.');\n                String pname = name.substring(0, idx == -1 ? 0 : idx);\n                // TODO: get manifest right\n                if (getPackage(pname) == null) {\n                    definePackage(pname, handler.getManifest(), url);\n                }\n                if (url.getProtocol().equals(\"jar\")) {\n                    String u = (\"\" + url).substring(4);\n                    u = u.substring(0, u.indexOf('!'));\n                    try {\n                        url = new URL(u);\n                    } catch (Exception e) {\n                    }\n                }\n                return defineClass(name, bytes, 0, bytes.length, new CodeSource(url, (java.security.cert.Certificate[]) null));\n            }\n        } finally {\n            i++;\n        }\n        throw new ClassNotFoundException(name);\n    }\n\n    public URL findResource(String name) {\n        int l = handlers.length;\n        int i = 0;\n        while (i < l) try {\n            ClassLoaderURLHandler handler = handlers[i];\n            URL url = handler.getURL(name);\n            if (url != null) {\n                return url;\n            }\n        } finally {\n            i++;\n        }\n        return null;\n    }\n\n    public Enumeration findResources(String name) throws IOException {\n        // TODO; wasn't there something about leading slash?\n        int l = handlers.length;\n        Vector v = new Vector(l);\n        int i = 0;\n        while (i < l) try {\n            ClassLoaderURLHandler handler = handlers[i];\n            URL url = handler.getURL(name);\n            if (url != null) {\n                v.add(url);\n            }\n        } finally {\n            i++;\n        }\n        return v.elements();\n    }\n\n    protected PermissionCollection getPermissions(CodeSource codes) {\n        PermissionCollection pc = super.getPermissions(codes);\n        //ToDo add extra permissions to allow usage of the URL's\n        return pc;\n    }\n\n    /**\n     * * returns a clone of the original URL array (for securiry reasons).\n     */\n    public URL[] getURLs() {\n        return (URL[]) urls.clone();\n    }\n}\n", "class_id": 0, "repo": "kifferltd/open-mika", "file": "core-vm/java/java/net/URLClassLoader.java", "last_update_at": "2021-11-28T20:18:59+00:00", "original_content": "public class URLClassLoader extends SecureClassLoader {\n\n    URL[] urls;\n\n    ClassLoaderURLHandler[] handlers;\n\n    private static boolean verbose = false;\n\n    private static void debug(String s) {\n        if (verbose) {\n            System.err.println(s);\n        }\n    }\n\n    private static final Manifest emptyMan = new Manifest();\n\n    private static void permissionCheck() {\n        // Note: we assume that java.net is a restricted package.\n        if (wonka.vm.SecurityConfiguration.ENABLE_SECURITY_CHECKS) {\n            SecurityManager sm = System.getSecurityManager();\n            if (sm != null) {\n                sm.checkPackageAccess(\"java.net\");\n            }\n        }\n    }\n\n    public URLClassLoader(URL[] urls) throws SecurityException {\n        debug(\"Loading: create URL handlers for \" + this);\n        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n        this.urls = urls;\n    }\n\n    public URLClassLoader(URL[] urls, ClassLoader parent) throws SecurityException {\n        super(parent);\n        debug(\"Loading: create URL handlers for \" + this);\n        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n        this.urls = urls;\n    }\n\n    public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) throws SecurityException {\n        super(parent);\n        debug(\"Loading: create URL handlers for \" + this);\n        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);\n        this.urls = urls;\n    }\n\n    public static URLClassLoader newInstance(final URL[] urls) throws SecurityException {\n        permissionCheck();\n        //TODO: do as a privileged action\n        return new URLClassLoader(urls);\n    }\n\n    public static URLClassLoader newInstance(final URL[] urls, ClassLoader parent) throws SecurityException {\n        permissionCheck();\n        //TODO: do as a privileged action\n        return new URLClassLoader(urls, parent);\n    }\n\n    protected void addURL(URL url) {\n        debug(\"Loading: add URL handler to \" + this);\n        ClassLoaderURLHandler handler = ClassLoaderURLHandler.createClassLoaderURLHandler(url);\n        debug(\"Loading: new URL handler = \" + handler);\n        int length = handlers.length;\n        ClassLoaderURLHandler[] newhandlers = new ClassLoaderURLHandler[length + 1];\n        System.arraycopy(handlers, 0, newhandlers, 0, length);\n        newhandlers[length] = handler;\n        handlers = newhandlers;\n        URL[] newurls = new URL[urls.length + 1];\n        System.arraycopy(urls, 0, newurls, 0, urls.length);\n        newurls[urls.length] = url;\n        urls = newurls;\n    }\n\n    protected Package definePackage(String pname, Manifest man, URL url) throws IllegalArgumentException {\n        Attributes attr = man.getMainAttributes();\n        String specTitle = attr.getValue(\"Specification-Title\");\n        String specVersion = attr.getValue(\"Specification-Version\");\n        String specVendor = attr.getValue(\"Specification-Vendor\");\n        String implTitle = attr.getValue(\"Implementation-Title\");\n        String implVersion = attr.getValue(\"Implementation-Version\");\n        String implVendor = attr.getValue(\"Implementation-Vendor\");\n        return definePackage(pname, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, url);\n    }\n\n    protected Class findClass(String name) throws ClassNotFoundException {\n        String filename = name.replace('.', '/') + \".class\";\n        int l = handlers.length;\n        for (int i = 0; i < l; i++) {\n            ClassLoaderURLHandler handler = handlers[i];\n            byte[] bytes = handler.getByteArray(filename);\n            if (bytes != null) {\n                URL url = urls[i];\n                int idx = name.lastIndexOf('.');\n                String pname = name.substring(0, idx == -1 ? 0 : idx);\n                // TODO: get manifest right\n                if (getPackage(pname) == null) {\n                    definePackage(pname, handler.getManifest(), url);\n                }\n                if (url.getProtocol().equals(\"jar\")) {\n                    String u = (\"\" + url).substring(4);\n                    u = u.substring(0, u.indexOf('!'));\n                    try {\n                        url = new URL(u);\n                    } catch (Exception e) {\n                    }\n                }\n                return defineClass(name, bytes, 0, bytes.length, new CodeSource(url, (java.security.cert.Certificate[]) null));\n            }\n        }\n        throw new ClassNotFoundException(name);\n    }\n\n    public URL findResource(String name) {\n        int l = handlers.length;\n        for (int i = 0; i < l; i++) {\n            ClassLoaderURLHandler handler = handlers[i];\n            URL url = handler.getURL(name);\n            if (url != null) {\n                return url;\n            }\n        }\n        return null;\n    }\n\n    public Enumeration findResources(String name) throws IOException {\n        // TODO; wasn't there something about leading slash?\n        int l = handlers.length;\n        Vector v = new Vector(l);\n        for (int i = 0; i < l; i++) {\n            ClassLoaderURLHandler handler = handlers[i];\n            URL url = handler.getURL(name);\n            if (url != null) {\n                v.add(url);\n            }\n        }\n        return v.elements();\n    }\n\n    protected PermissionCollection getPermissions(CodeSource codes) {\n        PermissionCollection pc = super.getPermissions(codes);\n        //ToDo add extra permissions to allow usage of the URL's\n        return pc;\n    }\n\n    /**\n     * * returns a clone of the original URL array (for securiry reasons).\n     */\n    public URL[] getURLs() {\n        return (URL[]) urls.clone();\n    }\n}\n", "refactored": true}
{"hexsha": "226b487adf17fcdc413f042460759648247259d6", "ext": "java", "lang": "Java", "content": "public class PC2LogViewer extends PC2Console {\r\n\r\n    public PC2LogViewer(JScrollPane scroll, PC2TextPane pane) {\r\n        super(scroll, pane);\r\n        pane.wrapText = false;\r\n    }\r\n\r\n    public void appendLog(String s) throws IllegalArgumentException {\r\n        boolean error = false;\r\n        boolean fatal = false;\r\n        boolean warn = false;\r\n        boolean info = false;\r\n        boolean debug = false;\r\n        boolean trace = false;\r\n        if (s != null) {\r\n            if (s.length() >= 29) {\r\n                String level = s.substring(24, 29);\r\n                if (level.equals(\"DEBUG\"))\r\n                    debug = true;\r\n                else if (level.equals(\"INFO \"))\r\n                    info = true;\r\n                else if (level.equals(\"WARN \"))\r\n                    warn = true;\r\n                else if (level.equals(\"ERROR\"))\r\n                    error = true;\r\n                else if (level.equals(\"TRACE\"))\r\n                    trace = true;\r\n                else if (level.equals(\"FATAL\"))\r\n                    fatal = true;\r\n                if (fatal)\r\n                    textPane.append(s, FATAL, RED);\r\n                else if (error) {\r\n                    if (s.contains(\"ERROR  VERIFY FAILED\"))\r\n                        textPane.append(s, VERIFY, RED);\r\n                    else\r\n                        textPane.append(s, ERROR, RED);\r\n                } else if (info) {\r\n                    if (s.contains(\">>>>> RX:\")) {\r\n                        textPane.append(s, MSG, GREEN);\r\n                    } else if (s.contains(\"<<<<< TX:\")) {\r\n                        textPane.append(s, MSG, ORANGE);\r\n                    } else if (s.contains(\"INFO   USER:\"))\r\n                        textPane.append(s, PROMPT, BLUE);\r\n                    else if (s.contains(\"INFO  Test \")) {\r\n                        if (s.contains(\"Passed.\"))\r\n                            textPane.append(s, FATAL, GREEN);\r\n                        else if (s.contains(\"Failed.\"))\r\n                            appendFailedTestResults(s);\r\n                    } else if (s.contains(\"INFO  Commencing test\")) {\r\n                        textPane.append(s, FATAL, GREEN);\r\n                    } else if (s.contains(\"INFO  VERIFY PASSED\"))\r\n                        textPane.append(s, VERIFY, BLUE);\r\n                    else\r\n                        textPane.append(s, INFO, NORMAL);\r\n                } else if (warn)\r\n                    textPane.append(s, WARN, DK_YELLOW);\r\n                else if (debug)\r\n                    textPane.append(s, DEBUG, DK_GRAY);\r\n                else if (trace)\r\n                    textPane.append(s, TRACE, GRAY);\r\n                else\r\n                    textPane.append(s, INFO, NORMAL);\r\n            } else\r\n                textPane.append(s, INFO, NORMAL);\r\n        } else {\r\n            throw new IllegalArgumentException(\"LogViewer doesn't allow a null string for an argument.\");\r\n        }\r\n    }\r\n\r\n    public void appendConsole(String s) throws IllegalArgumentException {\r\n        boolean error = false;\r\n        boolean fatal = false;\r\n        boolean warn = false;\r\n        boolean info = false;\r\n        boolean debug = false;\r\n        boolean trace = false;\r\n        if (s != null) {\r\n            if (s.length() >= 5) {\r\n                String level = s.substring(0, 5);\r\n                if (level.equals(\"DEBUG\"))\r\n                    debug = true;\r\n                else if (level.equals(\"INFO \"))\r\n                    info = true;\r\n                else if (level.equals(\"WARN \"))\r\n                    warn = true;\r\n                else if (level.equals(\"ERROR\"))\r\n                    error = true;\r\n                else if (level.equals(\"TRACE\"))\r\n                    trace = true;\r\n                else if (level.equals(\"FATAL\"))\r\n                    fatal = true;\r\n                if (fatal)\r\n                    textPane.append(s, FATAL, RED);\r\n                else if (error) {\r\n                    if (s.contains(\"ERROR  VERIFY FAILED\"))\r\n                        textPane.append(s, VERIFY, RED);\r\n                    else\r\n                        textPane.append(s, ERROR, RED);\r\n                } else if (info) {\r\n                    if (s.startsWith(\"INFO  >>>>> RX:\")) {\r\n                        textPane.append(s, MSG, GREEN);\r\n                    } else if (s.startsWith(\"INFO  <<<<< TX:\")) {\r\n                        textPane.append(s, MSG, ORANGE);\r\n                    } else if (s.startsWith(\"INFO   USER:\"))\r\n                        textPane.append(s, PROMPT, BLUE);\r\n                    else if (s.startsWith(\"INFO  Test \")) {\r\n                        if (s.contains(\"Passed.\"))\r\n                            textPane.append(s, FATAL, GREEN);\r\n                        else if (s.contains(\"Failed.\"))\r\n                            appendFailedTestResults(s);\r\n                    } else if (s.startsWith(\"INFO  Commencing test\")) {\r\n                        textPane.append(s, FATAL, GREEN);\r\n                    } else if (s.startsWith(\"INFO  \\n\\tVendor: \")) {\r\n                        textPane.append(s, MSG, BLUE);\r\n                    } else if (s.contains(\"INFO  VERIFY PASSED\"))\r\n                        textPane.append(s, VERIFY, BLUE);\r\n                    else\r\n                        textPane.append(s, INFO, NORMAL);\r\n                } else if (warn)\r\n                    textPane.append(s, WARN, DK_YELLOW);\r\n                else if (debug)\r\n                    textPane.append(s, DEBUG, DK_GRAY);\r\n                else if (trace)\r\n                    textPane.append(s, TRACE, GRAY);\r\n                else\r\n                    textPane.append(s, INFO, NORMAL);\r\n            } else\r\n                textPane.append(s, INFO, NORMAL);\r\n        }\r\n    }\r\n\r\n    private void appendFailedTestResults(String s) {\r\n        // passed.\r\n        StringTokenizer st = new StringTokenizer(s, \"\\n\");\r\n        for (; st.hasMoreTokens(); ) {\r\n            String temp = st.nextToken();\r\n            if (temp.contains(\"Passed\"))\r\n                textPane.append((temp + \"\\n\"), FATAL, GREEN);\r\n            else\r\n                textPane.append((temp + \"\\n\"), FATAL, RED);\r\n        }\r\n    }\r\n\r\n    public boolean isConsoleLog(String msg) {\r\n        if (msg.startsWith(\"DEBUG \") || msg.startsWith(\"INFO \") || msg.startsWith(\"WARN \") || msg.startsWith(\"ERROR \") || msg.startsWith(\"TRACE \") || msg.startsWith(\"FATAL \"))\r\n            return true;\r\n        return false;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "tinours/PCSim2", "file": "src/com/cablelabs/gui/PC2LogViewer.java", "last_update_at": "2021-04-30T18:47:15+00:00", "original_content": "public class PC2LogViewer extends PC2Console {\r\n\r\n    public PC2LogViewer(JScrollPane scroll, PC2TextPane pane) {\r\n        super(scroll, pane);\r\n        pane.wrapText = false;\r\n    }\r\n\r\n    public void appendLog(String s) throws IllegalArgumentException {\r\n        boolean error = false;\r\n        boolean fatal = false;\r\n        boolean warn = false;\r\n        boolean info = false;\r\n        boolean debug = false;\r\n        boolean trace = false;\r\n        if (s != null) {\r\n            if (s.length() >= 29) {\r\n                String level = s.substring(24, 29);\r\n                if (level.equals(\"DEBUG\"))\r\n                    debug = true;\r\n                else if (level.equals(\"INFO \"))\r\n                    info = true;\r\n                else if (level.equals(\"WARN \"))\r\n                    warn = true;\r\n                else if (level.equals(\"ERROR\"))\r\n                    error = true;\r\n                else if (level.equals(\"TRACE\"))\r\n                    trace = true;\r\n                else if (level.equals(\"FATAL\"))\r\n                    fatal = true;\r\n                if (fatal)\r\n                    textPane.append(s, FATAL, RED);\r\n                else if (error) {\r\n                    if (s.contains(\"ERROR  VERIFY FAILED\"))\r\n                        textPane.append(s, VERIFY, RED);\r\n                    else\r\n                        textPane.append(s, ERROR, RED);\r\n                } else if (info) {\r\n                    if (s.contains(\">>>>> RX:\")) {\r\n                        textPane.append(s, MSG, GREEN);\r\n                    } else if (s.contains(\"<<<<< TX:\")) {\r\n                        textPane.append(s, MSG, ORANGE);\r\n                    } else if (s.contains(\"INFO   USER:\"))\r\n                        textPane.append(s, PROMPT, BLUE);\r\n                    else if (s.contains(\"INFO  Test \")) {\r\n                        if (s.contains(\"Passed.\"))\r\n                            textPane.append(s, FATAL, GREEN);\r\n                        else if (s.contains(\"Failed.\"))\r\n                            appendFailedTestResults(s);\r\n                    } else if (s.contains(\"INFO  Commencing test\")) {\r\n                        textPane.append(s, FATAL, GREEN);\r\n                    } else if (s.contains(\"INFO  VERIFY PASSED\"))\r\n                        textPane.append(s, VERIFY, BLUE);\r\n                    else\r\n                        textPane.append(s, INFO, NORMAL);\r\n                } else if (warn)\r\n                    textPane.append(s, WARN, DK_YELLOW);\r\n                else if (debug)\r\n                    textPane.append(s, DEBUG, DK_GRAY);\r\n                else if (trace)\r\n                    textPane.append(s, TRACE, GRAY);\r\n                else\r\n                    textPane.append(s, INFO, NORMAL);\r\n            } else\r\n                textPane.append(s, INFO, NORMAL);\r\n        } else {\r\n            throw new IllegalArgumentException(\"LogViewer doesn't allow a null string for an argument.\");\r\n        }\r\n    }\r\n\r\n    public void appendConsole(String s) throws IllegalArgumentException {\r\n        boolean error = false;\r\n        boolean fatal = false;\r\n        boolean warn = false;\r\n        boolean info = false;\r\n        boolean debug = false;\r\n        boolean trace = false;\r\n        if (s != null) {\r\n            if (s.length() >= 5) {\r\n                String level = s.substring(0, 5);\r\n                if (level.equals(\"DEBUG\"))\r\n                    debug = true;\r\n                else if (level.equals(\"INFO \"))\r\n                    info = true;\r\n                else if (level.equals(\"WARN \"))\r\n                    warn = true;\r\n                else if (level.equals(\"ERROR\"))\r\n                    error = true;\r\n                else if (level.equals(\"TRACE\"))\r\n                    trace = true;\r\n                else if (level.equals(\"FATAL\"))\r\n                    fatal = true;\r\n                if (fatal)\r\n                    textPane.append(s, FATAL, RED);\r\n                else if (error) {\r\n                    if (s.contains(\"ERROR  VERIFY FAILED\"))\r\n                        textPane.append(s, VERIFY, RED);\r\n                    else\r\n                        textPane.append(s, ERROR, RED);\r\n                } else if (info) {\r\n                    if (s.startsWith(\"INFO  >>>>> RX:\")) {\r\n                        textPane.append(s, MSG, GREEN);\r\n                    } else if (s.startsWith(\"INFO  <<<<< TX:\")) {\r\n                        textPane.append(s, MSG, ORANGE);\r\n                    } else if (s.startsWith(\"INFO   USER:\"))\r\n                        textPane.append(s, PROMPT, BLUE);\r\n                    else if (s.startsWith(\"INFO  Test \")) {\r\n                        if (s.contains(\"Passed.\"))\r\n                            textPane.append(s, FATAL, GREEN);\r\n                        else if (s.contains(\"Failed.\"))\r\n                            appendFailedTestResults(s);\r\n                    } else if (s.startsWith(\"INFO  Commencing test\")) {\r\n                        textPane.append(s, FATAL, GREEN);\r\n                    } else if (s.startsWith(\"INFO  \\n\\tVendor: \")) {\r\n                        textPane.append(s, MSG, BLUE);\r\n                    } else if (s.contains(\"INFO  VERIFY PASSED\"))\r\n                        textPane.append(s, VERIFY, BLUE);\r\n                    else\r\n                        textPane.append(s, INFO, NORMAL);\r\n                } else if (warn)\r\n                    textPane.append(s, WARN, DK_YELLOW);\r\n                else if (debug)\r\n                    textPane.append(s, DEBUG, DK_GRAY);\r\n                else if (trace)\r\n                    textPane.append(s, TRACE, GRAY);\r\n                else\r\n                    textPane.append(s, INFO, NORMAL);\r\n            } else\r\n                textPane.append(s, INFO, NORMAL);\r\n        }\r\n    }\r\n\r\n    private void appendFailedTestResults(String s) {\r\n        // passed.\r\n        StringTokenizer st = new StringTokenizer(s, \"\\n\");\r\n        while (st.hasMoreTokens()) {\r\n            String temp = st.nextToken();\r\n            if (temp.contains(\"Passed\"))\r\n                textPane.append((temp + \"\\n\"), FATAL, GREEN);\r\n            else\r\n                textPane.append((temp + \"\\n\"), FATAL, RED);\r\n        }\r\n    }\r\n\r\n    public boolean isConsoleLog(String msg) {\r\n        if (msg.startsWith(\"DEBUG \") || msg.startsWith(\"INFO \") || msg.startsWith(\"WARN \") || msg.startsWith(\"ERROR \") || msg.startsWith(\"TRACE \") || msg.startsWith(\"FATAL \"))\r\n            return true;\r\n        return false;\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "3e54953c33cebf7c63898e13b7923b8e6bea2173", "ext": "java", "lang": "Java", "content": "class DefinitionYamlParser<T> implements DefinitionParser<Map<String, Map<String, T>>> {\n\n    private final Yaml yaml;\n\n    private DefinitionYamlParser() {\n        yaml = new Yaml();\n    }\n\n    public static <T> DefinitionParser<Map<String, Map<String, T>>> of() {\n        return new DefinitionYamlParser<>();\n    }\n\n    @Override\n    public Map<String, Map<String, T>> parse(InputStream in) {\n        Iterable<Object> iterableYaml = yaml.loadAll(in);\n        Iterator<Object> iterator = iterableYaml.iterator();\n        return (Map<String, Map<String, T>>) iterator.next();\n    }\n}\n", "class_id": 0, "repo": "wolfmanfp/fackito", "file": "src/main/java/com/fackito/definition/parser/yaml/DefinitionYamlParser.java", "last_update_at": "2021-11-30T11:51:19+00:00", "original_content": "class DefinitionYamlParser<T> implements DefinitionParser<Map<String, Map<String, T>>> {\n\n    private final Yaml yaml;\n\n    private DefinitionYamlParser() {\n        yaml = new Yaml();\n    }\n\n    public static <T> DefinitionParser<Map<String, Map<String, T>>> of() {\n        return new DefinitionYamlParser<>();\n    }\n\n    @Override\n    public Map<String, Map<String, T>> parse(InputStream in) {\n        Iterable<Object> iterableYaml = yaml.loadAll(in);\n        Iterator<Object> iterator = iterableYaml.iterator();\n        return (Map<String, Map<String, T>>) iterator.next();\n    }\n}\n", "refactored": false}
{"hexsha": "be1bff23924fd033faba7e753f5dc995c667f3c0", "ext": "java", "lang": "Java", "content": "class ThreadLocalVersionHolderTest {\r\n\r\n    private final Version version = Version.of(1324, 5);\r\n\r\n    private final Version localVersion = Version.of(345465, 435);\r\n\r\n    @Test\r\n    void testGetVersionInSameThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n        assertEquals(version, ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInSameThreadWhenNotInitialized() {\r\n        assertEquals(Version.empty(), ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInAnotherThreadWhenInitializedInsideThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n        CompletableFuture.runAsync(() -> {\r\n            ThreadLocalVersionHolder.initialize(localVersion);\r\n            assertEquals(localVersion, ThreadLocalVersionHolder.get().getVersion());\r\n        }).join();\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionWhenSwitched() {\r\n        Version first = Version.of(123, 123);\r\n        Version second = Version.of(546546, 1);\r\n        VersionHolder versionHolder = ThreadLocalVersionHolder.get();\r\n        ThreadLocalVersionHolder.initialize(first);\r\n        assertEquals(first, versionHolder.getVersion());\r\n        ThreadLocalVersionHolder.initialize(second);\r\n        assertEquals(second, versionHolder.getVersion());\r\n    }\r\n}\r\n", "class_id": 0, "repo": "liveisgood8/jackson-versioning-module", "file": "core/src/test/java/io/github/liveisgood8/jacksonversioning/holder/ThreadLocalVersionHolderTest.java", "last_update_at": "2021-11-03T16:43:23+00:00", "original_content": "class ThreadLocalVersionHolderTest {\r\n\r\n    private final Version version = Version.of(1324, 5);\r\n\r\n    private final Version localVersion = Version.of(345465, 435);\r\n\r\n    @Test\r\n    void testGetVersionInSameThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n        assertEquals(version, ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInSameThreadWhenNotInitialized() {\r\n        assertEquals(Version.empty(), ThreadLocalVersionHolder.get().getVersion());\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionInAnotherThreadWhenInitializedInsideThread() {\r\n        ThreadLocalVersionHolder.initialize(version);\r\n        CompletableFuture.runAsync(() -> {\r\n            ThreadLocalVersionHolder.initialize(localVersion);\r\n            assertEquals(localVersion, ThreadLocalVersionHolder.get().getVersion());\r\n        }).join();\r\n    }\r\n\r\n    @Test\r\n    void testGetVersionWhenSwitched() {\r\n        Version first = Version.of(123, 123);\r\n        Version second = Version.of(546546, 1);\r\n        VersionHolder versionHolder = ThreadLocalVersionHolder.get();\r\n        ThreadLocalVersionHolder.initialize(first);\r\n        assertEquals(first, versionHolder.getVersion());\r\n        ThreadLocalVersionHolder.initialize(second);\r\n        assertEquals(second, versionHolder.getVersion());\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "c97f14a7bf5ef3debf95529c86f3c6c29665f8e0", "ext": "java", "lang": "Java", "content": "public class Main {\n\n    public static void main(String[] args) {\n        LinkedList<Integer> linkedList = new LinkedList<Integer>();\n        linkedList.add(3);\n        linkedList.add(8);\n        System.out.println(\"Integer linked list content: \" + linkedList);\n        LinkedList<String> linkedList2 = new LinkedList<String>();\n        linkedList2.add(\"foo\");\n        linkedList2.add(\"bar\");\n        linkedList2.add(\"baz\");\n        linkedList2.add(\"qux\");\n        System.out.println(\"String linked list content: \" + linkedList2);\n        try {\n            System.out.println(\"The second String contains \" + linkedList2.get(1).length() + \" letters.\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n        if (linkedList2.contains(\"baz\")) {\n            System.out.println(\"The String linked list contains the word 'baz'.\");\n        }\n        if (!linkedList2.contains(\"quux\")) {\n            System.out.println(\"The String linked list does not contain the word 'quux'.\");\n        }\n    }\n}\n", "class_id": 0, "repo": "vscav/java-lab", "file": "TD09/src/fr/umlv/data/main/Main.java", "last_update_at": "2021-02-27T20:20:38+00:00", "original_content": "public class Main {\n\n    public static void main(String[] args) {\n        LinkedList<Integer> linkedList = new LinkedList<Integer>();\n        linkedList.add(3);\n        linkedList.add(8);\n        System.out.println(\"Integer linked list content: \" + linkedList);\n        LinkedList<String> linkedList2 = new LinkedList<String>();\n        linkedList2.add(\"foo\");\n        linkedList2.add(\"bar\");\n        linkedList2.add(\"baz\");\n        linkedList2.add(\"qux\");\n        System.out.println(\"String linked list content: \" + linkedList2);\n        try {\n            System.out.println(\"The second String contains \" + linkedList2.get(1).length() + \" letters.\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n        if (linkedList2.contains(\"baz\")) {\n            System.out.println(\"The String linked list contains the word 'baz'.\");\n        }\n        if (!linkedList2.contains(\"quux\")) {\n            System.out.println(\"The String linked list does not contain the word 'quux'.\");\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "fe59e73e25558d873a94e9fc5c1225b2bb48a8de", "ext": "java", "lang": "Java", "content": "public class WheelOfFortune extends SubsystemBase {\n\n    //Create necessary objects\n    private static ColorSensorV3 m_colorSensor;\n\n    private static WPI_VictorSPX m_spinWheel;\n\n    private static Solenoid m_wheelArm;\n\n    private Map<String, String> fieldToTargetColorMap = new HashMap<String, String>();\n\n    private double lastTimestamp;\n\n    private boolean isChanged;\n\n    private boolean isCounted;\n\n    private String actualColor;\n\n    private float deg = 0;\n\n    private float sat = 0;\n\n    private float brightness = 0;\n\n    private Thread interrogator;\n\n    private int cachedR = 0;\n\n    private int cachedG = 0;\n\n    private int cachedB = 0;\n\n    private class InterrogationLoop implements Runnable {\n\n        public void run() {\n            try {\n                // These three operations can run away waiting for i2c synchronization\n                int r = m_colorSensor.getRed();\n                int g = m_colorSensor.getGreen();\n                int b = m_colorSensor.getBlue();\n                // Now as we are back we can update the cache at once\n                cachedR = r;\n                cachedG = g;\n                cachedB = b;\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                DriverStation.reportError(\"Thread \" + Thread.currentThread().getName() + \" got interrupted\", true);\n                return;\n            }\n        }\n    }\n\n    private static final WheelOfFortune instance = new WheelOfFortune();\n\n    public static WheelOfFortune getInstance() {\n        return instance;\n    }\n\n    private WheelOfFortune() {\n        m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);\n        m_spinWheel = new WPI_VictorSPX(RobotMap.CAN_WHEELOFFORTUNE);\n        m_spinWheel.configFactoryDefault();\n        m_spinWheel.setNeutralMode(NeutralMode.Brake);\n        isChanged = false;\n        m_wheelArm = new Solenoid(RobotMap.CAN_PNMMODULE, RobotMap.PNM_WHEELARM);\n        m_wheelArm.set(false);\n        //This is the Map for converting the fieldColor into targetColor, which can be used to clear a lot of confusion while making the algorithm\n        fieldToTargetColorMap.put(\"Blue\", \"Red\");\n        fieldToTargetColorMap.put(\"Green\", \"Yellow\");\n        fieldToTargetColorMap.put(\"Red\", \"Blue\");\n        fieldToTargetColorMap.put(\"Yellow\", \"Green\");\n        // Initialize color tracker to black\n        actualColor = \"Black\";\n        interrogator = new Thread(new InterrogationLoop(), \"WOF interrogator\");\n        interrogator.start();\n        DriverStation.reportWarning(\"WOF color sensor Init complete\", false);\n    }\n\n    public String getTargetColor(String sourceColor, WheelOfFortune subsystem) {\n        return subsystem.fieldToTargetColorMap.get(sourceColor);\n    }\n\n    public String determineColor() {\n        String possibleColor = this.detectHSB();\n        if (!possibleColor.equals(actualColor)) {\n            if (!isChanged) {\n                lastTimestamp = Timer.getFPGATimestamp();\n                isChanged = true;\n                isCounted = false;\n            } else {\n                if (Timer.getFPGATimestamp() - lastTimestamp > .1 && !isCounted) {\n                    isCounted = true;\n                    isChanged = false;\n                    actualColor = possibleColor;\n                }\n            }\n        } else {\n            isChanged = false;\n        }\n        return actualColor;\n    }\n\n    /**\n     * Run the color match algorithm on our detected color\n     *\n     * @return String name of the most likely color\n     */\n    public String detectHSB() {\n        float[] hsb = java.awt.Color.RGBtoHSB(cachedR, cachedG, cachedB, null);\n        deg = hsb[0] * 360;\n        sat = hsb[1];\n        brightness = hsb[2];\n        //Potential algorithm for rgb to hsb\n        if (sat < 0.3 && brightness > 0.9) {\n            return \"White\";\n        } else if (brightness < 40.0) {\n            return \"Black\";\n        } else {\n            if (deg < 60 || deg > 310) {\n                return \"Red\";\n            } else if (deg < 100) {\n                return \"Yellow\";\n            } else if (deg < 130) {\n                return \"Green\";\n            } else if (deg < 250) {\n                return \"Blue\";\n            } else {\n                return \"Bruh\";\n            }\n        }\n    }\n\n    /**\n     * Method for toggling wheel of fortune manipulator\n     */\n    public void toggleWheel() {\n        //        System.out.println(\"Wheel has toggled\");\n        m_wheelArm.set(!m_wheelArm.get());\n    }\n\n    /**\n     * method for retracting wheel to be called in a command\n     */\n    public void retractWheel() {\n        //        System.out.println(\"Wheel has retracted\");\n        m_wheelArm.set(false);\n    }\n\n    public void motorSpin(double spin) {\n        m_spinWheel.set(ControlMode.PercentOutput, spin);\n    }\n\n    public void outputToShuffleboard(WheelOfFortune subsystem) {\n        SmartDashboard.putString(\"HSB Detected color\", subsystem.detectHSB());\n        //TODO: remove these\n        SmartDashboard.putNumber(\"Hue Degree\", subsystem.deg);\n        SmartDashboard.putNumber(\"Saturation\", subsystem.sat);\n        SmartDashboard.putNumber(\"Brightness\", subsystem.brightness);\n    }\n\n    @Override\n    public void periodic() {\n    }\n}\n", "class_id": 0, "repo": "team3130/Lotus", "file": "src/main/java/frc/team3130/robot/subsystems/WheelOfFortune.java", "last_update_at": "2021-04-08T16:59:07+00:00", "original_content": "public class WheelOfFortune extends SubsystemBase {\n\n    //Create necessary objects\n    private static ColorSensorV3 m_colorSensor;\n\n    private static WPI_VictorSPX m_spinWheel;\n\n    private static Solenoid m_wheelArm;\n\n    private Map<String, String> fieldToTargetColorMap = new HashMap<String, String>();\n\n    private double lastTimestamp;\n\n    private boolean isChanged;\n\n    private boolean isCounted;\n\n    private String actualColor;\n\n    private float deg = 0;\n\n    private float sat = 0;\n\n    private float brightness = 0;\n\n    private Thread interrogator;\n\n    private int cachedR = 0;\n\n    private int cachedG = 0;\n\n    private int cachedB = 0;\n\n    private class InterrogationLoop implements Runnable {\n\n        public void run() {\n            try {\n                // These three operations can run away waiting for i2c synchronization\n                int r = m_colorSensor.getRed();\n                int g = m_colorSensor.getGreen();\n                int b = m_colorSensor.getBlue();\n                // Now as we are back we can update the cache at once\n                cachedR = r;\n                cachedG = g;\n                cachedB = b;\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                DriverStation.reportError(\"Thread \" + Thread.currentThread().getName() + \" got interrupted\", true);\n                return;\n            }\n        }\n    }\n\n    private static final WheelOfFortune instance = new WheelOfFortune();\n\n    public static WheelOfFortune getInstance() {\n        return instance;\n    }\n\n    private WheelOfFortune() {\n        m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);\n        m_spinWheel = new WPI_VictorSPX(RobotMap.CAN_WHEELOFFORTUNE);\n        m_spinWheel.configFactoryDefault();\n        m_spinWheel.setNeutralMode(NeutralMode.Brake);\n        isChanged = false;\n        m_wheelArm = new Solenoid(RobotMap.CAN_PNMMODULE, RobotMap.PNM_WHEELARM);\n        m_wheelArm.set(false);\n        //This is the Map for converting the fieldColor into targetColor, which can be used to clear a lot of confusion while making the algorithm\n        fieldToTargetColorMap.put(\"Blue\", \"Red\");\n        fieldToTargetColorMap.put(\"Green\", \"Yellow\");\n        fieldToTargetColorMap.put(\"Red\", \"Blue\");\n        fieldToTargetColorMap.put(\"Yellow\", \"Green\");\n        // Initialize color tracker to black\n        actualColor = \"Black\";\n        interrogator = new Thread(new InterrogationLoop(), \"WOF interrogator\");\n        interrogator.start();\n        DriverStation.reportWarning(\"WOF color sensor Init complete\", false);\n    }\n\n    public String getTargetColor(String sourceColor, WheelOfFortune subsystem) {\n        return subsystem.fieldToTargetColorMap.get(sourceColor);\n    }\n\n    public String determineColor() {\n        String possibleColor = this.detectHSB();\n        if (!possibleColor.equals(actualColor)) {\n            if (!isChanged) {\n                lastTimestamp = Timer.getFPGATimestamp();\n                isChanged = true;\n                isCounted = false;\n            } else {\n                if (Timer.getFPGATimestamp() - lastTimestamp > .1 && !isCounted) {\n                    isCounted = true;\n                    isChanged = false;\n                    actualColor = possibleColor;\n                }\n            }\n        } else {\n            isChanged = false;\n        }\n        return actualColor;\n    }\n\n    /**\n     * Run the color match algorithm on our detected color\n     *\n     * @return String name of the most likely color\n     */\n    public String detectHSB() {\n        float[] hsb = java.awt.Color.RGBtoHSB(cachedR, cachedG, cachedB, null);\n        deg = hsb[0] * 360;\n        sat = hsb[1];\n        brightness = hsb[2];\n        //Potential algorithm for rgb to hsb\n        if (sat < 0.3 && brightness > 0.9) {\n            return \"White\";\n        } else if (brightness < 40.0) {\n            return \"Black\";\n        } else {\n            if (deg < 60 || deg > 310) {\n                return \"Red\";\n            } else if (deg < 100) {\n                return \"Yellow\";\n            } else if (deg < 130) {\n                return \"Green\";\n            } else if (deg < 250) {\n                return \"Blue\";\n            } else {\n                return \"Bruh\";\n            }\n        }\n    }\n\n    /**\n     * Method for toggling wheel of fortune manipulator\n     */\n    public void toggleWheel() {\n        //        System.out.println(\"Wheel has toggled\");\n        m_wheelArm.set(!m_wheelArm.get());\n    }\n\n    /**\n     * method for retracting wheel to be called in a command\n     */\n    public void retractWheel() {\n        //        System.out.println(\"Wheel has retracted\");\n        m_wheelArm.set(false);\n    }\n\n    public void motorSpin(double spin) {\n        m_spinWheel.set(ControlMode.PercentOutput, spin);\n    }\n\n    public void outputToShuffleboard(WheelOfFortune subsystem) {\n        SmartDashboard.putString(\"HSB Detected color\", subsystem.detectHSB());\n        //TODO: remove these\n        SmartDashboard.putNumber(\"Hue Degree\", subsystem.deg);\n        SmartDashboard.putNumber(\"Saturation\", subsystem.sat);\n        SmartDashboard.putNumber(\"Brightness\", subsystem.brightness);\n    }\n\n    @Override\n    public void periodic() {\n    }\n}\n", "refactored": false}
{"hexsha": "c7f36a8c5229e6ee24a8be25281e4e42828dbf4e", "ext": "java", "lang": "Java", "content": "@IntentBuilder\npublic class DetailActivity extends AppCompatActivity {\n\n    @Extra\n    String one;\n\n    @Extra\n    String two;\n\n    @Extra\n    @Nullable\n    String three;\n\n    @Extra\n    @Nullable\n    String four;\n\n    @Extra(\"five\")\n    @Nullable\n    String mFive;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        DetailActivityIntentBuilder.inject(getIntent(), this);\n        setContentView(R.layout.activity_detail);\n        ((TextView) findViewById(R.id.one)).setText(one);\n        ((TextView) findViewById(R.id.two)).setText(two);\n        ((TextView) findViewById(R.id.three)).setText(three);\n        ((TextView) findViewById(R.id.four)).setText(four);\n        ((TextView) findViewById(R.id.five)).setText(mFive);\n    }\n}\n", "class_id": 0, "repo": "lsjwzh/IntentBuilder", "file": "sample/src/main/java/se/emilsjolander/intentbuilder/sample/DetailActivity.java", "last_update_at": "2021-04-08T20:22:30+00:00", "original_content": "@IntentBuilder\npublic class DetailActivity extends AppCompatActivity {\n\n    @Extra\n    String one;\n\n    @Extra\n    String two;\n\n    @Extra\n    @Nullable\n    String three;\n\n    @Extra\n    @Nullable\n    String four;\n\n    @Extra(\"five\")\n    @Nullable\n    String mFive;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        DetailActivityIntentBuilder.inject(getIntent(), this);\n        setContentView(R.layout.activity_detail);\n        ((TextView) findViewById(R.id.one)).setText(one);\n        ((TextView) findViewById(R.id.two)).setText(two);\n        ((TextView) findViewById(R.id.three)).setText(three);\n        ((TextView) findViewById(R.id.four)).setText(four);\n        ((TextView) findViewById(R.id.five)).setText(mFive);\n    }\n}\n", "refactored": false}
{"hexsha": "902dc7a95be7bd3c98d3ff6f7bce99c84d3cd716", "ext": "java", "lang": "Java", "content": "public class ExpirationTimeScriptPlugin extends MockScriptPlugin {\n\n    @Override\n    public String pluginScriptLang() {\n        return \"painless\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {\n        final String fieldName = \"expiration_time\";\n        final String script = \" if (ctx._source.expiration_time < params.expiration_time) { \" + \"     ctx._source.expiration_time = params.expiration_time; \" + \" } else { \" + \"     ctx.op = \\\"noop\\\"; \" + \" }\";\n        return Map.of(script, vars -> {\n            Map<String, Object> params = (Map<String, Object>) vars.get(\"params\");\n            Assert.assertNotNull(params);\n            Assert.assertThat(params.keySet(), contains(fieldName));\n            long updatingValue = (long) params.get(fieldName);\n            Map<String, Object> ctx = (Map<String, Object>) vars.get(\"ctx\");\n            Assert.assertNotNull(ctx);\n            Map<String, Object> source = (Map<String, Object>) ctx.get(\"_source\");\n            long currentValue = (long) source.get(fieldName);\n            if (currentValue < updatingValue) {\n                source.put(fieldName, updatingValue);\n            } else {\n                ctx.put(\"op\", \"noop\");\n            }\n            return ctx;\n        });\n    }\n}\n", "class_id": 0, "repo": "SaiKai/elasticsearch", "file": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/async/ExpirationTimeScriptPlugin.java", "last_update_at": "2021-02-09T13:44:10+00:00", "original_content": "public class ExpirationTimeScriptPlugin extends MockScriptPlugin {\n\n    @Override\n    public String pluginScriptLang() {\n        return \"painless\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {\n        final String fieldName = \"expiration_time\";\n        final String script = \" if (ctx._source.expiration_time < params.expiration_time) { \" + \"     ctx._source.expiration_time = params.expiration_time; \" + \" } else { \" + \"     ctx.op = \\\"noop\\\"; \" + \" }\";\n        return Map.of(script, vars -> {\n            Map<String, Object> params = (Map<String, Object>) vars.get(\"params\");\n            Assert.assertNotNull(params);\n            Assert.assertThat(params.keySet(), contains(fieldName));\n            long updatingValue = (long) params.get(fieldName);\n            Map<String, Object> ctx = (Map<String, Object>) vars.get(\"ctx\");\n            Assert.assertNotNull(ctx);\n            Map<String, Object> source = (Map<String, Object>) ctx.get(\"_source\");\n            long currentValue = (long) source.get(fieldName);\n            if (currentValue < updatingValue) {\n                source.put(fieldName, updatingValue);\n            } else {\n                ctx.put(\"op\", \"noop\");\n            }\n            return ctx;\n        });\n    }\n}\n", "refactored": false}
{"hexsha": "91953d73cb626c9bf2be8918e0b871465e2f55ee", "ext": "java", "lang": "Java", "content": "public class DummyProviderTraces {\n\n    static DummyProviderTraces instance = new DummyProviderTraces();\n\n    public static DummyProviderTraces getInstance() {\n        return instance;\n    }\n\n    /**\n     * Flag indicates if test is enabled, so we should trace projects and configs\n     */\n    public volatile boolean enabled;\n\n    private DummyProviderTraces() {\n    }\n\n    Map /*<String, List>*/\n    id2prjTrace = new HashMap();\n\n    Map /*<String, List>*/\n    id2cfgTrace = new HashMap();\n\n    public List getProjectsTrace(Class provider) {\n        String key = provider.getName();\n        if (!id2prjTrace.containsKey(key)) {\n            id2prjTrace.put(key, Collections.synchronizedList(new ArrayList()));\n        }\n        return (List) id2prjTrace.get(key);\n    }\n\n    public List getCfgsTrace(Class provider) {\n        String key = provider.getName();\n        if (!id2cfgTrace.containsKey(key)) {\n            id2cfgTrace.put(key, Collections.synchronizedList(new ArrayList()));\n        }\n        return (List) id2cfgTrace.get(key);\n    }\n\n    public void reset(Class provider) {\n        getProjectsTrace(provider).clear();\n        getCfgsTrace(provider).clear();\n    }\n}\n", "class_id": 0, "repo": "NiSE-Virginia-Tech/Yuerr14-RepeatedFixes", "file": "RepeatedFixes/misc/org/eclipse/cdt/core/internal/index/provider/test/DummyProviderTraces.java", "last_update_at": "2021-03-29T19:54:05+00:00", "original_content": "public class DummyProviderTraces {\n\n    static DummyProviderTraces instance = new DummyProviderTraces();\n\n    public static DummyProviderTraces getInstance() {\n        return instance;\n    }\n\n    /**\n     * Flag indicates if test is enabled, so we should trace projects and configs\n     */\n    public volatile boolean enabled;\n\n    private DummyProviderTraces() {\n    }\n\n    Map /*<String, List>*/\n    id2prjTrace = new HashMap();\n\n    Map /*<String, List>*/\n    id2cfgTrace = new HashMap();\n\n    public List getProjectsTrace(Class provider) {\n        String key = provider.getName();\n        if (!id2prjTrace.containsKey(key)) {\n            id2prjTrace.put(key, Collections.synchronizedList(new ArrayList()));\n        }\n        return (List) id2prjTrace.get(key);\n    }\n\n    public List getCfgsTrace(Class provider) {\n        String key = provider.getName();\n        if (!id2cfgTrace.containsKey(key)) {\n            id2cfgTrace.put(key, Collections.synchronizedList(new ArrayList()));\n        }\n        return (List) id2cfgTrace.get(key);\n    }\n\n    public void reset(Class provider) {\n        getProjectsTrace(provider).clear();\n        getCfgsTrace(provider).clear();\n    }\n}\n", "refactored": false}
{"hexsha": "883288933fee1f2b5717071cb2d9eba2723d9d39", "ext": "java", "lang": "Java", "content": "public class TCRMPhoneNumberBObjType extends CommonBObjType implements java.io.Serializable {\n\n    private java.lang.String objectReferenceId;\n\n    private java.lang.String phoneNumberId;\n\n    private java.lang.String contactMethodId;\n\n    private java.lang.String phoneCountryCode;\n\n    private java.lang.String phoneAreaCode;\n\n    private java.lang.String phoneExchange;\n\n    private java.lang.String phoneNumber;\n\n    private java.lang.String phoneExtension;\n\n    private java.lang.String phoneLastUpdateDate;\n\n    private java.lang.String phoneLastUpdateUser;\n\n    private java.lang.String phoneLastUpdateTxId;\n\n    private TCRMExtension TCRMExtension;\n\n    private PrimaryKeyBObj primaryKeyBObj;\n\n    private java.lang.String phoneHistActionCode;\n\n    private java.lang.String phoneHistCreateDate;\n\n    private java.lang.String phoneHistCreatedBy;\n\n    private java.lang.String phoneHistEndDate;\n\n    private java.lang.String phoneHistoryIdPK;\n\n    private DWLStatus DWLStatus;\n\n    public TCRMPhoneNumberBObjType() {\n    }\n\n    public TCRMPhoneNumberBObjType(java.lang.String objectReferenceId, java.lang.String phoneNumberId, java.lang.String contactMethodId, java.lang.String phoneCountryCode, java.lang.String phoneAreaCode, java.lang.String phoneExchange, java.lang.String phoneNumber, java.lang.String phoneExtension, java.lang.String phoneLastUpdateDate, java.lang.String phoneLastUpdateUser, java.lang.String phoneLastUpdateTxId, TCRMExtension TCRMExtension, PrimaryKeyBObj primaryKeyBObj, java.lang.String phoneHistActionCode, java.lang.String phoneHistCreateDate, java.lang.String phoneHistCreatedBy, java.lang.String phoneHistEndDate, java.lang.String phoneHistoryIdPK, DWLStatus DWLStatus) {\n        this.objectReferenceId = objectReferenceId;\n        this.phoneNumberId = phoneNumberId;\n        this.contactMethodId = contactMethodId;\n        this.phoneCountryCode = phoneCountryCode;\n        this.phoneAreaCode = phoneAreaCode;\n        this.phoneExchange = phoneExchange;\n        this.phoneNumber = phoneNumber;\n        this.phoneExtension = phoneExtension;\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n        this.TCRMExtension = TCRMExtension;\n        this.primaryKeyBObj = primaryKeyBObj;\n        this.phoneHistActionCode = phoneHistActionCode;\n        this.phoneHistCreateDate = phoneHistCreateDate;\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n        this.phoneHistEndDate = phoneHistEndDate;\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n        this.DWLStatus = DWLStatus;\n    }\n\n    /**\n     * Gets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return objectReferenceId\n     */\n    public java.lang.String getObjectReferenceId() {\n        return objectReferenceId;\n    }\n\n    /**\n     * Sets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param objectReferenceId\n     */\n    public void setObjectReferenceId(java.lang.String objectReferenceId) {\n        this.objectReferenceId = objectReferenceId;\n    }\n\n    /**\n     * Gets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneNumberId\n     */\n    public java.lang.String getPhoneNumberId() {\n        return phoneNumberId;\n    }\n\n    /**\n     * Sets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneNumberId\n     */\n    public void setPhoneNumberId(java.lang.String phoneNumberId) {\n        this.phoneNumberId = phoneNumberId;\n    }\n\n    /**\n     * Gets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return contactMethodId\n     */\n    public java.lang.String getContactMethodId() {\n        return contactMethodId;\n    }\n\n    /**\n     * Sets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param contactMethodId\n     */\n    public void setContactMethodId(java.lang.String contactMethodId) {\n        this.contactMethodId = contactMethodId;\n    }\n\n    /**\n     * Gets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneCountryCode\n     */\n    public java.lang.String getPhoneCountryCode() {\n        return phoneCountryCode;\n    }\n\n    /**\n     * Sets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneCountryCode\n     */\n    public void setPhoneCountryCode(java.lang.String phoneCountryCode) {\n        this.phoneCountryCode = phoneCountryCode;\n    }\n\n    /**\n     * Gets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneAreaCode\n     */\n    public java.lang.String getPhoneAreaCode() {\n        return phoneAreaCode;\n    }\n\n    /**\n     * Sets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneAreaCode\n     */\n    public void setPhoneAreaCode(java.lang.String phoneAreaCode) {\n        this.phoneAreaCode = phoneAreaCode;\n    }\n\n    /**\n     * Gets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneExchange\n     */\n    public java.lang.String getPhoneExchange() {\n        return phoneExchange;\n    }\n\n    /**\n     * Sets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneExchange\n     */\n    public void setPhoneExchange(java.lang.String phoneExchange) {\n        this.phoneExchange = phoneExchange;\n    }\n\n    /**\n     * Gets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneNumber\n     */\n    public java.lang.String getPhoneNumber() {\n        return phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneNumber\n     */\n    public void setPhoneNumber(java.lang.String phoneNumber) {\n        this.phoneNumber = phoneNumber;\n    }\n\n    /**\n     * Gets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneExtension\n     */\n    public java.lang.String getPhoneExtension() {\n        return phoneExtension;\n    }\n\n    /**\n     * Sets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneExtension\n     */\n    public void setPhoneExtension(java.lang.String phoneExtension) {\n        this.phoneExtension = phoneExtension;\n    }\n\n    /**\n     * Gets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneLastUpdateDate\n     */\n    public java.lang.String getPhoneLastUpdateDate() {\n        return phoneLastUpdateDate;\n    }\n\n    /**\n     * Sets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneLastUpdateDate\n     */\n    public void setPhoneLastUpdateDate(java.lang.String phoneLastUpdateDate) {\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n    }\n\n    /**\n     * Gets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneLastUpdateUser\n     */\n    public java.lang.String getPhoneLastUpdateUser() {\n        return phoneLastUpdateUser;\n    }\n\n    /**\n     * Sets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneLastUpdateUser\n     */\n    public void setPhoneLastUpdateUser(java.lang.String phoneLastUpdateUser) {\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n    }\n\n    /**\n     * Gets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneLastUpdateTxId\n     */\n    public java.lang.String getPhoneLastUpdateTxId() {\n        return phoneLastUpdateTxId;\n    }\n\n    /**\n     * Sets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneLastUpdateTxId\n     */\n    public void setPhoneLastUpdateTxId(java.lang.String phoneLastUpdateTxId) {\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n    }\n\n    /**\n     * Gets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @return TCRMExtension\n     */\n    public TCRMExtension getTCRMExtension() {\n        return TCRMExtension;\n    }\n\n    /**\n     * Sets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @param TCRMExtension\n     */\n    public void setTCRMExtension(TCRMExtension TCRMExtension) {\n        this.TCRMExtension = TCRMExtension;\n    }\n\n    /**\n     * Gets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     *\n     * @return primaryKeyBObj\n     */\n    public PrimaryKeyBObj getPrimaryKeyBObj() {\n        return primaryKeyBObj;\n    }\n\n    /**\n     * Sets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     *\n     * @param primaryKeyBObj\n     */\n    public void setPrimaryKeyBObj(PrimaryKeyBObj primaryKeyBObj) {\n        this.primaryKeyBObj = primaryKeyBObj;\n    }\n\n    /**\n     * Gets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistActionCode\n     */\n    public java.lang.String getPhoneHistActionCode() {\n        return phoneHistActionCode;\n    }\n\n    /**\n     * Sets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistActionCode\n     */\n    public void setPhoneHistActionCode(java.lang.String phoneHistActionCode) {\n        this.phoneHistActionCode = phoneHistActionCode;\n    }\n\n    /**\n     * Gets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistCreateDate\n     */\n    public java.lang.String getPhoneHistCreateDate() {\n        return phoneHistCreateDate;\n    }\n\n    /**\n     * Sets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistCreateDate\n     */\n    public void setPhoneHistCreateDate(java.lang.String phoneHistCreateDate) {\n        this.phoneHistCreateDate = phoneHistCreateDate;\n    }\n\n    /**\n     * Gets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistCreatedBy\n     */\n    public java.lang.String getPhoneHistCreatedBy() {\n        return phoneHistCreatedBy;\n    }\n\n    /**\n     * Sets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistCreatedBy\n     */\n    public void setPhoneHistCreatedBy(java.lang.String phoneHistCreatedBy) {\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n    }\n\n    /**\n     * Gets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistEndDate\n     */\n    public java.lang.String getPhoneHistEndDate() {\n        return phoneHistEndDate;\n    }\n\n    /**\n     * Sets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistEndDate\n     */\n    public void setPhoneHistEndDate(java.lang.String phoneHistEndDate) {\n        this.phoneHistEndDate = phoneHistEndDate;\n    }\n\n    /**\n     * Gets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistoryIdPK\n     */\n    public java.lang.String getPhoneHistoryIdPK() {\n        return phoneHistoryIdPK;\n    }\n\n    /**\n     * Sets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistoryIdPK\n     */\n    public void setPhoneHistoryIdPK(java.lang.String phoneHistoryIdPK) {\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n    }\n\n    /**\n     * Gets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     *\n     * @return DWLStatus\n     */\n    public DWLStatus getDWLStatus() {\n        return DWLStatus;\n    }\n\n    /**\n     * Sets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     *\n     * @param DWLStatus\n     */\n    public void setDWLStatus(DWLStatus DWLStatus) {\n        this.DWLStatus = DWLStatus;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof TCRMPhoneNumberBObjType))\n            return false;\n        TCRMPhoneNumberBObjType other = (TCRMPhoneNumberBObjType) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = super.equals(obj) && ((this.objectReferenceId == null && other.getObjectReferenceId() == null) || (this.objectReferenceId != null && this.objectReferenceId.equals(other.getObjectReferenceId()))) && ((this.phoneNumberId == null && other.getPhoneNumberId() == null) || (this.phoneNumberId != null && this.phoneNumberId.equals(other.getPhoneNumberId()))) && ((this.contactMethodId == null && other.getContactMethodId() == null) || (this.contactMethodId != null && this.contactMethodId.equals(other.getContactMethodId()))) && ((this.phoneCountryCode == null && other.getPhoneCountryCode() == null) || (this.phoneCountryCode != null && this.phoneCountryCode.equals(other.getPhoneCountryCode()))) && ((this.phoneAreaCode == null && other.getPhoneAreaCode() == null) || (this.phoneAreaCode != null && this.phoneAreaCode.equals(other.getPhoneAreaCode()))) && ((this.phoneExchange == null && other.getPhoneExchange() == null) || (this.phoneExchange != null && this.phoneExchange.equals(other.getPhoneExchange()))) && ((this.phoneNumber == null && other.getPhoneNumber() == null) || (this.phoneNumber != null && this.phoneNumber.equals(other.getPhoneNumber()))) && ((this.phoneExtension == null && other.getPhoneExtension() == null) || (this.phoneExtension != null && this.phoneExtension.equals(other.getPhoneExtension()))) && ((this.phoneLastUpdateDate == null && other.getPhoneLastUpdateDate() == null) || (this.phoneLastUpdateDate != null && this.phoneLastUpdateDate.equals(other.getPhoneLastUpdateDate()))) && ((this.phoneLastUpdateUser == null && other.getPhoneLastUpdateUser() == null) || (this.phoneLastUpdateUser != null && this.phoneLastUpdateUser.equals(other.getPhoneLastUpdateUser()))) && ((this.phoneLastUpdateTxId == null && other.getPhoneLastUpdateTxId() == null) || (this.phoneLastUpdateTxId != null && this.phoneLastUpdateTxId.equals(other.getPhoneLastUpdateTxId()))) && ((this.TCRMExtension == null && other.getTCRMExtension() == null) || (this.TCRMExtension != null && this.TCRMExtension.equals(other.getTCRMExtension()))) && ((this.primaryKeyBObj == null && other.getPrimaryKeyBObj() == null) || (this.primaryKeyBObj != null && this.primaryKeyBObj.equals(other.getPrimaryKeyBObj()))) && ((this.phoneHistActionCode == null && other.getPhoneHistActionCode() == null) || (this.phoneHistActionCode != null && this.phoneHistActionCode.equals(other.getPhoneHistActionCode()))) && ((this.phoneHistCreateDate == null && other.getPhoneHistCreateDate() == null) || (this.phoneHistCreateDate != null && this.phoneHistCreateDate.equals(other.getPhoneHistCreateDate()))) && ((this.phoneHistCreatedBy == null && other.getPhoneHistCreatedBy() == null) || (this.phoneHistCreatedBy != null && this.phoneHistCreatedBy.equals(other.getPhoneHistCreatedBy()))) && ((this.phoneHistEndDate == null && other.getPhoneHistEndDate() == null) || (this.phoneHistEndDate != null && this.phoneHistEndDate.equals(other.getPhoneHistEndDate()))) && ((this.phoneHistoryIdPK == null && other.getPhoneHistoryIdPK() == null) || (this.phoneHistoryIdPK != null && this.phoneHistoryIdPK.equals(other.getPhoneHistoryIdPK()))) && ((this.DWLStatus == null && other.getDWLStatus() == null) || (this.DWLStatus != null && this.DWLStatus.equals(other.getDWLStatus())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = super.hashCode();\n        if (getObjectReferenceId() != null) {\n            _hashCode += getObjectReferenceId().hashCode();\n        }\n        if (getPhoneNumberId() != null) {\n            _hashCode += getPhoneNumberId().hashCode();\n        }\n        if (getContactMethodId() != null) {\n            _hashCode += getContactMethodId().hashCode();\n        }\n        if (getPhoneCountryCode() != null) {\n            _hashCode += getPhoneCountryCode().hashCode();\n        }\n        if (getPhoneAreaCode() != null) {\n            _hashCode += getPhoneAreaCode().hashCode();\n        }\n        if (getPhoneExchange() != null) {\n            _hashCode += getPhoneExchange().hashCode();\n        }\n        if (getPhoneNumber() != null) {\n            _hashCode += getPhoneNumber().hashCode();\n        }\n        if (getPhoneExtension() != null) {\n            _hashCode += getPhoneExtension().hashCode();\n        }\n        if (getPhoneLastUpdateDate() != null) {\n            _hashCode += getPhoneLastUpdateDate().hashCode();\n        }\n        if (getPhoneLastUpdateUser() != null) {\n            _hashCode += getPhoneLastUpdateUser().hashCode();\n        }\n        if (getPhoneLastUpdateTxId() != null) {\n            _hashCode += getPhoneLastUpdateTxId().hashCode();\n        }\n        if (getTCRMExtension() != null) {\n            _hashCode += getTCRMExtension().hashCode();\n        }\n        if (getPrimaryKeyBObj() != null) {\n            _hashCode += getPrimaryKeyBObj().hashCode();\n        }\n        if (getPhoneHistActionCode() != null) {\n            _hashCode += getPhoneHistActionCode().hashCode();\n        }\n        if (getPhoneHistCreateDate() != null) {\n            _hashCode += getPhoneHistCreateDate().hashCode();\n        }\n        if (getPhoneHistCreatedBy() != null) {\n            _hashCode += getPhoneHistCreatedBy().hashCode();\n        }\n        if (getPhoneHistEndDate() != null) {\n            _hashCode += getPhoneHistEndDate().hashCode();\n        }\n        if (getPhoneHistoryIdPK() != null) {\n            _hashCode += getPhoneHistoryIdPK().hashCode();\n        }\n        if (getDWLStatus() != null) {\n            _hashCode += getDWLStatus().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(TCRMPhoneNumberBObjType.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMPhoneNumberBObjType\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"objectReferenceId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ObjectReferenceId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumberId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumberId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"contactMethodId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ContactMethodId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneCountryCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneCountryCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneAreaCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneAreaCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExchange\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExchange\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumber\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumber\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateUser\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateUser\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateTxId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateTxId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"TCRMExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">TCRMExtension\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"primaryKeyBObj\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PrimaryKeyBObj\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">PrimaryKeyBObj\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistActionCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistActionCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreatedBy\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreatedBy\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistEndDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistEndDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistoryIdPK\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistoryIdPK\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"DWLStatus\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"DWLStatus\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">DWLStatus\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n", "class_id": 0, "repo": "huangzishuo/ace-security", "file": "mdm-api/src/main/java/tongji/domain/oracle/TCRMPhoneNumberBObjType.java", "last_update_at": "2021-07-12T01:22:35+00:00", "original_content": "public class TCRMPhoneNumberBObjType extends CommonBObjType implements java.io.Serializable {\n\n    private java.lang.String objectReferenceId;\n\n    private java.lang.String phoneNumberId;\n\n    private java.lang.String contactMethodId;\n\n    private java.lang.String phoneCountryCode;\n\n    private java.lang.String phoneAreaCode;\n\n    private java.lang.String phoneExchange;\n\n    private java.lang.String phoneNumber;\n\n    private java.lang.String phoneExtension;\n\n    private java.lang.String phoneLastUpdateDate;\n\n    private java.lang.String phoneLastUpdateUser;\n\n    private java.lang.String phoneLastUpdateTxId;\n\n    private TCRMExtension TCRMExtension;\n\n    private PrimaryKeyBObj primaryKeyBObj;\n\n    private java.lang.String phoneHistActionCode;\n\n    private java.lang.String phoneHistCreateDate;\n\n    private java.lang.String phoneHistCreatedBy;\n\n    private java.lang.String phoneHistEndDate;\n\n    private java.lang.String phoneHistoryIdPK;\n\n    private DWLStatus DWLStatus;\n\n    public TCRMPhoneNumberBObjType() {\n    }\n\n    public TCRMPhoneNumberBObjType(java.lang.String objectReferenceId, java.lang.String phoneNumberId, java.lang.String contactMethodId, java.lang.String phoneCountryCode, java.lang.String phoneAreaCode, java.lang.String phoneExchange, java.lang.String phoneNumber, java.lang.String phoneExtension, java.lang.String phoneLastUpdateDate, java.lang.String phoneLastUpdateUser, java.lang.String phoneLastUpdateTxId, TCRMExtension TCRMExtension, PrimaryKeyBObj primaryKeyBObj, java.lang.String phoneHistActionCode, java.lang.String phoneHistCreateDate, java.lang.String phoneHistCreatedBy, java.lang.String phoneHistEndDate, java.lang.String phoneHistoryIdPK, DWLStatus DWLStatus) {\n        this.objectReferenceId = objectReferenceId;\n        this.phoneNumberId = phoneNumberId;\n        this.contactMethodId = contactMethodId;\n        this.phoneCountryCode = phoneCountryCode;\n        this.phoneAreaCode = phoneAreaCode;\n        this.phoneExchange = phoneExchange;\n        this.phoneNumber = phoneNumber;\n        this.phoneExtension = phoneExtension;\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n        this.TCRMExtension = TCRMExtension;\n        this.primaryKeyBObj = primaryKeyBObj;\n        this.phoneHistActionCode = phoneHistActionCode;\n        this.phoneHistCreateDate = phoneHistCreateDate;\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n        this.phoneHistEndDate = phoneHistEndDate;\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n        this.DWLStatus = DWLStatus;\n    }\n\n    /**\n     * Gets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return objectReferenceId\n     */\n    public java.lang.String getObjectReferenceId() {\n        return objectReferenceId;\n    }\n\n    /**\n     * Sets the objectReferenceId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param objectReferenceId\n     */\n    public void setObjectReferenceId(java.lang.String objectReferenceId) {\n        this.objectReferenceId = objectReferenceId;\n    }\n\n    /**\n     * Gets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneNumberId\n     */\n    public java.lang.String getPhoneNumberId() {\n        return phoneNumberId;\n    }\n\n    /**\n     * Sets the phoneNumberId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneNumberId\n     */\n    public void setPhoneNumberId(java.lang.String phoneNumberId) {\n        this.phoneNumberId = phoneNumberId;\n    }\n\n    /**\n     * Gets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return contactMethodId\n     */\n    public java.lang.String getContactMethodId() {\n        return contactMethodId;\n    }\n\n    /**\n     * Sets the contactMethodId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param contactMethodId\n     */\n    public void setContactMethodId(java.lang.String contactMethodId) {\n        this.contactMethodId = contactMethodId;\n    }\n\n    /**\n     * Gets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneCountryCode\n     */\n    public java.lang.String getPhoneCountryCode() {\n        return phoneCountryCode;\n    }\n\n    /**\n     * Sets the phoneCountryCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneCountryCode\n     */\n    public void setPhoneCountryCode(java.lang.String phoneCountryCode) {\n        this.phoneCountryCode = phoneCountryCode;\n    }\n\n    /**\n     * Gets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneAreaCode\n     */\n    public java.lang.String getPhoneAreaCode() {\n        return phoneAreaCode;\n    }\n\n    /**\n     * Sets the phoneAreaCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneAreaCode\n     */\n    public void setPhoneAreaCode(java.lang.String phoneAreaCode) {\n        this.phoneAreaCode = phoneAreaCode;\n    }\n\n    /**\n     * Gets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneExchange\n     */\n    public java.lang.String getPhoneExchange() {\n        return phoneExchange;\n    }\n\n    /**\n     * Sets the phoneExchange value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneExchange\n     */\n    public void setPhoneExchange(java.lang.String phoneExchange) {\n        this.phoneExchange = phoneExchange;\n    }\n\n    /**\n     * Gets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneNumber\n     */\n    public java.lang.String getPhoneNumber() {\n        return phoneNumber;\n    }\n\n    /**\n     * Sets the phoneNumber value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneNumber\n     */\n    public void setPhoneNumber(java.lang.String phoneNumber) {\n        this.phoneNumber = phoneNumber;\n    }\n\n    /**\n     * Gets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneExtension\n     */\n    public java.lang.String getPhoneExtension() {\n        return phoneExtension;\n    }\n\n    /**\n     * Sets the phoneExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneExtension\n     */\n    public void setPhoneExtension(java.lang.String phoneExtension) {\n        this.phoneExtension = phoneExtension;\n    }\n\n    /**\n     * Gets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneLastUpdateDate\n     */\n    public java.lang.String getPhoneLastUpdateDate() {\n        return phoneLastUpdateDate;\n    }\n\n    /**\n     * Sets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneLastUpdateDate\n     */\n    public void setPhoneLastUpdateDate(java.lang.String phoneLastUpdateDate) {\n        this.phoneLastUpdateDate = phoneLastUpdateDate;\n    }\n\n    /**\n     * Gets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneLastUpdateUser\n     */\n    public java.lang.String getPhoneLastUpdateUser() {\n        return phoneLastUpdateUser;\n    }\n\n    /**\n     * Sets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneLastUpdateUser\n     */\n    public void setPhoneLastUpdateUser(java.lang.String phoneLastUpdateUser) {\n        this.phoneLastUpdateUser = phoneLastUpdateUser;\n    }\n\n    /**\n     * Gets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneLastUpdateTxId\n     */\n    public java.lang.String getPhoneLastUpdateTxId() {\n        return phoneLastUpdateTxId;\n    }\n\n    /**\n     * Sets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneLastUpdateTxId\n     */\n    public void setPhoneLastUpdateTxId(java.lang.String phoneLastUpdateTxId) {\n        this.phoneLastUpdateTxId = phoneLastUpdateTxId;\n    }\n\n    /**\n     * Gets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @return TCRMExtension\n     */\n    public TCRMExtension getTCRMExtension() {\n        return TCRMExtension;\n    }\n\n    /**\n     * Sets the TCRMExtension value for this TCRMPhoneNumberBObjType.\n     *\n     * @param TCRMExtension\n     */\n    public void setTCRMExtension(TCRMExtension TCRMExtension) {\n        this.TCRMExtension = TCRMExtension;\n    }\n\n    /**\n     * Gets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     *\n     * @return primaryKeyBObj\n     */\n    public PrimaryKeyBObj getPrimaryKeyBObj() {\n        return primaryKeyBObj;\n    }\n\n    /**\n     * Sets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.\n     *\n     * @param primaryKeyBObj\n     */\n    public void setPrimaryKeyBObj(PrimaryKeyBObj primaryKeyBObj) {\n        this.primaryKeyBObj = primaryKeyBObj;\n    }\n\n    /**\n     * Gets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistActionCode\n     */\n    public java.lang.String getPhoneHistActionCode() {\n        return phoneHistActionCode;\n    }\n\n    /**\n     * Sets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistActionCode\n     */\n    public void setPhoneHistActionCode(java.lang.String phoneHistActionCode) {\n        this.phoneHistActionCode = phoneHistActionCode;\n    }\n\n    /**\n     * Gets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistCreateDate\n     */\n    public java.lang.String getPhoneHistCreateDate() {\n        return phoneHistCreateDate;\n    }\n\n    /**\n     * Sets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistCreateDate\n     */\n    public void setPhoneHistCreateDate(java.lang.String phoneHistCreateDate) {\n        this.phoneHistCreateDate = phoneHistCreateDate;\n    }\n\n    /**\n     * Gets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistCreatedBy\n     */\n    public java.lang.String getPhoneHistCreatedBy() {\n        return phoneHistCreatedBy;\n    }\n\n    /**\n     * Sets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistCreatedBy\n     */\n    public void setPhoneHistCreatedBy(java.lang.String phoneHistCreatedBy) {\n        this.phoneHistCreatedBy = phoneHistCreatedBy;\n    }\n\n    /**\n     * Gets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistEndDate\n     */\n    public java.lang.String getPhoneHistEndDate() {\n        return phoneHistEndDate;\n    }\n\n    /**\n     * Sets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistEndDate\n     */\n    public void setPhoneHistEndDate(java.lang.String phoneHistEndDate) {\n        this.phoneHistEndDate = phoneHistEndDate;\n    }\n\n    /**\n     * Gets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     *\n     * @return phoneHistoryIdPK\n     */\n    public java.lang.String getPhoneHistoryIdPK() {\n        return phoneHistoryIdPK;\n    }\n\n    /**\n     * Sets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.\n     *\n     * @param phoneHistoryIdPK\n     */\n    public void setPhoneHistoryIdPK(java.lang.String phoneHistoryIdPK) {\n        this.phoneHistoryIdPK = phoneHistoryIdPK;\n    }\n\n    /**\n     * Gets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     *\n     * @return DWLStatus\n     */\n    public DWLStatus getDWLStatus() {\n        return DWLStatus;\n    }\n\n    /**\n     * Sets the DWLStatus value for this TCRMPhoneNumberBObjType.\n     *\n     * @param DWLStatus\n     */\n    public void setDWLStatus(DWLStatus DWLStatus) {\n        this.DWLStatus = DWLStatus;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof TCRMPhoneNumberBObjType))\n            return false;\n        TCRMPhoneNumberBObjType other = (TCRMPhoneNumberBObjType) obj;\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = super.equals(obj) && ((this.objectReferenceId == null && other.getObjectReferenceId() == null) || (this.objectReferenceId != null && this.objectReferenceId.equals(other.getObjectReferenceId()))) && ((this.phoneNumberId == null && other.getPhoneNumberId() == null) || (this.phoneNumberId != null && this.phoneNumberId.equals(other.getPhoneNumberId()))) && ((this.contactMethodId == null && other.getContactMethodId() == null) || (this.contactMethodId != null && this.contactMethodId.equals(other.getContactMethodId()))) && ((this.phoneCountryCode == null && other.getPhoneCountryCode() == null) || (this.phoneCountryCode != null && this.phoneCountryCode.equals(other.getPhoneCountryCode()))) && ((this.phoneAreaCode == null && other.getPhoneAreaCode() == null) || (this.phoneAreaCode != null && this.phoneAreaCode.equals(other.getPhoneAreaCode()))) && ((this.phoneExchange == null && other.getPhoneExchange() == null) || (this.phoneExchange != null && this.phoneExchange.equals(other.getPhoneExchange()))) && ((this.phoneNumber == null && other.getPhoneNumber() == null) || (this.phoneNumber != null && this.phoneNumber.equals(other.getPhoneNumber()))) && ((this.phoneExtension == null && other.getPhoneExtension() == null) || (this.phoneExtension != null && this.phoneExtension.equals(other.getPhoneExtension()))) && ((this.phoneLastUpdateDate == null && other.getPhoneLastUpdateDate() == null) || (this.phoneLastUpdateDate != null && this.phoneLastUpdateDate.equals(other.getPhoneLastUpdateDate()))) && ((this.phoneLastUpdateUser == null && other.getPhoneLastUpdateUser() == null) || (this.phoneLastUpdateUser != null && this.phoneLastUpdateUser.equals(other.getPhoneLastUpdateUser()))) && ((this.phoneLastUpdateTxId == null && other.getPhoneLastUpdateTxId() == null) || (this.phoneLastUpdateTxId != null && this.phoneLastUpdateTxId.equals(other.getPhoneLastUpdateTxId()))) && ((this.TCRMExtension == null && other.getTCRMExtension() == null) || (this.TCRMExtension != null && this.TCRMExtension.equals(other.getTCRMExtension()))) && ((this.primaryKeyBObj == null && other.getPrimaryKeyBObj() == null) || (this.primaryKeyBObj != null && this.primaryKeyBObj.equals(other.getPrimaryKeyBObj()))) && ((this.phoneHistActionCode == null && other.getPhoneHistActionCode() == null) || (this.phoneHistActionCode != null && this.phoneHistActionCode.equals(other.getPhoneHistActionCode()))) && ((this.phoneHistCreateDate == null && other.getPhoneHistCreateDate() == null) || (this.phoneHistCreateDate != null && this.phoneHistCreateDate.equals(other.getPhoneHistCreateDate()))) && ((this.phoneHistCreatedBy == null && other.getPhoneHistCreatedBy() == null) || (this.phoneHistCreatedBy != null && this.phoneHistCreatedBy.equals(other.getPhoneHistCreatedBy()))) && ((this.phoneHistEndDate == null && other.getPhoneHistEndDate() == null) || (this.phoneHistEndDate != null && this.phoneHistEndDate.equals(other.getPhoneHistEndDate()))) && ((this.phoneHistoryIdPK == null && other.getPhoneHistoryIdPK() == null) || (this.phoneHistoryIdPK != null && this.phoneHistoryIdPK.equals(other.getPhoneHistoryIdPK()))) && ((this.DWLStatus == null && other.getDWLStatus() == null) || (this.DWLStatus != null && this.DWLStatus.equals(other.getDWLStatus())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = super.hashCode();\n        if (getObjectReferenceId() != null) {\n            _hashCode += getObjectReferenceId().hashCode();\n        }\n        if (getPhoneNumberId() != null) {\n            _hashCode += getPhoneNumberId().hashCode();\n        }\n        if (getContactMethodId() != null) {\n            _hashCode += getContactMethodId().hashCode();\n        }\n        if (getPhoneCountryCode() != null) {\n            _hashCode += getPhoneCountryCode().hashCode();\n        }\n        if (getPhoneAreaCode() != null) {\n            _hashCode += getPhoneAreaCode().hashCode();\n        }\n        if (getPhoneExchange() != null) {\n            _hashCode += getPhoneExchange().hashCode();\n        }\n        if (getPhoneNumber() != null) {\n            _hashCode += getPhoneNumber().hashCode();\n        }\n        if (getPhoneExtension() != null) {\n            _hashCode += getPhoneExtension().hashCode();\n        }\n        if (getPhoneLastUpdateDate() != null) {\n            _hashCode += getPhoneLastUpdateDate().hashCode();\n        }\n        if (getPhoneLastUpdateUser() != null) {\n            _hashCode += getPhoneLastUpdateUser().hashCode();\n        }\n        if (getPhoneLastUpdateTxId() != null) {\n            _hashCode += getPhoneLastUpdateTxId().hashCode();\n        }\n        if (getTCRMExtension() != null) {\n            _hashCode += getTCRMExtension().hashCode();\n        }\n        if (getPrimaryKeyBObj() != null) {\n            _hashCode += getPrimaryKeyBObj().hashCode();\n        }\n        if (getPhoneHistActionCode() != null) {\n            _hashCode += getPhoneHistActionCode().hashCode();\n        }\n        if (getPhoneHistCreateDate() != null) {\n            _hashCode += getPhoneHistCreateDate().hashCode();\n        }\n        if (getPhoneHistCreatedBy() != null) {\n            _hashCode += getPhoneHistCreatedBy().hashCode();\n        }\n        if (getPhoneHistEndDate() != null) {\n            _hashCode += getPhoneHistEndDate().hashCode();\n        }\n        if (getPhoneHistoryIdPK() != null) {\n            _hashCode += getPhoneHistoryIdPK().hashCode();\n        }\n        if (getDWLStatus() != null) {\n            _hashCode += getDWLStatus().hashCode();\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(TCRMPhoneNumberBObjType.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMPhoneNumberBObjType\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"objectReferenceId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ObjectReferenceId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumberId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumberId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"contactMethodId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"ContactMethodId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneCountryCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneCountryCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneAreaCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneAreaCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExchange\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExchange\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneNumber\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneNumber\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateUser\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateUser\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneLastUpdateTxId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneLastUpdateTxId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"TCRMExtension\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"TCRMExtension\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">TCRMExtension\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"primaryKeyBObj\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PrimaryKeyBObj\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">PrimaryKeyBObj\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistActionCode\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistActionCode\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreateDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreateDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistCreatedBy\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistCreatedBy\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistEndDate\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistEndDate\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"phoneHistoryIdPK\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"PhoneHistoryIdPK\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"string\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"DWLStatus\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \"DWLStatus\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.ibm.com/mdm/schema\", \">DWLStatus\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {\n        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);\n    }\n}\n", "refactored": false}
{"hexsha": "691009fba7ccb50b017dca2a77a8604c2a1e3792", "ext": "java", "lang": "Java", "content": "public class ExecSQL extends AbstractStep {\n\n    @Override\n    public void decode(StepMetaInterface stepMetaInterface, mxCell cell, List<DatabaseMeta> databases, IMetaStore metaStore) throws Exception {\n        ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n        String con = cell.getAttribute(\"connection\");\n        execSQLMeta.setDatabaseMeta(DatabaseMeta.findDatabase(databases, con));\n        execSQLMeta.setSql(StringEscapeHelper.decode(cell.getAttribute(\"sql\")));\n        execSQLMeta.setExecutedEachInputRow(\"true\".equalsIgnoreCase(cell.getAttribute(\"executedEachInputRow\")));\n        execSQLMeta.setSingleStatement(\"true\".equalsIgnoreCase(cell.getAttribute(\"singleStatement\")));\n        execSQLMeta.setVariableReplacementActive(\"true\".equalsIgnoreCase(cell.getAttribute(\"replaceVariables\")));\n        execSQLMeta.setParams(\"true\".equalsIgnoreCase(cell.getAttribute(\"setParams\")));\n        execSQLMeta.setQuoteString(\"true\".equalsIgnoreCase(cell.getAttribute(\"quoteString\")));\n        JSONArray jsonArray = JSONArray.fromObject(cell.getAttribute(\"arguments\"));\n        execSQLMeta.allocate(jsonArray.size());\n        int i = 0;\n        while (i < jsonArray.size()) try {\n            JSONObject jsonObject = jsonArray.getJSONObject(i);\n            execSQLMeta.getArguments()[i] = jsonObject.optString(\"name\");\n        } finally {\n            i++;\n        }\n    }\n\n    @Override\n    public Element encode(StepMetaInterface stepMetaInterface) throws Exception {\n        ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n        Document doc = mxUtils.createDocument();\n        Element e = doc.createElement(\"Step\");\n        e.setAttribute(\"connection\", execSQLMeta.getDatabaseMeta() == null ? \"\" : execSQLMeta.getDatabaseMeta().getName());\n        e.setAttribute(\"sql\", StringEscapeHelper.encode(execSQLMeta.getSql()));\n        e.setAttribute(\"executedEachInputRow\", Boolean.toString(execSQLMeta.isExecutedEachInputRow()));\n        e.setAttribute(\"singleStatement\", Boolean.toString(execSQLMeta.isSingleStatement()));\n        e.setAttribute(\"replaceVariables\", Boolean.toString(execSQLMeta.isReplaceVariables()));\n        e.setAttribute(\"setParams\", Boolean.toString(execSQLMeta.isParams()));\n        e.setAttribute(\"quoteString\", Boolean.toString(execSQLMeta.isQuoteString()));\n        JSONArray arguments = new JSONArray();\n        int i = 0;\n        while (i < execSQLMeta.getArguments().length) try {\n            String name = execSQLMeta.getArguments()[i];\n            JSONObject jsonObject = new JSONObject();\n            jsonObject.put(\"name\", name);\n            arguments.add(jsonObject);\n        } finally {\n            i++;\n        }\n        e.setAttribute(\"arguments\", arguments.toString());\n        return e;\n    }\n}\n", "class_id": 0, "repo": "bioinformatics-ua/BIcenter", "file": "app/kettleExt/trans/steps/ExecSQL.java", "last_update_at": "2021-08-16T06:42:55+00:00", "original_content": "public class ExecSQL extends AbstractStep {\n\n    @Override\n    public void decode(StepMetaInterface stepMetaInterface, mxCell cell, List<DatabaseMeta> databases, IMetaStore metaStore) throws Exception {\n        ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n        String con = cell.getAttribute(\"connection\");\n        execSQLMeta.setDatabaseMeta(DatabaseMeta.findDatabase(databases, con));\n        execSQLMeta.setSql(StringEscapeHelper.decode(cell.getAttribute(\"sql\")));\n        execSQLMeta.setExecutedEachInputRow(\"true\".equalsIgnoreCase(cell.getAttribute(\"executedEachInputRow\")));\n        execSQLMeta.setSingleStatement(\"true\".equalsIgnoreCase(cell.getAttribute(\"singleStatement\")));\n        execSQLMeta.setVariableReplacementActive(\"true\".equalsIgnoreCase(cell.getAttribute(\"replaceVariables\")));\n        execSQLMeta.setParams(\"true\".equalsIgnoreCase(cell.getAttribute(\"setParams\")));\n        execSQLMeta.setQuoteString(\"true\".equalsIgnoreCase(cell.getAttribute(\"quoteString\")));\n        JSONArray jsonArray = JSONArray.fromObject(cell.getAttribute(\"arguments\"));\n        execSQLMeta.allocate(jsonArray.size());\n        for (int i = 0; i < jsonArray.size(); i++) {\n            JSONObject jsonObject = jsonArray.getJSONObject(i);\n            execSQLMeta.getArguments()[i] = jsonObject.optString(\"name\");\n        }\n    }\n\n    @Override\n    public Element encode(StepMetaInterface stepMetaInterface) throws Exception {\n        ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;\n        Document doc = mxUtils.createDocument();\n        Element e = doc.createElement(\"Step\");\n        e.setAttribute(\"connection\", execSQLMeta.getDatabaseMeta() == null ? \"\" : execSQLMeta.getDatabaseMeta().getName());\n        e.setAttribute(\"sql\", StringEscapeHelper.encode(execSQLMeta.getSql()));\n        e.setAttribute(\"executedEachInputRow\", Boolean.toString(execSQLMeta.isExecutedEachInputRow()));\n        e.setAttribute(\"singleStatement\", Boolean.toString(execSQLMeta.isSingleStatement()));\n        e.setAttribute(\"replaceVariables\", Boolean.toString(execSQLMeta.isReplaceVariables()));\n        e.setAttribute(\"setParams\", Boolean.toString(execSQLMeta.isParams()));\n        e.setAttribute(\"quoteString\", Boolean.toString(execSQLMeta.isQuoteString()));\n        JSONArray arguments = new JSONArray();\n        for (int i = 0; i < execSQLMeta.getArguments().length; i++) {\n            String name = execSQLMeta.getArguments()[i];\n            JSONObject jsonObject = new JSONObject();\n            jsonObject.put(\"name\", name);\n            arguments.add(jsonObject);\n        }\n        e.setAttribute(\"arguments\", arguments.toString());\n        return e;\n    }\n}\n", "refactored": true}
{"hexsha": "5241f583035803403a5ac7cfdbb3662fe1b799f8", "ext": "java", "lang": "Java", "content": "public class MainActivity extends AppCompatActivity implements MessageSignatureResultReceiver.Receiver {\n\n    private static final String TAG_FRAGMENT_MAIN = \"TAG_FRAGMENT_MAIN\";\n\n    public static final String TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS = \"TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS\";\n\n    private MessageSignatureResultReceiver resultReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        pullMainFragment();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // register the result receiver to get the Message Signature back from the server\n        registerResultReceiver();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void pullMainFragment() {\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        MainFragment mainFragment = (MainFragment) fragmentManager.findFragmentByTag(TAG_FRAGMENT_MAIN);\n        if (mainFragment == null) {\n            mainFragment = new MainFragment();\n            fragmentManager.beginTransaction().replace(R.id.web_checkout_fragment_container, mainFragment, TAG_FRAGMENT_MAIN).commit();\n        }\n    }\n\n    private void registerResultReceiver() {\n        if (resultReceiver != null)\n            return;\n        resultReceiver = new MessageSignatureResultReceiver(new Handler());\n        resultReceiver.setReceiver(this);\n    }\n\n    @Override\n    public void onReceiveResult(int resultCode, Bundle resultData) {\n    }\n\n    //send the result to OnActivityResult defined in the fragments attached to the Activity\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        for (Fragment fragment : getSupportFragmentManager().getFragments()) {\n            fragment.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n}\n", "class_id": 0, "repo": "samerzmd/cybersource-android-samples", "file": "app/src/main/java/com/cybersource/webcheckout/MainActivity.java", "last_update_at": "2021-11-09T21:07:11+00:00", "original_content": "public class MainActivity extends AppCompatActivity implements MessageSignatureResultReceiver.Receiver {\n\n    private static final String TAG_FRAGMENT_MAIN = \"TAG_FRAGMENT_MAIN\";\n\n    public static final String TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS = \"TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS\";\n\n    private MessageSignatureResultReceiver resultReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        pullMainFragment();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // register the result receiver to get the Message Signature back from the server\n        registerResultReceiver();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void pullMainFragment() {\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        MainFragment mainFragment = (MainFragment) fragmentManager.findFragmentByTag(TAG_FRAGMENT_MAIN);\n        if (mainFragment == null) {\n            mainFragment = new MainFragment();\n            fragmentManager.beginTransaction().replace(R.id.web_checkout_fragment_container, mainFragment, TAG_FRAGMENT_MAIN).commit();\n        }\n    }\n\n    private void registerResultReceiver() {\n        if (resultReceiver != null)\n            return;\n        resultReceiver = new MessageSignatureResultReceiver(new Handler());\n        resultReceiver.setReceiver(this);\n    }\n\n    @Override\n    public void onReceiveResult(int resultCode, Bundle resultData) {\n    }\n\n    //send the result to OnActivityResult defined in the fragments attached to the Activity\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        for (Fragment fragment : getSupportFragmentManager().getFragments()) {\n            fragment.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "276f9bf06fd9cdddd7881eec84d2337ed1845efa", "ext": "java", "lang": "Java", "content": "public abstract class Commands {\r\n\r\n    private static final Command ROOT = new RootCommand();\r\n\r\n    private static final Command[] SUB = new Command[] { new HelpCommand(), new SplitCommand(), new JoinCommand() };\r\n\r\n    public static Command rootCommand() {\r\n        return ROOT;\r\n    }\r\n\r\n    public static Command[] subCommands() {\r\n        return SUB;\r\n    }\r\n\r\n    public static List<String> names() {\r\n        List<String> n = new ArrayList<String>();\r\n        for (Command c : subCommands()) n.add(c.getName());\r\n        return n;\r\n    }\r\n\r\n    public static Command forName(String name) {\r\n        for (Command c : subCommands()) if (name.equals(c.getName()))\r\n            return c;\r\n        return null;\r\n    }\r\n\r\n    private Commands() {\r\n    }\r\n}\r\n", "class_id": 0, "repo": "cristicmf/secretsharing", "file": "secret-sharing-cli/src/main/java/org/mitre/secretsharing/cli/cmd/Commands.java", "last_update_at": "2021-09-17T01:47:44+00:00", "original_content": "public abstract class Commands {\r\n\r\n    private static final Command ROOT = new RootCommand();\r\n\r\n    private static final Command[] SUB = new Command[] { new HelpCommand(), new SplitCommand(), new JoinCommand() };\r\n\r\n    public static Command rootCommand() {\r\n        return ROOT;\r\n    }\r\n\r\n    public static Command[] subCommands() {\r\n        return SUB;\r\n    }\r\n\r\n    public static List<String> names() {\r\n        List<String> n = new ArrayList<String>();\r\n        for (Command c : subCommands()) n.add(c.getName());\r\n        return n;\r\n    }\r\n\r\n    public static Command forName(String name) {\r\n        for (Command c : subCommands()) if (name.equals(c.getName()))\r\n            return c;\r\n        return null;\r\n    }\r\n\r\n    private Commands() {\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "a0b3fec9ca0c28a20691df8528413edb7042e26c", "ext": "java", "lang": "Java", "content": "public class MainApp {\n\n    public static void main(String[] args) throws Exception {\n        ApplicationContext appContext = new ClassPathXmlApplicationContext(\"Spring-Customer.xml\");\n        Customer customer = (Customer) appContext.getBean(\"custom\");\n        customer.addCustomer();\n        customer.addCustomerReturnValue();\n        customer.addCustomerThrowException();\n        customer.addCustomerAround(\"mkyong\");\n    }\n}\n", "class_id": 0, "repo": "jasonwee/videoOnCloud", "file": "src/java/play/learn/java/aspectj/core/MainApp.java", "last_update_at": "2021-12-07T03:39:58+00:00", "original_content": "public class MainApp {\n\n    public static void main(String[] args) throws Exception {\n        ApplicationContext appContext = new ClassPathXmlApplicationContext(\"Spring-Customer.xml\");\n        Customer customer = (Customer) appContext.getBean(\"custom\");\n        customer.addCustomer();\n        customer.addCustomerReturnValue();\n        customer.addCustomerThrowException();\n        customer.addCustomerAround(\"mkyong\");\n    }\n}\n", "refactored": false}
{"hexsha": "e8e3c4b4e355e51e7e75ddb9456fe63248f39294", "ext": "java", "lang": "Java", "content": "public class ModifiableHToolbar extends BasicHToolbar {\n\n    protected final HBox modifyMLeftSection = new HBox();\n\n    protected final HBox modifyMCenterSection = new HBox();\n\n    protected final HBox modifyMRightSection = new HBox();\n\n    protected final HBox modifyingActionsWrapper = new HBox();\n\n    protected final Button modifyButton = new Button();\n\n    protected final Button doneButton = new Button();\n\n    /**\n     * Constructor\n     */\n    public ModifiableHToolbar() {\n        super();\n        NodeHelper.setHgrow(allOverWrapper);\n        modifyingActionsWrapper.getStyleClass().add(\"ep-modifying-toolbar\");\n        rootContainer.getStyleClass().add(\"ep-modifiable-toolbar\");\n        modifyMLeftSection.getStyleClass().add(\"ep-modifying-toolbar-left\");\n        modifyMCenterSection.getStyleClass().add(\"ep-modifying-toolbar-center\");\n        modifyMRightSection.getStyleClass().add(\"ep-modifying-toolbar-right\");\n    }\n\n    /**\n     * @{inheritedDoc}\n     */\n    @Override\n    public void buildFrom(AbstractViewController controller, IToolbarHolder toolbarHolder) {\n        super.buildFrom(controller, toolbarHolder);\n        buildModifyActions();\n        final String styleClass = configuration.getPropertyValue(\"modifyingActionsStyleClass\");\n        if (io.github.jsoagger.core.utils.StringUtils.isNotBlank(styleClass)) {\n            modifyingActionsWrapper.getStyleClass().addAll(styleClass.split(\",\"));\n        }\n    }\n\n    /**\n     * Modify menu configuration is menu displayed when the user clicked on modify button on the\n     * displayed toolbar.\n     * <p>\n     * If no modify menu is provided, the modify button is not displayed.\n     * <p>\n     */\n    private void buildModifyActions() {\n        if (modifyMenuConfiguration != null) {\n            // build left side actions\n            final VLViewComponentXML leftActions = modifyMenuConfiguration.getComponentById(\"LeftActions\").orElse(null);\n            if (leftActions != null) {\n                final List<IBuildable> buildables = buildActionGroup(leftActions);\n                for (IBuildable node : buildables) {\n                    modifyMLeftSection.getChildren().add(node.getDisplay());\n                }\n                modifyingActionsWrapper.getChildren().addAll(modifyMLeftSection);\n            }\n            // build center actions\n            final VLViewComponentXML centerActions = modifyMenuConfiguration.getComponentById(\"CenterActions\").orElse(null);\n            if (centerActions != null) {\n                final List<IBuildable> buildables = buildActionGroup(centerActions);\n                for (IBuildable node : buildables) {\n                    modifyMCenterSection.getChildren().add(node.getDisplay());\n                }\n                if (modifyingActionsWrapper.getChildren().size() > 0) {\n                    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n                }\n                modifyingActionsWrapper.getChildren().addAll(modifyMCenterSection);\n            }\n            final VLViewComponentXML rightActions = modifyMenuConfiguration.getComponentById(\"RightActions\").orElse(null);\n            if (rightActions != null) {\n                final List<IBuildable> buildables = buildActionGroup(rightActions);\n                for (IBuildable node : buildables) {\n                    modifyMRightSection.getChildren().add(node.getDisplay());\n                }\n                if (modifyingActionsWrapper.getChildren().size() > 0) {\n                    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n                }\n                modifyingActionsWrapper.getChildren().addAll(modifyMRightSection);\n            }\n        }\n        allOverWrapper.visibleProperty().bind(Bindings.not(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty()));\n        allOverWrapper.managedProperty().bind(allOverWrapper.visibleProperty());\n        buildModifyButton();\n        buildDoneButton();\n    }\n\n    /**\n     * Build the modify button.\n     */\n    private void buildModifyButton() {\n        modifyButton.getStyleClass().addAll(\"table-toolbar-action\", \"ep-button\");\n        modifyButton.setOnAction(e -> modifyClicked(controller));\n        modifyButton.setText(controller.getGLocalised(\"EDIT_LABEL\").toUpperCase());\n        IconUtils.setFontIcon(\"gmi-more-horiz:18\", modifyButton);\n        allOverWrapper.getChildren().add(modifyButton);\n        if (selectable.get()) {\n        }\n        NodeHelper.setHgrow(modifyingActionsWrapper);\n        modifyingActionsWrapper.visibleProperty().bind(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty());\n        modifyingActionsWrapper.managedProperty().bind(modifyingActionsWrapper.visibleProperty());\n        rootContainer.getChildren().add(modifyingActionsWrapper);\n    }\n\n    /**\n     * Build done button\n     */\n    private void buildDoneButton() {\n        doneButton.getStyleClass().addAll(\"button-small\", \"table-toolbar-action\", \"ep-button\");\n        doneButton.setOnAction(e -> modifyClicked(controller));\n        doneButton.setText(controller.getGLocalised(\"DONE_LABEL\").toUpperCase());\n        IconUtils.setFontIcon(\"fa-check:16\", doneButton);\n        modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer(), doneButton);\n    }\n\n    /**\n     * @param controller\n     */\n    protected void modifyClicked(AbstractViewController controller) {\n        if (!((IModifiableToolbarHolder) toolbarHolder).isModifying()) {\n            thickButton.setSelected(false);\n            ((IModifiableToolbarHolder) toolbarHolder).setModifying(true);\n            // show all selectors\n            ((IModifiableToolbarHolder) toolbarHolder).modify();\n            // reinit thick button\n            isThicked = true;\n            thickClicked();\n        } else {\n            ((IModifiableToolbarHolder) toolbarHolder).setModifying(false);\n            // hide all selectors\n            ((IModifiableToolbarHolder) toolbarHolder).cancelModify();\n        }\n    }\n\n    /**\n     * Called when a checkbox or a listcell is clicked.\n     */\n    public void listCellSelected() {\n        isThicked = false;\n        thickButton.setSelected(false);\n    }\n}\n", "class_id": 0, "repo": "jsoagger/jsoagger-fx", "file": "jsoagger-jfxcore-engine/src/main/java/io/github/jsoagger/jfxcore/engine/components/toolbar/htoolbar/ModifiableHToolbar.java", "last_update_at": "2021-09-26T10:22:13+00:00", "original_content": "public class ModifiableHToolbar extends BasicHToolbar {\n\n    protected final HBox modifyMLeftSection = new HBox();\n\n    protected final HBox modifyMCenterSection = new HBox();\n\n    protected final HBox modifyMRightSection = new HBox();\n\n    protected final HBox modifyingActionsWrapper = new HBox();\n\n    protected final Button modifyButton = new Button();\n\n    protected final Button doneButton = new Button();\n\n    /**\n     * Constructor\n     */\n    public ModifiableHToolbar() {\n        super();\n        NodeHelper.setHgrow(allOverWrapper);\n        modifyingActionsWrapper.getStyleClass().add(\"ep-modifying-toolbar\");\n        rootContainer.getStyleClass().add(\"ep-modifiable-toolbar\");\n        modifyMLeftSection.getStyleClass().add(\"ep-modifying-toolbar-left\");\n        modifyMCenterSection.getStyleClass().add(\"ep-modifying-toolbar-center\");\n        modifyMRightSection.getStyleClass().add(\"ep-modifying-toolbar-right\");\n    }\n\n    /**\n     * @{inheritedDoc}\n     */\n    @Override\n    public void buildFrom(AbstractViewController controller, IToolbarHolder toolbarHolder) {\n        super.buildFrom(controller, toolbarHolder);\n        buildModifyActions();\n        final String styleClass = configuration.getPropertyValue(\"modifyingActionsStyleClass\");\n        if (io.github.jsoagger.core.utils.StringUtils.isNotBlank(styleClass)) {\n            modifyingActionsWrapper.getStyleClass().addAll(styleClass.split(\",\"));\n        }\n    }\n\n    /**\n     * Modify menu configuration is menu displayed when the user clicked on modify button on the\n     * displayed toolbar.\n     * <p>\n     * If no modify menu is provided, the modify button is not displayed.\n     * <p>\n     */\n    private void buildModifyActions() {\n        if (modifyMenuConfiguration != null) {\n            // build left side actions\n            final VLViewComponentXML leftActions = modifyMenuConfiguration.getComponentById(\"LeftActions\").orElse(null);\n            if (leftActions != null) {\n                final List<IBuildable> buildables = buildActionGroup(leftActions);\n                for (IBuildable node : buildables) {\n                    modifyMLeftSection.getChildren().add(node.getDisplay());\n                }\n                modifyingActionsWrapper.getChildren().addAll(modifyMLeftSection);\n            }\n            // build center actions\n            final VLViewComponentXML centerActions = modifyMenuConfiguration.getComponentById(\"CenterActions\").orElse(null);\n            if (centerActions != null) {\n                final List<IBuildable> buildables = buildActionGroup(centerActions);\n                for (IBuildable node : buildables) {\n                    modifyMCenterSection.getChildren().add(node.getDisplay());\n                }\n                if (modifyingActionsWrapper.getChildren().size() > 0) {\n                    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n                }\n                modifyingActionsWrapper.getChildren().addAll(modifyMCenterSection);\n            }\n            final VLViewComponentXML rightActions = modifyMenuConfiguration.getComponentById(\"RightActions\").orElse(null);\n            if (rightActions != null) {\n                final List<IBuildable> buildables = buildActionGroup(rightActions);\n                for (IBuildable node : buildables) {\n                    modifyMRightSection.getChildren().add(node.getDisplay());\n                }\n                if (modifyingActionsWrapper.getChildren().size() > 0) {\n                    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());\n                }\n                modifyingActionsWrapper.getChildren().addAll(modifyMRightSection);\n            }\n        }\n        allOverWrapper.visibleProperty().bind(Bindings.not(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty()));\n        allOverWrapper.managedProperty().bind(allOverWrapper.visibleProperty());\n        buildModifyButton();\n        buildDoneButton();\n    }\n\n    /**\n     * Build the modify button.\n     */\n    private void buildModifyButton() {\n        modifyButton.getStyleClass().addAll(\"table-toolbar-action\", \"ep-button\");\n        modifyButton.setOnAction(e -> modifyClicked(controller));\n        modifyButton.setText(controller.getGLocalised(\"EDIT_LABEL\").toUpperCase());\n        IconUtils.setFontIcon(\"gmi-more-horiz:18\", modifyButton);\n        allOverWrapper.getChildren().add(modifyButton);\n        if (selectable.get()) {\n        }\n        NodeHelper.setHgrow(modifyingActionsWrapper);\n        modifyingActionsWrapper.visibleProperty().bind(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty());\n        modifyingActionsWrapper.managedProperty().bind(modifyingActionsWrapper.visibleProperty());\n        rootContainer.getChildren().add(modifyingActionsWrapper);\n    }\n\n    /**\n     * Build done button\n     */\n    private void buildDoneButton() {\n        doneButton.getStyleClass().addAll(\"button-small\", \"table-toolbar-action\", \"ep-button\");\n        doneButton.setOnAction(e -> modifyClicked(controller));\n        doneButton.setText(controller.getGLocalised(\"DONE_LABEL\").toUpperCase());\n        IconUtils.setFontIcon(\"fa-check:16\", doneButton);\n        modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer(), doneButton);\n    }\n\n    /**\n     * @param controller\n     */\n    protected void modifyClicked(AbstractViewController controller) {\n        if (!((IModifiableToolbarHolder) toolbarHolder).isModifying()) {\n            thickButton.setSelected(false);\n            ((IModifiableToolbarHolder) toolbarHolder).setModifying(true);\n            // show all selectors\n            ((IModifiableToolbarHolder) toolbarHolder).modify();\n            // reinit thick button\n            isThicked = true;\n            thickClicked();\n        } else {\n            ((IModifiableToolbarHolder) toolbarHolder).setModifying(false);\n            // hide all selectors\n            ((IModifiableToolbarHolder) toolbarHolder).cancelModify();\n        }\n    }\n\n    /**\n     * Called when a checkbox or a listcell is clicked.\n     */\n    public void listCellSelected() {\n        isThicked = false;\n        thickButton.setSelected(false);\n    }\n}\n", "refactored": false}
{"hexsha": "e040e3b45ccd4ca8119c5d2712b3808c26c479df", "ext": "java", "lang": "Java", "content": "public class UI {\n\n    public static float windowWidth;\n\n    public static float windowHeight;\n\n    private static float newWindowHeight = -1;\n\n    private static float newWindowWidth = -1;\n\n    protected static CopyOnWriteArrayList<Widget> components = new CopyOnWriteArrayList<>();\n\n    private static Queue<Runnable> imguiThread = new ConcurrentLinkedQueue<>();\n\n    private static boolean async;\n\n    private static WindowResizeEvent resizeEvent;\n\n    protected static LongAdder globalCounter = new LongAdder();\n\n    protected static float tabBottomBorderOffset = 7.1f;\n\n    private static Application app;\n\n    protected static JImFontAtlas fonts;\n\n    private static ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<>();\n\n    private static SerializableConsumer<WindowResizeEvent> resizeEventSerializableConsumer;\n\n    private static boolean readyCalledFlag;\n\n    private static String windowTitle;\n\n    private static void init(Application app, Runnable r) {\n        JniLoader.load();\n        JImGuiUtil.cacheStringToBytes();\n        try (JImGui jimgui = new JImGui(app.getWidth(), app.getHeight(), app.getTitle())) {\n            UI.windowHeight = app.getHeight();\n            UI.windowWidth = app.getWidth();\n            windowTitle = app.getTitle();\n            resizeEvent = new WindowResizeEvent(windowWidth, windowHeight, windowWidth, windowHeight);\n            app.setupTheme(jimgui);\n            Window.globalXPadding = jimgui.getStyle().getWindowPaddingX();\n            Window.globalYPadding = jimgui.getStyle().getWindowPaddingY();\n            fonts = jimgui.getIO().getFonts();\n            fonts.addDefaultFont();\n            app.loadFonts(fonts);\n            r.run();\n            for (; !jimgui.windowShouldClose(); ) {\n                if (!app.getTitle().equals(windowTitle)) {\n                    jimgui.setWindowTitle(new JImStr(app.getTitle()));\n                    windowTitle = app.getTitle();\n                }\n                float newY = jimgui.getPlatformWindowSizeY();\n                float newX = jimgui.getPlatformWindowSizeX();\n                //window resize event\n                if (newY != windowHeight || newX != windowWidth) {\n                    resizeEvent.setOldHeight(windowHeight);\n                    resizeEvent.setOldWidth(windowWidth);\n                    resizeEvent.setNewHeight(newY);\n                    resizeEvent.setNewWidth(newX);\n                    UI.windowHeight = jimgui.getPlatformWindowSizeY();\n                    UI.windowWidth = jimgui.getPlatformWindowSizeX();\n                    Window.reApplyRelativeSize();\n                    Popup.reApplyRelativeSize();\n                    Notification.reApplyAlignmenToAll();\n                    if (resizeEventSerializableConsumer != null) {\n                        resizeEventSerializableConsumer.accept(resizeEvent);\n                    }\n                }\n                //window size programatically changed\n                if (newWindowHeight > -1 || newWindowWidth > -1) {\n                    jimgui.setPlatformWindowSize(newWindowWidth, newWindowHeight);\n                    newWindowHeight = -1;\n                    newWindowWidth = -1;\n                }\n                jimgui.initNewFrame();\n                process(jimgui);\n                jimgui.render();\n                if (!readyCalledFlag) {\n                    if (app.getReady() != null) {\n                        app.getReady().run();\n                    }\n                    readyCalledFlag = true;\n                }\n            }\n        }\n    }\n\n    public static void render(Runnable r) {\n        app = new Application(\"flui\", 1200, 700);\n        init(app, r);\n    }\n\n    public static void render(Application app, Runnable r) {\n        init(app, r);\n    }\n\n    public static void renderAsync(Runnable r) {\n        async = true;\n        app = new Application(\"flui\", 1200, 700);\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n    }\n\n    public static void renderAsync(Application app, Runnable r) {\n        async = true;\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n    }\n\n    public static void setWindowSize(float w, float h) {\n        if (async) {\n            runLater(() -> {\n                newWindowHeight = h;\n                newWindowWidth = w;\n            });\n        } else {\n            newWindowHeight = h;\n            newWindowWidth = w;\n        }\n    }\n\n    public static void setWindowWidth(float w) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(w, windowHeight);\n            });\n        } else {\n            setWindowSize(w, windowHeight);\n        }\n    }\n\n    public static void setWindowHeight(float h) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(windowWidth, h);\n            });\n        } else {\n            setWindowSize(windowWidth, h);\n        }\n    }\n\n    public static void onWindowResize(SerializableConsumer<WindowResizeEvent> e) {\n        resizeEventSerializableConsumer = e;\n    }\n\n    protected static void addID(String id) {\n        ids.add(id);\n    }\n\n    protected static boolean idExists(String id) {\n        return (ids.contains(id));\n    }\n\n    protected static void add(Widget w) {\n        if (idExists(w.id)) {\n            System.err.println(\"ERROR: '\" + w.id + \"' has already been used as an identifier, ID's must be unique!\");\n            throw new RuntimeException(\"Duplicate ID : \" + w.id);\n        }\n        addID(w.id);\n        components.add(w);\n    }\n\n    public static void runLater(Runnable r) {\n        imguiThread.add(r);\n    }\n\n    protected static void process(JImGui imgui) {\n        for (int i = 0; i < components.size(); i++) {\n            components.get(i).render(imgui);\n        }\n        Iterator<Runnable> it = imguiThread.iterator();\n        for (; it.hasNext(); ) {\n            Runnable r = it.next();\n            try {\n                r.run();\n            } catch (Exception e) {\n            }\n            it.remove();\n        }\n    }\n}\n", "class_id": 0, "repo": "newk5/flui", "file": "src/main/java/com/github/newk5/flui/widgets/UI.java", "last_update_at": "2021-11-09T11:10:17+00:00", "original_content": "public class UI {\n\n    public static float windowWidth;\n\n    public static float windowHeight;\n\n    private static float newWindowHeight = -1;\n\n    private static float newWindowWidth = -1;\n\n    protected static CopyOnWriteArrayList<Widget> components = new CopyOnWriteArrayList<>();\n\n    private static Queue<Runnable> imguiThread = new ConcurrentLinkedQueue<>();\n\n    private static boolean async;\n\n    private static WindowResizeEvent resizeEvent;\n\n    protected static LongAdder globalCounter = new LongAdder();\n\n    protected static float tabBottomBorderOffset = 7.1f;\n\n    private static Application app;\n\n    protected static JImFontAtlas fonts;\n\n    private static ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<>();\n\n    private static SerializableConsumer<WindowResizeEvent> resizeEventSerializableConsumer;\n\n    private static boolean readyCalledFlag;\n\n    private static String windowTitle;\n\n    private static void init(Application app, Runnable r) {\n        JniLoader.load();\n        JImGuiUtil.cacheStringToBytes();\n        try (JImGui jimgui = new JImGui(app.getWidth(), app.getHeight(), app.getTitle())) {\n            UI.windowHeight = app.getHeight();\n            UI.windowWidth = app.getWidth();\n            windowTitle = app.getTitle();\n            resizeEvent = new WindowResizeEvent(windowWidth, windowHeight, windowWidth, windowHeight);\n            app.setupTheme(jimgui);\n            Window.globalXPadding = jimgui.getStyle().getWindowPaddingX();\n            Window.globalYPadding = jimgui.getStyle().getWindowPaddingY();\n            fonts = jimgui.getIO().getFonts();\n            fonts.addDefaultFont();\n            app.loadFonts(fonts);\n            r.run();\n            while (!jimgui.windowShouldClose()) {\n                if (!app.getTitle().equals(windowTitle)) {\n                    jimgui.setWindowTitle(new JImStr(app.getTitle()));\n                    windowTitle = app.getTitle();\n                }\n                float newY = jimgui.getPlatformWindowSizeY();\n                float newX = jimgui.getPlatformWindowSizeX();\n                //window resize event\n                if (newY != windowHeight || newX != windowWidth) {\n                    resizeEvent.setOldHeight(windowHeight);\n                    resizeEvent.setOldWidth(windowWidth);\n                    resizeEvent.setNewHeight(newY);\n                    resizeEvent.setNewWidth(newX);\n                    UI.windowHeight = jimgui.getPlatformWindowSizeY();\n                    UI.windowWidth = jimgui.getPlatformWindowSizeX();\n                    Window.reApplyRelativeSize();\n                    Popup.reApplyRelativeSize();\n                    Notification.reApplyAlignmenToAll();\n                    if (resizeEventSerializableConsumer != null) {\n                        resizeEventSerializableConsumer.accept(resizeEvent);\n                    }\n                }\n                //window size programatically changed\n                if (newWindowHeight > -1 || newWindowWidth > -1) {\n                    jimgui.setPlatformWindowSize(newWindowWidth, newWindowHeight);\n                    newWindowHeight = -1;\n                    newWindowWidth = -1;\n                }\n                jimgui.initNewFrame();\n                process(jimgui);\n                jimgui.render();\n                if (!readyCalledFlag) {\n                    if (app.getReady() != null) {\n                        app.getReady().run();\n                    }\n                    readyCalledFlag = true;\n                }\n            }\n        }\n    }\n\n    public static void render(Runnable r) {\n        app = new Application(\"flui\", 1200, 700);\n        init(app, r);\n    }\n\n    public static void render(Application app, Runnable r) {\n        init(app, r);\n    }\n\n    public static void renderAsync(Runnable r) {\n        async = true;\n        app = new Application(\"flui\", 1200, 700);\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n    }\n\n    public static void renderAsync(Application app, Runnable r) {\n        async = true;\n        new Thread(() -> {\n            init(app, r);\n        }).start();\n    }\n\n    public static void setWindowSize(float w, float h) {\n        if (async) {\n            runLater(() -> {\n                newWindowHeight = h;\n                newWindowWidth = w;\n            });\n        } else {\n            newWindowHeight = h;\n            newWindowWidth = w;\n        }\n    }\n\n    public static void setWindowWidth(float w) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(w, windowHeight);\n            });\n        } else {\n            setWindowSize(w, windowHeight);\n        }\n    }\n\n    public static void setWindowHeight(float h) {\n        if (async) {\n            runLater(() -> {\n                setWindowSize(windowWidth, h);\n            });\n        } else {\n            setWindowSize(windowWidth, h);\n        }\n    }\n\n    public static void onWindowResize(SerializableConsumer<WindowResizeEvent> e) {\n        resizeEventSerializableConsumer = e;\n    }\n\n    protected static void addID(String id) {\n        ids.add(id);\n    }\n\n    protected static boolean idExists(String id) {\n        return (ids.contains(id));\n    }\n\n    protected static void add(Widget w) {\n        if (idExists(w.id)) {\n            System.err.println(\"ERROR: '\" + w.id + \"' has already been used as an identifier, ID's must be unique!\");\n            throw new RuntimeException(\"Duplicate ID : \" + w.id);\n        }\n        addID(w.id);\n        components.add(w);\n    }\n\n    public static void runLater(Runnable r) {\n        imguiThread.add(r);\n    }\n\n    protected static void process(JImGui imgui) {\n        for (int i = 0; i < components.size(); i++) {\n            components.get(i).render(imgui);\n        }\n        Iterator<Runnable> it = imguiThread.iterator();\n        while (it.hasNext()) {\n            Runnable r = it.next();\n            try {\n                r.run();\n            } catch (Exception e) {\n            }\n            it.remove();\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "f56c1a6cd5b055c9b2e29a48257b31e8faab04f5", "ext": "java", "lang": "Java", "content": "class Main {\n\n    public static void main(String[] args) {\n        ArrayList<String> input = new ArrayList<String>();\n        input.add(\"Hello\");\n        input.add(\"World!\");\n        Executor<String> executor = new Executor<String>(new Day0Solution(), input);\n        executor.run(args);\n    }\n}\n", "class_id": 0, "repo": "tcollier/aoc_solver", "file": "2000/01/Main.java", "last_update_at": "2021-12-14T18:42:45+00:00", "original_content": "class Main {\n\n    public static void main(String[] args) {\n        ArrayList<String> input = new ArrayList<String>();\n        input.add(\"Hello\");\n        input.add(\"World!\");\n        Executor<String> executor = new Executor<String>(new Day0Solution(), input);\n        executor.run(args);\n    }\n}\n", "refactored": false}
{"hexsha": "43bc2c085e6a2cac1f9ce49766096d0942154236", "ext": "java", "lang": "Java", "content": "public class ExclusiveFilterSetTest {\n\n    @Test\n    public void constructor_null_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> new ExclusiveFilterSet<String>(null));\n    }\n\n    @Test\n    public void hasAny() {\n        // EP 1: Fully contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        // EP 2: Partially contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n\n    @Test\n    public void hasAll() {\n        // EP 1: Has All\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_ABC));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        // EP 2: Has Some\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AC));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n\n    @Test\n    public void add() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n        // EP 1: Empty\n        filterSet.add(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n        // EP 2: Not Empty\n        filterSet.add(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 3: Duplicate\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.add(null));\n    }\n\n    @Test\n    public void remove() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n        // EP 1: Has Multiple\n        filterSet.remove(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n        filterSet.remove(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n        // EP 2: Has One\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 3: Empty\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 4: null\n        filterSet.remove(null);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n    }\n\n    @Test\n    public void addAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n        // EP 1: Empty\n        filterSet.addAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n        // EP 2: Not Empty\n        filterSet.addAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 3: Duplicate\n        filterSet.addAll(TypicalFilters.SET_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.addAll((FilterSet<String>) null));\n    }\n\n    @Test\n    public void removeAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n        // EP 1: Has Multiple\n        filterSet.removeAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n        // EP 2: Has One\n        filterSet.removeAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 3: Empty\n        filterSet.removeAll(TypicalFilters.SET_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.removeAll((FilterSet<String>) null));\n    }\n\n    @Test\n    public void test() {\n        // EP 1: One filter match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_A));\n        // EP 2: Multiple filters match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B + TypicalFilters.FILTERABLE_C));\n        // EP 3: One filter no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_B));\n        // EP 4: Multiple filters no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_C));\n        // EP 5: null\n        assertThrows(NullPointerException.class, () -> TypicalFilters.EXCLUSIVE_FILTERSET_A.test(null));\n    }\n}\n", "class_id": 0, "repo": "yutingzou/tp", "file": "src/test/java/seedu/address/model/filter/ExclusiveFilterSetTest.java", "last_update_at": "2021-03-17T11:02:52+00:00", "original_content": "public class ExclusiveFilterSetTest {\n\n    @Test\n    public void constructor_null_throwsNullPointerException() {\n        assertThrows(NullPointerException.class, () -> new ExclusiveFilterSet<String>(null));\n    }\n\n    @Test\n    public void hasAny() {\n        // EP 1: Fully contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        // EP 2: Partially contains\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n\n    @Test\n    public void hasAll() {\n        // EP 1: Has All\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_ABC));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        // EP 2: Has Some\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AC));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));\n        // EP 3: Disjoint\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));\n    }\n\n    @Test\n    public void add() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n        // EP 1: Empty\n        filterSet.add(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n        // EP 2: Not Empty\n        filterSet.add(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 3: Duplicate\n        filterSet.add(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.add(null));\n    }\n\n    @Test\n    public void remove() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n        // EP 1: Has Multiple\n        filterSet.remove(TypicalFilters.FILTER_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);\n        filterSet.remove(TypicalFilters.FILTER_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);\n        // EP 2: Has One\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 3: Empty\n        filterSet.remove(TypicalFilters.FILTER_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 4: null\n        filterSet.remove(null);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n    }\n\n    @Test\n    public void addAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>();\n        // EP 1: Empty\n        filterSet.addAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n        // EP 2: Not Empty\n        filterSet.addAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 3: Duplicate\n        filterSet.addAll(TypicalFilters.SET_B);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.addAll((FilterSet<String>) null));\n    }\n\n    @Test\n    public void removeAll() {\n        FilterSet<String> filterSet = new ExclusiveFilterSet<>(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());\n        // EP 1: Has Multiple\n        filterSet.removeAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);\n        // EP 2: Has One\n        filterSet.removeAll(TypicalFilters.SET_C);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 3: Empty\n        filterSet.removeAll(TypicalFilters.SET_A);\n        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);\n        // EP 4: null\n        assertThrows(NullPointerException.class, () -> filterSet.removeAll((FilterSet<String>) null));\n    }\n\n    @Test\n    public void test() {\n        // EP 1: One filter match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_A));\n        // EP 2: Multiple filters match\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B + TypicalFilters.FILTERABLE_C));\n        // EP 3: One filter no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_B));\n        // EP 4: Multiple filters no match\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));\n        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_C));\n        // EP 5: null\n        assertThrows(NullPointerException.class, () -> TypicalFilters.EXCLUSIVE_FILTERSET_A.test(null));\n    }\n}\n", "refactored": false}
{"hexsha": "39f6b8b791c2a8605663251577fe1f85e00a7a2a", "ext": "java", "lang": "Java", "content": "public class ExprTimeRemainingUntilBorderStabilize extends SimpleExpression<Timespan> {\n\n    private Expression<World> worldExpression;\n\n    @Override\n    public Class<? extends Timespan> getReturnType() {\n        return Timespan.class;\n    }\n\n    @Override\n    public boolean isSingle() {\n        return true;\n    }\n\n    @Override\n    public boolean init(Expression<?>[] expr, int matchedPattern, Kleenean arg2, ParseResult arg3) {\n        worldExpression = (Expression<World>) expr[0];\n        return true;\n    }\n\n    @Override\n    public String toString(Event event, boolean arg1) {\n        return \"remaining time until border stabilize in \" + worldExpression;\n    }\n\n    @Override\n    protected Timespan[] get(Event event) {\n        World world = worldExpression.getSingle(event);\n        if (world.getWorldBorder() instanceof WorldBorderImpl) {\n            WorldBorderImpl border = (WorldBorderImpl) world.getWorldBorder();\n            Double timeInSeconds = border.remainingTimeInSeconds();\n            Timespan result = new Timespan((long) (timeInSeconds * 1000));\n            return new Timespan[] { result };\n        }\n        return new Timespan[0];\n    }\n}\n", "class_id": 0, "repo": "TlatoaniHJ/Kosmos", "file": "src/us/tlatoani/kosmos/border/event/ExprTimeRemainingUntilBorderStabilize.java", "last_update_at": "2021-12-14T19:23:54+00:00", "original_content": "public class ExprTimeRemainingUntilBorderStabilize extends SimpleExpression<Timespan> {\n\n    private Expression<World> worldExpression;\n\n    @Override\n    public Class<? extends Timespan> getReturnType() {\n        return Timespan.class;\n    }\n\n    @Override\n    public boolean isSingle() {\n        return true;\n    }\n\n    @Override\n    public boolean init(Expression<?>[] expr, int matchedPattern, Kleenean arg2, ParseResult arg3) {\n        worldExpression = (Expression<World>) expr[0];\n        return true;\n    }\n\n    @Override\n    public String toString(Event event, boolean arg1) {\n        return \"remaining time until border stabilize in \" + worldExpression;\n    }\n\n    @Override\n    protected Timespan[] get(Event event) {\n        World world = worldExpression.getSingle(event);\n        if (world.getWorldBorder() instanceof WorldBorderImpl) {\n            WorldBorderImpl border = (WorldBorderImpl) world.getWorldBorder();\n            Double timeInSeconds = border.remainingTimeInSeconds();\n            Timespan result = new Timespan((long) (timeInSeconds * 1000));\n            return new Timespan[] { result };\n        }\n        return new Timespan[0];\n    }\n}\n", "refactored": false}
{"hexsha": "234a5116347665188acce37b81c61d47cf6eb7ba", "ext": "java", "lang": "Java", "content": "public class PurityAnnotator extends Annotator<PurityAnnotator.Purity> {\n\n    PurityAnnotator() {\n        super(\"purity\", Purity.HEAP_MOD);\n    }\n\n    public static enum Purity {\n\n        /**\n         * Does not modify program state and always produces the same (or practically indistinguishable) result.\n         */\n        CONST,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if local variables directly involved into expression don't change.\n         */\n        LOCAL_DEP,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if heap does not change.\n         */\n        HEAP_DEP,\n        /**\n         * Does not modify program state.\n         */\n        SIDE_EFFECT_FREE,\n        /**\n         * May modify heap.\n         */\n        HEAP_MOD,\n        /**\n         * May modify heap and/or local variables.\n         */\n        LOCAL_MOD;\n\n        Purity merge(Purity other) {\n            return this.ordinal() > other.ordinal() ? this : other;\n        }\n\n        public boolean atLeast(Purity other) {\n            return this.ordinal() <= other.ordinal();\n        }\n    }\n\n    void annotate(Node node, FrameContext fc) {\n        forExpressions(node, expr -> annotatePurity(expr, fc));\n    }\n\n    private Purity getOwnPurity(Expression expr, FrameContext fc) {\n        switch(expr.getCode()) {\n            case Inc:\n            case PreIncrement:\n            case PostIncrement:\n            case Store:\n            case CompoundAssignment:\n                return Purity.LOCAL_MOD;\n            case InvokeDynamic:\n            case StoreElement:\n            case PutField:\n            case PutStatic:\n                return Purity.HEAP_MOD;\n            case InitObject:\n                {\n                    MethodReference mr = (MethodReference) expr.getOperand();\n                    if (!fc.cf.isSideEffectFree(mr, true))\n                        return Purity.HEAP_MOD;\n                    if (Types.isImmutable(mr.getDeclaringType()))\n                        return Purity.CONST;\n                    return Purity.SIDE_EFFECT_FREE;\n                }\n            case NewArray:\n            case InitArray:\n                return Purity.SIDE_EFFECT_FREE;\n            case GetField:\n                if (fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand())) && !fc.md.isConstructor()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case GetStatic:\n                if (fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand())) && !fc.md.isTypeInitializer()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case LoadElement:\n                return Purity.HEAP_DEP;\n            case InvokeSpecial:\n            case InvokeStatic:\n            case InvokeVirtual:\n            case InvokeInterface:\n                {\n                    MethodReference mr = (MethodReference) expr.getOperand();\n                    if (Methods.isPure(mr)) {\n                        boolean indistinguishable = mr.getReturnType().isVoid() || mr.getReturnType().isPrimitive() || Types.isImmutable(mr.getReturnType());\n                        if (indistinguishable) {\n                            return Purity.CONST;\n                        }\n                        return Purity.SIDE_EFFECT_FREE;\n                    }\n                    if (fc.cf.isSideEffectFree(mr, expr.getCode() == AstCode.InvokeSpecial)) {\n                        return Purity.SIDE_EFFECT_FREE;\n                    }\n                    return Purity.HEAP_MOD;\n                }\n            case Load:\n                return Purity.LOCAL_DEP;\n            default:\n                return Purity.CONST;\n        }\n    }\n\n    private Purity annotatePurity(Expression expr, FrameContext fc) {\n        Purity purity = Purity.CONST;\n        for (Expression child : expr.getArguments()) {\n            purity = purity.merge(annotatePurity(child, fc));\n        }\n        if (Inf.CONST.getValue(expr) != null) {\n            // statically known constant\n            purity = Purity.CONST;\n        } else {\n            purity = purity.merge(getOwnPurity(expr, fc));\n        }\n        putIfAbsent(expr, purity);\n        return purity;\n    }\n\n    @Override\n    public Purity get(Expression expr) {\n        return super.get(expr);\n    }\n\n    public boolean isPure(Expression expr) {\n        return get(expr).atLeast(Purity.LOCAL_DEP);\n    }\n\n    public boolean isSideEffectFree(Expression expr) {\n        return get(expr).atLeast(Purity.SIDE_EFFECT_FREE);\n    }\n}\n", "class_id": 0, "repo": "amaembo/huntbugs", "file": "huntbugs/src/main/java/one/util/huntbugs/flow/PurityAnnotator.java", "last_update_at": "2021-11-09T09:36:36+00:00", "original_content": "public class PurityAnnotator extends Annotator<PurityAnnotator.Purity> {\n\n    PurityAnnotator() {\n        super(\"purity\", Purity.HEAP_MOD);\n    }\n\n    public static enum Purity {\n\n        /**\n         * Does not modify program state and always produces the same (or practically indistinguishable) result.\n         */\n        CONST,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if local variables directly involved into expression don't change.\n         */\n        LOCAL_DEP,\n        /**\n         * Does not modify program state and produces the same (or practically indistinguishable) result\n         * if heap does not change.\n         */\n        HEAP_DEP,\n        /**\n         * Does not modify program state.\n         */\n        SIDE_EFFECT_FREE,\n        /**\n         * May modify heap.\n         */\n        HEAP_MOD,\n        /**\n         * May modify heap and/or local variables.\n         */\n        LOCAL_MOD;\n\n        Purity merge(Purity other) {\n            return this.ordinal() > other.ordinal() ? this : other;\n        }\n\n        public boolean atLeast(Purity other) {\n            return this.ordinal() <= other.ordinal();\n        }\n    }\n\n    void annotate(Node node, FrameContext fc) {\n        forExpressions(node, expr -> annotatePurity(expr, fc));\n    }\n\n    private Purity getOwnPurity(Expression expr, FrameContext fc) {\n        switch(expr.getCode()) {\n            case Inc:\n            case PreIncrement:\n            case PostIncrement:\n            case Store:\n            case CompoundAssignment:\n                return Purity.LOCAL_MOD;\n            case InvokeDynamic:\n            case StoreElement:\n            case PutField:\n            case PutStatic:\n                return Purity.HEAP_MOD;\n            case InitObject:\n                {\n                    MethodReference mr = (MethodReference) expr.getOperand();\n                    if (!fc.cf.isSideEffectFree(mr, true))\n                        return Purity.HEAP_MOD;\n                    if (Types.isImmutable(mr.getDeclaringType()))\n                        return Purity.CONST;\n                    return Purity.SIDE_EFFECT_FREE;\n                }\n            case NewArray:\n            case InitArray:\n                return Purity.SIDE_EFFECT_FREE;\n            case GetField:\n                if (fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand())) && !fc.md.isConstructor()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case GetStatic:\n                if (fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand())) && !fc.md.isTypeInitializer()) {\n                    return Purity.CONST;\n                }\n                return Purity.HEAP_DEP;\n            case LoadElement:\n                return Purity.HEAP_DEP;\n            case InvokeSpecial:\n            case InvokeStatic:\n            case InvokeVirtual:\n            case InvokeInterface:\n                {\n                    MethodReference mr = (MethodReference) expr.getOperand();\n                    if (Methods.isPure(mr)) {\n                        boolean indistinguishable = mr.getReturnType().isVoid() || mr.getReturnType().isPrimitive() || Types.isImmutable(mr.getReturnType());\n                        if (indistinguishable) {\n                            return Purity.CONST;\n                        }\n                        return Purity.SIDE_EFFECT_FREE;\n                    }\n                    if (fc.cf.isSideEffectFree(mr, expr.getCode() == AstCode.InvokeSpecial)) {\n                        return Purity.SIDE_EFFECT_FREE;\n                    }\n                    return Purity.HEAP_MOD;\n                }\n            case Load:\n                return Purity.LOCAL_DEP;\n            default:\n                return Purity.CONST;\n        }\n    }\n\n    private Purity annotatePurity(Expression expr, FrameContext fc) {\n        Purity purity = Purity.CONST;\n        for (Expression child : expr.getArguments()) {\n            purity = purity.merge(annotatePurity(child, fc));\n        }\n        if (Inf.CONST.getValue(expr) != null) {\n            // statically known constant\n            purity = Purity.CONST;\n        } else {\n            purity = purity.merge(getOwnPurity(expr, fc));\n        }\n        putIfAbsent(expr, purity);\n        return purity;\n    }\n\n    @Override\n    public Purity get(Expression expr) {\n        return super.get(expr);\n    }\n\n    public boolean isPure(Expression expr) {\n        return get(expr).atLeast(Purity.LOCAL_DEP);\n    }\n\n    public boolean isSideEffectFree(Expression expr) {\n        return get(expr).atLeast(Purity.SIDE_EFFECT_FREE);\n    }\n}\n", "refactored": false}
{"hexsha": "4145e4ff9250cae0f2320ca43bb45cac1e8eae61", "ext": "java", "lang": "Java", "content": "public class Log4JRuleHelper extends RuleHelper {\n\n    private static final LogEventTracker tracker = new LogEventTracker();\n\n    public Log4JRuleHelper(Rule rule) {\n        super(rule);\n    }\n\n    public void appendersCalled(LoggingEvent event) {\n        ThrowableInformation throwableInfo = event.getThrowableInformation();\n        String throwableName = null;\n        ErrorFingerprint fingerprint = null;\n        if (throwableInfo != null) {\n            Throwable throwable = throwableInfo.getThrowable();\n            throwableName = (throwable != null) ? throwable.getClass().getName() : null;\n            fingerprint = ErrorFingerprint.fromThrowable(throwableInfo.getThrowable());\n        }\n        LogEventTracker.LogLevel level = LogEventTracker.LogLevel.valueOf(event.getLevel().toString());\n        tracker.track(level, (throwableInfo != null), throwableName, fingerprint);\n        if (fingerprint != null && event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME) == null) {\n            event.setProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME, fingerprint.getChecksum());\n        }\n    }\n\n    public String convertMessage(LoggingEvent event, String origMessage) {\n        String fingerprint = event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME);\n        if (fingerprint == null) {\n            return origMessage;\n        }\n        return \"[error:\" + fingerprint + \"] \" + origMessage;\n    }\n}\n", "class_id": 0, "repo": "uditsharma/JInsight", "file": "src/main/java/ai/apptuit/metrics/jinsight/modules/log4j/Log4JRuleHelper.java", "last_update_at": "2021-06-05T13:08:36+00:00", "original_content": "public class Log4JRuleHelper extends RuleHelper {\n\n    private static final LogEventTracker tracker = new LogEventTracker();\n\n    public Log4JRuleHelper(Rule rule) {\n        super(rule);\n    }\n\n    public void appendersCalled(LoggingEvent event) {\n        ThrowableInformation throwableInfo = event.getThrowableInformation();\n        String throwableName = null;\n        ErrorFingerprint fingerprint = null;\n        if (throwableInfo != null) {\n            Throwable throwable = throwableInfo.getThrowable();\n            throwableName = (throwable != null) ? throwable.getClass().getName() : null;\n            fingerprint = ErrorFingerprint.fromThrowable(throwableInfo.getThrowable());\n        }\n        LogEventTracker.LogLevel level = LogEventTracker.LogLevel.valueOf(event.getLevel().toString());\n        tracker.track(level, (throwableInfo != null), throwableName, fingerprint);\n        if (fingerprint != null && event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME) == null) {\n            event.setProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME, fingerprint.getChecksum());\n        }\n    }\n\n    public String convertMessage(LoggingEvent event, String origMessage) {\n        String fingerprint = event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME);\n        if (fingerprint == null) {\n            return origMessage;\n        }\n        return \"[error:\" + fingerprint + \"] \" + origMessage;\n    }\n}\n", "refactored": false}
{"hexsha": "e81b5f345b921f4750ec25a2ac2076deb78ae3c4", "ext": "java", "lang": "Java", "content": "public class HtdfTransferTest {\n\n    @Test\n    public void sign() throws Exception {\n        String hexPrivateKey = \"25E9F2EDAAF9464E9FA0EFDB896835741EBE0F5E34F97CFB88457818B6681C32\";\n        byte[] privateKey = Hex.decode(hexPrivateKey);\n        MessageDigest sh256Digest = MessageDigest.getInstance(\"SHA-256\");\n        sh256Digest.update(\"hello\".getBytes(StandardCharsets.UTF_8));\n        byte[] sha256Bytes = sh256Digest.digest();\n        byte[] sigRS = HtdfTransfer.sign(sha256Bytes, privateKey);\n        //s:6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\n        final String RIGHT_RS = \"5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6\" + \"6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\";\n        System.out.println(Hex.toHexString(sigRS));\n        assertTrue(RIGHT_RS.compareTo(Hex.toHexString(sigRS)) == 0);\n    }\n\n    @Test\n    public void htdfToSatoshi1() {\n        assertTrue(0 == HtdfToSatoshi(BigDecimal.valueOf(0.1234)).compareTo(BigInteger.valueOf(12340000)));\n    }\n\n    @Test\n    public void doHttpGet() throws Exception {\n        String ret = HtdfTransfer.doHttpGet(\"http://www.htdfscan.com\");\n        assertTrue(ret.length() > 0);\n    }\n\n    @Test\n    public void doHttpPost() {\n    }\n\n    @Test\n    public void transfer() throws Exception {\n        String dstAddress = \"htdf1jrh6kxrcr0fd8gfgdwna8yyr9tkt99ggmz9ja2\";\n        String memo = \"htdf transaction demo in java\";\n        BigInteger amountSatoshi = HtdfToSatoshi(BigDecimal.valueOf(0.12345678));\n        HtdfTransfer.transfer(dstAddress, amountSatoshi, memo);\n    }\n}\n", "class_id": 0, "repo": "youngqqcn/htdfdocs", "file": "demos/java_demos/src/test/java/com/orientwalt/demos/HtdfTransferTest.java", "last_update_at": "2021-03-10T06:28:27+00:00", "original_content": "public class HtdfTransferTest {\n\n    @Test\n    public void sign() throws Exception {\n        String hexPrivateKey = \"25E9F2EDAAF9464E9FA0EFDB896835741EBE0F5E34F97CFB88457818B6681C32\";\n        byte[] privateKey = Hex.decode(hexPrivateKey);\n        MessageDigest sh256Digest = MessageDigest.getInstance(\"SHA-256\");\n        sh256Digest.update(\"hello\".getBytes(StandardCharsets.UTF_8));\n        byte[] sha256Bytes = sh256Digest.digest();\n        byte[] sigRS = HtdfTransfer.sign(sha256Bytes, privateKey);\n        //s:6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\n        final String RIGHT_RS = \"5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6\" + \"6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a\";\n        System.out.println(Hex.toHexString(sigRS));\n        assertTrue(RIGHT_RS.compareTo(Hex.toHexString(sigRS)) == 0);\n    }\n\n    @Test\n    public void htdfToSatoshi1() {\n        assertTrue(0 == HtdfToSatoshi(BigDecimal.valueOf(0.1234)).compareTo(BigInteger.valueOf(12340000)));\n    }\n\n    @Test\n    public void doHttpGet() throws Exception {\n        String ret = HtdfTransfer.doHttpGet(\"http://www.htdfscan.com\");\n        assertTrue(ret.length() > 0);\n    }\n\n    @Test\n    public void doHttpPost() {\n    }\n\n    @Test\n    public void transfer() throws Exception {\n        String dstAddress = \"htdf1jrh6kxrcr0fd8gfgdwna8yyr9tkt99ggmz9ja2\";\n        String memo = \"htdf transaction demo in java\";\n        BigInteger amountSatoshi = HtdfToSatoshi(BigDecimal.valueOf(0.12345678));\n        HtdfTransfer.transfer(dstAddress, amountSatoshi, memo);\n    }\n}\n", "refactored": false}
{"hexsha": "f416cf9485d12f7d7cc768a7e123b492cfdebc32", "ext": "java", "lang": "Java", "content": "public class S3AReadOpContext extends S3AOpContext {\n\n    /**\n     * Path of read.\n     */\n    private final Path path;\n\n    /**\n     * Initial input policy of the stream.\n     */\n    private S3AInputPolicy inputPolicy;\n\n    /**\n     * How to detect and deal with the object being updated during read.\n     */\n    private ChangeDetectionPolicy changeDetectionPolicy;\n\n    /**\n     * Readahead for GET operations/skip, etc.\n     */\n    private long readahead;\n\n    private AuditSpan auditSpan;\n\n    /**\n     * Threshold for stream reads to switch to\n     * asynchronous draining.\n     */\n    private long asyncDrainThreshold;\n\n    /**\n     * Instantiate.\n     * @param path path of read\n     * @param invoker invoker for normal retries.\n     * @param stats Fileystem statistics (may be null)\n     * @param instrumentation statistics context\n     * @param dstFileStatus target file status\n     */\n    public S3AReadOpContext(final Path path, Invoker invoker, @Nullable FileSystem.Statistics stats, S3AStatisticsContext instrumentation, FileStatus dstFileStatus) {\n        super(invoker, stats, instrumentation, dstFileStatus);\n        this.path = requireNonNull(path);\n    }\n\n    /**\n     * validate the context.\n     * @return a read operation context ready for use.\n     */\n    public S3AReadOpContext build() {\n        requireNonNull(inputPolicy, \"inputPolicy\");\n        requireNonNull(changeDetectionPolicy, \"changeDetectionPolicy\");\n        requireNonNull(auditSpan, \"auditSpan\");\n        requireNonNull(inputPolicy, \"inputPolicy\");\n        Preconditions.checkArgument(readahead >= 0, \"invalid readahead %d\", readahead);\n        Preconditions.checkArgument(asyncDrainThreshold >= 0, \"invalid drainThreshold %d\", asyncDrainThreshold);\n        return this;\n    }\n\n    /**\n     * Get invoker to use for read operations.\n     * @return invoker to use for read codepaths\n     */\n    public Invoker getReadInvoker() {\n        return invoker;\n    }\n\n    /**\n     * Get the path of this read.\n     * @return path.\n     */\n    public Path getPath() {\n        return path;\n    }\n\n    /**\n     * Get the IO policy.\n     * @return the initial input policy.\n     */\n    public S3AInputPolicy getInputPolicy() {\n        return inputPolicy;\n    }\n\n    public ChangeDetectionPolicy getChangeDetectionPolicy() {\n        return changeDetectionPolicy;\n    }\n\n    /**\n     * Get the readahead for this operation.\n     * @return a value {@literal >=} 0\n     */\n    public long getReadahead() {\n        return readahead;\n    }\n\n    /**\n     * Get the audit which was active when the file was opened.\n     * @return active span\n     */\n    public AuditSpan getAuditSpan() {\n        return auditSpan;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withInputPolicy(final S3AInputPolicy value) {\n        inputPolicy = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withChangeDetectionPolicy(final ChangeDetectionPolicy value) {\n        changeDetectionPolicy = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withReadahead(final long value) {\n        readahead = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withAuditSpan(final AuditSpan value) {\n        auditSpan = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withAsyncDrainThreshold(final long value) {\n        asyncDrainThreshold = value;\n        return this;\n    }\n\n    public long getAsyncDrainThreshold() {\n        return asyncDrainThreshold;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"S3AReadOpContext{\");\n        sb.append(\"path=\").append(path);\n        sb.append(\", inputPolicy=\").append(inputPolicy);\n        sb.append(\", readahead=\").append(readahead);\n        sb.append(\", changeDetectionPolicy=\").append(changeDetectionPolicy);\n        sb.append('}');\n        return sb.toString();\n    }\n}\n", "class_id": 0, "repo": "MingXiangLi/hadoop", "file": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AReadOpContext.java", "last_update_at": "2021-12-23T03:23:44+00:00", "original_content": "public class S3AReadOpContext extends S3AOpContext {\n\n    /**\n     * Path of read.\n     */\n    private final Path path;\n\n    /**\n     * Initial input policy of the stream.\n     */\n    private S3AInputPolicy inputPolicy;\n\n    /**\n     * How to detect and deal with the object being updated during read.\n     */\n    private ChangeDetectionPolicy changeDetectionPolicy;\n\n    /**\n     * Readahead for GET operations/skip, etc.\n     */\n    private long readahead;\n\n    private AuditSpan auditSpan;\n\n    /**\n     * Threshold for stream reads to switch to\n     * asynchronous draining.\n     */\n    private long asyncDrainThreshold;\n\n    /**\n     * Instantiate.\n     * @param path path of read\n     * @param invoker invoker for normal retries.\n     * @param stats Fileystem statistics (may be null)\n     * @param instrumentation statistics context\n     * @param dstFileStatus target file status\n     */\n    public S3AReadOpContext(final Path path, Invoker invoker, @Nullable FileSystem.Statistics stats, S3AStatisticsContext instrumentation, FileStatus dstFileStatus) {\n        super(invoker, stats, instrumentation, dstFileStatus);\n        this.path = requireNonNull(path);\n    }\n\n    /**\n     * validate the context.\n     * @return a read operation context ready for use.\n     */\n    public S3AReadOpContext build() {\n        requireNonNull(inputPolicy, \"inputPolicy\");\n        requireNonNull(changeDetectionPolicy, \"changeDetectionPolicy\");\n        requireNonNull(auditSpan, \"auditSpan\");\n        requireNonNull(inputPolicy, \"inputPolicy\");\n        Preconditions.checkArgument(readahead >= 0, \"invalid readahead %d\", readahead);\n        Preconditions.checkArgument(asyncDrainThreshold >= 0, \"invalid drainThreshold %d\", asyncDrainThreshold);\n        return this;\n    }\n\n    /**\n     * Get invoker to use for read operations.\n     * @return invoker to use for read codepaths\n     */\n    public Invoker getReadInvoker() {\n        return invoker;\n    }\n\n    /**\n     * Get the path of this read.\n     * @return path.\n     */\n    public Path getPath() {\n        return path;\n    }\n\n    /**\n     * Get the IO policy.\n     * @return the initial input policy.\n     */\n    public S3AInputPolicy getInputPolicy() {\n        return inputPolicy;\n    }\n\n    public ChangeDetectionPolicy getChangeDetectionPolicy() {\n        return changeDetectionPolicy;\n    }\n\n    /**\n     * Get the readahead for this operation.\n     * @return a value {@literal >=} 0\n     */\n    public long getReadahead() {\n        return readahead;\n    }\n\n    /**\n     * Get the audit which was active when the file was opened.\n     * @return active span\n     */\n    public AuditSpan getAuditSpan() {\n        return auditSpan;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withInputPolicy(final S3AInputPolicy value) {\n        inputPolicy = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withChangeDetectionPolicy(final ChangeDetectionPolicy value) {\n        changeDetectionPolicy = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withReadahead(final long value) {\n        readahead = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withAuditSpan(final AuditSpan value) {\n        auditSpan = value;\n        return this;\n    }\n\n    /**\n     * Set builder value.\n     * @param value new value\n     * @return the builder\n     */\n    public S3AReadOpContext withAsyncDrainThreshold(final long value) {\n        asyncDrainThreshold = value;\n        return this;\n    }\n\n    public long getAsyncDrainThreshold() {\n        return asyncDrainThreshold;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"S3AReadOpContext{\");\n        sb.append(\"path=\").append(path);\n        sb.append(\", inputPolicy=\").append(inputPolicy);\n        sb.append(\", readahead=\").append(readahead);\n        sb.append(\", changeDetectionPolicy=\").append(changeDetectionPolicy);\n        sb.append('}');\n        return sb.toString();\n    }\n}\n", "refactored": false}
{"hexsha": "613edc207594fb66f34f7fbd0a1d1f3fc371a4e9", "ext": "java", "lang": "Java", "content": "public final class LargestRowInTreeTestCase {\n\n    private LargestRowInTree alg;\n\n    /**\n     * Init.\n     */\n    @Before\n    public void init() {\n        this.alg = new LargestRowInTree();\n    }\n\n    @Test\n    public void test() {\n        final PlainTree tree = new PlainTree(1);\n        tree.left = new PlainTree(3);\n        tree.left.left = new PlainTree(5);\n        tree.left.right = new PlainTree(3);\n        tree.right = new PlainTree(2);\n        tree.right.right = new PlainTree(9);\n        Assert.assertEquals(Arrays.asList(1, 3, 9), this.alg.largestValues(tree));\n    }\n}\n", "class_id": 0, "repo": "strogiyotec/leetcode-oo", "file": "src/test/java/leetcode/oo/tree/LargestRowInTreeTestCase.java", "last_update_at": "2021-05-03T16:51:47+00:00", "original_content": "public final class LargestRowInTreeTestCase {\n\n    private LargestRowInTree alg;\n\n    /**\n     * Init.\n     */\n    @Before\n    public void init() {\n        this.alg = new LargestRowInTree();\n    }\n\n    @Test\n    public void test() {\n        final PlainTree tree = new PlainTree(1);\n        tree.left = new PlainTree(3);\n        tree.left.left = new PlainTree(5);\n        tree.left.right = new PlainTree(3);\n        tree.right = new PlainTree(2);\n        tree.right.right = new PlainTree(9);\n        Assert.assertEquals(Arrays.asList(1, 3, 9), this.alg.largestValues(tree));\n    }\n}\n", "refactored": false}
{"hexsha": "d9ecb15e843577b711bc488b0ff3800761dceffb", "ext": "java", "lang": "Java", "content": "@Controller\npublic class ModelController {\n\n    @ModelAttribute(\"girl\")\n    public Girl init(Model model) {\n        Girl g = new Girl();\n        g.setAge(28);\n        g.setName(\"??\");\n        return g;\n    }\n\n    @RequestMapping(\"/m1\")\n    public String m1(Model model) {\n        System.out.println(model.containsAttribute(\"girl\"));\n        return \"msg\";\n    }\n\n    @RequestMapping(\"/m2/{name}/{age}\")\n    public String m1(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName() + girl.getAge());\n        return \"msg\";\n    }\n\n    @RequestMapping(value = \"m3\", method = RequestMethod.POST)\n    public String m3(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName() + girl.getAge());\n        return \"msg\";\n    }\n}\n", "class_id": 0, "repo": "djwangweijie/springmvc001", "file": "src/com/wwj/controller/ModelController.java", "last_update_at": "2021-07-14T14:36:52+00:00", "original_content": "@Controller\npublic class ModelController {\n\n    @ModelAttribute(\"girl\")\n    public Girl init(Model model) {\n        Girl g = new Girl();\n        g.setAge(28);\n        g.setName(\"??\");\n        return g;\n    }\n\n    @RequestMapping(\"/m1\")\n    public String m1(Model model) {\n        System.out.println(model.containsAttribute(\"girl\"));\n        return \"msg\";\n    }\n\n    @RequestMapping(\"/m2/{name}/{age}\")\n    public String m1(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName() + girl.getAge());\n        return \"msg\";\n    }\n\n    @RequestMapping(value = \"m3\", method = RequestMethod.POST)\n    public String m3(@ModelAttribute Girl girl) {\n        System.out.println(girl.getName() + girl.getAge());\n        return \"msg\";\n    }\n}\n", "refactored": false}
{"hexsha": "93ee8390b37253340129ea65b53a309a0aac8927", "ext": "java", "lang": "Java", "content": "public class SequenceTest {\n\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newFixedThreadPool(100);\n        ExecutorService exec1 = Executors.newFixedThreadPool(100);\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"????:\" + System.currentTimeMillis());\n        Runnable runnable = new SequenceRunnable();\n        int i = 0;\n        while (i < 100) try {\n            exec.submit(runnable);\n            exec1.submit(runnable);\n        } finally {\n            i++;\n        }\n        System.out.println(\"???:\" + (System.currentTimeMillis() - startTime));\n        //?????\n        exec.shutdown();\n        exec1.shutdown();\n    }\n}\n", "class_id": 0, "repo": "XWxiaowei/TempCode", "file": "java-thread-demo/src/test/com/jay/thread/SequenceTest.java", "last_update_at": "2021-12-29T12:11:37+00:00", "original_content": "public class SequenceTest {\n\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newFixedThreadPool(100);\n        ExecutorService exec1 = Executors.newFixedThreadPool(100);\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"????:\" + System.currentTimeMillis());\n        Runnable runnable = new SequenceRunnable();\n        for (int i = 0; i < 100; i++) {\n            exec.submit(runnable);\n            exec1.submit(runnable);\n        }\n        System.out.println(\"???:\" + (System.currentTimeMillis() - startTime));\n        //?????\n        exec.shutdown();\n        exec1.shutdown();\n    }\n}\n", "refactored": true}
{"hexsha": "6571a406fc36a6fca11c11117b7c8d3178aa31e8", "ext": "java", "lang": "Java", "content": "@Service\npublic class DocumentoService {\n\n    @Autowired\n    private DocumentoRepository documentoRepository;\n\n    @Autowired\n    private MilitarRepository militarRepository;\n\n    @Autowired\n    private MilitarService militarService;\n\n    /**\n     * Cria um novo documento\n     *\n     * @param documento DTO do documento a ser salvo\n     * @return retorna um response file do documento salvo\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFDocumento criar(DocumentoDTO documentodto) throws IOException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"validation failed\");\n        RFDocumento rfdoc;\n        Documento doc = DocumentoMapper.toModel(documentodto);\n        doc.setMilitares(null);\n        List<Militar> militares = new ArrayList<Militar>();\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n                }\n            });\n        }\n        doc.setMilitares(militares);\n        rfdoc = new RFDocumento(documentoRepository.save(doc));\n        return rfdoc;\n    }\n\n    /**\n     * Edita um documento e salva no banco\n     *\n     * @param id           id do documento a ser editado\n     * @param documentodto dto com documento atualizado\n     * @return\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFEditarDocumento editar(long id, DocumentoDTO documentodto) throws IOException, ValidationException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"erro\");\n        Documento doc = documentoRepository.findById(id).get();\n        doc.setTipo(documentodto.getTipo());\n        doc.setNumeracao(documentodto.getNumeracao());\n        doc.setNome(documentodto.getNome());\n        doc.setDescricao(documentodto.getDescricao());\n        doc.setData(documentodto.getData());\n        doc.setPublico(documentodto.getPublico());\n        List<Militar> militares = new ArrayList<Militar>();\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n                }\n            });\n        }\n        doc.setMilitares(militares);\n        documentoRepository.save(doc);\n        return new RFEditarDocumento(doc);\n    }\n\n    /**\n     * Busca um documento pelo id\n     *\n     * @param id id do documento a ser procurado\n     * @return retorna um response file do documento\n     * @throws IOException\n     */\n    public RFDocumento getDocumento(Long id) throws IOException {\n        Documento doc = documentoRepository.findById(id).get();\n        RFDocumento rfdoc = new RFDocumento(doc);\n        return rfdoc;\n    }\n\n    /**\n     * Busca um documento utilizando multiplos campos e uma specification\n     *\n     * @param docJson jsonNode gerada com os campos de busca\n     * @return uma lista de responsefiles de documentos\n     * @throws IOException\n     */\n    public List<RFBuscaDocumentos> getDocumento(Map<String, Object> map) throws IOException {\n        DocumentoSpecification ds = new DocumentoSpecification(map);\n        List<RFBuscaDocumentos> rfDocList = documentoRepository.findAll(ds).stream().map(documento -> {\n            RFBuscaDocumentos newRFDoc = new RFBuscaDocumentos(documento);\n            return newRFDoc;\n        }).collect(Collectors.toList());\n        /*\n         * List<RFBuscaDocumentos> rfDocList =\n         * documentoRepository.findAll().stream().map(documento -> { RFBuscaDocumentos\n         * newRFDoc = new RFBuscaDocumentos(documento); return newRFDoc;\n         * }).collect(Collectors.toList());\n         */\n        return rfDocList;\n    }\n}\n", "class_id": 0, "repo": "digitalse-bomb/back", "file": "src/main/java/com/digitalse/cbm/back/services/DocumentoService.java", "last_update_at": "2021-07-17T17:08:41+00:00", "original_content": "@Service\npublic class DocumentoService {\n\n    @Autowired\n    private DocumentoRepository documentoRepository;\n\n    @Autowired\n    private MilitarRepository militarRepository;\n\n    @Autowired\n    private MilitarService militarService;\n\n    /**\n     * Cria um novo documento\n     *\n     * @param documento DTO do documento a ser salvo\n     * @return retorna um response file do documento salvo\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFDocumento criar(DocumentoDTO documentodto) throws IOException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"validation failed\");\n        RFDocumento rfdoc;\n        Documento doc = DocumentoMapper.toModel(documentodto);\n        doc.setMilitares(null);\n        List<Militar> militares = new ArrayList<Militar>();\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n                }\n            });\n        }\n        doc.setMilitares(militares);\n        rfdoc = new RFDocumento(documentoRepository.save(doc));\n        return rfdoc;\n    }\n\n    /**\n     * Edita um documento e salva no banco\n     *\n     * @param id           id do documento a ser editado\n     * @param documentodto dto com documento atualizado\n     * @return\n     * @throws IOException\n     * @throws HttpException\n     */\n    public RFEditarDocumento editar(long id, DocumentoDTO documentodto) throws IOException, ValidationException, HttpException {\n        if (!documentodto.isValidationOk())\n            throw new HttpException(\"erro\");\n        Documento doc = documentoRepository.findById(id).get();\n        doc.setTipo(documentodto.getTipo());\n        doc.setNumeracao(documentodto.getNumeracao());\n        doc.setNome(documentodto.getNome());\n        doc.setDescricao(documentodto.getDescricao());\n        doc.setData(documentodto.getData());\n        doc.setPublico(documentodto.getPublico());\n        List<Militar> militares = new ArrayList<Militar>();\n        if (documentodto.getMilitares() != null) {\n            documentodto.getMilitares().forEach(element -> {\n                if (!militarRepository.existsByMatricula(element.getMatricula())) {\n                    try {\n                        if (militarService.getListByMatricula(element.getMatricula()) != null) {\n                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());\n                            mil = militarRepository.save(mil);\n                            militares.add(mil);\n                        } else {\n                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Envie um militar valido\");\n                        }\n                    } catch (IOException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                } else {\n                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();\n                    militares.add(mil);\n                }\n            });\n        }\n        doc.setMilitares(militares);\n        documentoRepository.save(doc);\n        return new RFEditarDocumento(doc);\n    }\n\n    /**\n     * Busca um documento pelo id\n     *\n     * @param id id do documento a ser procurado\n     * @return retorna um response file do documento\n     * @throws IOException\n     */\n    public RFDocumento getDocumento(Long id) throws IOException {\n        Documento doc = documentoRepository.findById(id).get();\n        RFDocumento rfdoc = new RFDocumento(doc);\n        return rfdoc;\n    }\n\n    /**\n     * Busca um documento utilizando multiplos campos e uma specification\n     *\n     * @param docJson jsonNode gerada com os campos de busca\n     * @return uma lista de responsefiles de documentos\n     * @throws IOException\n     */\n    public List<RFBuscaDocumentos> getDocumento(Map<String, Object> map) throws IOException {\n        DocumentoSpecification ds = new DocumentoSpecification(map);\n        List<RFBuscaDocumentos> rfDocList = documentoRepository.findAll(ds).stream().map(documento -> {\n            RFBuscaDocumentos newRFDoc = new RFBuscaDocumentos(documento);\n            return newRFDoc;\n        }).collect(Collectors.toList());\n        /*\n         * List<RFBuscaDocumentos> rfDocList =\n         * documentoRepository.findAll().stream().map(documento -> { RFBuscaDocumentos\n         * newRFDoc = new RFBuscaDocumentos(documento); return newRFDoc;\n         * }).collect(Collectors.toList());\n         */\n        return rfDocList;\n    }\n}\n", "refactored": false}
{"hexsha": "0497272e2b6a1d4fbfc2a7ce34c849fbfbcb0d9d", "ext": "java", "lang": "Java", "content": "@SpringBootTest(classes = { Application.class, TestIdamConfiguration.class })\n@AutoConfigureMockMvc\n@AutoConfigureWireMock(port = 0, stubs = \"classpath:/wiremock-stubs\")\n@ActiveProfiles(\"itest\")\npublic class BaseTest {\n\n    public static final long AUTH_TOKEN_TTL = 14400000;\n\n    public static final String IDAM_MOCK_USER_ID = \"445\";\n\n    private static final String EXAMPLE_REQUEST_ID = \"TEST REQUEST ID\";\n\n    @SpyBean\n    @Autowired\n    protected AuditRepository auditRepository;\n\n    public static HttpHeaders createHttpHeaders(String serviceName) throws JOSEException {\n        return createHttpHeaders(AUTH_TOKEN_TTL, serviceName, AUTH_TOKEN_TTL);\n    }\n\n    protected static HttpHeaders createHttpHeaders(long authTtlMillis, String serviceName, long s2sAuthTtlMillis) throws JOSEException {\n        HttpHeaders headers = new HttpHeaders();\n        String authToken = BEARER + generateAuthToken(authTtlMillis);\n        headers.add(AUTHORIZATION, authToken);\n        String s2SToken = generateS2SToken(serviceName, s2sAuthTtlMillis);\n        headers.add(SERVICE_AUTHORIZATION, s2SToken);\n        headers.add(AuditConfiguration.REQUEST_ID, EXAMPLE_REQUEST_ID);\n        return headers;\n    }\n\n    protected ResultMatcher hasGeneratedLogAudit(AuditOperationType operationType, String invokingService, List<String> documentIds, String caseId, String jurisdiction, String caseType) {\n        return result -> verifyLogAuditValues(result, operationType, invokingService, documentIds, caseId, jurisdiction, caseType);\n    }\n\n    protected void verifyLogAuditValues(MvcResult result, AuditOperationType operationType, String invokingService, List<String> documentIds, String caseId, String jurisdiction, String caseType) {\n        ArgumentCaptor<AuditEntry> captor = ArgumentCaptor.forClass(AuditEntry.class);\n        verify(auditRepository).save(captor.capture());\n        AuditEntry auditEntry = captor.getValue();\n        assertNotNull(\"DateTime\", auditEntry.getDateTime());\n        assertEquals(\"Operation Type\", operationType.getLabel(), auditEntry.getOperationType());\n        assertEquals(\"Idam ID\", IDAM_MOCK_USER_ID, auditEntry.getIdamId());\n        assertEquals(\"Invoking Service\", invokingService, auditEntry.getInvokingService());\n        assertEquals(\"HTTP Status\", result.getResponse().getStatus(), auditEntry.getHttpStatus());\n        assertEquals(\"HTTP Method\", result.getRequest().getMethod(), auditEntry.getHttpMethod());\n        assertEquals(\"Request Path\", result.getRequest().getRequestURI(), auditEntry.getRequestPath());\n        assertEquals(\"Request ID\", EXAMPLE_REQUEST_ID, auditEntry.getRequestId());\n        // NB: skip validation of inputs for BAD_REQUEST as some may not have been populated\n        if (result.getResponse().getStatus() != HttpStatus.BAD_REQUEST.value()) {\n            if (documentIds != null && !documentIds.isEmpty()) {\n                assertThat(auditEntry.getDocumentIds()).isNotNull().hasSize(documentIds.size()).containsAll(documentIds);\n            } else {\n                assertThat(auditEntry.getDocumentIds()).isNullOrEmpty();\n            }\n            if (caseId != null && !caseId.equals(\"\")) {\n                assertThat(auditEntry.getCaseId()).isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseId()).isNullOrEmpty();\n            }\n            if (jurisdiction != null && !jurisdiction.equals(\"\")) {\n                assertThat(auditEntry.getJurisdiction()).isNotNull();\n            } else {\n                assertThat(auditEntry.getJurisdiction()).isNullOrEmpty();\n            }\n            if (caseType != null && !caseType.equals(\"\")) {\n                assertThat(auditEntry.getCaseType()).isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseType()).isNullOrEmpty();\n            }\n        }\n    }\n\n    private static String generateAuthToken(long ttlMillis) throws JOSEException {\n        JWTClaimsSet.Builder builder = new JWTClaimsSet.Builder().subject(\"API_Stub\").issueTime(new Date()).claim(TOKEN_NAME, ACCESS_TOKEN).expirationTime(new Date(System.currentTimeMillis() + ttlMillis));\n        SignedJWT signedJWT = new SignedJWT(new JWSHeader.Builder(JWSAlgorithm.RS256).keyID(KeyGenUtil.getRsaJWK().getKeyID()).build(), builder.build());\n        signedJWT.sign(new RSASSASigner(KeyGenUtil.getRsaJWK()));\n        return signedJWT.serialize();\n    }\n\n    private static String generateS2SToken(String serviceName, long ttlMillis) {\n        return Jwts.builder().setSubject(serviceName).setExpiration(new Date(System.currentTimeMillis() + ttlMillis)).signWith(SignatureAlgorithm.HS256, TextCodec.BASE64.encode(\"AA\")).compact();\n    }\n}\n", "class_id": 0, "repo": "duranfatih/ccd-case-document-am-api", "file": "src/integrationTest/java/uk/gov/hmcts/reform/ccd/documentam/BaseTest.java", "last_update_at": "2021-04-13T07:06:18+00:00", "original_content": "@SpringBootTest(classes = { Application.class, TestIdamConfiguration.class })\n@AutoConfigureMockMvc\n@AutoConfigureWireMock(port = 0, stubs = \"classpath:/wiremock-stubs\")\n@ActiveProfiles(\"itest\")\npublic class BaseTest {\n\n    public static final long AUTH_TOKEN_TTL = 14400000;\n\n    public static final String IDAM_MOCK_USER_ID = \"445\";\n\n    private static final String EXAMPLE_REQUEST_ID = \"TEST REQUEST ID\";\n\n    @SpyBean\n    @Autowired\n    protected AuditRepository auditRepository;\n\n    public static HttpHeaders createHttpHeaders(String serviceName) throws JOSEException {\n        return createHttpHeaders(AUTH_TOKEN_TTL, serviceName, AUTH_TOKEN_TTL);\n    }\n\n    protected static HttpHeaders createHttpHeaders(long authTtlMillis, String serviceName, long s2sAuthTtlMillis) throws JOSEException {\n        HttpHeaders headers = new HttpHeaders();\n        String authToken = BEARER + generateAuthToken(authTtlMillis);\n        headers.add(AUTHORIZATION, authToken);\n        String s2SToken = generateS2SToken(serviceName, s2sAuthTtlMillis);\n        headers.add(SERVICE_AUTHORIZATION, s2SToken);\n        headers.add(AuditConfiguration.REQUEST_ID, EXAMPLE_REQUEST_ID);\n        return headers;\n    }\n\n    protected ResultMatcher hasGeneratedLogAudit(AuditOperationType operationType, String invokingService, List<String> documentIds, String caseId, String jurisdiction, String caseType) {\n        return result -> verifyLogAuditValues(result, operationType, invokingService, documentIds, caseId, jurisdiction, caseType);\n    }\n\n    protected void verifyLogAuditValues(MvcResult result, AuditOperationType operationType, String invokingService, List<String> documentIds, String caseId, String jurisdiction, String caseType) {\n        ArgumentCaptor<AuditEntry> captor = ArgumentCaptor.forClass(AuditEntry.class);\n        verify(auditRepository).save(captor.capture());\n        AuditEntry auditEntry = captor.getValue();\n        assertNotNull(\"DateTime\", auditEntry.getDateTime());\n        assertEquals(\"Operation Type\", operationType.getLabel(), auditEntry.getOperationType());\n        assertEquals(\"Idam ID\", IDAM_MOCK_USER_ID, auditEntry.getIdamId());\n        assertEquals(\"Invoking Service\", invokingService, auditEntry.getInvokingService());\n        assertEquals(\"HTTP Status\", result.getResponse().getStatus(), auditEntry.getHttpStatus());\n        assertEquals(\"HTTP Method\", result.getRequest().getMethod(), auditEntry.getHttpMethod());\n        assertEquals(\"Request Path\", result.getRequest().getRequestURI(), auditEntry.getRequestPath());\n        assertEquals(\"Request ID\", EXAMPLE_REQUEST_ID, auditEntry.getRequestId());\n        // NB: skip validation of inputs for BAD_REQUEST as some may not have been populated\n        if (result.getResponse().getStatus() != HttpStatus.BAD_REQUEST.value()) {\n            if (documentIds != null && !documentIds.isEmpty()) {\n                assertThat(auditEntry.getDocumentIds()).isNotNull().hasSize(documentIds.size()).containsAll(documentIds);\n            } else {\n                assertThat(auditEntry.getDocumentIds()).isNullOrEmpty();\n            }\n            if (caseId != null && !caseId.equals(\"\")) {\n                assertThat(auditEntry.getCaseId()).isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseId()).isNullOrEmpty();\n            }\n            if (jurisdiction != null && !jurisdiction.equals(\"\")) {\n                assertThat(auditEntry.getJurisdiction()).isNotNull();\n            } else {\n                assertThat(auditEntry.getJurisdiction()).isNullOrEmpty();\n            }\n            if (caseType != null && !caseType.equals(\"\")) {\n                assertThat(auditEntry.getCaseType()).isNotNull();\n            } else {\n                assertThat(auditEntry.getCaseType()).isNullOrEmpty();\n            }\n        }\n    }\n\n    private static String generateAuthToken(long ttlMillis) throws JOSEException {\n        JWTClaimsSet.Builder builder = new JWTClaimsSet.Builder().subject(\"API_Stub\").issueTime(new Date()).claim(TOKEN_NAME, ACCESS_TOKEN).expirationTime(new Date(System.currentTimeMillis() + ttlMillis));\n        SignedJWT signedJWT = new SignedJWT(new JWSHeader.Builder(JWSAlgorithm.RS256).keyID(KeyGenUtil.getRsaJWK().getKeyID()).build(), builder.build());\n        signedJWT.sign(new RSASSASigner(KeyGenUtil.getRsaJWK()));\n        return signedJWT.serialize();\n    }\n\n    private static String generateS2SToken(String serviceName, long ttlMillis) {\n        return Jwts.builder().setSubject(serviceName).setExpiration(new Date(System.currentTimeMillis() + ttlMillis)).signWith(SignatureAlgorithm.HS256, TextCodec.BASE64.encode(\"AA\")).compact();\n    }\n}\n", "refactored": false}
{"hexsha": "1962c85665f13d6ae1a31bdf9bcc8be6c9e4f9ee", "ext": "java", "lang": "Java", "content": "public class TopMetricFilter implements ISetWiseProcessingStrategy {\r\n\r\n    /**\r\n     * Reference to the logger\r\n     */\r\n    private static final Logger LOGGER = LogManager.getLogger(\"main\");\r\n\r\n    /**\r\n     * Internally used correlation threshold.\r\n     */\r\n    double correlationThreshold = 0.5;\r\n\r\n    /*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see de.ugoe.cs.cpdp.IParameterizable#setParameter(java.lang.String)\r\n     */\r\n    @Override\r\n    public void setParameter(String parameters) {\r\n        if (parameters != null && !parameters.equals(\"\")) {\r\n            this.correlationThreshold = Double.parseDouble(parameters);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void apply(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) {\r\n        try {\r\n            determineTopKAttributes(testversion, trainversionSet);\r\n        } catch (Exception e) {\r\n            LOGGER.error(\"Failure during metric selection: \" + e.getMessage());\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private void determineTopKAttributes(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) throws Exception {\r\n        Instances testdata = testversion.getInstances();\r\n        Integer[] counts = new Integer[trainversionSet.get(0).getInstances().get(0).numAttributes() - 1];\r\n        IntStream.range(0, counts.length).forEach(val -> counts[val] = 0);\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            J48 decisionTree = new J48();\r\n            decisionTree.buildClassifier(traindata);\r\n            int k = 0;\r\n            for (int j = 0; j < traindata.numAttributes(); j++) {\r\n                if (j != traindata.classIndex()) {\r\n                    if (decisionTree.toString().contains(traindata.attribute(j).name())) {\r\n                        counts[k] = counts[k] + 1;\r\n                    }\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n        int[] topkIndex = new int[counts.length];\r\n        IntStream.range(0, counts.length).forEach(val -> topkIndex[val] = val);\r\n        SortUtils.quicksort(counts, topkIndex, true);\r\n        // get CFSs for each training set\r\n        List<Set<Integer>> cfsSets = new LinkedList<>();\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            boolean selectionSuccessful = false;\r\n            boolean secondAttempt = false;\r\n            Instances traindataCopy = null;\r\n            for (; ; ) try {\r\n                try {\r\n                    if (secondAttempt) {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindataCopy);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    } else {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindata);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    }\r\n                } catch (IllegalArgumentException e) {\r\n                    String regex = \"A nominal attribute \\\\((.*)\\\\) cannot have duplicate labels.*\";\r\n                    Pattern p = Pattern.compile(regex);\r\n                    Matcher m = p.matcher(e.getMessage());\r\n                    if (!m.find()) {\r\n                        // cannot treat problem, rethrow exception\r\n                        throw e;\r\n                    }\r\n                    String attributeName = m.group(1);\r\n                    int attrIndex = traindata.attribute(attributeName).index();\r\n                    if (secondAttempt) {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindataCopy, attrIndex);\r\n                    } else {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindata, attrIndex);\r\n                    }\r\n                    LOGGER.info(\"upscaled attribute \" + attributeName + \"; restarting training\");\r\n                    secondAttempt = true;\r\n                    continue;\r\n                }\r\n            } finally {\r\n                if (!// dummy loop for internal continue\r\n                !selectionSuccessful) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        double[] coverages = new double[topkIndex.length];\r\n        for (Set<Integer> cfsSet : cfsSets) {\r\n            Set<Integer> topkSet = new HashSet<>();\r\n            for (int k = 0; k < topkIndex.length; k++) {\r\n                topkSet.add(topkIndex[k]);\r\n                coverages[k] += (coverage(topkSet, cfsSet) / trainversionSet.size());\r\n            }\r\n        }\r\n        double bestCoverageValue = Double.MIN_VALUE;\r\n        int bestCoverageIndex = 0;\r\n        for (int i = 0; i < coverages.length; i++) {\r\n            if (coverages[i] > bestCoverageValue) {\r\n                bestCoverageValue = coverages[i];\r\n                bestCoverageIndex = i;\r\n            }\r\n        }\r\n        // build correlation matrix\r\n        SpearmansCorrelation corr = new SpearmansCorrelation();\r\n        double[][] correlationMatrix = new double[bestCoverageIndex][bestCoverageIndex];\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            double[][] vectors = new double[bestCoverageIndex][traindata.size()];\r\n            for (int i = 0; i < traindata.size(); i++) {\r\n                for (int j = 0; j < bestCoverageIndex; j++) {\r\n                    vectors[j][i] = traindata.get(i).value(topkIndex[j]);\r\n                }\r\n            }\r\n            for (int j = 0; j < bestCoverageIndex; j++) {\r\n                for (int k = j + 1; k < bestCoverageIndex; k++) {\r\n                    correlationMatrix[j][k] = Math.abs(corr.correlation(vectors[j], vectors[k]));\r\n                }\r\n            }\r\n        }\r\n        Set<Integer> topkSetIndexSet = new TreeSet<>();\r\n        // complexity\r\n        for (int j = 0; j < bestCoverageIndex && j < 30; j++) {\r\n            topkSetIndexSet.add(j);\r\n        }\r\n        Set<Set<Integer>> allCombinations = Sets.powerSet(topkSetIndexSet);\r\n        double bestOptCoverage = Double.MIN_VALUE;\r\n        Set<Integer> opttopkSetIndexSet = null;\r\n        for (Set<Integer> combination : allCombinations) {\r\n            if (isUncorrelated(correlationMatrix, combination)) {\r\n                double currentCoverage = 0.0;\r\n                Set<Integer> topkCombination = new TreeSet<>();\r\n                for (Integer index : combination) {\r\n                    topkCombination.add(topkIndex[index]);\r\n                }\r\n                for (Set<Integer> cfsSet : cfsSets) {\r\n                    currentCoverage += (coverage(topkCombination, cfsSet) / trainversionSet.size());\r\n                }\r\n                if (currentCoverage > bestOptCoverage) {\r\n                    bestOptCoverage = currentCoverage;\r\n                    opttopkSetIndexSet = combination;\r\n                }\r\n            }\r\n        }\r\n        if (opttopkSetIndexSet == null) {\r\n            throw new RuntimeException(\"Could not determine a best top-k set with optimal coverage. This means that the top-k set and the subset determined by CFS are disjunctive.\");\r\n        }\r\n        Set<Integer> opttopkIndex = new TreeSet<>();\r\n        for (Integer index : opttopkSetIndexSet) {\r\n            opttopkIndex.add(topkIndex[index]);\r\n        }\r\n        LOGGER.debug(\"selected the following metrics:\");\r\n        for (Integer index : opttopkIndex) {\r\n            LOGGER.debug(trainversionSet.get(0).getInstances().get(0).attribute(index).name());\r\n        }\r\n        // finally remove attributes\r\n        for (int j = testdata.numAttributes() - 1; j >= 0; j--) {\r\n            if (j != testdata.classIndex() && !opttopkIndex.contains(j)) {\r\n                testdata.deleteAttributeAt(j);\r\n                for (SoftwareVersion trainversion : trainversionSet) {\r\n                    Instances traindata = trainversion.getInstances();\r\n                    traindata.deleteAttributeAt(j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private boolean isUncorrelated(double[][] correlationMatrix, Set<Integer> combination) {\r\n        Integer[] intCombination = combination.toArray(new Integer[0]);\r\n        boolean areUncorrelated = true;\r\n        for (int i = 0; areUncorrelated && i < intCombination.length; i++) {\r\n            for (int j = i + 1; areUncorrelated && j < intCombination.length; j++) {\r\n                areUncorrelated &= correlationMatrix[intCombination[i]][intCombination[j]] > this.correlationThreshold;\r\n            }\r\n        }\r\n        return areUncorrelated;\r\n    }\r\n\r\n    private static double coverage(Set<Integer> topkSet, Set<Integer> cfsSet) {\r\n        Set<Integer> topkSetCopy1 = new HashSet<>(topkSet);\r\n        topkSetCopy1.retainAll(cfsSet);\r\n        Set<Integer> topkSetCopy2 = new HashSet<>(topkSet);\r\n        topkSetCopy2.addAll(cfsSet);\r\n        return ((double) topkSetCopy1.size()) / topkSetCopy2.size();\r\n    }\r\n}\r\n", "class_id": 0, "repo": "SteffenTunkel/CrossPare", "file": "CrossPare/src/main/java/de/ugoe/cs/cpdp/dataprocessing/TopMetricFilter.java", "last_update_at": "2021-12-01T06:46:04+00:00", "original_content": "public class TopMetricFilter implements ISetWiseProcessingStrategy {\r\n\r\n    /**\r\n     * Reference to the logger\r\n     */\r\n    private static final Logger LOGGER = LogManager.getLogger(\"main\");\r\n\r\n    /**\r\n     * Internally used correlation threshold.\r\n     */\r\n    double correlationThreshold = 0.5;\r\n\r\n    /*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see de.ugoe.cs.cpdp.IParameterizable#setParameter(java.lang.String)\r\n     */\r\n    @Override\r\n    public void setParameter(String parameters) {\r\n        if (parameters != null && !parameters.equals(\"\")) {\r\n            this.correlationThreshold = Double.parseDouble(parameters);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void apply(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) {\r\n        try {\r\n            determineTopKAttributes(testversion, trainversionSet);\r\n        } catch (Exception e) {\r\n            LOGGER.error(\"Failure during metric selection: \" + e.getMessage());\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private void determineTopKAttributes(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) throws Exception {\r\n        Instances testdata = testversion.getInstances();\r\n        Integer[] counts = new Integer[trainversionSet.get(0).getInstances().get(0).numAttributes() - 1];\r\n        IntStream.range(0, counts.length).forEach(val -> counts[val] = 0);\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            J48 decisionTree = new J48();\r\n            decisionTree.buildClassifier(traindata);\r\n            int k = 0;\r\n            for (int j = 0; j < traindata.numAttributes(); j++) {\r\n                if (j != traindata.classIndex()) {\r\n                    if (decisionTree.toString().contains(traindata.attribute(j).name())) {\r\n                        counts[k] = counts[k] + 1;\r\n                    }\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n        int[] topkIndex = new int[counts.length];\r\n        IntStream.range(0, counts.length).forEach(val -> topkIndex[val] = val);\r\n        SortUtils.quicksort(counts, topkIndex, true);\r\n        // get CFSs for each training set\r\n        List<Set<Integer>> cfsSets = new LinkedList<>();\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            boolean selectionSuccessful = false;\r\n            boolean secondAttempt = false;\r\n            Instances traindataCopy = null;\r\n            do {\r\n                try {\r\n                    if (secondAttempt) {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindataCopy);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    } else {\r\n                        AttributeSelection attsel = new AttributeSelection();\r\n                        CfsSubsetEval eval = new CfsSubsetEval();\r\n                        GreedyStepwise search = new GreedyStepwise();\r\n                        search.setSearchBackwards(true);\r\n                        attsel.setEvaluator(eval);\r\n                        attsel.setSearch(search);\r\n                        attsel.SelectAttributes(traindata);\r\n                        Set<Integer> cfsSet = new HashSet<>();\r\n                        for (int attr : attsel.selectedAttributes()) {\r\n                            cfsSet.add(attr);\r\n                        }\r\n                        cfsSets.add(cfsSet);\r\n                        selectionSuccessful = true;\r\n                    }\r\n                } catch (IllegalArgumentException e) {\r\n                    String regex = \"A nominal attribute \\\\((.*)\\\\) cannot have duplicate labels.*\";\r\n                    Pattern p = Pattern.compile(regex);\r\n                    Matcher m = p.matcher(e.getMessage());\r\n                    if (!m.find()) {\r\n                        // cannot treat problem, rethrow exception\r\n                        throw e;\r\n                    }\r\n                    String attributeName = m.group(1);\r\n                    int attrIndex = traindata.attribute(attributeName).index();\r\n                    if (secondAttempt) {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindataCopy, attrIndex);\r\n                    } else {\r\n                        traindataCopy = WekaUtils.upscaleAttribute(traindata, attrIndex);\r\n                    }\r\n                    LOGGER.info(\"upscaled attribute \" + attributeName + \"; restarting training\");\r\n                    secondAttempt = true;\r\n                    continue;\r\n                }\r\n            } while (// dummy loop for internal continue\r\n            !selectionSuccessful);\r\n        }\r\n        double[] coverages = new double[topkIndex.length];\r\n        for (Set<Integer> cfsSet : cfsSets) {\r\n            Set<Integer> topkSet = new HashSet<>();\r\n            for (int k = 0; k < topkIndex.length; k++) {\r\n                topkSet.add(topkIndex[k]);\r\n                coverages[k] += (coverage(topkSet, cfsSet) / trainversionSet.size());\r\n            }\r\n        }\r\n        double bestCoverageValue = Double.MIN_VALUE;\r\n        int bestCoverageIndex = 0;\r\n        for (int i = 0; i < coverages.length; i++) {\r\n            if (coverages[i] > bestCoverageValue) {\r\n                bestCoverageValue = coverages[i];\r\n                bestCoverageIndex = i;\r\n            }\r\n        }\r\n        // build correlation matrix\r\n        SpearmansCorrelation corr = new SpearmansCorrelation();\r\n        double[][] correlationMatrix = new double[bestCoverageIndex][bestCoverageIndex];\r\n        for (SoftwareVersion trainversion : trainversionSet) {\r\n            Instances traindata = trainversion.getInstances();\r\n            double[][] vectors = new double[bestCoverageIndex][traindata.size()];\r\n            for (int i = 0; i < traindata.size(); i++) {\r\n                for (int j = 0; j < bestCoverageIndex; j++) {\r\n                    vectors[j][i] = traindata.get(i).value(topkIndex[j]);\r\n                }\r\n            }\r\n            for (int j = 0; j < bestCoverageIndex; j++) {\r\n                for (int k = j + 1; k < bestCoverageIndex; k++) {\r\n                    correlationMatrix[j][k] = Math.abs(corr.correlation(vectors[j], vectors[k]));\r\n                }\r\n            }\r\n        }\r\n        Set<Integer> topkSetIndexSet = new TreeSet<>();\r\n        // complexity\r\n        for (int j = 0; j < bestCoverageIndex && j < 30; j++) {\r\n            topkSetIndexSet.add(j);\r\n        }\r\n        Set<Set<Integer>> allCombinations = Sets.powerSet(topkSetIndexSet);\r\n        double bestOptCoverage = Double.MIN_VALUE;\r\n        Set<Integer> opttopkSetIndexSet = null;\r\n        for (Set<Integer> combination : allCombinations) {\r\n            if (isUncorrelated(correlationMatrix, combination)) {\r\n                double currentCoverage = 0.0;\r\n                Set<Integer> topkCombination = new TreeSet<>();\r\n                for (Integer index : combination) {\r\n                    topkCombination.add(topkIndex[index]);\r\n                }\r\n                for (Set<Integer> cfsSet : cfsSets) {\r\n                    currentCoverage += (coverage(topkCombination, cfsSet) / trainversionSet.size());\r\n                }\r\n                if (currentCoverage > bestOptCoverage) {\r\n                    bestOptCoverage = currentCoverage;\r\n                    opttopkSetIndexSet = combination;\r\n                }\r\n            }\r\n        }\r\n        if (opttopkSetIndexSet == null) {\r\n            throw new RuntimeException(\"Could not determine a best top-k set with optimal coverage. This means that the top-k set and the subset determined by CFS are disjunctive.\");\r\n        }\r\n        Set<Integer> opttopkIndex = new TreeSet<>();\r\n        for (Integer index : opttopkSetIndexSet) {\r\n            opttopkIndex.add(topkIndex[index]);\r\n        }\r\n        LOGGER.debug(\"selected the following metrics:\");\r\n        for (Integer index : opttopkIndex) {\r\n            LOGGER.debug(trainversionSet.get(0).getInstances().get(0).attribute(index).name());\r\n        }\r\n        // finally remove attributes\r\n        for (int j = testdata.numAttributes() - 1; j >= 0; j--) {\r\n            if (j != testdata.classIndex() && !opttopkIndex.contains(j)) {\r\n                testdata.deleteAttributeAt(j);\r\n                for (SoftwareVersion trainversion : trainversionSet) {\r\n                    Instances traindata = trainversion.getInstances();\r\n                    traindata.deleteAttributeAt(j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"boxing\")\r\n    private boolean isUncorrelated(double[][] correlationMatrix, Set<Integer> combination) {\r\n        Integer[] intCombination = combination.toArray(new Integer[0]);\r\n        boolean areUncorrelated = true;\r\n        for (int i = 0; areUncorrelated && i < intCombination.length; i++) {\r\n            for (int j = i + 1; areUncorrelated && j < intCombination.length; j++) {\r\n                areUncorrelated &= correlationMatrix[intCombination[i]][intCombination[j]] > this.correlationThreshold;\r\n            }\r\n        }\r\n        return areUncorrelated;\r\n    }\r\n\r\n    private static double coverage(Set<Integer> topkSet, Set<Integer> cfsSet) {\r\n        Set<Integer> topkSetCopy1 = new HashSet<>(topkSet);\r\n        topkSetCopy1.retainAll(cfsSet);\r\n        Set<Integer> topkSetCopy2 = new HashSet<>(topkSet);\r\n        topkSetCopy2.addAll(cfsSet);\r\n        return ((double) topkSetCopy1.size()) / topkSetCopy2.size();\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "c96c4ecc65c9873bc3aeb3bef98ea74ea5e3c409", "ext": "java", "lang": "Java", "content": "public class CryptUtilsTest {\n\n    private static final Logger LOG = LoggerFactory.getLogger(CryptUtilsTest.class);\n\n    @Test\n    public void testPositive() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        long encStartTime = System.currentTimeMillis();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        String result1b = cu.encrypt(\"msg\", \"pwd\");\n        String result2 = cu.encrypt(\"msg\", \"pwd2\");\n        long encEndTime = System.currentTimeMillis();\n        LOG.info(result1a);\n        LOG.info(result1b);\n        LOG.info(result2);\n        assertNotEquals(result1a, result1b);\n        assertNotEquals(result1a, result2);\n        long decStartTime = System.currentTimeMillis();\n        assertEquals(\"msg\", cu.decrypt(result1a, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result1b, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result2, \"pwd2\"));\n        long decEndTime = System.currentTimeMillis();\n        LOG.info(String.format(\"encryption speed: %.2f msgs/second, decryption speed: %.2f msgs/second\", 3000.0 / (encEndTime - encStartTime), 3000.0 / (decEndTime - decStartTime)));\n    }\n\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongPwd() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.decrypt(result1a, \"wrongpwd\");\n    }\n\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setGcmTagLength(12);\n        cu.decrypt(result1a, \"pwd\");\n    }\n\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams2() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setKeySize(192);\n        cu.decrypt(result1a, \"pwd\");\n    }\n}\n", "class_id": 0, "repo": "jjYBdx4IL/misc", "file": "encryption-utils/src/test/java/com/github/jjYBdx4IL/utils/encryption/CryptUtilsTest.java", "last_update_at": "2021-09-18T07:42:23+00:00", "original_content": "public class CryptUtilsTest {\n\n    private static final Logger LOG = LoggerFactory.getLogger(CryptUtilsTest.class);\n\n    @Test\n    public void testPositive() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        long encStartTime = System.currentTimeMillis();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        String result1b = cu.encrypt(\"msg\", \"pwd\");\n        String result2 = cu.encrypt(\"msg\", \"pwd2\");\n        long encEndTime = System.currentTimeMillis();\n        LOG.info(result1a);\n        LOG.info(result1b);\n        LOG.info(result2);\n        assertNotEquals(result1a, result1b);\n        assertNotEquals(result1a, result2);\n        long decStartTime = System.currentTimeMillis();\n        assertEquals(\"msg\", cu.decrypt(result1a, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result1b, \"pwd\"));\n        assertEquals(\"msg\", cu.decrypt(result2, \"pwd2\"));\n        long decEndTime = System.currentTimeMillis();\n        LOG.info(String.format(\"encryption speed: %.2f msgs/second, decryption speed: %.2f msgs/second\", 3000.0 / (encEndTime - encStartTime), 3000.0 / (decEndTime - decStartTime)));\n    }\n\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongPwd() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.decrypt(result1a, \"wrongpwd\");\n    }\n\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setGcmTagLength(12);\n        cu.decrypt(result1a, \"pwd\");\n    }\n\n    @Test(expected = AEADBadTagException.class)\n    public void testWrongParams2() throws Exception {\n        CryptUtils cu = new CryptUtils();\n        String result1a = cu.encrypt(\"msg\", \"pwd\");\n        cu.setKeySize(192);\n        cu.decrypt(result1a, \"pwd\");\n    }\n}\n", "refactored": false}
{"hexsha": "75e7aff9329d69de6955705804c709b35b64974f", "ext": "java", "lang": "Java", "content": "public class ZookeeperWatcher {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZookeeperWatcher.class);\n\n    private static final String yuzhouwan4 = \"yuzhouwan04:2181\";\n\n    private static final String zNode = \"/yuzhouwan\";\n\n    {\n        init();\n    }\n\n    public void init() {\n        RetryPolicy retrypolicy = new ExponentialBackoffRetry(3000, 60);\n        CuratorFramework curatorClient;\n        /**\n         * using fluent api\n         */\n        // root path: /watcher\n        curatorClient = // root path: /watcher\n        CuratorFrameworkFactory.builder().connectString(yuzhouwan4).sessionTimeoutMs(5000).connectionTimeoutMs(3000).retryPolicy(retrypolicy).namespace(\"watcher\").build();\n        curatorClient.start();\n        final PathChildrenCache cached = new PathChildrenCache(curatorClient, zNode, true);\n        cached.getListenable().addListener((client, event) -> {\n            PathChildrenCacheEvent.Type childrenEventType = event.getType();\n            if (childrenEventType != null) {\n                switch(childrenEventType) {\n                    case CONNECTION_RECONNECTED:\n                        cached.rebuild();\n                        break;\n                    case CONNECTION_SUSPENDED:\n                    case CONNECTION_LOST:\n                        LOG.error(\"Connection error, waiting...\");\n                        break;\n                    default:\n                        LOG.info(\"PathChildrenCache changed : {path:\" + event.getData().getPath() + \" data:\" + new String(event.getData().getData()) + \"}\");\n                }\n            }\n        });\n        try {\n            cached.start();\n        } catch (Exception e) {\n            LOG.error(\"Can not start PathChildrenCache!!\");\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "class_id": 0, "repo": "Celebrate-future/yuzhouwan", "file": "yuzhouwan-bigdata/yuzhouwan-bigdata-zookeeper/src/main/java/com/yuzhouwan/bigdata/zookeeper/ZookeeperWatcher.java", "last_update_at": "2021-12-19T11:01:31+00:00", "original_content": "public class ZookeeperWatcher {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZookeeperWatcher.class);\n\n    private static final String yuzhouwan4 = \"yuzhouwan04:2181\";\n\n    private static final String zNode = \"/yuzhouwan\";\n\n    {\n        init();\n    }\n\n    public void init() {\n        RetryPolicy retrypolicy = new ExponentialBackoffRetry(3000, 60);\n        CuratorFramework curatorClient;\n        /**\n         * using fluent api\n         */\n        curatorClient = CuratorFrameworkFactory.builder().connectString(yuzhouwan4).sessionTimeoutMs(5000).connectionTimeoutMs(3000).retryPolicy(retrypolicy).namespace(// root path: /watcher\n        \"watcher\").build();\n        curatorClient.start();\n        final PathChildrenCache cached = new PathChildrenCache(curatorClient, zNode, true);\n        cached.getListenable().addListener((client, event) -> {\n            PathChildrenCacheEvent.Type childrenEventType = event.getType();\n            if (childrenEventType != null) {\n                switch(childrenEventType) {\n                    case CONNECTION_RECONNECTED:\n                        cached.rebuild();\n                        break;\n                    case CONNECTION_SUSPENDED:\n                    case CONNECTION_LOST:\n                        LOG.error(\"Connection error, waiting...\");\n                        break;\n                    default:\n                        LOG.info(\"PathChildrenCache changed : {path:\" + event.getData().getPath() + \" data:\" + new String(event.getData().getData()) + \"}\");\n                }\n            }\n        });\n        try {\n            cached.start();\n        } catch (Exception e) {\n            LOG.error(\"Can not start PathChildrenCache!!\");\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "ac822e94033f3255263e66325468841e95569ce2", "ext": "java", "lang": "Java", "content": "public class ForLab2 {\r\n\r\n    public static void main(String[] args) {\r\n        int[][] x = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\r\n        int sum = 0;\r\n        int i = 0;\r\n        while (i < x.length) try {\r\n            int j = 0;\r\n            while (j < x[i].length) try {\r\n                sum = sum + x[i][j];\r\n            } finally {\r\n                j++;\r\n            }\r\n        } finally {\r\n            i++;\r\n        }\r\n        for (int[] y : x) {\r\n            for (int a : y) {\r\n                System.out.println(a);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "class_id": 0, "repo": "chaoannricardo/StudyNotes", "file": "III_DataEngineer_BDSE10/1902_Java/JavaWorkspace/Sample/src/array/ForLab2.java", "last_update_at": "2021-05-18T06:09:25+00:00", "original_content": "public class ForLab2 {\r\n\r\n    public static void main(String[] args) {\r\n        int[][] x = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\r\n        int sum = 0;\r\n        for (int i = 0; i < x.length; i++) {\r\n            for (int j = 0; j < x[i].length; j++) {\r\n                sum = sum + x[i][j];\r\n            }\r\n        }\r\n        for (int[] y : x) {\r\n            for (int a : y) {\r\n                System.out.println(a);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "423faf3c08720e4a86a03cf520bae2cb7efce200", "ext": "java", "lang": "Java", "content": "@RestrictTo({ RestrictTo.Scope.LIBRARY_GROUP_PREFIX })\npublic class AnimationUtilsCompat {\n\n    private AnimationUtilsCompat() {\n    }\n\n    private static Interpolator createInterpolatorFromXml(Context context, Resources resources, Resources.Theme theme, XmlPullParser xmlPullParser) {\n        Interpolator pathInterpolatorCompat;\n        int depth = xmlPullParser.getDepth();\n        Interpolator interpolator = null;\n        for (; true; ) {\n            int next = xmlPullParser.next();\n            if ((next != 3 || xmlPullParser.getDepth() > depth) && next != 1) {\n                if (next == 2) {\n                    AttributeSet asAttributeSet = Xml.asAttributeSet(xmlPullParser);\n                    String name = xmlPullParser.getName();\n                    if (name.equals(\"linearInterpolator\")) {\n                        interpolator = new LinearInterpolator();\n                    } else {\n                        if (name.equals(\"accelerateInterpolator\")) {\n                            pathInterpolatorCompat = new AccelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"decelerateInterpolator\")) {\n                            pathInterpolatorCompat = new DecelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"accelerateDecelerateInterpolator\")) {\n                            interpolator = new AccelerateDecelerateInterpolator();\n                        } else if (name.equals(\"cycleInterpolator\")) {\n                            pathInterpolatorCompat = new CycleInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"overshootInterpolator\")) {\n                            pathInterpolatorCompat = new OvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateOvershootInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateOvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"bounceInterpolator\")) {\n                            interpolator = new BounceInterpolator();\n                        } else if (name.equals(\"pathInterpolator\")) {\n                            pathInterpolatorCompat = new PathInterpolatorCompat(context, asAttributeSet, xmlPullParser);\n                        } else {\n                            throw new RuntimeException(\"Unknown interpolator name: \" + xmlPullParser.getName());\n                        }\n                        interpolator = pathInterpolatorCompat;\n                    }\n                }\n            }\n        }\n        return interpolator;\n    }\n\n    public static Interpolator loadInterpolator(Context context, int i) {\n        if (Build.VERSION.SDK_INT >= 21) {\n            return AnimationUtils.loadInterpolator(context, i);\n        }\n        XmlResourceParser xmlResourceParser = null;\n        if (i == 17563663) {\n            try {\n                return new FastOutLinearInInterpolator();\n            } catch (XmlPullParserException e) {\n                Resources.NotFoundException notFoundException = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException.initCause(e);\n                throw notFoundException;\n            } catch (IOException e2) {\n                Resources.NotFoundException notFoundException2 = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException2.initCause(e2);\n                throw notFoundException2;\n            } catch (Throwable th) {\n                if (xmlResourceParser != null) {\n                    xmlResourceParser.close();\n                }\n                throw th;\n            }\n        } else if (i == 17563661) {\n            return new FastOutSlowInInterpolator();\n        } else {\n            if (i == 17563662) {\n                return new LinearOutSlowInInterpolator();\n            }\n            XmlResourceParser animation = context.getResources().getAnimation(i);\n            Interpolator createInterpolatorFromXml = createInterpolatorFromXml(context, context.getResources(), context.getTheme(), animation);\n            if (animation != null) {\n                animation.close();\n            }\n            return createInterpolatorFromXml;\n        }\n    }\n}\n", "class_id": 0, "repo": "abhiManyuSingh59/Track-And-Trail", "file": "vectordrawable/graphics/drawable/AnimationUtilsCompat.java", "last_update_at": "2021-07-18T09:35:51+00:00", "original_content": "@RestrictTo({ RestrictTo.Scope.LIBRARY_GROUP_PREFIX })\npublic class AnimationUtilsCompat {\n\n    private AnimationUtilsCompat() {\n    }\n\n    private static Interpolator createInterpolatorFromXml(Context context, Resources resources, Resources.Theme theme, XmlPullParser xmlPullParser) {\n        Interpolator pathInterpolatorCompat;\n        int depth = xmlPullParser.getDepth();\n        Interpolator interpolator = null;\n        while (true) {\n            int next = xmlPullParser.next();\n            if ((next != 3 || xmlPullParser.getDepth() > depth) && next != 1) {\n                if (next == 2) {\n                    AttributeSet asAttributeSet = Xml.asAttributeSet(xmlPullParser);\n                    String name = xmlPullParser.getName();\n                    if (name.equals(\"linearInterpolator\")) {\n                        interpolator = new LinearInterpolator();\n                    } else {\n                        if (name.equals(\"accelerateInterpolator\")) {\n                            pathInterpolatorCompat = new AccelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"decelerateInterpolator\")) {\n                            pathInterpolatorCompat = new DecelerateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"accelerateDecelerateInterpolator\")) {\n                            interpolator = new AccelerateDecelerateInterpolator();\n                        } else if (name.equals(\"cycleInterpolator\")) {\n                            pathInterpolatorCompat = new CycleInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"overshootInterpolator\")) {\n                            pathInterpolatorCompat = new OvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"anticipateOvershootInterpolator\")) {\n                            pathInterpolatorCompat = new AnticipateOvershootInterpolator(context, asAttributeSet);\n                        } else if (name.equals(\"bounceInterpolator\")) {\n                            interpolator = new BounceInterpolator();\n                        } else if (name.equals(\"pathInterpolator\")) {\n                            pathInterpolatorCompat = new PathInterpolatorCompat(context, asAttributeSet, xmlPullParser);\n                        } else {\n                            throw new RuntimeException(\"Unknown interpolator name: \" + xmlPullParser.getName());\n                        }\n                        interpolator = pathInterpolatorCompat;\n                    }\n                }\n            }\n        }\n        return interpolator;\n    }\n\n    public static Interpolator loadInterpolator(Context context, int i) {\n        if (Build.VERSION.SDK_INT >= 21) {\n            return AnimationUtils.loadInterpolator(context, i);\n        }\n        XmlResourceParser xmlResourceParser = null;\n        if (i == 17563663) {\n            try {\n                return new FastOutLinearInInterpolator();\n            } catch (XmlPullParserException e) {\n                Resources.NotFoundException notFoundException = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException.initCause(e);\n                throw notFoundException;\n            } catch (IOException e2) {\n                Resources.NotFoundException notFoundException2 = new Resources.NotFoundException(\"Can't load animation resource ID #0x\" + Integer.toHexString(i));\n                notFoundException2.initCause(e2);\n                throw notFoundException2;\n            } catch (Throwable th) {\n                if (xmlResourceParser != null) {\n                    xmlResourceParser.close();\n                }\n                throw th;\n            }\n        } else if (i == 17563661) {\n            return new FastOutSlowInInterpolator();\n        } else {\n            if (i == 17563662) {\n                return new LinearOutSlowInInterpolator();\n            }\n            XmlResourceParser animation = context.getResources().getAnimation(i);\n            Interpolator createInterpolatorFromXml = createInterpolatorFromXml(context, context.getResources(), context.getTheme(), animation);\n            if (animation != null) {\n                animation.close();\n            }\n            return createInterpolatorFromXml;\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "d5ac6617927f4b4b7426323e7423cf1ef9f5dad1", "ext": "java", "lang": "Java", "content": "public class ComputationPipeline {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ComputationPipeline.class);\n\n    private static final long DEFAULT_WAIT_TIME_IN_SECONDS = 30;\n\n    private final List<PipelineStreamSource> sources = Lists.newArrayList();\n\n    private final List<PipelineStage> stages = Lists.newArrayList();\n\n    private NotificationBus notificationBus;\n\n    private long waitTimeInSeconds;\n\n    private String computationName;\n\n    public static ComputationPipeline builder() {\n        return new ComputationPipeline();\n    }\n\n    public ComputationPipeline notificationBus(NotificationBus notificationBusArg) {\n        this.notificationBus = notificationBusArg;\n        return this;\n    }\n\n    public ComputationPipeline computationName(String computationNameArg) {\n        this.computationName = computationNameArg;\n        return this;\n    }\n\n    public ComputationPipeline addSource(PipelineStreamSource streamSource) {\n        this.sources.add(streamSource);\n        return this;\n    }\n\n    public ComputationPipeline addPipelineStage(PipelineStage pipelineStage) {\n        this.stages.add(pipelineStage);\n        return this;\n    }\n\n    public ComputationPipeline connect(MessageSource to, PipelineStage... pipelineStages) {\n        notificationBus.connect(to, pipelineStages);\n        return this;\n    }\n\n    public ComputationPipeline initialize(Properties properties) {\n        properties.put(\"computation.name\", computationName);\n        waitTimeInSeconds = PropertyReader.readLong(properties, properties, \"computation.shutdown.wait_time_in_seconds\", DEFAULT_WAIT_TIME_IN_SECONDS);\n        sources.forEach(streamSource -> {\n            try {\n                streamSource.initialize(properties);\n                ComponentMetadata componentMetadata = streamSource.getSourceMetadata();\n                LOGGER.info(\"Initialized source: {}:{}:{}->{}\", componentMetadata.getNamespace(), componentMetadata.getName(), componentMetadata.getVersion(), streamSource.getInstanceId());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Error initializing source: %s\", streamSource.getInstanceId()), e);\n            }\n        });\n        stages.forEach(stage -> {\n            try {\n                stage.initialize(properties);\n                ComponentMetadata componentMetadata = stage.getProcessorMetadata();\n                LOGGER.info(\"Initialized processor: {}:{}:{}->{}\", componentMetadata.getNamespace(), componentMetadata.getName(), componentMetadata.getVersion(), stage.getInstanceId());\n            } catch (InitializationException e) {\n                throw new RuntimeException(String.format(\"Error initializing processor: %s\", stage.getInstanceId()), e);\n            }\n        });\n        return this;\n    }\n\n    public boolean healthcheck() {\n        boolean a = true;\n        try {\n            for (PipelineStreamSource source : sources) {\n                a = a & source.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n            for (PipelineStage stage : stages) {\n                a = a & stage.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n        } catch (Throwable t) {\n            a = false;\n            LOGGER.error(\"Error when calling healthcheck on one of the components: \", t);\n        }\n        return a;\n    }\n\n    public ComputationPipeline start() {\n        LOGGER.info(\"Starting pipeline...\");\n        notificationBus.start();\n        stages.forEach(PipelineStage::start);\n        sources.forEach(PipelineStreamSource::start);\n        return this;\n    }\n\n    public void stop() {\n        LOGGER.info(\"Stopping pipeline...\");\n        sources.forEach(PipelineStreamSource::stop);\n        // adding sufficient sleep time for a graceful stop, allowing enough time for events in transit to be processed\n        try {\n            Thread.sleep(waitTimeInSeconds * 1000);\n        } catch (InterruptedException iEx) {\n            LOGGER.warn(\"Sleep was interrupted: \" + iEx.getMessage());\n        }\n        stages.forEach(PipelineStage::stop);\n        notificationBus.stop();\n    }\n}\n", "class_id": 0, "repo": "apsingh12/fabric", "file": "fabric-compute-framework/src/main/java/com/olacabs/fabric/compute/pipeline/ComputationPipeline.java", "last_update_at": "2021-05-30T10:24:48+00:00", "original_content": "public class ComputationPipeline {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ComputationPipeline.class);\n\n    private static final long DEFAULT_WAIT_TIME_IN_SECONDS = 30;\n\n    private final List<PipelineStreamSource> sources = Lists.newArrayList();\n\n    private final List<PipelineStage> stages = Lists.newArrayList();\n\n    private NotificationBus notificationBus;\n\n    private long waitTimeInSeconds;\n\n    private String computationName;\n\n    public static ComputationPipeline builder() {\n        return new ComputationPipeline();\n    }\n\n    public ComputationPipeline notificationBus(NotificationBus notificationBusArg) {\n        this.notificationBus = notificationBusArg;\n        return this;\n    }\n\n    public ComputationPipeline computationName(String computationNameArg) {\n        this.computationName = computationNameArg;\n        return this;\n    }\n\n    public ComputationPipeline addSource(PipelineStreamSource streamSource) {\n        this.sources.add(streamSource);\n        return this;\n    }\n\n    public ComputationPipeline addPipelineStage(PipelineStage pipelineStage) {\n        this.stages.add(pipelineStage);\n        return this;\n    }\n\n    public ComputationPipeline connect(MessageSource to, PipelineStage... pipelineStages) {\n        notificationBus.connect(to, pipelineStages);\n        return this;\n    }\n\n    public ComputationPipeline initialize(Properties properties) {\n        properties.put(\"computation.name\", computationName);\n        waitTimeInSeconds = PropertyReader.readLong(properties, properties, \"computation.shutdown.wait_time_in_seconds\", DEFAULT_WAIT_TIME_IN_SECONDS);\n        sources.forEach(streamSource -> {\n            try {\n                streamSource.initialize(properties);\n                ComponentMetadata componentMetadata = streamSource.getSourceMetadata();\n                LOGGER.info(\"Initialized source: {}:{}:{}->{}\", componentMetadata.getNamespace(), componentMetadata.getName(), componentMetadata.getVersion(), streamSource.getInstanceId());\n            } catch (Exception e) {\n                throw new RuntimeException(String.format(\"Error initializing source: %s\", streamSource.getInstanceId()), e);\n            }\n        });\n        stages.forEach(stage -> {\n            try {\n                stage.initialize(properties);\n                ComponentMetadata componentMetadata = stage.getProcessorMetadata();\n                LOGGER.info(\"Initialized processor: {}:{}:{}->{}\", componentMetadata.getNamespace(), componentMetadata.getName(), componentMetadata.getVersion(), stage.getInstanceId());\n            } catch (InitializationException e) {\n                throw new RuntimeException(String.format(\"Error initializing processor: %s\", stage.getInstanceId()), e);\n            }\n        });\n        return this;\n    }\n\n    public boolean healthcheck() {\n        boolean a = true;\n        try {\n            for (PipelineStreamSource source : sources) {\n                a = a & source.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n            for (PipelineStage stage : stages) {\n                a = a & stage.healthcheck();\n                if (!a) {\n                    return a;\n                }\n            }\n        } catch (Throwable t) {\n            a = false;\n            LOGGER.error(\"Error when calling healthcheck on one of the components: \", t);\n        }\n        return a;\n    }\n\n    public ComputationPipeline start() {\n        LOGGER.info(\"Starting pipeline...\");\n        notificationBus.start();\n        stages.forEach(PipelineStage::start);\n        sources.forEach(PipelineStreamSource::start);\n        return this;\n    }\n\n    public void stop() {\n        LOGGER.info(\"Stopping pipeline...\");\n        sources.forEach(PipelineStreamSource::stop);\n        // adding sufficient sleep time for a graceful stop, allowing enough time for events in transit to be processed\n        try {\n            Thread.sleep(waitTimeInSeconds * 1000);\n        } catch (InterruptedException iEx) {\n            LOGGER.warn(\"Sleep was interrupted: \" + iEx.getMessage());\n        }\n        stages.forEach(PipelineStage::stop);\n        notificationBus.stop();\n    }\n}\n", "refactored": false}
{"hexsha": "67e1a9532bb4ba1630a30e9b874e7bee7caead7c", "ext": "java", "lang": "Java", "content": "class PersonNameField extends ValueFieldTest {\r\n\r\n    public void clearAssociation(final NakedObject inObject) {\r\n        getPerson(inObject).setName(\"\");\r\n    }\r\n\r\n    public String debugData() {\r\n        return \"\";\r\n    }\r\n\r\n    public NakedObject get(final NakedObject fromObject) {\r\n        final TestProxyNakedObject nakedObject = new TestProxyNakedObject();\r\n        nakedObject.setupObject(getPerson(fromObject).getName());\r\n        return nakedObject;\r\n    }\r\n\r\n    public String getId() {\r\n        return \"name\";\r\n    }\r\n\r\n    public String getName() {\r\n        return \"Name\";\r\n    }\r\n\r\n    private Person getPerson(final NakedObject inObject) {\r\n        return (Person) inObject.getObject();\r\n    }\r\n\r\n    public NakedObjectSpecification getSpecification() {\r\n        return new TestSpecification(\"java.lang.String\");\r\n    }\r\n\r\n    public void initAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public Consent isAssociationValid(final NakedObject inObject, final NakedObject association) {\r\n        return Allow.DEFAULT;\r\n    }\r\n\r\n    public void setAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public void set(NakedObject owner, NakedObject newValue) {\r\n        setAssociation(owner, newValue);\r\n    }\r\n}\r\n", "class_id": 0, "repo": "Corpus-2021/nakedobjects-4.0.0", "file": "core/runtime/src/test/java/org/nakedobjects/runtime/testspec/PersonSpecification.java", "last_update_at": "2021-02-22T15:40:05+00:00", "original_content": "class PersonNameField extends ValueFieldTest {\r\n\r\n    public void clearAssociation(final NakedObject inObject) {\r\n        getPerson(inObject).setName(\"\");\r\n    }\r\n\r\n    public String debugData() {\r\n        return \"\";\r\n    }\r\n\r\n    public NakedObject get(final NakedObject fromObject) {\r\n        final TestProxyNakedObject nakedObject = new TestProxyNakedObject();\r\n        nakedObject.setupObject(getPerson(fromObject).getName());\r\n        return nakedObject;\r\n    }\r\n\r\n    public String getId() {\r\n        return \"name\";\r\n    }\r\n\r\n    public String getName() {\r\n        return \"Name\";\r\n    }\r\n\r\n    private Person getPerson(final NakedObject inObject) {\r\n        return (Person) inObject.getObject();\r\n    }\r\n\r\n    public NakedObjectSpecification getSpecification() {\r\n        return new TestSpecification(\"java.lang.String\");\r\n    }\r\n\r\n    public void initAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public Consent isAssociationValid(final NakedObject inObject, final NakedObject association) {\r\n        return Allow.DEFAULT;\r\n    }\r\n\r\n    public void setAssociation(final NakedObject inObject, final NakedObject association) {\r\n        getPerson(inObject).setName((String) association.getObject());\r\n    }\r\n\r\n    public void set(NakedObject owner, NakedObject newValue) {\r\n        setAssociation(owner, newValue);\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "0a4a4369ec3b6de4d86e3c5f2ecc32c64dac30a0", "ext": "java", "lang": "Java", "content": "public class Identifieds {\n\n    private Identifieds() {\n    }\n\n    public static Function<Identified, Description> TO_DESCRIPTION = new Function<Identified, Description>() {\n\n        @Override\n        public Description apply(Identified input) {\n            return (Description) input;\n        }\n    };\n\n    public static Predicate<Identified> IS_DESCRIPTION = new Predicate<Identified>() {\n\n        @Override\n        public boolean apply(Identified input) {\n            return input instanceof Description;\n        }\n    };\n\n    public static List<Description> getDescriptions(Iterable<? extends Identified> identifieds) {\n        return ImmutableList.copyOf(Iterables.transform(Iterables.filter(identifieds, IS_DESCRIPTION), TO_DESCRIPTION));\n    }\n\n    private static Iterable<Person> getEmbeddedPeople(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_PEOPLE));\n    }\n\n    private static Iterable<Identified> getEmbeddedBrandsAndSeries(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_BRAND_AND_SERIES_SUMMARIES));\n    }\n\n    public static Iterable<Identified> getFlattenedIdentifieds(Iterable<? extends Identified> identifieds) {\n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        Iterable<Description> allDescriptions = Iterables.filter(identifieds, Description.class);\n        List<Item> allItems = Descriptions.getItems(allDescriptions);\n        Iterable<Identified> embeddedBrandsAndSeries = getEmbeddedBrandsAndSeries(allItems);\n        Iterable<Person> embeddedPeople = getEmbeddedPeople(allItems);\n        return Iterables.concat(allDescriptions, embeddedBrandsAndSeries, people, embeddedPeople);\n    }\n\n    public static Iterable<ContentIdentifier> getContentIdentifiers(Iterable<? extends Identified> identifieds) {\n        Builder<ContentIdentifier> builder = ImmutableList.builder();\n        Iterable<Playlist> playlists = Iterables.filter(identifieds, Playlist.class);\n        for (Playlist playlist : playlists) {\n            builder.addAll(playlist.getContent());\n            builder.addAll(playlist.getSeriesList());\n            if (playlist.getAvailableContent() != null) {\n                builder.addAll(playlist.getAvailableContent());\n            }\n            if (playlist.getUpcomingContent() != null) {\n                builder.addAll(playlist.getUpcomingContent());\n            }\n        }\n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        for (Person person : people) {\n            // people embedded in items/brands don't have content attached\n            if (person.getContent() != null) {\n                builder.addAll(person.getContent());\n            }\n        }\n        return builder.build();\n    }\n\n    private static final Function<Item, Iterable<Identified>> TO_BRAND_AND_SERIES_SUMMARIES = new Function<Item, Iterable<Identified>>() {\n\n        @Override\n        public Iterable<Identified> apply(Item input) {\n            Builder<Identified> builder = ImmutableList.builder();\n            if (input.getSeriesSummary() != null) {\n                builder.add(input.getSeriesSummary());\n            }\n            if (input.getBrandSummary() != null) {\n                builder.add(input.getBrandSummary());\n            }\n            return builder.build();\n        }\n    };\n}\n", "class_id": 0, "repo": "atlasapi/atlas-model", "file": "src/main/java/org/atlasapi/media/util/Identifieds.java", "last_update_at": "2021-11-08T08:35:28+00:00", "original_content": "public class Identifieds {\n\n    private Identifieds() {\n    }\n\n    public static Function<Identified, Description> TO_DESCRIPTION = new Function<Identified, Description>() {\n\n        @Override\n        public Description apply(Identified input) {\n            return (Description) input;\n        }\n    };\n\n    public static Predicate<Identified> IS_DESCRIPTION = new Predicate<Identified>() {\n\n        @Override\n        public boolean apply(Identified input) {\n            return input instanceof Description;\n        }\n    };\n\n    public static List<Description> getDescriptions(Iterable<? extends Identified> identifieds) {\n        return ImmutableList.copyOf(Iterables.transform(Iterables.filter(identifieds, IS_DESCRIPTION), TO_DESCRIPTION));\n    }\n\n    private static Iterable<Person> getEmbeddedPeople(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_PEOPLE));\n    }\n\n    private static Iterable<Identified> getEmbeddedBrandsAndSeries(Iterable<Item> items) {\n        return Iterables.concat(Iterables.transform(items, TO_BRAND_AND_SERIES_SUMMARIES));\n    }\n\n    public static Iterable<Identified> getFlattenedIdentifieds(Iterable<? extends Identified> identifieds) {\n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        Iterable<Description> allDescriptions = Iterables.filter(identifieds, Description.class);\n        List<Item> allItems = Descriptions.getItems(allDescriptions);\n        Iterable<Identified> embeddedBrandsAndSeries = getEmbeddedBrandsAndSeries(allItems);\n        Iterable<Person> embeddedPeople = getEmbeddedPeople(allItems);\n        return Iterables.concat(allDescriptions, embeddedBrandsAndSeries, people, embeddedPeople);\n    }\n\n    public static Iterable<ContentIdentifier> getContentIdentifiers(Iterable<? extends Identified> identifieds) {\n        Builder<ContentIdentifier> builder = ImmutableList.builder();\n        Iterable<Playlist> playlists = Iterables.filter(identifieds, Playlist.class);\n        for (Playlist playlist : playlists) {\n            builder.addAll(playlist.getContent());\n            builder.addAll(playlist.getSeriesList());\n            if (playlist.getAvailableContent() != null) {\n                builder.addAll(playlist.getAvailableContent());\n            }\n            if (playlist.getUpcomingContent() != null) {\n                builder.addAll(playlist.getUpcomingContent());\n            }\n        }\n        Iterable<Person> people = Iterables.filter(identifieds, Person.class);\n        for (Person person : people) {\n            // people embedded in items/brands don't have content attached\n            if (person.getContent() != null) {\n                builder.addAll(person.getContent());\n            }\n        }\n        return builder.build();\n    }\n\n    private static final Function<Item, Iterable<Identified>> TO_BRAND_AND_SERIES_SUMMARIES = new Function<Item, Iterable<Identified>>() {\n\n        @Override\n        public Iterable<Identified> apply(Item input) {\n            Builder<Identified> builder = ImmutableList.builder();\n            if (input.getSeriesSummary() != null) {\n                builder.add(input.getSeriesSummary());\n            }\n            if (input.getBrandSummary() != null) {\n                builder.add(input.getBrandSummary());\n            }\n            return builder.build();\n        }\n    };\n}\n", "refactored": false}
{"hexsha": "dd665ca0160a69141e541d7df9ca35966420c029", "ext": "java", "lang": "Java", "content": "class FilesystemSource extends AbstractSource implements StreamSource, FileSource {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(FilesystemSource.class);\n\n    private static final String UNIX_PATH_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_PATH_SEPARATOR = \"\\\\\";\n\n    /**\n     * Lazy-loaded by {@link #getPath}.\n     */\n    private Path path;\n\n    @Override\n    public void checkAccess() throws IOException {\n        final Path path = getPath();\n        if (!Files.exists(path)) {\n            throw new NoSuchFileException(\"Failed to resolve \" + identifier + \" to \" + path);\n        } else if (!Files.isReadable(path)) {\n            throw new AccessDeniedException(\"File is not readable: \" + path);\n        }\n    }\n\n    /**\n     * @return Path corresponding to the given identifier according to the\n     *         current lookup strategy\n     *         ({@link Key#FILESYSTEMSOURCE_LOOKUP_STRATEGY}). The result is\n     *         cached.\n     */\n    @Override\n    public Path getPath() throws IOException {\n        if (path == null) {\n            final LookupStrategy strategy = LookupStrategy.from(Key.FILESYSTEMSOURCE_LOOKUP_STRATEGY);\n            switch(strategy) {\n                case DELEGATE_SCRIPT:\n                    try {\n                        path = getPathWithScriptStrategy();\n                    } catch (ScriptException e) {\n                        LOGGER.error(e.getMessage(), e);\n                        throw new IOException(e);\n                    }\n                    break;\n                default:\n                    path = getPathWithBasicStrategy();\n                    break;\n            }\n            LOGGER.debug(\"Resolved {} to {}\", identifier, path);\n        }\n        return path;\n    }\n\n    private Path getPathWithBasicStrategy() {\n        final Configuration config = Configuration.getInstance();\n        final String prefix = config.getString(Key.FILESYSTEMSOURCE_PATH_PREFIX, \"\");\n        final String suffix = config.getString(Key.FILESYSTEMSOURCE_PATH_SUFFIX, \"\");\n        final Identifier sanitizedId = sanitizedIdentifier();\n        return Paths.get(prefix + sanitizedId.toString() + suffix);\n    }\n\n    /**\n     * @return Pathname of the file corresponding to the identifier passed to\n     *         {@link #setIdentifier(Identifier)}.\n     * @throws NoSuchFileException if the delegate method indicated that there\n     *                             is no file corresponding to the given\n     *                             identifier.\n     * @throws ScriptException     if the method invocation failed.\n     */\n    private Path getPathWithScriptStrategy() throws NoSuchFileException, ScriptException {\n        String pathname = getDelegateProxy().getFilesystemSourcePathname();\n        if (pathname == null) {\n            throw new NoSuchFileException(DelegateMethod.FILESYSTEMSOURCE_PATHMAME + \" returned nil for \" + identifier);\n        }\n        return Paths.get(pathname);\n    }\n\n    /**\n     * <ol>\n     *     <li>If the file's filename contains an extension, the format is\n     *     inferred from that.</li>\n     *     <li>If unsuccessful, and the identifier contains an extension, the\n     *     format is inferred from that.</li>\n     *     <li>If unsuccessful, the format is inferred from the file's magic\n     *     bytes.</li>\n     * </ol>\n     *\n     * @return Best attempt at determining the file format.\n     * @throws IOException if the magic byte check fails.\n     */\n    @Override\n    public Format getFormat() throws IOException {\n        if (format == null) {\n            // Try to infer a format from the filename.\n            format = Format.inferFormat(getPath().getFileName().toString());\n            if (Format.UNKNOWN.equals(format)) {\n                // Try to infer a format from the identifier.\n                format = Format.inferFormat(identifier);\n            }\n            if (Format.UNKNOWN.equals(format)) {\n                // Fall back to reading the magic bytes.\n                format = detectFormat();\n            }\n        }\n        return format;\n    }\n\n    /**\n     * Detects the format of a file by reading its header.\n     *\n     * @return Detected format, or {@link Format#UNKNOWN}.\n     */\n    private Format detectFormat() throws IOException {\n        Format format = Format.UNKNOWN;\n        final Path path = getPath();\n        List<MediaType> detectedTypes = MediaType.detectMediaTypes(path);\n        if (!detectedTypes.isEmpty()) {\n            format = detectedTypes.get(0).toFormat();\n        }\n        return format;\n    }\n\n    @Override\n    public StreamFactory newStreamFactory() throws IOException {\n        return new PathStreamFactory(getPath());\n    }\n\n    /**\n     * Recursively filters out {@literal fileseparator..} and\n     * {@literal ..fileseparator} to prevent moving up a directory tree.\n     *\n     * @return Sanitized identifier.\n     */\n    private Identifier sanitizedIdentifier() {\n        final String sanitized = StringUtils.sanitize(identifier.toString(), UNIX_PATH_SEPARATOR + \"..\", \"..\" + UNIX_PATH_SEPARATOR, WINDOWS_PATH_SEPARATOR + \"..\", \"..\" + WINDOWS_PATH_SEPARATOR);\n        return new Identifier(sanitized);\n    }\n\n    @Override\n    public void setIdentifier(Identifier identifier) {\n        path = null;\n        format = null;\n        this.identifier = identifier;\n    }\n}\n", "class_id": 0, "repo": "BossaNova/cantaloupe", "file": "src/main/java/edu/illinois/library/cantaloupe/source/FilesystemSource.java", "last_update_at": "2021-01-21T21:23:09+00:00", "original_content": "class FilesystemSource extends AbstractSource implements StreamSource, FileSource {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(FilesystemSource.class);\n\n    private static final String UNIX_PATH_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_PATH_SEPARATOR = \"\\\\\";\n\n    /**\n     * Lazy-loaded by {@link #getPath}.\n     */\n    private Path path;\n\n    @Override\n    public void checkAccess() throws IOException {\n        final Path path = getPath();\n        if (!Files.exists(path)) {\n            throw new NoSuchFileException(\"Failed to resolve \" + identifier + \" to \" + path);\n        } else if (!Files.isReadable(path)) {\n            throw new AccessDeniedException(\"File is not readable: \" + path);\n        }\n    }\n\n    /**\n     * @return Path corresponding to the given identifier according to the\n     *         current lookup strategy\n     *         ({@link Key#FILESYSTEMSOURCE_LOOKUP_STRATEGY}). The result is\n     *         cached.\n     */\n    @Override\n    public Path getPath() throws IOException {\n        if (path == null) {\n            final LookupStrategy strategy = LookupStrategy.from(Key.FILESYSTEMSOURCE_LOOKUP_STRATEGY);\n            switch(strategy) {\n                case DELEGATE_SCRIPT:\n                    try {\n                        path = getPathWithScriptStrategy();\n                    } catch (ScriptException e) {\n                        LOGGER.error(e.getMessage(), e);\n                        throw new IOException(e);\n                    }\n                    break;\n                default:\n                    path = getPathWithBasicStrategy();\n                    break;\n            }\n            LOGGER.debug(\"Resolved {} to {}\", identifier, path);\n        }\n        return path;\n    }\n\n    private Path getPathWithBasicStrategy() {\n        final Configuration config = Configuration.getInstance();\n        final String prefix = config.getString(Key.FILESYSTEMSOURCE_PATH_PREFIX, \"\");\n        final String suffix = config.getString(Key.FILESYSTEMSOURCE_PATH_SUFFIX, \"\");\n        final Identifier sanitizedId = sanitizedIdentifier();\n        return Paths.get(prefix + sanitizedId.toString() + suffix);\n    }\n\n    /**\n     * @return Pathname of the file corresponding to the identifier passed to\n     *         {@link #setIdentifier(Identifier)}.\n     * @throws NoSuchFileException if the delegate method indicated that there\n     *                             is no file corresponding to the given\n     *                             identifier.\n     * @throws ScriptException     if the method invocation failed.\n     */\n    private Path getPathWithScriptStrategy() throws NoSuchFileException, ScriptException {\n        String pathname = getDelegateProxy().getFilesystemSourcePathname();\n        if (pathname == null) {\n            throw new NoSuchFileException(DelegateMethod.FILESYSTEMSOURCE_PATHMAME + \" returned nil for \" + identifier);\n        }\n        return Paths.get(pathname);\n    }\n\n    /**\n     * <ol>\n     *     <li>If the file's filename contains an extension, the format is\n     *     inferred from that.</li>\n     *     <li>If unsuccessful, and the identifier contains an extension, the\n     *     format is inferred from that.</li>\n     *     <li>If unsuccessful, the format is inferred from the file's magic\n     *     bytes.</li>\n     * </ol>\n     *\n     * @return Best attempt at determining the file format.\n     * @throws IOException if the magic byte check fails.\n     */\n    @Override\n    public Format getFormat() throws IOException {\n        if (format == null) {\n            // Try to infer a format from the filename.\n            format = Format.inferFormat(getPath().getFileName().toString());\n            if (Format.UNKNOWN.equals(format)) {\n                // Try to infer a format from the identifier.\n                format = Format.inferFormat(identifier);\n            }\n            if (Format.UNKNOWN.equals(format)) {\n                // Fall back to reading the magic bytes.\n                format = detectFormat();\n            }\n        }\n        return format;\n    }\n\n    /**\n     * Detects the format of a file by reading its header.\n     *\n     * @return Detected format, or {@link Format#UNKNOWN}.\n     */\n    private Format detectFormat() throws IOException {\n        Format format = Format.UNKNOWN;\n        final Path path = getPath();\n        List<MediaType> detectedTypes = MediaType.detectMediaTypes(path);\n        if (!detectedTypes.isEmpty()) {\n            format = detectedTypes.get(0).toFormat();\n        }\n        return format;\n    }\n\n    @Override\n    public StreamFactory newStreamFactory() throws IOException {\n        return new PathStreamFactory(getPath());\n    }\n\n    /**\n     * Recursively filters out {@literal fileseparator..} and\n     * {@literal ..fileseparator} to prevent moving up a directory tree.\n     *\n     * @return Sanitized identifier.\n     */\n    private Identifier sanitizedIdentifier() {\n        final String sanitized = StringUtils.sanitize(identifier.toString(), UNIX_PATH_SEPARATOR + \"..\", \"..\" + UNIX_PATH_SEPARATOR, WINDOWS_PATH_SEPARATOR + \"..\", \"..\" + WINDOWS_PATH_SEPARATOR);\n        return new Identifier(sanitized);\n    }\n\n    @Override\n    public void setIdentifier(Identifier identifier) {\n        path = null;\n        format = null;\n        this.identifier = identifier;\n    }\n}\n", "refactored": false}
{"hexsha": "bec0e15270d0c37da3353799049257d5d218b2d9", "ext": "java", "lang": "Java", "content": "@Service\npublic class TableServiceImpl implements TableService {\n\n    @Autowired\n    private ClusterService clusterService;\n\n    @Override\n    public List<Table> listTableByClusterName(String clusterName, boolean isContainMetrics) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        List<Table> tableList = hbaseFacade.listTables();\n        String hdfsRootpath = cluster.getHdfsRootPath();\n        HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n        String tableDataPath = hdfsRootpath + \"/data/\";\n        // ??????\n        if (isContainMetrics) {\n            for (Table table : tableList) {\n                table.setSpaceSize(hdfsFacade.getPathSpaceSize(tableDataPath + table.getNamespace() + \"/\" + table.getTableName()));\n            }\n        }\n        return tableList;\n    }\n\n    @Override\n    public List<String> listTableNameByClusterName(String clusterName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        return hbaseFacade.listTableNames();\n    }\n\n    @Override\n    public Table getTableByName(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        Table table = hbaseFacade.getTableByName(tableName);\n        return table;\n    }\n\n    @Override\n    public int save(String clusterName, String ddlStr) {\n        Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n        if (null != table) {\n            Cluster cluster = clusterService.getClusterByName(clusterName);\n            HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n            hbaseFacade.createTable(table);\n        }\n        return 0;\n    }\n\n    @Override\n    public int update(String clusterName, String ddlStr) {\n        Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n        if (null != table) {\n            Cluster cluster = clusterService.getClusterByName(clusterName);\n            HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n            hbaseFacade.alterTable(table);\n        }\n        return 0;\n    }\n\n    @Override\n    public void enableTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.ENABLE);\n    }\n\n    @Override\n    public void disableTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.DISABLE);\n    }\n\n    @Override\n    public void deleteTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.DELETE);\n    }\n\n    @Override\n    public void compactTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.COMPACT);\n    }\n\n    @Override\n    public Long getTableSpaceSize(String clusterName, String namespace, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        String hdfsRootpath = cluster.getHdfsRootPath();\n        HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n        String tableDataPath = new StringBuilder(hdfsRootpath).append(\"/data/\").append(namespace).append(\"/\").append(tableName).toString();\n        long spaceSize = hdfsFacade.getPathSpaceSize(tableDataPath);\n        return spaceSize;\n    }\n}\n", "class_id": 0, "repo": "MeetYouDevs/hbase-manager", "file": "src/main/java/com/meiyou/hbase/manager/service/impl/TableServiceImpl.java", "last_update_at": "2021-08-17T16:13:14+00:00", "original_content": "@Service\npublic class TableServiceImpl implements TableService {\n\n    @Autowired\n    private ClusterService clusterService;\n\n    @Override\n    public List<Table> listTableByClusterName(String clusterName, boolean isContainMetrics) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        List<Table> tableList = hbaseFacade.listTables();\n        String hdfsRootpath = cluster.getHdfsRootPath();\n        HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n        String tableDataPath = hdfsRootpath + \"/data/\";\n        // ??????\n        if (isContainMetrics) {\n            for (Table table : tableList) {\n                table.setSpaceSize(hdfsFacade.getPathSpaceSize(tableDataPath + table.getNamespace() + \"/\" + table.getTableName()));\n            }\n        }\n        return tableList;\n    }\n\n    @Override\n    public List<String> listTableNameByClusterName(String clusterName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        return hbaseFacade.listTableNames();\n    }\n\n    @Override\n    public Table getTableByName(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        Table table = hbaseFacade.getTableByName(tableName);\n        return table;\n    }\n\n    @Override\n    public int save(String clusterName, String ddlStr) {\n        Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n        if (null != table) {\n            Cluster cluster = clusterService.getClusterByName(clusterName);\n            HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n            hbaseFacade.createTable(table);\n        }\n        return 0;\n    }\n\n    @Override\n    public int update(String clusterName, String ddlStr) {\n        Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);\n        if (null != table) {\n            Cluster cluster = clusterService.getClusterByName(clusterName);\n            HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n            hbaseFacade.alterTable(table);\n        }\n        return 0;\n    }\n\n    @Override\n    public void enableTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.ENABLE);\n    }\n\n    @Override\n    public void disableTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.DISABLE);\n    }\n\n    @Override\n    public void deleteTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.DELETE);\n    }\n\n    @Override\n    public void compactTable(String clusterName, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());\n        hbaseFacade.operateTable(tableName, HTableOpEnum.COMPACT);\n    }\n\n    @Override\n    public Long getTableSpaceSize(String clusterName, String namespace, String tableName) {\n        Cluster cluster = clusterService.getClusterByName(clusterName);\n        String hdfsRootpath = cluster.getHdfsRootPath();\n        HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);\n        String tableDataPath = new StringBuilder(hdfsRootpath).append(\"/data/\").append(namespace).append(\"/\").append(tableName).toString();\n        long spaceSize = hdfsFacade.getPathSpaceSize(tableDataPath);\n        return spaceSize;\n    }\n}\n", "refactored": false}
{"hexsha": "2242cfb0f4039ef1dd1986bcfd3655b2f3ae6feb", "ext": "java", "lang": "Java", "content": "public class MD {\n\n    /**\n     * @param obj the object to create the check sum\n     * @return the numeric checksum for an object\n     */\n    public static BigInteger checksum(Object obj) {\n        if (obj == null) {\n            return BigInteger.ZERO;\n        }\n        Class<?> clz = obj.getClass();\n        if (!(Serializable.class.isAssignableFrom(clz))) {\n            String tostring = obj.toString();\n            if (tostring.contains(clz.getName()) && tostring.contains(\"@\")) {\n                //use hash code\n                return BigInteger.valueOf(obj.hashCode());\n            } else {\n                //try to use toString\n                obj = tostring;\n            }\n        }\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(obj);\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(baos.toByteArray());\n            return new BigInteger(1, m.digest());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to write to object output stream ERROR:\" + e.getMessage(), e);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Unable to get message digest MD5 ERROR:\" + e.getMessage());\n        }\n    }\n}\n", "class_id": 0, "repo": "vaquarkhan/nyla", "file": "src/main/java/nyla/solutions/core/security/MD.java", "last_update_at": "2021-09-20T13:20:21+00:00", "original_content": "public class MD {\n\n    /**\n     * @param obj the object to create the check sum\n     * @return the numeric checksum for an object\n     */\n    public static BigInteger checksum(Object obj) {\n        if (obj == null) {\n            return BigInteger.ZERO;\n        }\n        Class<?> clz = obj.getClass();\n        if (!(Serializable.class.isAssignableFrom(clz))) {\n            String tostring = obj.toString();\n            if (tostring.contains(clz.getName()) && tostring.contains(\"@\")) {\n                //use hash code\n                return BigInteger.valueOf(obj.hashCode());\n            } else {\n                //try to use toString\n                obj = tostring;\n            }\n        }\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(obj);\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(baos.toByteArray());\n            return new BigInteger(1, m.digest());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to write to object output stream ERROR:\" + e.getMessage(), e);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Unable to get message digest MD5 ERROR:\" + e.getMessage());\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "0a1e9bd38adebe2351975cd89a116d8cc06a6a3a", "ext": "java", "lang": "Java", "content": "public class BlockRail extends BlockRailBase {\n\n    public static final PropertyEnum<BlockRailBase.EnumRailDirection> SHAPE = PropertyEnum.<BlockRailBase.EnumRailDirection>create(\"shape\", BlockRailBase.EnumRailDirection.class);\n\n    protected BlockRail() {\n        super(false);\n        this.setDefaultState(this.blockState.getBaseState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH));\n    }\n\n    protected void updateState(IBlockState state, World worldIn, BlockPos pos, Block blockIn) {\n        if (blockIn.getDefaultState().canProvidePower() && (new BlockRailBase.Rail(worldIn, pos, state)).countAdjacentRails() == 3) {\n            this.updateDir(worldIn, pos, state, false);\n        }\n    }\n\n    public IProperty<BlockRailBase.EnumRailDirection> getShapeProperty() {\n        return SHAPE;\n    }\n\n    /**\n     * Convert the given metadata into a BlockState for this Block\n     */\n    public IBlockState getStateFromMeta(int meta) {\n        return this.getDefaultState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.byMetadata(meta));\n    }\n\n    /**\n     * Convert the BlockState into the correct metadata value\n     */\n    public int getMetaFromState(IBlockState state) {\n        return ((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)).getMetadata();\n    }\n\n    /**\n     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withRotation(Rotation)} whenever possible. Implementing/overriding is\n     * fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withRotation(IBlockState state, Rotation rot) {\n        switch(rot) {\n            case CLOCKWISE_180:\n                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                }\n            case COUNTERCLOCKWISE_90:\n                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n            case CLOCKWISE_90:\n                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n            default:\n                return state;\n        }\n    }\n\n    /**\n     * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withMirror(Mirror)} whenever possible. Implementing/overriding is fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withMirror(IBlockState state, Mirror mirrorIn) {\n        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = (BlockRailBase.EnumRailDirection) state.getValue(SHAPE);\n        switch(mirrorIn) {\n            case LEFT_RIGHT:\n                switch(blockrailbase$enumraildirection) {\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    default:\n                        return super.withMirror(state, mirrorIn);\n                }\n            case FRONT_BACK:\n                switch(blockrailbase$enumraildirection) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                    case ASCENDING_SOUTH:\n                    default:\n                        break;\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                }\n        }\n        return super.withMirror(state, mirrorIn);\n    }\n\n    protected BlockStateContainer createBlockState() {\n        return new BlockStateContainer(this, new IProperty[] { SHAPE });\n    }\n}\n", "class_id": 0, "repo": "KubecraftServer/addon", "file": "build/tmp/recompileMc/sources/net/minecraft/block/BlockRail.java", "last_update_at": "2021-12-19T18:11:35+00:00", "original_content": "public class BlockRail extends BlockRailBase {\n\n    public static final PropertyEnum<BlockRailBase.EnumRailDirection> SHAPE = PropertyEnum.<BlockRailBase.EnumRailDirection>create(\"shape\", BlockRailBase.EnumRailDirection.class);\n\n    protected BlockRail() {\n        super(false);\n        this.setDefaultState(this.blockState.getBaseState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH));\n    }\n\n    protected void updateState(IBlockState state, World worldIn, BlockPos pos, Block blockIn) {\n        if (blockIn.getDefaultState().canProvidePower() && (new BlockRailBase.Rail(worldIn, pos, state)).countAdjacentRails() == 3) {\n            this.updateDir(worldIn, pos, state, false);\n        }\n    }\n\n    public IProperty<BlockRailBase.EnumRailDirection> getShapeProperty() {\n        return SHAPE;\n    }\n\n    /**\n     * Convert the given metadata into a BlockState for this Block\n     */\n    public IBlockState getStateFromMeta(int meta) {\n        return this.getDefaultState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.byMetadata(meta));\n    }\n\n    /**\n     * Convert the BlockState into the correct metadata value\n     */\n    public int getMetaFromState(IBlockState state) {\n        return ((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)).getMetadata();\n    }\n\n    /**\n     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withRotation(Rotation)} whenever possible. Implementing/overriding is\n     * fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withRotation(IBlockState state, Rotation rot) {\n        switch(rot) {\n            case CLOCKWISE_180:\n                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                }\n            case COUNTERCLOCKWISE_90:\n                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n            case CLOCKWISE_90:\n                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);\n                    case EAST_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);\n                }\n            default:\n                return state;\n        }\n    }\n\n    /**\n     * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed\n     * blockstate.\n     * @deprecated call via {@link IBlockState#withMirror(Mirror)} whenever possible. Implementing/overriding is fine.\n     */\n    @SuppressWarnings(\"incomplete-switch\")\n    public IBlockState withMirror(IBlockState state, Mirror mirrorIn) {\n        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = (BlockRailBase.EnumRailDirection) state.getValue(SHAPE);\n        switch(mirrorIn) {\n            case LEFT_RIGHT:\n                switch(blockrailbase$enumraildirection) {\n                    case ASCENDING_NORTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);\n                    case ASCENDING_SOUTH:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    default:\n                        return super.withMirror(state, mirrorIn);\n                }\n            case FRONT_BACK:\n                switch(blockrailbase$enumraildirection) {\n                    case ASCENDING_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);\n                    case ASCENDING_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);\n                    case ASCENDING_NORTH:\n                    case ASCENDING_SOUTH:\n                    default:\n                        break;\n                    case SOUTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);\n                    case SOUTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);\n                    case NORTH_WEST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);\n                    case NORTH_EAST:\n                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);\n                }\n        }\n        return super.withMirror(state, mirrorIn);\n    }\n\n    protected BlockStateContainer createBlockState() {\n        return new BlockStateContainer(this, new IProperty[] { SHAPE });\n    }\n}\n", "refactored": false}
{"hexsha": "0a90942c9de76f337b39b5c7475c993ad265d6d6", "ext": "java", "lang": "Java", "content": "public class QueryRunner {\n\n    private Tokenizer tokenizer;\n\n    private Parser parser;\n\n    private Interpreter interpreter;\n\n    public QueryRunner() {\n        tokenizer = new SimpleTokenizer();\n        parser = new Parser();\n        interpreter = new Interpreter();\n    }\n\n    public QueryRunner(Tokenizer tokenizer, Parser parser, Interpreter interpreter) {\n        this.tokenizer = tokenizer;\n        this.parser = parser;\n        this.interpreter = interpreter;\n    }\n\n    public Boolean runQuery(String query, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n        List<Token> tokens = tokenizer.tokenize(query);\n        AbstractSyntaxTree ast = parser.generateAst(tokens);\n        return interpreter.interpretAst(ast, valueMap);\n    }\n\n    public Boolean runQuery(AbstractSyntaxTree ast, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n        return interpreter.interpretAst(ast, valueMap);\n    }\n\n    public AbstractSyntaxTree generateAst(String query) {\n        List<Token> tokens = tokenizer.tokenize(query);\n        return parser.generateAst(tokens);\n    }\n}\n", "class_id": 0, "repo": "stargarth-enterprise/BooleanQueryParser", "file": "src/main/java/stargarth/interpreter/QueryRunner.java", "last_update_at": "2021-09-16T09:37:41+00:00", "original_content": "public class QueryRunner {\n\n    private Tokenizer tokenizer;\n\n    private Parser parser;\n\n    private Interpreter interpreter;\n\n    public QueryRunner() {\n        tokenizer = new SimpleTokenizer();\n        parser = new Parser();\n        interpreter = new Interpreter();\n    }\n\n    public QueryRunner(Tokenizer tokenizer, Parser parser, Interpreter interpreter) {\n        this.tokenizer = tokenizer;\n        this.parser = parser;\n        this.interpreter = interpreter;\n    }\n\n    public Boolean runQuery(String query, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n        List<Token> tokens = tokenizer.tokenize(query);\n        AbstractSyntaxTree ast = parser.generateAst(tokens);\n        return interpreter.interpretAst(ast, valueMap);\n    }\n\n    public Boolean runQuery(AbstractSyntaxTree ast, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {\n        return interpreter.interpretAst(ast, valueMap);\n    }\n\n    public AbstractSyntaxTree generateAst(String query) {\n        List<Token> tokens = tokenizer.tokenize(query);\n        return parser.generateAst(tokens);\n    }\n}\n", "refactored": false}
{"hexsha": "e2f527d42211782844bffcb67f211f4aac0df984", "ext": "java", "lang": "Java", "content": "public class SignupIntegrationTest extends ApiGatewayHandlerIntegrationTest {\n\n    @BeforeEach\n    void setup() {\n        handler = new SignUpHandler(TEST_CONFIGURATION_SERVICE);\n    }\n\n    @Test\n    void shouldReturn200WhenValidSignUpRequest() throws IOException {\n        String sessionId = redis.createSession();\n        redis.setSessionState(sessionId, EMAIL_CODE_VERIFIED);\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Session-Id\", sessionId);\n        headers.put(\"X-API-Key\", FRONTEND_API_KEY);\n        var response = makeRequest(Optional.of(new SignupRequest(\"joe.bloggs+5@digital.cabinet-office.gov.uk\", \"password-1\")), headers, Map.of());\n        assertThat(response, hasStatus(200));\n        BaseAPIResponse BaseAPIResponse = objectMapper.readValue(response.getBody(), BaseAPIResponse.class);\n        assertThat(BaseAPIResponse.getSessionState(), equalTo(TWO_FACTOR_REQUIRED));\n        assertTrue(userStore.userExists(\"joe.bloggs+5@digital.cabinet-office.gov.uk\"));\n    }\n}\n", "class_id": 0, "repo": "alphagov/di-authentication-api", "file": "integration-tests/src/test/java/uk/gov/di/authentication/api/SignupIntegrationTest.java", "last_update_at": "2021-11-15T12:55:55+00:00", "original_content": "public class SignupIntegrationTest extends ApiGatewayHandlerIntegrationTest {\n\n    @BeforeEach\n    void setup() {\n        handler = new SignUpHandler(TEST_CONFIGURATION_SERVICE);\n    }\n\n    @Test\n    void shouldReturn200WhenValidSignUpRequest() throws IOException {\n        String sessionId = redis.createSession();\n        redis.setSessionState(sessionId, EMAIL_CODE_VERIFIED);\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Session-Id\", sessionId);\n        headers.put(\"X-API-Key\", FRONTEND_API_KEY);\n        var response = makeRequest(Optional.of(new SignupRequest(\"joe.bloggs+5@digital.cabinet-office.gov.uk\", \"password-1\")), headers, Map.of());\n        assertThat(response, hasStatus(200));\n        BaseAPIResponse BaseAPIResponse = objectMapper.readValue(response.getBody(), BaseAPIResponse.class);\n        assertThat(BaseAPIResponse.getSessionState(), equalTo(TWO_FACTOR_REQUIRED));\n        assertTrue(userStore.userExists(\"joe.bloggs+5@digital.cabinet-office.gov.uk\"));\n    }\n}\n", "refactored": false}
{"hexsha": "d55baea88f5220601a1f7762d2dc42a9e59e67e8", "ext": "java", "lang": "Java", "content": "public class SendMessageTransaction {\n\n    private IconService iconService;\n\n    private Wallet wallet;\n\n    private SendMessageTransaction() {\n        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();\n        logging.setLevel(HttpLoggingInterceptor.Level.BODY);\n        OkHttpClient httpClient = new OkHttpClient.Builder().addInterceptor(logging).build();\n        iconService = new IconService(new HttpProvider(httpClient, Constants.SERVER_URL, 3));\n        wallet = KeyWallet.load(Constants.privateKey);\n    }\n\n    private void sendTransaction() throws IOException {\n        BigInteger networkId = BigInteger.valueOf(3);\n        Address fromAddress = wallet.getAddress();\n        Address toAddress = Constants.testAddress1;\n        BigInteger nonce = BigInteger.valueOf(1);\n        String message = \"Hello World\";\n        // make a raw transaction without the stepLimit\n        Transaction transaction = TransactionBuilder.newBuilder().nid(networkId).from(fromAddress).to(toAddress).nonce(nonce).message(message).build();\n        // get an estimated step value\n        BigInteger estimatedStep = iconService.estimateStep(transaction).execute();\n        // make a signed transaction with the same raw transaction and the estimated step\n        SignedTransaction signedTransaction = new SignedTransaction(transaction, wallet, estimatedStep);\n        Bytes hash = iconService.sendTransaction(signedTransaction).execute();\n        System.out.println(\"txHash: \" + hash);\n        TransactionResult result = Utils.getTransactionResult(iconService, hash);\n        System.out.println(\"status: \" + result.getStatus());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new SendMessageTransaction().sendTransaction();\n    }\n}\n", "class_id": 0, "repo": "ICONationDevTeam/icon-sdk-java", "file": "samples/src/main/java/foundation/icon/icx/SendMessageTransaction.java", "last_update_at": "2021-09-17T20:34:21+00:00", "original_content": "public class SendMessageTransaction {\n\n    private IconService iconService;\n\n    private Wallet wallet;\n\n    private SendMessageTransaction() {\n        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();\n        logging.setLevel(HttpLoggingInterceptor.Level.BODY);\n        OkHttpClient httpClient = new OkHttpClient.Builder().addInterceptor(logging).build();\n        iconService = new IconService(new HttpProvider(httpClient, Constants.SERVER_URL, 3));\n        wallet = KeyWallet.load(Constants.privateKey);\n    }\n\n    private void sendTransaction() throws IOException {\n        BigInteger networkId = BigInteger.valueOf(3);\n        Address fromAddress = wallet.getAddress();\n        Address toAddress = Constants.testAddress1;\n        BigInteger nonce = BigInteger.valueOf(1);\n        String message = \"Hello World\";\n        // make a raw transaction without the stepLimit\n        Transaction transaction = TransactionBuilder.newBuilder().nid(networkId).from(fromAddress).to(toAddress).nonce(nonce).message(message).build();\n        // get an estimated step value\n        BigInteger estimatedStep = iconService.estimateStep(transaction).execute();\n        // make a signed transaction with the same raw transaction and the estimated step\n        SignedTransaction signedTransaction = new SignedTransaction(transaction, wallet, estimatedStep);\n        Bytes hash = iconService.sendTransaction(signedTransaction).execute();\n        System.out.println(\"txHash: \" + hash);\n        TransactionResult result = Utils.getTransactionResult(iconService, hash);\n        System.out.println(\"status: \" + result.getStatus());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new SendMessageTransaction().sendTransaction();\n    }\n}\n", "refactored": false}
{"hexsha": "45059a9352250ed2493baa512f6df38fe9ceaa67", "ext": "java", "lang": "Java", "content": "public class IO {\n\n    private final PrintStream out;\n\n    private final Scanner scanner;\n\n    private final String consolePrefix;\n\n    enum MessageType {\n\n        INFO, WARNING, ERROR\n    }\n\n    public IO(PrintStream out, InputStream in, String consolePrefix) {\n        this.out = out;\n        this.scanner = new Scanner(in);\n        this.consolePrefix = consolePrefix;\n    }\n\n    public IO(PrintStream out, InputStream in) {\n        this(out, in, \">>> \");\n    }\n\n    public IO() {\n        this(System.out, System.in);\n    }\n\n    public void printString(String string) {\n        out.print(string);\n    }\n\n    private void printConsolePrefix() {\n        printString(consolePrefix);\n    }\n\n    public void printMessage(MessageType type, String message) {\n        printLine(String.format(\"%s: %s\", type.name(), message));\n    }\n\n    public void printError(String errorMessage) {\n        printMessage(MessageType.ERROR, errorMessage);\n    }\n\n    public void printConditionError(Object value, String condition) {\n        printError(String.format(\"The value (%s) is mismatching next condition: %s\", value.toString(), condition));\n    }\n\n    public void printLine(String string) {\n        printString(String.format(\"%s\\n\", string));\n    }\n\n    public String readString() {\n        printConsolePrefix();\n        return scanner.next();\n    }\n\n    public String readString(Predicate<String> predicate, String predicateCondition) {\n        String string;\n        for (; true; ) {\n            string = readString();\n            if (predicate.test(string)) {\n                break;\n            } else {\n                printConditionError(string, predicateCondition);\n            }\n        }\n        return string;\n    }\n\n    public int readInt() throws InputMismatchException {\n        printConsolePrefix();\n        return scanner.nextInt();\n    }\n\n    public int readInt(String errorMessage) {\n        Integer number = null;\n        for (; number == null; ) {\n            try {\n                number = readInt();\n            } catch (InputMismatchException e) {\n                readString();\n                printError(errorMessage);\n            }\n        }\n        return number;\n    }\n\n    public int readInt(String errorMessage, Predicate<Integer> predicate, String predicateCondition) {\n        int number;\n        for (; true; ) {\n            number = readInt(errorMessage);\n            if (predicate.test(number)) {\n                break;\n            } else {\n                printConditionError(number, predicateCondition);\n            }\n        }\n        return number;\n    }\n}\n", "class_id": 0, "repo": "leonidpodriz/Flights-booking", "file": "src/main/java/Console/IO.java", "last_update_at": "2021-03-28T13:28:02+00:00", "original_content": "public class IO {\n\n    private final PrintStream out;\n\n    private final Scanner scanner;\n\n    private final String consolePrefix;\n\n    enum MessageType {\n\n        INFO, WARNING, ERROR\n    }\n\n    public IO(PrintStream out, InputStream in, String consolePrefix) {\n        this.out = out;\n        this.scanner = new Scanner(in);\n        this.consolePrefix = consolePrefix;\n    }\n\n    public IO(PrintStream out, InputStream in) {\n        this(out, in, \">>> \");\n    }\n\n    public IO() {\n        this(System.out, System.in);\n    }\n\n    public void printString(String string) {\n        out.print(string);\n    }\n\n    private void printConsolePrefix() {\n        printString(consolePrefix);\n    }\n\n    public void printMessage(MessageType type, String message) {\n        printLine(String.format(\"%s: %s\", type.name(), message));\n    }\n\n    public void printError(String errorMessage) {\n        printMessage(MessageType.ERROR, errorMessage);\n    }\n\n    public void printConditionError(Object value, String condition) {\n        printError(String.format(\"The value (%s) is mismatching next condition: %s\", value.toString(), condition));\n    }\n\n    public void printLine(String string) {\n        printString(String.format(\"%s\\n\", string));\n    }\n\n    public String readString() {\n        printConsolePrefix();\n        return scanner.next();\n    }\n\n    public String readString(Predicate<String> predicate, String predicateCondition) {\n        String string;\n        while (true) {\n            string = readString();\n            if (predicate.test(string)) {\n                break;\n            } else {\n                printConditionError(string, predicateCondition);\n            }\n        }\n        return string;\n    }\n\n    public int readInt() throws InputMismatchException {\n        printConsolePrefix();\n        return scanner.nextInt();\n    }\n\n    public int readInt(String errorMessage) {\n        Integer number = null;\n        while (number == null) {\n            try {\n                number = readInt();\n            } catch (InputMismatchException e) {\n                readString();\n                printError(errorMessage);\n            }\n        }\n        return number;\n    }\n\n    public int readInt(String errorMessage, Predicate<Integer> predicate, String predicateCondition) {\n        int number;\n        while (true) {\n            number = readInt(errorMessage);\n            if (predicate.test(number)) {\n                break;\n            } else {\n                printConditionError(number, predicateCondition);\n            }\n        }\n        return number;\n    }\n}\n", "refactored": true}
{"hexsha": "4dae9c1547b458a35477b0baee243af818ee49fc", "ext": "java", "lang": "Java", "content": "public class Pair<T, U> {\n\n    /**\n     * The first value.\n     */\n    public final T first;\n\n    /**\n     * The second value.\n     */\n    public final U second;\n\n    /**\n     * Create a new pair.\n     *\n     * @param first The first value.\n     * @param second The second value.\n     */\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null || getClass() != other.getClass()) {\n            return false;\n        }\n        Pair<?, ?> pair = (Pair<?, ?>) other;\n        return Objects.equals(first, pair.first) && Objects.equals(second, pair.second);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        return Objects.hash(first, second);\n    }\n}\n", "class_id": 0, "repo": "chrsan/css-selectors", "file": "src/main/java/se/fishtank/css/selectors/util/Pair.java", "last_update_at": "2021-11-30T08:26:04+00:00", "original_content": "public class Pair<T, U> {\n\n    /**\n     * The first value.\n     */\n    public final T first;\n\n    /**\n     * The second value.\n     */\n    public final U second;\n\n    /**\n     * Create a new pair.\n     *\n     * @param first The first value.\n     * @param second The second value.\n     */\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null || getClass() != other.getClass()) {\n            return false;\n        }\n        Pair<?, ?> pair = (Pair<?, ?>) other;\n        return Objects.equals(first, pair.first) && Objects.equals(second, pair.second);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        return Objects.hash(first, second);\n    }\n}\n", "refactored": false}
{"hexsha": "56fb1f9c5d91901b20d488ac07ac5c45430043f7", "ext": "java", "lang": "Java", "content": "public class U3_L6_Activity_One {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Enter a number in the twenties\");\n        int num = scan.nextInt();\n        if (!((num >= 20) && (num < 30))) {\n            System.out.println(\"That's not in the twenties!\");\n            num = 25;\n        }\n        System.out.println(\"Your number is \" + num);\n    }\n}\n", "class_id": 0, "repo": "courtneybooker/apcsa2020", "file": "unit3/lesson6/U3L6Q1.java", "last_update_at": "2021-04-26T19:40:09+00:00", "original_content": "public class U3_L6_Activity_One {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Enter a number in the twenties\");\n        int num = scan.nextInt();\n        if (!((num >= 20) && (num < 30))) {\n            System.out.println(\"That's not in the twenties!\");\n            num = 25;\n        }\n        System.out.println(\"Your number is \" + num);\n    }\n}\n", "refactored": false}
{"hexsha": "6830f69e5781fcb99df09fa5dae7e7634139394b", "ext": "java", "lang": "Java", "content": "public class OffscreenView implements IView, IWindow {\n\n    private static final Log log = Log.create();\n\n    private boolean enabled = true;\n\n    private final Config config;\n\n    private final IController controller;\n\n    private final Viewport viewport;\n\n    private FrameBuffer frameBuffer;\n\n    private String title;\n\n    private IGPUImage colorTexture;\n\n    private Texture depthTexture;\n\n    private IContext context;\n\n    public OffscreenView(IController controller, int w, int h, Config config) {\n        this.config = config;\n        this.controller = controller;\n        this.viewport = new Viewport(0, 0, w, h);\n        setSize(new Vec2(w, h));\n        runOnSceneThread(t -> controller.viewCreated(this));\n    }\n\n    private void runOnSceneThread(IAction action) {\n        if (controller.isSceneThread())\n            action.run(controller.getScheduler().getTime());\n        else\n            controller.run(action);\n    }\n\n    @Override\n    public void dispose() {\n        frameBuffer = null;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    @Override\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    @Override\n    public Config getConfig() {\n        return config;\n    }\n\n    @Override\n    public IController getController() {\n        return controller;\n    }\n\n    @Override\n    public Viewport getViewport() {\n        return viewport;\n    }\n\n    @Override\n    public IWindow getWindow() {\n        return this;\n    }\n\n    @Override\n    public boolean isDisposed() {\n        return frameBuffer == null;\n    }\n\n    class Context implements IContext {\n\n        private final IContext ctx;\n\n        public Context() {\n            ctx = GLContextManager.acquireContext();\n        }\n\n        @Override\n        public void close() throws Exception {\n            GL11.glFinish();\n            FrameBuffer.unbind();\n            try {\n                ctx.close();\n            } catch (Throwable t) {\n                log.severe(t);\n            }\n            context = null;\n        }\n    }\n\n    @Override\n    public IContext acquireContext() {\n        context = new Context();\n        if (frameBuffer == null || viewport.w != colorTexture.getWidth() || viewport.h != colorTexture.getHeight()) {\n            if (frameBuffer == null)\n                frameBuffer = new FrameBuffer();\n            frameBuffer.bind();\n            int width = (int) viewport.w;\n            int height = (int) viewport.h;\n            colorTexture = IGPUImage.create(width, height, ComponentType.BYTE, ComponentFormat.RGBA);\n            frameBuffer.attach(GL30.GL_COLOR_ATTACHMENT0, colorTexture);\n            depthTexture = new Texture(new GLObject(Type.TEXTURE), width, height);\n            GL11.glBindTexture(GL11.GL_TEXTURE_2D, (int) depthTexture.getGPUHandle());\n            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_DEPTH_COMPONENT, width, height, 0, GL11.GL_DEPTH_COMPONENT, GL11.GL_UNSIGNED_INT, (ByteBuffer) null);\n            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);\n            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);\n            frameBuffer.attach(GL30.GL_DEPTH_ATTACHMENT, depthTexture);\n            GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);\n            GL20.glDrawBuffers(GL30.GL_COLOR_ATTACHMENT0);\n            if (!frameBuffer.isComplete())\n                log.severe(\"Status: \" + FrameBuffer.toString(frameBuffer.getStatus()));\n        } else\n            frameBuffer.bind();\n        return context;\n    }\n\n    @Override\n    public void releaseContext() {\n        try {\n            context.close();\n        } catch (Throwable t) {\n            log.severe(t);\n        }\n        context = null;\n    }\n\n    @Override\n    public void swapBuffers() {\n    }\n\n    @Override\n    public String getTitle() {\n        return title;\n    }\n\n    @Override\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    @Override\n    public boolean isVisible() {\n        return !(isDisposed());\n    }\n\n    @Override\n    public void setVisible(boolean visible) {\n    }\n\n    @Override\n    public Vec2 getPosition() {\n        return Vec2.ZERO;\n    }\n\n    @Override\n    public void setPosition(Vec2 position) {\n    }\n\n    @Override\n    public Vec2 getSize() {\n        return new Vec2(colorTexture.getWidth(), colorTexture.getHeight());\n    }\n\n    @Override\n    public void setSize(Vec2 size) {\n        colorTexture = IGPUImage.create((int) size.x, (int) size.y, ComponentType.BYTE, ComponentFormat.RGBA);\n    }\n\n    @Override\n    public Vec2 getFramebufferSize() {\n        return getSize();\n    }\n\n    public IHostImage getImage() {\n        return colorTexture.createHostImage();\n    }\n\n    @Override\n    public void setFullscreen(IMonitor monitor) {\n    }\n\n    @Override\n    public void setPointerMode(PointerMode mode) {\n    }\n\n    @Override\n    public void setPointerPosition(float x, float y) {\n    }\n\n    @Override\n    public void setWindowListener(IWindowListener windowListener) {\n    }\n\n    @Override\n    public void setKeyListener(IKeyListener keyListener) {\n    }\n\n    @Override\n    public void setPointerListener(IPointerListener pointerListener) {\n    }\n\n    @Override\n    public void setPointerIcon(File file, int hotX, int hotY) {\n    }\n}\n", "class_id": 0, "repo": "bhzunami/TronGame", "file": "ether-core/src/main/java/ch/fhnw/ether/view/OffscreenView.java", "last_update_at": "2021-08-04T07:17:00+00:00", "original_content": "public class OffscreenView implements IView, IWindow {\n\n    private static final Log log = Log.create();\n\n    private boolean enabled = true;\n\n    private final Config config;\n\n    private final IController controller;\n\n    private final Viewport viewport;\n\n    private FrameBuffer frameBuffer;\n\n    private String title;\n\n    private IGPUImage colorTexture;\n\n    private Texture depthTexture;\n\n    private IContext context;\n\n    public OffscreenView(IController controller, int w, int h, Config config) {\n        this.config = config;\n        this.controller = controller;\n        this.viewport = new Viewport(0, 0, w, h);\n        setSize(new Vec2(w, h));\n        runOnSceneThread(t -> controller.viewCreated(this));\n    }\n\n    private void runOnSceneThread(IAction action) {\n        if (controller.isSceneThread())\n            action.run(controller.getScheduler().getTime());\n        else\n            controller.run(action);\n    }\n\n    @Override\n    public void dispose() {\n        frameBuffer = null;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    @Override\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    @Override\n    public Config getConfig() {\n        return config;\n    }\n\n    @Override\n    public IController getController() {\n        return controller;\n    }\n\n    @Override\n    public Viewport getViewport() {\n        return viewport;\n    }\n\n    @Override\n    public IWindow getWindow() {\n        return this;\n    }\n\n    @Override\n    public boolean isDisposed() {\n        return frameBuffer == null;\n    }\n\n    class Context implements IContext {\n\n        private final IContext ctx;\n\n        public Context() {\n            ctx = GLContextManager.acquireContext();\n        }\n\n        @Override\n        public void close() throws Exception {\n            GL11.glFinish();\n            FrameBuffer.unbind();\n            try {\n                ctx.close();\n            } catch (Throwable t) {\n                log.severe(t);\n            }\n            context = null;\n        }\n    }\n\n    @Override\n    public IContext acquireContext() {\n        context = new Context();\n        if (frameBuffer == null || viewport.w != colorTexture.getWidth() || viewport.h != colorTexture.getHeight()) {\n            if (frameBuffer == null)\n                frameBuffer = new FrameBuffer();\n            frameBuffer.bind();\n            int width = (int) viewport.w;\n            int height = (int) viewport.h;\n            colorTexture = IGPUImage.create(width, height, ComponentType.BYTE, ComponentFormat.RGBA);\n            frameBuffer.attach(GL30.GL_COLOR_ATTACHMENT0, colorTexture);\n            depthTexture = new Texture(new GLObject(Type.TEXTURE), width, height);\n            GL11.glBindTexture(GL11.GL_TEXTURE_2D, (int) depthTexture.getGPUHandle());\n            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_DEPTH_COMPONENT, width, height, 0, GL11.GL_DEPTH_COMPONENT, GL11.GL_UNSIGNED_INT, (ByteBuffer) null);\n            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);\n            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);\n            frameBuffer.attach(GL30.GL_DEPTH_ATTACHMENT, depthTexture);\n            GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);\n            GL20.glDrawBuffers(GL30.GL_COLOR_ATTACHMENT0);\n            if (!frameBuffer.isComplete())\n                log.severe(\"Status: \" + FrameBuffer.toString(frameBuffer.getStatus()));\n        } else\n            frameBuffer.bind();\n        return context;\n    }\n\n    @Override\n    public void releaseContext() {\n        try {\n            context.close();\n        } catch (Throwable t) {\n            log.severe(t);\n        }\n        context = null;\n    }\n\n    @Override\n    public void swapBuffers() {\n    }\n\n    @Override\n    public String getTitle() {\n        return title;\n    }\n\n    @Override\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    @Override\n    public boolean isVisible() {\n        return !(isDisposed());\n    }\n\n    @Override\n    public void setVisible(boolean visible) {\n    }\n\n    @Override\n    public Vec2 getPosition() {\n        return Vec2.ZERO;\n    }\n\n    @Override\n    public void setPosition(Vec2 position) {\n    }\n\n    @Override\n    public Vec2 getSize() {\n        return new Vec2(colorTexture.getWidth(), colorTexture.getHeight());\n    }\n\n    @Override\n    public void setSize(Vec2 size) {\n        colorTexture = IGPUImage.create((int) size.x, (int) size.y, ComponentType.BYTE, ComponentFormat.RGBA);\n    }\n\n    @Override\n    public Vec2 getFramebufferSize() {\n        return getSize();\n    }\n\n    public IHostImage getImage() {\n        return colorTexture.createHostImage();\n    }\n\n    @Override\n    public void setFullscreen(IMonitor monitor) {\n    }\n\n    @Override\n    public void setPointerMode(PointerMode mode) {\n    }\n\n    @Override\n    public void setPointerPosition(float x, float y) {\n    }\n\n    @Override\n    public void setWindowListener(IWindowListener windowListener) {\n    }\n\n    @Override\n    public void setKeyListener(IKeyListener keyListener) {\n    }\n\n    @Override\n    public void setPointerListener(IPointerListener pointerListener) {\n    }\n\n    @Override\n    public void setPointerIcon(File file, int hotX, int hotY) {\n    }\n}\n", "refactored": false}
{"hexsha": "d01caa778c358af05e7c9ced3072245899fa3392", "ext": "java", "lang": "Java", "content": "@Mojo(defaultPhase = LifecyclePhase.VALIDATE, name = \"check-format\", threadSafe = true)\npublic class CheckFormatMojo extends AbstractXmlMojo {\n\n    private class ViolationCollector implements XmlFormatViolationHandler {\n\n        private final Map<String, List<XmlFormatViolation>> violations = new LinkedHashMap<String, List<XmlFormatViolation>>();\n\n        @Override\n        public void handle(XmlFormatViolation violation) {\n            List<XmlFormatViolation> list = violations.get(violation.getFile().getAbsolutePath());\n            if (list == null) {\n                list = new ArrayList<XmlFormatViolation>();\n                violations.put(violation.getFile().getAbsolutePath(), list);\n            }\n            list.add(violation);\n            if (failOnFormatViolation) {\n                getLog().error(violation.toString());\n            } else {\n                getLog().warn(violation.toString());\n            }\n        }\n\n        public boolean hasViolations() {\n            return !violations.isEmpty();\n        }\n\n        public boolean hasViolations(File file) {\n            List<XmlFormatViolation> list = violations.get(file.getAbsolutePath());\n            return list != null && !list.isEmpty();\n        }\n    }\n\n    /**\n     * The encoding of files included in {@link #formatFileSets}. Note that the\n     * {@code encoding can be set also per FormatFileSet}.\n     */\n    @Parameter(property = \"xml.encoding\", defaultValue = \"${project.build.sourceEncoding}\")\n    private String encoding;\n\n    /**\n     * Tells the mojo what to do in case XML formatting violations are found. if {@code true}, all violations will be\n     * reported on the console as ERRORs and the build will fail. if {@code false}, all violations will be reported on\n     * the console as WARNs and the build will proceed further.\n     */\n    @Parameter(property = \"xml.failOnFormatViolation\", defaultValue = \"true\")\n    private boolean failOnFormatViolation;\n\n    /**\n     * File patterns to include. The patterns are relative to the current project's {@code baseDir}.\n     */\n    @Parameter\n    private List<FormatFileSet> formatFileSets = new ArrayList<FormatFileSet>();\n\n    /**\n     * The number of spaces expected for indentation. Note that {@code indentSize} can be configuread also per\n     * {@link FormatFileSet}.\n     */\n    @Parameter(property = \"xml.indentSize\", defaultValue = \"2\")\n    private int indentSize;\n\n    /**\n     * A {@link SAXParserFactory}\n     */\n    private SAXParserFactory saxParserFactory;\n\n    /**\n     * If set to {@code true}, the result of {@link FormatFileSet#getDefault(String, int)} will be appended to\n     * {@link #formatFileSets} before the processing.\n     */\n    @Parameter(property = \"xml.useDefaultFormatFileSet\", defaultValue = \"true\")\n    private boolean useDefaultFormatFileSet;\n\n    /**\n     * Creates a new {@link CheckFormatMojo} instance.\n     */\n    public CheckFormatMojo() {\n        super();\n        this.saxParserFactory = SAXParserFactory.newInstance();\n        this.saxParserFactory.setValidating(false);\n    }\n\n    /**\n     * Checks the formatting of the given {@code file}. The file is read using the given {@code encoding} and the\n     * violations are reported to the given {@code violationHandler}.\n     *\n     * @param file the file to check\n     * @param encoding the encoding to use for reading the {@code file}\n     * @param violationHandler the {@link XmlFormatViolationHandler} to report violations\n     * @throws MojoExecutionException if there is any lover level exception reading or parsing the file.\n     */\n    private void check(File file, String encoding, XmlFormatViolationHandler violationHandler) throws MojoExecutionException {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new FileInputStream(file), encoding);\n            SAXParser saxParser = saxParserFactory.newSAXParser();\n            IndentCheckSaxHandler handler = new IndentCheckSaxHandler(file, indentSize, violationHandler);\n            saxParser.parse(new InputSource(in), handler);\n        } catch (Exception e) {\n            throw new MojoExecutionException(\"Could not process file \" + file.getAbsolutePath(), e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    getLog().error(\"Could not close Reader for \" + file.getAbsolutePath(), e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Called by Maven for executing the Mojo.\n     *\n     * @throws MojoExecutionException Running the Mojo failed.\n     * @throws MojoFailureException A configuration error was detected.\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        if (isSkipping()) {\n            getLog().debug(\"Skipping execution, as demanded by user.\");\n            return;\n        }\n        if (useDefaultFormatFileSet) {\n            formatFileSets.add(FormatFileSet.getDefault(getBasedir(), encoding, indentSize));\n        }\n        if (formatFileSets == null || formatFileSets.isEmpty()) {\n            /* nothing to do */\n            return;\n        }\n        ViolationCollector violationCollector = new ViolationCollector();\n        int processedFileCount = 0;\n        for (FormatFileSet formatFileSet : formatFileSets) {\n            String effectiveEncoding = formatFileSet.getEncoding();\n            if (effectiveEncoding == null) {\n                effectiveEncoding = this.encoding;\n            }\n            String[] includedFiles = scan(formatFileSet);\n            for (String includedPath : includedFiles) {\n                processedFileCount++;\n                File file = new File(formatFileSet.getDirectory(), includedPath);\n                check(file, effectiveEncoding, violationCollector);\n                if (getLog().isDebugEnabled() && !violationCollector.hasViolations(file)) {\n                    getLog().debug(\"No XML formatting violations found in file \" + file.getAbsolutePath());\n                }\n            }\n        }\n        getLog().debug(\"Checked the formatting of \" + processedFileCount + \" files\");\n        if (failOnFormatViolation && violationCollector.hasViolations()) {\n            throw new MojoFailureException(\"There are XML formatting violations. Check the above log for details.\");\n        }\n    }\n\n    /**\n     * A {@link DirectoryScanner} boiler plate.\n     *\n     * @param fileSet {@link FileSet} to scan\n     * @return the included paths\n     */\n    private String[] scan(FileSet fileSet) {\n        File basedir = new File(fileSet.getDirectory());\n        if (!basedir.exists() || !basedir.isDirectory()) {\n            return null;\n        }\n        DirectoryScanner scanner = new DirectoryScanner();\n        List<String> includes = fileSet.getIncludes();\n        List<String> excludes = fileSet.getExcludes();\n        if (includes != null && includes.size() > 0) {\n            scanner.setIncludes(includes.toArray(new String[0]));\n        }\n        if (excludes != null && excludes.size() > 0) {\n            scanner.setExcludes(excludes.toArray(new String[0]));\n        }\n        scanner.setBasedir(basedir);\n        scanner.scan();\n        return scanner.getIncludedFiles();\n    }\n\n    /**\n     * Sets the number of spaces for indentation.\n     *\n     * @param indentSize the number of spaces\n     */\n    public void setIndentSize(int indentSize) {\n        this.indentSize = indentSize;\n    }\n}\n", "class_id": 0, "repo": "srinivas32/xml-maven-plugin", "file": "src/main/java/org/codehaus/mojo/xml/CheckFormatMojo.java", "last_update_at": "2021-09-11T04:38:42+00:00", "original_content": "@Mojo(defaultPhase = LifecyclePhase.VALIDATE, name = \"check-format\", threadSafe = true)\npublic class CheckFormatMojo extends AbstractXmlMojo {\n\n    private class ViolationCollector implements XmlFormatViolationHandler {\n\n        private final Map<String, List<XmlFormatViolation>> violations = new LinkedHashMap<String, List<XmlFormatViolation>>();\n\n        @Override\n        public void handle(XmlFormatViolation violation) {\n            List<XmlFormatViolation> list = violations.get(violation.getFile().getAbsolutePath());\n            if (list == null) {\n                list = new ArrayList<XmlFormatViolation>();\n                violations.put(violation.getFile().getAbsolutePath(), list);\n            }\n            list.add(violation);\n            if (failOnFormatViolation) {\n                getLog().error(violation.toString());\n            } else {\n                getLog().warn(violation.toString());\n            }\n        }\n\n        public boolean hasViolations() {\n            return !violations.isEmpty();\n        }\n\n        public boolean hasViolations(File file) {\n            List<XmlFormatViolation> list = violations.get(file.getAbsolutePath());\n            return list != null && !list.isEmpty();\n        }\n    }\n\n    /**\n     * The encoding of files included in {@link #formatFileSets}. Note that the\n     * {@code encoding can be set also per FormatFileSet}.\n     */\n    @Parameter(property = \"xml.encoding\", defaultValue = \"${project.build.sourceEncoding}\")\n    private String encoding;\n\n    /**\n     * Tells the mojo what to do in case XML formatting violations are found. if {@code true}, all violations will be\n     * reported on the console as ERRORs and the build will fail. if {@code false}, all violations will be reported on\n     * the console as WARNs and the build will proceed further.\n     */\n    @Parameter(property = \"xml.failOnFormatViolation\", defaultValue = \"true\")\n    private boolean failOnFormatViolation;\n\n    /**\n     * File patterns to include. The patterns are relative to the current project's {@code baseDir}.\n     */\n    @Parameter\n    private List<FormatFileSet> formatFileSets = new ArrayList<FormatFileSet>();\n\n    /**\n     * The number of spaces expected for indentation. Note that {@code indentSize} can be configuread also per\n     * {@link FormatFileSet}.\n     */\n    @Parameter(property = \"xml.indentSize\", defaultValue = \"2\")\n    private int indentSize;\n\n    /**\n     * A {@link SAXParserFactory}\n     */\n    private SAXParserFactory saxParserFactory;\n\n    /**\n     * If set to {@code true}, the result of {@link FormatFileSet#getDefault(String, int)} will be appended to\n     * {@link #formatFileSets} before the processing.\n     */\n    @Parameter(property = \"xml.useDefaultFormatFileSet\", defaultValue = \"true\")\n    private boolean useDefaultFormatFileSet;\n\n    /**\n     * Creates a new {@link CheckFormatMojo} instance.\n     */\n    public CheckFormatMojo() {\n        super();\n        this.saxParserFactory = SAXParserFactory.newInstance();\n        this.saxParserFactory.setValidating(false);\n    }\n\n    /**\n     * Checks the formatting of the given {@code file}. The file is read using the given {@code encoding} and the\n     * violations are reported to the given {@code violationHandler}.\n     *\n     * @param file the file to check\n     * @param encoding the encoding to use for reading the {@code file}\n     * @param violationHandler the {@link XmlFormatViolationHandler} to report violations\n     * @throws MojoExecutionException if there is any lover level exception reading or parsing the file.\n     */\n    private void check(File file, String encoding, XmlFormatViolationHandler violationHandler) throws MojoExecutionException {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new FileInputStream(file), encoding);\n            SAXParser saxParser = saxParserFactory.newSAXParser();\n            IndentCheckSaxHandler handler = new IndentCheckSaxHandler(file, indentSize, violationHandler);\n            saxParser.parse(new InputSource(in), handler);\n        } catch (Exception e) {\n            throw new MojoExecutionException(\"Could not process file \" + file.getAbsolutePath(), e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    getLog().error(\"Could not close Reader for \" + file.getAbsolutePath(), e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Called by Maven for executing the Mojo.\n     *\n     * @throws MojoExecutionException Running the Mojo failed.\n     * @throws MojoFailureException A configuration error was detected.\n     */\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        if (isSkipping()) {\n            getLog().debug(\"Skipping execution, as demanded by user.\");\n            return;\n        }\n        if (useDefaultFormatFileSet) {\n            formatFileSets.add(FormatFileSet.getDefault(getBasedir(), encoding, indentSize));\n        }\n        if (formatFileSets == null || formatFileSets.isEmpty()) {\n            /* nothing to do */\n            return;\n        }\n        ViolationCollector violationCollector = new ViolationCollector();\n        int processedFileCount = 0;\n        for (FormatFileSet formatFileSet : formatFileSets) {\n            String effectiveEncoding = formatFileSet.getEncoding();\n            if (effectiveEncoding == null) {\n                effectiveEncoding = this.encoding;\n            }\n            String[] includedFiles = scan(formatFileSet);\n            for (String includedPath : includedFiles) {\n                processedFileCount++;\n                File file = new File(formatFileSet.getDirectory(), includedPath);\n                check(file, effectiveEncoding, violationCollector);\n                if (getLog().isDebugEnabled() && !violationCollector.hasViolations(file)) {\n                    getLog().debug(\"No XML formatting violations found in file \" + file.getAbsolutePath());\n                }\n            }\n        }\n        getLog().debug(\"Checked the formatting of \" + processedFileCount + \" files\");\n        if (failOnFormatViolation && violationCollector.hasViolations()) {\n            throw new MojoFailureException(\"There are XML formatting violations. Check the above log for details.\");\n        }\n    }\n\n    /**\n     * A {@link DirectoryScanner} boiler plate.\n     *\n     * @param fileSet {@link FileSet} to scan\n     * @return the included paths\n     */\n    private String[] scan(FileSet fileSet) {\n        File basedir = new File(fileSet.getDirectory());\n        if (!basedir.exists() || !basedir.isDirectory()) {\n            return null;\n        }\n        DirectoryScanner scanner = new DirectoryScanner();\n        List<String> includes = fileSet.getIncludes();\n        List<String> excludes = fileSet.getExcludes();\n        if (includes != null && includes.size() > 0) {\n            scanner.setIncludes(includes.toArray(new String[0]));\n        }\n        if (excludes != null && excludes.size() > 0) {\n            scanner.setExcludes(excludes.toArray(new String[0]));\n        }\n        scanner.setBasedir(basedir);\n        scanner.scan();\n        return scanner.getIncludedFiles();\n    }\n\n    /**\n     * Sets the number of spaces for indentation.\n     *\n     * @param indentSize the number of spaces\n     */\n    public void setIndentSize(int indentSize) {\n        this.indentSize = indentSize;\n    }\n}\n", "refactored": false}
{"hexsha": "29468b6a959b45f1ec1410e8277b26109e673596", "ext": "java", "lang": "Java", "content": "public final class SHA1Util {\n\n    private static final ThreadLocal<MessageDigest> SHA1 = ThreadLocal.withInitial(() -> {\n        try {\n            return MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new InternalError(\"SHA-1 not supported on this platform - Outdated?\");\n        }\n    });\n\n    /**\n     * Performs a SHA-1 hash on the specified data\n     *\n     * @param data The data to hash\n     * @return The hashed data\n     */\n    private static byte[] sha1(byte[] data) {\n        MessageDigest digest = SHA1.get();\n        digest.reset();\n        return digest.digest(data);\n    }\n\n    public static String sha1(File file) throws IOException {\n        return SecretUtil.byteArrayToHexString(Files.readAllBytes(file.toPath()));\n    }\n\n    public static String sha1(String source) {\n        return sha1(source, StandardCharsets.UTF_8);\n    }\n\n    public static String sha1(String source, Charset charset) {\n        byte[] bytes = source.getBytes(charset);\n        return SecretUtil.byteArrayToHexString(sha1(bytes));\n    }\n}\n", "class_id": 0, "repo": "qiunet/DuoDuo", "file": "QiunetUtils/src/main/java/org/qiunet/utils/secret/SHA1Util.java", "last_update_at": "2021-11-19T01:51:27+00:00", "original_content": "public final class SHA1Util {\n\n    private static final ThreadLocal<MessageDigest> SHA1 = ThreadLocal.withInitial(() -> {\n        try {\n            return MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new InternalError(\"SHA-1 not supported on this platform - Outdated?\");\n        }\n    });\n\n    /**\n     * Performs a SHA-1 hash on the specified data\n     *\n     * @param data The data to hash\n     * @return The hashed data\n     */\n    private static byte[] sha1(byte[] data) {\n        MessageDigest digest = SHA1.get();\n        digest.reset();\n        return digest.digest(data);\n    }\n\n    public static String sha1(File file) throws IOException {\n        return SecretUtil.byteArrayToHexString(Files.readAllBytes(file.toPath()));\n    }\n\n    public static String sha1(String source) {\n        return sha1(source, StandardCharsets.UTF_8);\n    }\n\n    public static String sha1(String source, Charset charset) {\n        byte[] bytes = source.getBytes(charset);\n        return SecretUtil.byteArrayToHexString(sha1(bytes));\n    }\n}\n", "refactored": false}
{"hexsha": "21bf6ff3974912f326f07e60b655d83815cf8d49", "ext": "java", "lang": "Java", "content": "public class CertificateBuilderTest {\n\n    @Test\n    public void SelfSignCertificateBuilder() {\n        KeyPair keyPair = new KeyPairBuilder().setAlgorithm(\"RSA\").setLength(2048).setProvider(\"bc\").setSecureRandom(new SecureRandom()).build();\n        PKCS10CertificationRequest pkcs10CertificationRequest = new CertificateRequestBuilder().setSubject(\"C=CN,L=nanjing,O=koal,OU=develop,CN=robert\").setPublicKey(keyPair.getPublic()).setPrivateKey(keyPair.getPrivate()).setProvider(\"BC\").build();\n        try {\n            X509Certificate signCertificate = Converter.file2Cert(new FileInputStream(\"/Users/robert/client.crt\"));\n            X509Certificate x509Certificate = new CertificateBuilder().setSignCertificate(signCertificate).setCA(true).setPathLen(10).setRequest(pkcs10CertificationRequest).setSerialNumber(new BigInteger(\"1\")).setSignKey(keyPair.getPrivate()).build();\n            Converter.cert2File(x509Certificate, new FileOutputStream(\"/Users/robert/test.crt\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "class_id": 0, "repo": "mr-tan4/openca", "file": "commonlang/src/test/java/com/common/cert/CertificateBuilderTest.java", "last_update_at": "2021-01-19T02:00:49+00:00", "original_content": "public class CertificateBuilderTest {\n\n    @Test\n    public void SelfSignCertificateBuilder() {\n        KeyPair keyPair = new KeyPairBuilder().setAlgorithm(\"RSA\").setLength(2048).setProvider(\"bc\").setSecureRandom(new SecureRandom()).build();\n        PKCS10CertificationRequest pkcs10CertificationRequest = new CertificateRequestBuilder().setSubject(\"C=CN,L=nanjing,O=koal,OU=develop,CN=robert\").setPublicKey(keyPair.getPublic()).setPrivateKey(keyPair.getPrivate()).setProvider(\"BC\").build();\n        try {\n            X509Certificate signCertificate = Converter.file2Cert(new FileInputStream(\"/Users/robert/client.crt\"));\n            X509Certificate x509Certificate = new CertificateBuilder().setSignCertificate(signCertificate).setCA(true).setPathLen(10).setRequest(pkcs10CertificationRequest).setSerialNumber(new BigInteger(\"1\")).setSignKey(keyPair.getPrivate()).build();\n            Converter.cert2File(x509Certificate, new FileOutputStream(\"/Users/robert/test.crt\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "979d1de477d5676a88d93695c18feea4c16e195d", "ext": "java", "lang": "Java", "content": "class Coordinate {\n\n    private final int x;\n\n    private final int y;\n\n    private final int manhattanDistance;\n\n    Coordinate(final int x, final int y) {\n        this.x = x;\n        this.y = y;\n        this.manhattanDistance = Math.abs(x) + Math.abs(y);\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        final Coordinate that = (Coordinate) o;\n        return x == that.x && y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n\n    @Override\n    public String toString() {\n        return \"Coordinate{\" + \"x=\" + x + \", y=\" + y + '}';\n    }\n\n    public boolean horizontallyBetween(final Coordinate start, final Coordinate end) {\n        return start.x <= x && x <= end.x || end.x <= x && x <= start.x;\n    }\n\n    public boolean verticallyBetween(final Coordinate start, final Coordinate end) {\n        return start.y <= y && y <= end.y || end.y <= y && y <= start.y;\n    }\n\n    public boolean horizontalWith(final Coordinate other) {\n        return y == other.y;\n    }\n\n    public boolean verticalWith(final Coordinate other) {\n        return x == other.x;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public int manhattanDistance() {\n        return manhattanDistance;\n    }\n\n    public int lengthTo(final Coordinate other) {\n        if (x == other.x) {\n            return Math.abs(y - other.y);\n        } else {\n            return Math.abs(x - other.x);\n        }\n    }\n}\n", "class_id": 0, "repo": "clssn/aoc-2019", "file": "day03/java/jensnerche/src/main/java/Coordinate.java", "last_update_at": "2021-04-27T05:37:08+00:00", "original_content": "class Coordinate {\n\n    private final int x;\n\n    private final int y;\n\n    private final int manhattanDistance;\n\n    Coordinate(final int x, final int y) {\n        this.x = x;\n        this.y = y;\n        this.manhattanDistance = Math.abs(x) + Math.abs(y);\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        final Coordinate that = (Coordinate) o;\n        return x == that.x && y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n\n    @Override\n    public String toString() {\n        return \"Coordinate{\" + \"x=\" + x + \", y=\" + y + '}';\n    }\n\n    public boolean horizontallyBetween(final Coordinate start, final Coordinate end) {\n        return start.x <= x && x <= end.x || end.x <= x && x <= start.x;\n    }\n\n    public boolean verticallyBetween(final Coordinate start, final Coordinate end) {\n        return start.y <= y && y <= end.y || end.y <= y && y <= start.y;\n    }\n\n    public boolean horizontalWith(final Coordinate other) {\n        return y == other.y;\n    }\n\n    public boolean verticalWith(final Coordinate other) {\n        return x == other.x;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public int manhattanDistance() {\n        return manhattanDistance;\n    }\n\n    public int lengthTo(final Coordinate other) {\n        if (x == other.x) {\n            return Math.abs(y - other.y);\n        } else {\n            return Math.abs(x - other.x);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "9fe15468b8a7ba983a58726361f89a67189c0327", "ext": "java", "lang": "Java", "content": "public class VivecraftTransformationService implements ITransformationService {\n\n    private static final Logger LOGGER = LogManager.getLogger();\n\n    public static URL ZipFileUrl;\n\n    private static ZipFile ZipFile;\n\n    private static VivecraftTransformer transformer;\n\n    @Override\n    public String name() {\n        return \"Vivecraft\";\n    }\n\n    @Override\n    public void initialize(IEnvironment environment) {\n        LOGGER.info(\"VivecraftTransformationService.initialize\");\n    }\n\n    @Override\n    public void beginScanning(IEnvironment environment) {\n    }\n\n    @Override\n    public void onLoad(IEnvironment env, Set<String> otherServices) throws IncompatibleEnvironmentException {\n        LOGGER.info(\"VivecraftTransformationService.onLoad\");\n        try {\n            ZipFileUrl = Utils.getVivecraftZipLocation().toURL();\n            ZipFile = Utils.getVivecraftZip();\n            transformer = new VivecraftTransformer(ZipFile);\n        } catch (Exception exception) {\n            LOGGER.error(\"Error loading ZIP file: \" + ZipFileUrl, (Throwable) exception);\n            throw new IncompatibleEnvironmentException(\"Error loading ZIP file: \" + ZipFileUrl);\n        }\n    }\n\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalResourcesLocator() {\n        return ITransformationService.super.additionalResourcesLocator();\n    }\n\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalClassesLocator() {\n        Set<String> set = new HashSet<>();\n        set.add(\"org.vivecraft.\");\n        Supplier<Function<String, Optional<URL>>> supplier = () -> {\n            return this::getResourceUrl;\n        };\n        Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> entry = new SimpleEntry<>(set, supplier);\n        LOGGER.info(\"additionalClassesLocator: \" + set);\n        return entry;\n    }\n\n    public Optional<URL> getResourceUrl(String name) {\n        if (name.endsWith(\".class\") && !name.startsWith(\"optifine/\")) {\n            name = \"srg/\" + name;\n        }\n        if (transformer == null) {\n            return Optional.empty();\n        } else {\n            ZipEntry zipentry = ZipFile.getEntry(name);\n            if (zipentry == null) {\n                return Optional.empty();\n            } else {\n                try {\n                    String s = ZipFileUrl.toExternalForm();\n                    URL url = new URL(\"jar:\" + s + \"!/\" + name);\n                    return Optional.of(url);\n                } catch (IOException ioexception) {\n                    LOGGER.error(ioexception);\n                    return Optional.empty();\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<ITransformer> transformers() {\n        LOGGER.info(\"VivecraftTransformationService.transformers\");\n        List<ITransformer> list = new ArrayList<>();\n        if (transformer != null) {\n            list.add(transformer);\n        }\n        list.add(new VivecraftASMTransformer());\n        return list;\n    }\n\n    public static VivecraftTransformer getTransformer() {\n        return transformer;\n    }\n}\n", "class_id": 0, "repo": "ElijahZAwesome/Vivecraft_116", "file": "src/org/vivecraft/tweaker/VivecraftTransformationService.java", "last_update_at": "2021-12-11T15:44:55+00:00", "original_content": "public class VivecraftTransformationService implements ITransformationService {\n\n    private static final Logger LOGGER = LogManager.getLogger();\n\n    public static URL ZipFileUrl;\n\n    private static ZipFile ZipFile;\n\n    private static VivecraftTransformer transformer;\n\n    @Override\n    public String name() {\n        return \"Vivecraft\";\n    }\n\n    @Override\n    public void initialize(IEnvironment environment) {\n        LOGGER.info(\"VivecraftTransformationService.initialize\");\n    }\n\n    @Override\n    public void beginScanning(IEnvironment environment) {\n    }\n\n    @Override\n    public void onLoad(IEnvironment env, Set<String> otherServices) throws IncompatibleEnvironmentException {\n        LOGGER.info(\"VivecraftTransformationService.onLoad\");\n        try {\n            ZipFileUrl = Utils.getVivecraftZipLocation().toURL();\n            ZipFile = Utils.getVivecraftZip();\n            transformer = new VivecraftTransformer(ZipFile);\n        } catch (Exception exception) {\n            LOGGER.error(\"Error loading ZIP file: \" + ZipFileUrl, (Throwable) exception);\n            throw new IncompatibleEnvironmentException(\"Error loading ZIP file: \" + ZipFileUrl);\n        }\n    }\n\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalResourcesLocator() {\n        return ITransformationService.super.additionalResourcesLocator();\n    }\n\n    @Override\n    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalClassesLocator() {\n        Set<String> set = new HashSet<>();\n        set.add(\"org.vivecraft.\");\n        Supplier<Function<String, Optional<URL>>> supplier = () -> {\n            return this::getResourceUrl;\n        };\n        Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> entry = new SimpleEntry<>(set, supplier);\n        LOGGER.info(\"additionalClassesLocator: \" + set);\n        return entry;\n    }\n\n    public Optional<URL> getResourceUrl(String name) {\n        if (name.endsWith(\".class\") && !name.startsWith(\"optifine/\")) {\n            name = \"srg/\" + name;\n        }\n        if (transformer == null) {\n            return Optional.empty();\n        } else {\n            ZipEntry zipentry = ZipFile.getEntry(name);\n            if (zipentry == null) {\n                return Optional.empty();\n            } else {\n                try {\n                    String s = ZipFileUrl.toExternalForm();\n                    URL url = new URL(\"jar:\" + s + \"!/\" + name);\n                    return Optional.of(url);\n                } catch (IOException ioexception) {\n                    LOGGER.error(ioexception);\n                    return Optional.empty();\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<ITransformer> transformers() {\n        LOGGER.info(\"VivecraftTransformationService.transformers\");\n        List<ITransformer> list = new ArrayList<>();\n        if (transformer != null) {\n            list.add(transformer);\n        }\n        list.add(new VivecraftASMTransformer());\n        return list;\n    }\n\n    public static VivecraftTransformer getTransformer() {\n        return transformer;\n    }\n}\n", "refactored": false}
{"hexsha": "3bc37aa206b127ec430864edd59b331b4f994f0e", "ext": "java", "lang": "Java", "content": "public class NobleIntegersInArray {\n\n    public int nobleInteger(int[] arr) {\n        Arrays.sort(arr);\n        int i = 0;\n        while (i < arr.length) try {\n            if ((arr.length - 1 - i) == arr[i]) {\n                return arr[i];\n            }\n        } finally {\n            i++;\n        }\n        return -1;\n    }\n}\n", "class_id": 0, "repo": "NEWBEE108/java_algos", "file": "geeks-for-geeks/src/array/NobleIntegersInArray.java", "last_update_at": "2021-12-27T23:50:12+00:00", "original_content": "public class NobleIntegersInArray {\n\n    public int nobleInteger(int[] arr) {\n        Arrays.sort(arr);\n        for (int i = 0; i < arr.length; i++) {\n            if ((arr.length - 1 - i) == arr[i]) {\n                return arr[i];\n            }\n        }\n        return -1;\n    }\n}\n", "refactored": true}
{"hexsha": "fbcf75319c426de85274374bae423ac2f8e3f1f1", "ext": "java", "lang": "Java", "content": "@Controller\npublic class SaleController {\n\n    @Autowired\n    SaleService service;\n\n    @RequestMapping(value = \"/sales\")\n    public String getAllSales(Model model) {\n        List<Sale> list = service.getAllSales();\n        model.addAttribute(\"sales\", list);\n        return \"sale-list\";\n    }\n}\n", "class_id": 0, "repo": "imran110219/Medical-Inventory", "file": "src/main/java/com/sadman/medicalinventory/controller/SaleController.java", "last_update_at": "2021-06-14T14:11:58+00:00", "original_content": "@Controller\npublic class SaleController {\n\n    @Autowired\n    SaleService service;\n\n    @RequestMapping(value = \"/sales\")\n    public String getAllSales(Model model) {\n        List<Sale> list = service.getAllSales();\n        model.addAttribute(\"sales\", list);\n        return \"sale-list\";\n    }\n}\n", "refactored": false}
{"hexsha": "2e0431d1a4cadc7c4b4e0c230f216ea1e08fe83d", "ext": "java", "lang": "Java", "content": "public class Library {\n\n    // roll a dice n times and return an array of rolls\n    public static int[] roll(int n) {\n        int[] rollArray = new int[n];\n        int i = 0;\n        while (i < rollArray.length) try {\n            rollArray[i] = (int) (Math.random() * 6) + 1;\n        } finally {\n            i++;\n        }\n        return rollArray;\n    }\n\n    public static boolean containsDuplicates(int[] array) {\n    }\n\n    // calculate the average of an array\n    public static float calculatingAverages(int[] inputArray) {\n        int sum = 0;\n        int i = 0;\n        while (i < inputArray.length) try {\n            sum += inputArray[i];\n        } finally {\n            i++;\n        }\n        float average = (float) sum / inputArray.length;\n        return average;\n    }\n\n    // take in a 2d array and return the array with the lowest average\n    public static int[] arrayOfArrays(int[][] inputArray) {\n        int[] outputArray = new int[inputArray[0].length];\n        float[] averagedArray = new float[inputArray.length];\n        System.out.println(inputArray.length);\n        int i = 0;\n        while (i < inputArray.length) try {\n            averagedArray[i] = calculatingAverages(inputArray[i]);\n        } finally {\n            i++;\n        }\n        float lowest = 9999;\n        int i = 0;\n        while (i < averagedArray.length) try {\n            if (averagedArray[i] < lowest) {\n                lowest = averagedArray[i];\n                int j = 0;\n                while (j < inputArray[0].length) try {\n                    outputArray[j] = inputArray[i][j];\n                } finally {\n                    j++;\n                }\n            }\n        } finally {\n            i++;\n        }\n        return outputArray;\n    }\n}\n", "class_id": 0, "repo": "shaybrow/java-basics", "file": "basiclibrary/lib/src/main/java/basiclibrary/Library.java", "last_update_at": "2021-03-23T16:17:18+00:00", "original_content": "public class Library {\n\n    // roll a dice n times and return an array of rolls\n    public static int[] roll(int n) {\n        int[] rollArray = new int[n];\n        for (int i = 0; i < rollArray.length; i++) {\n            rollArray[i] = (int) (Math.random() * 6) + 1;\n        }\n        return rollArray;\n    }\n\n    public static boolean containsDuplicates(int[] array) {\n    }\n\n    // calculate the average of an array\n    public static float calculatingAverages(int[] inputArray) {\n        int sum = 0;\n        for (int i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n        }\n        float average = (float) sum / inputArray.length;\n        return average;\n    }\n\n    // take in a 2d array and return the array with the lowest average\n    public static int[] arrayOfArrays(int[][] inputArray) {\n        int[] outputArray = new int[inputArray[0].length];\n        float[] averagedArray = new float[inputArray.length];\n        System.out.println(inputArray.length);\n        for (int i = 0; i < inputArray.length; i++) {\n            averagedArray[i] = calculatingAverages(inputArray[i]);\n        }\n        float lowest = 9999;\n        for (int i = 0; i < averagedArray.length; i++) {\n            if (averagedArray[i] < lowest) {\n                lowest = averagedArray[i];\n                for (int j = 0; j < inputArray[0].length; j++) {\n                    outputArray[j] = inputArray[i][j];\n                }\n            }\n        }\n        return outputArray;\n    }\n}\n", "refactored": true}
{"hexsha": "4a17c9b5e055a50b149cdea259f2165215f2fe4d", "ext": "java", "lang": "Java", "content": "@ApplicationScoped\npublic class RtppmFeed implements Consumer<String> {\n\n    private static final Logger LOG = Logger.getLogger(RtppmFeed.class.getName());\n\n    private static final String ROUTING_KEY = \"nr.rtppm\";\n\n    @Inject\n    private NetworkRailConnection networkRailFeed;\n\n    @Inject\n    private Rabbit rabbit;\n\n    @Inject\n    private RtppmLogger rtppmLogger;\n\n    @Inject\n    private RtppmArchiver rtppmArchiver;\n\n    private Consumer<String> publisher;\n\n    private Consumer<String> monitor;\n\n    @PostConstruct\n    public void start() {\n        publisher = rabbit.publishString(ROUTING_KEY);\n        monitor = RateMonitor.log(LOG, ROUTING_KEY);\n        networkRailFeed.registerTopicConsumer(\"RTPPM_ALL\", JMS.toText, this);\n        rtppmArchiver.start();\n        rtppmLogger.start();\n    }\n\n    @Override\n    public void accept(String t) {\n        if (t != null) {\n            monitor.accept(t);\n            publisher.accept(t);\n        }\n    }\n}\n", "class_id": 0, "repo": "peter-mount/opendata", "file": "applications/networkrail/src/main/java/uk/trainwatch/nrod/feed/rtppm/RtppmFeed.java", "last_update_at": "2021-12-21T13:34:54+00:00", "original_content": "@ApplicationScoped\npublic class RtppmFeed implements Consumer<String> {\n\n    private static final Logger LOG = Logger.getLogger(RtppmFeed.class.getName());\n\n    private static final String ROUTING_KEY = \"nr.rtppm\";\n\n    @Inject\n    private NetworkRailConnection networkRailFeed;\n\n    @Inject\n    private Rabbit rabbit;\n\n    @Inject\n    private RtppmLogger rtppmLogger;\n\n    @Inject\n    private RtppmArchiver rtppmArchiver;\n\n    private Consumer<String> publisher;\n\n    private Consumer<String> monitor;\n\n    @PostConstruct\n    public void start() {\n        publisher = rabbit.publishString(ROUTING_KEY);\n        monitor = RateMonitor.log(LOG, ROUTING_KEY);\n        networkRailFeed.registerTopicConsumer(\"RTPPM_ALL\", JMS.toText, this);\n        rtppmArchiver.start();\n        rtppmLogger.start();\n    }\n\n    @Override\n    public void accept(String t) {\n        if (t != null) {\n            monitor.accept(t);\n            publisher.accept(t);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "6f4c2c53552e653c27c8464de45584da3459e70a", "ext": "java", "lang": "Java", "content": "public class FastMarchingMethodMovementStrategy extends DefaultMovementStrategy {\n\n    /**\n     * The default radius to respect other people in the neighbourhood in.l\n     */\n    public static final int DEFAULT_RADIUS = 3;\n\n    /**\n     * Name of the strategy.\n     */\n    public static final String NAME = \"Fast marching method\";\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public FastMarchingMethodMovementStrategy(@JsonProperty(\"mollifierConfiguration\") MollifierConfiguration mollifierConfiguration, @JsonProperty(\"radius\") int radius) {\n        super(mollifierConfiguration, radius);\n    }\n\n    @Override\n    public String getName() {\n        return FastMarchingMethodMovementStrategy.NAME;\n    }\n\n    /**\n     * Calculate the utility function using the fast marching method.\n     *\n     * @param state  to calculate on\n     * @param target to calculate from\n     * @return the utility function in a discrete matrix form\n     */\n    @Override\n    public double[][] calculateBasePotential(State state, Location target) {\n        FastMarchingMethod fmm = new FastMarchingMethod(state.getRows(), state.getColumns(), (location) -> {\n            Optional<SimObject> occupant = state.getCellOccupant(location);\n            if (occupant.isPresent() && occupant.get().getType() == SimObjectType.OBSTACLE) {\n                // Avoid obstacles!\n                return Double.MAX_VALUE;\n            }\n            return null;\n        }, (location) -> 1.0);\n        fmm.calculate(target);\n        return fmm.getResult();\n    }\n}\n", "class_id": 0, "repo": "bennyboer/stream-sim", "file": "sim/src/main/java/edu/hm/cs/bess/streamsim/sim/logic/move/FastMarchingMethodMovementStrategy.java", "last_update_at": "2021-06-15T07:08:47+00:00", "original_content": "public class FastMarchingMethodMovementStrategy extends DefaultMovementStrategy {\n\n    /**\n     * The default radius to respect other people in the neighbourhood in.l\n     */\n    public static final int DEFAULT_RADIUS = 3;\n\n    /**\n     * Name of the strategy.\n     */\n    public static final String NAME = \"Fast marching method\";\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public FastMarchingMethodMovementStrategy(@JsonProperty(\"mollifierConfiguration\") MollifierConfiguration mollifierConfiguration, @JsonProperty(\"radius\") int radius) {\n        super(mollifierConfiguration, radius);\n    }\n\n    @Override\n    public String getName() {\n        return FastMarchingMethodMovementStrategy.NAME;\n    }\n\n    /**\n     * Calculate the utility function using the fast marching method.\n     *\n     * @param state  to calculate on\n     * @param target to calculate from\n     * @return the utility function in a discrete matrix form\n     */\n    @Override\n    public double[][] calculateBasePotential(State state, Location target) {\n        FastMarchingMethod fmm = new FastMarchingMethod(state.getRows(), state.getColumns(), (location) -> {\n            Optional<SimObject> occupant = state.getCellOccupant(location);\n            if (occupant.isPresent() && occupant.get().getType() == SimObjectType.OBSTACLE) {\n                // Avoid obstacles!\n                return Double.MAX_VALUE;\n            }\n            return null;\n        }, (location) -> 1.0);\n        fmm.calculate(target);\n        return fmm.getResult();\n    }\n}\n", "refactored": false}
{"hexsha": "04487734330501eece391abc11eeabec9bbaa619", "ext": "java", "lang": "Java", "content": "class LayerRulesTest {\n\n    @Test\n    void layerControllerMayNotBeAccessed() {\n        getLayeredArchitectur().whereLayer(\"Controller\").mayNotBeAccessedByAnyLayer().check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void layerBoundaryMayOnlyBeAccessedFromController() {\n        getLayeredArchitectur().whereLayer(\"Boundary\").mayOnlyBeAccessedByLayers(\"Controller\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void layerRepositoryMayOnlyBeAccessedFromBoundary() {\n        getLayeredArchitectur().whereLayer(\"Repository\").mayOnlyBeAccessedByLayers(\"Boundary\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void layerEntityMayNotAccessOtherLayers() {\n        noClasses().that().resideInAnyPackage(\"..entity..\").should().accessClassesThat().resideInAnyPackage(\"..controller..\", \"..services..\", \"respository..\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void noUnwantedNewPackages() {\n        noClasses().that().areNotAnnotatedWith(SpringBootApplication.class).should().resideOutsideOfPackages(\"..controller\", \"..boundary\", \"..repository\", \"..entity\", \"..dto\", \"..common\", \"..architecture\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void freeOfCycles() {\n        // then check those slices for cyclic dependencies\n        SlicesRuleDefinition.slices().matching(\"..benjamineckstein.(*)..\").should().beFreeOfCycles().check(SHOWCASECLASSES);\n    }\n\n    @Test\n    @Disabled\n    void testThatTopTierPackagesAreIndependend() {\n        // checks all subpackages of 'myapp' for cycles\n        SlicesRuleDefinition.slices().matching(\"..benjamineckstein.(**)\").should().notDependOnEachOther().check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void freeOfCycles3() {\n        // then check those slices for not having any dependencies on each other\n        SlicesRuleDefinition.slices().matching(\"..benjamineckstein.(**).service..\").should().notDependOnEachOther().check(SHOWCASECLASSES);\n    }\n\n    private Architectures.LayeredArchitecture getLayeredArchitectur() {\n        return layeredArchitecture().layer(\"Controller\").definedBy(\"..controller..\").layer(\"Boundary\").definedBy(\"..boundary..\").layer(\"Entity\").definedBy(\"..entity..\").layer(\"Repository\").definedBy(\"..repository..\");\n    }\n}\n", "class_id": 0, "repo": "benjamineckstein/showcase_tests", "file": "src/test/java/com/github/benjamineckstein/showcase/archunit/LayerRulesTest.java", "last_update_at": "2021-09-16T05:55:05+00:00", "original_content": "class LayerRulesTest {\n\n    @Test\n    void layerControllerMayNotBeAccessed() {\n        getLayeredArchitectur().whereLayer(\"Controller\").mayNotBeAccessedByAnyLayer().check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void layerBoundaryMayOnlyBeAccessedFromController() {\n        getLayeredArchitectur().whereLayer(\"Boundary\").mayOnlyBeAccessedByLayers(\"Controller\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void layerRepositoryMayOnlyBeAccessedFromBoundary() {\n        getLayeredArchitectur().whereLayer(\"Repository\").mayOnlyBeAccessedByLayers(\"Boundary\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void layerEntityMayNotAccessOtherLayers() {\n        noClasses().that().resideInAnyPackage(\"..entity..\").should().accessClassesThat().resideInAnyPackage(\"..controller..\", \"..services..\", \"respository..\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void noUnwantedNewPackages() {\n        noClasses().that().areNotAnnotatedWith(SpringBootApplication.class).should().resideOutsideOfPackages(\"..controller\", \"..boundary\", \"..repository\", \"..entity\", \"..dto\", \"..common\", \"..architecture\").check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void freeOfCycles() {\n        // then check those slices for cyclic dependencies\n        SlicesRuleDefinition.slices().matching(\"..benjamineckstein.(*)..\").should().beFreeOfCycles().check(SHOWCASECLASSES);\n    }\n\n    @Test\n    @Disabled\n    void testThatTopTierPackagesAreIndependend() {\n        // checks all subpackages of 'myapp' for cycles\n        SlicesRuleDefinition.slices().matching(\"..benjamineckstein.(**)\").should().notDependOnEachOther().check(SHOWCASECLASSES);\n    }\n\n    @Test\n    void freeOfCycles3() {\n        // then check those slices for not having any dependencies on each other\n        SlicesRuleDefinition.slices().matching(\"..benjamineckstein.(**).service..\").should().notDependOnEachOther().check(SHOWCASECLASSES);\n    }\n\n    private Architectures.LayeredArchitecture getLayeredArchitectur() {\n        return layeredArchitecture().layer(\"Controller\").definedBy(\"..controller..\").layer(\"Boundary\").definedBy(\"..boundary..\").layer(\"Entity\").definedBy(\"..entity..\").layer(\"Repository\").definedBy(\"..repository..\");\n    }\n}\n", "refactored": false}
{"hexsha": "f7522f424ae92b2a0db7550cedd1e41327b08448", "ext": "java", "lang": "Java", "content": "public class Pokemon {\n\n    //atributos\n    private String nome;\n\n    private String tipo;\n\n    //n?o esquecer de colocar o f (0.5f, 14.6f)\n    private float peso;\n\n    private float altura;\n\n    private int felicidade;\n\n    private int chanceDeCaptura;\n\n    private boolean capturado;\n\n    //metodo status atual\n    public void statusAtual() {\n        System.out.println(\"------------------------\");\n        System.out.println(\"Nome: \" + this.getNome());\n        System.out.println(\"Tipo: \" + this.getTipo());\n        System.out.println(\"Peso \" + this.getPeso());\n        System.out.println(\"Altura: \" + this.getAltura());\n        System.out.println(\"Felicidade: \" + this.getFelicidade());\n        System.out.println(\"Chance de captura: \" + this.getChanceDeCaptura());\n        System.out.println(\"Foi capturado? \" + this.isCapturado());\n        System.out.println();\n    }\n\n    //contruct\n    public Pokemon() {\n        this.setCapturado(false);\n        this.setFelicidade(0);\n    }\n\n    //metodos personalizados\n    public void capturar() {\n        Random random = new Random();\n        int aleatorio = random.nextInt(100);\n        if (this.isCapturado()) {\n            System.out.println(this.nome + \" j? foi capturado\");\n        } else {\n            if (this.chanceDeCaptura <= aleatorio) {\n                System.out.println(\"Foi capturado\");\n                System.out.println(aleatorio);\n                this.setCapturado(true);\n            } else {\n                System.out.println(\"N?o foi capturado\");\n                System.out.println(aleatorio);\n            }\n        }\n    }\n\n    public void libertar() {\n        if (this.isCapturado()) {\n            this.setCapturado(false);\n            System.out.println(this.getNome() + \" foi libertado\");\n        } else {\n            System.out.println(\"N?o h? como libertar, pois n foi capturado\");\n        }\n    }\n\n    public void brincar() {\n        this.setFelicidade(getFelicidade() + 20);\n    }\n\n    public void alimentar() {\n        this.setFelicidade(getFelicidade() + 35);\n    }\n\n    public void falar() {\n        System.out.println(\"Ol?, sou o \" + this.getNome());\n    }\n\n    public void evoluir(String nome, String tipo, int captura) {\n        if (this.getFelicidade() > 100) {\n            System.out.println(\"Pokemon evolu?do com sucesso\");\n            this.setFelicidade(getFelicidade() - 100);\n            this.setNome(nome);\n            this.setTipo(tipo);\n            this.setChanceDeCaptura(captura);\n        } else {\n            System.out.printf(\"Sua felicidade ? de %d, espere chegar at? 100\\n\", this.getFelicidade());\n        }\n    }\n\n    //metodos especiais\n    public String getNome() {\n        return nome;\n    }\n\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n\n    public String getTipo() {\n        return tipo;\n    }\n\n    public void setTipo(String tipo) {\n        this.tipo = tipo;\n    }\n\n    public float getPeso() {\n        return peso;\n    }\n\n    public void setPeso(float peso) {\n        this.peso = peso;\n    }\n\n    public float getAltura() {\n        return altura;\n    }\n\n    public void setAltura(float altura) {\n        this.altura = altura;\n    }\n\n    public int getFelicidade() {\n        return felicidade;\n    }\n\n    public void setFelicidade(int felicidade) {\n        this.felicidade = felicidade;\n    }\n\n    public float getChanceDeCaptura() {\n        return chanceDeCaptura;\n    }\n\n    public void setChanceDeCaptura(int chanceDeCaptura) {\n        this.chanceDeCaptura = chanceDeCaptura;\n    }\n\n    public boolean isCapturado() {\n        return capturado;\n    }\n\n    public void setCapturado(boolean capturado) {\n        this.capturado = capturado;\n    }\n}\n", "class_id": 0, "repo": "marianamtd/Java", "file": "unirio/src/dojo/Dojo2/Pokemon.java", "last_update_at": "2021-09-22T13:27:57+00:00", "original_content": "public class Pokemon {\n\n    //atributos\n    private String nome;\n\n    private String tipo;\n\n    //n?o esquecer de colocar o f (0.5f, 14.6f)\n    private float peso;\n\n    private float altura;\n\n    private int felicidade;\n\n    private int chanceDeCaptura;\n\n    private boolean capturado;\n\n    //metodo status atual\n    public void statusAtual() {\n        System.out.println(\"------------------------\");\n        System.out.println(\"Nome: \" + this.getNome());\n        System.out.println(\"Tipo: \" + this.getTipo());\n        System.out.println(\"Peso \" + this.getPeso());\n        System.out.println(\"Altura: \" + this.getAltura());\n        System.out.println(\"Felicidade: \" + this.getFelicidade());\n        System.out.println(\"Chance de captura: \" + this.getChanceDeCaptura());\n        System.out.println(\"Foi capturado? \" + this.isCapturado());\n        System.out.println();\n    }\n\n    //contruct\n    public Pokemon() {\n        this.setCapturado(false);\n        this.setFelicidade(0);\n    }\n\n    //metodos personalizados\n    public void capturar() {\n        Random random = new Random();\n        int aleatorio = random.nextInt(100);\n        if (this.isCapturado()) {\n            System.out.println(this.nome + \" j? foi capturado\");\n        } else {\n            if (this.chanceDeCaptura <= aleatorio) {\n                System.out.println(\"Foi capturado\");\n                System.out.println(aleatorio);\n                this.setCapturado(true);\n            } else {\n                System.out.println(\"N?o foi capturado\");\n                System.out.println(aleatorio);\n            }\n        }\n    }\n\n    public void libertar() {\n        if (this.isCapturado()) {\n            this.setCapturado(false);\n            System.out.println(this.getNome() + \" foi libertado\");\n        } else {\n            System.out.println(\"N?o h? como libertar, pois n foi capturado\");\n        }\n    }\n\n    public void brincar() {\n        this.setFelicidade(getFelicidade() + 20);\n    }\n\n    public void alimentar() {\n        this.setFelicidade(getFelicidade() + 35);\n    }\n\n    public void falar() {\n        System.out.println(\"Ol?, sou o \" + this.getNome());\n    }\n\n    public void evoluir(String nome, String tipo, int captura) {\n        if (this.getFelicidade() > 100) {\n            System.out.println(\"Pokemon evolu?do com sucesso\");\n            this.setFelicidade(getFelicidade() - 100);\n            this.setNome(nome);\n            this.setTipo(tipo);\n            this.setChanceDeCaptura(captura);\n        } else {\n            System.out.printf(\"Sua felicidade ? de %d, espere chegar at? 100\\n\", this.getFelicidade());\n        }\n    }\n\n    //metodos especiais\n    public String getNome() {\n        return nome;\n    }\n\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n\n    public String getTipo() {\n        return tipo;\n    }\n\n    public void setTipo(String tipo) {\n        this.tipo = tipo;\n    }\n\n    public float getPeso() {\n        return peso;\n    }\n\n    public void setPeso(float peso) {\n        this.peso = peso;\n    }\n\n    public float getAltura() {\n        return altura;\n    }\n\n    public void setAltura(float altura) {\n        this.altura = altura;\n    }\n\n    public int getFelicidade() {\n        return felicidade;\n    }\n\n    public void setFelicidade(int felicidade) {\n        this.felicidade = felicidade;\n    }\n\n    public float getChanceDeCaptura() {\n        return chanceDeCaptura;\n    }\n\n    public void setChanceDeCaptura(int chanceDeCaptura) {\n        this.chanceDeCaptura = chanceDeCaptura;\n    }\n\n    public boolean isCapturado() {\n        return capturado;\n    }\n\n    public void setCapturado(boolean capturado) {\n        this.capturado = capturado;\n    }\n}\n", "refactored": false}
{"hexsha": "640175d1e067155b22c70f2b34c608f3002f0f9f", "ext": "java", "lang": "Java", "content": "public class ByteSizeUnitTests extends ElasticsearchTestCase {\n\n    @Test\n    public void testBytes() {\n        assertThat(BYTES.toBytes(1), equalTo(1l));\n        assertThat(BYTES.toKB(1024), equalTo(1l));\n        assertThat(BYTES.toMB(1024 * 1024), equalTo(1l));\n        assertThat(BYTES.toGB(1024 * 1024 * 1024), equalTo(1l));\n    }\n\n    @Test\n    public void testKB() {\n        assertThat(KB.toBytes(1), equalTo(1024l));\n        assertThat(KB.toKB(1), equalTo(1l));\n        assertThat(KB.toMB(1024), equalTo(1l));\n        assertThat(KB.toGB(1024 * 1024), equalTo(1l));\n    }\n\n    @Test\n    public void testMB() {\n        assertThat(MB.toBytes(1), equalTo(1024l * 1024));\n        assertThat(MB.toKB(1), equalTo(1024l));\n        assertThat(MB.toMB(1), equalTo(1l));\n        assertThat(MB.toGB(1024), equalTo(1l));\n    }\n\n    @Test\n    public void testGB() {\n        assertThat(GB.toBytes(1), equalTo(1024l * 1024 * 1024));\n        assertThat(GB.toKB(1), equalTo(1024l * 1024));\n        assertThat(GB.toMB(1), equalTo(1024l));\n        assertThat(GB.toGB(1), equalTo(1l));\n    }\n}\n", "class_id": 0, "repo": "liatrio/elasticsearch", "file": "src/test/java/org/elasticsearch/common/unit/ByteSizeUnitTests.java", "last_update_at": "2021-02-21T21:58:27+00:00", "original_content": "public class ByteSizeUnitTests extends ElasticsearchTestCase {\n\n    @Test\n    public void testBytes() {\n        assertThat(BYTES.toBytes(1), equalTo(1l));\n        assertThat(BYTES.toKB(1024), equalTo(1l));\n        assertThat(BYTES.toMB(1024 * 1024), equalTo(1l));\n        assertThat(BYTES.toGB(1024 * 1024 * 1024), equalTo(1l));\n    }\n\n    @Test\n    public void testKB() {\n        assertThat(KB.toBytes(1), equalTo(1024l));\n        assertThat(KB.toKB(1), equalTo(1l));\n        assertThat(KB.toMB(1024), equalTo(1l));\n        assertThat(KB.toGB(1024 * 1024), equalTo(1l));\n    }\n\n    @Test\n    public void testMB() {\n        assertThat(MB.toBytes(1), equalTo(1024l * 1024));\n        assertThat(MB.toKB(1), equalTo(1024l));\n        assertThat(MB.toMB(1), equalTo(1l));\n        assertThat(MB.toGB(1024), equalTo(1l));\n    }\n\n    @Test\n    public void testGB() {\n        assertThat(GB.toBytes(1), equalTo(1024l * 1024 * 1024));\n        assertThat(GB.toKB(1), equalTo(1024l * 1024));\n        assertThat(GB.toMB(1), equalTo(1024l));\n        assertThat(GB.toGB(1), equalTo(1l));\n    }\n}\n", "refactored": false}
{"hexsha": "0194d4049752064a887d1e9fe16575075c992aa7", "ext": "java", "lang": "Java", "content": "public final class SpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {\n\n    public SpscLinkedAtomicQueue() {\n        LinkedQueueNode<E> node = new LinkedQueueNode();\n        spProducerNode(node);\n        spConsumerNode(node);\n        node.soNext(null);\n    }\n\n    public boolean offer(E nextValue) {\n        if (nextValue == null) {\n            throw new NullPointerException(\"null elements not allowed\");\n        }\n        LinkedQueueNode<E> nextNode = new LinkedQueueNode(nextValue);\n        lpProducerNode().soNext(nextNode);\n        spProducerNode(nextNode);\n        return true;\n    }\n\n    public E poll() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode == null) {\n            return null;\n        }\n        E nextValue = nextNode.getAndNullValue();\n        spConsumerNode(nextNode);\n        return nextValue;\n    }\n\n    public E peek() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }\n}\n", "class_id": 0, "repo": "JackChan1999/boohee_v5.6", "file": "src/main/java/rx/internal/util/atomic/SpscLinkedAtomicQueue.java", "last_update_at": "2021-04-22T12:22:39+00:00", "original_content": "public final class SpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {\n\n    public SpscLinkedAtomicQueue() {\n        LinkedQueueNode<E> node = new LinkedQueueNode();\n        spProducerNode(node);\n        spConsumerNode(node);\n        node.soNext(null);\n    }\n\n    public boolean offer(E nextValue) {\n        if (nextValue == null) {\n            throw new NullPointerException(\"null elements not allowed\");\n        }\n        LinkedQueueNode<E> nextNode = new LinkedQueueNode(nextValue);\n        lpProducerNode().soNext(nextNode);\n        spProducerNode(nextNode);\n        return true;\n    }\n\n    public E poll() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode == null) {\n            return null;\n        }\n        E nextValue = nextNode.getAndNullValue();\n        spConsumerNode(nextNode);\n        return nextValue;\n    }\n\n    public E peek() {\n        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();\n        if (nextNode != null) {\n            return nextNode.lpValue();\n        }\n        return null;\n    }\n}\n", "refactored": false}
{"hexsha": "df24fff179af2f6b34da1640e8cdc9a0ebf2b74e", "ext": "java", "lang": "Java", "content": "public class GenericFontMapper implements org.jpedal.render.output.FontMapper {\n\n    private static final String DEFAULT_FONT = \"DEFAULT_FONT\";\n\n    //weight\n    String style = \"normal\";\n\n    String weight = \"normal\";\n\n    String family;\n\n    private String fontID;\n\n    private int fontMode = DEFAULT_ON_UNMAPPED;\n\n    private boolean isFontEmbedded;\n\n    private boolean isFontSubstituted;\n\n    //list of font mappings to substitute fonts\n    public static final Map<String, String> fontMappings = new HashMap<String, String>();\n\n    public static final Map<String, Integer> fontSizeAdjustments = new HashMap<String, Integer>();\n\n    private static final Map<String, String> fontStyle = new HashMap<String, String>();\n\n    private static final Map<String, String> fontWeight = new HashMap<String, String>();\n\n    //original name in PDF\n    private String rawFont;\n\n    //setup font substitutions once\n    static {\n        //Mappings reference: http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html\n        final String arialType = \"Arial, Helvetica, sans-serif\";\n        final String arialBlackType = \"'Arial Black', Gadget, sans-serif\";\n        final String comicSansType = \"'Comic Sans MS', Textile, cursive\";\n        final String courierNewType = \"'Courier New', Courier, monospace\";\n        final String georgiaType = \"Georgia, 'Times New Roman', Times, serif\";\n        final String impactType = \"Impact, Charcoal, sans-serif\";\n        final String lucidaConsoleType = \"'Lucida Console', Monaco, monospace\";\n        final String lucidaSansType = \"'Lucida Sans Unicode', 'Lucida Grande', sans-serif\";\n        final String palatinoType = \"'Palatino Linotype', 'Book Antiqua', Palatino, serif\";\n        final String tahomaType = \"Tahoma, Geneva, sans-serif\";\n        final String romanType = \"'Times New Roman', Times, serif\";\n        final String trebuchetType = \"'Trebuchet MS', Helvetica, sans-serif\";\n        final String verdanaType = \"Verdana, Geneva, sans-serif\";\n        final String symbolType = \"Symbol\";\n        final String webdingsType = \"Webdings\";\n        final String wingdingsType = \"Wingdings, 'Zapf Dingbats'\";\n        final String msSansSerifType = \"'MS Sans Serif', Geneva, sans-serif\";\n        final String msSerifType = \"'MS Serif', 'New York', serif\";\n        final String helveticaType = \"Helvetica, Arial, sans-serif\";\n        if (fontMappings.keySet().isEmpty()) {\n            //Default fonts\n            fontMappings.put(\"Arial\", arialType);\n            fontMappings.put(\"ArialMT\", arialType);\n            fontMappings.put(\"ArialBlack\", arialBlackType);\n            fontMappings.put(\"ComicSansMS\", comicSansType);\n            fontMappings.put(\"CourierNew\", courierNewType);\n            fontMappings.put(\"Georgia\", georgiaType);\n            fontMappings.put(\"Impact\", impactType);\n            fontMappings.put(\"LucidaConsole\", lucidaConsoleType);\n            fontMappings.put(\"LucidaSansUnicode\", lucidaSansType);\n            fontMappings.put(\"PalatinoLinotype\", palatinoType);\n            fontMappings.put(\"Tahoma\", tahomaType);\n            fontMappings.put(\"TimesNewRoman\", romanType);\n            fontMappings.put(\"Times\", romanType);\n            fontMappings.put(\"Trebuchet\", trebuchetType);\n            fontMappings.put(\"Verdana\", verdanaType);\n            fontMappings.put(\"Symbol\", symbolType);\n            fontMappings.put(\"Webdings\", webdingsType);\n            fontMappings.put(\"Wingdings\", wingdingsType);\n            fontMappings.put(\"MSSansSerif\", msSansSerifType);\n            fontMappings.put(\"MSSerif\", msSerifType);\n            fontMappings.put(\"Helvetica\", helveticaType);\n            fontMappings.put(\"ZapfDingbats\", wingdingsType);\n            fontMappings.put(DEFAULT_FONT, romanType);\n            //Err on the side of caution for default fonts.\n            fontSizeAdjustments.put(DEFAULT_FONT, -1);\n        }\n    }\n\n    public GenericFontMapper(final String rawFont) {\n        init(rawFont);\n        this.rawFont = rawFont;\n    }\n\n    public GenericFontMapper(final String rawFont, final int fontMode, final boolean isFontEmbedded, final boolean isFontSubstituted) {\n        this.fontMode = fontMode;\n        this.isFontEmbedded = isFontEmbedded;\n        this.isFontSubstituted = isFontSubstituted;\n        this.rawFont = rawFont;\n        init(rawFont);\n    }\n\n    private void init(final String rawFont) {\n        if (fontMode == EMBED_ALL || fontMode == EMBED_ALL_EXCEPT_BASE_FAMILIES) {\n            fontID = rawFont;\n            //limit to nonn-emebedded of Standard (ie TNR, Arial)\n            if (!isFontEmbedded || StandardFonts.isStandardFont(rawFont, true)) {\n                int ptr = rawFont.indexOf(',');\n                if (ptr == -1) {\n                    ptr = rawFont.indexOf('-');\n                }\n                if (ptr == -1) {\n                    int i = (rawFont.length() - 1);\n                    while (i >= 0) try {\n                        final int pt = rawFont.codePointAt(i);\n                        if (pt >= 0x30 && pt <= 0x39) {\n                            if (i < (rawFont.length() - 1)) {\n                                ptr = i - 1;\n                            }\n                            break;\n                        }\n                    } finally {\n                        i--;\n                    }\n                }\n                if (ptr > 0) {\n                    findAttributes(rawFont);\n                }\n            }\n        } else if (!directMapFont(rawFont)) {\n            final String fontLessAttributes = findAttributes(rawFont);\n            //Does the font name minus attributes exist in mappings?\n            if (!mapFont(fontLessAttributes)) {\n                //If there isnt a similiar one use the default.\n                if (!hasSimiliarMapping(fontLessAttributes)) {\n                    switch(this.fontMode) {\n                        case DEFAULT_ON_UNMAPPED:\n                            fontID = DEFAULT_FONT;\n                            break;\n                        case FontMapper.FAIL_ON_UNMAPPED:\n                            throw new RuntimeException(\"Font \" + rawFont + \" not mapped\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Strip out and set font attributes returning the font name\n     * @param rawFont\n     * @return String contains the name of the font\n     */\n    private String findAttributes(final String rawFont) {\n        String result = rawFont;\n        int ptr = rawFont.indexOf(',');\n        if (ptr == -1) {\n            ptr = rawFont.indexOf('-');\n        }\n        if (ptr == -1) {\n            ptr = rawFont.lastIndexOf(' ');\n        }\n        if (ptr == -1) {\n            int i = (rawFont.length() - 1);\n            while (i >= 0) try {\n                final int pt = rawFont.codePointAt(i);\n                if (pt >= 0x30 && pt <= 0x39) {\n                    if (i < (rawFont.length() - 1)) {\n                        ptr = i - 1;\n                    }\n                    break;\n                }\n            } finally {\n                i--;\n            }\n        }\n        if (ptr != -1) {\n            final String fontAttributes = rawFont.substring(ptr + 1, rawFont.length()).toLowerCase();\n            result = rawFont.substring(0, ptr);\n            //font less any -, or number\n            family = result;\n            boolean isFontExists = false;\n            for (final String k : fontMappings.keySet()) {\n                if (k.startsWith(family)) {\n                    isFontExists = true;\n                }\n            }\n            if (isFontExists || !isFontEmbedded) {\n                if (fontAttributes.contains(\"heavy\")) {\n                    weight = \"900\";\n                } else if (fontAttributes.endsWith(\"black\")) {\n                    weight = \"bolder\";\n                } else if (fontAttributes.contains(\"light\")) {\n                    weight = \"lighter\";\n                } else if (fontAttributes.contains(\"condensed\")) {\n                    weight = \"100\";\n                } else if (fontAttributes.contains(\"bold\")) {\n                    weight = \"bold\";\n                }\n                /**\n                 * and style\n                 */\n                if (fontAttributes.equals(\"it\") || fontAttributes.contains(\"italic\") || fontAttributes.contains(\"kursiv\") || fontAttributes.contains(\"oblique\")) {\n                    style = \"italic\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * See if font is in mappings and set the font ID.  Return false if its not.\n     * @param s String to check\n     * @return true if it maps\n     */\n    private boolean mapFont(final String s) {\n        if (fontMappings.get(s) != null) {\n            fontID = s;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find out if there is a direct mapping to the given font\n     */\n    private boolean directMapFont(final String s) {\n        final boolean result = mapFont(s);\n        if (!result) {\n            return false;\n        }\n        if (fontStyle.containsKey(s)) {\n            style = fontStyle.get(s);\n        }\n        if (fontWeight.containsKey(s)) {\n            weight = fontWeight.get(s);\n        }\n        return true;\n    }\n\n    /**\n     * Search mappings for a one that sounds close.\n     * @param fontName\n     * @return\n     */\n    private boolean hasSimiliarMapping(final String fontName) {\n        final Set<String> keySet = fontMappings.keySet();\n        final Set<String> candidates = new HashSet<String>();\n        for (final String key : keySet) {\n            final String lcKey = key.toLowerCase();\n            final String lcFont = fontName.toLowerCase();\n            if (lcKey.equals(lcFont)) {\n                fontID = key;\n                return true;\n            }\n            if (lcKey.contains(lcFont) || lcFont.contains(lcKey)) {\n                candidates.add(key);\n            }\n        }\n        if (!candidates.isEmpty()) {\n            String[] result = new String[candidates.size()];\n            result = candidates.toArray(result);\n            fontID = result[0];\n            //@TODO Just get the shortest one for the time being.\n            if (candidates.size() > 1) {\n                int i = 1;\n                while (i < result.length) try {\n                    if (result[i].length() < fontID.length()) {\n                        fontID = result[i];\n                    }\n                } finally {\n                    i++;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public String getFont() {\n        String result = fontMappings.get(fontID);\n        if (result == null && family != null && !isFontEmbedded) {\n            result = fontMappings.get(family);\n        }\n        if (result == null && (fontMode == EMBED_ALL || fontMode == EMBED_ALL_EXCEPT_BASE_FAMILIES)) {\n            //just pass through\n            rawFont = rawFont.replaceAll(\"[.,@*#]\", \"-\");\n            result = rawFont;\n        } else if (result != null && isFontEmbedded && fontMode == EMBED_ALL) {\n            //  System.out.println(fontID+\" \"+result);\n            result = fontID;\n        }\n        return (result == null) ? \"\" : result;\n    }\n\n    @Override\n    public String getStyle() {\n        if (isFontEmbedded) {\n            style = \"normal\";\n        }\n        return style;\n    }\n\n    @Override\n    public String getWeight() {\n        if (isFontEmbedded) {\n            weight = \"normal\";\n        }\n        return weight;\n    }\n\n    @Override\n    public boolean isFontEmbedded() {\n        return isFontEmbedded;\n    }\n\n    @Override\n    public boolean isFontSubstituted() {\n        return isFontSubstituted;\n    }\n\n    @Override\n    public boolean equals(FontMapper fontMapper) {\n        return this.getStyle().equals(fontMapper.getStyle()) && this.getFont().equals(fontMapper.getFont()) && this.getWeight().equals(fontMapper.getWeight()) && this.isFontEmbedded() == fontMapper.isFontEmbedded();\n    }\n}\n", "class_id": 0, "repo": "UprootStaging/maven-OpenViewerFX-src", "file": "OpenViewerFX/src/main/java/org/jpedal/render/output/GenericFontMapper.java", "last_update_at": "2021-09-03T08:51:14+00:00", "original_content": "public class GenericFontMapper implements org.jpedal.render.output.FontMapper {\n\n    private static final String DEFAULT_FONT = \"DEFAULT_FONT\";\n\n    //weight\n    String style = \"normal\";\n\n    String weight = \"normal\";\n\n    String family;\n\n    private String fontID;\n\n    private int fontMode = DEFAULT_ON_UNMAPPED;\n\n    private boolean isFontEmbedded;\n\n    private boolean isFontSubstituted;\n\n    //list of font mappings to substitute fonts\n    public static final Map<String, String> fontMappings = new HashMap<String, String>();\n\n    public static final Map<String, Integer> fontSizeAdjustments = new HashMap<String, Integer>();\n\n    private static final Map<String, String> fontStyle = new HashMap<String, String>();\n\n    private static final Map<String, String> fontWeight = new HashMap<String, String>();\n\n    //original name in PDF\n    private String rawFont;\n\n    //setup font substitutions once\n    static {\n        //Mappings reference: http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html\n        final String arialType = \"Arial, Helvetica, sans-serif\";\n        final String arialBlackType = \"'Arial Black', Gadget, sans-serif\";\n        final String comicSansType = \"'Comic Sans MS', Textile, cursive\";\n        final String courierNewType = \"'Courier New', Courier, monospace\";\n        final String georgiaType = \"Georgia, 'Times New Roman', Times, serif\";\n        final String impactType = \"Impact, Charcoal, sans-serif\";\n        final String lucidaConsoleType = \"'Lucida Console', Monaco, monospace\";\n        final String lucidaSansType = \"'Lucida Sans Unicode', 'Lucida Grande', sans-serif\";\n        final String palatinoType = \"'Palatino Linotype', 'Book Antiqua', Palatino, serif\";\n        final String tahomaType = \"Tahoma, Geneva, sans-serif\";\n        final String romanType = \"'Times New Roman', Times, serif\";\n        final String trebuchetType = \"'Trebuchet MS', Helvetica, sans-serif\";\n        final String verdanaType = \"Verdana, Geneva, sans-serif\";\n        final String symbolType = \"Symbol\";\n        final String webdingsType = \"Webdings\";\n        final String wingdingsType = \"Wingdings, 'Zapf Dingbats'\";\n        final String msSansSerifType = \"'MS Sans Serif', Geneva, sans-serif\";\n        final String msSerifType = \"'MS Serif', 'New York', serif\";\n        final String helveticaType = \"Helvetica, Arial, sans-serif\";\n        if (fontMappings.keySet().isEmpty()) {\n            //Default fonts\n            fontMappings.put(\"Arial\", arialType);\n            fontMappings.put(\"ArialMT\", arialType);\n            fontMappings.put(\"ArialBlack\", arialBlackType);\n            fontMappings.put(\"ComicSansMS\", comicSansType);\n            fontMappings.put(\"CourierNew\", courierNewType);\n            fontMappings.put(\"Georgia\", georgiaType);\n            fontMappings.put(\"Impact\", impactType);\n            fontMappings.put(\"LucidaConsole\", lucidaConsoleType);\n            fontMappings.put(\"LucidaSansUnicode\", lucidaSansType);\n            fontMappings.put(\"PalatinoLinotype\", palatinoType);\n            fontMappings.put(\"Tahoma\", tahomaType);\n            fontMappings.put(\"TimesNewRoman\", romanType);\n            fontMappings.put(\"Times\", romanType);\n            fontMappings.put(\"Trebuchet\", trebuchetType);\n            fontMappings.put(\"Verdana\", verdanaType);\n            fontMappings.put(\"Symbol\", symbolType);\n            fontMappings.put(\"Webdings\", webdingsType);\n            fontMappings.put(\"Wingdings\", wingdingsType);\n            fontMappings.put(\"MSSansSerif\", msSansSerifType);\n            fontMappings.put(\"MSSerif\", msSerifType);\n            fontMappings.put(\"Helvetica\", helveticaType);\n            fontMappings.put(\"ZapfDingbats\", wingdingsType);\n            fontMappings.put(DEFAULT_FONT, romanType);\n            //Err on the side of caution for default fonts.\n            fontSizeAdjustments.put(DEFAULT_FONT, -1);\n        }\n    }\n\n    public GenericFontMapper(final String rawFont) {\n        init(rawFont);\n        this.rawFont = rawFont;\n    }\n\n    public GenericFontMapper(final String rawFont, final int fontMode, final boolean isFontEmbedded, final boolean isFontSubstituted) {\n        this.fontMode = fontMode;\n        this.isFontEmbedded = isFontEmbedded;\n        this.isFontSubstituted = isFontSubstituted;\n        this.rawFont = rawFont;\n        init(rawFont);\n    }\n\n    private void init(final String rawFont) {\n        if (fontMode == EMBED_ALL || fontMode == EMBED_ALL_EXCEPT_BASE_FAMILIES) {\n            fontID = rawFont;\n            //limit to nonn-emebedded of Standard (ie TNR, Arial)\n            if (!isFontEmbedded || StandardFonts.isStandardFont(rawFont, true)) {\n                int ptr = rawFont.indexOf(',');\n                if (ptr == -1) {\n                    ptr = rawFont.indexOf('-');\n                }\n                if (ptr == -1) {\n                    //Split at the last number\n                    for (int i = (rawFont.length() - 1); i >= 0; i--) {\n                        final int pt = rawFont.codePointAt(i);\n                        if (pt >= 0x30 && pt <= 0x39) {\n                            if (i < (rawFont.length() - 1)) {\n                                ptr = i - 1;\n                            }\n                            break;\n                        }\n                    }\n                }\n                if (ptr > 0) {\n                    findAttributes(rawFont);\n                }\n            }\n        } else if (!directMapFont(rawFont)) {\n            final String fontLessAttributes = findAttributes(rawFont);\n            //Does the font name minus attributes exist in mappings?\n            if (!mapFont(fontLessAttributes)) {\n                //If there isnt a similiar one use the default.\n                if (!hasSimiliarMapping(fontLessAttributes)) {\n                    switch(this.fontMode) {\n                        case DEFAULT_ON_UNMAPPED:\n                            fontID = DEFAULT_FONT;\n                            break;\n                        case FontMapper.FAIL_ON_UNMAPPED:\n                            throw new RuntimeException(\"Font \" + rawFont + \" not mapped\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Strip out and set font attributes returning the font name\n     * @param rawFont\n     * @return String contains the name of the font\n     */\n    private String findAttributes(final String rawFont) {\n        String result = rawFont;\n        int ptr = rawFont.indexOf(',');\n        if (ptr == -1) {\n            ptr = rawFont.indexOf('-');\n        }\n        if (ptr == -1) {\n            ptr = rawFont.lastIndexOf(' ');\n        }\n        if (ptr == -1) {\n            //Split at the last number\n            for (int i = (rawFont.length() - 1); i >= 0; i--) {\n                final int pt = rawFont.codePointAt(i);\n                if (pt >= 0x30 && pt <= 0x39) {\n                    if (i < (rawFont.length() - 1)) {\n                        ptr = i - 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if (ptr != -1) {\n            final String fontAttributes = rawFont.substring(ptr + 1, rawFont.length()).toLowerCase();\n            result = rawFont.substring(0, ptr);\n            //font less any -, or number\n            family = result;\n            boolean isFontExists = false;\n            for (final String k : fontMappings.keySet()) {\n                if (k.startsWith(family)) {\n                    isFontExists = true;\n                }\n            }\n            if (isFontExists || !isFontEmbedded) {\n                if (fontAttributes.contains(\"heavy\")) {\n                    weight = \"900\";\n                } else if (fontAttributes.endsWith(\"black\")) {\n                    weight = \"bolder\";\n                } else if (fontAttributes.contains(\"light\")) {\n                    weight = \"lighter\";\n                } else if (fontAttributes.contains(\"condensed\")) {\n                    weight = \"100\";\n                } else if (fontAttributes.contains(\"bold\")) {\n                    weight = \"bold\";\n                }\n                /**\n                 * and style\n                 */\n                if (fontAttributes.equals(\"it\") || fontAttributes.contains(\"italic\") || fontAttributes.contains(\"kursiv\") || fontAttributes.contains(\"oblique\")) {\n                    style = \"italic\";\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * See if font is in mappings and set the font ID.  Return false if its not.\n     * @param s String to check\n     * @return true if it maps\n     */\n    private boolean mapFont(final String s) {\n        if (fontMappings.get(s) != null) {\n            fontID = s;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find out if there is a direct mapping to the given font\n     */\n    private boolean directMapFont(final String s) {\n        final boolean result = mapFont(s);\n        if (!result) {\n            return false;\n        }\n        if (fontStyle.containsKey(s)) {\n            style = fontStyle.get(s);\n        }\n        if (fontWeight.containsKey(s)) {\n            weight = fontWeight.get(s);\n        }\n        return true;\n    }\n\n    /**\n     * Search mappings for a one that sounds close.\n     * @param fontName\n     * @return\n     */\n    private boolean hasSimiliarMapping(final String fontName) {\n        final Set<String> keySet = fontMappings.keySet();\n        final Set<String> candidates = new HashSet<String>();\n        for (final String key : keySet) {\n            final String lcKey = key.toLowerCase();\n            final String lcFont = fontName.toLowerCase();\n            if (lcKey.equals(lcFont)) {\n                fontID = key;\n                return true;\n            }\n            if (lcKey.contains(lcFont) || lcFont.contains(lcKey)) {\n                candidates.add(key);\n            }\n        }\n        if (!candidates.isEmpty()) {\n            String[] result = new String[candidates.size()];\n            result = candidates.toArray(result);\n            fontID = result[0];\n            //@TODO Just get the shortest one for the time being.\n            if (candidates.size() > 1) {\n                for (int i = 1; i < result.length; i++) {\n                    if (result[i].length() < fontID.length()) {\n                        fontID = result[i];\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public String getFont() {\n        String result = fontMappings.get(fontID);\n        if (result == null && family != null && !isFontEmbedded) {\n            result = fontMappings.get(family);\n        }\n        if (result == null && (fontMode == EMBED_ALL || fontMode == EMBED_ALL_EXCEPT_BASE_FAMILIES)) {\n            //just pass through\n            rawFont = rawFont.replaceAll(\"[.,@*#]\", \"-\");\n            result = rawFont;\n        } else if (result != null && isFontEmbedded && fontMode == EMBED_ALL) {\n            //  System.out.println(fontID+\" \"+result);\n            result = fontID;\n        }\n        return (result == null) ? \"\" : result;\n    }\n\n    @Override\n    public String getStyle() {\n        if (isFontEmbedded) {\n            style = \"normal\";\n        }\n        return style;\n    }\n\n    @Override\n    public String getWeight() {\n        if (isFontEmbedded) {\n            weight = \"normal\";\n        }\n        return weight;\n    }\n\n    @Override\n    public boolean isFontEmbedded() {\n        return isFontEmbedded;\n    }\n\n    @Override\n    public boolean isFontSubstituted() {\n        return isFontSubstituted;\n    }\n\n    @Override\n    public boolean equals(FontMapper fontMapper) {\n        return this.getStyle().equals(fontMapper.getStyle()) && this.getFont().equals(fontMapper.getFont()) && this.getWeight().equals(fontMapper.getWeight()) && this.isFontEmbedded() == fontMapper.isFontEmbedded();\n    }\n}\n", "refactored": true}
{"hexsha": "9cedeea0468199cd3b728e960a264b645131c05c", "ext": "java", "lang": "Java", "content": "final class ExpandedRow {\n\n    private final List<ExpandedPair> pairs;\n\n    private final int rowNumber;\n\n    private final boolean wasReversed;\n\n    ExpandedRow(List<ExpandedPair> list, int i, boolean z) {\n        this.pairs = new ArrayList(list);\n        this.rowNumber = i;\n        this.wasReversed = z;\n    }\n\n    /* access modifiers changed from: package-private */\n    public List<ExpandedPair> getPairs() {\n        return this.pairs;\n    }\n\n    /* access modifiers changed from: package-private */\n    public int getRowNumber() {\n        return this.rowNumber;\n    }\n\n    /* access modifiers changed from: package-private */\n    public boolean isReversed() {\n        return this.wasReversed;\n    }\n\n    /* access modifiers changed from: package-private */\n    public boolean isEquivalent(List<ExpandedPair> list) {\n        return this.pairs.equals(list);\n    }\n\n    public String toString() {\n        return \"{ \" + this.pairs + \" }\";\n    }\n\n    public boolean equals(Object obj) {\n        if (!(obj instanceof ExpandedRow)) {\n            return false;\n        }\n        ExpandedRow expandedRow = (ExpandedRow) obj;\n        if (!this.pairs.equals(expandedRow.getPairs()) || this.wasReversed != expandedRow.wasReversed) {\n            return false;\n        }\n        return true;\n    }\n\n    public int hashCode() {\n        return this.pairs.hashCode() ^ Boolean.valueOf(this.wasReversed).hashCode();\n    }\n}\n", "class_id": 0, "repo": "atul-vyshnav/2021_IBM_Code_Challenge_StockIT", "file": "src/StockIT-v1-release_source_from_JADX/sources/com/google/zxing/oned/rss/expanded/ExpandedRow.java", "last_update_at": "2021-11-23T10:12:35+00:00", "original_content": "final class ExpandedRow {\n\n    private final List<ExpandedPair> pairs;\n\n    private final int rowNumber;\n\n    private final boolean wasReversed;\n\n    ExpandedRow(List<ExpandedPair> list, int i, boolean z) {\n        this.pairs = new ArrayList(list);\n        this.rowNumber = i;\n        this.wasReversed = z;\n    }\n\n    /* access modifiers changed from: package-private */\n    public List<ExpandedPair> getPairs() {\n        return this.pairs;\n    }\n\n    /* access modifiers changed from: package-private */\n    public int getRowNumber() {\n        return this.rowNumber;\n    }\n\n    /* access modifiers changed from: package-private */\n    public boolean isReversed() {\n        return this.wasReversed;\n    }\n\n    /* access modifiers changed from: package-private */\n    public boolean isEquivalent(List<ExpandedPair> list) {\n        return this.pairs.equals(list);\n    }\n\n    public String toString() {\n        return \"{ \" + this.pairs + \" }\";\n    }\n\n    public boolean equals(Object obj) {\n        if (!(obj instanceof ExpandedRow)) {\n            return false;\n        }\n        ExpandedRow expandedRow = (ExpandedRow) obj;\n        if (!this.pairs.equals(expandedRow.getPairs()) || this.wasReversed != expandedRow.wasReversed) {\n            return false;\n        }\n        return true;\n    }\n\n    public int hashCode() {\n        return this.pairs.hashCode() ^ Boolean.valueOf(this.wasReversed).hashCode();\n    }\n}\n", "refactored": false}
{"hexsha": "fb95d0d1f84c992bbf15971afd687b13538188f4", "ext": "java", "lang": "Java", "content": "public abstract class AbstractCrawlerService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AbstractCrawlerService.class);\n\n    private static final String ID_SEPARATOR = \".\";\n\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    protected static final String ID = \"id\";\n\n    protected static final String SESSION_ID = \"sessionId\";\n\n    protected static final String URL = \"url\";\n\n    protected static final String LAST_MODIFIED = \"lastModified\";\n\n    protected static final String CREATE_TIME = \"createTime\";\n\n    protected static final String _DOC = \"_doc\";\n\n    protected static final String[] timestampFields = { LAST_MODIFIED, CREATE_TIME };\n\n    protected static final HashFunction murmur3Hash = Hashing.murmur3_128(0);\n\n    @Resource\n    protected volatile FesenClient fesenClient;\n\n    protected String index;\n\n    protected int scrollTimeout = 60000;\n\n    protected int scrollSize = 100;\n\n    protected int bulkBufferSize = 10;\n\n    protected int numberOfShards = 5;\n\n    protected int numberOfReplicas = 1;\n\n    protected int idPrefixLength = 445;\n\n    protected FesenClient getClient() {\n        if (!fesenClient.connected()) {\n            synchronized (fesenClient) {\n                if (!fesenClient.connected()) {\n                    fesenClient.connect();\n                }\n            }\n        }\n        return fesenClient;\n    }\n\n    protected void createMapping(final String mappingName) {\n        boolean exists = false;\n        try {\n            final IndicesExistsResponse response = fesenClient.get(c -> c.admin().indices().prepareExists(index).execute());\n            exists = response.isExists();\n        } catch (final IndexNotFoundException e) {\n        }\n        if (!exists) {\n            final CreateIndexResponse indexResponse = fesenClient.get(c -> {\n                final String source;\n                if (numberOfReplicas > 0) {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards + \",\\\"number_of_replicas\\\":0,\\\"auto_expand_replicas\\\":\\\"0-\" + numberOfReplicas + \"\\\"}}}\";\n                } else {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards + \",\\\"number_of_replicas\\\":\" + numberOfReplicas + \"}}}\";\n                }\n                return c.admin().indices().prepareCreate(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (indexResponse.isAcknowledged()) {\n                logger.info(\"Created {} index.\", index);\n            } else if (logger.isDebugEnabled()) {\n                logger.debug(\"Failed to create {} index.\", index);\n            }\n        }\n        final GetMappingsResponse getMappingsResponse = fesenClient.get(c -> c.admin().indices().prepareGetMappings(index).execute());\n        final ImmutableOpenMap<String, MappingMetadata> indexMappings = getMappingsResponse.mappings().get(index);\n        if (indexMappings == null || !indexMappings.containsKey(\"properties\")) {\n            final AcknowledgedResponse putMappingResponse = fesenClient.get(c -> {\n                final String source = FileUtil.readText(\"mapping/\" + mappingName + \".json\");\n                return c.admin().indices().preparePutMapping(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (putMappingResponse.isAcknowledged()) {\n                logger.info(\"Created {} mapping.\", index);\n            } else {\n                logger.warn(\"Failed to create {} mapping.\", index);\n            }\n        } else if (logger.isDebugEnabled()) {\n            logger.debug(\"{} mapping exists.\", index);\n        }\n    }\n\n    protected Date getDateFromSource(final Map<String, Object> sourceMap, final String name) {\n        final Object obj = sourceMap.get(name);\n        if (obj instanceof Date) {\n            return (Date) obj;\n        }\n        if (obj instanceof Number) {\n            return new Date(((Number) obj).longValue());\n        }\n        if (obj instanceof String) {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            try {\n                return sdf.parse(obj.toString());\n            } catch (final ParseException e) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to parse {}\", obj, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected XContentBuilder getXContentBuilder(final Object target) {\n        try {\n            final XContentBuilder builder = jsonBuilder().value(target);\n            builder.flush();\n            return builder;\n        } catch (final IOException e) {\n            throw new EsAccessException(\"Failed to convert \" + target + \" to JSON.\", e);\n        }\n    }\n\n    protected RefreshResponse refresh() {\n        try {\n            return getClient().get(c -> c.admin().indices().prepareRefresh(index).execute());\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to refresh.\", e);\n        }\n    }\n\n    protected IndexResponse insert(final Object target, final OpType opType) {\n        final String url = getUrl(target);\n        if (url == null) {\n            throw new EsAccessException(\"url is null.\");\n        }\n        final String id = getId(getSessionId(target), url);\n        try (final XContentBuilder source = getXContentBuilder(target)) {\n            final IndexResponse response = getClient().get(c -> c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            setId(target, id);\n            return response;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + id, e);\n        }\n    }\n\n    protected <T> void insertAll(final List<T> list, final OpType opType) {\n        insertAll(list, opType, false);\n    }\n\n    protected <T> void insertAll(final List<T> list, final OpType opType, final boolean ignoreAlreadyExists) {\n        final List<T> bufferedList = new ArrayList<>(bulkBufferSize);\n        final StringBuilder failureBuf = new StringBuilder(100);\n        list.stream().forEach(target -> {\n            bufferedList.add(target);\n            if (bufferedList.size() >= bulkBufferSize) {\n                final BulkResponse response = doInsertAll(bufferedList, opType);\n                if (response.hasFailures()) {\n                    final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                    if (failureMessage.length() > 0) {\n                        failureBuf.append(response.buildFailureMessage()).append('\\n');\n                    }\n                }\n                bufferedList.clear();\n            }\n        });\n        if (!bufferedList.isEmpty()) {\n            final BulkResponse response = doInsertAll(bufferedList, opType);\n            if (response.hasFailures()) {\n                final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                if (failureMessage.length() > 0) {\n                    failureBuf.append(response.buildFailureMessage()).append('\\n');\n                }\n            }\n        }\n        if (failureBuf.length() > 0) {\n            throw new EsAccessException(failureBuf.toString());\n        }\n    }\n\n    protected String buildFailureMessage(final BulkResponse bulkResponse, final boolean ignoreAlreadyExists) {\n        final StringBuilder sb = new StringBuilder(100);\n        final BulkItemResponse[] responses = bulkResponse.getItems();\n        int i = 0;\n        while (i < responses.length) try {\n            final BulkItemResponse response = responses[i];\n            if (response.isFailed()) {\n                if (ignoreAlreadyExists) {\n                    continue;\n                }\n                sb.append(\"\\n[\").append(i).append(\"]: index [\").append(response.getIndex()).append(\"], type [\").append(response.getType()).append(\"], id [\").append(response.getId()).append(\"], message [\").append(response.getFailureMessage()).append(\"]\");\n            }\n        } finally {\n            i++;\n        }\n        if (sb.length() > 0) {\n            return \"failure in bulk execution:\" + sb.toString();\n        }\n        return StringUtil.EMPTY;\n    }\n\n    protected <T> BulkResponse doInsertAll(final List<T> list, final OpType opType) {\n        try {\n            return getClient().get(c -> {\n                final BulkRequestBuilder bulkRequest = c.prepareBulk();\n                for (final T target : list) {\n                    final String id = getId(getSessionId(target), getUrl(target));\n                    try (final XContentBuilder source = getXContentBuilder(target)) {\n                        bulkRequest.add(c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType));\n                    }\n                    setId(target, id);\n                }\n                return bulkRequest.setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute();\n            });\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + list, e);\n        }\n    }\n\n    protected boolean exists(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final GetResponse response = getClient().get(c -> c.prepareGet(index, null, id).execute());\n            return response.isExists();\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to check if \" + sessionId + \":\" + url + \" exists.\", e);\n        }\n    }\n\n    public int getCount(final Consumer<SearchRequestBuilder> callback) {\n        return (int) getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setSize(0).setTrackTotalHits(true);\n            callback.accept(builder);\n            return builder.execute();\n        }).getHits().getTotalHits().value;\n    }\n\n    protected <T> T get(final Class<T> clazz, final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        final GetResponse response = getClient().get(c -> c.prepareGet().setIndex(index).setId(id).execute());\n        if (response.isExists()) {\n            final Map<String, Object> source = response.getSource();\n            final T bean = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n            });\n            @SuppressWarnings(\"unchecked\")\n            final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n            if (data != null) {\n                ((EsAccessResult) bean).setAccessResultData(new EsAccessResultData(data));\n            }\n            setId(bean, id);\n            return bean;\n        }\n        return null;\n    }\n\n    protected <T> List<T> getList(final Class<T> clazz, final String sessionId, final QueryBuilder queryBuilder, final Integer from, final Integer size, final SortBuilder<?> sortBuilder) {\n        return getList(clazz, builder -> {\n            if (StringUtil.isNotBlank(sessionId)) {\n                if (queryBuilder instanceof BoolQueryBuilder) {\n                    ((BoolQueryBuilder) queryBuilder).filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                } else {\n                    final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                    if (queryBuilder != null) {\n                        boolQuery.must(queryBuilder);\n                    }\n                    builder.setQuery(boolQuery);\n                }\n            } else if (queryBuilder != null) {\n                builder.setQuery(queryBuilder);\n            } else {\n                builder.setQuery(QueryBuilders.matchAllQuery());\n            }\n            if (sortBuilder != null) {\n                builder.addSort(sortBuilder);\n            }\n            if (from != null) {\n                builder.setFrom(from);\n            }\n            if (size != null) {\n                builder.setSize(size);\n            }\n        });\n    }\n\n    protected <T> List<T> getList(final Class<T> clazz, final Consumer<SearchRequestBuilder> callback) {\n        final SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        final EsResultList<T> targetList = new EsResultList<>();\n        final SearchHits hits = response.getHits();\n        targetList.setTotalHits(hits.getTotalHits().value);\n        targetList.setTookInMillis(response.getTook().getMillis());\n        if (hits.getTotalHits().value != 0) {\n            try {\n                for (final SearchHit searchHit : hits.getHits()) {\n                    final Map<String, Object> source = searchHit.getSourceAsMap();\n                    final T target = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                        option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                        option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n                    });\n                    @SuppressWarnings(\"unchecked\")\n                    final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n                    if (data != null) {\n                        ((EsAccessResult) target).setAccessResultData(new EsAccessResultData(data));\n                    }\n                    setId(target, searchHit.getId());\n                    targetList.add(target);\n                }\n            } catch (final Exception e) {\n                throw new EsAccessException(\"response: \" + response, e);\n            }\n        }\n        return targetList;\n    }\n\n    protected boolean delete(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final DeleteResponse response = getClient().get(c -> c.prepareDelete().setIndex(index).setId(id).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            return response.getResult() == Result.DELETED;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to delete \" + sessionId + \":\" + url, e);\n        }\n    }\n\n    protected void deleteBySessionId(final String sessionId) {\n        delete(builder -> builder.setQuery(QueryBuilders.termQuery(SESSION_ID, sessionId)));\n    }\n\n    public void deleteAll() {\n        delete(builder -> builder.setQuery(QueryBuilders.matchAllQuery()));\n    }\n\n    public void delete(final Consumer<SearchRequestBuilder> callback) {\n        SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setScroll(new TimeValue(scrollTimeout)).setSize(scrollSize);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        String scrollId = response.getScrollId();\n        try {\n            while (scrollId != null) {\n                final SearchHits searchHits = response.getHits();\n                if (searchHits.getHits().length == 0) {\n                    break;\n                }\n                final BulkResponse bulkResponse = getClient().get(c -> {\n                    final BulkRequestBuilder bulkBuilder = c.prepareBulk();\n                    for (final SearchHit searchHit : searchHits) {\n                        bulkBuilder.add(c.prepareDelete().setIndex(index).setId(searchHit.getId()));\n                    }\n                    return bulkBuilder.execute();\n                });\n                if (bulkResponse.hasFailures()) {\n                    throw new EsAccessException(bulkResponse.buildFailureMessage());\n                }\n                final String sid = scrollId;\n                response = getClient().get(c -> c.prepareSearchScroll(sid).setScroll(new TimeValue(scrollTimeout)).execute());\n                if (!scrollId.equals(response.getScrollId())) {\n                    getClient().clearScroll(scrollId);\n                }\n                scrollId = response.getScrollId();\n            }\n        } finally {\n            getClient().clearScroll(scrollId);\n        }\n        refresh();\n    }\n\n    private String getId(final String sessionId, final String url) {\n        final String id = sessionId + ID_SEPARATOR + new String(Base64.getUrlEncoder().withoutPadding().encode(url.getBytes(UTF_8)), UTF_8);\n        if (id.length() <= idPrefixLength) {\n            return id;\n        }\n        return id.substring(0, idPrefixLength) + MessageDigestUtil.digest(\"SHA-256\", id.substring(idPrefixLength));\n    }\n\n    private String getUrl(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(URL);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n\n    private String getSessionId(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(SESSION_ID);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n\n    protected void setId(final Object target, final String id) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc idProp = beanDesc.getPropertyDesc(ID);\n        idProp.setValue(target, id);\n    }\n\n    public String getIndex() {\n        return index;\n    }\n\n    public void setIndex(final String index) {\n        this.index = index;\n    }\n\n    public int getScrollTimeout() {\n        return scrollTimeout;\n    }\n\n    public void setScrollTimeout(final int scrollTimeout) {\n        this.scrollTimeout = scrollTimeout;\n    }\n\n    public int getScrollSize() {\n        return scrollSize;\n    }\n\n    public void setScrollSize(final int scrollSize) {\n        this.scrollSize = scrollSize;\n    }\n\n    protected static class EsTimestampConverter implements Converter {\n\n        public static final DateTimeFormatter DEFAULT_DATE_PRINTER = ISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC);\n\n        @Override\n        public String getAsString(final Object value) {\n            if (value instanceof Date) {\n                return DEFAULT_DATE_PRINTER.print(((Date) value).getTime());\n            }\n            return null;\n        }\n\n        @Override\n        public Object getAsObject(final String value) {\n            if (StringUtil.isEmpty(value)) {\n                return null;\n            }\n            return new Timestamp(DEFAULT_DATE_PRINTER.parseMillis(value));\n        }\n\n        @Override\n        public boolean isTarget(@SuppressWarnings(\"rawtypes\") final Class clazz) {\n            return clazz == Date.class;\n        }\n    }\n\n    public int getBulkBufferSize() {\n        return bulkBufferSize;\n    }\n\n    public void setBulkBufferSize(final int bulkBufferSize) {\n        this.bulkBufferSize = bulkBufferSize;\n    }\n\n    public void setNumberOfShards(final int numberOfShards) {\n        this.numberOfShards = numberOfShards;\n    }\n\n    public void setNumberOfReplicas(final int numberOfReplicas) {\n        this.numberOfReplicas = numberOfReplicas;\n    }\n\n    public void setIdPrefixLength(final int idPrefixLength) {\n        this.idPrefixLength = idPrefixLength;\n    }\n}\n", "class_id": 0, "repo": "codelibs/fess-crawler", "file": "fess-crawler-es/src/main/java/org/codelibs/fess/crawler/service/impl/AbstractCrawlerService.java", "last_update_at": "2021-04-08T07:26:05+00:00", "original_content": "public abstract class AbstractCrawlerService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AbstractCrawlerService.class);\n\n    private static final String ID_SEPARATOR = \".\";\n\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    protected static final String ID = \"id\";\n\n    protected static final String SESSION_ID = \"sessionId\";\n\n    protected static final String URL = \"url\";\n\n    protected static final String LAST_MODIFIED = \"lastModified\";\n\n    protected static final String CREATE_TIME = \"createTime\";\n\n    protected static final String _DOC = \"_doc\";\n\n    protected static final String[] timestampFields = { LAST_MODIFIED, CREATE_TIME };\n\n    protected static final HashFunction murmur3Hash = Hashing.murmur3_128(0);\n\n    @Resource\n    protected volatile FesenClient fesenClient;\n\n    protected String index;\n\n    protected int scrollTimeout = 60000;\n\n    protected int scrollSize = 100;\n\n    protected int bulkBufferSize = 10;\n\n    protected int numberOfShards = 5;\n\n    protected int numberOfReplicas = 1;\n\n    protected int idPrefixLength = 445;\n\n    protected FesenClient getClient() {\n        if (!fesenClient.connected()) {\n            synchronized (fesenClient) {\n                if (!fesenClient.connected()) {\n                    fesenClient.connect();\n                }\n            }\n        }\n        return fesenClient;\n    }\n\n    protected void createMapping(final String mappingName) {\n        boolean exists = false;\n        try {\n            final IndicesExistsResponse response = fesenClient.get(c -> c.admin().indices().prepareExists(index).execute());\n            exists = response.isExists();\n        } catch (final IndexNotFoundException e) {\n        }\n        if (!exists) {\n            final CreateIndexResponse indexResponse = fesenClient.get(c -> {\n                final String source;\n                if (numberOfReplicas > 0) {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards + \",\\\"number_of_replicas\\\":0,\\\"auto_expand_replicas\\\":\\\"0-\" + numberOfReplicas + \"\\\"}}}\";\n                } else {\n                    source = \"{\\\"settings\\\":{\\\"index\\\":{\\\"number_of_shards\\\":\" + numberOfShards + \",\\\"number_of_replicas\\\":\" + numberOfReplicas + \"}}}\";\n                }\n                return c.admin().indices().prepareCreate(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (indexResponse.isAcknowledged()) {\n                logger.info(\"Created {} index.\", index);\n            } else if (logger.isDebugEnabled()) {\n                logger.debug(\"Failed to create {} index.\", index);\n            }\n        }\n        final GetMappingsResponse getMappingsResponse = fesenClient.get(c -> c.admin().indices().prepareGetMappings(index).execute());\n        final ImmutableOpenMap<String, MappingMetadata> indexMappings = getMappingsResponse.mappings().get(index);\n        if (indexMappings == null || !indexMappings.containsKey(\"properties\")) {\n            final AcknowledgedResponse putMappingResponse = fesenClient.get(c -> {\n                final String source = FileUtil.readText(\"mapping/\" + mappingName + \".json\");\n                return c.admin().indices().preparePutMapping(index).setSource(source, XContentType.JSON).execute();\n            });\n            if (putMappingResponse.isAcknowledged()) {\n                logger.info(\"Created {} mapping.\", index);\n            } else {\n                logger.warn(\"Failed to create {} mapping.\", index);\n            }\n        } else if (logger.isDebugEnabled()) {\n            logger.debug(\"{} mapping exists.\", index);\n        }\n    }\n\n    protected Date getDateFromSource(final Map<String, Object> sourceMap, final String name) {\n        final Object obj = sourceMap.get(name);\n        if (obj instanceof Date) {\n            return (Date) obj;\n        }\n        if (obj instanceof Number) {\n            return new Date(((Number) obj).longValue());\n        }\n        if (obj instanceof String) {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            try {\n                return sdf.parse(obj.toString());\n            } catch (final ParseException e) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to parse {}\", obj, e);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected XContentBuilder getXContentBuilder(final Object target) {\n        try {\n            final XContentBuilder builder = jsonBuilder().value(target);\n            builder.flush();\n            return builder;\n        } catch (final IOException e) {\n            throw new EsAccessException(\"Failed to convert \" + target + \" to JSON.\", e);\n        }\n    }\n\n    protected RefreshResponse refresh() {\n        try {\n            return getClient().get(c -> c.admin().indices().prepareRefresh(index).execute());\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to refresh.\", e);\n        }\n    }\n\n    protected IndexResponse insert(final Object target, final OpType opType) {\n        final String url = getUrl(target);\n        if (url == null) {\n            throw new EsAccessException(\"url is null.\");\n        }\n        final String id = getId(getSessionId(target), url);\n        try (final XContentBuilder source = getXContentBuilder(target)) {\n            final IndexResponse response = getClient().get(c -> c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            setId(target, id);\n            return response;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + id, e);\n        }\n    }\n\n    protected <T> void insertAll(final List<T> list, final OpType opType) {\n        insertAll(list, opType, false);\n    }\n\n    protected <T> void insertAll(final List<T> list, final OpType opType, final boolean ignoreAlreadyExists) {\n        final List<T> bufferedList = new ArrayList<>(bulkBufferSize);\n        final StringBuilder failureBuf = new StringBuilder(100);\n        list.stream().forEach(target -> {\n            bufferedList.add(target);\n            if (bufferedList.size() >= bulkBufferSize) {\n                final BulkResponse response = doInsertAll(bufferedList, opType);\n                if (response.hasFailures()) {\n                    final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                    if (failureMessage.length() > 0) {\n                        failureBuf.append(response.buildFailureMessage()).append('\\n');\n                    }\n                }\n                bufferedList.clear();\n            }\n        });\n        if (!bufferedList.isEmpty()) {\n            final BulkResponse response = doInsertAll(bufferedList, opType);\n            if (response.hasFailures()) {\n                final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);\n                if (failureMessage.length() > 0) {\n                    failureBuf.append(response.buildFailureMessage()).append('\\n');\n                }\n            }\n        }\n        if (failureBuf.length() > 0) {\n            throw new EsAccessException(failureBuf.toString());\n        }\n    }\n\n    protected String buildFailureMessage(final BulkResponse bulkResponse, final boolean ignoreAlreadyExists) {\n        final StringBuilder sb = new StringBuilder(100);\n        final BulkItemResponse[] responses = bulkResponse.getItems();\n        for (int i = 0; i < responses.length; i++) {\n            final BulkItemResponse response = responses[i];\n            if (response.isFailed()) {\n                if (ignoreAlreadyExists) {\n                    continue;\n                }\n                sb.append(\"\\n[\").append(i).append(\"]: index [\").append(response.getIndex()).append(\"], type [\").append(response.getType()).append(\"], id [\").append(response.getId()).append(\"], message [\").append(response.getFailureMessage()).append(\"]\");\n            }\n        }\n        if (sb.length() > 0) {\n            return \"failure in bulk execution:\" + sb.toString();\n        }\n        return StringUtil.EMPTY;\n    }\n\n    protected <T> BulkResponse doInsertAll(final List<T> list, final OpType opType) {\n        try {\n            return getClient().get(c -> {\n                final BulkRequestBuilder bulkRequest = c.prepareBulk();\n                for (final T target : list) {\n                    final String id = getId(getSessionId(target), getUrl(target));\n                    try (final XContentBuilder source = getXContentBuilder(target)) {\n                        bulkRequest.add(c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType));\n                    }\n                    setId(target, id);\n                }\n                return bulkRequest.setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute();\n            });\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to insert \" + list, e);\n        }\n    }\n\n    protected boolean exists(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final GetResponse response = getClient().get(c -> c.prepareGet(index, null, id).execute());\n            return response.isExists();\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to check if \" + sessionId + \":\" + url + \" exists.\", e);\n        }\n    }\n\n    public int getCount(final Consumer<SearchRequestBuilder> callback) {\n        return (int) getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setSize(0).setTrackTotalHits(true);\n            callback.accept(builder);\n            return builder.execute();\n        }).getHits().getTotalHits().value;\n    }\n\n    protected <T> T get(final Class<T> clazz, final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        final GetResponse response = getClient().get(c -> c.prepareGet().setIndex(index).setId(id).execute());\n        if (response.isExists()) {\n            final Map<String, Object> source = response.getSource();\n            final T bean = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n            });\n            @SuppressWarnings(\"unchecked\")\n            final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n            if (data != null) {\n                ((EsAccessResult) bean).setAccessResultData(new EsAccessResultData(data));\n            }\n            setId(bean, id);\n            return bean;\n        }\n        return null;\n    }\n\n    protected <T> List<T> getList(final Class<T> clazz, final String sessionId, final QueryBuilder queryBuilder, final Integer from, final Integer size, final SortBuilder<?> sortBuilder) {\n        return getList(clazz, builder -> {\n            if (StringUtil.isNotBlank(sessionId)) {\n                if (queryBuilder instanceof BoolQueryBuilder) {\n                    ((BoolQueryBuilder) queryBuilder).filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                } else {\n                    final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(SESSION_ID, sessionId));\n                    if (queryBuilder != null) {\n                        boolQuery.must(queryBuilder);\n                    }\n                    builder.setQuery(boolQuery);\n                }\n            } else if (queryBuilder != null) {\n                builder.setQuery(queryBuilder);\n            } else {\n                builder.setQuery(QueryBuilders.matchAllQuery());\n            }\n            if (sortBuilder != null) {\n                builder.addSort(sortBuilder);\n            }\n            if (from != null) {\n                builder.setFrom(from);\n            }\n            if (size != null) {\n                builder.setSize(size);\n            }\n        });\n    }\n\n    protected <T> List<T> getList(final Class<T> clazz, final Consumer<SearchRequestBuilder> callback) {\n        final SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        final EsResultList<T> targetList = new EsResultList<>();\n        final SearchHits hits = response.getHits();\n        targetList.setTotalHits(hits.getTotalHits().value);\n        targetList.setTookInMillis(response.getTook().getMillis());\n        if (hits.getTotalHits().value != 0) {\n            try {\n                for (final SearchHit searchHit : hits.getHits()) {\n                    final Map<String, Object> source = searchHit.getSourceAsMap();\n                    final T target = BeanUtil.copyMapToNewBean(source, clazz, option -> {\n                        option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();\n                        option.exclude(EsAccessResult.ACCESS_RESULT_DATA);\n                    });\n                    @SuppressWarnings(\"unchecked\")\n                    final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);\n                    if (data != null) {\n                        ((EsAccessResult) target).setAccessResultData(new EsAccessResultData(data));\n                    }\n                    setId(target, searchHit.getId());\n                    targetList.add(target);\n                }\n            } catch (final Exception e) {\n                throw new EsAccessException(\"response: \" + response, e);\n            }\n        }\n        return targetList;\n    }\n\n    protected boolean delete(final String sessionId, final String url) {\n        final String id = getId(sessionId, url);\n        try {\n            final DeleteResponse response = getClient().get(c -> c.prepareDelete().setIndex(index).setId(id).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());\n            return response.getResult() == Result.DELETED;\n        } catch (final Exception e) {\n            throw new EsAccessException(\"Failed to delete \" + sessionId + \":\" + url, e);\n        }\n    }\n\n    protected void deleteBySessionId(final String sessionId) {\n        delete(builder -> builder.setQuery(QueryBuilders.termQuery(SESSION_ID, sessionId)));\n    }\n\n    public void deleteAll() {\n        delete(builder -> builder.setQuery(QueryBuilders.matchAllQuery()));\n    }\n\n    public void delete(final Consumer<SearchRequestBuilder> callback) {\n        SearchResponse response = getClient().get(c -> {\n            final SearchRequestBuilder builder = c.prepareSearch(index).setScroll(new TimeValue(scrollTimeout)).setSize(scrollSize);\n            callback.accept(builder);\n            return builder.execute();\n        });\n        String scrollId = response.getScrollId();\n        try {\n            while (scrollId != null) {\n                final SearchHits searchHits = response.getHits();\n                if (searchHits.getHits().length == 0) {\n                    break;\n                }\n                final BulkResponse bulkResponse = getClient().get(c -> {\n                    final BulkRequestBuilder bulkBuilder = c.prepareBulk();\n                    for (final SearchHit searchHit : searchHits) {\n                        bulkBuilder.add(c.prepareDelete().setIndex(index).setId(searchHit.getId()));\n                    }\n                    return bulkBuilder.execute();\n                });\n                if (bulkResponse.hasFailures()) {\n                    throw new EsAccessException(bulkResponse.buildFailureMessage());\n                }\n                final String sid = scrollId;\n                response = getClient().get(c -> c.prepareSearchScroll(sid).setScroll(new TimeValue(scrollTimeout)).execute());\n                if (!scrollId.equals(response.getScrollId())) {\n                    getClient().clearScroll(scrollId);\n                }\n                scrollId = response.getScrollId();\n            }\n        } finally {\n            getClient().clearScroll(scrollId);\n        }\n        refresh();\n    }\n\n    private String getId(final String sessionId, final String url) {\n        final String id = sessionId + ID_SEPARATOR + new String(Base64.getUrlEncoder().withoutPadding().encode(url.getBytes(UTF_8)), UTF_8);\n        if (id.length() <= idPrefixLength) {\n            return id;\n        }\n        return id.substring(0, idPrefixLength) + MessageDigestUtil.digest(\"SHA-256\", id.substring(idPrefixLength));\n    }\n\n    private String getUrl(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(URL);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n\n    private String getSessionId(final Object target) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(SESSION_ID);\n        final Object sessionId = sessionIdProp.getValue(target);\n        return sessionId == null ? null : sessionId.toString();\n    }\n\n    protected void setId(final Object target, final String id) {\n        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());\n        final PropertyDesc idProp = beanDesc.getPropertyDesc(ID);\n        idProp.setValue(target, id);\n    }\n\n    public String getIndex() {\n        return index;\n    }\n\n    public void setIndex(final String index) {\n        this.index = index;\n    }\n\n    public int getScrollTimeout() {\n        return scrollTimeout;\n    }\n\n    public void setScrollTimeout(final int scrollTimeout) {\n        this.scrollTimeout = scrollTimeout;\n    }\n\n    public int getScrollSize() {\n        return scrollSize;\n    }\n\n    public void setScrollSize(final int scrollSize) {\n        this.scrollSize = scrollSize;\n    }\n\n    protected static class EsTimestampConverter implements Converter {\n\n        public static final DateTimeFormatter DEFAULT_DATE_PRINTER = ISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC);\n\n        @Override\n        public String getAsString(final Object value) {\n            if (value instanceof Date) {\n                return DEFAULT_DATE_PRINTER.print(((Date) value).getTime());\n            }\n            return null;\n        }\n\n        @Override\n        public Object getAsObject(final String value) {\n            if (StringUtil.isEmpty(value)) {\n                return null;\n            }\n            return new Timestamp(DEFAULT_DATE_PRINTER.parseMillis(value));\n        }\n\n        @Override\n        public boolean isTarget(@SuppressWarnings(\"rawtypes\") final Class clazz) {\n            return clazz == Date.class;\n        }\n    }\n\n    public int getBulkBufferSize() {\n        return bulkBufferSize;\n    }\n\n    public void setBulkBufferSize(final int bulkBufferSize) {\n        this.bulkBufferSize = bulkBufferSize;\n    }\n\n    public void setNumberOfShards(final int numberOfShards) {\n        this.numberOfShards = numberOfShards;\n    }\n\n    public void setNumberOfReplicas(final int numberOfReplicas) {\n        this.numberOfReplicas = numberOfReplicas;\n    }\n\n    public void setIdPrefixLength(final int idPrefixLength) {\n        this.idPrefixLength = idPrefixLength;\n    }\n}\n", "refactored": true}
{"hexsha": "856bafe9197904c12be321e8dde1820862f17070", "ext": "java", "lang": "Java", "content": "@SuppressWarnings({ \"unused\" })\npublic class StaffCoreAPI {\n\n    private static main plugin;\n\n    public StaffCoreAPI(main plugin) {\n        StaffCoreAPI.plugin = plugin;\n    }\n\n    public static String getIP(String player) {\n        if (utils.mysqlEnabled())\n            return AltsQuery.getIp(player);\n        try {\n            return Bukkit.getPlayer(player).getAddress().getAddress().toString();\n        } catch (NullPointerException error) {\n            return \"\";\n        }\n    }\n\n    public static int getPing(String player) {\n        try {\n            return utils.getPing(Bukkit.getPlayer(player));\n        } catch (NullPointerException error) {\n            return 0;\n        }\n    }\n\n    public static ArrayList<String> getSavedPlayerList() {\n        return utils.getUsers();\n    }\n\n    public static List<String> getPlayerAlts(String player) {\n        return CheckAlts.alts(player);\n    }\n\n    public static void clearPlayerChat(Player player) {\n        utils.ccPlayer(player);\n    }\n\n    public static void clearAllPlayersChat() {\n        utils.ccAll();\n    }\n\n    public static boolean isRegistered(String player) {\n        return utils.isRegistered(player);\n    }\n\n    public static boolean mysqlEnabled() {\n        return utils.mysqlEnabled();\n    }\n\n    public static boolean getFrozenStatus(String player) {\n        if (mysqlEnabled())\n            return FreezeQuery.isFrozen(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"frozen\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getVanishedStatus(String player) {\n        if (mysqlEnabled())\n            return VanishQuery.isVanished(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"vanished\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getStaffStatus(String player) {\n        if (mysqlEnabled())\n            return StaffQuery.isStaff(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"staff\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getStaffChatStatus(String player) {\n        if (mysqlEnabled())\n            return StaffChatQuery.isStaffChat(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"staffchat\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getFlyingStatus(String player) {\n        return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"flying\"), PersistentDataType.STRING);\n    }\n\n    public static boolean getTrollStatus(String player) {\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"troll\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean isBanned(String player) {\n        if (mysqlEnabled())\n            return BansQuery.getBannedPlayers().contains(player);\n        List<String> bannedPlayers = new ArrayList<>();\n        ConfigurationSection bans = plugin.bans.getConfig().getConfigurationSection(\"bans\");\n        for (String s : bans.getKeys(false)) bannedPlayers.add(plugin.bans.getConfig().getString(\"bans.\" + s + \".name\"));\n        return bannedPlayers.contains(player);\n    }\n\n    public static boolean isWarned(String player) {\n        if (mysqlEnabled())\n            return WarnsQuery.getWarnedPlayers().contains(player);\n        List<String> warnedPlayers = new ArrayList<>();\n        ConfigurationSection warns = plugin.warns.getConfig().getConfigurationSection(\"warns\");\n        for (String s : warns.getKeys(false)) warnedPlayers.add(plugin.warns.getConfig().getString(\"warns.\" + s + \".name\"));\n        return warnedPlayers.contains(player);\n    }\n\n    public static void setFrozenStatus(Player target, String sender, boolean status) {\n        FreezePlayer.FreezePlayer(target, sender, status);\n    }\n\n    public static void setVanishStatus(Player target, boolean status) {\n        SetVanish.setVanish(target, status);\n    }\n\n    public static void setStaffStatus(Player target, boolean status) {\n        if (status) {\n            SetStaffItems.On(target);\n        } else {\n            SetStaffItems.Off(target);\n        }\n    }\n\n    public static void setStaffChatStatus(Player target, boolean status) {\n        if (mysqlEnabled()) {\n            if (status) {\n                StaffChatQuery.enable(target.getName());\n            } else {\n                StaffChatQuery.disable(target.getName());\n            }\n        } else if (status) {\n            target.getPersistentDataContainer().set(new NamespacedKey(plugin, \"staffchat\"), PersistentDataType.STRING, \"staffchat\");\n        } else {\n            target.getPersistentDataContainer().remove(new NamespacedKey(plugin, \"staffchat\"));\n        }\n    }\n\n    public static void setFlyingStatus(Player target, boolean status) {\n        new SetFly(target, status);\n    }\n\n    public static ArrayList<String> getBannedPlayers() {\n        ArrayList<String> bannedPlayers = new ArrayList<>();\n        if (utils.mysqlEnabled()) {\n            bannedPlayers.addAll(BansQuery.getBannedPlayers());\n        } else {\n            try {\n                ConfigurationSection inventorySection = plugin.bans.getConfig().getConfigurationSection(\"bans\");\n                for (String key : inventorySection.getKeys(false)) {\n                    String name = plugin.bans.getConfig().getString(\"bans.\" + key + \".name\");\n                    if (!bannedPlayers.contains(name))\n                        bannedPlayers.add(name);\n                }\n            } catch (NullPointerException ignored) {\n            }\n        }\n        return bannedPlayers;\n    }\n\n    public static ArrayList<String> getReportedPlayers() {\n        ArrayList<String> reportedPlayers = new ArrayList<>();\n        if (utils.mysqlEnabled()) {\n            reportedPlayers.addAll(ReportsQuery.getReportedPlayers());\n        } else {\n            ConfigurationSection inventorySection = plugin.reports.getConfig().getConfigurationSection(\"reports\");\n            for (String key : inventorySection.getKeys(false)) {\n                String name = plugin.reports.getConfig().getString(\"reports.\" + key + \".name\");\n                if (!reportedPlayers.contains(name))\n                    reportedPlayers.add(name);\n            }\n        }\n        return reportedPlayers;\n    }\n\n    public static void setTrollMode(Player p, Boolean bol) {\n        PersistentDataContainer PlayerData = p.getPersistentDataContainer();\n        if (bol) {\n            PlayerData.set(new NamespacedKey(plugin, \"troll\"), PersistentDataType.STRING, \"troll\");\n        } else {\n            PlayerData.remove(new NamespacedKey(plugin, \"troll\"));\n        }\n    }\n\n    public static ArrayList<String> getWarnedPlayers() {\n        return utils.getWarnedPlayers();\n    }\n\n    public static Boolean isStillBanned(int Id) {\n        if (utils.mysqlEnabled())\n            return BansQuery.isStillBanned(Id);\n        try {\n            Date now = new Date();\n            Date exp_date = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\").parse(plugin.bans.getConfig().getString(\"bans.\" + Id + \".expdate\"));\n            if (now.after(exp_date)) {\n                plugin.bans.getConfig().set(\"bans.\" + Id + \".status\", \"closed\");\n                plugin.bans.saveConfig();\n                plugin.bans.reloadConfig();\n                return false;\n            }\n            return true;\n        } catch (ParseException | NullPointerException ignored) {\n            ignored.printStackTrace();\n            plugin.bans.getConfig().set(\"bans.\" + Id + \".status\", \"closed\");\n            plugin.bans.saveConfig();\n            plugin.bans.reloadConfig();\n            return false;\n        }\n    }\n\n    public static Boolean isStillWarned(int Id) {\n        if (utils.mysqlEnabled()) {\n            return WarnsQuery.isStillWarned(Id);\n        }\n        try {\n            Date now = new Date();\n            Date exp_date = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\").parse(plugin.warns.getConfig().getString(\"warns.\" + Id + \".expdate\"));\n            if (now.after(exp_date)) {\n                plugin.warns.getConfig().set(\"warns.\" + Id + \".status\", \"closed\");\n                plugin.warns.saveConfig();\n                plugin.warns.reloadConfig();\n                return false;\n            }\n            return true;\n        } catch (ParseException | NullPointerException ignored) {\n            plugin.warns.getConfig().set(\"warns.\" + Id + \".status\", \"closed\");\n            plugin.warns.saveConfig();\n            plugin.warns.reloadConfig();\n            return false;\n        }\n    }\n\n    public static void banPlayer(CommandSender sender, String banned, String reason, Long amount, String time) {\n        BanPlayer.BanCooldown(sender, banned, reason, amount, time);\n    }\n\n    public static void banPlayer(CommandSender sender, String banned, String reason) {\n        BanPlayer.BanPlayer(sender, banned, reason);\n    }\n\n    public static void warnPlayer(Player player, String warned, String reason, Long amount, String time) {\n        WarnPlayer.createWarn(player, warned, reason, amount, time);\n    }\n\n    public static void warnPlayer(Player player, String warned, String reason) {\n        WarnPlayer.createWarn(player, warned, reason, utils.getInt(\"warns.expire_after\", null), utils.getString(\"warns.expire_after_quantity\"));\n    }\n\n    public static void muteGlobalChat() {\n        main.plugin.chatMuted = true;\n    }\n\n    public static void unMuteGlobalChat() {\n        main.plugin.chatMuted = false;\n    }\n\n    public static void mutePlayerChat(CommandSender sender, Player muted) {\n        ToggleChat.MutePlayer(sender, muted);\n    }\n\n    public static void unMutePlayerChat(CommandSender sender, Player muted) {\n        ToggleChat.unMute(sender, muted);\n    }\n\n    public static List<String> getVanishedPlayers() {\n        if (mysqlEnabled()) {\n            return VanishQuery.getVanishedPlayers();\n        } else {\n            List<String> vanishedPlayer = new ArrayList<>();\n            for (Player p : Bukkit.getOnlinePlayers()) {\n                if (p.getPersistentDataContainer().has(new NamespacedKey(plugin, \"vanished\"), PersistentDataType.STRING)) {\n                    vanishedPlayer.add(p.getName());\n                }\n            }\n            return vanishedPlayer;\n        }\n    }\n\n    public static List<String> getStaffPlayers() {\n        if (mysqlEnabled()) {\n            return StaffQuery.getStaffPlayers();\n        } else {\n            List<String> staffPlayer = new ArrayList<>();\n            for (Player p : Bukkit.getOnlinePlayers()) {\n                if (p.getPersistentDataContainer().has(new NamespacedKey(plugin, \"staff\"), PersistentDataType.STRING)) {\n                    staffPlayer.add(p.getName());\n                }\n            }\n            return staffPlayer;\n        }\n    }\n\n    public static Boolean isOlderVersion() {\n        return utils.isOlderVersion();\n    }\n\n    public static double getTPS() {\n        return TPS.getTPS();\n    }\n\n    public static String getServerVersion() {\n        return Bukkit.getServer().getClass().getPackage().getName().substring(23);\n    }\n\n    public static int getCurrentBans() {\n        return BanPlayer.currentBans();\n    }\n\n    public static int getCurrentWarns() {\n        if (mysqlEnabled()) {\n            return WarnsQuery.getCurrentWarns();\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.warns.getConfig().getConfigurationSection(\"warns\");\n                for (String key : inventorySection.getKeys(false)) current++;\n            } catch (NullPointerException ignored) {\n            }\n            return current;\n        }\n    }\n\n    public static int getCurrentReports() {\n        if (mysqlEnabled()) {\n            return ReportsQuery.getCurrentReports();\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.reports.getConfig().getConfigurationSection(\"reports\");\n                for (String key : inventorySection.getKeys(false)) current++;\n            } catch (NullPointerException ignored) {\n            }\n            return current;\n        }\n    }\n\n    public static String getIp(Player p) {\n        InetAddress address = p.getAddress().getAddress();\n        String ip = address.toString();\n        ip = ip.replace(\"/\", \"\");\n        return ip;\n    }\n}\n", "class_id": 0, "repo": "TheNumberOne/StaffCore", "file": "src/main/java/cl/bebt/staffcore/API/StaffCoreAPI.java", "last_update_at": "2021-05-02T11:05:13+00:00", "original_content": "@SuppressWarnings({ \"unused\" })\npublic class StaffCoreAPI {\n\n    private static main plugin;\n\n    public StaffCoreAPI(main plugin) {\n        StaffCoreAPI.plugin = plugin;\n    }\n\n    public static String getIP(String player) {\n        if (utils.mysqlEnabled())\n            return AltsQuery.getIp(player);\n        try {\n            return Bukkit.getPlayer(player).getAddress().getAddress().toString();\n        } catch (NullPointerException error) {\n            return \"\";\n        }\n    }\n\n    public static int getPing(String player) {\n        try {\n            return utils.getPing(Bukkit.getPlayer(player));\n        } catch (NullPointerException error) {\n            return 0;\n        }\n    }\n\n    public static ArrayList<String> getSavedPlayerList() {\n        return utils.getUsers();\n    }\n\n    public static List<String> getPlayerAlts(String player) {\n        return CheckAlts.alts(player);\n    }\n\n    public static void clearPlayerChat(Player player) {\n        utils.ccPlayer(player);\n    }\n\n    public static void clearAllPlayersChat() {\n        utils.ccAll();\n    }\n\n    public static boolean isRegistered(String player) {\n        return utils.isRegistered(player);\n    }\n\n    public static boolean mysqlEnabled() {\n        return utils.mysqlEnabled();\n    }\n\n    public static boolean getFrozenStatus(String player) {\n        if (mysqlEnabled())\n            return FreezeQuery.isFrozen(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"frozen\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getVanishedStatus(String player) {\n        if (mysqlEnabled())\n            return VanishQuery.isVanished(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"vanished\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getStaffStatus(String player) {\n        if (mysqlEnabled())\n            return StaffQuery.isStaff(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"staff\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getStaffChatStatus(String player) {\n        if (mysqlEnabled())\n            return StaffChatQuery.isStaffChat(player).equalsIgnoreCase(\"true\");\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"staffchat\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean getFlyingStatus(String player) {\n        return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"flying\"), PersistentDataType.STRING);\n    }\n\n    public static boolean getTrollStatus(String player) {\n        try {\n            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, \"troll\"), PersistentDataType.STRING);\n        } catch (NullPointerException error) {\n            return false;\n        }\n    }\n\n    public static boolean isBanned(String player) {\n        if (mysqlEnabled())\n            return BansQuery.getBannedPlayers().contains(player);\n        List<String> bannedPlayers = new ArrayList<>();\n        ConfigurationSection bans = plugin.bans.getConfig().getConfigurationSection(\"bans\");\n        for (String s : bans.getKeys(false)) bannedPlayers.add(plugin.bans.getConfig().getString(\"bans.\" + s + \".name\"));\n        return bannedPlayers.contains(player);\n    }\n\n    public static boolean isWarned(String player) {\n        if (mysqlEnabled())\n            return WarnsQuery.getWarnedPlayers().contains(player);\n        List<String> warnedPlayers = new ArrayList<>();\n        ConfigurationSection warns = plugin.warns.getConfig().getConfigurationSection(\"warns\");\n        for (String s : warns.getKeys(false)) warnedPlayers.add(plugin.warns.getConfig().getString(\"warns.\" + s + \".name\"));\n        return warnedPlayers.contains(player);\n    }\n\n    public static void setFrozenStatus(Player target, String sender, boolean status) {\n        FreezePlayer.FreezePlayer(target, sender, status);\n    }\n\n    public static void setVanishStatus(Player target, boolean status) {\n        SetVanish.setVanish(target, status);\n    }\n\n    public static void setStaffStatus(Player target, boolean status) {\n        if (status) {\n            SetStaffItems.On(target);\n        } else {\n            SetStaffItems.Off(target);\n        }\n    }\n\n    public static void setStaffChatStatus(Player target, boolean status) {\n        if (mysqlEnabled()) {\n            if (status) {\n                StaffChatQuery.enable(target.getName());\n            } else {\n                StaffChatQuery.disable(target.getName());\n            }\n        } else if (status) {\n            target.getPersistentDataContainer().set(new NamespacedKey(plugin, \"staffchat\"), PersistentDataType.STRING, \"staffchat\");\n        } else {\n            target.getPersistentDataContainer().remove(new NamespacedKey(plugin, \"staffchat\"));\n        }\n    }\n\n    public static void setFlyingStatus(Player target, boolean status) {\n        new SetFly(target, status);\n    }\n\n    public static ArrayList<String> getBannedPlayers() {\n        ArrayList<String> bannedPlayers = new ArrayList<>();\n        if (utils.mysqlEnabled()) {\n            bannedPlayers.addAll(BansQuery.getBannedPlayers());\n        } else {\n            try {\n                ConfigurationSection inventorySection = plugin.bans.getConfig().getConfigurationSection(\"bans\");\n                for (String key : inventorySection.getKeys(false)) {\n                    String name = plugin.bans.getConfig().getString(\"bans.\" + key + \".name\");\n                    if (!bannedPlayers.contains(name))\n                        bannedPlayers.add(name);\n                }\n            } catch (NullPointerException ignored) {\n            }\n        }\n        return bannedPlayers;\n    }\n\n    public static ArrayList<String> getReportedPlayers() {\n        ArrayList<String> reportedPlayers = new ArrayList<>();\n        if (utils.mysqlEnabled()) {\n            reportedPlayers.addAll(ReportsQuery.getReportedPlayers());\n        } else {\n            ConfigurationSection inventorySection = plugin.reports.getConfig().getConfigurationSection(\"reports\");\n            for (String key : inventorySection.getKeys(false)) {\n                String name = plugin.reports.getConfig().getString(\"reports.\" + key + \".name\");\n                if (!reportedPlayers.contains(name))\n                    reportedPlayers.add(name);\n            }\n        }\n        return reportedPlayers;\n    }\n\n    public static void setTrollMode(Player p, Boolean bol) {\n        PersistentDataContainer PlayerData = p.getPersistentDataContainer();\n        if (bol) {\n            PlayerData.set(new NamespacedKey(plugin, \"troll\"), PersistentDataType.STRING, \"troll\");\n        } else {\n            PlayerData.remove(new NamespacedKey(plugin, \"troll\"));\n        }\n    }\n\n    public static ArrayList<String> getWarnedPlayers() {\n        return utils.getWarnedPlayers();\n    }\n\n    public static Boolean isStillBanned(int Id) {\n        if (utils.mysqlEnabled())\n            return BansQuery.isStillBanned(Id);\n        try {\n            Date now = new Date();\n            Date exp_date = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\").parse(plugin.bans.getConfig().getString(\"bans.\" + Id + \".expdate\"));\n            if (now.after(exp_date)) {\n                plugin.bans.getConfig().set(\"bans.\" + Id + \".status\", \"closed\");\n                plugin.bans.saveConfig();\n                plugin.bans.reloadConfig();\n                return false;\n            }\n            return true;\n        } catch (ParseException | NullPointerException ignored) {\n            ignored.printStackTrace();\n            plugin.bans.getConfig().set(\"bans.\" + Id + \".status\", \"closed\");\n            plugin.bans.saveConfig();\n            plugin.bans.reloadConfig();\n            return false;\n        }\n    }\n\n    public static Boolean isStillWarned(int Id) {\n        if (utils.mysqlEnabled()) {\n            return WarnsQuery.isStillWarned(Id);\n        }\n        try {\n            Date now = new Date();\n            Date exp_date = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\").parse(plugin.warns.getConfig().getString(\"warns.\" + Id + \".expdate\"));\n            if (now.after(exp_date)) {\n                plugin.warns.getConfig().set(\"warns.\" + Id + \".status\", \"closed\");\n                plugin.warns.saveConfig();\n                plugin.warns.reloadConfig();\n                return false;\n            }\n            return true;\n        } catch (ParseException | NullPointerException ignored) {\n            plugin.warns.getConfig().set(\"warns.\" + Id + \".status\", \"closed\");\n            plugin.warns.saveConfig();\n            plugin.warns.reloadConfig();\n            return false;\n        }\n    }\n\n    public static void banPlayer(CommandSender sender, String banned, String reason, Long amount, String time) {\n        BanPlayer.BanCooldown(sender, banned, reason, amount, time);\n    }\n\n    public static void banPlayer(CommandSender sender, String banned, String reason) {\n        BanPlayer.BanPlayer(sender, banned, reason);\n    }\n\n    public static void warnPlayer(Player player, String warned, String reason, Long amount, String time) {\n        WarnPlayer.createWarn(player, warned, reason, amount, time);\n    }\n\n    public static void warnPlayer(Player player, String warned, String reason) {\n        WarnPlayer.createWarn(player, warned, reason, utils.getInt(\"warns.expire_after\", null), utils.getString(\"warns.expire_after_quantity\"));\n    }\n\n    public static void muteGlobalChat() {\n        main.plugin.chatMuted = true;\n    }\n\n    public static void unMuteGlobalChat() {\n        main.plugin.chatMuted = false;\n    }\n\n    public static void mutePlayerChat(CommandSender sender, Player muted) {\n        ToggleChat.MutePlayer(sender, muted);\n    }\n\n    public static void unMutePlayerChat(CommandSender sender, Player muted) {\n        ToggleChat.unMute(sender, muted);\n    }\n\n    public static List<String> getVanishedPlayers() {\n        if (mysqlEnabled()) {\n            return VanishQuery.getVanishedPlayers();\n        } else {\n            List<String> vanishedPlayer = new ArrayList<>();\n            for (Player p : Bukkit.getOnlinePlayers()) {\n                if (p.getPersistentDataContainer().has(new NamespacedKey(plugin, \"vanished\"), PersistentDataType.STRING)) {\n                    vanishedPlayer.add(p.getName());\n                }\n            }\n            return vanishedPlayer;\n        }\n    }\n\n    public static List<String> getStaffPlayers() {\n        if (mysqlEnabled()) {\n            return StaffQuery.getStaffPlayers();\n        } else {\n            List<String> staffPlayer = new ArrayList<>();\n            for (Player p : Bukkit.getOnlinePlayers()) {\n                if (p.getPersistentDataContainer().has(new NamespacedKey(plugin, \"staff\"), PersistentDataType.STRING)) {\n                    staffPlayer.add(p.getName());\n                }\n            }\n            return staffPlayer;\n        }\n    }\n\n    public static Boolean isOlderVersion() {\n        return utils.isOlderVersion();\n    }\n\n    public static double getTPS() {\n        return TPS.getTPS();\n    }\n\n    public static String getServerVersion() {\n        return Bukkit.getServer().getClass().getPackage().getName().substring(23);\n    }\n\n    public static int getCurrentBans() {\n        return BanPlayer.currentBans();\n    }\n\n    public static int getCurrentWarns() {\n        if (mysqlEnabled()) {\n            return WarnsQuery.getCurrentWarns();\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.warns.getConfig().getConfigurationSection(\"warns\");\n                for (String key : inventorySection.getKeys(false)) current++;\n            } catch (NullPointerException ignored) {\n            }\n            return current;\n        }\n    }\n\n    public static int getCurrentReports() {\n        if (mysqlEnabled()) {\n            return ReportsQuery.getCurrentReports();\n        } else {\n            int current = 0;\n            try {\n                ConfigurationSection inventorySection = main.plugin.reports.getConfig().getConfigurationSection(\"reports\");\n                for (String key : inventorySection.getKeys(false)) current++;\n            } catch (NullPointerException ignored) {\n            }\n            return current;\n        }\n    }\n\n    public static String getIp(Player p) {\n        InetAddress address = p.getAddress().getAddress();\n        String ip = address.toString();\n        ip = ip.replace(\"/\", \"\");\n        return ip;\n    }\n}\n", "refactored": false}
{"hexsha": "3aeba7a2e5875d961c7b615ed7f977845a528c34", "ext": "java", "lang": "Java", "content": "@SpringBootApplication\npublic class AgendabotApplication {\n\n    private final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n\n    private final List<String> SCOPES = Collections.singletonList(CalendarScopes.CALENDAR_READONLY);\n\n    public static void main(String[] args) {\n        SpringApplication.run(AgendabotApplication.class, args);\n    }\n\n    private Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT) throws IOException {\n        String CREDENTIALS_FILE_PATH = \"/credentials.json\";\n        InputStream in = AgendabotApplication.class.getResourceAsStream(CREDENTIALS_FILE_PATH);\n        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));\n        String TOKENS_DIRECTORY_PATH = \"tokens\";\n        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES).setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH))).setAccessType(\"offline\").build();\n        return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize(\"user\");\n    }\n\n    @Bean\n    Calendar getCalendar() throws GeneralSecurityException, IOException {\n        NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();\n        String APPLICATION_NAME = \"MyEvent\";\n        return new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT)).setApplicationName(APPLICATION_NAME).build();\n    }\n}\n", "class_id": 0, "repo": "matfurrier/AgendaBot", "file": "src/main/java/com/zenvia/newhorizon/agendabot/AgendabotApplication.java", "last_update_at": "2021-08-07T00:38:06+00:00", "original_content": "@SpringBootApplication\npublic class AgendabotApplication {\n\n    private final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n\n    private final List<String> SCOPES = Collections.singletonList(CalendarScopes.CALENDAR_READONLY);\n\n    public static void main(String[] args) {\n        SpringApplication.run(AgendabotApplication.class, args);\n    }\n\n    private Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT) throws IOException {\n        String CREDENTIALS_FILE_PATH = \"/credentials.json\";\n        InputStream in = AgendabotApplication.class.getResourceAsStream(CREDENTIALS_FILE_PATH);\n        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));\n        String TOKENS_DIRECTORY_PATH = \"tokens\";\n        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES).setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH))).setAccessType(\"offline\").build();\n        return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize(\"user\");\n    }\n\n    @Bean\n    Calendar getCalendar() throws GeneralSecurityException, IOException {\n        NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();\n        String APPLICATION_NAME = \"MyEvent\";\n        return new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT)).setApplicationName(APPLICATION_NAME).build();\n    }\n}\n", "refactored": false}
{"hexsha": "6e26950490701ecf5a24f45ce57289a210764de4", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"unused\")\r\npublic class RawFilesCopier extends BasePagesGenerator {\r\n\r\n    public RawFilesCopier(FoldersConfig foldersConfig) {\r\n        super(foldersConfig);\r\n    }\r\n\r\n    @Override\r\n    protected void generateData() throws IOException {\r\n        var rawFolder = foldersConfig.getTemplateFolder() + \"RAW\";\r\n        //?????? ?????\r\n        var rootFiles = FileHelper.getFilesList(rawFolder);\r\n        for (var file : rootFiles) {\r\n            var outputFolder = foldersConfig.getOutputFolder();\r\n            FileHelper.createFolder(outputFolder);\r\n            FileHelper.copyFile(rawFolder + \"/\" + file, outputFolder + file);\r\n        }\r\n        String[] gameDirs = FileHelper.getDirsList(rawFolder);\r\n        for (var dir : gameDirs) {\r\n            var filePath = rawFolder + \"/\" + dir;\r\n            var files = FileHelper.getFilesList(filePath);\r\n            for (var file : files) {\r\n                var outputFolder = foldersConfig.getOutputFolder();\r\n                FileHelper.createFolder(outputFolder + dir);\r\n                FileHelper.copyFile(filePath + \"/\" + file, outputFolder + dir + \"/\" + file);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "class_id": 0, "repo": "saiks24/GamesRevivalSiteGenerator", "file": "src/main/java/newbilius/GamesRevival/Generators/RawFilesCopier.java", "last_update_at": "2021-11-14T08:04:35+00:00", "original_content": "@SuppressWarnings(\"unused\")\r\npublic class RawFilesCopier extends BasePagesGenerator {\r\n\r\n    public RawFilesCopier(FoldersConfig foldersConfig) {\r\n        super(foldersConfig);\r\n    }\r\n\r\n    @Override\r\n    protected void generateData() throws IOException {\r\n        var rawFolder = foldersConfig.getTemplateFolder() + \"RAW\";\r\n        //?????? ?????\r\n        var rootFiles = FileHelper.getFilesList(rawFolder);\r\n        for (var file : rootFiles) {\r\n            var outputFolder = foldersConfig.getOutputFolder();\r\n            FileHelper.createFolder(outputFolder);\r\n            FileHelper.copyFile(rawFolder + \"/\" + file, outputFolder + file);\r\n        }\r\n        String[] gameDirs = FileHelper.getDirsList(rawFolder);\r\n        for (var dir : gameDirs) {\r\n            var filePath = rawFolder + \"/\" + dir;\r\n            var files = FileHelper.getFilesList(filePath);\r\n            for (var file : files) {\r\n                var outputFolder = foldersConfig.getOutputFolder();\r\n                FileHelper.createFolder(outputFolder + dir);\r\n                FileHelper.copyFile(filePath + \"/\" + file, outputFolder + dir + \"/\" + file);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "e0ea20945f697123219e25bb900d86a4b8cb0fbb", "ext": "java", "lang": "Java", "content": "public class Facade {\n\n    private SubSystemOne subSystemOne;\n\n    private SubSystemTwo subSystemTwo;\n\n    private SubSystemThree subSystemThree;\n\n    private SubSystemFour subSystemFour;\n\n    public Facade() {\n        subSystemOne = new SubSystemOne();\n        subSystemTwo = new SubSystemTwo();\n        subSystemThree = new SubSystemThree();\n        subSystemFour = new SubSystemFour();\n    }\n\n    public void methodA() {\n        subSystemOne.methodOne();\n        subSystemTwo.methodOne();\n        subSystemThree.methodOne();\n    }\n\n    public void methodB() {\n        subSystemTwo.methodOne();\n        subSystemThree.methodOne();\n        subSystemFour.methodOne();\n    }\n}\n", "class_id": 0, "repo": "DongjianPeng/PatternDesign", "file": "src/main/java/structure/facade/structure/Facade.java", "last_update_at": "2021-05-26T06:51:53+00:00", "original_content": "public class Facade {\n\n    private SubSystemOne subSystemOne;\n\n    private SubSystemTwo subSystemTwo;\n\n    private SubSystemThree subSystemThree;\n\n    private SubSystemFour subSystemFour;\n\n    public Facade() {\n        subSystemOne = new SubSystemOne();\n        subSystemTwo = new SubSystemTwo();\n        subSystemThree = new SubSystemThree();\n        subSystemFour = new SubSystemFour();\n    }\n\n    public void methodA() {\n        subSystemOne.methodOne();\n        subSystemTwo.methodOne();\n        subSystemThree.methodOne();\n    }\n\n    public void methodB() {\n        subSystemTwo.methodOne();\n        subSystemThree.methodOne();\n        subSystemFour.methodOne();\n    }\n}\n", "refactored": false}
{"hexsha": "d0e08467a50a8d3f84bbbe7b3bd74b5a35347772", "ext": "java", "lang": "Java", "content": "public class ManageProjectFeatures extends SecureScreen {\r\n\r\n    @Override\r\n    protected void doBuildTemplate(RunData data, Context context) throws Exception {\r\n        final Object projects = TurbineUtils.GetPassedParameter(\"projects\", data);\r\n        if (projects != null) {\r\n            context.put(\"project\", projects);\r\n        } else {\r\n            context.put(\"project\", TurbineUtils.GetPassedParameter(\"project\", data));\r\n        }\r\n        context.put(\"features\", Features.getAllFeatures());\r\n    }\r\n}\r\n", "class_id": 0, "repo": "student-t/Xnat", "file": "src/main/java/org/nrg/xnat/turbine/modules/screens/ManageProjectFeatures.java", "last_update_at": "2021-01-19T19:55:55+00:00", "original_content": "public class ManageProjectFeatures extends SecureScreen {\r\n\r\n    @Override\r\n    protected void doBuildTemplate(RunData data, Context context) throws Exception {\r\n        final Object projects = TurbineUtils.GetPassedParameter(\"projects\", data);\r\n        if (projects != null) {\r\n            context.put(\"project\", projects);\r\n        } else {\r\n            context.put(\"project\", TurbineUtils.GetPassedParameter(\"project\", data));\r\n        }\r\n        context.put(\"features\", Features.getAllFeatures());\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "4df8a27f0598864bd98f434816cd53ecd56f674f", "ext": "java", "lang": "Java", "content": "public final class EndpointId {\n\n    private static final Log logger = LogFactory.getLog(EndpointId.class);\n\n    private static final Set<String> loggedWarnings = new HashSet<>();\n\n    private static final Pattern VALID_PATTERN = Pattern.compile(\"[a-zA-Z0-9\\\\.\\\\-]+\");\n\n    private static final Pattern WARNING_PATTERN = Pattern.compile(\"[\\\\.\\\\-]+\");\n\n    private static final String MIGRATE_LEGACY_NAMES_PROPRTY = \"management.endpoints.migrate-legacy-ids\";\n\n    private final String value;\n\n    private final String lowerCaseValue;\n\n    private final String lowerCaseAlphaNumeric;\n\n    private EndpointId(String value) {\n        Assert.hasText(value, \"Value must not be empty\");\n        Assert.isTrue(VALID_PATTERN.matcher(value).matches(), \"Value must only contain valid chars\");\n        Assert.isTrue(!Character.isDigit(value.charAt(0)), \"Value must not start with a number\");\n        Assert.isTrue(!Character.isUpperCase(value.charAt(0)), \"Value must not start with an uppercase letter\");\n        if (WARNING_PATTERN.matcher(value).find()) {\n            logWarning(value);\n        }\n        this.value = value;\n        this.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);\n        this.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);\n    }\n\n    private String getAlphaNumerics(String value) {\n        StringBuilder result = new StringBuilder(value.length());\n        int i = 0;\n        while (i < value.length()) try {\n            char ch = value.charAt(i);\n            if (ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9') {\n                result.append(ch);\n            }\n        } finally {\n            i++;\n        }\n        return result.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        return this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.lowerCaseAlphaNumeric.hashCode();\n    }\n\n    /**\n     * Return a lower-case version of the endpoint ID.\n     * @return the lower-case endpoint ID\n     */\n    public String toLowerCaseString() {\n        return this.lowerCaseValue;\n    }\n\n    @Override\n    public String toString() {\n        return this.value;\n    }\n\n    /**\n     * Factory method to create a new {@link EndpointId} of the specified value.\n     * @param value the endpoint ID value\n     * @return an {@link EndpointId} instance\n     */\n    public static EndpointId of(String value) {\n        return new EndpointId(value);\n    }\n\n    /**\n     * Factory method to create a new {@link EndpointId} of the specified value. This\n     * variant will respect the {@code management.endpoints.migrate-legacy-names} property\n     * if it has been set in the {@link Environment}.\n     * @param environment the Spring environment\n     * @param value the endpoint ID value\n     * @return an {@link EndpointId} instance\n     * @since 2.2.0\n     */\n    public static EndpointId of(Environment environment, String value) {\n        Assert.notNull(environment, \"Environment must not be null\");\n        return new EndpointId(migrateLegacyId(environment, value));\n    }\n\n    private static String migrateLegacyId(Environment environment, String value) {\n        if (environment.getProperty(MIGRATE_LEGACY_NAMES_PROPRTY, Boolean.class, false)) {\n            return value.replace(\".\", \"\");\n        }\n        return value;\n    }\n\n    /**\n     * Factory method to create a new {@link EndpointId} from a property value. More\n     * lenient than {@link #of(String)} to allow for common \"relaxed\" property variants.\n     * @param value the property value to convert\n     * @return an {@link EndpointId} instance\n     */\n    public static EndpointId fromPropertyValue(String value) {\n        return new EndpointId(value.replace(\"-\", \"\"));\n    }\n\n    static void resetLoggedWarnings() {\n        loggedWarnings.clear();\n    }\n\n    private static void logWarning(String value) {\n        if (logger.isWarnEnabled() && loggedWarnings.add(value)) {\n            logger.warn(\"Endpoint ID '\" + value + \"' contains invalid characters, please migrate to a valid format.\");\n        }\n    }\n}\n", "class_id": 0, "repo": "clove506/spring-boot", "file": "spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/EndpointId.java", "last_update_at": "2021-03-02T12:02:19+00:00", "original_content": "public final class EndpointId {\n\n    private static final Log logger = LogFactory.getLog(EndpointId.class);\n\n    private static final Set<String> loggedWarnings = new HashSet<>();\n\n    private static final Pattern VALID_PATTERN = Pattern.compile(\"[a-zA-Z0-9\\\\.\\\\-]+\");\n\n    private static final Pattern WARNING_PATTERN = Pattern.compile(\"[\\\\.\\\\-]+\");\n\n    private static final String MIGRATE_LEGACY_NAMES_PROPRTY = \"management.endpoints.migrate-legacy-ids\";\n\n    private final String value;\n\n    private final String lowerCaseValue;\n\n    private final String lowerCaseAlphaNumeric;\n\n    private EndpointId(String value) {\n        Assert.hasText(value, \"Value must not be empty\");\n        Assert.isTrue(VALID_PATTERN.matcher(value).matches(), \"Value must only contain valid chars\");\n        Assert.isTrue(!Character.isDigit(value.charAt(0)), \"Value must not start with a number\");\n        Assert.isTrue(!Character.isUpperCase(value.charAt(0)), \"Value must not start with an uppercase letter\");\n        if (WARNING_PATTERN.matcher(value).find()) {\n            logWarning(value);\n        }\n        this.value = value;\n        this.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);\n        this.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);\n    }\n\n    private String getAlphaNumerics(String value) {\n        StringBuilder result = new StringBuilder(value.length());\n        for (int i = 0; i < value.length(); i++) {\n            char ch = value.charAt(i);\n            if (ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9') {\n                result.append(ch);\n            }\n        }\n        return result.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        return this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.lowerCaseAlphaNumeric.hashCode();\n    }\n\n    /**\n     * Return a lower-case version of the endpoint ID.\n     * @return the lower-case endpoint ID\n     */\n    public String toLowerCaseString() {\n        return this.lowerCaseValue;\n    }\n\n    @Override\n    public String toString() {\n        return this.value;\n    }\n\n    /**\n     * Factory method to create a new {@link EndpointId} of the specified value.\n     * @param value the endpoint ID value\n     * @return an {@link EndpointId} instance\n     */\n    public static EndpointId of(String value) {\n        return new EndpointId(value);\n    }\n\n    /**\n     * Factory method to create a new {@link EndpointId} of the specified value. This\n     * variant will respect the {@code management.endpoints.migrate-legacy-names} property\n     * if it has been set in the {@link Environment}.\n     * @param environment the Spring environment\n     * @param value the endpoint ID value\n     * @return an {@link EndpointId} instance\n     * @since 2.2.0\n     */\n    public static EndpointId of(Environment environment, String value) {\n        Assert.notNull(environment, \"Environment must not be null\");\n        return new EndpointId(migrateLegacyId(environment, value));\n    }\n\n    private static String migrateLegacyId(Environment environment, String value) {\n        if (environment.getProperty(MIGRATE_LEGACY_NAMES_PROPRTY, Boolean.class, false)) {\n            return value.replace(\".\", \"\");\n        }\n        return value;\n    }\n\n    /**\n     * Factory method to create a new {@link EndpointId} from a property value. More\n     * lenient than {@link #of(String)} to allow for common \"relaxed\" property variants.\n     * @param value the property value to convert\n     * @return an {@link EndpointId} instance\n     */\n    public static EndpointId fromPropertyValue(String value) {\n        return new EndpointId(value.replace(\"-\", \"\"));\n    }\n\n    static void resetLoggedWarnings() {\n        loggedWarnings.clear();\n    }\n\n    private static void logWarning(String value) {\n        if (logger.isWarnEnabled() && loggedWarnings.add(value)) {\n            logger.warn(\"Endpoint ID '\" + value + \"' contains invalid characters, please migrate to a valid format.\");\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "02ba5c430b56fa53c25a4d0f7607776b7d2fa8fe", "ext": "java", "lang": "Java", "content": "@RunWith(ConcurrentJunitRunner.class)\n@Concurrent()\npublic class CheckPasswordPolicyTest {\n\n    private static final int passwordLength = 6;\n\n    private static final int categoryCount = 3;\n\n    private static final int tokenSize = 3;\n\n    private static final CheckPasswordPolicy policy = new CheckPasswordPolicy();\n\n    /**\n     * Tests that a good password is valid according to all policy checks.\n     */\n    @Test\n    public void testGoodPassword() {\n        String username = \"Enrique Rodriguez\";\n        String password = \"d1r3ct0rY\";\n        assertTrue(policy.isValidPasswordLength(password, passwordLength));\n        assertTrue(policy.isValidCategoryCount(password, categoryCount));\n        assertTrue(policy.isValidUsernameSubstring(username, password, tokenSize));\n        assertTrue(policy.isValid(username, password, passwordLength, categoryCount, tokenSize));\n    }\n\n    /**\n     * Tests that a bad password fails all validity checks.\n     */\n    @Test\n    public void testBadPassword() {\n        String username = \"Erin Randall\";\n        String password = \"erin1\";\n        assertFalse(policy.isValidPasswordLength(password, passwordLength));\n        assertFalse(policy.isValidCategoryCount(password, categoryCount));\n        assertFalse(policy.isValidUsernameSubstring(username, password, tokenSize));\n        assertFalse(policy.isValid(username, password, passwordLength, categoryCount, tokenSize));\n    }\n\n    /**\n     * Tests variations of a password where the password includes tokens of the username.\n     */\n    @Test\n    public void testPrincipalAsUsername() {\n        String username = new KerberosPrincipal(\"erodriguez@EXAMPLE.COM\").getName();\n        String password1 = \"d1r3ct0rY\";\n        String password2 = \"ERodriguez@d1r3ct0rY\";\n        String password3 = \"Example@d1r3ct0rY\";\n        assertTrue(policy.isValidUsernameSubstring(username, password1, tokenSize));\n        assertFalse(policy.isValidUsernameSubstring(username, password2, tokenSize));\n        assertFalse(policy.isValidUsernameSubstring(username, password3, tokenSize));\n    }\n}\n", "class_id": 0, "repo": "senthalan/directory-server", "file": "protocol-changepw/src/test/java/org/apache/directory/server/changepw/service/CheckPasswordPolicyTest.java", "last_update_at": "2021-02-23T13:28:38+00:00", "original_content": "@RunWith(ConcurrentJunitRunner.class)\n@Concurrent()\npublic class CheckPasswordPolicyTest {\n\n    private static final int passwordLength = 6;\n\n    private static final int categoryCount = 3;\n\n    private static final int tokenSize = 3;\n\n    private static final CheckPasswordPolicy policy = new CheckPasswordPolicy();\n\n    /**\n     * Tests that a good password is valid according to all policy checks.\n     */\n    @Test\n    public void testGoodPassword() {\n        String username = \"Enrique Rodriguez\";\n        String password = \"d1r3ct0rY\";\n        assertTrue(policy.isValidPasswordLength(password, passwordLength));\n        assertTrue(policy.isValidCategoryCount(password, categoryCount));\n        assertTrue(policy.isValidUsernameSubstring(username, password, tokenSize));\n        assertTrue(policy.isValid(username, password, passwordLength, categoryCount, tokenSize));\n    }\n\n    /**\n     * Tests that a bad password fails all validity checks.\n     */\n    @Test\n    public void testBadPassword() {\n        String username = \"Erin Randall\";\n        String password = \"erin1\";\n        assertFalse(policy.isValidPasswordLength(password, passwordLength));\n        assertFalse(policy.isValidCategoryCount(password, categoryCount));\n        assertFalse(policy.isValidUsernameSubstring(username, password, tokenSize));\n        assertFalse(policy.isValid(username, password, passwordLength, categoryCount, tokenSize));\n    }\n\n    /**\n     * Tests variations of a password where the password includes tokens of the username.\n     */\n    @Test\n    public void testPrincipalAsUsername() {\n        String username = new KerberosPrincipal(\"erodriguez@EXAMPLE.COM\").getName();\n        String password1 = \"d1r3ct0rY\";\n        String password2 = \"ERodriguez@d1r3ct0rY\";\n        String password3 = \"Example@d1r3ct0rY\";\n        assertTrue(policy.isValidUsernameSubstring(username, password1, tokenSize));\n        assertFalse(policy.isValidUsernameSubstring(username, password2, tokenSize));\n        assertFalse(policy.isValidUsernameSubstring(username, password3, tokenSize));\n    }\n}\n", "refactored": false}
{"hexsha": "72ae39170a00e26a90f4a2eecfcf893492a74a15", "ext": "java", "lang": "Java", "content": "@OnStop\n@Messages({ \"# {0} - autosave id\", \"MSG_CleanedUp=Cleaned up autosave {0}\" })\npublic final class AutosaveStop implements Runnable {\n\n    private static final Logger LOGGER = Logger.getLogger(AutosaveStop.class.getName());\n\n    @Override\n    public void run() {\n        final Map<String, Graph> graphs = GraphNode.getAllGraphs();\n        for (final Map.Entry<String, Graph> entry : graphs.entrySet()) {\n            final Graph graph = entry.getValue();\n            AutosaveUtilities.deleteAutosave(graph.getId());\n            LOGGER.info(Bundle.MSG_CleanedUp(graph.getId()));\n        }\n        AutosaveUtilities.cleanup();\n    }\n}\n", "class_id": 0, "repo": "aldebaran30701/constellation", "file": "CoreInteractiveGraph/src/au/gov/asd/tac/constellation/graph/interaction/plugins/io/AutosaveStop.java", "last_update_at": "2021-03-22T04:32:17+00:00", "original_content": "@OnStop\n@Messages({ \"# {0} - autosave id\", \"MSG_CleanedUp=Cleaned up autosave {0}\" })\npublic final class AutosaveStop implements Runnable {\n\n    private static final Logger LOGGER = Logger.getLogger(AutosaveStop.class.getName());\n\n    @Override\n    public void run() {\n        final Map<String, Graph> graphs = GraphNode.getAllGraphs();\n        for (final Map.Entry<String, Graph> entry : graphs.entrySet()) {\n            final Graph graph = entry.getValue();\n            AutosaveUtilities.deleteAutosave(graph.getId());\n            LOGGER.info(Bundle.MSG_CleanedUp(graph.getId()));\n        }\n        AutosaveUtilities.cleanup();\n    }\n}\n", "refactored": false}
{"hexsha": "60102b23cb71fa0a9064c2d93835462b9f29e26f", "ext": "java", "lang": "Java", "content": "public class ZipHelper {\r\n\r\n    /**\r\n     * To zip a set of files or directories to an archive:\r\n     */\r\n    public static void zipit(String sourcePath, String targetPath) throws IOException {\r\n        FileOutputStream fos = new FileOutputStream(targetPath);\r\n        ZipOutputStream zipOut = new ZipOutputStream(fos);\r\n        File fileToZip = new File(sourcePath);\r\n        zip(fileToZip, fileToZip.getName(), zipOut);\r\n        zipOut.close();\r\n        fos.close();\r\n    }\r\n\r\n    /**\r\n     * To unzip an archive to a target directory\r\n     */\r\n    public static void unzipit(String sourcePath, String targetPath) throws IOException {\r\n        File dir = new File(targetPath);\r\n        if (!dir.exists())\r\n            dir.mkdirs();\r\n        FileInputStream fis = new FileInputStream(sourcePath);\r\n        ZipInputStream zipIn = new ZipInputStream(fis);\r\n        unzip(targetPath, zipIn);\r\n        zipIn.close();\r\n        fis.close();\r\n    }\r\n\r\n    private static void zip(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {\r\n        if (fileToZip.isHidden()) {\r\n            return;\r\n        }\r\n        if (fileToZip.isDirectory()) {\r\n            File[] files = fileToZip.listFiles();\r\n            for (File file : files) {\r\n                zip(file, fileName + \"/\" + file.getName(), zipOut);\r\n            }\r\n            return;\r\n        }\r\n        FileInputStream fis = new FileInputStream(fileToZip);\r\n        ZipEntry zipEntry = new ZipEntry(fileName);\r\n        zipOut.putNextEntry(zipEntry);\r\n        byte[] bytes = new byte[1024];\r\n        int length;\r\n        for (; (length = fis.read(bytes)) >= 0; ) {\r\n            zipOut.write(bytes, 0, length);\r\n        }\r\n        fis.close();\r\n    }\r\n\r\n    private static void unzip(String targetPath, ZipInputStream zipIn) {\r\n        //buffer for read and write data to file\r\n        byte[] buffer = new byte[1024];\r\n        try {\r\n            ZipEntry ze = zipIn.getNextEntry();\r\n            for (; ze != null; ) {\r\n                String fileName = ze.getName();\r\n                File newFile = new File(targetPath + File.separator + fileName);\r\n                new File(newFile.getParent()).mkdirs();\r\n                FileOutputStream fos = new FileOutputStream(newFile);\r\n                int len;\r\n                for (; (len = zipIn.read(buffer)) > 0; ) {\r\n                    fos.write(buffer, 0, len);\r\n                }\r\n                fos.close();\r\n                //close this ZipEntry\r\n                zipIn.closeEntry();\r\n                ze = zipIn.getNextEntry();\r\n            }\r\n            //close last ZipEntry\r\n            zipIn.closeEntry();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n", "class_id": 0, "repo": "yash-rustagi/atom", "file": "sample-selenium/src/test/java/automation/library/common/ZipHelper.java", "last_update_at": "2021-12-30T18:09:01+00:00", "original_content": "public class ZipHelper {\r\n\r\n    /**\r\n     * To zip a set of files or directories to an archive:\r\n     */\r\n    public static void zipit(String sourcePath, String targetPath) throws IOException {\r\n        FileOutputStream fos = new FileOutputStream(targetPath);\r\n        ZipOutputStream zipOut = new ZipOutputStream(fos);\r\n        File fileToZip = new File(sourcePath);\r\n        zip(fileToZip, fileToZip.getName(), zipOut);\r\n        zipOut.close();\r\n        fos.close();\r\n    }\r\n\r\n    /**\r\n     * To unzip an archive to a target directory\r\n     */\r\n    public static void unzipit(String sourcePath, String targetPath) throws IOException {\r\n        File dir = new File(targetPath);\r\n        if (!dir.exists())\r\n            dir.mkdirs();\r\n        FileInputStream fis = new FileInputStream(sourcePath);\r\n        ZipInputStream zipIn = new ZipInputStream(fis);\r\n        unzip(targetPath, zipIn);\r\n        zipIn.close();\r\n        fis.close();\r\n    }\r\n\r\n    private static void zip(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {\r\n        if (fileToZip.isHidden()) {\r\n            return;\r\n        }\r\n        if (fileToZip.isDirectory()) {\r\n            File[] files = fileToZip.listFiles();\r\n            for (File file : files) {\r\n                zip(file, fileName + \"/\" + file.getName(), zipOut);\r\n            }\r\n            return;\r\n        }\r\n        FileInputStream fis = new FileInputStream(fileToZip);\r\n        ZipEntry zipEntry = new ZipEntry(fileName);\r\n        zipOut.putNextEntry(zipEntry);\r\n        byte[] bytes = new byte[1024];\r\n        int length;\r\n        while ((length = fis.read(bytes)) >= 0) {\r\n            zipOut.write(bytes, 0, length);\r\n        }\r\n        fis.close();\r\n    }\r\n\r\n    private static void unzip(String targetPath, ZipInputStream zipIn) {\r\n        //buffer for read and write data to file\r\n        byte[] buffer = new byte[1024];\r\n        try {\r\n            ZipEntry ze = zipIn.getNextEntry();\r\n            while (ze != null) {\r\n                String fileName = ze.getName();\r\n                File newFile = new File(targetPath + File.separator + fileName);\r\n                new File(newFile.getParent()).mkdirs();\r\n                FileOutputStream fos = new FileOutputStream(newFile);\r\n                int len;\r\n                while ((len = zipIn.read(buffer)) > 0) {\r\n                    fos.write(buffer, 0, len);\r\n                }\r\n                fos.close();\r\n                //close this ZipEntry\r\n                zipIn.closeEntry();\r\n                ze = zipIn.getNextEntry();\r\n            }\r\n            //close last ZipEntry\r\n            zipIn.closeEntry();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "673ab9412635a6e9d321e08447e1e08c0938e832", "ext": "java", "lang": "Java", "content": "public class DistributorModule extends SenderModule2 {\n\n    private static final TintColor TINT_COLOR = new TintColor(240, 240, 60);\n\n    public DistributorModule() {\n        super(CompiledDistributorModule::new);\n    }\n\n    @Override\n    public void addSettingsInformation(ItemStack itemstack, List<ITextComponent> list) {\n        super.addSettingsInformation(itemstack, list);\n        CompiledDistributorModule cdm = new CompiledDistributorModule(null, itemstack);\n        list.add(ClientUtil.xlate(\"modularrouters.guiText.tooltip.distributor.strategy\").append(\": \").withStyle(TextFormatting.YELLOW).append(ClientUtil.xlate(cdm.getDistributionStrategy().getTranslationKey())).withStyle(TextFormatting.AQUA));\n        list.add(ClientUtil.xlate(\"modularrouters.itemText.fluid.direction.\" + (cdm.isPulling() ? \"IN\" : \"OUT\")).withStyle(TextFormatting.YELLOW));\n    }\n\n    @Override\n    public ContainerType<? extends ContainerModule> getContainerType() {\n        return ModContainerTypes.CONTAINER_MODULE_DISTRIBUTOR.get();\n    }\n\n    @Override\n    public List<ModuleTarget> getStoredPositions(@Nonnull ItemStack stack) {\n        return ImmutableList.copyOf(TargetedModule.getTargets(stack, false));\n    }\n\n    @Override\n    public TintColor getItemTint() {\n        return TINT_COLOR;\n    }\n\n    @Override\n    protected int getMaxTargets() {\n        return 8;\n    }\n\n    @Override\n    public int getRenderColor(int index) {\n        return 0x80B0FF90;\n    }\n\n    @Override\n    public int getEnergyCost(ItemStack stack) {\n        return MRConfig.Common.EnergyCosts.distributorModuleEnergyCost;\n    }\n}\n", "class_id": 0, "repo": "misny/ModularRouters", "file": "src/main/java/me/desht/modularrouters/item/module/DistributorModule.java", "last_update_at": "2021-10-17T13:37:38+00:00", "original_content": "public class DistributorModule extends SenderModule2 {\n\n    private static final TintColor TINT_COLOR = new TintColor(240, 240, 60);\n\n    public DistributorModule() {\n        super(CompiledDistributorModule::new);\n    }\n\n    @Override\n    public void addSettingsInformation(ItemStack itemstack, List<ITextComponent> list) {\n        super.addSettingsInformation(itemstack, list);\n        CompiledDistributorModule cdm = new CompiledDistributorModule(null, itemstack);\n        list.add(ClientUtil.xlate(\"modularrouters.guiText.tooltip.distributor.strategy\").append(\": \").withStyle(TextFormatting.YELLOW).append(ClientUtil.xlate(cdm.getDistributionStrategy().getTranslationKey())).withStyle(TextFormatting.AQUA));\n        list.add(ClientUtil.xlate(\"modularrouters.itemText.fluid.direction.\" + (cdm.isPulling() ? \"IN\" : \"OUT\")).withStyle(TextFormatting.YELLOW));\n    }\n\n    @Override\n    public ContainerType<? extends ContainerModule> getContainerType() {\n        return ModContainerTypes.CONTAINER_MODULE_DISTRIBUTOR.get();\n    }\n\n    @Override\n    public List<ModuleTarget> getStoredPositions(@Nonnull ItemStack stack) {\n        return ImmutableList.copyOf(TargetedModule.getTargets(stack, false));\n    }\n\n    @Override\n    public TintColor getItemTint() {\n        return TINT_COLOR;\n    }\n\n    @Override\n    protected int getMaxTargets() {\n        return 8;\n    }\n\n    @Override\n    public int getRenderColor(int index) {\n        return 0x80B0FF90;\n    }\n\n    @Override\n    public int getEnergyCost(ItemStack stack) {\n        return MRConfig.Common.EnergyCosts.distributorModuleEnergyCost;\n    }\n}\n", "refactored": false}
{"hexsha": "2015410f2622e7d62890cc961ff627e53cdbb9db", "ext": "java", "lang": "Java", "content": "public class AlertRuleRequest {\n\n    @JsonProperty(\"aggregationPeriod\")\n    private String aggregationPeriod = null;\n\n    /**\n     * Gets or Sets aggregationType\n     */\n    public enum AggregationTypeEnum {\n\n        COUNT(\"COUNT\"), AVG(\"AVG\"), SUM(\"SUM\"), MAX(\"MAX\"), MIN(\"MIN\");\n\n        private String value;\n\n        AggregationTypeEnum(String value) {\n            this.value = value;\n        }\n\n        @JsonValue\n        public String getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n\n        @JsonCreator\n        public static AggregationTypeEnum fromValue(String text) {\n            for (AggregationTypeEnum b : AggregationTypeEnum.values()) {\n                if (String.valueOf(b.value).equals(text)) {\n                    return b;\n                }\n            }\n            return null;\n        }\n    }\n\n    @JsonProperty(\"aggregationType\")\n    private AggregationTypeEnum aggregationType = null;\n\n    @JsonProperty(\"alertDestinationIds\")\n    private List<UUID> alertDestinationIds = null;\n\n    @JsonProperty(\"applicationIds\")\n    private List<UUID> applicationIds = null;\n\n    @JsonProperty(\"enabled\")\n    private Boolean enabled = null;\n\n    @JsonProperty(\"filterBy\")\n    private String filterBy = null;\n\n    @JsonProperty(\"groupByField\")\n    private String groupByField = null;\n\n    @JsonProperty(\"name\")\n    private String name = null;\n\n    @JsonProperty(\"riskLevel\")\n    private Integer riskLevel = null;\n\n    @JsonProperty(\"searchPeriod\")\n    private String searchPeriod = null;\n\n    @JsonProperty(\"tags\")\n    private List<String> tags = null;\n\n    /**\n     * Gets or Sets thresholdType\n     */\n    public enum ThresholdTypeEnum {\n\n        ABOVE(\"ABOVE\"), BELOW(\"BELOW\"), BOTH(\"BOTH\");\n\n        private String value;\n\n        ThresholdTypeEnum(String value) {\n            this.value = value;\n        }\n\n        @JsonValue\n        public String getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n\n        @JsonCreator\n        public static ThresholdTypeEnum fromValue(String text) {\n            for (ThresholdTypeEnum b : ThresholdTypeEnum.values()) {\n                if (String.valueOf(b.value).equals(text)) {\n                    return b;\n                }\n            }\n            return null;\n        }\n    }\n\n    @JsonProperty(\"thresholdType\")\n    private ThresholdTypeEnum thresholdType = null;\n\n    @JsonProperty(\"thresholdValue\")\n    private Double thresholdValue = null;\n\n    /**\n     * Gets or Sets type\n     */\n    public enum TypeEnum {\n\n        ST_DEV(\"ST_DEV\"), MEAN(\"MEAN\"), FIXED(\"FIXED\");\n\n        private String value;\n\n        TypeEnum(String value) {\n            this.value = value;\n        }\n\n        @JsonValue\n        public String getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n\n        @JsonCreator\n        public static TypeEnum fromValue(String text) {\n            for (TypeEnum b : TypeEnum.values()) {\n                if (String.valueOf(b.value).equals(text)) {\n                    return b;\n                }\n            }\n            return null;\n        }\n    }\n\n    @JsonProperty(\"type\")\n    private TypeEnum type = null;\n\n    public AlertRuleRequest aggregationPeriod(String aggregationPeriod) {\n        this.aggregationPeriod = aggregationPeriod;\n        return this;\n    }\n\n    /**\n     * Get aggregationPeriod\n     * @return aggregationPeriod\n     */\n    @ApiModelProperty(value = \"\")\n    public String getAggregationPeriod() {\n        return aggregationPeriod;\n    }\n\n    public void setAggregationPeriod(String aggregationPeriod) {\n        this.aggregationPeriod = aggregationPeriod;\n    }\n\n    public AlertRuleRequest aggregationType(AggregationTypeEnum aggregationType) {\n        this.aggregationType = aggregationType;\n        return this;\n    }\n\n    /**\n     * Get aggregationType\n     * @return aggregationType\n     */\n    @ApiModelProperty(value = \"\")\n    public AggregationTypeEnum getAggregationType() {\n        return aggregationType;\n    }\n\n    public void setAggregationType(AggregationTypeEnum aggregationType) {\n        this.aggregationType = aggregationType;\n    }\n\n    public AlertRuleRequest alertDestinationIds(List<UUID> alertDestinationIds) {\n        this.alertDestinationIds = alertDestinationIds;\n        return this;\n    }\n\n    public AlertRuleRequest addAlertDestinationIdsItem(UUID alertDestinationIdsItem) {\n        if (this.alertDestinationIds == null) {\n            this.alertDestinationIds = new ArrayList<>();\n        }\n        this.alertDestinationIds.add(alertDestinationIdsItem);\n        return this;\n    }\n\n    /**\n     * Get alertDestinationIds\n     * @return alertDestinationIds\n     */\n    @ApiModelProperty(value = \"\")\n    public List<UUID> getAlertDestinationIds() {\n        return alertDestinationIds;\n    }\n\n    public void setAlertDestinationIds(List<UUID> alertDestinationIds) {\n        this.alertDestinationIds = alertDestinationIds;\n    }\n\n    public AlertRuleRequest applicationIds(List<UUID> applicationIds) {\n        this.applicationIds = applicationIds;\n        return this;\n    }\n\n    public AlertRuleRequest addApplicationIdsItem(UUID applicationIdsItem) {\n        if (this.applicationIds == null) {\n            this.applicationIds = new ArrayList<>();\n        }\n        this.applicationIds.add(applicationIdsItem);\n        return this;\n    }\n\n    /**\n     * Get applicationIds\n     * @return applicationIds\n     */\n    @ApiModelProperty(value = \"\")\n    public List<UUID> getApplicationIds() {\n        return applicationIds;\n    }\n\n    public void setApplicationIds(List<UUID> applicationIds) {\n        this.applicationIds = applicationIds;\n    }\n\n    public AlertRuleRequest enabled(Boolean enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Get enabled\n     * @return enabled\n     */\n    @ApiModelProperty(value = \"\")\n    public Boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(Boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public AlertRuleRequest filterBy(String filterBy) {\n        this.filterBy = filterBy;\n        return this;\n    }\n\n    /**\n     * Get filterBy\n     * @return filterBy\n     */\n    @ApiModelProperty(value = \"\")\n    public String getFilterBy() {\n        return filterBy;\n    }\n\n    public void setFilterBy(String filterBy) {\n        this.filterBy = filterBy;\n    }\n\n    public AlertRuleRequest groupByField(String groupByField) {\n        this.groupByField = groupByField;\n        return this;\n    }\n\n    /**\n     * Get groupByField\n     * @return groupByField\n     */\n    @ApiModelProperty(value = \"\")\n    public String getGroupByField() {\n        return groupByField;\n    }\n\n    public void setGroupByField(String groupByField) {\n        this.groupByField = groupByField;\n    }\n\n    public AlertRuleRequest name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    /**\n     * Get name\n     * @return name\n     */\n    @ApiModelProperty(value = \"\")\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public AlertRuleRequest riskLevel(Integer riskLevel) {\n        this.riskLevel = riskLevel;\n        return this;\n    }\n\n    /**\n     * Get riskLevel\n     * @return riskLevel\n     */\n    @ApiModelProperty(value = \"\")\n    public Integer getRiskLevel() {\n        return riskLevel;\n    }\n\n    public void setRiskLevel(Integer riskLevel) {\n        this.riskLevel = riskLevel;\n    }\n\n    public AlertRuleRequest searchPeriod(String searchPeriod) {\n        this.searchPeriod = searchPeriod;\n        return this;\n    }\n\n    /**\n     * Get searchPeriod\n     * @return searchPeriod\n     */\n    @ApiModelProperty(value = \"\")\n    public String getSearchPeriod() {\n        return searchPeriod;\n    }\n\n    public void setSearchPeriod(String searchPeriod) {\n        this.searchPeriod = searchPeriod;\n    }\n\n    public AlertRuleRequest tags(List<String> tags) {\n        this.tags = tags;\n        return this;\n    }\n\n    public AlertRuleRequest addTagsItem(String tagsItem) {\n        if (this.tags == null) {\n            this.tags = new ArrayList<>();\n        }\n        this.tags.add(tagsItem);\n        return this;\n    }\n\n    /**\n     * Get tags\n     * @return tags\n     */\n    @ApiModelProperty(value = \"\")\n    public List<String> getTags() {\n        return tags;\n    }\n\n    public void setTags(List<String> tags) {\n        this.tags = tags;\n    }\n\n    public AlertRuleRequest thresholdType(ThresholdTypeEnum thresholdType) {\n        this.thresholdType = thresholdType;\n        return this;\n    }\n\n    /**\n     * Get thresholdType\n     * @return thresholdType\n     */\n    @ApiModelProperty(value = \"\")\n    public ThresholdTypeEnum getThresholdType() {\n        return thresholdType;\n    }\n\n    public void setThresholdType(ThresholdTypeEnum thresholdType) {\n        this.thresholdType = thresholdType;\n    }\n\n    public AlertRuleRequest thresholdValue(Double thresholdValue) {\n        this.thresholdValue = thresholdValue;\n        return this;\n    }\n\n    /**\n     * Get thresholdValue\n     * @return thresholdValue\n     */\n    @ApiModelProperty(value = \"\")\n    public Double getThresholdValue() {\n        return thresholdValue;\n    }\n\n    public void setThresholdValue(Double thresholdValue) {\n        this.thresholdValue = thresholdValue;\n    }\n\n    public AlertRuleRequest type(TypeEnum type) {\n        this.type = type;\n        return this;\n    }\n\n    /**\n     * Get type\n     * @return type\n     */\n    @ApiModelProperty(value = \"\")\n    public TypeEnum getType() {\n        return type;\n    }\n\n    public void setType(TypeEnum type) {\n        this.type = type;\n    }\n\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        AlertRuleRequest alertRuleRequest = (AlertRuleRequest) o;\n        return Objects.equals(this.aggregationPeriod, alertRuleRequest.aggregationPeriod) && Objects.equals(this.aggregationType, alertRuleRequest.aggregationType) && Objects.equals(this.alertDestinationIds, alertRuleRequest.alertDestinationIds) && Objects.equals(this.applicationIds, alertRuleRequest.applicationIds) && Objects.equals(this.enabled, alertRuleRequest.enabled) && Objects.equals(this.filterBy, alertRuleRequest.filterBy) && Objects.equals(this.groupByField, alertRuleRequest.groupByField) && Objects.equals(this.name, alertRuleRequest.name) && Objects.equals(this.riskLevel, alertRuleRequest.riskLevel) && Objects.equals(this.searchPeriod, alertRuleRequest.searchPeriod) && Objects.equals(this.tags, alertRuleRequest.tags) && Objects.equals(this.thresholdType, alertRuleRequest.thresholdType) && Objects.equals(this.thresholdValue, alertRuleRequest.thresholdValue) && Objects.equals(this.type, alertRuleRequest.type);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(aggregationPeriod, aggregationType, alertDestinationIds, applicationIds, enabled, filterBy, groupByField, name, riskLevel, searchPeriod, tags, thresholdType, thresholdValue, type);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class AlertRuleRequest {\\n\");\n        sb.append(\"    aggregationPeriod: \").append(toIndentedString(aggregationPeriod)).append(\"\\n\");\n        sb.append(\"    aggregationType: \").append(toIndentedString(aggregationType)).append(\"\\n\");\n        sb.append(\"    alertDestinationIds: \").append(toIndentedString(alertDestinationIds)).append(\"\\n\");\n        sb.append(\"    applicationIds: \").append(toIndentedString(applicationIds)).append(\"\\n\");\n        sb.append(\"    enabled: \").append(toIndentedString(enabled)).append(\"\\n\");\n        sb.append(\"    filterBy: \").append(toIndentedString(filterBy)).append(\"\\n\");\n        sb.append(\"    groupByField: \").append(toIndentedString(groupByField)).append(\"\\n\");\n        sb.append(\"    name: \").append(toIndentedString(name)).append(\"\\n\");\n        sb.append(\"    riskLevel: \").append(toIndentedString(riskLevel)).append(\"\\n\");\n        sb.append(\"    searchPeriod: \").append(toIndentedString(searchPeriod)).append(\"\\n\");\n        sb.append(\"    tags: \").append(toIndentedString(tags)).append(\"\\n\");\n        sb.append(\"    thresholdType: \").append(toIndentedString(thresholdType)).append(\"\\n\");\n        sb.append(\"    thresholdValue: \").append(toIndentedString(thresholdValue)).append(\"\\n\");\n        sb.append(\"    type: \").append(toIndentedString(type)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "class_id": 0, "repo": "LogSentinel/logsentinel-java-api", "file": "src/main/java/com/logsentinel/model/AlertRuleRequest.java", "last_update_at": "2021-05-14T10:05:46+00:00", "original_content": "public class AlertRuleRequest {\n\n    @JsonProperty(\"aggregationPeriod\")\n    private String aggregationPeriod = null;\n\n    /**\n     * Gets or Sets aggregationType\n     */\n    public enum AggregationTypeEnum {\n\n        COUNT(\"COUNT\"), AVG(\"AVG\"), SUM(\"SUM\"), MAX(\"MAX\"), MIN(\"MIN\");\n\n        private String value;\n\n        AggregationTypeEnum(String value) {\n            this.value = value;\n        }\n\n        @JsonValue\n        public String getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n\n        @JsonCreator\n        public static AggregationTypeEnum fromValue(String text) {\n            for (AggregationTypeEnum b : AggregationTypeEnum.values()) {\n                if (String.valueOf(b.value).equals(text)) {\n                    return b;\n                }\n            }\n            return null;\n        }\n    }\n\n    @JsonProperty(\"aggregationType\")\n    private AggregationTypeEnum aggregationType = null;\n\n    @JsonProperty(\"alertDestinationIds\")\n    private List<UUID> alertDestinationIds = null;\n\n    @JsonProperty(\"applicationIds\")\n    private List<UUID> applicationIds = null;\n\n    @JsonProperty(\"enabled\")\n    private Boolean enabled = null;\n\n    @JsonProperty(\"filterBy\")\n    private String filterBy = null;\n\n    @JsonProperty(\"groupByField\")\n    private String groupByField = null;\n\n    @JsonProperty(\"name\")\n    private String name = null;\n\n    @JsonProperty(\"riskLevel\")\n    private Integer riskLevel = null;\n\n    @JsonProperty(\"searchPeriod\")\n    private String searchPeriod = null;\n\n    @JsonProperty(\"tags\")\n    private List<String> tags = null;\n\n    /**\n     * Gets or Sets thresholdType\n     */\n    public enum ThresholdTypeEnum {\n\n        ABOVE(\"ABOVE\"), BELOW(\"BELOW\"), BOTH(\"BOTH\");\n\n        private String value;\n\n        ThresholdTypeEnum(String value) {\n            this.value = value;\n        }\n\n        @JsonValue\n        public String getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n\n        @JsonCreator\n        public static ThresholdTypeEnum fromValue(String text) {\n            for (ThresholdTypeEnum b : ThresholdTypeEnum.values()) {\n                if (String.valueOf(b.value).equals(text)) {\n                    return b;\n                }\n            }\n            return null;\n        }\n    }\n\n    @JsonProperty(\"thresholdType\")\n    private ThresholdTypeEnum thresholdType = null;\n\n    @JsonProperty(\"thresholdValue\")\n    private Double thresholdValue = null;\n\n    /**\n     * Gets or Sets type\n     */\n    public enum TypeEnum {\n\n        ST_DEV(\"ST_DEV\"), MEAN(\"MEAN\"), FIXED(\"FIXED\");\n\n        private String value;\n\n        TypeEnum(String value) {\n            this.value = value;\n        }\n\n        @JsonValue\n        public String getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(value);\n        }\n\n        @JsonCreator\n        public static TypeEnum fromValue(String text) {\n            for (TypeEnum b : TypeEnum.values()) {\n                if (String.valueOf(b.value).equals(text)) {\n                    return b;\n                }\n            }\n            return null;\n        }\n    }\n\n    @JsonProperty(\"type\")\n    private TypeEnum type = null;\n\n    public AlertRuleRequest aggregationPeriod(String aggregationPeriod) {\n        this.aggregationPeriod = aggregationPeriod;\n        return this;\n    }\n\n    /**\n     * Get aggregationPeriod\n     * @return aggregationPeriod\n     */\n    @ApiModelProperty(value = \"\")\n    public String getAggregationPeriod() {\n        return aggregationPeriod;\n    }\n\n    public void setAggregationPeriod(String aggregationPeriod) {\n        this.aggregationPeriod = aggregationPeriod;\n    }\n\n    public AlertRuleRequest aggregationType(AggregationTypeEnum aggregationType) {\n        this.aggregationType = aggregationType;\n        return this;\n    }\n\n    /**\n     * Get aggregationType\n     * @return aggregationType\n     */\n    @ApiModelProperty(value = \"\")\n    public AggregationTypeEnum getAggregationType() {\n        return aggregationType;\n    }\n\n    public void setAggregationType(AggregationTypeEnum aggregationType) {\n        this.aggregationType = aggregationType;\n    }\n\n    public AlertRuleRequest alertDestinationIds(List<UUID> alertDestinationIds) {\n        this.alertDestinationIds = alertDestinationIds;\n        return this;\n    }\n\n    public AlertRuleRequest addAlertDestinationIdsItem(UUID alertDestinationIdsItem) {\n        if (this.alertDestinationIds == null) {\n            this.alertDestinationIds = new ArrayList<>();\n        }\n        this.alertDestinationIds.add(alertDestinationIdsItem);\n        return this;\n    }\n\n    /**\n     * Get alertDestinationIds\n     * @return alertDestinationIds\n     */\n    @ApiModelProperty(value = \"\")\n    public List<UUID> getAlertDestinationIds() {\n        return alertDestinationIds;\n    }\n\n    public void setAlertDestinationIds(List<UUID> alertDestinationIds) {\n        this.alertDestinationIds = alertDestinationIds;\n    }\n\n    public AlertRuleRequest applicationIds(List<UUID> applicationIds) {\n        this.applicationIds = applicationIds;\n        return this;\n    }\n\n    public AlertRuleRequest addApplicationIdsItem(UUID applicationIdsItem) {\n        if (this.applicationIds == null) {\n            this.applicationIds = new ArrayList<>();\n        }\n        this.applicationIds.add(applicationIdsItem);\n        return this;\n    }\n\n    /**\n     * Get applicationIds\n     * @return applicationIds\n     */\n    @ApiModelProperty(value = \"\")\n    public List<UUID> getApplicationIds() {\n        return applicationIds;\n    }\n\n    public void setApplicationIds(List<UUID> applicationIds) {\n        this.applicationIds = applicationIds;\n    }\n\n    public AlertRuleRequest enabled(Boolean enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Get enabled\n     * @return enabled\n     */\n    @ApiModelProperty(value = \"\")\n    public Boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(Boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public AlertRuleRequest filterBy(String filterBy) {\n        this.filterBy = filterBy;\n        return this;\n    }\n\n    /**\n     * Get filterBy\n     * @return filterBy\n     */\n    @ApiModelProperty(value = \"\")\n    public String getFilterBy() {\n        return filterBy;\n    }\n\n    public void setFilterBy(String filterBy) {\n        this.filterBy = filterBy;\n    }\n\n    public AlertRuleRequest groupByField(String groupByField) {\n        this.groupByField = groupByField;\n        return this;\n    }\n\n    /**\n     * Get groupByField\n     * @return groupByField\n     */\n    @ApiModelProperty(value = \"\")\n    public String getGroupByField() {\n        return groupByField;\n    }\n\n    public void setGroupByField(String groupByField) {\n        this.groupByField = groupByField;\n    }\n\n    public AlertRuleRequest name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    /**\n     * Get name\n     * @return name\n     */\n    @ApiModelProperty(value = \"\")\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public AlertRuleRequest riskLevel(Integer riskLevel) {\n        this.riskLevel = riskLevel;\n        return this;\n    }\n\n    /**\n     * Get riskLevel\n     * @return riskLevel\n     */\n    @ApiModelProperty(value = \"\")\n    public Integer getRiskLevel() {\n        return riskLevel;\n    }\n\n    public void setRiskLevel(Integer riskLevel) {\n        this.riskLevel = riskLevel;\n    }\n\n    public AlertRuleRequest searchPeriod(String searchPeriod) {\n        this.searchPeriod = searchPeriod;\n        return this;\n    }\n\n    /**\n     * Get searchPeriod\n     * @return searchPeriod\n     */\n    @ApiModelProperty(value = \"\")\n    public String getSearchPeriod() {\n        return searchPeriod;\n    }\n\n    public void setSearchPeriod(String searchPeriod) {\n        this.searchPeriod = searchPeriod;\n    }\n\n    public AlertRuleRequest tags(List<String> tags) {\n        this.tags = tags;\n        return this;\n    }\n\n    public AlertRuleRequest addTagsItem(String tagsItem) {\n        if (this.tags == null) {\n            this.tags = new ArrayList<>();\n        }\n        this.tags.add(tagsItem);\n        return this;\n    }\n\n    /**\n     * Get tags\n     * @return tags\n     */\n    @ApiModelProperty(value = \"\")\n    public List<String> getTags() {\n        return tags;\n    }\n\n    public void setTags(List<String> tags) {\n        this.tags = tags;\n    }\n\n    public AlertRuleRequest thresholdType(ThresholdTypeEnum thresholdType) {\n        this.thresholdType = thresholdType;\n        return this;\n    }\n\n    /**\n     * Get thresholdType\n     * @return thresholdType\n     */\n    @ApiModelProperty(value = \"\")\n    public ThresholdTypeEnum getThresholdType() {\n        return thresholdType;\n    }\n\n    public void setThresholdType(ThresholdTypeEnum thresholdType) {\n        this.thresholdType = thresholdType;\n    }\n\n    public AlertRuleRequest thresholdValue(Double thresholdValue) {\n        this.thresholdValue = thresholdValue;\n        return this;\n    }\n\n    /**\n     * Get thresholdValue\n     * @return thresholdValue\n     */\n    @ApiModelProperty(value = \"\")\n    public Double getThresholdValue() {\n        return thresholdValue;\n    }\n\n    public void setThresholdValue(Double thresholdValue) {\n        this.thresholdValue = thresholdValue;\n    }\n\n    public AlertRuleRequest type(TypeEnum type) {\n        this.type = type;\n        return this;\n    }\n\n    /**\n     * Get type\n     * @return type\n     */\n    @ApiModelProperty(value = \"\")\n    public TypeEnum getType() {\n        return type;\n    }\n\n    public void setType(TypeEnum type) {\n        this.type = type;\n    }\n\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        AlertRuleRequest alertRuleRequest = (AlertRuleRequest) o;\n        return Objects.equals(this.aggregationPeriod, alertRuleRequest.aggregationPeriod) && Objects.equals(this.aggregationType, alertRuleRequest.aggregationType) && Objects.equals(this.alertDestinationIds, alertRuleRequest.alertDestinationIds) && Objects.equals(this.applicationIds, alertRuleRequest.applicationIds) && Objects.equals(this.enabled, alertRuleRequest.enabled) && Objects.equals(this.filterBy, alertRuleRequest.filterBy) && Objects.equals(this.groupByField, alertRuleRequest.groupByField) && Objects.equals(this.name, alertRuleRequest.name) && Objects.equals(this.riskLevel, alertRuleRequest.riskLevel) && Objects.equals(this.searchPeriod, alertRuleRequest.searchPeriod) && Objects.equals(this.tags, alertRuleRequest.tags) && Objects.equals(this.thresholdType, alertRuleRequest.thresholdType) && Objects.equals(this.thresholdValue, alertRuleRequest.thresholdValue) && Objects.equals(this.type, alertRuleRequest.type);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(aggregationPeriod, aggregationType, alertDestinationIds, applicationIds, enabled, filterBy, groupByField, name, riskLevel, searchPeriod, tags, thresholdType, thresholdValue, type);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class AlertRuleRequest {\\n\");\n        sb.append(\"    aggregationPeriod: \").append(toIndentedString(aggregationPeriod)).append(\"\\n\");\n        sb.append(\"    aggregationType: \").append(toIndentedString(aggregationType)).append(\"\\n\");\n        sb.append(\"    alertDestinationIds: \").append(toIndentedString(alertDestinationIds)).append(\"\\n\");\n        sb.append(\"    applicationIds: \").append(toIndentedString(applicationIds)).append(\"\\n\");\n        sb.append(\"    enabled: \").append(toIndentedString(enabled)).append(\"\\n\");\n        sb.append(\"    filterBy: \").append(toIndentedString(filterBy)).append(\"\\n\");\n        sb.append(\"    groupByField: \").append(toIndentedString(groupByField)).append(\"\\n\");\n        sb.append(\"    name: \").append(toIndentedString(name)).append(\"\\n\");\n        sb.append(\"    riskLevel: \").append(toIndentedString(riskLevel)).append(\"\\n\");\n        sb.append(\"    searchPeriod: \").append(toIndentedString(searchPeriod)).append(\"\\n\");\n        sb.append(\"    tags: \").append(toIndentedString(tags)).append(\"\\n\");\n        sb.append(\"    thresholdType: \").append(toIndentedString(thresholdType)).append(\"\\n\");\n        sb.append(\"    thresholdValue: \").append(toIndentedString(thresholdValue)).append(\"\\n\");\n        sb.append(\"    type: \").append(toIndentedString(type)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "refactored": false}
{"hexsha": "086569103dfc31b2649c3f12a6338fcfe2ef52d3", "ext": "java", "lang": "Java", "content": "public class LogModule extends PrivateModule {\n\n    private final File logDirectory;\n\n    private final StateMachine stateMachine;\n\n    private final Executor executor;\n\n    public LogModule(@Nonnull File logDirectory, @Nonnull StateMachine stateMachine, @Nonnull Executor executor) {\n        this.logDirectory = checkNotNull(logDirectory);\n        this.stateMachine = checkNotNull(stateMachine);\n        this.executor = checkNotNull(executor);\n    }\n\n    @Override\n    protected void configure() {\n        bind(StateMachine.class).toInstance(stateMachine);\n        bind(StateMachineProxy.class);\n        bind(Executor.class).annotatedWith(StateExecutor.class).toInstance(executor);\n        bind(RaftLog.class).asEagerSingleton();\n        expose(RaftLog.class);\n    }\n\n    @Nonnull\n    @Provides\n    @Singleton\n    Journal getJournal() {\n        try {\n            final Journal journal = JournalBuilder.of(logDirectory).setPhysicalSync(true).open();\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                //noinspection EmptyCatchBlock\n                try {\n                    journal.close();\n                } catch (IOException e) {\n                }\n            }));\n            return journal;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "class_id": 0, "repo": "mgodave/barge", "file": "barge-core/src/main/java/org/robotninjas/barge/log/LogModule.java", "last_update_at": "2021-11-06T08:38:03+00:00", "original_content": "public class LogModule extends PrivateModule {\n\n    private final File logDirectory;\n\n    private final StateMachine stateMachine;\n\n    private final Executor executor;\n\n    public LogModule(@Nonnull File logDirectory, @Nonnull StateMachine stateMachine, @Nonnull Executor executor) {\n        this.logDirectory = checkNotNull(logDirectory);\n        this.stateMachine = checkNotNull(stateMachine);\n        this.executor = checkNotNull(executor);\n    }\n\n    @Override\n    protected void configure() {\n        bind(StateMachine.class).toInstance(stateMachine);\n        bind(StateMachineProxy.class);\n        bind(Executor.class).annotatedWith(StateExecutor.class).toInstance(executor);\n        bind(RaftLog.class).asEagerSingleton();\n        expose(RaftLog.class);\n    }\n\n    @Nonnull\n    @Provides\n    @Singleton\n    Journal getJournal() {\n        try {\n            final Journal journal = JournalBuilder.of(logDirectory).setPhysicalSync(true).open();\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                //noinspection EmptyCatchBlock\n                try {\n                    journal.close();\n                } catch (IOException e) {\n                }\n            }));\n            return journal;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "d11a112c80b51a47725f96971f69f14f8a4af6d6", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"service_info\")\npublic class ServiceInfo implements Serializable {\n\n    private static final long serialVersionUID = 768026109321305392L;\n\n    @Id\n    @BusinessKey\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\")\n    private Integer id;\n\n    @Column(name = \"SERVICE_INPUT\")\n    private String serviceInput;\n\n    @Column(name = \"SERVICE_PROPERTIES\")\n    private String serviceProperties;\n\n    @ManyToOne(cascade = CascadeType.ALL)\n    @JoinColumn(name = \"SERVICE_MODEL_UUID\")\n    private Service service;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer serviceInfoId) {\n        this.id = serviceInfoId;\n    }\n\n    public String getServiceInput() {\n        return serviceInput;\n    }\n\n    public void setServiceInput(String serviceInput) {\n        this.serviceInput = serviceInput;\n    }\n\n    public String getServiceProperties() {\n        return serviceProperties;\n    }\n\n    public void setServiceProperties(String serviceProperties) {\n        this.serviceProperties = serviceProperties;\n    }\n\n    @LinkedResource\n    public Service getService() {\n        return service;\n    }\n\n    public void setService(Service service) {\n        this.service = service;\n    }\n\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this).append(\"id\", id).append(\"serviceProperties\", serviceProperties).append(\"serviceInput\", serviceInput).toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ServiceInfo that = (ServiceInfo) o;\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n", "class_id": 0, "repo": "sharmajiii/so", "file": "mso-catalog-db/src/main/java/org/onap/so/db/catalog/beans/ServiceInfo.java", "last_update_at": "2021-10-15T15:01:14+00:00", "original_content": "@Entity\n@Table(name = \"service_info\")\npublic class ServiceInfo implements Serializable {\n\n    private static final long serialVersionUID = 768026109321305392L;\n\n    @Id\n    @BusinessKey\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\")\n    private Integer id;\n\n    @Column(name = \"SERVICE_INPUT\")\n    private String serviceInput;\n\n    @Column(name = \"SERVICE_PROPERTIES\")\n    private String serviceProperties;\n\n    @ManyToOne(cascade = CascadeType.ALL)\n    @JoinColumn(name = \"SERVICE_MODEL_UUID\")\n    private Service service;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer serviceInfoId) {\n        this.id = serviceInfoId;\n    }\n\n    public String getServiceInput() {\n        return serviceInput;\n    }\n\n    public void setServiceInput(String serviceInput) {\n        this.serviceInput = serviceInput;\n    }\n\n    public String getServiceProperties() {\n        return serviceProperties;\n    }\n\n    public void setServiceProperties(String serviceProperties) {\n        this.serviceProperties = serviceProperties;\n    }\n\n    @LinkedResource\n    public Service getService() {\n        return service;\n    }\n\n    public void setService(Service service) {\n        this.service = service;\n    }\n\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this).append(\"id\", id).append(\"serviceProperties\", serviceProperties).append(\"serviceInput\", serviceInput).toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ServiceInfo that = (ServiceInfo) o;\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n", "refactored": false}
{"hexsha": "e622e9d58ce211f568a1cb75a3cb263859d636e1", "ext": "java", "lang": "Java", "content": "@Name(\"pythonpaths\")\n@Summary(\"A utility command to manage system installed and manually registered python binaries.\")\n@Description(\"A utility command to manage system installed and manually registered python binaries. Python binaries \" + \"could be from either a regular python install, through a conda environment, javacpp cpython or a virtual \" + \"environment through 'venv' package. Each python installation has been assigned a particular id and a \" + \"specific type which ultimately identifies which python installation is going to be used with a particular \" + \"PythonStep configuration. You can also register a python binary if it's not listed through 'pythonpaths add' \" + \"subcommand. \\n\\n\" + \"Example usages:\\n\" + \"--------------\\n\" + \"- Lists all the installed and registered python binaries:\\n\" + \"$ konduit pythonpaths list \\n\\n\" + \"- Lists python installs with their included packages:\\n\" + \"$ konduit pythonpaths -wip \\n\\n\" + \"- Register a custom python installation:\\n\" + \"$ konduit pythonpaths add -t=python -p=E:\\\\python37\\\\python.exe \\n\" + \"--------------\")\n@Slf4j\npublic class PythonPathsCommand extends DefaultCommand {\n\n    private SubCommand subCommand;\n\n    private Object type;\n\n    private String path;\n\n    private boolean withInstalledPackages;\n\n    @Argument(index = 0, argName = \"sub_command\", required = false)\n    @DefaultValue(\"LIST\")\n    @Description(\"Sub command to be used with the pythonpaths command. Sub commands are: [add, list, config]. \" + \"Defaults to 'LIST'\")\n    public void setSubCommand(String subCommand) {\n        try {\n            this.subCommand = PythonPathsCommand.SubCommand.valueOf(subCommand.toUpperCase());\n        } catch (Exception e) {\n            System.out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n            System.exit(1);\n        }\n    }\n\n    @Option(shortName = \"t\", longName = \"type\", argName = \"type\", required = true)\n    @Description(\"Name of the python type. For the 'add' subcommand, accepted values are: [python, conda, venv]. \" + \"For the 'list' subcommand, accepted values are: [all, javacpp, python, conda, venv]. \" + \"For 'config' subcommand the accepted values are: [custom, javacpp, python, conda, venv]\")\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    @Option(shortName = \"p\", longName = \"path\", argName = \"install_path\")\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" + \"of the root installation folder.\")\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    @Option(shortName = \"wip\", longName = \"with-installed-packages\", flag = true)\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" + \"of the root installation folder.\")\n    public void setPath(boolean withInstalledPackages) {\n        this.withInstalledPackages = withInstalledPackages;\n    }\n\n    private enum SubCommand {\n\n        ADD, LIST, CONFIG\n    }\n\n    public enum ListInstallationType {\n\n        ALL, JAVACPP, PYTHON, CONDA, VENV\n    }\n\n    @Override\n    public void run() {\n        switch(this.subCommand) {\n            case ADD:\n                try {\n                    this.type = PythonType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\", type, Arrays.toString(PythonType.values()));\n                    System.exit(1);\n                }\n                break;\n            case CONFIG:\n                try {\n                    this.type = PythonConfigType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\", type, Arrays.toString(PythonConfigType.values()));\n                    System.exit(1);\n                }\n                break;\n            case LIST:\n                try {\n                    this.type = PythonPathsCommand.ListInstallationType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\", type, Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n                    System.exit(1);\n                }\n                break;\n            default:\n                out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n        switch(this.subCommand) {\n            case ADD:\n                registerInstallation((PythonType) type, path);\n                break;\n            case LIST:\n                listInstallations((ListInstallationType) type, withInstalledPackages);\n                break;\n            case CONFIG:\n                createConfig((PythonConfigType) type);\n                break;\n            default:\n                log.error(\"Invalid sub command name: {}. Allowed values are: {} -> (case insensitive).\", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n    }\n\n    private void createConfig(PythonConfigType pythonConfigType) {\n        throw new UnsupportedOperationException(\"This will be implemented in a continuation PR\");\n    }\n\n    public static void listInstallations(ListInstallationType type, boolean withInstalledPackages) {\n        switch(type) {\n            case ALL:\n                listJavacppInstallations(withInstalledPackages);\n                listPythonInstallations(withInstalledPackages);\n                listCondaInstallations(withInstalledPackages);\n                listVenvInstallations(withInstalledPackages);\n                break;\n            case JAVACPP:\n                listJavacppInstallations(withInstalledPackages);\n                break;\n            case PYTHON:\n                listPythonInstallations(withInstalledPackages);\n                break;\n            case CONDA:\n                listCondaInstallations(withInstalledPackages);\n                break;\n            case VENV:\n                listVenvInstallations(withInstalledPackages);\n                break;\n            default:\n                System.out.format(\"Invalid installation type name: '%s'. Allowed values are: %s -> (case insensitive).\", type.name(), Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n        }\n    }\n\n    private static void listJavacppInstallations(boolean withInstalledPackages) {\n        JavaCppDetails javaCppDetails = getJavaCppDetails();\n        System.out.println(\"\\n----------------------------JAVACPP INSTALLS---------------------------\");\n        System.out.print(formatPythonInstallation(new PythonDetails(javaCppDetails.id(), javaCppDetails.path(), javaCppDetails.version()), false));\n        if (!withInstalledPackages) {\n            System.out.println(\"\\n-----------------------------------------------------------------------\");\n        } else {\n            System.out.println(\"\\t--------Installed Modules--------\");\n            printJavaCppInstalledModules();\n            System.out.println(\"\\t---------------------------------\");\n            System.out.println(\"-----------------------------------------------------------------------\");\n        }\n    }\n\n    public static JavaCppDetails getJavaCppDetails() {\n        try {\n            Py_AddPath(cachePackages());\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);\n            /* optional but recommended */\n            Py_Initialize();\n            PyObject globals = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n            PyRun_StringFlags(\"import os, sys; \" + \"executable = os.path.abspath(os.path.join(os.__file__, '..', '..')) + ' (embedded python)'; \" + \"version = sys.version.split(' ')[0]\", Py_single_input, globals, null, null);\n            JavaCppDetails javaCppDetails = new JavaCppDetails(\"0\", getStringFromPythonObject(PyDict_GetItemString(globals, \"executable\")), getStringFromPythonObject(PyDict_GetItemString(globals, \"version\")) + System.lineSeparator());\n            PyMem_RawFree(program);\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n            return javaCppDetails;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n            return null;\n        }\n    }\n\n    private static void listPythonInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------PYTHON INSTALLS----------------------------\");\n        System.out.print(findPythonInstallations().stream().map(pythonDetails -> formatPythonInstallation(pythonDetails, withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static void listCondaInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------CONDA INSTALLS-----------------------------\");\n        System.out.print(findCondaInstallations().stream().map(condaDetails -> formatCondaInstallation(condaDetails, withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static String formatPythonInstallation(PythonDetails pythonDetails, boolean withInstalledPackages) {\n        return formatPythonInstallation(pythonDetails, 1, withInstalledPackages);\n    }\n\n    private static String formatPythonInstallation(PythonDetails pythonDetails, int numberOfTabs, boolean withInstalledPackages) {\n        String tabs = IntStream.range(0, numberOfTabs).mapToObj(index -> \"\\t\").collect(Collectors.joining(\"\"));\n        return String.format(\" -%s%s: %s%n%spath: %s%n%sversion: %s%s\", \"\\t\", numberOfTabs > 1 ? \"name\" : \"id\", pythonDetails.id(), tabs, pythonDetails.path(), tabs, pythonDetails.version(), withInstalledPackages ? String.format(\"%s--------Installed Modules--------%n%s%n%s---------------------------------%n\", tabs, Arrays.stream(ProcessUtils.runAndGetOutput(pythonDetails.path(), \"-c\", \"from pip import _internal; _internal.main(['list'])\").split(System.lineSeparator())).map(line -> String.format(\"%s- %s\", tabs, line)).collect(Collectors.joining(System.lineSeparator())), tabs) : \"\");\n    }\n\n    private static void printJavaCppInstalledModules() {\n        try {\n            Py_AddPath(cachePackages());\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);\n            /* optional but recommended */\n            Py_Initialize();\n            PyRun_SimpleStringFlags(\"from pip import _internal\\n\" + \"import warnings\\n\" + \"warnings.filterwarnings(action='ignore')\\n\" + \"class writer :\\n\" + \"    def __init__(self, *writers) :\\n\" + \"        self.writers = writers\\n\" + \"\\n\" + \"    def write(self, text) :\\n\" + \"        for w in self.writers :\\n\" + \"            w.write('\\t- ' + text)\\n\" + \"\\n\" + \"    def flush(self):\\n\" + \"        pass\\n\" + \"import sys\\n\" + \"sys.stdout = writer(sys.stdout)\\n\" + \"installed_modules = _internal.main(['list'])\", null);\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n            PyMem_RawFree(program);\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n        }\n    }\n\n    private static String formatCondaInstallation(CondaDetails condaDetails, boolean withInstalledPackages) {\n        List<String> formattedCondaEnvironments = new ArrayList<>();\n        condaDetails.environments().forEach(pythonDetails -> formattedCondaEnvironments.add(formatPythonInstallation(pythonDetails, 2, withInstalledPackages)));\n        return String.format(\" -\\tid: %s%n\\tpath: %s%n\\tversion: %s%s\", condaDetails.id(), condaDetails.path(), condaDetails.version(), String.format(\"\\t--------------------------ENVIRONMENTS-------------------------%n\" + \"\\t%s\" + \"\\t---------------------------------------------------------------%n\", String.join(System.lineSeparator() + \"\\t\", formattedCondaEnvironments)));\n    }\n\n    private static void listVenvInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n-----------------------------VENV INSTALLS-----------------------------\");\n        System.out.print(findVenvInstallations().stream().map(venvDetails -> formatPythonInstallation(new PythonDetails(venvDetails.id(), venvDetails.path(), venvDetails.version()), withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static String getStringFromPythonObject(PyObject pythonObject) {\n        PyObject pythonEncodedString = PyUnicode_AsEncodedString(pythonObject, \"utf-8\", \"~E~\");\n        String javaString = PyBytes_AsString(pythonEncodedString).getString();\n        Py_DecRef(pythonEncodedString);\n        return javaString;\n    }\n}\n", "class_id": 0, "repo": "KonduitAI/konduit-serving", "file": "konduit-serving-cli/src/main/java/ai/konduit/serving/cli/launcher/command/build/extension/PythonPathsCommand.java", "last_update_at": "2021-12-16T08:27:01+00:00", "original_content": "@Name(\"pythonpaths\")\n@Summary(\"A utility command to manage system installed and manually registered python binaries.\")\n@Description(\"A utility command to manage system installed and manually registered python binaries. Python binaries \" + \"could be from either a regular python install, through a conda environment, javacpp cpython or a virtual \" + \"environment through 'venv' package. Each python installation has been assigned a particular id and a \" + \"specific type which ultimately identifies which python installation is going to be used with a particular \" + \"PythonStep configuration. You can also register a python binary if it's not listed through 'pythonpaths add' \" + \"subcommand. \\n\\n\" + \"Example usages:\\n\" + \"--------------\\n\" + \"- Lists all the installed and registered python binaries:\\n\" + \"$ konduit pythonpaths list \\n\\n\" + \"- Lists python installs with their included packages:\\n\" + \"$ konduit pythonpaths -wip \\n\\n\" + \"- Register a custom python installation:\\n\" + \"$ konduit pythonpaths add -t=python -p=E:\\\\python37\\\\python.exe \\n\" + \"--------------\")\n@Slf4j\npublic class PythonPathsCommand extends DefaultCommand {\n\n    private SubCommand subCommand;\n\n    private Object type;\n\n    private String path;\n\n    private boolean withInstalledPackages;\n\n    @Argument(index = 0, argName = \"sub_command\", required = false)\n    @DefaultValue(\"LIST\")\n    @Description(\"Sub command to be used with the pythonpaths command. Sub commands are: [add, list, config]. \" + \"Defaults to 'LIST'\")\n    public void setSubCommand(String subCommand) {\n        try {\n            this.subCommand = PythonPathsCommand.SubCommand.valueOf(subCommand.toUpperCase());\n        } catch (Exception e) {\n            System.out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n            System.exit(1);\n        }\n    }\n\n    @Option(shortName = \"t\", longName = \"type\", argName = \"type\", required = true)\n    @Description(\"Name of the python type. For the 'add' subcommand, accepted values are: [python, conda, venv]. \" + \"For the 'list' subcommand, accepted values are: [all, javacpp, python, conda, venv]. \" + \"For 'config' subcommand the accepted values are: [custom, javacpp, python, conda, venv]\")\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    @Option(shortName = \"p\", longName = \"path\", argName = \"install_path\")\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" + \"of the root installation folder.\")\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    @Option(shortName = \"wip\", longName = \"with-installed-packages\", flag = true)\n    @Description(\"Absolute path of the python installation. For conda and venv types this refers to the absolute path \" + \"of the root installation folder.\")\n    public void setPath(boolean withInstalledPackages) {\n        this.withInstalledPackages = withInstalledPackages;\n    }\n\n    private enum SubCommand {\n\n        ADD, LIST, CONFIG\n    }\n\n    public enum ListInstallationType {\n\n        ALL, JAVACPP, PYTHON, CONDA, VENV\n    }\n\n    @Override\n    public void run() {\n        switch(this.subCommand) {\n            case ADD:\n                try {\n                    this.type = PythonType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\", type, Arrays.toString(PythonType.values()));\n                    System.exit(1);\n                }\n                break;\n            case CONFIG:\n                try {\n                    this.type = PythonConfigType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\", type, Arrays.toString(PythonConfigType.values()));\n                    System.exit(1);\n                }\n                break;\n            case LIST:\n                try {\n                    this.type = PythonPathsCommand.ListInstallationType.valueOf(((String) type).toUpperCase());\n                } catch (Exception e) {\n                    out.format(\"Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).\", type, Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n                    System.exit(1);\n                }\n                break;\n            default:\n                out.format(\"Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).\", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n        switch(this.subCommand) {\n            case ADD:\n                registerInstallation((PythonType) type, path);\n                break;\n            case LIST:\n                listInstallations((ListInstallationType) type, withInstalledPackages);\n                break;\n            case CONFIG:\n                createConfig((PythonConfigType) type);\n                break;\n            default:\n                log.error(\"Invalid sub command name: {}. Allowed values are: {} -> (case insensitive).\", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));\n        }\n    }\n\n    private void createConfig(PythonConfigType pythonConfigType) {\n        throw new UnsupportedOperationException(\"This will be implemented in a continuation PR\");\n    }\n\n    public static void listInstallations(ListInstallationType type, boolean withInstalledPackages) {\n        switch(type) {\n            case ALL:\n                listJavacppInstallations(withInstalledPackages);\n                listPythonInstallations(withInstalledPackages);\n                listCondaInstallations(withInstalledPackages);\n                listVenvInstallations(withInstalledPackages);\n                break;\n            case JAVACPP:\n                listJavacppInstallations(withInstalledPackages);\n                break;\n            case PYTHON:\n                listPythonInstallations(withInstalledPackages);\n                break;\n            case CONDA:\n                listCondaInstallations(withInstalledPackages);\n                break;\n            case VENV:\n                listVenvInstallations(withInstalledPackages);\n                break;\n            default:\n                System.out.format(\"Invalid installation type name: '%s'. Allowed values are: %s -> (case insensitive).\", type.name(), Arrays.toString(PythonPathsCommand.ListInstallationType.values()));\n        }\n    }\n\n    private static void listJavacppInstallations(boolean withInstalledPackages) {\n        JavaCppDetails javaCppDetails = getJavaCppDetails();\n        System.out.println(\"\\n----------------------------JAVACPP INSTALLS---------------------------\");\n        System.out.print(formatPythonInstallation(new PythonDetails(javaCppDetails.id(), javaCppDetails.path(), javaCppDetails.version()), false));\n        if (!withInstalledPackages) {\n            System.out.println(\"\\n-----------------------------------------------------------------------\");\n        } else {\n            System.out.println(\"\\t--------Installed Modules--------\");\n            printJavaCppInstalledModules();\n            System.out.println(\"\\t---------------------------------\");\n            System.out.println(\"-----------------------------------------------------------------------\");\n        }\n    }\n\n    public static JavaCppDetails getJavaCppDetails() {\n        try {\n            Py_AddPath(cachePackages());\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);\n            /* optional but recommended */\n            Py_Initialize();\n            PyObject globals = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n            PyRun_StringFlags(\"import os, sys; \" + \"executable = os.path.abspath(os.path.join(os.__file__, '..', '..')) + ' (embedded python)'; \" + \"version = sys.version.split(' ')[0]\", Py_single_input, globals, null, null);\n            JavaCppDetails javaCppDetails = new JavaCppDetails(\"0\", getStringFromPythonObject(PyDict_GetItemString(globals, \"executable\")), getStringFromPythonObject(PyDict_GetItemString(globals, \"version\")) + System.lineSeparator());\n            PyMem_RawFree(program);\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n            return javaCppDetails;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n            return null;\n        }\n    }\n\n    private static void listPythonInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------PYTHON INSTALLS----------------------------\");\n        System.out.print(findPythonInstallations().stream().map(pythonDetails -> formatPythonInstallation(pythonDetails, withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static void listCondaInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n----------------------------CONDA INSTALLS-----------------------------\");\n        System.out.print(findCondaInstallations().stream().map(condaDetails -> formatCondaInstallation(condaDetails, withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static String formatPythonInstallation(PythonDetails pythonDetails, boolean withInstalledPackages) {\n        return formatPythonInstallation(pythonDetails, 1, withInstalledPackages);\n    }\n\n    private static String formatPythonInstallation(PythonDetails pythonDetails, int numberOfTabs, boolean withInstalledPackages) {\n        String tabs = IntStream.range(0, numberOfTabs).mapToObj(index -> \"\\t\").collect(Collectors.joining(\"\"));\n        return String.format(\" -%s%s: %s%n%spath: %s%n%sversion: %s%s\", \"\\t\", numberOfTabs > 1 ? \"name\" : \"id\", pythonDetails.id(), tabs, pythonDetails.path(), tabs, pythonDetails.version(), withInstalledPackages ? String.format(\"%s--------Installed Modules--------%n%s%n%s---------------------------------%n\", tabs, Arrays.stream(ProcessUtils.runAndGetOutput(pythonDetails.path(), \"-c\", \"from pip import _internal; _internal.main(['list'])\").split(System.lineSeparator())).map(line -> String.format(\"%s- %s\", tabs, line)).collect(Collectors.joining(System.lineSeparator())), tabs) : \"\");\n    }\n\n    private static void printJavaCppInstalledModules() {\n        try {\n            Py_AddPath(cachePackages());\n            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);\n            if (program == null) {\n                System.out.println(\"Fatal error: cannot get class name\");\n                System.exit(1);\n            }\n            Py_SetProgramName(program);\n            /* optional but recommended */\n            Py_Initialize();\n            PyRun_SimpleStringFlags(\"from pip import _internal\\n\" + \"import warnings\\n\" + \"warnings.filterwarnings(action='ignore')\\n\" + \"class writer :\\n\" + \"    def __init__(self, *writers) :\\n\" + \"        self.writers = writers\\n\" + \"\\n\" + \"    def write(self, text) :\\n\" + \"        for w in self.writers :\\n\" + \"            w.write('\\t- ' + text)\\n\" + \"\\n\" + \"    def flush(self):\\n\" + \"        pass\\n\" + \"import sys\\n\" + \"sys.stdout = writer(sys.stdout)\\n\" + \"installed_modules = _internal.main(['list'])\", null);\n            if (Py_FinalizeEx() < 0) {\n                System.exit(120);\n            }\n            PyMem_RawFree(program);\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            System.exit(1);\n        }\n    }\n\n    private static String formatCondaInstallation(CondaDetails condaDetails, boolean withInstalledPackages) {\n        List<String> formattedCondaEnvironments = new ArrayList<>();\n        condaDetails.environments().forEach(pythonDetails -> formattedCondaEnvironments.add(formatPythonInstallation(pythonDetails, 2, withInstalledPackages)));\n        return String.format(\" -\\tid: %s%n\\tpath: %s%n\\tversion: %s%s\", condaDetails.id(), condaDetails.path(), condaDetails.version(), String.format(\"\\t--------------------------ENVIRONMENTS-------------------------%n\" + \"\\t%s\" + \"\\t---------------------------------------------------------------%n\", String.join(System.lineSeparator() + \"\\t\", formattedCondaEnvironments)));\n    }\n\n    private static void listVenvInstallations(boolean withInstalledPackages) {\n        System.out.println(\"\\n-----------------------------VENV INSTALLS-----------------------------\");\n        System.out.print(findVenvInstallations().stream().map(venvDetails -> formatPythonInstallation(new PythonDetails(venvDetails.id(), venvDetails.path(), venvDetails.version()), withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));\n        System.out.println(\"-----------------------------------------------------------------------\");\n    }\n\n    private static String getStringFromPythonObject(PyObject pythonObject) {\n        PyObject pythonEncodedString = PyUnicode_AsEncodedString(pythonObject, \"utf-8\", \"~E~\");\n        String javaString = PyBytes_AsString(pythonEncodedString).getString();\n        Py_DecRef(pythonEncodedString);\n        return javaString;\n    }\n}\n", "refactored": false}
{"hexsha": "165be4ad837d4dc31731102269d03b8d9ccf05db", "ext": "java", "lang": "Java", "content": "public class SimpleSpider {\n\n    //The page number at which the program is trying to start.\n    private static final int page = 2376;\n\n    public static void main(String[] args) {\n        //HttpClient Comfigurations for time out\n        RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).setConnectionRequestTimeout(6000).setConnectTimeout(6000).build();\n        CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(globalConfig).build();\n        System.out.println(\"Begin searching in 5 seconds??\");\n        int i = page;\n        while (i > 0) try {\n            //Creating a GET request\n            HttpGet httpGet = new HttpGet(\"http://jandan.net/ooxx/page-\" + i);\n            httpGet.addHeader(\"User-Agent\", \"Chrome/56.0.2924.87\");\n            httpGet.addHeader(\"Cookie\", \"_gat=1; nsfw-click-load=off; gif-click-load=on; _ga=GA1.2.1861846600.1423061484\");\n            try {\n                Thread.sleep(5000);\n                //Sending the request\n                CloseableHttpResponse response = httpClient.execute(httpGet);\n                InputStream in = response.getEntity().getContent();\n                String html = Utils.convertStreamToString(in);\n                //Analyzing the web contents\n                new Thread(new JianDanHtmlParser(html, i)).start();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } finally {\n            i--;\n        }\n    }\n}\n", "class_id": 0, "repo": "rickypeng99/Hot-girlrs-pics-seacher", "file": "SimpleSpider.java", "last_update_at": "2021-03-29T02:44:06+00:00", "original_content": "public class SimpleSpider {\n\n    //The page number at which the program is trying to start.\n    private static final int page = 2376;\n\n    public static void main(String[] args) {\n        //HttpClient Comfigurations for time out\n        RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).setConnectionRequestTimeout(6000).setConnectTimeout(6000).build();\n        CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(globalConfig).build();\n        System.out.println(\"Begin searching in 5 seconds??\");\n        for (int i = page; i > 0; i--) {\n            //Creating a GET request\n            HttpGet httpGet = new HttpGet(\"http://jandan.net/ooxx/page-\" + i);\n            httpGet.addHeader(\"User-Agent\", \"Chrome/56.0.2924.87\");\n            httpGet.addHeader(\"Cookie\", \"_gat=1; nsfw-click-load=off; gif-click-load=on; _ga=GA1.2.1861846600.1423061484\");\n            try {\n                Thread.sleep(5000);\n                //Sending the request\n                CloseableHttpResponse response = httpClient.execute(httpGet);\n                InputStream in = response.getEntity().getContent();\n                String html = Utils.convertStreamToString(in);\n                //Analyzing the web contents\n                new Thread(new JianDanHtmlParser(html, i)).start();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "a95d8fe653bfdab75d936ec05cd4ea7fa852d3e6", "ext": "java", "lang": "Java", "content": "public class d {\n\n    /* renamed from: a  reason: collision with root package name */\n    private String f691a;\n\n    private String b;\n\n    private Map<String, String> c;\n\n    public String a() {\n        return this.f691a;\n    }\n\n    public void a(String str) {\n        this.f691a = str;\n    }\n\n    public String b() {\n        return this.b;\n    }\n\n    public void b(String str) {\n        this.b = str;\n    }\n\n    public Map<String, String> c() {\n        return this.c;\n    }\n\n    public void a(Map<String, String> map) {\n        this.c = map;\n    }\n\n    public boolean equals(Object obj) {\n        if (!(obj instanceof d)) {\n            return false;\n        }\n        d dVar = (d) obj;\n        if (!TextUtils.equals(this.f691a, dVar.f691a) || !TextUtils.equals(this.b, dVar.b)) {\n            return false;\n        }\n        Map<String, String> map = this.c;\n        Map<String, String> map2 = dVar.c;\n        if (map == map2 || map == null || map.equals(map2)) {\n            return true;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        String str = this.f691a;\n        int i = 0;\n        int hashCode = (str != null ? str.hashCode() : 0) * 31;\n        String str2 = this.b;\n        int hashCode2 = (hashCode + (str2 != null ? str2.hashCode() : 0)) * 31;\n        Map<String, String> map = this.c;\n        if (map != null) {\n            i = map.hashCode();\n        }\n        return hashCode2 + i;\n    }\n}\n", "class_id": 0, "repo": "Minionguyjpro/Ghostly-Skills", "file": "sources/com/yandex/metrica/d.java", "last_update_at": "2021-11-03T14:24:37+00:00", "original_content": "public class d {\n\n    /* renamed from: a  reason: collision with root package name */\n    private String f691a;\n\n    private String b;\n\n    private Map<String, String> c;\n\n    public String a() {\n        return this.f691a;\n    }\n\n    public void a(String str) {\n        this.f691a = str;\n    }\n\n    public String b() {\n        return this.b;\n    }\n\n    public void b(String str) {\n        this.b = str;\n    }\n\n    public Map<String, String> c() {\n        return this.c;\n    }\n\n    public void a(Map<String, String> map) {\n        this.c = map;\n    }\n\n    public boolean equals(Object obj) {\n        if (!(obj instanceof d)) {\n            return false;\n        }\n        d dVar = (d) obj;\n        if (!TextUtils.equals(this.f691a, dVar.f691a) || !TextUtils.equals(this.b, dVar.b)) {\n            return false;\n        }\n        Map<String, String> map = this.c;\n        Map<String, String> map2 = dVar.c;\n        if (map == map2 || map == null || map.equals(map2)) {\n            return true;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        String str = this.f691a;\n        int i = 0;\n        int hashCode = (str != null ? str.hashCode() : 0) * 31;\n        String str2 = this.b;\n        int hashCode2 = (hashCode + (str2 != null ? str2.hashCode() : 0)) * 31;\n        Map<String, String> map = this.c;\n        if (map != null) {\n            i = map.hashCode();\n        }\n        return hashCode2 + i;\n    }\n}\n", "refactored": false}
{"hexsha": "808dd88a9f7ffc10968ef98a648fd4967d60303d", "ext": "java", "lang": "Java", "content": "public class assembly_Task_auto {\n\n    @Inject\n    private LBR kuka_Iiwa;\n\n    @Inject\n    private MediaFlangeIOGroup media_Flange;\n\n    @Inject\n    private FlexFellow kuka_Ffellow;\n\n    @Inject\n    private Gripper gripper_1;\n\n    @Inject\n    private ITaskLogger logger;\n\n    // Very important:\n    @Inject\n    private IApplicationData //call the frame\n    app_Data;\n\n    @Inject\n    private IApplicationUI // call the diag\n    user_I;\n\n    @Inject\n    private Frame frame_Kuka;\n\n    @Inject\n    private Robot_application_humza robo;\n\n    public void main_App() {\n        //Speed\n        robo.getApplicationControl().setApplicationOverride(0.2);\n        gripper_1.open_M();\n        gripper_1.attachTo(kuka_Iiwa.getFlange());\n        auto_Assem_Seq();\n    }\n\n    private void auto_Assem_Seq() {\n        kuka_Iiwa.move(ptpHome());\n        hrc_Pos();\n        idle_Rob();\n        fh202_Assem();\n        hrc_Pos();\n        c6_Assem();\n        hrc_Pos();\n        d6_Assem();\n        hrc_Pos();\n        d2_Assem();\n        hrc_Pos();\n        idle_Rob();\n        b6_Assem();\n        hrc_Pos();\n        b10_Assem();\n        hrc_Pos();\n        e256_Assem();\n        hrc_Pos();\n        m1174_Assem();\n        hrc_Pos();\n        e215_Assem();\n        hrc_Pos();\n        idle_Rob();\n    }\n\n    public void fastening(ICondition start_Screw_2) {\n        // TODO Auto-generated method stub\n        CartesianImpedanceControlMode fastening = new CartesianImpedanceControlMode();\n        fastening.parametrize(CartDOF.X).setStiffness(800.0);\n        fastening.parametrize(CartDOF.Z).setStiffness(100.0);\n        fastening.parametrize(CartDOF.Y).setStiffness(100.0);\n        Frame fastening_Pos = app_Data.getFrame(\"/fastening_Pos\").copyWithRedundancy();\n        gripper_1.move(ptp(fastening_Pos));\n        ForceCondition start_Screw = ForceCondition.createNormalForceCondition(gripper_1.getDefaultMotionFrame(), CoordinateAxis.X, 60);\n        IMotionContainer hand_Mani = gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n        if (hand_Mani.hasFired(start_Screw)) {\n            logger.info(\"its broken\");\n            media_Flange.setLEDBlue(true);\n        }\n        CartesianImpedanceControlMode fastening_Op = new CartesianImpedanceControlMode();\n        fastening_Op.parametrize(CartDOF.X).setStiffness(5000);\n        fastening_Op.parametrize(CartDOF.Z).setStiffness(5000);\n        fastening_Op.parametrize(CartDOF.Y).setStiffness(5000);\n        fastening_Op.parametrize(CartDOF.C).setDamping(0.7);\n        IMotionContainer fast_Screw = gripper_1.move(positionHold(fastening_Op, 50, TimeUnit.SECONDS).breakWhen(start_Screw_2));\n        if (fast_Screw.hasFired(start_Screw_2)) {\n            logger.info(\"it is soft again\");\n            media_Flange.setLEDBlue(false);\n        }\n        gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n    }\n\n    private void push_Comp() {\n        CartesianImpedanceControlMode softrob_Push = new CartesianImpedanceControlMode();\n        softrob_Push.parametrize(CartDOF.X).setStiffness(500.0);\n        softrob_Push.parametrize(CartDOF.Y).setStiffness(500.0);\n        softrob_Push.parametrize(CartDOF.Z).setStiffness(500.0);\n        Frame safelyto_Comp_Orient = app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n        Frame push_Comp_Orient = app_Data.getFrame(\"/Assembly_Table/push_Orient\").copyWithRedundancy();\n        Frame push_Comp = app_Data.getFrame(\"/Assembly_Table/push_Comp\").copyWithRedundancy();\n        gripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n        gripper_1.move(ptp(push_Comp_Orient));\n        gripper_1.move(lin(push_Comp));\n        Frame push_Comp_Child = app_Data.getFrame(\"/Assembly_Table/push_Comp/push_Lin\").copyWithRedundancy();\n        gripper_1.move(lin(push_Comp_Child).setCartVelocity(100).setMode(softrob_Push));\n        gripper_1.move(lin(push_Comp));\n        gripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n    }\n\n    private void zdu_grn_Assem() {\n        logger.info(\"Starting Assembly task for ZDU 2.5/4AN GREEN\");\n        zdu_grn_Pick();\n        zdugrn_rail_Assem();\n    }\n\n    private void zdu_grn_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_ZPE_GRN_P = app_Data.getFrame(\"/Rack/ZPE_GRN_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_ZPE_GRN_P));\n        Frame Tray_ZPE_GRN_P_1 = app_Data.getFrame(\"/Rack/ZPE_GRN_P/ZPE_GRN_P_1\").copyWithRedundancy();\n        //Tray_ZPE_GRN_P.setX(Tray_ZPE_GRN_P.getX()+50);\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_ZPE_GRN_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_ZPE_GRN_P).setCartVelocity(100));\n    }\n\n    private void zdugrn_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n        Frame Green = orient_Assem_Pos.setX(orient_Assem_Pos.getX() - 50);\n        gripper_1.move(ptp(Green));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl/P1\").copyWithRedundancy();\n        Frame green_Fix = fix_Assem_Pos.setX(fix_Assem_Pos.getX() - 50);\n        gripper_1.move(ptp(green_Fix));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void zdu_bl_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for ZDU 2.5/4AN Blue\");\n        zdu_Bl_Pick();\n        zdubl_rail_Assem();\n    }\n\n    private void zdu_Bl_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_ZDU_BL_P = app_Data.getFrame(\"/Rack/ZDU_BL_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_ZDU_BL_P));\n        Frame Tray_ZDU_BL_P_1 = app_Data.getFrame(\"/Rack/ZDU_BL_P/ZDU_BL_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_ZDU_BL_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_ZDU_BL_P).setCartVelocity(100));\n    }\n\n    private void zdubl_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_fix_zdubl\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void d6_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for D6\");\n        d6_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void d6_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_D6_P = app_Data.getFrame(\"/Rack/D6_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_D6_P));\n        Frame Tray_D6_P_1 = app_Data.getFrame(\"/Rack/D6_P/D6_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_D6_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_D6_P).setCartVelocity(100));\n    }\n\n    private void b6_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for B6\");\n        b6_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void b6_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_B6_P = app_Data.getFrame(\"/Rack/B6_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_B6_P));\n        Frame Tray_B6_P_1 = app_Data.getFrame(\"/Rack/B6_P/B6_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_B6_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_B6_P).setCartVelocity(100));\n    }\n\n    private void b10_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for B10\");\n        b10_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void b10_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_B10_P = app_Data.getFrame(\"/Rack/B10_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_B10_P));\n        Frame Tray_B10_P_1 = app_Data.getFrame(\"/Rack/B10_P/B10_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_B10_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_B10_P).setCartVelocity(100));\n    }\n\n    private void c6_Assem() {\n        logger.info(\"Starting Assembly task for C6\");\n        c6_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void c6_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_C6_P = app_Data.getFrame(\"/Rack/C6_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_C6_P));\n        Frame Tray_C6_P_1 = app_Data.getFrame(\"/Rack/C6_P/C6_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_C6_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_C6_P).setCartVelocity(100));\n    }\n\n    private void e215_Assem() {\n        logger.info(\"Starting Assembly task for E215\");\n        e215_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void e215_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_E215_P = app_Data.getFrame(\"/Rack/E215_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_E215_P));\n        Frame Tray_E215_P_1 = app_Data.getFrame(\"/Rack/E215_P/E215_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        //softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_E215_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_E215_P).setCartVelocity(100));\n    }\n\n    private void e215_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void e290_Assem() {\n        logger.info(\"Starting Assembly task for E290\");\n        e290_Pick();\n    }\n\n    private void e290_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_E290_P = app_Data.getFrame(\"/Rack/E290_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_E290_P));\n        Frame Tray_E290_P_1 = app_Data.getFrame(\"/Rack/E290_P/E290_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_E290_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_E290_P).setCartVelocity(100));\n    }\n\n    private void e256_Assem() {\n        logger.info(\"Starting Assembly task for E256\");\n        e256_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void e256_Pick() {\n        Frame Tray_E256_P = app_Data.getFrame(\"/Rack/E256_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_E256_P));\n        Frame Tray_E256_P_1 = app_Data.getFrame(\"/Rack/E256_P/E256_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_E256_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_E256_P).setCartVelocity(100));\n    }\n\n    private void d2_Assem() {\n        logger.info(\"Starting Assembly task for D2\");\n        d2_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void d2_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_d2_P = app_Data.getFrame(\"/Rack/D2_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_d2_P));\n        Frame Tray_d2_P_1 = app_Data.getFrame(\"/Rack/D2_P/D2_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_d2_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_d2_P).setCartVelocity(100));\n    }\n\n    private void m1174_Assem() {\n        logger.info(\"Starting Assembly task for M1174\");\n        m1174_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void m1174_Pick() {\n        Frame Tray_M1174_P = app_Data.getFrame(\"/Rack/M1174_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_M1174_P));\n        Frame Tray_M1174_P_1 = app_Data.getFrame(\"/Rack/M1174_P/M1174_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_M1174_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_M1174_P).setCartVelocity(100));\n    }\n\n    private void m1174_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2\").copyWithRedundancy();\n        gripper_1.move(lin(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2/rail_Orient_Large2_1\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void m1174_rail_Assem_3() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n        gripper_1.move(lin(orient_Assem_Pos));\n        linear_Force_3();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void fh202_Assem() {\n        logger.info(\"Starting Assembly task for FH202A\");\n        fh202_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void fh202_Pick() {\n        Frame Tray_FH202_P = app_Data.getFrame(\"/Rack/FH202_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_FH202_P));\n        Frame Tray_FH202_P_1 = app_Data.getFrame(\"/Rack/FH202_P/FH202_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_FH202_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_FH202_P).setCartVelocity(100).setMode(softMode));\n    }\n\n    public void shelf_position() {\n        Frame Shelf_Pos = app_Data.getFrame(\"/Rack/Shelf_Pos_1\").copyWithRedundancy();\n        gripper_1.move(ptp(Shelf_Pos));\n    }\n\n    public void idle_Rob() {\n        logger.info(\"Tap the robot to start the task\");\n        ForceCondition contact_Start = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 15);\n        while (true) try {\n            media_Flange.setLEDBlue(true);\n            IMotionContainer contactMotion_1 = gripper_1.move(linRel(0, 0, 10).setCartVelocity(100).breakWhen(contact_Start));\n            IMotionContainer contactMotion_2 = gripper_1.move(linRel(0, 0, -10).setCartVelocity(100).breakWhen(contact_Start));\n            if (contactMotion_1.hasFired(contact_Start) || contactMotion_2.hasFired(contact_Start)) {\n                media_Flange.setLEDBlue(false);\n                logger.info(\"The assembly task starts now\");\n                break;\n            }\n        } finally {\n        }\n    }\n\n    public void hrc_Pos() {\n        Frame hrc_Pos = app_Data.getFrame(\"/hrc_Pos\").copyWithRedundancy();\n        gripper_1.move(ptp(hrc_Pos));\n    }\n\n    public void linear_Force_Shelf() {\n        logger.info(\"linear motion with force control\");\n        ForceCondition contact_Start_Pick_tr2 = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(100).breakWhen(contact_Start_Pick_tr2));\n        if (contactMotion_Pick.hasFired(contact_Start_Pick_tr2)) {\n            logger.info(\"The contact has occured!\");\n        }\n    }\n\n    public void linear_Force() {\n        logger.info(\"linear motion with force control\");\n        ForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(450).breakWhen(contact_Start_Pick));\n        if (contactMotion_Pick.hasFired(contact_Start_Pick)) {\n            logger.info(\"The contact has occured!\");\n        }\n    }\n\n    public void linear_Force_3() {\n        logger.info(\"linear motion with force control\");\n        ForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 800).setCartVelocity(450).breakWhen(contact_Start_Pick));\n        if (contactMotion_Pick.hasFired(contact_Start_Pick)) {\n            logger.info(\"The contact has occured!\");\n        }\n    }\n\n    public void assem_Rail_ABB_M1174() {\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_M1174\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n        gripper_1.open_M();\n    }\n\n    public void assem_Rail_Fh202a() {\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a/fix_Pos\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n        gripper_1.open_M();\n    }\n\n    private void assem_Rail_mag() {\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Assem_T\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.ALL).setStiffness(100.0);\n        Frame fix_Assem_Pos_mag = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_Mag\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos_mag));\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(fix_Assem_Pos_mag).setMode(softrob).breakWhen(contact_Assem_Mag));\n        //gripper_1.move(ptp(orient_Assem_Pos_A7_orient).setMode(softrob).breakWhen(contact_Assem_Mag));\n        gripper_1.open_M();\n    }\n\n    public void p_grip_h() {\n        CartesianSineImpedanceControlMode ctrl = new CartesianSineImpedanceControlMode();\n        ctrl.parametrize(CartDOF.X).setStiffness(300).setDamping(0.5);\n        ctrl.parametrize(CartDOF.Y).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(2);\n        ctrl.parametrize(CartDOF.Z).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(3);\n        // X,Y,Z Translations 0-300\n        ctrl.parametrize(CartDOF.A).setStiffness(200).setDamping(0.5);\n        ctrl.parametrize(CartDOF.B).setStiffness(200).setDamping(0.5);\n        ctrl.parametrize(CartDOF.C).setStiffness(20).setDamping(0.5).setFrequency(4).setAmplitude(3);\n        IMotionContainer positionHoldMotion = gripper_1.move(positionHold(ctrl, 2, TimeUnit.SECONDS));\n    }\n}\n", "class_id": 0, "repo": "Mohammad-Shahzaib/Labyrinth-Solver-Kuka-iiwa", "file": "src/application/assembly_Task_auto.java", "last_update_at": "2021-01-22T10:12:32+00:00", "original_content": "public class assembly_Task_auto {\n\n    @Inject\n    private LBR kuka_Iiwa;\n\n    @Inject\n    private MediaFlangeIOGroup media_Flange;\n\n    @Inject\n    private FlexFellow kuka_Ffellow;\n\n    @Inject\n    private Gripper gripper_1;\n\n    @Inject\n    private ITaskLogger logger;\n\n    // Very important:\n    @Inject\n    private IApplicationData //call the frame\n    app_Data;\n\n    @Inject\n    private IApplicationUI // call the diag\n    user_I;\n\n    @Inject\n    private Frame frame_Kuka;\n\n    @Inject\n    private Robot_application_humza robo;\n\n    public void main_App() {\n        //Speed\n        robo.getApplicationControl().setApplicationOverride(0.2);\n        gripper_1.open_M();\n        gripper_1.attachTo(kuka_Iiwa.getFlange());\n        auto_Assem_Seq();\n    }\n\n    private void auto_Assem_Seq() {\n        kuka_Iiwa.move(ptpHome());\n        hrc_Pos();\n        idle_Rob();\n        fh202_Assem();\n        hrc_Pos();\n        c6_Assem();\n        hrc_Pos();\n        d6_Assem();\n        hrc_Pos();\n        d2_Assem();\n        hrc_Pos();\n        idle_Rob();\n        b6_Assem();\n        hrc_Pos();\n        b10_Assem();\n        hrc_Pos();\n        e256_Assem();\n        hrc_Pos();\n        m1174_Assem();\n        hrc_Pos();\n        e215_Assem();\n        hrc_Pos();\n        idle_Rob();\n    }\n\n    public void fastening(ICondition start_Screw_2) {\n        // TODO Auto-generated method stub\n        CartesianImpedanceControlMode fastening = new CartesianImpedanceControlMode();\n        fastening.parametrize(CartDOF.X).setStiffness(800.0);\n        fastening.parametrize(CartDOF.Z).setStiffness(100.0);\n        fastening.parametrize(CartDOF.Y).setStiffness(100.0);\n        Frame fastening_Pos = app_Data.getFrame(\"/fastening_Pos\").copyWithRedundancy();\n        gripper_1.move(ptp(fastening_Pos));\n        ForceCondition start_Screw = ForceCondition.createNormalForceCondition(gripper_1.getDefaultMotionFrame(), CoordinateAxis.X, 60);\n        IMotionContainer hand_Mani = gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n        if (hand_Mani.hasFired(start_Screw)) {\n            logger.info(\"its broken\");\n            media_Flange.setLEDBlue(true);\n        }\n        CartesianImpedanceControlMode fastening_Op = new CartesianImpedanceControlMode();\n        fastening_Op.parametrize(CartDOF.X).setStiffness(5000);\n        fastening_Op.parametrize(CartDOF.Z).setStiffness(5000);\n        fastening_Op.parametrize(CartDOF.Y).setStiffness(5000);\n        fastening_Op.parametrize(CartDOF.C).setDamping(0.7);\n        IMotionContainer fast_Screw = gripper_1.move(positionHold(fastening_Op, 50, TimeUnit.SECONDS).breakWhen(start_Screw_2));\n        if (fast_Screw.hasFired(start_Screw_2)) {\n            logger.info(\"it is soft again\");\n            media_Flange.setLEDBlue(false);\n        }\n        gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));\n    }\n\n    private void push_Comp() {\n        CartesianImpedanceControlMode softrob_Push = new CartesianImpedanceControlMode();\n        softrob_Push.parametrize(CartDOF.X).setStiffness(500.0);\n        softrob_Push.parametrize(CartDOF.Y).setStiffness(500.0);\n        softrob_Push.parametrize(CartDOF.Z).setStiffness(500.0);\n        Frame safelyto_Comp_Orient = app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n        Frame push_Comp_Orient = app_Data.getFrame(\"/Assembly_Table/push_Orient\").copyWithRedundancy();\n        Frame push_Comp = app_Data.getFrame(\"/Assembly_Table/push_Comp\").copyWithRedundancy();\n        gripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n        gripper_1.move(ptp(push_Comp_Orient));\n        gripper_1.move(lin(push_Comp));\n        Frame push_Comp_Child = app_Data.getFrame(\"/Assembly_Table/push_Comp/push_Lin\").copyWithRedundancy();\n        gripper_1.move(lin(push_Comp_Child).setCartVelocity(100).setMode(softrob_Push));\n        gripper_1.move(lin(push_Comp));\n        gripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));\n    }\n\n    private void zdu_grn_Assem() {\n        logger.info(\"Starting Assembly task for ZDU 2.5/4AN GREEN\");\n        zdu_grn_Pick();\n        zdugrn_rail_Assem();\n    }\n\n    private void zdu_grn_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_ZPE_GRN_P = app_Data.getFrame(\"/Rack/ZPE_GRN_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_ZPE_GRN_P));\n        Frame Tray_ZPE_GRN_P_1 = app_Data.getFrame(\"/Rack/ZPE_GRN_P/ZPE_GRN_P_1\").copyWithRedundancy();\n        //Tray_ZPE_GRN_P.setX(Tray_ZPE_GRN_P.getX()+50);\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_ZPE_GRN_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_ZPE_GRN_P).setCartVelocity(100));\n    }\n\n    private void zdugrn_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n        Frame Green = orient_Assem_Pos.setX(orient_Assem_Pos.getX() - 50);\n        gripper_1.move(ptp(Green));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl/P1\").copyWithRedundancy();\n        Frame green_Fix = fix_Assem_Pos.setX(fix_Assem_Pos.getX() - 50);\n        gripper_1.move(ptp(green_Fix));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void zdu_bl_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for ZDU 2.5/4AN Blue\");\n        zdu_Bl_Pick();\n        zdubl_rail_Assem();\n    }\n\n    private void zdu_Bl_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_ZDU_BL_P = app_Data.getFrame(\"/Rack/ZDU_BL_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_ZDU_BL_P));\n        Frame Tray_ZDU_BL_P_1 = app_Data.getFrame(\"/Rack/ZDU_BL_P/ZDU_BL_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_ZDU_BL_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_ZDU_BL_P).setCartVelocity(100));\n    }\n\n    private void zdubl_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_orient_zdubl\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_fix_zdubl\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void d6_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for D6\");\n        d6_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void d6_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_D6_P = app_Data.getFrame(\"/Rack/D6_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_D6_P));\n        Frame Tray_D6_P_1 = app_Data.getFrame(\"/Rack/D6_P/D6_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_D6_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_D6_P).setCartVelocity(100));\n    }\n\n    private void b6_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for B6\");\n        b6_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void b6_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_B6_P = app_Data.getFrame(\"/Rack/B6_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_B6_P));\n        Frame Tray_B6_P_1 = app_Data.getFrame(\"/Rack/B6_P/B6_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_B6_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_B6_P).setCartVelocity(100));\n    }\n\n    private void b10_Assem() {\n        // TODO Auto-generated method stub\n        logger.info(\"Starting Assembly task for B10\");\n        b10_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void b10_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_B10_P = app_Data.getFrame(\"/Rack/B10_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_B10_P));\n        Frame Tray_B10_P_1 = app_Data.getFrame(\"/Rack/B10_P/B10_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_B10_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_B10_P).setCartVelocity(100));\n    }\n\n    private void c6_Assem() {\n        logger.info(\"Starting Assembly task for C6\");\n        c6_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void c6_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_C6_P = app_Data.getFrame(\"/Rack/C6_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_C6_P));\n        Frame Tray_C6_P_1 = app_Data.getFrame(\"/Rack/C6_P/C6_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_C6_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_C6_P).setCartVelocity(100));\n    }\n\n    private void e215_Assem() {\n        logger.info(\"Starting Assembly task for E215\");\n        e215_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void e215_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_E215_P = app_Data.getFrame(\"/Rack/E215_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_E215_P));\n        Frame Tray_E215_P_1 = app_Data.getFrame(\"/Rack/E215_P/E215_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        //softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_E215_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_E215_P).setCartVelocity(100));\n    }\n\n    private void e215_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void e290_Assem() {\n        logger.info(\"Starting Assembly task for E290\");\n        e290_Pick();\n    }\n\n    private void e290_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_E290_P = app_Data.getFrame(\"/Rack/E290_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_E290_P));\n        Frame Tray_E290_P_1 = app_Data.getFrame(\"/Rack/E290_P/E290_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_E290_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_E290_P).setCartVelocity(100));\n    }\n\n    private void e256_Assem() {\n        logger.info(\"Starting Assembly task for E256\");\n        e256_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void e256_Pick() {\n        Frame Tray_E256_P = app_Data.getFrame(\"/Rack/E256_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_E256_P));\n        Frame Tray_E256_P_1 = app_Data.getFrame(\"/Rack/E256_P/E256_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_E256_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_E256_P).setCartVelocity(100));\n    }\n\n    private void d2_Assem() {\n        logger.info(\"Starting Assembly task for D2\");\n        d2_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void d2_Pick() {\n        // TODO Auto-generated method stub\n        Frame Tray_d2_P = app_Data.getFrame(\"/Rack/D2_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_d2_P));\n        Frame Tray_d2_P_1 = app_Data.getFrame(\"/Rack/D2_P/D2_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_d2_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_d2_P).setCartVelocity(100));\n    }\n\n    private void m1174_Assem() {\n        logger.info(\"Starting Assembly task for M1174\");\n        m1174_Pick();\n        m1174_rail_Assem_3();\n    }\n\n    private void m1174_Pick() {\n        Frame Tray_M1174_P = app_Data.getFrame(\"/Rack/M1174_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_M1174_P));\n        Frame Tray_M1174_P_1 = app_Data.getFrame(\"/Rack/M1174_P/M1174_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_M1174_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_M1174_P).setCartVelocity(100));\n    }\n\n    private void m1174_rail_Assem() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2\").copyWithRedundancy();\n        gripper_1.move(lin(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large2/rail_Orient_Large2_1\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void m1174_rail_Assem_3() {\n        // TODO Auto-generated method stub\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large\").copyWithRedundancy();\n        gripper_1.move(lin(orient_Assem_Pos));\n        linear_Force_3();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        gripper_1.open_M();\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n    }\n\n    private void fh202_Assem() {\n        logger.info(\"Starting Assembly task for FH202A\");\n        fh202_Pick();\n        m1174_rail_Assem();\n    }\n\n    private void fh202_Pick() {\n        Frame Tray_FH202_P = app_Data.getFrame(\"/Rack/FH202_P\").copyWithRedundancy();\n        gripper_1.move(ptp(Tray_FH202_P));\n        Frame Tray_FH202_P_1 = app_Data.getFrame(\"/Rack/FH202_P/FH202_P_1\").copyWithRedundancy();\n        int stiff_Fh202 = 1000;\n        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();\n        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);\n        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);\n        gripper_1.move(lin(Tray_FH202_P_1).setCartVelocity(100).setMode(softMode));\n        gripper_1.close_M();\n        gripper_1.move(lin(Tray_FH202_P).setCartVelocity(100).setMode(softMode));\n    }\n\n    public void shelf_position() {\n        Frame Shelf_Pos = app_Data.getFrame(\"/Rack/Shelf_Pos_1\").copyWithRedundancy();\n        gripper_1.move(ptp(Shelf_Pos));\n    }\n\n    public void idle_Rob() {\n        logger.info(\"Tap the robot to start the task\");\n        ForceCondition contact_Start = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 15);\n        for (; ; ) {\n            media_Flange.setLEDBlue(true);\n            IMotionContainer contactMotion_1 = gripper_1.move(linRel(0, 0, 10).setCartVelocity(100).breakWhen(contact_Start));\n            IMotionContainer contactMotion_2 = gripper_1.move(linRel(0, 0, -10).setCartVelocity(100).breakWhen(contact_Start));\n            if (contactMotion_1.hasFired(contact_Start) || contactMotion_2.hasFired(contact_Start)) {\n                media_Flange.setLEDBlue(false);\n                logger.info(\"The assembly task starts now\");\n                break;\n            }\n        }\n    }\n\n    public void hrc_Pos() {\n        Frame hrc_Pos = app_Data.getFrame(\"/hrc_Pos\").copyWithRedundancy();\n        gripper_1.move(ptp(hrc_Pos));\n    }\n\n    public void linear_Force_Shelf() {\n        logger.info(\"linear motion with force control\");\n        ForceCondition contact_Start_Pick_tr2 = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(100).breakWhen(contact_Start_Pick_tr2));\n        if (contactMotion_Pick.hasFired(contact_Start_Pick_tr2)) {\n            logger.info(\"The contact has occured!\");\n        }\n    }\n\n    public void linear_Force() {\n        logger.info(\"linear motion with force control\");\n        ForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(450).breakWhen(contact_Start_Pick));\n        if (contactMotion_Pick.hasFired(contact_Start_Pick)) {\n            logger.info(\"The contact has occured!\");\n        }\n    }\n\n    public void linear_Force_3() {\n        logger.info(\"linear motion with force control\");\n        ForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);\n        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 800).setCartVelocity(450).breakWhen(contact_Start_Pick));\n        if (contactMotion_Pick.hasFired(contact_Start_Pick)) {\n            logger.info(\"The contact has occured!\");\n        }\n    }\n\n    public void assem_Rail_ABB_M1174() {\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Abbm1174\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_M1174\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n        gripper_1.open_M();\n    }\n\n    public void assem_Rail_Fh202a() {\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        int stiff_assembrail = 100;\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);\n        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);\n        Frame fix_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Fh202a/fix_Pos\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos));\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));\n        gripper_1.open_M();\n    }\n\n    private void assem_Rail_mag() {\n        Frame orient_Assem_Pos = app_Data.getFrame(\"/Assembly_Table/orient_Assem_T\").copyWithRedundancy();\n        gripper_1.move(ptp(orient_Assem_Pos));\n        linear_Force();\n        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();\n        softrob.parametrize(CartDOF.ALL).setStiffness(100.0);\n        Frame fix_Assem_Pos_mag = app_Data.getFrame(\"/Assembly_Table/fix_Assem_Pos_Mag\").copyWithRedundancy();\n        gripper_1.move(ptp(fix_Assem_Pos_mag));\n        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);\n        gripper_1.move(ptp(fix_Assem_Pos_mag).setMode(softrob).breakWhen(contact_Assem_Mag));\n        //gripper_1.move(ptp(orient_Assem_Pos_A7_orient).setMode(softrob).breakWhen(contact_Assem_Mag));\n        gripper_1.open_M();\n    }\n\n    public void p_grip_h() {\n        CartesianSineImpedanceControlMode ctrl = new CartesianSineImpedanceControlMode();\n        ctrl.parametrize(CartDOF.X).setStiffness(300).setDamping(0.5);\n        ctrl.parametrize(CartDOF.Y).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(2);\n        ctrl.parametrize(CartDOF.Z).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(3);\n        // X,Y,Z Translations 0-300\n        ctrl.parametrize(CartDOF.A).setStiffness(200).setDamping(0.5);\n        ctrl.parametrize(CartDOF.B).setStiffness(200).setDamping(0.5);\n        ctrl.parametrize(CartDOF.C).setStiffness(20).setDamping(0.5).setFrequency(4).setAmplitude(3);\n        IMotionContainer positionHoldMotion = gripper_1.move(positionHold(ctrl, 2, TimeUnit.SECONDS));\n    }\n}\n", "refactored": true}
{"hexsha": "05c8c395b91c6ea8a0b51f65d49c4ecd0e41e210", "ext": "java", "lang": "Java", "content": "@Internal\nfinal class CurrentRowEvaluationSheet implements EvaluationSheet {\n\n    private final Sheet _xs;\n\n    private final Row _row;\n\n    CurrentRowEvaluationSheet(Sheet sheet, Row row) {\n        _xs = sheet;\n        _row = row;\n    }\n\n    Sheet getSheet() {\n        return _xs;\n    }\n\n    /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#getlastRowNum()\n   * @since POI 4.0.0\n   */\n    @Override\n    public int getLastRowNum() {\n        return _xs.getLastRowNum();\n    }\n\n    /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#isRowHidden(int)\n   * @since POI 4.1.0\n   */\n    @Override\n    public boolean isRowHidden(int rowIndex) {\n        if (_row == null)\n            return false;\n        return _row.getZeroHeight();\n    }\n\n    @Override\n    public EvaluationCell getCell(int rowIndex, int columnIndex) {\n        if (_row == null) {\n            return null;\n        }\n        Cell cell = _row.getCell(columnIndex);\n        if (cell == null) {\n            return null;\n        }\n        return new OoxmlEvaluationCell(cell, this);\n    }\n\n    /* (non-JavaDoc), inherit JavaDoc from EvaluationSheet\n   * @since POI 3.15 beta 3\n   */\n    @Override\n    public void clearAllCachedResultValues() {\n    }\n}\n", "class_id": 0, "repo": "mirahbo/excel-streaming-reader", "file": "src/main/java/com/github/pjfanning/xlsx/impl/CurrentRowEvaluationSheet.java", "last_update_at": "2021-12-13T14:01:59+00:00", "original_content": "@Internal\nfinal class CurrentRowEvaluationSheet implements EvaluationSheet {\n\n    private final Sheet _xs;\n\n    private final Row _row;\n\n    CurrentRowEvaluationSheet(Sheet sheet, Row row) {\n        _xs = sheet;\n        _row = row;\n    }\n\n    Sheet getSheet() {\n        return _xs;\n    }\n\n    /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#getlastRowNum()\n   * @since POI 4.0.0\n   */\n    @Override\n    public int getLastRowNum() {\n        return _xs.getLastRowNum();\n    }\n\n    /* (non-Javadoc)\n   * @see org.apache.poi.ss.formula.EvaluationSheet#isRowHidden(int)\n   * @since POI 4.1.0\n   */\n    @Override\n    public boolean isRowHidden(int rowIndex) {\n        if (_row == null)\n            return false;\n        return _row.getZeroHeight();\n    }\n\n    @Override\n    public EvaluationCell getCell(int rowIndex, int columnIndex) {\n        if (_row == null) {\n            return null;\n        }\n        Cell cell = _row.getCell(columnIndex);\n        if (cell == null) {\n            return null;\n        }\n        return new OoxmlEvaluationCell(cell, this);\n    }\n\n    /* (non-JavaDoc), inherit JavaDoc from EvaluationSheet\n   * @since POI 3.15 beta 3\n   */\n    @Override\n    public void clearAllCachedResultValues() {\n    }\n}\n", "refactored": false}
{"hexsha": "f8859217700a688c3b89f361bb816019b9456d26", "ext": "java", "lang": "Java", "content": "public final class JoinUtils {\n\n    private JoinUtils() {\n    }\n\n    public static List<Page> channelsToPages(List<List<Block>> channels) {\n        if (channels.isEmpty()) {\n            return ImmutableList.of();\n        }\n        int pagesCount = channels.get(0).size();\n        ImmutableList.Builder<Page> pagesBuilder = ImmutableList.builderWithExpectedSize(pagesCount);\n        int pageIndex = 0;\n        while (pageIndex < pagesCount) try {\n            Block[] blocks = new Block[channels.size()];\n            int channelIndex = 0;\n            while (channelIndex < blocks.length) try {\n                blocks[channelIndex] = channels.get(channelIndex).get(pageIndex);\n            } finally {\n                ++channelIndex;\n            }\n            pagesBuilder.add(new Page(blocks));\n        } finally {\n            ++pageIndex;\n        }\n        return pagesBuilder.build();\n    }\n\n    public static boolean isBuildSideReplicated(JoinNode joinNode) {\n        return PlanNodeSearcher.searchFrom(joinNode.getRight()).recurseOnlyWhen(MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class).or(JoinUtils::isLocalRepartitionExchange)).where(JoinUtils::isRemoteReplicatedExchange).matches();\n    }\n\n    private static boolean isRemoteReplicatedExchange(PlanNode node) {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == REMOTE && exchangeNode.getType() == REPLICATE;\n    }\n\n    private static boolean isLocalRepartitionExchange(PlanNode node) {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == LOCAL && exchangeNode.getType() == REPARTITION;\n    }\n}\n", "class_id": 0, "repo": "YituHealthcare/presto", "file": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "last_update_at": "2021-09-15T06:54:35+00:00", "original_content": "public final class JoinUtils {\n\n    private JoinUtils() {\n    }\n\n    public static List<Page> channelsToPages(List<List<Block>> channels) {\n        if (channels.isEmpty()) {\n            return ImmutableList.of();\n        }\n        int pagesCount = channels.get(0).size();\n        ImmutableList.Builder<Page> pagesBuilder = ImmutableList.builderWithExpectedSize(pagesCount);\n        for (int pageIndex = 0; pageIndex < pagesCount; ++pageIndex) {\n            Block[] blocks = new Block[channels.size()];\n            for (int channelIndex = 0; channelIndex < blocks.length; ++channelIndex) {\n                blocks[channelIndex] = channels.get(channelIndex).get(pageIndex);\n            }\n            pagesBuilder.add(new Page(blocks));\n        }\n        return pagesBuilder.build();\n    }\n\n    public static boolean isBuildSideReplicated(JoinNode joinNode) {\n        return PlanNodeSearcher.searchFrom(joinNode.getRight()).recurseOnlyWhen(MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class).or(JoinUtils::isLocalRepartitionExchange)).where(JoinUtils::isRemoteReplicatedExchange).matches();\n    }\n\n    private static boolean isRemoteReplicatedExchange(PlanNode node) {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == REMOTE && exchangeNode.getType() == REPLICATE;\n    }\n\n    private static boolean isLocalRepartitionExchange(PlanNode node) {\n        if (!(node instanceof ExchangeNode)) {\n            return false;\n        }\n        ExchangeNode exchangeNode = (ExchangeNode) node;\n        return exchangeNode.getScope() == LOCAL && exchangeNode.getType() == REPARTITION;\n    }\n}\n", "refactored": true}
{"hexsha": "3467de5b9dd69d853da9674e47652781da6c0a68", "ext": "java", "lang": "Java", "content": "public class ExpressionMultiNashProb extends ExpressionQuant {\n\n    protected Expression expr;\n\n    public ExpressionMultiNashProb() {\n    }\n\n    public void setExpression(Expression e) {\n        this.expr = e;\n    }\n\n    public Expression getExpression() {\n        return this.expr;\n    }\n\n    @Override\n    public OpRelOpBound getRelopBoundInfo(Values constantValues) throws PrismException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isConstant() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    @Override\n    public boolean isProposition() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    @Override\n    public Object evaluate(EvaluateContext ec) throws PrismLangException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigRational evaluateExact(EvaluateContext ec) throws PrismLangException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean returnsSingleValue() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    @Override\n    public Expression deepCopy() {\n        ExpressionMultiNashProb expr = new ExpressionMultiNashProb();\n        expr.setExpression(getExpression() == null ? null : getExpression().deepCopy());\n        expr.setType(type);\n        expr.setPosition(this);\n        return expr;\n    }\n\n    @Override\n    public Object accept(ASTVisitor v) throws PrismLangException {\n        return v.visit(this);\n    }\n\n    @Override\n    public String toString() {\n        // TODO Auto-generated method stub\n        String s = \"P[\" + expr.toString() + \"]\";\n        return s;\n    }\n}\n", "class_id": 0, "repo": "kushgrover/apt-vs-dift", "file": "src/prism-games/prism/src/parser/ast/ExpressionMultiNashProb.java", "last_update_at": "2021-09-08T08:42:42+00:00", "original_content": "public class ExpressionMultiNashProb extends ExpressionQuant {\n\n    protected Expression expr;\n\n    public ExpressionMultiNashProb() {\n    }\n\n    public void setExpression(Expression e) {\n        this.expr = e;\n    }\n\n    public Expression getExpression() {\n        return this.expr;\n    }\n\n    @Override\n    public OpRelOpBound getRelopBoundInfo(Values constantValues) throws PrismException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isConstant() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    @Override\n    public boolean isProposition() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    @Override\n    public Object evaluate(EvaluateContext ec) throws PrismLangException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigRational evaluateExact(EvaluateContext ec) throws PrismLangException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean returnsSingleValue() {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    @Override\n    public Expression deepCopy() {\n        ExpressionMultiNashProb expr = new ExpressionMultiNashProb();\n        expr.setExpression(getExpression() == null ? null : getExpression().deepCopy());\n        expr.setType(type);\n        expr.setPosition(this);\n        return expr;\n    }\n\n    @Override\n    public Object accept(ASTVisitor v) throws PrismLangException {\n        return v.visit(this);\n    }\n\n    @Override\n    public String toString() {\n        // TODO Auto-generated method stub\n        String s = \"P[\" + expr.toString() + \"]\";\n        return s;\n    }\n}\n", "refactored": false}
{"hexsha": "669e310d22d7a1c8173c0b5886391f9475cf7bc7", "ext": "java", "lang": "Java", "content": "public class ConColDemoApp {\n\n    private CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n\n    public static void main(String[] args) {\n        ConColDemoApp obj = new ConColDemoApp();\n        obj.list.add(10);\n        obj.list.add(20);\n        obj.list.add(30);\n        System.out.println(obj.list);\n    }\n}\n", "class_id": 0, "repo": "vamandeshmukh/cg-java-project", "file": "src/com/cg/demo/concdemo/ConColDemoApp.java", "last_update_at": "2021-03-10T08:20:41+00:00", "original_content": "public class ConColDemoApp {\n\n    private CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n\n    public static void main(String[] args) {\n        ConColDemoApp obj = new ConColDemoApp();\n        obj.list.add(10);\n        obj.list.add(20);\n        obj.list.add(30);\n        System.out.println(obj.list);\n    }\n}\n", "refactored": false}
{"hexsha": "396fe0097ad6ee2717cc47e6dc55b22f44414219", "ext": "java", "lang": "Java", "content": "public abstract class GeometryBase extends Geometry {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    // default (clampToGround)\r\n    private AltitudeModeEnumType altitudeMode;\r\n\r\n    // default (false)\r\n    private Boolean extrude;\r\n\r\n    // default (false)\r\n    private Boolean tessellate;\r\n\r\n    // indicates gx:drawOrder (default = 0) for non-point geometries (line, ring, polygon)\r\n    private Integer drawOrder;\r\n\r\n    /**\r\n     * Altitude Mode ([clampToGround], relativeToGround, absolute). If value is null\r\n     * then the default clampToGround is assumed and altitude can be ignored.\r\n     *\r\n     * @return the altitudeMode\r\n     */\r\n    @CheckForNull\r\n    public AltitudeModeEnumType getAltitudeMode() {\r\n        return altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     */\r\n    public void setAltitudeMode(AltitudeModeEnumType altitudeMode) {\r\n        this.altitudeMode = altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode to normalized AltitudeModeEnumType value or null if invalid.\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     *                     also includes gx:extensions (clampToSeaFloor and relativeToSeaFloor)\r\n     */\r\n    public void setAltitudeMode(String altitudeMode) {\r\n        this.altitudeMode = AltitudeModeEnumType.getNormalizedMode(altitudeMode);\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getExtrude() {\r\n        return extrude;\r\n    }\r\n\r\n    public void setExtrude(Boolean extrude) {\r\n        this.extrude = extrude;\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getTessellate() {\r\n        return tessellate;\r\n    }\r\n\r\n    public void setTessellate(Boolean tessellate) {\r\n        this.tessellate = tessellate;\r\n    }\r\n\r\n    public Integer getDrawOrder() {\r\n        return drawOrder;\r\n    }\r\n\r\n    public void setDrawOrder(Integer drawOrder) {\r\n        this.drawOrder = drawOrder;\r\n    }\r\n\r\n    /**\r\n     * Read data from SimpleObjectInputStream\r\n     *\r\n     * @param in SimpleObjectInputStream\r\n     * @throws IOException              if an I/O error occurs or if this input stream has reached the end.\r\n     * @throws ClassNotFoundException   if the class cannot be located\r\n     * @throws IllegalAccessException   if the class or its nullary\r\n     *                                  constructor is not accessible.\r\n     * @throws InstantiationException   if this <code>Class</code> represents an abstract class,\r\n     *                                  an interface, an array class, a primitive type, or void;\r\n     *                                  or if the class has no nullary constructor;\r\n     *                                  or if the instantiation fails for some other reason.\r\n     * @throws IllegalArgumentException if enumerated AltitudeMode value is invalid\r\n     * @see org.mitre.giscore.utils.SimpleObjectInputStream#readObject()\r\n     */\r\n    @Override\r\n    public void readData(SimpleObjectInputStream in) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n        super.readData(in);\r\n        String val = in.readString();\r\n        altitudeMode = val != null && val.length() != 0 ? AltitudeModeEnumType.valueOf(val) : null;\r\n        int mask = in.readByte();\r\n        // extrude: 2 = null, 1 = true, 0 = false\r\n        int exMask = mask & 0x3;\r\n        extrude = (exMask == 0 || exMask == 0x1) ? Boolean.valueOf(exMask == 0x1) : null;\r\n        // tessellate: 2x = null, 1x = true, 0x = false\r\n        int tessMask = mask & 0x30;\r\n        tessellate = (tessMask == 0 || tessMask == 0x10) ? Boolean.valueOf(tessMask == 0x10) : null;\r\n        this.drawOrder = (mask & 0x80) != 0 ? null : in.readInt();\r\n    }\r\n\r\n    /*\r\n      * (non-Javadoc)\r\n      * @see SimpleObjectOutputStream#writeObject(org.mitre.giscore.utils.IDataSerializable)\r\n      */\r\n    @Override\r\n    public void writeData(SimpleObjectOutputStream out) throws IOException {\r\n        super.writeData(out);\r\n        out.writeString(altitudeMode == null ? \"\" : altitudeMode.toString());\r\n        // with values: 0,1,null\r\n        int mask = extrude == null ? 0x2 : extrude ? 0x1 : 0;\r\n        if (tessellate == null)\r\n            mask |= 0x20;\r\n        else if (tessellate)\r\n            mask |= 0x10;\r\n        if (drawOrder == null)\r\n            mask |= 0x80;\r\n        out.writeByte(mask);\r\n        if (drawOrder != null) {\r\n            out.writeInt(drawOrder);\r\n        }\r\n    }\r\n}\r\n", "class_id": 0, "repo": "OpenSextant/giscore", "file": "src/main/java/org/opensextant/giscore/geometry/GeometryBase.java", "last_update_at": "2021-12-08T16:19:37+00:00", "original_content": "public abstract class GeometryBase extends Geometry {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    // default (clampToGround)\r\n    private AltitudeModeEnumType altitudeMode;\r\n\r\n    // default (false)\r\n    private Boolean extrude;\r\n\r\n    // default (false)\r\n    private Boolean tessellate;\r\n\r\n    // indicates gx:drawOrder (default = 0) for non-point geometries (line, ring, polygon)\r\n    private Integer drawOrder;\r\n\r\n    /**\r\n     * Altitude Mode ([clampToGround], relativeToGround, absolute). If value is null\r\n     * then the default clampToGround is assumed and altitude can be ignored.\r\n     *\r\n     * @return the altitudeMode\r\n     */\r\n    @CheckForNull\r\n    public AltitudeModeEnumType getAltitudeMode() {\r\n        return altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     */\r\n    public void setAltitudeMode(AltitudeModeEnumType altitudeMode) {\r\n        this.altitudeMode = altitudeMode;\r\n    }\r\n\r\n    /**\r\n     * Set altitudeMode to normalized AltitudeModeEnumType value or null if invalid.\r\n     *\r\n     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)\r\n     *                     also includes gx:extensions (clampToSeaFloor and relativeToSeaFloor)\r\n     */\r\n    public void setAltitudeMode(String altitudeMode) {\r\n        this.altitudeMode = AltitudeModeEnumType.getNormalizedMode(altitudeMode);\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getExtrude() {\r\n        return extrude;\r\n    }\r\n\r\n    public void setExtrude(Boolean extrude) {\r\n        this.extrude = extrude;\r\n    }\r\n\r\n    @CheckForNull\r\n    public Boolean getTessellate() {\r\n        return tessellate;\r\n    }\r\n\r\n    public void setTessellate(Boolean tessellate) {\r\n        this.tessellate = tessellate;\r\n    }\r\n\r\n    public Integer getDrawOrder() {\r\n        return drawOrder;\r\n    }\r\n\r\n    public void setDrawOrder(Integer drawOrder) {\r\n        this.drawOrder = drawOrder;\r\n    }\r\n\r\n    /**\r\n     * Read data from SimpleObjectInputStream\r\n     *\r\n     * @param in SimpleObjectInputStream\r\n     * @throws IOException              if an I/O error occurs or if this input stream has reached the end.\r\n     * @throws ClassNotFoundException   if the class cannot be located\r\n     * @throws IllegalAccessException   if the class or its nullary\r\n     *                                  constructor is not accessible.\r\n     * @throws InstantiationException   if this <code>Class</code> represents an abstract class,\r\n     *                                  an interface, an array class, a primitive type, or void;\r\n     *                                  or if the class has no nullary constructor;\r\n     *                                  or if the instantiation fails for some other reason.\r\n     * @throws IllegalArgumentException if enumerated AltitudeMode value is invalid\r\n     * @see org.mitre.giscore.utils.SimpleObjectInputStream#readObject()\r\n     */\r\n    @Override\r\n    public void readData(SimpleObjectInputStream in) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {\r\n        super.readData(in);\r\n        String val = in.readString();\r\n        altitudeMode = val != null && val.length() != 0 ? AltitudeModeEnumType.valueOf(val) : null;\r\n        int mask = in.readByte();\r\n        // extrude: 2 = null, 1 = true, 0 = false\r\n        int exMask = mask & 0x3;\r\n        extrude = (exMask == 0 || exMask == 0x1) ? Boolean.valueOf(exMask == 0x1) : null;\r\n        // tessellate: 2x = null, 1x = true, 0x = false\r\n        int tessMask = mask & 0x30;\r\n        tessellate = (tessMask == 0 || tessMask == 0x10) ? Boolean.valueOf(tessMask == 0x10) : null;\r\n        this.drawOrder = (mask & 0x80) != 0 ? null : in.readInt();\r\n    }\r\n\r\n    /*\r\n      * (non-Javadoc)\r\n      * @see SimpleObjectOutputStream#writeObject(org.mitre.giscore.utils.IDataSerializable)\r\n      */\r\n    @Override\r\n    public void writeData(SimpleObjectOutputStream out) throws IOException {\r\n        super.writeData(out);\r\n        out.writeString(altitudeMode == null ? \"\" : altitudeMode.toString());\r\n        // with values: 0,1,null\r\n        int mask = extrude == null ? 0x2 : extrude ? 0x1 : 0;\r\n        if (tessellate == null)\r\n            mask |= 0x20;\r\n        else if (tessellate)\r\n            mask |= 0x10;\r\n        if (drawOrder == null)\r\n            mask |= 0x80;\r\n        out.writeByte(mask);\r\n        if (drawOrder != null) {\r\n            out.writeInt(drawOrder);\r\n        }\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "5d472b5f1430329360203403faee99d7d06a9a9e", "ext": "java", "lang": "Java", "content": "public class SupportedPointFormatsExtension extends HelloExtension {\n\n    private static final int LIST_LENGTH_BITS = 8;\n\n    private static final int POINT_FORMAT_BITS = 8;\n\n    /**\n     * Items in here are ordered according to the client's preferences (favorite\n     * choice first).\n     */\n    List<ECPointFormat> ecPointFormatList;\n\n    public SupportedPointFormatsExtension(List<ECPointFormat> ecPointFormatList) {\n        super(ExtensionType.EC_POINT_FORMATS);\n        this.ecPointFormatList = ecPointFormatList;\n    }\n\n    public void addECPointFormat(ECPointFormat format) {\n        ecPointFormatList.add(format);\n    }\n\n    @Override\n    public int getLength() {\n        // variable: number of point formats\n        return 5 + ecPointFormatList.size();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(super.toString());\n        sb.append(\"\\t\\t\\t\\tLength: \" + (getLength() - 4) + \"\\n\");\n        sb.append(\"\\t\\t\\t\\tEC point formats length: \" + (getLength() - 5) + \"\\n\");\n        sb.append(\"\\t\\t\\t\\tElliptic Curves Point Formats (\" + ecPointFormatList.size() + \"):\\n\");\n        for (ECPointFormat format : ecPointFormatList) {\n            sb.append(\"\\t\\t\\t\\t\\tEC point format: \" + format.toString() + \"\\n\");\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public byte[] toByteArray() {\n        DatagramWriter writer = new DatagramWriter();\n        writer.writeBytes(super.toByteArray());\n        int listLength = ecPointFormatList.size();\n        // list length + list length field (1 byte)\n        writer.write(listLength + 1, LENGTH_BITS);\n        writer.write(listLength, LIST_LENGTH_BITS);\n        for (ECPointFormat format : ecPointFormatList) {\n            writer.write(format.getId(), POINT_FORMAT_BITS);\n        }\n        return writer.toByteArray();\n    }\n\n    public static HelloExtension fromByteArray(byte[] byteArray) {\n        DatagramReader reader = new DatagramReader(byteArray);\n        int listLength = reader.read(LIST_LENGTH_BITS);\n        List<ECPointFormat> ecPointFormatList = new ArrayList<ECPointFormat>();\n        for (; listLength > 0; ) {\n            ECPointFormat format = ECPointFormat.getECPointFormatById(reader.read(POINT_FORMAT_BITS));\n            ecPointFormatList.add(format);\n            // one point format uses 1 byte\n            listLength -= 1;\n        }\n        return new SupportedPointFormatsExtension(ecPointFormatList);\n    }\n\n    /**\n     * See <a href=\"http://tools.ietf.org/html/rfc4492#section-5.1.2\">RFC 4492,\n     * 5.1.2. Supported Point Formats Extension</a>.\n     *\n     * @author Stefan Jucker\n     */\n    public enum ECPointFormat {\n\n        UNCOMPRESSED(0), ANSIX962_COMPRESSED_PRIME(1), ANSIX962_COMPRESSED_CHAR2(2);\n\n        private int id;\n\n        private ECPointFormat(int id) {\n            this.id = id;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        @Override\n        public String toString() {\n            switch(id) {\n                case 0:\n                    return \"uncompressed (\" + id + \")\";\n                case 1:\n                    return \"ansiX962_compressed_prime (\" + id + \")\";\n                case 2:\n                    return \"ansiX962_compressed_char2 (\" + id + \")\";\n                default:\n                    return \"\";\n            }\n        }\n\n        public static ECPointFormat getECPointFormatById(int id) {\n            switch(id) {\n                case 0:\n                    return ECPointFormat.UNCOMPRESSED;\n                case 1:\n                    return ECPointFormat.ANSIX962_COMPRESSED_PRIME;\n                case 2:\n                    return ECPointFormat.ANSIX962_COMPRESSED_CHAR2;\n                default:\n                    return null;\n            }\n        }\n    }\n}\n", "class_id": 0, "repo": "Orange-OpenSource/holico", "file": "sds/Californium/src/main/java/ch/ethz/inf/vs/californium/dtls/SupportedPointFormatsExtension.java", "last_update_at": "2021-06-22T08:52:33+00:00", "original_content": "public class SupportedPointFormatsExtension extends HelloExtension {\n\n    private static final int LIST_LENGTH_BITS = 8;\n\n    private static final int POINT_FORMAT_BITS = 8;\n\n    /**\n     * Items in here are ordered according to the client's preferences (favorite\n     * choice first).\n     */\n    List<ECPointFormat> ecPointFormatList;\n\n    public SupportedPointFormatsExtension(List<ECPointFormat> ecPointFormatList) {\n        super(ExtensionType.EC_POINT_FORMATS);\n        this.ecPointFormatList = ecPointFormatList;\n    }\n\n    public void addECPointFormat(ECPointFormat format) {\n        ecPointFormatList.add(format);\n    }\n\n    @Override\n    public int getLength() {\n        // variable: number of point formats\n        return 5 + ecPointFormatList.size();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(super.toString());\n        sb.append(\"\\t\\t\\t\\tLength: \" + (getLength() - 4) + \"\\n\");\n        sb.append(\"\\t\\t\\t\\tEC point formats length: \" + (getLength() - 5) + \"\\n\");\n        sb.append(\"\\t\\t\\t\\tElliptic Curves Point Formats (\" + ecPointFormatList.size() + \"):\\n\");\n        for (ECPointFormat format : ecPointFormatList) {\n            sb.append(\"\\t\\t\\t\\t\\tEC point format: \" + format.toString() + \"\\n\");\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public byte[] toByteArray() {\n        DatagramWriter writer = new DatagramWriter();\n        writer.writeBytes(super.toByteArray());\n        int listLength = ecPointFormatList.size();\n        // list length + list length field (1 byte)\n        writer.write(listLength + 1, LENGTH_BITS);\n        writer.write(listLength, LIST_LENGTH_BITS);\n        for (ECPointFormat format : ecPointFormatList) {\n            writer.write(format.getId(), POINT_FORMAT_BITS);\n        }\n        return writer.toByteArray();\n    }\n\n    public static HelloExtension fromByteArray(byte[] byteArray) {\n        DatagramReader reader = new DatagramReader(byteArray);\n        int listLength = reader.read(LIST_LENGTH_BITS);\n        List<ECPointFormat> ecPointFormatList = new ArrayList<ECPointFormat>();\n        while (listLength > 0) {\n            ECPointFormat format = ECPointFormat.getECPointFormatById(reader.read(POINT_FORMAT_BITS));\n            ecPointFormatList.add(format);\n            // one point format uses 1 byte\n            listLength -= 1;\n        }\n        return new SupportedPointFormatsExtension(ecPointFormatList);\n    }\n\n    /**\n     * See <a href=\"http://tools.ietf.org/html/rfc4492#section-5.1.2\">RFC 4492,\n     * 5.1.2. Supported Point Formats Extension</a>.\n     *\n     * @author Stefan Jucker\n     */\n    public enum ECPointFormat {\n\n        UNCOMPRESSED(0), ANSIX962_COMPRESSED_PRIME(1), ANSIX962_COMPRESSED_CHAR2(2);\n\n        private int id;\n\n        private ECPointFormat(int id) {\n            this.id = id;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        @Override\n        public String toString() {\n            switch(id) {\n                case 0:\n                    return \"uncompressed (\" + id + \")\";\n                case 1:\n                    return \"ansiX962_compressed_prime (\" + id + \")\";\n                case 2:\n                    return \"ansiX962_compressed_char2 (\" + id + \")\";\n                default:\n                    return \"\";\n            }\n        }\n\n        public static ECPointFormat getECPointFormatById(int id) {\n            switch(id) {\n                case 0:\n                    return ECPointFormat.UNCOMPRESSED;\n                case 1:\n                    return ECPointFormat.ANSIX962_COMPRESSED_PRIME;\n                case 2:\n                    return ECPointFormat.ANSIX962_COMPRESSED_CHAR2;\n                default:\n                    return null;\n            }\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "148008a50c8bbbb2285f3a440bc17c14279086c3", "ext": "java", "lang": "Java", "content": "@RunWith(JUnit4.class)\npublic class InheritanceHelperTest {\n\n    @Test\n    public void testEmptyChildList() {\n        // be copied to the child.\n        List<Resource> parentList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30), Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));\n        List<Resource> childList = Collections.emptyList();\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(parentList, result);\n    }\n\n    @Test\n    public void testOverrides() {\n        List<Resource> parentList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30));\n        List<Resource> childList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(childList, result);\n    }\n}\n", "class_id": 0, "repo": "7kasper/TerrainControl", "file": "common/src/test/java/com/khorn/terraincontrol/util/helpers/InheritanceHelperTest.java", "last_update_at": "2021-06-26T00:14:52+00:00", "original_content": "@RunWith(JUnit4.class)\npublic class InheritanceHelperTest {\n\n    @Test\n    public void testEmptyChildList() {\n        // be copied to the child.\n        List<Resource> parentList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30), Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));\n        List<Resource> childList = Collections.emptyList();\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(parentList, result);\n    }\n\n    @Test\n    public void testOverrides() {\n        List<Resource> parentList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30));\n        List<Resource> childList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));\n        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);\n        assertEquals(childList, result);\n    }\n}\n", "refactored": false}
{"hexsha": "d89d093a9df3cb37c4585f397e20182e3baca772", "ext": "java", "lang": "Java", "content": "public class Quini6Test {\n\n    @Test\n    public void testJugadorAlPasarPorPrimeraVezRecibe50000ASuCapital() {\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 150000);\n    }\n\n    @Test\n    public void testJugadorAlPasarPorSegundaVezRecibe30000ASuCapital() {\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n\n    @Test\n    public void testJugadorAlPasarPorTerceraVezNoRecibeIngresoASuCapital() {\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n}\n", "class_id": 0, "repo": "FdelMazo/TP-AlgoPoly", "file": "test/Modelo/Casilleros/Quini6Test.java", "last_update_at": "2021-11-20T18:41:38+00:00", "original_content": "public class Quini6Test {\n\n    @Test\n    public void testJugadorAlPasarPorPrimeraVezRecibe50000ASuCapital() {\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 150000);\n    }\n\n    @Test\n    public void testJugadorAlPasarPorSegundaVezRecibe30000ASuCapital() {\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n\n    @Test\n    public void testJugadorAlPasarPorTerceraVezNoRecibeIngresoASuCapital() {\n        Jugador jugador = new Jugador(\"Dio\");\n        Quini6 quini6 = new Quini6();\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        jugador.caeEn(quini6);\n        Assert.assertEquals(jugador.capital(), 180000);\n    }\n}\n", "refactored": false}
{"hexsha": "48a9c953325d8eadddafc395f69d25eaf7e14bb5", "ext": "java", "lang": "Java", "content": "public class QuadTreePool extends Pool<QuadTree> {\n\n    private QuadTreeContainer container;\n\n    public QuadTreePool(QuadTreeContainer container) {\n        super(50);\n        this.container = container;\n    }\n\n    public void freeSub(QuadTree quadTree) {\n        free(quadTree.ne);\n        free(quadTree.nw);\n        free(quadTree.se);\n        free(quadTree.sw);\n        quadTree.ne = quadTree.nw = quadTree.se = quadTree.sw = null;\n    }\n\n    public void initSubs(QuadTree quadTree) {\n        quadTree.ne = container.poolQuads.obtain();\n        quadTree.nw = container.poolQuads.obtain();\n        quadTree.se = container.poolQuads.obtain();\n        quadTree.sw = container.poolQuads.obtain();\n    }\n\n    @Override\n    protected QuadTree newObject() {\n        return new QuadTree(container);\n    }\n}\n", "class_id": 0, "repo": "fabiitch/NztBox", "file": "src/main/java/com/nzt/box/math/quadtree/pools/QuadTreePool.java", "last_update_at": "2021-12-10T11:26:19+00:00", "original_content": "public class QuadTreePool extends Pool<QuadTree> {\n\n    private QuadTreeContainer container;\n\n    public QuadTreePool(QuadTreeContainer container) {\n        super(50);\n        this.container = container;\n    }\n\n    public void freeSub(QuadTree quadTree) {\n        free(quadTree.ne);\n        free(quadTree.nw);\n        free(quadTree.se);\n        free(quadTree.sw);\n        quadTree.ne = quadTree.nw = quadTree.se = quadTree.sw = null;\n    }\n\n    public void initSubs(QuadTree quadTree) {\n        quadTree.ne = container.poolQuads.obtain();\n        quadTree.nw = container.poolQuads.obtain();\n        quadTree.se = container.poolQuads.obtain();\n        quadTree.sw = container.poolQuads.obtain();\n    }\n\n    @Override\n    protected QuadTree newObject() {\n        return new QuadTree(container);\n    }\n}\n", "refactored": false}
{"hexsha": "2ec0e02382de9a93dd698a861f3d7345f8e857b8", "ext": "java", "lang": "Java", "content": "public class LeetCode0387FirstUniqueCharacterTest {\n\n    private final static Logger logger = LoggerFactory.getLogger(LeetCode0387FirstUniqueCharacterTest.class);\n\n    /**\n     */\n    @Test\n    public void testMain() {\n        logger.debug(\"BEGIN\");\n        String data = \"lovelycomossez\";\n        System.out.println(firstUniqChar(data));\n        System.out.println(firstUniqCharString(data));\n    }\n\n    /**\n     * Return the first Uniq Char String index\n     *\n     * @param data\n     * @return\n     */\n    private int firstUniqChar(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return -1;\n        }\n        int retVal = -1;\n        LinkedHashMap<Character, String> retMap = new LinkedHashMap<Character, String>();\n        char[] chStr = data.toCharArray();\n        int i = 0;\n        while (i < chStr.length) try {\n            if (retMap.get(chStr[i]) != null) {\n                retMap.put(chStr[i], retMap.get(chStr[i]) + \"#\" + String.valueOf(i));\n            } else {\n                retMap.put(chStr[i], String.valueOf(i));\n            }\n        } finally {\n            i++;\n        }\n        for (Map.Entry me : retMap.entrySet()) {\n            String val = \"\" + me.getValue();\n            if (!val.contains(\"#\")) {\n                retVal = Integer.valueOf(val);\n                break;\n            }\n        }\n        return retVal;\n    }\n\n    /**\n     * Return the first Uniq Char String without using Map\n     * @param data\n     * @return\n     */\n    private String firstUniqCharString(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return \"\";\n        }\n        char[] strArray = data.toCharArray();\n        String retStr = \"\";\n        if (data.length() == 1) {\n            retStr = data;\n        }\n        int i = 0;\n        while (i < strArray.length) try {\n            String valStr = Character.toString(strArray[i]);\n            String rData = data;\n            rData = data.replace(valStr, \"\");\n            rData = rData.replace(valStr.toUpperCase(Locale.ROOT), \"\");\n            rData = rData.replace(valStr.toLowerCase(Locale.ROOT), \"\");\n            if (rData.length() == 0) {\n                retStr = \"\";\n            } else if (rData.length() + 1 == data.length()) {\n                retStr = valStr;\n                break;\n            }\n        } finally {\n            i++;\n        }\n        return retStr;\n    }\n}\n", "class_id": 0, "repo": "cwiki-us/Java-Tutorial", "file": "toolkits/codebank/src/test/java/com/ossez/toolkits/codebank/tests/leetcode/LeetCode0387FirstUniqueCharacterTest.java", "last_update_at": "2021-04-26T04:18:19+00:00", "original_content": "public class LeetCode0387FirstUniqueCharacterTest {\n\n    private final static Logger logger = LoggerFactory.getLogger(LeetCode0387FirstUniqueCharacterTest.class);\n\n    /**\n     */\n    @Test\n    public void testMain() {\n        logger.debug(\"BEGIN\");\n        String data = \"lovelycomossez\";\n        System.out.println(firstUniqChar(data));\n        System.out.println(firstUniqCharString(data));\n    }\n\n    /**\n     * Return the first Uniq Char String index\n     *\n     * @param data\n     * @return\n     */\n    private int firstUniqChar(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return -1;\n        }\n        int retVal = -1;\n        LinkedHashMap<Character, String> retMap = new LinkedHashMap<Character, String>();\n        char[] chStr = data.toCharArray();\n        for (int i = 0; i < chStr.length; i++) {\n            if (retMap.get(chStr[i]) != null) {\n                retMap.put(chStr[i], retMap.get(chStr[i]) + \"#\" + String.valueOf(i));\n            } else {\n                retMap.put(chStr[i], String.valueOf(i));\n            }\n        }\n        for (Map.Entry me : retMap.entrySet()) {\n            String val = \"\" + me.getValue();\n            if (!val.contains(\"#\")) {\n                retVal = Integer.valueOf(val);\n                break;\n            }\n        }\n        return retVal;\n    }\n\n    /**\n     * Return the first Uniq Char String without using Map\n     * @param data\n     * @return\n     */\n    private String firstUniqCharString(String data) {\n        // NULL CHECK\n        if (data.equals(\"\")) {\n            return \"\";\n        }\n        char[] strArray = data.toCharArray();\n        String retStr = \"\";\n        if (data.length() == 1) {\n            retStr = data;\n        }\n        for (int i = 0; i < strArray.length; i++) {\n            String valStr = Character.toString(strArray[i]);\n            String rData = data;\n            rData = data.replace(valStr, \"\");\n            rData = rData.replace(valStr.toUpperCase(Locale.ROOT), \"\");\n            rData = rData.replace(valStr.toLowerCase(Locale.ROOT), \"\");\n            if (rData.length() == 0) {\n                retStr = \"\";\n            } else if (rData.length() + 1 == data.length()) {\n                retStr = valStr;\n                break;\n            }\n        }\n        return retStr;\n    }\n}\n", "refactored": true}
{"hexsha": "c841148268d578f4c981485c7835479bf60d2d61", "ext": "java", "lang": "Java", "content": "public class CertificateExtensionAppAuthenticator implements ExtensionAppAuthenticator {\n\n    private final TokensRepository tokensRepository;\n\n    private final SymExtensionAppAuth symExtensionAppAuth;\n\n    public CertificateExtensionAppAuthenticator(SymConfig symConfig, TokensRepository tokensRepository) {\n        symExtensionAppAuth = new SymExtensionAppAuth(symConfig);\n        this.tokensRepository = tokensRepository;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public AppAuthResponse appAuthenticate() {\n        AppAuthResponse appAuthResponse = symExtensionAppAuth.sessionAppAuthenticate(generateAppToken());\n        if (appAuthResponse != null) {\n            tokensRepository.save(appAuthResponse);\n        }\n        return appAuthResponse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean validateTokens(String appToken, String symphonyToken) {\n        return tokensRepository.get(appToken).filter(token -> token.getSymphonyToken().equals(symphonyToken)).isPresent();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserInfo verifyJWT(String jwt) {\n        return symExtensionAppAuth.verifyJWT(jwt, new String[0]);\n    }\n\n    private String generateAppToken() {\n        byte[] randBytes = new byte[64];\n        new SecureRandom().nextBytes(randBytes);\n        return Hex.encodeHexString(randBytes);\n    }\n}\n", "class_id": 0, "repo": "micaste/symphony-api-client-java", "file": "symphony-bdk-legacy/symphony-bdk-bot-sdk-java/src/main/java/com/symphony/bdk/bot/sdk/symphony/authentication/CertificateExtensionAppAuthenticator.java", "last_update_at": "2021-04-22T10:57:49+00:00", "original_content": "public class CertificateExtensionAppAuthenticator implements ExtensionAppAuthenticator {\n\n    private final TokensRepository tokensRepository;\n\n    private final SymExtensionAppAuth symExtensionAppAuth;\n\n    public CertificateExtensionAppAuthenticator(SymConfig symConfig, TokensRepository tokensRepository) {\n        symExtensionAppAuth = new SymExtensionAppAuth(symConfig);\n        this.tokensRepository = tokensRepository;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public AppAuthResponse appAuthenticate() {\n        AppAuthResponse appAuthResponse = symExtensionAppAuth.sessionAppAuthenticate(generateAppToken());\n        if (appAuthResponse != null) {\n            tokensRepository.save(appAuthResponse);\n        }\n        return appAuthResponse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean validateTokens(String appToken, String symphonyToken) {\n        return tokensRepository.get(appToken).filter(token -> token.getSymphonyToken().equals(symphonyToken)).isPresent();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserInfo verifyJWT(String jwt) {\n        return symExtensionAppAuth.verifyJWT(jwt, new String[0]);\n    }\n\n    private String generateAppToken() {\n        byte[] randBytes = new byte[64];\n        new SecureRandom().nextBytes(randBytes);\n        return Hex.encodeHexString(randBytes);\n    }\n}\n", "refactored": false}
{"hexsha": "1818ef99173a05fb9a278b65c8a3ba47949352bd", "ext": "java", "lang": "Java", "content": "public class Timetable {\n\n    private final String group;\n\n    private final String semiGroup;\n\n    private final int semester;\n\n    private List<Activity> allActivities;\n\n    /**\n     * Constructor for the timetable. It parses all the lines, storing the necessary information for the given group.\n     *\n     * @param website - a ParseURL object containing the HTML source code lines\n     * @param group   - the group number\n     * @throws IOException\n     */\n    public Timetable(ParseURL website, final String group, final String semiGroup) throws IOException {\n        this.group = group;\n        this.semiGroup = semiGroup;\n        allActivities = new ArrayList<>();\n        semester = website.getSemester();\n        List<String> htmlCode = website.getLines();\n        if (!tableExists(htmlCode, group)) {\n            throw new InvalidParameterException(\"The given URL does not contain the timetable for group \" + group);\n        }\n        List<String> tableOfGroup = getTableOfGroup(htmlCode, group);\n        List<List<String>> rows = divideIntoRows(tableOfGroup);\n        rows.forEach(row -> allActivities.add(processRow(row)));\n        filterActivities();\n    }\n\n    public Timetable(ParseURL website, final String group, final String semiGroup, List<String> filteredActivities) throws IOException {\n        this(website, group, semiGroup);\n        allActivities = allActivities.stream().filter(activity -> filteredActivities.contains(activity.getNameOfActivity())).collect(Collectors.toList());\n    }\n\n    private List<String> getTableOfGroup(List<String> htmlCode, final String group) {\n        Pattern beginningOfTable = Pattern.compile(\"<table .*>\");\n        Pattern endOfTable = Pattern.compile(\"</table>\");\n        int wantedTable = group.charAt(group.length() - 1) - '0';\n        int indexOfBeginning = -1, indexOfEnd = -1;\n        int i = 0, foundTable = 0;\n        while (i < htmlCode.size()) try {\n            if (foundTable < wantedTable) {\n                Matcher matcherTable = beginningOfTable.matcher(htmlCode.get(i));\n                if (matcherTable.matches()) {\n                    foundTable++;\n                    if (wantedTable == foundTable) {\n                        indexOfBeginning = i + 1;\n                    }\n                }\n            }\n            if (foundTable == wantedTable) {\n                Matcher matcherEndTable = endOfTable.matcher(htmlCode.get(i));\n                if (matcherEndTable.matches()) {\n                    indexOfEnd = i;\n                    break;\n                }\n            }\n        } finally {\n            i++;\n        }\n        return htmlCode.subList(indexOfBeginning, indexOfEnd);\n    }\n\n    private List<List<String>> divideIntoRows(List<String> table) {\n        Pattern beginningOfRow = Pattern.compile(\"<tr .*>\");\n        Pattern endOfRow = Pattern.compile(\"</tr>\");\n        List<List<String>> rows = new ArrayList<>();\n        List<String> currentRow = new ArrayList<>();\n        boolean inRow = false;\n        for (String line : table) {\n            Matcher endOfRowMatcher = endOfRow.matcher(line);\n            if (endOfRowMatcher.matches()) {\n                rows.add(currentRow);\n                currentRow = new ArrayList<>();\n                inRow = false;\n            }\n            if (inRow) {\n                currentRow.add(line);\n            } else {\n                Matcher beginningOfRowMatcher = beginningOfRow.matcher(line);\n                if (beginningOfRowMatcher.matches()) {\n                    inRow = true;\n                }\n            }\n        }\n        //information, it should be ignored\n        return rows.subList(1, rows.size());\n    }\n\n    private boolean tableExists(List<String> htmlCode, String group) {\n        Pattern groupPattern = Pattern.compile(\".*Grupa \" + group + \".*\");\n        return htmlCode.stream().anyMatch(line -> groupPattern.matcher(line).matches());\n    }\n\n    private Activity processRow(List<String> row) {\n        Activity activity = new Activity();\n        int currentColumn = 0;\n        for (String column : row) {\n            Pattern informationPattern = Pattern.compile(\".*>([^<]+)<.*\");\n            Matcher matcher = informationPattern.matcher(column);\n            if (matcher.find()) {\n                String information = matcher.group(1);\n                activity.setInformation(currentColumn, information);\n            }\n            currentColumn++;\n        }\n        return activity;\n    }\n\n    private void filterActivities() {\n        allActivities = allActivities.stream().filter(activity -> activity.isForSemiGroup(semiGroup)).collect(Collectors.toList());\n    }\n\n    public List<Activity> getAllActivities() {\n        return allActivities;\n    }\n\n    public String getGroup() {\n        return group;\n    }\n\n    public String getSemiGroup() {\n        return semiGroup;\n    }\n\n    public int getSemester() {\n        return semester;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n        for (Activity activity : allActivities) {\n            output.append(activity);\n        }\n        return output.toString();\n    }\n}\n", "class_id": 0, "repo": "harababurel/timetable-builder", "file": "src/main/java/model/Timetable.java", "last_update_at": "2021-02-25T16:40:10+00:00", "original_content": "public class Timetable {\n\n    private final String group;\n\n    private final String semiGroup;\n\n    private final int semester;\n\n    private List<Activity> allActivities;\n\n    /**\n     * Constructor for the timetable. It parses all the lines, storing the necessary information for the given group.\n     *\n     * @param website - a ParseURL object containing the HTML source code lines\n     * @param group   - the group number\n     * @throws IOException\n     */\n    public Timetable(ParseURL website, final String group, final String semiGroup) throws IOException {\n        this.group = group;\n        this.semiGroup = semiGroup;\n        allActivities = new ArrayList<>();\n        semester = website.getSemester();\n        List<String> htmlCode = website.getLines();\n        if (!tableExists(htmlCode, group)) {\n            throw new InvalidParameterException(\"The given URL does not contain the timetable for group \" + group);\n        }\n        List<String> tableOfGroup = getTableOfGroup(htmlCode, group);\n        List<List<String>> rows = divideIntoRows(tableOfGroup);\n        rows.forEach(row -> allActivities.add(processRow(row)));\n        filterActivities();\n    }\n\n    public Timetable(ParseURL website, final String group, final String semiGroup, List<String> filteredActivities) throws IOException {\n        this(website, group, semiGroup);\n        allActivities = allActivities.stream().filter(activity -> filteredActivities.contains(activity.getNameOfActivity())).collect(Collectors.toList());\n    }\n\n    private List<String> getTableOfGroup(List<String> htmlCode, final String group) {\n        Pattern beginningOfTable = Pattern.compile(\"<table .*>\");\n        Pattern endOfTable = Pattern.compile(\"</table>\");\n        int wantedTable = group.charAt(group.length() - 1) - '0';\n        int indexOfBeginning = -1, indexOfEnd = -1;\n        for (int i = 0, foundTable = 0; i < htmlCode.size(); i++) {\n            if (foundTable < wantedTable) {\n                Matcher matcherTable = beginningOfTable.matcher(htmlCode.get(i));\n                if (matcherTable.matches()) {\n                    foundTable++;\n                    if (wantedTable == foundTable) {\n                        indexOfBeginning = i + 1;\n                    }\n                }\n            }\n            if (foundTable == wantedTable) {\n                Matcher matcherEndTable = endOfTable.matcher(htmlCode.get(i));\n                if (matcherEndTable.matches()) {\n                    indexOfEnd = i;\n                    break;\n                }\n            }\n        }\n        return htmlCode.subList(indexOfBeginning, indexOfEnd);\n    }\n\n    private List<List<String>> divideIntoRows(List<String> table) {\n        Pattern beginningOfRow = Pattern.compile(\"<tr .*>\");\n        Pattern endOfRow = Pattern.compile(\"</tr>\");\n        List<List<String>> rows = new ArrayList<>();\n        List<String> currentRow = new ArrayList<>();\n        boolean inRow = false;\n        for (String line : table) {\n            Matcher endOfRowMatcher = endOfRow.matcher(line);\n            if (endOfRowMatcher.matches()) {\n                rows.add(currentRow);\n                currentRow = new ArrayList<>();\n                inRow = false;\n            }\n            if (inRow) {\n                currentRow.add(line);\n            } else {\n                Matcher beginningOfRowMatcher = beginningOfRow.matcher(line);\n                if (beginningOfRowMatcher.matches()) {\n                    inRow = true;\n                }\n            }\n        }\n        //information, it should be ignored\n        return rows.subList(1, rows.size());\n    }\n\n    private boolean tableExists(List<String> htmlCode, String group) {\n        Pattern groupPattern = Pattern.compile(\".*Grupa \" + group + \".*\");\n        return htmlCode.stream().anyMatch(line -> groupPattern.matcher(line).matches());\n    }\n\n    private Activity processRow(List<String> row) {\n        Activity activity = new Activity();\n        int currentColumn = 0;\n        for (String column : row) {\n            Pattern informationPattern = Pattern.compile(\".*>([^<]+)<.*\");\n            Matcher matcher = informationPattern.matcher(column);\n            if (matcher.find()) {\n                String information = matcher.group(1);\n                activity.setInformation(currentColumn, information);\n            }\n            currentColumn++;\n        }\n        return activity;\n    }\n\n    private void filterActivities() {\n        allActivities = allActivities.stream().filter(activity -> activity.isForSemiGroup(semiGroup)).collect(Collectors.toList());\n    }\n\n    public List<Activity> getAllActivities() {\n        return allActivities;\n    }\n\n    public String getGroup() {\n        return group;\n    }\n\n    public String getSemiGroup() {\n        return semiGroup;\n    }\n\n    public int getSemester() {\n        return semester;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder output = new StringBuilder();\n        for (Activity activity : allActivities) {\n            output.append(activity);\n        }\n        return output.toString();\n    }\n}\n", "refactored": true}
{"hexsha": "48385fa6bc6bfb5933e597d776cf834b02f5dee2", "ext": "java", "lang": "Java", "content": "public class HandsVisualization extends GenericWindow implements Visualization {\n\n    HandsRenderer renderer;\n\n    @Override\n    public void show() {\n        renderer.setSize(640, 480);\n        viewFrame.add(\"Center\", renderer);\n        viewFrame.setSize(renderer.getWidth(), renderer.getHeight());\n        viewFrame.setVisible(true);\n        new Thread(this).start();\n    }\n\n    public HandsVisualization(NiTETracker tracker, String name) {\n        super(name);\n        renderer = new HandsRenderer(tracker.getHandTracker());\n        tracker.addHandsListener(renderer);\n    }\n}\n", "class_id": 0, "repo": "isabella232/screenful-gestures", "file": "server/Screenful-GestureServer/src/screenful/gui/visualization/HandsVisualization.java", "last_update_at": "2021-11-03T17:04:01+00:00", "original_content": "public class HandsVisualization extends GenericWindow implements Visualization {\n\n    HandsRenderer renderer;\n\n    @Override\n    public void show() {\n        renderer.setSize(640, 480);\n        viewFrame.add(\"Center\", renderer);\n        viewFrame.setSize(renderer.getWidth(), renderer.getHeight());\n        viewFrame.setVisible(true);\n        new Thread(this).start();\n    }\n\n    public HandsVisualization(NiTETracker tracker, String name) {\n        super(name);\n        renderer = new HandsRenderer(tracker.getHandTracker());\n        tracker.addHandsListener(renderer);\n    }\n}\n", "refactored": false}
{"hexsha": "e4b942f15ea71c6bd3c05404bc0adeed6fb51639", "ext": "java", "lang": "Java", "content": "public final class JobConfGenDriver {\r\n\r\n    private static final Log logger = LogFactory.getLog(JobConfGenDriver.class.getName());\r\n\r\n    private static final String METHOD_DECLARATION = \"(/\\\\*(.+?)\\\\*/)([^;]+;)\";\r\n\r\n    private static final String COMMENT_PATTERN = \"(\\\\w+\\\\s*)(:)([^\\\\r\\\\n]+)\";\r\n\r\n    private static final String MEMBER_PATTERN = \"([^=]=\\\\s*)(\\\"[^\\\"]+\\\")\";\r\n\r\n    public enum PluginType {\r\n\r\n        Reader, Writer\r\n    }\r\n\r\n    // Suppress default constructor for non-instantiability\r\n    private JobConfGenDriver() {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    public static void showCopyRight() {\r\n        System.out.println(\"Welcome to using DianPing WormHole Version 0.1\");\r\n    }\r\n\r\n    public static List<String> getPluginDirAsList(String pluginsDirName) {\r\n        List<String> pluginsList = new ArrayList<String>();\r\n        String lastNameOfPluginsDirName = pluginsDirName.substring(pluginsDirName.lastIndexOf(File.separator) + 1);\r\n        for (File file : new File(pluginsDirName).listFiles()) {\r\n            if (file.isDirectory() && file.getName().endsWith(lastNameOfPluginsDirName)) {\r\n                pluginsList.add(file.getName());\r\n            }\r\n        }\r\n        Collections.sort(pluginsList);\r\n        return pluginsList;\r\n    }\r\n\r\n    public static int showPluginsInfo(String prefixInfo, List<String> pluginsList) {\r\n        int pluginsSize = pluginsList.size();\r\n        int choice = -1;\r\n        for (; choice < 0 || choice > pluginsSize - 1; ) {\r\n            System.out.println(prefixInfo);\r\n            for (int idx = 0; idx < pluginsSize; idx++) {\r\n                System.out.println(String.format(\"%d\\t%s\", idx, pluginsList.get(idx).toLowerCase().replace(\"reader\", \"\").replace(\"writer\", \"\")));\r\n            }\r\n            System.out.print(String.format(\"Please choose [%d-%d]: \", 0, pluginsSize - 1));\r\n            try {\r\n                choice = Integer.parseInt(new Scanner(System.in).nextLine());\r\n            } catch (NumberFormatException e) {\r\n                System.out.println(\"Your chosen number is not correct. Please choose it again.\");\r\n                choice = -1;\r\n            }\r\n        }\r\n        return choice;\r\n    }\r\n\r\n    public static void generateJobConfXml() throws IOException {\r\n        showCopyRight();\r\n        Map<PluginType, List<String>> pluginMap = new HashMap<PluginType, List<String>>();\r\n        pluginMap.put(PluginType.Reader, getPluginDirAsList(Environment.READER_PLUGINS_DIR));\r\n        pluginMap.put(PluginType.Writer, getPluginDirAsList(Environment.WRITER_PLUGINS_DIR));\r\n        int readerPluginIndex = showPluginsInfo(\"WormHole Data Source: \", pluginMap.get(PluginType.Reader));\r\n        int writerPluginIndex = showPluginsInfo(\"WormHole Data Destination: \", pluginMap.get(PluginType.Writer));\r\n        String readerPluginName = pluginMap.get(PluginType.Reader).get(readerPluginIndex);\r\n        String writerPluginName = pluginMap.get(PluginType.Writer).get(writerPluginIndex);\r\n        String readerPluginPath = String.format(\"%s/%s/ParamKey.java\", Environment.READER_PLUGINS_DIR, readerPluginName);\r\n        String writerPluginPath = String.format(\"%s/%s/ParamKey.java\", Environment.WRITER_PLUGINS_DIR, writerPluginName);\r\n        ClassNode readerClassNode = parse(readerPluginName, readerPluginPath);\r\n        ClassNode writerClassNode = parse(writerPluginName, writerPluginPath);\r\n        String jobFileName = MessageFormat.format(\"wormhole_{0}_to_{1}_{2}.xml\", readerClassNode.getName(), writerClassNode.getName(), System.currentTimeMillis());\r\n        int retStatus = generateXmlFile(readerClassNode, writerClassNode, jobFileName);\r\n        if (0 == retStatus) {\r\n            System.out.println(String.format(\"Create jobfile %s completed.\", jobFileName));\r\n        }\r\n    }\r\n\r\n    public static int generateXmlFile(ClassNode readerClassNode, ClassNode writerClassNode, String fileName) throws IOException {\r\n        Document doc = DocumentHelper.createDocument();\r\n        Element jobE = doc.addElement(\"job\");\r\n        String jobId = readerClassNode.getName() + \"_to_\" + writerClassNode.getName() + \"_job\";\r\n        jobE.addAttribute(\"id\", jobId);\r\n        /* add reader part */\r\n        Element readerE = jobE.addElement(\"reader\");\r\n        Element pluginE = readerE.addElement(\"plugin\");\r\n        pluginE.setText(readerClassNode.getName());\r\n        Element tempElement = null;\r\n        List<ClassMember> members = readerClassNode.getAllMembers();\r\n        for (ClassMember member : members) {\r\n            StringBuilder command = new StringBuilder(\"\\n\");\r\n            Set<String> set = member.getAllKeys();\r\n            String value = \"\";\r\n            for (String key : set) {\r\n                value = member.getAttr(\"default\");\r\n                command.append(key).append(\":\").append(member.getAttr(key)).append(\"\\n\");\r\n            }\r\n            readerE.addComment(command.toString());\r\n            String keyName = member.getName();\r\n            keyName = keyName.substring(1, keyName.length() - 1);\r\n            tempElement = readerE.addElement(keyName);\r\n            if (StringUtils.isEmpty(value)) {\r\n                value = \"\";\r\n            }\r\n            tempElement.setText(value);\r\n        }\r\n        /* add writer part */\r\n        Element writerE = jobE.addElement(\"writer\");\r\n        pluginE = writerE.addElement(\"plugin\");\r\n        pluginE.setText(writerClassNode.getName());\r\n        members = writerClassNode.getAllMembers();\r\n        for (ClassMember member : members) {\r\n            StringBuilder command = new StringBuilder(\"\\n\");\r\n            Set<String> set = member.getAllKeys();\r\n            String value = \"\";\r\n            for (String key : set) {\r\n                value = member.getAttr(\"default\");\r\n                command.append(key).append(\":\").append(member.getAttr(key)).append(\"\\n\");\r\n            }\r\n            writerE.addComment(command.toString());\r\n            String keyName = member.getName();\r\n            keyName = keyName.substring(1, keyName.length() - 1);\r\n            tempElement = writerE.addElement(keyName);\r\n            if (!StringUtils.isBlank(value)) {\r\n                tempElement.addText(value);\r\n            } else {\r\n                tempElement.addText(\"\");\r\n            }\r\n        }\r\n        XMLWriter output;\r\n        OutputFormat format = OutputFormat.createPrettyPrint();\r\n        format.setEncoding(\"UTF-8\");\r\n        output = new XMLWriter(new FileWriter(fileName), format);\r\n        output.write(doc);\r\n        output.close();\r\n        return 0;\r\n    }\r\n\r\n    public static ClassNode parse(String name, String path) {\r\n        String source = \"\";\r\n        try {\r\n            source = FileUtils.readFileToString(new File(path));\r\n        } catch (IOException e) {\r\n            logger.error(org.apache.hadoop.util.StringUtils.stringifyException(e));\r\n            return null;\r\n        }\r\n        source = source.substring(source.indexOf('{') + 1);\r\n        source = source.substring(0, source.lastIndexOf('}'));\r\n        ClassNode node = ClassNode.newInstance();\r\n        node.setName(name);\r\n        Pattern pattern = Pattern.compile(METHOD_DECLARATION, Pattern.DOTALL);\r\n        Matcher matcher = pattern.matcher(source);\r\n        for (; matcher.find(); ) {\r\n            /* parse comment */\r\n            Pattern commentPattern = Pattern.compile(COMMENT_PATTERN);\r\n            Matcher commentMatcher = commentPattern.matcher(matcher.group(1));\r\n            if (!commentMatcher.find()) {\r\n                throw new IllegalArgumentException(\"File format error: class declaration without comment @\" + matcher.group(1));\r\n            }\r\n            Map<String, String> attributes = new HashMap<String, String>();\r\n            for (; ; ) try {\r\n                attributes.put(commentMatcher.group(1), commentMatcher.group(3).trim());\r\n            } finally {\r\n                if (!commentMatcher.find()) {\r\n                    break;\r\n                }\r\n            }\r\n            /* add key */\r\n            Pattern memberPattern = Pattern.compile(MEMBER_PATTERN);\r\n            Matcher memberMatcher = memberPattern.matcher(matcher.group(3));\r\n            if (!memberMatcher.find()) {\r\n                throw new IllegalArgumentException(\"File format error: comment without member declaration @\" + matcher.group(3));\r\n            }\r\n            node.addMember(ClassNode.createMember(memberMatcher.group(2), attributes));\r\n        }\r\n        return node;\r\n    }\r\n}\r\n", "class_id": 0, "repo": "kangzhenkang/wormhole", "file": "src/main/java/com/dp/nebula/wormhole/common/utils/JobConfGenDriver.java", "last_update_at": "2021-04-11T05:29:02+00:00", "original_content": "public final class JobConfGenDriver {\r\n\r\n    private static final Log logger = LogFactory.getLog(JobConfGenDriver.class.getName());\r\n\r\n    private static final String METHOD_DECLARATION = \"(/\\\\*(.+?)\\\\*/)([^;]+;)\";\r\n\r\n    private static final String COMMENT_PATTERN = \"(\\\\w+\\\\s*)(:)([^\\\\r\\\\n]+)\";\r\n\r\n    private static final String MEMBER_PATTERN = \"([^=]=\\\\s*)(\\\"[^\\\"]+\\\")\";\r\n\r\n    public enum PluginType {\r\n\r\n        Reader, Writer\r\n    }\r\n\r\n    // Suppress default constructor for non-instantiability\r\n    private JobConfGenDriver() {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    public static void showCopyRight() {\r\n        System.out.println(\"Welcome to using DianPing WormHole Version 0.1\");\r\n    }\r\n\r\n    public static List<String> getPluginDirAsList(String pluginsDirName) {\r\n        List<String> pluginsList = new ArrayList<String>();\r\n        String lastNameOfPluginsDirName = pluginsDirName.substring(pluginsDirName.lastIndexOf(File.separator) + 1);\r\n        for (File file : new File(pluginsDirName).listFiles()) {\r\n            if (file.isDirectory() && file.getName().endsWith(lastNameOfPluginsDirName)) {\r\n                pluginsList.add(file.getName());\r\n            }\r\n        }\r\n        Collections.sort(pluginsList);\r\n        return pluginsList;\r\n    }\r\n\r\n    public static int showPluginsInfo(String prefixInfo, List<String> pluginsList) {\r\n        int pluginsSize = pluginsList.size();\r\n        int choice = -1;\r\n        while (choice < 0 || choice > pluginsSize - 1) {\r\n            System.out.println(prefixInfo);\r\n            for (int idx = 0; idx < pluginsSize; idx++) {\r\n                System.out.println(String.format(\"%d\\t%s\", idx, pluginsList.get(idx).toLowerCase().replace(\"reader\", \"\").replace(\"writer\", \"\")));\r\n            }\r\n            System.out.print(String.format(\"Please choose [%d-%d]: \", 0, pluginsSize - 1));\r\n            try {\r\n                choice = Integer.parseInt(new Scanner(System.in).nextLine());\r\n            } catch (NumberFormatException e) {\r\n                System.out.println(\"Your chosen number is not correct. Please choose it again.\");\r\n                choice = -1;\r\n            }\r\n        }\r\n        return choice;\r\n    }\r\n\r\n    public static void generateJobConfXml() throws IOException {\r\n        showCopyRight();\r\n        Map<PluginType, List<String>> pluginMap = new HashMap<PluginType, List<String>>();\r\n        pluginMap.put(PluginType.Reader, getPluginDirAsList(Environment.READER_PLUGINS_DIR));\r\n        pluginMap.put(PluginType.Writer, getPluginDirAsList(Environment.WRITER_PLUGINS_DIR));\r\n        int readerPluginIndex = showPluginsInfo(\"WormHole Data Source: \", pluginMap.get(PluginType.Reader));\r\n        int writerPluginIndex = showPluginsInfo(\"WormHole Data Destination: \", pluginMap.get(PluginType.Writer));\r\n        String readerPluginName = pluginMap.get(PluginType.Reader).get(readerPluginIndex);\r\n        String writerPluginName = pluginMap.get(PluginType.Writer).get(writerPluginIndex);\r\n        String readerPluginPath = String.format(\"%s/%s/ParamKey.java\", Environment.READER_PLUGINS_DIR, readerPluginName);\r\n        String writerPluginPath = String.format(\"%s/%s/ParamKey.java\", Environment.WRITER_PLUGINS_DIR, writerPluginName);\r\n        ClassNode readerClassNode = parse(readerPluginName, readerPluginPath);\r\n        ClassNode writerClassNode = parse(writerPluginName, writerPluginPath);\r\n        String jobFileName = MessageFormat.format(\"wormhole_{0}_to_{1}_{2}.xml\", readerClassNode.getName(), writerClassNode.getName(), System.currentTimeMillis());\r\n        int retStatus = generateXmlFile(readerClassNode, writerClassNode, jobFileName);\r\n        if (0 == retStatus) {\r\n            System.out.println(String.format(\"Create jobfile %s completed.\", jobFileName));\r\n        }\r\n    }\r\n\r\n    public static int generateXmlFile(ClassNode readerClassNode, ClassNode writerClassNode, String fileName) throws IOException {\r\n        Document doc = DocumentHelper.createDocument();\r\n        Element jobE = doc.addElement(\"job\");\r\n        String jobId = readerClassNode.getName() + \"_to_\" + writerClassNode.getName() + \"_job\";\r\n        jobE.addAttribute(\"id\", jobId);\r\n        /* add reader part */\r\n        Element readerE = jobE.addElement(\"reader\");\r\n        Element pluginE = readerE.addElement(\"plugin\");\r\n        pluginE.setText(readerClassNode.getName());\r\n        Element tempElement = null;\r\n        List<ClassMember> members = readerClassNode.getAllMembers();\r\n        for (ClassMember member : members) {\r\n            StringBuilder command = new StringBuilder(\"\\n\");\r\n            Set<String> set = member.getAllKeys();\r\n            String value = \"\";\r\n            for (String key : set) {\r\n                value = member.getAttr(\"default\");\r\n                command.append(key).append(\":\").append(member.getAttr(key)).append(\"\\n\");\r\n            }\r\n            readerE.addComment(command.toString());\r\n            String keyName = member.getName();\r\n            keyName = keyName.substring(1, keyName.length() - 1);\r\n            tempElement = readerE.addElement(keyName);\r\n            if (StringUtils.isEmpty(value)) {\r\n                value = \"\";\r\n            }\r\n            tempElement.setText(value);\r\n        }\r\n        /* add writer part */\r\n        Element writerE = jobE.addElement(\"writer\");\r\n        pluginE = writerE.addElement(\"plugin\");\r\n        pluginE.setText(writerClassNode.getName());\r\n        members = writerClassNode.getAllMembers();\r\n        for (ClassMember member : members) {\r\n            StringBuilder command = new StringBuilder(\"\\n\");\r\n            Set<String> set = member.getAllKeys();\r\n            String value = \"\";\r\n            for (String key : set) {\r\n                value = member.getAttr(\"default\");\r\n                command.append(key).append(\":\").append(member.getAttr(key)).append(\"\\n\");\r\n            }\r\n            writerE.addComment(command.toString());\r\n            String keyName = member.getName();\r\n            keyName = keyName.substring(1, keyName.length() - 1);\r\n            tempElement = writerE.addElement(keyName);\r\n            if (!StringUtils.isBlank(value)) {\r\n                tempElement.addText(value);\r\n            } else {\r\n                tempElement.addText(\"\");\r\n            }\r\n        }\r\n        XMLWriter output;\r\n        OutputFormat format = OutputFormat.createPrettyPrint();\r\n        format.setEncoding(\"UTF-8\");\r\n        output = new XMLWriter(new FileWriter(fileName), format);\r\n        output.write(doc);\r\n        output.close();\r\n        return 0;\r\n    }\r\n\r\n    public static ClassNode parse(String name, String path) {\r\n        String source = \"\";\r\n        try {\r\n            source = FileUtils.readFileToString(new File(path));\r\n        } catch (IOException e) {\r\n            logger.error(org.apache.hadoop.util.StringUtils.stringifyException(e));\r\n            return null;\r\n        }\r\n        source = source.substring(source.indexOf('{') + 1);\r\n        source = source.substring(0, source.lastIndexOf('}'));\r\n        ClassNode node = ClassNode.newInstance();\r\n        node.setName(name);\r\n        Pattern pattern = Pattern.compile(METHOD_DECLARATION, Pattern.DOTALL);\r\n        Matcher matcher = pattern.matcher(source);\r\n        while (matcher.find()) {\r\n            /* parse comment */\r\n            Pattern commentPattern = Pattern.compile(COMMENT_PATTERN);\r\n            Matcher commentMatcher = commentPattern.matcher(matcher.group(1));\r\n            if (!commentMatcher.find()) {\r\n                throw new IllegalArgumentException(\"File format error: class declaration without comment @\" + matcher.group(1));\r\n            }\r\n            Map<String, String> attributes = new HashMap<String, String>();\r\n            do {\r\n                attributes.put(commentMatcher.group(1), commentMatcher.group(3).trim());\r\n            } while (commentMatcher.find());\r\n            /* add key */\r\n            Pattern memberPattern = Pattern.compile(MEMBER_PATTERN);\r\n            Matcher memberMatcher = memberPattern.matcher(matcher.group(3));\r\n            if (!memberMatcher.find()) {\r\n                throw new IllegalArgumentException(\"File format error: comment without member declaration @\" + matcher.group(3));\r\n            }\r\n            node.addMember(ClassNode.createMember(memberMatcher.group(2), attributes));\r\n        }\r\n        return node;\r\n    }\r\n}\r\n", "refactored": true}
{"hexsha": "11bd2a32cfcc0fc4457dad773f0af7c018a9725c", "ext": "java", "lang": "Java", "content": "public class h_svRenderer implements GLSurfaceView.Renderer {\n\n    private boolean circleShowing = false;\n\n    private int circleXstart = 0;\n\n    private int circleYstart = 0;\n\n    private int circleX = 0;\n\n    private int circleY = 0;\n\n    private float circleSize = 0;\n\n    private int width;\n\n    private int height;\n\n    private float onePixelWidth = 0f;\n\n    private float onePixelHeight = 0f;\n\n    private sv_2d_gradient sv_2d_gradient;\n\n    private hueBar hueBar;\n\n    private circle circle;\n\n    private circle selected_sv_circle;\n\n    private rect hueRect;\n\n    private float hueRectWidth;\n\n    private int dpi;\n\n    private float hue;\n\n    public float getHue() {\n        return hue;\n    }\n\n    private float _saturation;\n\n    public float getSaturation() {\n        return _saturation;\n    }\n\n    private float _value;\n\n    public float getValue() {\n        return _value;\n    }\n\n    // color change task that gets ran in onSurfaceChanged\n    private boolean doSetColorJob = false;\n\n    private float colorJobHue;\n\n    private float colorJobSaturation;\n\n    private float colorJobValue;\n\n    public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n        // enable vertex arrays\n        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\n        // enable color arrays\n        gl.glEnableClientState(GL10.GL_COLOR_ARRAY);\n        gl.glShadeModel(GL10.GL_SMOOTH);\n        gl.glClearColor(0, 0, 0, 0);\n    }\n\n    public void setColor(float[] color) {\n        colorJobHue = color[0];\n        colorJobSaturation = color[1];\n        colorJobValue = color[2];\n        doSetColorJob = true;\n    }\n\n    public void showCircle() {\n        circleShowing = true;\n    }\n\n    public void hideCircle() {\n        circleShowing = false;\n    }\n\n    private boolean pointInsideMainGradient(int x, int y) {\n        if (sv_2d_gradient == null) {\n            return false;\n        }\n        // left\n        float left = (sv_2d_gradient.getLeft()) / onePixelWidth;\n        int leftmargin = (int) (left + (width / 2)) + 1;\n        boolean result = true;\n        if ((x < leftmargin)) {\n            result = false;\n        }\n        // right\n        float right = (sv_2d_gradient.getRight()) / onePixelWidth;\n        int rightmargin = (int) (right + (width / 2));\n        if ((x > rightmargin)) {\n            result = false;\n        }\n        // top\n        float top = (sv_2d_gradient.getTop()) / onePixelHeight;\n        int topmargin = (int) Math.abs((top - (height / 2)));\n        if ((y < topmargin)) {\n            result = false;\n        }\n        // bottom\n        float bottom = (sv_2d_gradient.getBottom()) / onePixelHeight;\n        int bottommargin = (int) Math.abs((bottom - (height / 2)));\n        if ((y > bottommargin)) {\n            result = false;\n        }\n        return result;\n    }\n\n    public boolean pointInsideHueSlider(int x, int y) {\n        if (hueRect == null) {\n            return false;\n        }\n        // left\n        float left = (hueBar.getLeft()) / onePixelWidth;\n        int leftmargin = (int) (left + (width / 2)) + 1;\n        boolean result = true;\n        if ((x < leftmargin)) {\n            result = false;\n        }\n        // right\n        float right = (hueBar.getRight()) / onePixelWidth;\n        int rightmargin = (int) (right + (width / 2));\n        if ((x > rightmargin)) {\n            result = false;\n        }\n        // top\n        float top = (hueBar.getTop()) / onePixelHeight;\n        int topmargin = (int) (top - (height / 2));\n        if ((y < topmargin)) {\n            result = false;\n        }\n        return result;\n    }\n\n    public void startMoveCircle(float x, float y) {\n        circleXstart = (int) x;\n        circleYstart = (int) y;\n    }\n\n    public void moveCircle(float x, float y, float size) {\n        if (pointInsideMainGradient(circleXstart, circleYstart)) {\n            circleX = (int) x;\n            circleY = (int) y;\n            circleSize = size;\n            if (sv_2d_gradient != null) {\n                // left\n                float left = (sv_2d_gradient.getLeft()) / onePixelWidth;\n                int leftmargin = (int) (left + (width / 2)) + 1;\n                if (circleX < leftmargin) {\n                    circleX = (int) leftmargin;\n                }\n                // right\n                float right = (sv_2d_gradient.getRight()) / onePixelWidth;\n                int rightmargin = (int) (right + (width / 2));\n                if (circleX > rightmargin) {\n                    circleX = (int) rightmargin;\n                }\n                // top\n                float top = (sv_2d_gradient.getTop()) / onePixelHeight;\n                int topmargin = (int) Math.abs((top - (height / 2)));\n                if (circleY < topmargin) {\n                    circleY = (int) topmargin;\n                }\n                // bottom\n                float bottom = (sv_2d_gradient.getBottom()) / onePixelHeight;\n                int bottommargin = (int) Math.abs((bottom - (height / 2)));\n                if (circleY > bottommargin) {\n                    circleY = (int) bottommargin;\n                }\n                float value = (sv_2d_gradient.getValues()[circleX - leftmargin]);\n                float saturation = (sv_2d_gradient.getSaturations()[circleY - topmargin]);\n                value = reverseFloatWithRange(value, 0f, 1f);\n                if (value > 1f) {\n                    value = 1f;\n                }\n                if (value < 0.0000001f) {\n                    value = 0f;\n                }\n                _value = value;\n                _saturation = saturation;\n            }\n        } else if (pointInsideHueSlider(circleXstart, circleYstart)) {\n            // calculate new location\n            float left = (hueBar.getLeft()) / onePixelWidth;\n            int leftmargin = (int) (left + (width / 2)) + 1;\n            float right = (hueBar.getRight()) / onePixelWidth;\n            int rightmargin = (int) (right + (width / 2)) + 1;\n            int bottom_margin_dp = 20;\n            int b_px = bottom_margin_dp * (dpi / 160);\n            float bottom_margin = heightPxToFloat(b_px);\n            int screen_height_dp = height / (dpi / 160);\n            int top_margin_dp = (screen_height_dp) - 90;\n            int px = (top_margin_dp * (dpi / 160));\n            float top_margin = heightPxToFloat(px);\n            float screen_width_f = floatFromPx(width, 0);\n            float x2;\n            if (x <= leftmargin + 1) {\n                x = leftmargin + 1;\n                x2 = floatFromPx((int) x, 0);\n            } else {\n                x2 = floatFromPx((int) x, 0);\n            }\n            if (x >= rightmargin - 1) {\n                x = rightmargin - 1;\n                x2 = floatFromPx((int) x, 0);\n            } else {\n                x2 = floatFromPx((int) x, 0);\n            }\n            float new_left = ((-(hueRectWidth)) + x2) - screen_width_f / 2;\n            float new_top = -1f + bottom_margin;\n            float new_right = (((hueRectWidth)) + x2) - screen_width_f / 2;\n            float new_bottom = 1f - top_margin;\n            hueRect.setLocation(new_left, new_top, new_right, new_bottom);\n            // set hue for main gradient\n            float hue1 = floatFromPx((int) (x - leftmargin), 0);\n            hue1 = ((hue1 / floatFromPx(hueBar.getWidth(), 0)));\n            float hueReal = hue1 * 360f;\n            hueReal = reverseFloatWithRange(hueReal, 0f, 360f);\n            sv_2d_gradient.updateHue(hueReal);\n            // Log.i(\"DEFCOL\",\"current hue: \"+hueReal);\n            hue = hueReal;\n        }\n    }\n\n    private float reverseFloatWithRange(float f, float min, float max) {\n        float middle;\n        if (min == 0f) {\n            middle = max / 2;\n        } else {\n            // (max-min)/2?\n            middle = max / min;\n        }\n        if (f > middle) {\n            f = f - ((f - middle) * 2);\n        } else if (f < middle) {\n            f = f + ((middle - f) * 2);\n        }\n        return f;\n    }\n\n    // DRAW-DRAW-DRAW-DRAW-DRAW!! *spins in chair with pencil on head*\n    public void onDrawFrame(GL10 gl) {\n        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n        // draw main box \\\\\n        sv_2d_gradient.draw();\n        selected_sv_circle.updateLocation(circleX, circleY, 0.1f);\n        selected_sv_circle.draw();\n        hueBar.draw();\n        hueRect.draw();\n    }\n\n    public void setDpi(int DPI) {\n        dpi = DPI;\n    }\n\n    public void onSurfaceChanged(GL10 gl, int _width, int _height) {\n        // send to gl\n        gl.glViewport(0, 0, _width, _height);\n        // save data in memory\n        width = _width;\n        height = _height;\n        onePixelWidth = (new Float(1) / new Float(width)) * 2;\n        onePixelHeight = (new Float(1) / new Float(height)) * 2;\n        // calculate top margin\n        int top_margin_dp = 20;\n        int px = top_margin_dp * (dpi / 160);\n        float top_margin = heightPxToFloat(px);\n        // calculate bottom margin\n        int bottom_margin_dp = 100;\n        int b_px = bottom_margin_dp * (dpi / 160);\n        float bottom_margin = heightPxToFloat(b_px);\n        // create gradient\n        sv_2d_gradient = new sv_2d_gradient(gl, -0.9f, 0.9f, -1f + bottom_margin, 1f - top_margin, 250f, onePixelWidth, onePixelHeight);\n        // calculate bottom margin\n        bottom_margin_dp = 20;\n        b_px = bottom_margin_dp * (dpi / 160);\n        bottom_margin = heightPxToFloat(b_px);\n        int screen_height_dp = height / (dpi / 160);\n        top_margin_dp = (screen_height_dp) - 90;\n        px = (top_margin_dp * (dpi / 160));\n        top_margin = heightPxToFloat(px);\n        hueRectWidth = (5 * onePixelWidth) / 2;\n        // create hue bar\n        hueBar = new hueBar(gl, -0.9f, 0.9f, -1f + bottom_margin, 1f - top_margin, onePixelWidth, onePixelHeight);\n        // create circle\n        circle = new circle(gl, 0.5f, 0.5f, 0.5f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n        selected_sv_circle = new circle(gl, 0.5f, 0.5f, 0.1f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n        // create hueRect\n        hueRect = new rect(gl, -0.9f - (hueRectWidth), -1f + bottom_margin, -0.9f + (hueRectWidth), 1f - top_margin, 2f, onePixelWidth, onePixelHeight, width, height);\n        if (doSetColorJob == true) {\n            float screen_width_f = floatFromPx(width, 0);\n            // hue\n            float scaledToOne = colorJobHue / 360f;\n            float x3 = (scaledToOne * (hueBar.getWidth())) + ((((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth));\n            x3 = reverseFloatWithRange(x3, 0f, width);\n            circleXstart = (int) (width / 2);\n            circleYstart = (int) (height - bottom_margin);\n            moveCircle(x3, (height - bottom_margin), 0.5f);\n            // saturation and value\n            if (colorJobValue == 0f && colorJobSaturation == 0f) {\n                int left_margin = (int) (((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth);\n                top_margin_dp = 20;\n                px = top_margin_dp * (dpi / 160);\n                top_margin = px;\n                x3 = left_margin;\n                ;\n                float y3 = top_margin + sv_2d_gradient.getHeight();\n                circleXstart = (int) x3 + 1;\n                circleYstart = (int) y3;\n                moveCircle(x3 + 1, y3, 0.5f);\n            } else {\n                top_margin_dp = 20;\n                px = top_margin_dp * (dpi / 160);\n                top_margin = px;\n                scaledToOne = colorJobSaturation;\n                int left_margin = (int) (((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth);\n                x3 = (scaledToOne * (hueBar.getWidth()));\n                x3 = reverseFloatWithRange(x3, 0f, hueBar.getWidth());\n                x3 += left_margin;\n                scaledToOne = colorJobValue;\n                float y3 = (scaledToOne * (sv_2d_gradient.getHeight()));\n                y3 = reverseFloatWithRange(y3, 0f, sv_2d_gradient.getHeight());\n                y3 += top_margin;\n                circleXstart = (int) x3 + 1;\n                circleYstart = (int) y3;\n                moveCircle(x3 + 1, y3, 0.5f);\n            }\n        }\n    }\n\n    public float heightPxToFloat(int px) {\n        // deprecated\n        float f = 0.0f;\n        if (px != 0) {\n            int i = 0;\n            while (i < px) try {\n                f += onePixelHeight;\n            } finally {\n                i++;\n            }\n        }\n        return f;\n    }\n\n    public float floatFromPx(int px, int axis) {\n        float result = 0f;\n        if (px != 0) {\n            int i = 0;\n            while (i < px) try {\n                if (axis == 0) {\n                    result += onePixelWidth;\n                } else {\n                    result += onePixelHeight;\n                }\n            } finally {\n                i++;\n            }\n        }\n        return result;\n    }\n}\n", "class_id": 0, "repo": "wentam/DefCol", "file": "src/com/wentam/defcol/colorpicker/h_svRenderer.java", "last_update_at": "2021-07-03T06:47:46+00:00", "original_content": "public class h_svRenderer implements GLSurfaceView.Renderer {\n\n    private boolean circleShowing = false;\n\n    private int circleXstart = 0;\n\n    private int circleYstart = 0;\n\n    private int circleX = 0;\n\n    private int circleY = 0;\n\n    private float circleSize = 0;\n\n    private int width;\n\n    private int height;\n\n    private float onePixelWidth = 0f;\n\n    private float onePixelHeight = 0f;\n\n    private sv_2d_gradient sv_2d_gradient;\n\n    private hueBar hueBar;\n\n    private circle circle;\n\n    private circle selected_sv_circle;\n\n    private rect hueRect;\n\n    private float hueRectWidth;\n\n    private int dpi;\n\n    private float hue;\n\n    public float getHue() {\n        return hue;\n    }\n\n    private float _saturation;\n\n    public float getSaturation() {\n        return _saturation;\n    }\n\n    private float _value;\n\n    public float getValue() {\n        return _value;\n    }\n\n    // color change task that gets ran in onSurfaceChanged\n    private boolean doSetColorJob = false;\n\n    private float colorJobHue;\n\n    private float colorJobSaturation;\n\n    private float colorJobValue;\n\n    public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n        // enable vertex arrays\n        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);\n        // enable color arrays\n        gl.glEnableClientState(GL10.GL_COLOR_ARRAY);\n        gl.glShadeModel(GL10.GL_SMOOTH);\n        gl.glClearColor(0, 0, 0, 0);\n    }\n\n    public void setColor(float[] color) {\n        colorJobHue = color[0];\n        colorJobSaturation = color[1];\n        colorJobValue = color[2];\n        doSetColorJob = true;\n    }\n\n    public void showCircle() {\n        circleShowing = true;\n    }\n\n    public void hideCircle() {\n        circleShowing = false;\n    }\n\n    private boolean pointInsideMainGradient(int x, int y) {\n        if (sv_2d_gradient == null) {\n            return false;\n        }\n        // left\n        float left = (sv_2d_gradient.getLeft()) / onePixelWidth;\n        int leftmargin = (int) (left + (width / 2)) + 1;\n        boolean result = true;\n        if ((x < leftmargin)) {\n            result = false;\n        }\n        // right\n        float right = (sv_2d_gradient.getRight()) / onePixelWidth;\n        int rightmargin = (int) (right + (width / 2));\n        if ((x > rightmargin)) {\n            result = false;\n        }\n        // top\n        float top = (sv_2d_gradient.getTop()) / onePixelHeight;\n        int topmargin = (int) Math.abs((top - (height / 2)));\n        if ((y < topmargin)) {\n            result = false;\n        }\n        // bottom\n        float bottom = (sv_2d_gradient.getBottom()) / onePixelHeight;\n        int bottommargin = (int) Math.abs((bottom - (height / 2)));\n        if ((y > bottommargin)) {\n            result = false;\n        }\n        return result;\n    }\n\n    public boolean pointInsideHueSlider(int x, int y) {\n        if (hueRect == null) {\n            return false;\n        }\n        // left\n        float left = (hueBar.getLeft()) / onePixelWidth;\n        int leftmargin = (int) (left + (width / 2)) + 1;\n        boolean result = true;\n        if ((x < leftmargin)) {\n            result = false;\n        }\n        // right\n        float right = (hueBar.getRight()) / onePixelWidth;\n        int rightmargin = (int) (right + (width / 2));\n        if ((x > rightmargin)) {\n            result = false;\n        }\n        // top\n        float top = (hueBar.getTop()) / onePixelHeight;\n        int topmargin = (int) (top - (height / 2));\n        if ((y < topmargin)) {\n            result = false;\n        }\n        return result;\n    }\n\n    public void startMoveCircle(float x, float y) {\n        circleXstart = (int) x;\n        circleYstart = (int) y;\n    }\n\n    public void moveCircle(float x, float y, float size) {\n        if (pointInsideMainGradient(circleXstart, circleYstart)) {\n            circleX = (int) x;\n            circleY = (int) y;\n            circleSize = size;\n            if (sv_2d_gradient != null) {\n                // left\n                float left = (sv_2d_gradient.getLeft()) / onePixelWidth;\n                int leftmargin = (int) (left + (width / 2)) + 1;\n                if (circleX < leftmargin) {\n                    circleX = (int) leftmargin;\n                }\n                // right\n                float right = (sv_2d_gradient.getRight()) / onePixelWidth;\n                int rightmargin = (int) (right + (width / 2));\n                if (circleX > rightmargin) {\n                    circleX = (int) rightmargin;\n                }\n                // top\n                float top = (sv_2d_gradient.getTop()) / onePixelHeight;\n                int topmargin = (int) Math.abs((top - (height / 2)));\n                if (circleY < topmargin) {\n                    circleY = (int) topmargin;\n                }\n                // bottom\n                float bottom = (sv_2d_gradient.getBottom()) / onePixelHeight;\n                int bottommargin = (int) Math.abs((bottom - (height / 2)));\n                if (circleY > bottommargin) {\n                    circleY = (int) bottommargin;\n                }\n                float value = (sv_2d_gradient.getValues()[circleX - leftmargin]);\n                float saturation = (sv_2d_gradient.getSaturations()[circleY - topmargin]);\n                value = reverseFloatWithRange(value, 0f, 1f);\n                if (value > 1f) {\n                    value = 1f;\n                }\n                if (value < 0.0000001f) {\n                    value = 0f;\n                }\n                _value = value;\n                _saturation = saturation;\n            }\n        } else if (pointInsideHueSlider(circleXstart, circleYstart)) {\n            // calculate new location\n            float left = (hueBar.getLeft()) / onePixelWidth;\n            int leftmargin = (int) (left + (width / 2)) + 1;\n            float right = (hueBar.getRight()) / onePixelWidth;\n            int rightmargin = (int) (right + (width / 2)) + 1;\n            int bottom_margin_dp = 20;\n            int b_px = bottom_margin_dp * (dpi / 160);\n            float bottom_margin = heightPxToFloat(b_px);\n            int screen_height_dp = height / (dpi / 160);\n            int top_margin_dp = (screen_height_dp) - 90;\n            int px = (top_margin_dp * (dpi / 160));\n            float top_margin = heightPxToFloat(px);\n            float screen_width_f = floatFromPx(width, 0);\n            float x2;\n            if (x <= leftmargin + 1) {\n                x = leftmargin + 1;\n                x2 = floatFromPx((int) x, 0);\n            } else {\n                x2 = floatFromPx((int) x, 0);\n            }\n            if (x >= rightmargin - 1) {\n                x = rightmargin - 1;\n                x2 = floatFromPx((int) x, 0);\n            } else {\n                x2 = floatFromPx((int) x, 0);\n            }\n            float new_left = ((-(hueRectWidth)) + x2) - screen_width_f / 2;\n            float new_top = -1f + bottom_margin;\n            float new_right = (((hueRectWidth)) + x2) - screen_width_f / 2;\n            float new_bottom = 1f - top_margin;\n            hueRect.setLocation(new_left, new_top, new_right, new_bottom);\n            // set hue for main gradient\n            float hue1 = floatFromPx((int) (x - leftmargin), 0);\n            hue1 = ((hue1 / floatFromPx(hueBar.getWidth(), 0)));\n            float hueReal = hue1 * 360f;\n            hueReal = reverseFloatWithRange(hueReal, 0f, 360f);\n            sv_2d_gradient.updateHue(hueReal);\n            // Log.i(\"DEFCOL\",\"current hue: \"+hueReal);\n            hue = hueReal;\n        }\n    }\n\n    private float reverseFloatWithRange(float f, float min, float max) {\n        float middle;\n        if (min == 0f) {\n            middle = max / 2;\n        } else {\n            // (max-min)/2?\n            middle = max / min;\n        }\n        if (f > middle) {\n            f = f - ((f - middle) * 2);\n        } else if (f < middle) {\n            f = f + ((middle - f) * 2);\n        }\n        return f;\n    }\n\n    // DRAW-DRAW-DRAW-DRAW-DRAW!! *spins in chair with pencil on head*\n    public void onDrawFrame(GL10 gl) {\n        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n        // draw main box \\\\\n        sv_2d_gradient.draw();\n        selected_sv_circle.updateLocation(circleX, circleY, 0.1f);\n        selected_sv_circle.draw();\n        hueBar.draw();\n        hueRect.draw();\n    }\n\n    public void setDpi(int DPI) {\n        dpi = DPI;\n    }\n\n    public void onSurfaceChanged(GL10 gl, int _width, int _height) {\n        // send to gl\n        gl.glViewport(0, 0, _width, _height);\n        // save data in memory\n        width = _width;\n        height = _height;\n        onePixelWidth = (new Float(1) / new Float(width)) * 2;\n        onePixelHeight = (new Float(1) / new Float(height)) * 2;\n        // calculate top margin\n        int top_margin_dp = 20;\n        int px = top_margin_dp * (dpi / 160);\n        float top_margin = heightPxToFloat(px);\n        // calculate bottom margin\n        int bottom_margin_dp = 100;\n        int b_px = bottom_margin_dp * (dpi / 160);\n        float bottom_margin = heightPxToFloat(b_px);\n        // create gradient\n        sv_2d_gradient = new sv_2d_gradient(gl, -0.9f, 0.9f, -1f + bottom_margin, 1f - top_margin, 250f, onePixelWidth, onePixelHeight);\n        // calculate bottom margin\n        bottom_margin_dp = 20;\n        b_px = bottom_margin_dp * (dpi / 160);\n        bottom_margin = heightPxToFloat(b_px);\n        int screen_height_dp = height / (dpi / 160);\n        top_margin_dp = (screen_height_dp) - 90;\n        px = (top_margin_dp * (dpi / 160));\n        top_margin = heightPxToFloat(px);\n        hueRectWidth = (5 * onePixelWidth) / 2;\n        // create hue bar\n        hueBar = new hueBar(gl, -0.9f, 0.9f, -1f + bottom_margin, 1f - top_margin, onePixelWidth, onePixelHeight);\n        // create circle\n        circle = new circle(gl, 0.5f, 0.5f, 0.5f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n        selected_sv_circle = new circle(gl, 0.5f, 0.5f, 0.1f, 2.0f, onePixelWidth, onePixelHeight, width, height);\n        // create hueRect\n        hueRect = new rect(gl, -0.9f - (hueRectWidth), -1f + bottom_margin, -0.9f + (hueRectWidth), 1f - top_margin, 2f, onePixelWidth, onePixelHeight, width, height);\n        if (doSetColorJob == true) {\n            float screen_width_f = floatFromPx(width, 0);\n            // hue\n            float scaledToOne = colorJobHue / 360f;\n            float x3 = (scaledToOne * (hueBar.getWidth())) + ((((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth));\n            x3 = reverseFloatWithRange(x3, 0f, width);\n            circleXstart = (int) (width / 2);\n            circleYstart = (int) (height - bottom_margin);\n            moveCircle(x3, (height - bottom_margin), 0.5f);\n            // saturation and value\n            if (colorJobValue == 0f && colorJobSaturation == 0f) {\n                int left_margin = (int) (((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth);\n                top_margin_dp = 20;\n                px = top_margin_dp * (dpi / 160);\n                top_margin = px;\n                x3 = left_margin;\n                ;\n                float y3 = top_margin + sv_2d_gradient.getHeight();\n                circleXstart = (int) x3 + 1;\n                circleYstart = (int) y3;\n                moveCircle(x3 + 1, y3, 0.5f);\n            } else {\n                top_margin_dp = 20;\n                px = top_margin_dp * (dpi / 160);\n                top_margin = px;\n                scaledToOne = colorJobSaturation;\n                int left_margin = (int) (((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth);\n                x3 = (scaledToOne * (hueBar.getWidth()));\n                x3 = reverseFloatWithRange(x3, 0f, hueBar.getWidth());\n                x3 += left_margin;\n                scaledToOne = colorJobValue;\n                float y3 = (scaledToOne * (sv_2d_gradient.getHeight()));\n                y3 = reverseFloatWithRange(y3, 0f, sv_2d_gradient.getHeight());\n                y3 += top_margin;\n                circleXstart = (int) x3 + 1;\n                circleYstart = (int) y3;\n                moveCircle(x3 + 1, y3, 0.5f);\n            }\n        }\n    }\n\n    public float heightPxToFloat(int px) {\n        // deprecated\n        float f = 0.0f;\n        if (px != 0) {\n            for (int i = 0; i < px; i++) {\n                f += onePixelHeight;\n            }\n        }\n        return f;\n    }\n\n    public float floatFromPx(int px, int axis) {\n        float result = 0f;\n        if (px != 0) {\n            for (int i = 0; i < px; i++) {\n                if (axis == 0) {\n                    result += onePixelWidth;\n                } else {\n                    result += onePixelHeight;\n                }\n            }\n        }\n        return result;\n    }\n}\n", "refactored": true}
{"hexsha": "ee7e106a17a6d3c50b58c0f6591bc9a924d1b4d4", "ext": "java", "lang": "Java", "content": "@Entity\n@EntityListeners(AuditingEntityListener.class)\n@TypeDef(name = \"pgsql_enum\", typeClass = PostgreSQLEnumType.class)\n@Table(name = \"test_item\", schema = \"public\")\npublic class TestItem implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"item_id\")\n    private Long itemId;\n\n    @Column(name = \"uuid\")\n    private String uuid;\n\n    @Column(name = \"name\", length = 256)\n    private String name;\n\n    @Column(name = \"code_ref\")\n    private String codeRef;\n\n    @Enumerated(EnumType.STRING)\n    @Type(type = \"pqsql_enum\")\n    @Column(name = \"type\", nullable = false)\n    private TestItemTypeEnum type;\n\n    @Column(name = \"start_time\", nullable = false)\n    private LocalDateTime startTime;\n\n    @Column(name = \"description\")\n    private String description;\n\n    @Column(name = \"launch_id\", nullable = false)\n    private Long launchId;\n\n    @LastModifiedDate\n    @Column(name = \"last_modified\", nullable = false)\n    private LocalDateTime lastModified;\n\n    @ElementCollection(fetch = FetchType.EAGER)\n    @CollectionTable(name = \"parameter\", joinColumns = @JoinColumn(name = \"item_id\"))\n    @Fetch(FetchMode.SUBSELECT)\n    private Set<Parameter> parameters = Sets.newHashSet();\n\n    @Column(name = \"unique_id\", nullable = false, length = 256)\n    private String uniqueId;\n\n    @Column(name = \"test_case_id\")\n    private String testCaseId;\n\n    @Column(name = \"test_case_hash\")\n    private Integer testCaseHash;\n\n    @OneToMany(mappedBy = \"testItem\", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)\n    @Fetch(FetchMode.SUBSELECT)\n    private Set<ItemAttribute> attributes = Sets.newHashSet();\n\n    @OneToMany(mappedBy = \"testItem\", fetch = FetchType.LAZY, orphanRemoval = true)\n    private Set<Log> logs = Sets.newHashSet();\n\n    @Column(name = \"path\", nullable = false, columnDefinition = \"ltree\")\n    @Type(type = \"com.epam.ta.reportportal.entity.LTreeType\")\n    private String path;\n\n    @Column(name = \"retry_of\", precision = 64)\n    private Long retryOf;\n\n    @Column(name = \"parent_id\")\n    private Long parentId;\n\n    @OneToOne(cascade = CascadeType.ALL, mappedBy = \"testItem\")\n    private TestItemResults itemResults;\n\n    @OneToMany(mappedBy = \"testItem\", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, fetch = FetchType.LAZY)\n    @OrderBy(value = \"pattern_id\")\n    @Fetch(FetchMode.SUBSELECT)\n    private Set<PatternTemplateTestItem> patternTemplateTestItems = Sets.newLinkedHashSet();\n\n    @Column(name = \"has_children\")\n    private boolean hasChildren;\n\n    @Column(name = \"has_retries\")\n    private boolean hasRetries;\n\n    @Column(name = \"has_stats\")\n    private boolean hasStats;\n\n    public TestItem() {\n    }\n\n    public TestItem(Long id) {\n        this.itemId = id;\n    }\n\n    public TestItem(Long itemId, String name, TestItemTypeEnum type, LocalDateTime startTime, String description, LocalDateTime lastModified, String uniqueId, boolean hasChildren, boolean hasRetries, boolean hasStats) {\n        this.itemId = itemId;\n        this.name = name;\n        this.type = type;\n        this.startTime = startTime;\n        this.description = description;\n        this.lastModified = lastModified;\n        this.uniqueId = uniqueId;\n        this.hasChildren = hasChildren;\n        this.hasRetries = hasRetries;\n    }\n\n    public Set<ItemAttribute> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Set<ItemAttribute> tags) {\n        this.attributes.clear();\n        this.attributes.addAll(tags);\n    }\n\n    public Set<Log> getLogs() {\n        return logs;\n    }\n\n    public void setLogs(Set<Log> logs) {\n        this.logs.clear();\n        this.logs.addAll(logs);\n    }\n\n    public void addLog(Log log) {\n        logs.add(log);\n    }\n\n    public Long getItemId() {\n        return itemId;\n    }\n\n    public void setItemId(Long itemId) {\n        this.itemId = itemId;\n    }\n\n    public String getUuid() {\n        return uuid;\n    }\n\n    public void setUuid(String uuid) {\n        this.uuid = uuid;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCodeRef() {\n        return codeRef;\n    }\n\n    public void setCodeRef(String codeRef) {\n        this.codeRef = codeRef;\n    }\n\n    public TestItemTypeEnum getType() {\n        return type;\n    }\n\n    public void setType(TestItemTypeEnum type) {\n        this.type = type;\n    }\n\n    public LocalDateTime getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(LocalDateTime startTime) {\n        this.startTime = startTime;\n    }\n\n    public LocalDateTime getLastModified() {\n        return lastModified;\n    }\n\n    public void setLastModified(LocalDateTime lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public Set<Parameter> getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(Set<Parameter> parameters) {\n        this.parameters = parameters;\n    }\n\n    public String getUniqueId() {\n        return uniqueId;\n    }\n\n    public void setUniqueId(String uniqueId) {\n        this.uniqueId = uniqueId;\n    }\n\n    public String getTestCaseId() {\n        return testCaseId;\n    }\n\n    public void setTestCaseId(String testCaseId) {\n        this.testCaseId = testCaseId;\n    }\n\n    public Integer getTestCaseHash() {\n        return testCaseHash;\n    }\n\n    public void setTestCaseHash(Integer testCaseHash) {\n        this.testCaseHash = testCaseHash;\n    }\n\n    public Long getLaunchId() {\n        return launchId;\n    }\n\n    public void setLaunchId(Long launchId) {\n        this.launchId = launchId;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public Long getRetryOf() {\n        return retryOf;\n    }\n\n    public void setRetryOf(Long retryOf) {\n        this.retryOf = retryOf;\n    }\n\n    public Long getParentId() {\n        return parentId;\n    }\n\n    public void setParentId(Long parentId) {\n        this.parentId = parentId;\n    }\n\n    public TestItemResults getItemResults() {\n        return itemResults;\n    }\n\n    public void setItemResults(TestItemResults itemResults) {\n        this.itemResults = itemResults;\n    }\n\n    public boolean isHasChildren() {\n        return hasChildren;\n    }\n\n    public void setHasChildren(boolean hasChildren) {\n        this.hasChildren = hasChildren;\n    }\n\n    public Set<PatternTemplateTestItem> getPatternTemplateTestItems() {\n        return patternTemplateTestItems;\n    }\n\n    public void setPatternTemplateTestItems(Set<PatternTemplateTestItem> patternTemplateTestItems) {\n        this.patternTemplateTestItems = patternTemplateTestItems;\n    }\n\n    public boolean isHasRetries() {\n        return hasRetries;\n    }\n\n    public void setHasRetries(boolean hasRetries) {\n        this.hasRetries = hasRetries;\n    }\n\n    public boolean isHasStats() {\n        return hasStats;\n    }\n\n    public void setHasStats(boolean hasStats) {\n        this.hasStats = hasStats;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        TestItem testItem = (TestItem) o;\n        return Objects.equals(itemId, testItem.itemId) && Objects.equals(name, testItem.name) && Objects.equals(codeRef, testItem.codeRef) && type == testItem.type && Objects.equals(uniqueId, testItem.uniqueId) && Objects.equals(testCaseId, testItem.testCaseId) && Objects.equals(testCaseHash, testItem.testCaseHash) && Objects.equals(path, testItem.path) && Objects.equals(retryOf, testItem.retryOf);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(itemId, name, codeRef, type, uniqueId, testCaseId, testCaseHash, path, retryOf);\n    }\n}\n", "class_id": 0, "repo": "santhoskumara/commons-dao", "file": "src/main/java/com/epam/ta/reportportal/entity/item/TestItem.java", "last_update_at": "2021-04-13T08:46:19+00:00", "original_content": "@Entity\n@EntityListeners(AuditingEntityListener.class)\n@TypeDef(name = \"pgsql_enum\", typeClass = PostgreSQLEnumType.class)\n@Table(name = \"test_item\", schema = \"public\")\npublic class TestItem implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"item_id\")\n    private Long itemId;\n\n    @Column(name = \"uuid\")\n    private String uuid;\n\n    @Column(name = \"name\", length = 256)\n    private String name;\n\n    @Column(name = \"code_ref\")\n    private String codeRef;\n\n    @Enumerated(EnumType.STRING)\n    @Type(type = \"pqsql_enum\")\n    @Column(name = \"type\", nullable = false)\n    private TestItemTypeEnum type;\n\n    @Column(name = \"start_time\", nullable = false)\n    private LocalDateTime startTime;\n\n    @Column(name = \"description\")\n    private String description;\n\n    @Column(name = \"launch_id\", nullable = false)\n    private Long launchId;\n\n    @LastModifiedDate\n    @Column(name = \"last_modified\", nullable = false)\n    private LocalDateTime lastModified;\n\n    @ElementCollection(fetch = FetchType.EAGER)\n    @CollectionTable(name = \"parameter\", joinColumns = @JoinColumn(name = \"item_id\"))\n    @Fetch(FetchMode.SUBSELECT)\n    private Set<Parameter> parameters = Sets.newHashSet();\n\n    @Column(name = \"unique_id\", nullable = false, length = 256)\n    private String uniqueId;\n\n    @Column(name = \"test_case_id\")\n    private String testCaseId;\n\n    @Column(name = \"test_case_hash\")\n    private Integer testCaseHash;\n\n    @OneToMany(mappedBy = \"testItem\", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)\n    @Fetch(FetchMode.SUBSELECT)\n    private Set<ItemAttribute> attributes = Sets.newHashSet();\n\n    @OneToMany(mappedBy = \"testItem\", fetch = FetchType.LAZY, orphanRemoval = true)\n    private Set<Log> logs = Sets.newHashSet();\n\n    @Column(name = \"path\", nullable = false, columnDefinition = \"ltree\")\n    @Type(type = \"com.epam.ta.reportportal.entity.LTreeType\")\n    private String path;\n\n    @Column(name = \"retry_of\", precision = 64)\n    private Long retryOf;\n\n    @Column(name = \"parent_id\")\n    private Long parentId;\n\n    @OneToOne(cascade = CascadeType.ALL, mappedBy = \"testItem\")\n    private TestItemResults itemResults;\n\n    @OneToMany(mappedBy = \"testItem\", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, fetch = FetchType.LAZY)\n    @OrderBy(value = \"pattern_id\")\n    @Fetch(FetchMode.SUBSELECT)\n    private Set<PatternTemplateTestItem> patternTemplateTestItems = Sets.newLinkedHashSet();\n\n    @Column(name = \"has_children\")\n    private boolean hasChildren;\n\n    @Column(name = \"has_retries\")\n    private boolean hasRetries;\n\n    @Column(name = \"has_stats\")\n    private boolean hasStats;\n\n    public TestItem() {\n    }\n\n    public TestItem(Long id) {\n        this.itemId = id;\n    }\n\n    public TestItem(Long itemId, String name, TestItemTypeEnum type, LocalDateTime startTime, String description, LocalDateTime lastModified, String uniqueId, boolean hasChildren, boolean hasRetries, boolean hasStats) {\n        this.itemId = itemId;\n        this.name = name;\n        this.type = type;\n        this.startTime = startTime;\n        this.description = description;\n        this.lastModified = lastModified;\n        this.uniqueId = uniqueId;\n        this.hasChildren = hasChildren;\n        this.hasRetries = hasRetries;\n    }\n\n    public Set<ItemAttribute> getAttributes() {\n        return attributes;\n    }\n\n    public void setAttributes(Set<ItemAttribute> tags) {\n        this.attributes.clear();\n        this.attributes.addAll(tags);\n    }\n\n    public Set<Log> getLogs() {\n        return logs;\n    }\n\n    public void setLogs(Set<Log> logs) {\n        this.logs.clear();\n        this.logs.addAll(logs);\n    }\n\n    public void addLog(Log log) {\n        logs.add(log);\n    }\n\n    public Long getItemId() {\n        return itemId;\n    }\n\n    public void setItemId(Long itemId) {\n        this.itemId = itemId;\n    }\n\n    public String getUuid() {\n        return uuid;\n    }\n\n    public void setUuid(String uuid) {\n        this.uuid = uuid;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCodeRef() {\n        return codeRef;\n    }\n\n    public void setCodeRef(String codeRef) {\n        this.codeRef = codeRef;\n    }\n\n    public TestItemTypeEnum getType() {\n        return type;\n    }\n\n    public void setType(TestItemTypeEnum type) {\n        this.type = type;\n    }\n\n    public LocalDateTime getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(LocalDateTime startTime) {\n        this.startTime = startTime;\n    }\n\n    public LocalDateTime getLastModified() {\n        return lastModified;\n    }\n\n    public void setLastModified(LocalDateTime lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public Set<Parameter> getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(Set<Parameter> parameters) {\n        this.parameters = parameters;\n    }\n\n    public String getUniqueId() {\n        return uniqueId;\n    }\n\n    public void setUniqueId(String uniqueId) {\n        this.uniqueId = uniqueId;\n    }\n\n    public String getTestCaseId() {\n        return testCaseId;\n    }\n\n    public void setTestCaseId(String testCaseId) {\n        this.testCaseId = testCaseId;\n    }\n\n    public Integer getTestCaseHash() {\n        return testCaseHash;\n    }\n\n    public void setTestCaseHash(Integer testCaseHash) {\n        this.testCaseHash = testCaseHash;\n    }\n\n    public Long getLaunchId() {\n        return launchId;\n    }\n\n    public void setLaunchId(Long launchId) {\n        this.launchId = launchId;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public Long getRetryOf() {\n        return retryOf;\n    }\n\n    public void setRetryOf(Long retryOf) {\n        this.retryOf = retryOf;\n    }\n\n    public Long getParentId() {\n        return parentId;\n    }\n\n    public void setParentId(Long parentId) {\n        this.parentId = parentId;\n    }\n\n    public TestItemResults getItemResults() {\n        return itemResults;\n    }\n\n    public void setItemResults(TestItemResults itemResults) {\n        this.itemResults = itemResults;\n    }\n\n    public boolean isHasChildren() {\n        return hasChildren;\n    }\n\n    public void setHasChildren(boolean hasChildren) {\n        this.hasChildren = hasChildren;\n    }\n\n    public Set<PatternTemplateTestItem> getPatternTemplateTestItems() {\n        return patternTemplateTestItems;\n    }\n\n    public void setPatternTemplateTestItems(Set<PatternTemplateTestItem> patternTemplateTestItems) {\n        this.patternTemplateTestItems = patternTemplateTestItems;\n    }\n\n    public boolean isHasRetries() {\n        return hasRetries;\n    }\n\n    public void setHasRetries(boolean hasRetries) {\n        this.hasRetries = hasRetries;\n    }\n\n    public boolean isHasStats() {\n        return hasStats;\n    }\n\n    public void setHasStats(boolean hasStats) {\n        this.hasStats = hasStats;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        TestItem testItem = (TestItem) o;\n        return Objects.equals(itemId, testItem.itemId) && Objects.equals(name, testItem.name) && Objects.equals(codeRef, testItem.codeRef) && type == testItem.type && Objects.equals(uniqueId, testItem.uniqueId) && Objects.equals(testCaseId, testItem.testCaseId) && Objects.equals(testCaseHash, testItem.testCaseHash) && Objects.equals(path, testItem.path) && Objects.equals(retryOf, testItem.retryOf);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(itemId, name, codeRef, type, uniqueId, testCaseId, testCaseHash, path, retryOf);\n    }\n}\n", "refactored": false}
{"hexsha": "770ba336660ddb6d1684c88a6ffd4027a484b65d", "ext": "java", "lang": "Java", "content": "@Deprecated\n@Plugin(type = ConsoleArgument.class)\npublic class RunArgument extends AbstractConsoleArgument {\n\n    @Parameter\n    private CommandService commandService;\n\n    @Parameter\n    private LogService log;\n\n    public RunArgument() {\n        super(2, \"--class\");\n    }\n\n    @Override\n    public void handle(final LinkedList<String> args) {\n        if (!supports(args))\n            return;\n        log.warn(\"The --class flag is deprecated, and will\\n\" + \"be removed in a future release. Use --run instead.\");\n        // --class\n        args.removeFirst();\n        final String commandToRun = args.removeFirst();\n        final String paramString = ConsoleUtils.hasParam(args) ? args.removeFirst() : \"\";\n        run(commandToRun, paramString);\n    }\n\n    @Override\n    public boolean supports(final LinkedList<String> args) {\n        if (!super.supports(args))\n            return false;\n        return getInfo(args.get(1)) != null;\n    }\n\n    /**\n     * Implements the {@code --run} command line argument.\n     */\n    private void run(final String commandToRun, final String optionString) {\n        // get the command info\n        final CommandInfo info = getInfo(commandToRun);\n        // couldn't find anything to run\n        if (info == null)\n            return;\n        // TODO: parse the optionString a la ImageJ1\n        final Map<String, Object> inputMap = ConsoleUtils.parseParameterString(optionString, info, log);\n        try {\n            commandService.run(info, true, inputMap).get();\n        } catch (final Exception exc) {\n            log.error(exc);\n        }\n    }\n\n    /**\n     * Try to convert the given string to a {@link CommandInfo}\n     */\n    private CommandInfo getInfo(final String commandToRun) {\n        CommandInfo info = commandService.getCommand(commandToRun);\n        if (info == null) {\n            // command was not a class name; search for command by title instead\n            final String label = commandToRun.replace('_', ' ');\n            for (final CommandInfo ci : commandService.getCommands()) {\n                if (label.equals(ci.getTitle())) {\n                    info = ci;\n                    break;\n                }\n            }\n        }\n        return info;\n    }\n}\n", "class_id": 0, "repo": "karlduderstadt/scijava-common", "file": "src/main/java/org/scijava/command/console/RunArgument.java", "last_update_at": "2021-05-18T11:47:13+00:00", "original_content": "@Deprecated\n@Plugin(type = ConsoleArgument.class)\npublic class RunArgument extends AbstractConsoleArgument {\n\n    @Parameter\n    private CommandService commandService;\n\n    @Parameter\n    private LogService log;\n\n    public RunArgument() {\n        super(2, \"--class\");\n    }\n\n    @Override\n    public void handle(final LinkedList<String> args) {\n        if (!supports(args))\n            return;\n        log.warn(\"The --class flag is deprecated, and will\\n\" + \"be removed in a future release. Use --run instead.\");\n        // --class\n        args.removeFirst();\n        final String commandToRun = args.removeFirst();\n        final String paramString = ConsoleUtils.hasParam(args) ? args.removeFirst() : \"\";\n        run(commandToRun, paramString);\n    }\n\n    @Override\n    public boolean supports(final LinkedList<String> args) {\n        if (!super.supports(args))\n            return false;\n        return getInfo(args.get(1)) != null;\n    }\n\n    /**\n     * Implements the {@code --run} command line argument.\n     */\n    private void run(final String commandToRun, final String optionString) {\n        // get the command info\n        final CommandInfo info = getInfo(commandToRun);\n        // couldn't find anything to run\n        if (info == null)\n            return;\n        // TODO: parse the optionString a la ImageJ1\n        final Map<String, Object> inputMap = ConsoleUtils.parseParameterString(optionString, info, log);\n        try {\n            commandService.run(info, true, inputMap).get();\n        } catch (final Exception exc) {\n            log.error(exc);\n        }\n    }\n\n    /**\n     * Try to convert the given string to a {@link CommandInfo}\n     */\n    private CommandInfo getInfo(final String commandToRun) {\n        CommandInfo info = commandService.getCommand(commandToRun);\n        if (info == null) {\n            // command was not a class name; search for command by title instead\n            final String label = commandToRun.replace('_', ' ');\n            for (final CommandInfo ci : commandService.getCommands()) {\n                if (label.equals(ci.getTitle())) {\n                    info = ci;\n                    break;\n                }\n            }\n        }\n        return info;\n    }\n}\n", "refactored": false}
{"hexsha": "3657c2a163170b02431c0dbfc628de7c3d0901ee", "ext": "java", "lang": "Java", "content": "public class PreRegistrationFragment extends FragmentViewController<EmptyArg, PreRegistrationListener> {\n\n    @Override\n    public ControllerTypes<EmptyArg, PreRegistrationListener> getTypes() {\n        return new ControllerTypes<>(EmptyArg.class, PreRegistrationListener.class);\n    }\n\n    @Override\n    public View onCreateView(@NonNull final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {\n        final View view = BottomDetailAndButtonView.inflateWithMenuButton(inflater, container, getActivity(), R.layout.pre_registration);\n        final Button startRegistrationButton = view.findViewById(R.id.start_registration_button);\n        startRegistrationButton.setOnClickListener(click -> getListener().startRegistration());\n        return view;\n    }\n}\n", "class_id": 0, "repo": "rideOS/rideos-sdk-android", "file": "driver_app/src/main/java/ai/rideos/android/driver_app/vehicle_unregistered/pre_registration/PreRegistrationFragment.java", "last_update_at": "2021-04-03T12:29:56+00:00", "original_content": "public class PreRegistrationFragment extends FragmentViewController<EmptyArg, PreRegistrationListener> {\n\n    @Override\n    public ControllerTypes<EmptyArg, PreRegistrationListener> getTypes() {\n        return new ControllerTypes<>(EmptyArg.class, PreRegistrationListener.class);\n    }\n\n    @Override\n    public View onCreateView(@NonNull final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {\n        final View view = BottomDetailAndButtonView.inflateWithMenuButton(inflater, container, getActivity(), R.layout.pre_registration);\n        final Button startRegistrationButton = view.findViewById(R.id.start_registration_button);\n        startRegistrationButton.setOnClickListener(click -> getListener().startRegistration());\n        return view;\n    }\n}\n", "refactored": false}
{"hexsha": "a24f84caa66e1f813870bcc8b107c4c0772b2c17", "ext": "java", "lang": "Java", "content": "public class ComplexStringExampleActivity extends AppCompatActivity {\n\n    ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder> mListenerRelay = new ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder>() {\n\n        @Override\n        public void onClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch(view.getId()) {\n                    case R.id.text:\n                        {\n                            mSnackbarLogic.make(view, item + \" is clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_a:\n                        {\n                            mSnackbarLogic.make(view, item + \" is clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_b:\n                        {\n                            mSnackbarLogic.make(view, item + \" is clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                }\n            }\n        }\n\n        @Override\n        public boolean onLongClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch(view.getId()) {\n                    case R.id.text:\n                        {\n                            mSnackbarLogic.make(view, item + \" is long clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_a:\n                        {\n                            mSnackbarLogic.make(view, item + \" is long clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_b:\n                        {\n                            mSnackbarLogic.make(view, item + \" is long clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                }\n                return true;\n            }\n            return false;\n        }\n    };\n\n    RecyclerView mRecyclerView;\n\n    SnackbarLogic mSnackbarLogic = new SnackbarLogic();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_simple_string_example);\n        // find views\n        mRecyclerView = (RecyclerView) findViewById(R.id.recycler);\n        {\n            // set adapter\n            List<String> items = new ArrayList<>();\n            int i = 0;\n            while (i < 100) try {\n                items.add(\"item \" + i);\n            } finally {\n                i++;\n            }\n            ComplexStringAdapter adapter = new ComplexStringAdapter(this, items, mListenerRelay);\n            mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));\n            mRecyclerView.setAdapter(adapter);\n        }\n    }\n}\n", "class_id": 0, "repo": "cattaka/AdapterToolbox", "file": "example/src/main/java/net/cattaka/android/adaptertoolbox/example/ComplexStringExampleActivity.java", "last_update_at": "2021-02-21T05:12:08+00:00", "original_content": "public class ComplexStringExampleActivity extends AppCompatActivity {\n\n    ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder> mListenerRelay = new ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder>() {\n\n        @Override\n        public void onClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch(view.getId()) {\n                    case R.id.text:\n                        {\n                            mSnackbarLogic.make(view, item + \" is clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_a:\n                        {\n                            mSnackbarLogic.make(view, item + \" is clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_b:\n                        {\n                            mSnackbarLogic.make(view, item + \" is clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                }\n            }\n        }\n\n        @Override\n        public boolean onLongClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {\n            if (recyclerView.getId() == R.id.recycler) {\n                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());\n                switch(view.getId()) {\n                    case R.id.text:\n                        {\n                            mSnackbarLogic.make(view, item + \" is long clicked.(Text)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_a:\n                        {\n                            mSnackbarLogic.make(view, item + \" is long clicked.(A)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                    case R.id.button_b:\n                        {\n                            mSnackbarLogic.make(view, item + \" is long clicked.(B)\", Snackbar.LENGTH_SHORT).show();\n                            break;\n                        }\n                }\n                return true;\n            }\n            return false;\n        }\n    };\n\n    RecyclerView mRecyclerView;\n\n    SnackbarLogic mSnackbarLogic = new SnackbarLogic();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_simple_string_example);\n        // find views\n        mRecyclerView = (RecyclerView) findViewById(R.id.recycler);\n        {\n            // set adapter\n            List<String> items = new ArrayList<>();\n            for (int i = 0; i < 100; i++) {\n                items.add(\"item \" + i);\n            }\n            ComplexStringAdapter adapter = new ComplexStringAdapter(this, items, mListenerRelay);\n            mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));\n            mRecyclerView.setAdapter(adapter);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "897fdb49750e90c9a13f17c981ee07272d6899b3", "ext": "java", "lang": "Java", "content": "public abstract class TemplateMatchingAlg extends SentenceAlgorithm {\n\n    // separates the template from the rest of the algorithm in its init string.\n    private static String TEMPLATE_DELINEATOR = \"\\n=\\n\";\n\n    private FeatureTemplate template;\n\n    private String signature;\n\n    protected FeatureTemplate getTemplate() {\n        return template;\n    }\n\n    protected void setTemplate(FeatureTemplate t) {\n        template = t;\n    }\n\n    /**\n     * Tests if ConstituentNode is a superset of template\n     *\n     * @param node\n     * @return map of matching nodes\n     */\n    protected Map<String, FeatureNode> canApplyTo(FeatureNode node) {\n        return template.match(node);\n    }\n\n    protected String getSignature() {\n        return signature;\n    }\n\n    public int init(String str) {\n        if (!Character.isLetter(str.charAt(0)))\n            throw new RuntimeException(\"TemplateMatchingAlg string must start with a letter.\\n\" + str);\n        // get signature\n        int sigEnd = str.indexOf(\"\\n\");\n        signature = str.substring(0, sigEnd);\n        // get template\n        int templateEnd = str.indexOf(TEMPLATE_DELINEATOR);\n        if (templateEnd < 0)\n            throw new RuntimeException(\"TemplateMAtchingAlg must have:\" + TEMPLATE_DELINEATOR + \"separating the template from the actions.\\n\" + str);\n        setTemplate(new FeatureTemplate(str.substring(sigEnd + 1, templateEnd)));\n        return templateEnd + TEMPLATE_DELINEATOR.length();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n        sb.append(getSignature()).append(\"\\n\").append(getTemplate()).append(TEMPLATE_DELINEATOR);\n        return sb.toString();\n    }\n}\n", "class_id": 0, "repo": "tozhovez/relex", "file": "src/java/relex/algs/TemplateMatchingAlg.java", "last_update_at": "2021-11-09T11:27:11+00:00", "original_content": "public abstract class TemplateMatchingAlg extends SentenceAlgorithm {\n\n    // separates the template from the rest of the algorithm in its init string.\n    private static String TEMPLATE_DELINEATOR = \"\\n=\\n\";\n\n    private FeatureTemplate template;\n\n    private String signature;\n\n    protected FeatureTemplate getTemplate() {\n        return template;\n    }\n\n    protected void setTemplate(FeatureTemplate t) {\n        template = t;\n    }\n\n    /**\n     * Tests if ConstituentNode is a superset of template\n     *\n     * @param node\n     * @return map of matching nodes\n     */\n    protected Map<String, FeatureNode> canApplyTo(FeatureNode node) {\n        return template.match(node);\n    }\n\n    protected String getSignature() {\n        return signature;\n    }\n\n    public int init(String str) {\n        if (!Character.isLetter(str.charAt(0)))\n            throw new RuntimeException(\"TemplateMatchingAlg string must start with a letter.\\n\" + str);\n        // get signature\n        int sigEnd = str.indexOf(\"\\n\");\n        signature = str.substring(0, sigEnd);\n        // get template\n        int templateEnd = str.indexOf(TEMPLATE_DELINEATOR);\n        if (templateEnd < 0)\n            throw new RuntimeException(\"TemplateMAtchingAlg must have:\" + TEMPLATE_DELINEATOR + \"separating the template from the actions.\\n\" + str);\n        setTemplate(new FeatureTemplate(str.substring(sigEnd + 1, templateEnd)));\n        return templateEnd + TEMPLATE_DELINEATOR.length();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n        sb.append(getSignature()).append(\"\\n\").append(getTemplate()).append(TEMPLATE_DELINEATOR);\n        return sb.toString();\n    }\n}\n", "refactored": false}
{"hexsha": "40075c370335e4894f6de3f58bbf672ce1c03ed7", "ext": "java", "lang": "Java", "content": "public class JsonArrayDiff implements JsonDiff {\n\n    private final Map<Integer, JsonNode> valuesWithoutMatch = new HashMap<>();\n\n    private final Map<Integer, JsonDiff> valuesWithMatch = new HashMap<>();\n\n    private final Map<Integer, JsonNode> extraValues = new HashMap<>();\n\n    private final Path path;\n\n    public JsonArrayDiff(Path path) {\n        this.path = path;\n    }\n\n    public void addNoMatch(int index, JsonNode expectedValue) {\n        this.valuesWithoutMatch.put(index, expectedValue);\n    }\n\n    public void addDiff(int index, JsonDiff jsonDiff) {\n        this.valuesWithMatch.put(index, jsonDiff);\n    }\n\n    public void addExtraItem(int index, JsonNode extraReceivedValue) {\n        this.extraValues.put(index, extraReceivedValue);\n    }\n\n    @Override\n    public double similarityRate() {\n        final var totalArraySize = valuesWithoutMatch.size() + valuesWithMatch.size() + this.extraValues.size();\n        final var totalSimilarityRate = valuesWithMatch.values().stream().mapToDouble(JsonDiff::similarityRate).sum();\n        return totalSimilarityRate / totalArraySize;\n    }\n\n    @Override\n    public void display(JsonDiffViewer viewer) {\n        for (final var valuesWithMatch : valuesWithMatch.entrySet()) {\n            if (valuesWithMatch.getValue().similarityRate() >= 99.9) {\n                viewer.matchingProperty(valuesWithMatch.getValue());\n            } else {\n                viewer.nonMatchingProperty(valuesWithMatch.getValue());\n            }\n        }\n        for (final var valuesWithoutMatch : valuesWithoutMatch.entrySet()) {\n            viewer.missingProperty(new Path.ChainedPath(path(), String.valueOf(valuesWithoutMatch.getKey())), valuesWithoutMatch.getValue());\n        }\n        for (final var extraItem : extraValues.entrySet()) {\n            viewer.extraProperty(new Path.ChainedPath(path(), String.valueOf(extraItem.getKey())), extraItem.getValue());\n        }\n    }\n\n    @Override\n    public Path path() {\n        return this.path;\n    }\n}\n", "class_id": 0, "repo": "deblockt/json-diff", "file": "src/main/java/com/deblock/jsondiff/diff/JsonArrayDiff.java", "last_update_at": "2021-06-29T21:27:43+00:00", "original_content": "public class JsonArrayDiff implements JsonDiff {\n\n    private final Map<Integer, JsonNode> valuesWithoutMatch = new HashMap<>();\n\n    private final Map<Integer, JsonDiff> valuesWithMatch = new HashMap<>();\n\n    private final Map<Integer, JsonNode> extraValues = new HashMap<>();\n\n    private final Path path;\n\n    public JsonArrayDiff(Path path) {\n        this.path = path;\n    }\n\n    public void addNoMatch(int index, JsonNode expectedValue) {\n        this.valuesWithoutMatch.put(index, expectedValue);\n    }\n\n    public void addDiff(int index, JsonDiff jsonDiff) {\n        this.valuesWithMatch.put(index, jsonDiff);\n    }\n\n    public void addExtraItem(int index, JsonNode extraReceivedValue) {\n        this.extraValues.put(index, extraReceivedValue);\n    }\n\n    @Override\n    public double similarityRate() {\n        final var totalArraySize = valuesWithoutMatch.size() + valuesWithMatch.size() + this.extraValues.size();\n        final var totalSimilarityRate = valuesWithMatch.values().stream().mapToDouble(JsonDiff::similarityRate).sum();\n        return totalSimilarityRate / totalArraySize;\n    }\n\n    @Override\n    public void display(JsonDiffViewer viewer) {\n        for (final var valuesWithMatch : valuesWithMatch.entrySet()) {\n            if (valuesWithMatch.getValue().similarityRate() >= 99.9) {\n                viewer.matchingProperty(valuesWithMatch.getValue());\n            } else {\n                viewer.nonMatchingProperty(valuesWithMatch.getValue());\n            }\n        }\n        for (final var valuesWithoutMatch : valuesWithoutMatch.entrySet()) {\n            viewer.missingProperty(new Path.ChainedPath(path(), String.valueOf(valuesWithoutMatch.getKey())), valuesWithoutMatch.getValue());\n        }\n        for (final var extraItem : extraValues.entrySet()) {\n            viewer.extraProperty(new Path.ChainedPath(path(), String.valueOf(extraItem.getKey())), extraItem.getValue());\n        }\n    }\n\n    @Override\n    public Path path() {\n        return this.path;\n    }\n}\n", "refactored": false}
{"hexsha": "dc9e7da59510f1ed559c7ecc60156b3e286bb598", "ext": "java", "lang": "Java", "content": "public class Auth {\n\n    private final FirebaseAuth mAuth = FirebaseAuth.getInstance();\n\n    private final UsersDatabaseCrud userCrud = new UsersDatabaseCrud();\n\n    private FirebaseUser mFirebaseUser;\n\n    private Activity activity = null;\n\n    /**\n     * Constructor Default\n     */\n    public Auth() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param activity Activity from where it has been called\n     */\n    public Auth(Activity activity) {\n        this.activity = activity;\n    }\n\n    /**\n     * Check if the current user is logged in or not\n     *\n     * @return boolean False [not logged in], True [logged in]\n     */\n    public boolean isLogged() {\n        return (mAuth.getCurrentUser() != null);\n    }\n\n    /**\n     * Return current user logged\n     *\n     * @return FirebaseUser\n     */\n    public FirebaseUser getCurrentUser() {\n        return mAuth.getCurrentUser();\n    }\n\n    /**\n     * Try to log in with the email and password passed as parameters\n     *\n     * @param email    User validated email\n     * @param password User's validated password\n     */\n    public void signInWithEmailAndPassword(String email, String password) {\n        mAuth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {\n            if (task.isSuccessful()) {\n                if (isLogged()) {\n                    mFirebaseUser = mAuth.getCurrentUser();\n                    userCrud.read(mFirebaseUser.getUid(), user -> {\n                        //                        Log.d(App.DEFAULT_TAG, mFirebaseUser.getUid());\n                        App.getInstance().setCurrentUser(user);\n                        // Update lastAccess field\n                        user.setLastAccess(new Date(System.currentTimeMillis()));\n                        userCrud.update(user.getUid(), user.parseToMap(), response -> {\n                            if (response) {\n                                checkRole(App.getInstance().getCurrentUser().getRole());\n                            } else {\n                                Intent intent = new Intent(App.getContext(), GeneralMainActivity.class);\n                                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                                intent.putExtra(\"message\", \"No se ha podido verificar tu identidad correctamente.\");\n                                App.getContext().startActivity(intent);\n                            }\n                        });\n                    });\n                }\n            } else {\n                App.getInstance().snackMessage(activity.findViewById(R.id.auth_email_activity_container), R.color.black, \"Datos de acceso incorrectos.\", App.getContext());\n            }\n        });\n    }\n\n    /**\n     * Send a password reset email\n     *\n     * @param email User validated email\n     */\n    public void sendPasswordResetEmail(String email) {\n        mAuth.sendPasswordResetEmail(email).addOnCompleteListener(task -> {\n            Intent intent = new Intent(App.getContext(), AuthEmailActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n            intent.putExtra(\"message\", \"S? el email esta registrado recibir?s un correo para restablecer la contrase?a.\");\n            App.getContext().startActivity(intent);\n        });\n    }\n\n    /**\n     * Disconnect the user\n     */\n    public void signOut() {\n        mAuth.signOut();\n        App.getInstance().setCurrentUser(null);\n    }\n\n    /**\n     * Check the role and redirect to the corresponding activity when logging in\n     *\n     * @param role Role of the logged in user\n     */\n    public void checkRole(String role) {\n        switch(role) {\n            case \"root\":\n            case \"administrator\":\n                {\n                    redirectActivity(AdministratorMainActivity.class);\n                    break;\n                }\n            case \"technician\":\n                {\n                    redirectActivity(TechnicianMainActivity.class);\n                    break;\n                }\n            default:\n                {\n                    redirectActivity(GeneralMainActivity.class);\n                    break;\n                }\n        }\n    }\n\n    /**\n     * Redirect to corresponding activity\n     *\n     * @param activity Activity where it will be redirected\n     */\n    public void redirectActivity(Class<?> activity) {\n        Intent intent;\n        intent = new Intent(App.getContext(), activity);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        App.getContext().startActivity(intent);\n    }\n}\n", "class_id": 0, "repo": "abidanBrito/murbin", "file": "src/mobile_app/Murbin/app/src/main/java/com/example/murbin/firebase/Auth.java", "last_update_at": "2021-04-01T17:24:35+00:00", "original_content": "public class Auth {\n\n    private final FirebaseAuth mAuth = FirebaseAuth.getInstance();\n\n    private final UsersDatabaseCrud userCrud = new UsersDatabaseCrud();\n\n    private FirebaseUser mFirebaseUser;\n\n    private Activity activity = null;\n\n    /**\n     * Constructor Default\n     */\n    public Auth() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param activity Activity from where it has been called\n     */\n    public Auth(Activity activity) {\n        this.activity = activity;\n    }\n\n    /**\n     * Check if the current user is logged in or not\n     *\n     * @return boolean False [not logged in], True [logged in]\n     */\n    public boolean isLogged() {\n        return (mAuth.getCurrentUser() != null);\n    }\n\n    /**\n     * Return current user logged\n     *\n     * @return FirebaseUser\n     */\n    public FirebaseUser getCurrentUser() {\n        return mAuth.getCurrentUser();\n    }\n\n    /**\n     * Try to log in with the email and password passed as parameters\n     *\n     * @param email    User validated email\n     * @param password User's validated password\n     */\n    public void signInWithEmailAndPassword(String email, String password) {\n        mAuth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {\n            if (task.isSuccessful()) {\n                if (isLogged()) {\n                    mFirebaseUser = mAuth.getCurrentUser();\n                    userCrud.read(mFirebaseUser.getUid(), user -> {\n                        //                        Log.d(App.DEFAULT_TAG, mFirebaseUser.getUid());\n                        App.getInstance().setCurrentUser(user);\n                        // Update lastAccess field\n                        user.setLastAccess(new Date(System.currentTimeMillis()));\n                        userCrud.update(user.getUid(), user.parseToMap(), response -> {\n                            if (response) {\n                                checkRole(App.getInstance().getCurrentUser().getRole());\n                            } else {\n                                Intent intent = new Intent(App.getContext(), GeneralMainActivity.class);\n                                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                                intent.putExtra(\"message\", \"No se ha podido verificar tu identidad correctamente.\");\n                                App.getContext().startActivity(intent);\n                            }\n                        });\n                    });\n                }\n            } else {\n                App.getInstance().snackMessage(activity.findViewById(R.id.auth_email_activity_container), R.color.black, \"Datos de acceso incorrectos.\", App.getContext());\n            }\n        });\n    }\n\n    /**\n     * Send a password reset email\n     *\n     * @param email User validated email\n     */\n    public void sendPasswordResetEmail(String email) {\n        mAuth.sendPasswordResetEmail(email).addOnCompleteListener(task -> {\n            Intent intent = new Intent(App.getContext(), AuthEmailActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n            intent.putExtra(\"message\", \"S? el email esta registrado recibir?s un correo para restablecer la contrase?a.\");\n            App.getContext().startActivity(intent);\n        });\n    }\n\n    /**\n     * Disconnect the user\n     */\n    public void signOut() {\n        mAuth.signOut();\n        App.getInstance().setCurrentUser(null);\n    }\n\n    /**\n     * Check the role and redirect to the corresponding activity when logging in\n     *\n     * @param role Role of the logged in user\n     */\n    public void checkRole(String role) {\n        switch(role) {\n            case \"root\":\n            case \"administrator\":\n                {\n                    redirectActivity(AdministratorMainActivity.class);\n                    break;\n                }\n            case \"technician\":\n                {\n                    redirectActivity(TechnicianMainActivity.class);\n                    break;\n                }\n            default:\n                {\n                    redirectActivity(GeneralMainActivity.class);\n                    break;\n                }\n        }\n    }\n\n    /**\n     * Redirect to corresponding activity\n     *\n     * @param activity Activity where it will be redirected\n     */\n    public void redirectActivity(Class<?> activity) {\n        Intent intent;\n        intent = new Intent(App.getContext(), activity);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        App.getContext().startActivity(intent);\n    }\n}\n", "refactored": false}
{"hexsha": "0a2f28df151b3621ae7f64d2d75f3eace8e03e16", "ext": "java", "lang": "Java", "content": "public class WebglInteractiveCubes extends Attachable {\n\n    public final static String name = \"interactive / cubes\";\n\n    private Random rand = new Random();\n\n    private Raycaster raycaster;\n\n    private Vector2 mouse = new Vector2();\n\n    private float radius = 100, theta = 0;\n\n    private Mesh INTERSECTED;\n\n    public WebglInteractiveCubes() {\n        camera = new PerspectiveCamera(70, aspect, 1, 10000);\n        scene = new Scene();\n        scene.background = new Color(0xf0f0f0);\n        DirectionalLight light = new DirectionalLight(0xffffff, 1);\n        light.position.set(1, 1, 1).normalize();\n        scene.add(light);\n        BoxBufferGeometry geometry = new BoxBufferGeometry(20, 20, 20);\n        int i = 0;\n        while (i < 2000) try {\n            MeshLambertMaterialParameters parameters = new MeshLambertMaterialParameters();\n            parameters.color = new Color(rand.nextInt() * 0xffffff);\n            Mesh object = new Mesh(geometry, new MeshLambertMaterial(parameters));\n            object.position.x = rand.nextFloat() * 800 - 400;\n            object.position.y = rand.nextFloat() * 800 - 400;\n            object.position.z = rand.nextFloat() * 800 - 400;\n            object.rotation.x = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.y = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.z = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.scale.x = rand.nextFloat() + 0.5f;\n            object.scale.y = rand.nextFloat() + 0.5f;\n            object.scale.z = rand.nextFloat() + 0.5f;\n            scene.add(object);\n        } finally {\n            i++;\n        }\n        raycaster = new Raycaster();\n        // RENDERER\n        WebGLRendererParameters parameters = new WebGLRendererParameters();\n        parameters.antialias = true;\n        renderer = new WebGLRenderer(parameters);\n        setupWebGLRenderer(renderer);\n        container.appendChild(renderer.domElement);\n        renderer.domElement.onmousemove = p0 -> {\n            MouseEvent event = Js.uncheckedCast(p0);\n            onDocumentMouseMove(event);\n            return null;\n        };\n    }\n\n    private void animate() {\n        AnimationScheduler.get().requestAnimationFrame(timestamp -> {\n            if (root.parentNode != null) {\n                StatsProducer.getStats().update();\n                render();\n                animate();\n            }\n        });\n    }\n\n    private void onDocumentMouseMove(MouseEvent event) {\n        event.preventDefault();\n        mouse.x = (float) (((event.clientX - panel.offsetWidth) / (window.innerWidth - panel.offsetWidth)) * 2 - 1);\n        mouse.y = (float) (-(event.clientY / window.innerHeight) * 2 + 1);\n    }\n\n    @Override\n    protected void doAttachScene() {\n        root.appendChild(container);\n        renderer.setSize(getWidth(), getHeight());\n        animate();\n    }\n\n    @Override\n    protected void doAttachInfo() {\n        AppSetup.infoDiv.show().setHrefToInfo(\"http://threejs.org\").setTextContentToInfo(\"three.js\").setInnetHtml(\"  -  webgl - interactive cubes\");\n    }\n\n    private void render() {\n        theta += 0.1;\n        camera.position.x = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.y = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.z = radius * (float) Math.cos(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.lookAt(scene.position);\n        camera.updateMatrixWorld();\n        // find intersections\n        raycaster.setFromCamera(mouse, camera);\n        Intersect[] intersects = raycaster.intersectObjects(scene.children);\n        if (intersects.length > 0) {\n            Intersect intersect = intersects[0];\n            Mesh intersected = intersect.object;\n            if (INTERSECTED != intersected) {\n                int currentHex = ((MeshLambertMaterial) intersected.material).emissive.getHex();\n                intersected.userData.setProperty(\"currentHex\", currentHex);\n                ((MeshLambertMaterial) intersected.material).emissive.setHex(0xff0000);\n                INTERSECTED = intersected;\n            }\n        } else {\n            if (INTERSECTED != null) {\n                ((MeshLambertMaterial) INTERSECTED.material).emissive.setHex(INTERSECTED.userData.getProperty(\"currentHex\"));\n                INTERSECTED = null;\n            }\n        }\n        renderer.render(scene, camera);\n    }\n}\n", "class_id": 0, "repo": "Calpano/three4g", "file": "demo/src/main/java/org/treblereel/gwt/three4g/demo/client/local/examples/interactive/WebglInteractiveCubes.java", "last_update_at": "2021-11-27T19:59:57+00:00", "original_content": "public class WebglInteractiveCubes extends Attachable {\n\n    public final static String name = \"interactive / cubes\";\n\n    private Random rand = new Random();\n\n    private Raycaster raycaster;\n\n    private Vector2 mouse = new Vector2();\n\n    private float radius = 100, theta = 0;\n\n    private Mesh INTERSECTED;\n\n    public WebglInteractiveCubes() {\n        camera = new PerspectiveCamera(70, aspect, 1, 10000);\n        scene = new Scene();\n        scene.background = new Color(0xf0f0f0);\n        DirectionalLight light = new DirectionalLight(0xffffff, 1);\n        light.position.set(1, 1, 1).normalize();\n        scene.add(light);\n        BoxBufferGeometry geometry = new BoxBufferGeometry(20, 20, 20);\n        for (int i = 0; i < 2000; i++) {\n            MeshLambertMaterialParameters parameters = new MeshLambertMaterialParameters();\n            parameters.color = new Color(rand.nextInt() * 0xffffff);\n            Mesh object = new Mesh(geometry, new MeshLambertMaterial(parameters));\n            object.position.x = rand.nextFloat() * 800 - 400;\n            object.position.y = rand.nextFloat() * 800 - 400;\n            object.position.z = rand.nextFloat() * 800 - 400;\n            object.rotation.x = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.y = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.rotation.z = (float) (rand.nextFloat() * 2 * Math.PI);\n            object.scale.x = rand.nextFloat() + 0.5f;\n            object.scale.y = rand.nextFloat() + 0.5f;\n            object.scale.z = rand.nextFloat() + 0.5f;\n            scene.add(object);\n        }\n        raycaster = new Raycaster();\n        // RENDERER\n        WebGLRendererParameters parameters = new WebGLRendererParameters();\n        parameters.antialias = true;\n        renderer = new WebGLRenderer(parameters);\n        setupWebGLRenderer(renderer);\n        container.appendChild(renderer.domElement);\n        renderer.domElement.onmousemove = p0 -> {\n            MouseEvent event = Js.uncheckedCast(p0);\n            onDocumentMouseMove(event);\n            return null;\n        };\n    }\n\n    private void animate() {\n        AnimationScheduler.get().requestAnimationFrame(timestamp -> {\n            if (root.parentNode != null) {\n                StatsProducer.getStats().update();\n                render();\n                animate();\n            }\n        });\n    }\n\n    private void onDocumentMouseMove(MouseEvent event) {\n        event.preventDefault();\n        mouse.x = (float) (((event.clientX - panel.offsetWidth) / (window.innerWidth - panel.offsetWidth)) * 2 - 1);\n        mouse.y = (float) (-(event.clientY / window.innerHeight) * 2 + 1);\n    }\n\n    @Override\n    protected void doAttachScene() {\n        root.appendChild(container);\n        renderer.setSize(getWidth(), getHeight());\n        animate();\n    }\n\n    @Override\n    protected void doAttachInfo() {\n        AppSetup.infoDiv.show().setHrefToInfo(\"http://threejs.org\").setTextContentToInfo(\"three.js\").setInnetHtml(\"  -  webgl - interactive cubes\");\n    }\n\n    private void render() {\n        theta += 0.1;\n        camera.position.x = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.y = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.position.z = radius * (float) Math.cos(org.treblereel.gwt.three4g.math.Math.degToRad(theta));\n        camera.lookAt(scene.position);\n        camera.updateMatrixWorld();\n        // find intersections\n        raycaster.setFromCamera(mouse, camera);\n        Intersect[] intersects = raycaster.intersectObjects(scene.children);\n        if (intersects.length > 0) {\n            Intersect intersect = intersects[0];\n            Mesh intersected = intersect.object;\n            if (INTERSECTED != intersected) {\n                int currentHex = ((MeshLambertMaterial) intersected.material).emissive.getHex();\n                intersected.userData.setProperty(\"currentHex\", currentHex);\n                ((MeshLambertMaterial) intersected.material).emissive.setHex(0xff0000);\n                INTERSECTED = intersected;\n            }\n        } else {\n            if (INTERSECTED != null) {\n                ((MeshLambertMaterial) INTERSECTED.material).emissive.setHex(INTERSECTED.userData.getProperty(\"currentHex\"));\n                INTERSECTED = null;\n            }\n        }\n        renderer.render(scene, camera);\n    }\n}\n", "refactored": true}
{"hexsha": "95739590f6b06a260225dba9dd818b49155e72a0", "ext": "java", "lang": "Java", "content": "public class BaseWebSettings {\n\n    /**\n     * ?????\n     */\n    public static void defaultInit(WebSettings webSettings) {\n        //??????????Javascript????webview??????Javascript\n        webSettings.setJavaScriptEnabled(true);\n        //????JS?????\n        webSettings.setJavaScriptCanOpenWindowsAutomatically(true);\n        //????????webview???,?????????????????????\n        webSettings.setUseWideViewPort(true);\n        // ????????\n        webSettings.setLoadWithOverviewMode(true);\n        //?????.NARROW_COLUMNS:??????\n        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);\n        //????????true??????????\n        webSettings.setSupportZoom(true);\n        //???????false???WebView????\n        webSettings.setBuiltInZoomControls(true);\n        //?????????\n        webSettings.setDisplayZoomControls(false);\n        //???????,???????\n        webSettings.setBlockNetworkImage(false);\n        //????????\n        webSettings.setLoadsImagesAutomatically(true);\n        //??????,utf-8, GBK\n        webSettings.setDefaultTextEncodingName(\"utf-8\");\n        //????????, ??, ??????\n        webSettings.setTextSize(WebSettings.TextSize.NORMAL);\n        //????????????, ??100\n        webSettings.setTextZoom(100);\n        //????,???????\n        webSettings.setDomStorageEnabled(false);\n        //??,??,??,css,js...\n        webSettings.setAppCacheEnabled(true);\n        //??????\n        webSettings.setAppCachePath(ConfigUtils.APPLICATION.getCacheDir().getAbsolutePath());\n        /*\n         * ???????\n         * ???cache-control?\n         *   cache-control??????????????,???????????????.\n         *   ??????public(?????????),\n         *   private(???????????),\n         *   no-cache(??????????),\n         *   max-age=xxx(??????? xxx ????)??\n         *\n         * WebSettings.LOAD_CACHE_ELSE_NETWORK  ???????????????no-cache??????????\n         * WebSettings.LOAD_CACHE_ONLY          ?????\n         * WebSettings.LOAD_DEFAULT             ??cache-control???????????\n         * WebSettings.LOAD_NO_CACHE            ?????\n         * WebSettings.LOAD_NORMAL\n         */\n        webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n        /**\n         * ???\n         */\n        webSettings.setDatabaseEnabled(true);\n        /**\n         * ????\n         */\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            /**\n             * MIXED_CONTENT_ALWAYS_ALLOW???????????????????????\n             * MIXED_CONTENT_NEVER_ALLOW????Https??Http??????????????????????????\n             * MIXED_CONTENT_COMPATIBILITY_MODE????????????WebView ????????Web???????\n             */\n            webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n        }\n        //????????\n        webSettings.setAllowFileAccess(true);\n        //????\n        webSettings.setSavePassword(false);\n        //??????????\n        webSettings.setGeolocationEnabled(true);\n        /*\n         * ??WebView????????????(swf?)?? ON_DEMAND ????????????\n         * ?????????????????????????????\n         * ?????????????. ??OFF.\n         */\n        webSettings.setPluginState(WebSettings.PluginState.ON_DEMAND);\n    }\n}\n", "class_id": 0, "repo": "actor20170211030627/MyAndroidFrameWork", "file": "myandroidframework/src/main/java/com/actor/myandroidframework/widget/webview/BaseWebSettings.java", "last_update_at": "2021-11-16T07:04:20+00:00", "original_content": "public class BaseWebSettings {\n\n    /**\n     * ?????\n     */\n    public static void defaultInit(WebSettings webSettings) {\n        //??????????Javascript????webview??????Javascript\n        webSettings.setJavaScriptEnabled(true);\n        //????JS?????\n        webSettings.setJavaScriptCanOpenWindowsAutomatically(true);\n        //????????webview???,?????????????????????\n        webSettings.setUseWideViewPort(true);\n        // ????????\n        webSettings.setLoadWithOverviewMode(true);\n        //?????.NARROW_COLUMNS:??????\n        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);\n        //????????true??????????\n        webSettings.setSupportZoom(true);\n        //???????false???WebView????\n        webSettings.setBuiltInZoomControls(true);\n        //?????????\n        webSettings.setDisplayZoomControls(false);\n        //???????,???????\n        webSettings.setBlockNetworkImage(false);\n        //????????\n        webSettings.setLoadsImagesAutomatically(true);\n        //??????,utf-8, GBK\n        webSettings.setDefaultTextEncodingName(\"utf-8\");\n        //????????, ??, ??????\n        webSettings.setTextSize(WebSettings.TextSize.NORMAL);\n        //????????????, ??100\n        webSettings.setTextZoom(100);\n        //????,???????\n        webSettings.setDomStorageEnabled(false);\n        //??,??,??,css,js...\n        webSettings.setAppCacheEnabled(true);\n        //??????\n        webSettings.setAppCachePath(ConfigUtils.APPLICATION.getCacheDir().getAbsolutePath());\n        /*\n         * ???????\n         * ???cache-control?\n         *   cache-control??????????????,???????????????.\n         *   ??????public(?????????),\n         *   private(???????????),\n         *   no-cache(??????????),\n         *   max-age=xxx(??????? xxx ????)??\n         *\n         * WebSettings.LOAD_CACHE_ELSE_NETWORK  ???????????????no-cache??????????\n         * WebSettings.LOAD_CACHE_ONLY          ?????\n         * WebSettings.LOAD_DEFAULT             ??cache-control???????????\n         * WebSettings.LOAD_NO_CACHE            ?????\n         * WebSettings.LOAD_NORMAL\n         */\n        webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n        /**\n         * ???\n         */\n        webSettings.setDatabaseEnabled(true);\n        /**\n         * ????\n         */\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            /**\n             * MIXED_CONTENT_ALWAYS_ALLOW???????????????????????\n             * MIXED_CONTENT_NEVER_ALLOW????Https??Http??????????????????????????\n             * MIXED_CONTENT_COMPATIBILITY_MODE????????????WebView ????????Web???????\n             */\n            webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n        }\n        //????????\n        webSettings.setAllowFileAccess(true);\n        //????\n        webSettings.setSavePassword(false);\n        //??????????\n        webSettings.setGeolocationEnabled(true);\n        /*\n         * ??WebView????????????(swf?)?? ON_DEMAND ????????????\n         * ?????????????????????????????\n         * ?????????????. ??OFF.\n         */\n        webSettings.setPluginState(WebSettings.PluginState.ON_DEMAND);\n    }\n}\n", "refactored": false}
{"hexsha": "117d1bfc6a7d95635dd924ba6af65c3abadbb183", "ext": "java", "lang": "Java", "content": "public class ProvisionFailureEventNode extends RemoteServiceEventNode<ProvisionFailureEvent> {\n\n    private String status;\n\n    public ProvisionFailureEventNode(ProvisionFailureEvent event) {\n        super(event);\n        status = \"Pending\";\n    }\n\n    @Override\n    public Throwable getThrown() {\n        return getEvent().getThrowable();\n    }\n\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder();\n        for (String reason : getEvent().getFailureReasons()) {\n            if (builder.length() > 0)\n                builder.append(\"\\n    \");\n            builder.append(reason);\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public String getOperationalStringName() {\n        return getEvent().getServiceElement().getOperationalStringName();\n    }\n\n    @Override\n    public String getServiceName() {\n        return getEvent().getServiceElement().getName();\n    }\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n\n    @Override\n    public String toString() {\n        return getServiceName();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 3;\n    }\n\n    @Override\n    public Object getValueAt(int column) {\n        String value;\n        if (column == 0) {\n            value = \"PROVISION_FAILURE\";\n        } else if (column == 1) {\n            value = getDescription();\n        } else {\n            value = Constants.DATE_FORMAT.format(getDate());\n        }\n        return value;\n    }\n}\n", "class_id": 0, "repo": "khartig/assimilator", "file": "rio-tools/rio-ui/src/main/java/org/rioproject/tools/ui/servicenotification/ProvisionFailureEventNode.java", "last_update_at": "2021-02-07T11:36:51+00:00", "original_content": "public class ProvisionFailureEventNode extends RemoteServiceEventNode<ProvisionFailureEvent> {\n\n    private String status;\n\n    public ProvisionFailureEventNode(ProvisionFailureEvent event) {\n        super(event);\n        status = \"Pending\";\n    }\n\n    @Override\n    public Throwable getThrown() {\n        return getEvent().getThrowable();\n    }\n\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder();\n        for (String reason : getEvent().getFailureReasons()) {\n            if (builder.length() > 0)\n                builder.append(\"\\n    \");\n            builder.append(reason);\n        }\n        return builder.toString();\n    }\n\n    @Override\n    public String getOperationalStringName() {\n        return getEvent().getServiceElement().getOperationalStringName();\n    }\n\n    @Override\n    public String getServiceName() {\n        return getEvent().getServiceElement().getName();\n    }\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n\n    @Override\n    public String toString() {\n        return getServiceName();\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 3;\n    }\n\n    @Override\n    public Object getValueAt(int column) {\n        String value;\n        if (column == 0) {\n            value = \"PROVISION_FAILURE\";\n        } else if (column == 1) {\n            value = getDescription();\n        } else {\n            value = Constants.DATE_FORMAT.format(getDate());\n        }\n        return value;\n    }\n}\n", "refactored": false}
{"hexsha": "95fc3562a6d884a48bc6d5bc1a1773c7aed9a8a8", "ext": "java", "lang": "Java", "content": "@Vetoed\npublic class Linker {\n\n    private final Router router;\n\n    private final ServletContext context;\n\n    private final List<Object> args;\n\n    private final String methodName;\n\n    private final Class<?> controller;\n\n    private final ReflectionProvider reflectionProvider;\n\n    public Linker(ServletContext context, Router router, Class<?> controller, String methodName, List<Object> args, ReflectionProvider reflectionProvider) {\n        this.router = router;\n        this.context = context;\n        this.controller = controller;\n        this.methodName = methodName;\n        this.args = args;\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    protected String getLink() {\n        Method method = getMethod();\n        return getPrefix() + router.urlFor(controller, method, getArgs(method));\n    }\n\n    protected String getPrefix() {\n        return context.getContextPath();\n    }\n\n    protected Method getMethod() {\n        Method method = null;\n        if (countMethodsWithSameName() > 1) {\n            method = reflectionProvider.getMethod(controller, methodName, getClasses(args));\n            if (method == null && args.isEmpty()) {\n                throw new IllegalArgumentException(\"Ambiguous method '\" + methodName + \"' on \" + controller + \". Try to add some parameters to resolve ambiguity, or use different method names.\");\n            }\n        } else {\n            method = findMethodWithName(controller, methodName);\n        }\n        if (method == null) {\n            throw new IllegalArgumentException(String.format(\"There are no methods on %s named '%s' that receives args of types %s\", controller, methodName, Arrays.toString(getClasses(args))));\n        }\n        return method;\n    }\n\n    protected Object[] getArgs(Method method) {\n        int methodArity = method.getParameterTypes().length;\n        if (args.size() == methodArity) {\n            return args.toArray();\n        }\n        if (args.size() > methodArity) {\n            throw new IllegalArgumentException(String.format(\"linkTo param args must have the same or lower length as method param args. linkTo args: %d | method args: %d\", args.size(), methodArity));\n        }\n        Object[] noMissingParamsArgs = new Object[methodArity];\n        System.arraycopy(args.toArray(), 0, noMissingParamsArgs, 0, args.size());\n        return noMissingParamsArgs;\n    }\n\n    protected Method findMethodWithName(Class<?> type, String name) {\n        for (Method method : type.getDeclaredMethods()) {\n            if (!method.isBridge() && method.getName().equals(name)) {\n                return method;\n            }\n        }\n        if (type.getSuperclass().equals(Object.class)) {\n            return null;\n        }\n        return findMethodWithName(type.getSuperclass(), name);\n    }\n\n    protected int countMethodsWithSameName() {\n        int amount = 0;\n        for (Method method : controller.getDeclaredMethods()) {\n            if (!method.isBridge() && method.getName().equals(methodName)) {\n                amount++;\n            }\n        }\n        return amount;\n    }\n\n    protected Class<?>[] getClasses(List<Object> params) {\n        Class<?>[] classes = new Class<?>[params.size()];\n        int i = 0;\n        while (i < params.size()) try {\n            classes[i] = params.get(i).getClass();\n        } finally {\n            i++;\n        }\n        return classes;\n    }\n}\n", "class_id": 0, "repo": "gruposwa/vraptor4", "file": "vraptor-core/src/main/java/br/com/caelum/vraptor/view/Linker.java", "last_update_at": "2021-12-16T23:35:05+00:00", "original_content": "@Vetoed\npublic class Linker {\n\n    private final Router router;\n\n    private final ServletContext context;\n\n    private final List<Object> args;\n\n    private final String methodName;\n\n    private final Class<?> controller;\n\n    private final ReflectionProvider reflectionProvider;\n\n    public Linker(ServletContext context, Router router, Class<?> controller, String methodName, List<Object> args, ReflectionProvider reflectionProvider) {\n        this.router = router;\n        this.context = context;\n        this.controller = controller;\n        this.methodName = methodName;\n        this.args = args;\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    protected String getLink() {\n        Method method = getMethod();\n        return getPrefix() + router.urlFor(controller, method, getArgs(method));\n    }\n\n    protected String getPrefix() {\n        return context.getContextPath();\n    }\n\n    protected Method getMethod() {\n        Method method = null;\n        if (countMethodsWithSameName() > 1) {\n            method = reflectionProvider.getMethod(controller, methodName, getClasses(args));\n            if (method == null && args.isEmpty()) {\n                throw new IllegalArgumentException(\"Ambiguous method '\" + methodName + \"' on \" + controller + \". Try to add some parameters to resolve ambiguity, or use different method names.\");\n            }\n        } else {\n            method = findMethodWithName(controller, methodName);\n        }\n        if (method == null) {\n            throw new IllegalArgumentException(String.format(\"There are no methods on %s named '%s' that receives args of types %s\", controller, methodName, Arrays.toString(getClasses(args))));\n        }\n        return method;\n    }\n\n    protected Object[] getArgs(Method method) {\n        int methodArity = method.getParameterTypes().length;\n        if (args.size() == methodArity) {\n            return args.toArray();\n        }\n        if (args.size() > methodArity) {\n            throw new IllegalArgumentException(String.format(\"linkTo param args must have the same or lower length as method param args. linkTo args: %d | method args: %d\", args.size(), methodArity));\n        }\n        Object[] noMissingParamsArgs = new Object[methodArity];\n        System.arraycopy(args.toArray(), 0, noMissingParamsArgs, 0, args.size());\n        return noMissingParamsArgs;\n    }\n\n    protected Method findMethodWithName(Class<?> type, String name) {\n        for (Method method : type.getDeclaredMethods()) {\n            if (!method.isBridge() && method.getName().equals(name)) {\n                return method;\n            }\n        }\n        if (type.getSuperclass().equals(Object.class)) {\n            return null;\n        }\n        return findMethodWithName(type.getSuperclass(), name);\n    }\n\n    protected int countMethodsWithSameName() {\n        int amount = 0;\n        for (Method method : controller.getDeclaredMethods()) {\n            if (!method.isBridge() && method.getName().equals(methodName)) {\n                amount++;\n            }\n        }\n        return amount;\n    }\n\n    protected Class<?>[] getClasses(List<Object> params) {\n        Class<?>[] classes = new Class<?>[params.size()];\n        for (int i = 0; i < params.size(); i++) {\n            classes[i] = params.get(i).getClass();\n        }\n        return classes;\n    }\n}\n", "refactored": true}
{"hexsha": "855941c331899e68cc0842119277b6bc04059a56", "ext": "java", "lang": "Java", "content": "class TrueFalseQuestionTest {\n\n    private static TrueFalseQuestion validTfQuestion = null;\n\n    @BeforeEach\n    void setUp() {\n        Set<Choice> validTfqChoices = new HashSet<>();\n        validTfqChoices.add(new Choice(TRUE_CHOICE_TITLE, false));\n        validTfqChoices.add(new Choice(FALSE_CHOICE_TITLE, true));\n        validTfQuestion = new TrueFalseQuestion(new Name(VALID_QUESTION_1), new Importance(VALID_IMPORTANCE_1), new HashSet<>(), validTfqChoices);\n    }\n\n    @Test\n    void isValidQuestion_validAnswers_true() {\n        assertTrue(validTfQuestion.isValidQuestion());\n    }\n\n    @Test\n    void isValidTrueFalseChoice_validChoice_true() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(TRUE_CHOICE_TITLE, false));\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(FALSE_CHOICE_TITLE, true));\n    }\n\n    @Test\n    void isValidTrueFalseChoice_invalidChoice_false() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(VALID_ANSWER_1, false));\n    }\n}\n", "class_id": 0, "repo": "cedricongjh/tp", "file": "src/test/java/seedu/smartnus/model/question/TrueFalseQuestionTest.java", "last_update_at": "2021-11-11T11:13:31+00:00", "original_content": "class TrueFalseQuestionTest {\n\n    private static TrueFalseQuestion validTfQuestion = null;\n\n    @BeforeEach\n    void setUp() {\n        Set<Choice> validTfqChoices = new HashSet<>();\n        validTfqChoices.add(new Choice(TRUE_CHOICE_TITLE, false));\n        validTfqChoices.add(new Choice(FALSE_CHOICE_TITLE, true));\n        validTfQuestion = new TrueFalseQuestion(new Name(VALID_QUESTION_1), new Importance(VALID_IMPORTANCE_1), new HashSet<>(), validTfqChoices);\n    }\n\n    @Test\n    void isValidQuestion_validAnswers_true() {\n        assertTrue(validTfQuestion.isValidQuestion());\n    }\n\n    @Test\n    void isValidTrueFalseChoice_validChoice_true() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(TRUE_CHOICE_TITLE, false));\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(FALSE_CHOICE_TITLE, true));\n    }\n\n    @Test\n    void isValidTrueFalseChoice_invalidChoice_false() {\n        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(VALID_ANSWER_1, false));\n    }\n}\n", "refactored": false}
{"hexsha": "0c671b7afe8a693de6d48a3af9f2b3772d1a2aa8", "ext": "java", "lang": "Java", "content": "public class InsertTag extends SimpleTagSupport {\n\n    private String definitionName = null;\n\n    private String parameterName = null;\n\n    public InsertTag() {\n        super();\n    }\n\n    public void setParameter(String parameter) {\n        this.parameterName = parameter;\n    }\n\n    public void setDefinition(String name) {\n        this.definitionName = name;\n    }\n\n    public void doTag() throws JspTagException {\n        Definition definition = null;\n        Parameter parameter = null;\n        boolean directInclude = false;\n        PageContext context = (PageContext) getJspContext();\n        // get the definition from the page context\n        definition = (Definition) context.getAttribute(definitionName, context.APPLICATION_SCOPE);\n        // get the parameter\n        if ((parameterName != null) && (definition != null)) {\n            parameter = (Parameter) definition.getParam(parameterName);\n        }\n        if (parameter != null) {\n            directInclude = parameter.isDirect();\n        }\n        try {\n            // if parameter is direct, print to out\n            if (directInclude && (parameter != null)) {\n                context.getOut().print(parameter.getValue());\n            } else // if parameter is indirect, include results of dispatching to page\n            {\n                if ((parameter != null) && (parameter.getValue() != null)) {\n                    context.include(parameter.getValue());\n                }\n            }\n        } catch (Exception ex) {\n            Throwable rootCause = null;\n            if (ex instanceof ServletException) {\n                rootCause = ((ServletException) ex).getRootCause();\n            }\n            throw new JspTagException(ex.getMessage(), rootCause);\n        }\n    }\n}\n", "class_id": 0, "repo": "kwkoo/fsi-workshop-v2m1-labs", "file": "monolith/dukesbank-war/src/main/java/com/sun/tutorial/javaee/dukesbank/web/template/InsertTag.java", "last_update_at": "2021-03-02T21:01:01+00:00", "original_content": "public class InsertTag extends SimpleTagSupport {\n\n    private String definitionName = null;\n\n    private String parameterName = null;\n\n    public InsertTag() {\n        super();\n    }\n\n    public void setParameter(String parameter) {\n        this.parameterName = parameter;\n    }\n\n    public void setDefinition(String name) {\n        this.definitionName = name;\n    }\n\n    public void doTag() throws JspTagException {\n        Definition definition = null;\n        Parameter parameter = null;\n        boolean directInclude = false;\n        PageContext context = (PageContext) getJspContext();\n        // get the definition from the page context\n        definition = (Definition) context.getAttribute(definitionName, context.APPLICATION_SCOPE);\n        // get the parameter\n        if ((parameterName != null) && (definition != null)) {\n            parameter = (Parameter) definition.getParam(parameterName);\n        }\n        if (parameter != null) {\n            directInclude = parameter.isDirect();\n        }\n        try {\n            // if parameter is direct, print to out\n            if (directInclude && (parameter != null)) {\n                context.getOut().print(parameter.getValue());\n            } else // if parameter is indirect, include results of dispatching to page\n            {\n                if ((parameter != null) && (parameter.getValue() != null)) {\n                    context.include(parameter.getValue());\n                }\n            }\n        } catch (Exception ex) {\n            Throwable rootCause = null;\n            if (ex instanceof ServletException) {\n                rootCause = ((ServletException) ex).getRootCause();\n            }\n            throw new JspTagException(ex.getMessage(), rootCause);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "0a1afb5c947f6e859bce2ccb8a05da9ecf9f75e5", "ext": "java", "lang": "Java", "content": "public class IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest {\n\n    @RegisterExtension\n    static QuarkusUnitTest runner = new QuarkusUnitTest().withApplicationRoot((jar) -> jar.addClass(MyEntity.class).addAsManifestResource(\"META-INF/persistence-discriminator-ignore-explicit-for-joined-false-value.xml\", \"persistence.xml\").addAsResource(\"application-datasource-only.properties\", \"application.properties\"));\n\n    @Inject\n    EntityManager em;\n\n    @ActivateRequestContext\n    @Test\n    public void testFalseValue() {\n        Map<String, Object> properties = em.getEntityManagerFactory().getProperties();\n        // the PU is templatePU from the persistence.xml, not the default entity manager from application.properties\n        assertEquals(\"templatePU\", properties.get(\"hibernate.ejb.persistenceUnitName\"));\n        assertEquals(\"false\", properties.get(\"hibernate.discriminator.ignore_explicit_for_joined\"));\n    }\n}\n", "class_id": 0, "repo": "Markus-Schwer/quarkus", "file": "extensions/hibernate-orm/deployment/src/test/java/io/quarkus/hibernate/orm/ignore_explicit_for_joined/IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest.java", "last_update_at": "2021-07-27T10:45:53+00:00", "original_content": "public class IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest {\n\n    @RegisterExtension\n    static QuarkusUnitTest runner = new QuarkusUnitTest().withApplicationRoot((jar) -> jar.addClass(MyEntity.class).addAsManifestResource(\"META-INF/persistence-discriminator-ignore-explicit-for-joined-false-value.xml\", \"persistence.xml\").addAsResource(\"application-datasource-only.properties\", \"application.properties\"));\n\n    @Inject\n    EntityManager em;\n\n    @ActivateRequestContext\n    @Test\n    public void testFalseValue() {\n        Map<String, Object> properties = em.getEntityManagerFactory().getProperties();\n        // the PU is templatePU from the persistence.xml, not the default entity manager from application.properties\n        assertEquals(\"templatePU\", properties.get(\"hibernate.ejb.persistenceUnitName\"));\n        assertEquals(\"false\", properties.get(\"hibernate.discriminator.ignore_explicit_for_joined\"));\n    }\n}\n", "refactored": false}
{"hexsha": "e81c1f3aac9022f7c0a476697baebee32efeef68", "ext": "java", "lang": "Java", "content": "class customers {\n\n    int tableNo;\n\n    String name;\n\n    int phoneNo;\n\n    void customerData() {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Entere no.    :\");\n        tableNo = sc.nextInt();\n        System.out.print(\"Entermer name : \");\n        name = sc.next();\n        System.out.print(\"Entere no.    :\");\n        phoneNo = sc.nextInt();\n    }\n}\n", "class_id": 1, "repo": "umanggoel2001/Hacktoberfest2021-1", "file": "hotel_AP.java", "last_update_at": "2021-11-08T12:01:08+00:00", "original_content": "class customers {\n\n    int tableNo;\n\n    String name;\n\n    int phoneNo;\n\n    void customerData() {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Entere no.    :\");\n        tableNo = sc.nextInt();\n        System.out.print(\"Entermer name : \");\n        name = sc.next();\n        System.out.print(\"Entere no.    :\");\n        phoneNo = sc.nextInt();\n    }\n}\n", "refactored": false}
{"hexsha": "36e36bd6a324cff383b99117320c5b7080ea7be0", "ext": "java", "lang": "Java", "content": "public class Literals {\n\n    public static void main(String[] args) {\n        // int\n        var i = 1234;\n        // double\n        var d1 = 1.;\n        var d2 = 1.0;\n        var d3 = 1.123456;\n        // 5 * 10 ^ 3 == 5000.0\n        var d4 = 5e3;\n        // boolean\n        var b1 = true;\n        var b2 = false;\n        // char\n        var ch1 = 'a';\n        var ch2 = '\\t';\n        var ch3 = '\\n';\n        // String\n        var s1 = \"a\";\n        var s2 = \"Hello world\";\n        //\n        int num = 1;\n        char ch = '1';\n        String s = \"1\";\n    }\n}\n", "class_id": 0, "repo": "lanaflonPerso/java-basic", "file": "src/academy/devonline/java/basic/section03_expression/Literals.java", "last_update_at": "2021-12-27T16:00:51+00:00", "original_content": "public class Literals {\n\n    public static void main(String[] args) {\n        // int\n        var i = 1234;\n        // double\n        var d1 = 1.;\n        var d2 = 1.0;\n        var d3 = 1.123456;\n        // 5 * 10 ^ 3 == 5000.0\n        var d4 = 5e3;\n        // boolean\n        var b1 = true;\n        var b2 = false;\n        // char\n        var ch1 = 'a';\n        var ch2 = '\\t';\n        var ch3 = '\\n';\n        // String\n        var s1 = \"a\";\n        var s2 = \"Hello world\";\n        //\n        int num = 1;\n        char ch = '1';\n        String s = \"1\";\n    }\n}\n", "refactored": false}
{"hexsha": "475d786aedd10b146cce1f943e4de0d4c30628a6", "ext": "java", "lang": "Java", "content": "final public class IpConnectivityMetrics extends SystemService {\n\n    private static final String TAG = IpConnectivityMetrics.class.getSimpleName();\n\n    private static final boolean DBG = false;\n\n    // \"version\" field of IpConnectivityLog.\n    private static final int NYC = 0;\n\n    private static final int NYC_MR1 = 1;\n\n    private static final int NYC_MR2 = 2;\n\n    public static final int VERSION = NYC_MR2;\n\n    private static final String SERVICE_NAME = IpConnectivityLog.SERVICE_NAME;\n\n    // Default size of the event buffer. Once the buffer is full, incoming events are dropped.\n    private static final int DEFAULT_BUFFER_SIZE = 2000;\n\n    // Maximum size of the event buffer.\n    private static final int MAXIMUM_BUFFER_SIZE = DEFAULT_BUFFER_SIZE * 10;\n\n    private static final int MAXIMUM_CONNECT_LATENCY_RECORDS = 20000;\n\n    private static final int ERROR_RATE_LIMITED = -1;\n\n    //  - flushing the buffer content and replacing it by a new buffer.\n    private final Object mLock = new Object();\n\n    @VisibleForTesting\n    public final Impl impl = new Impl();\n\n    @VisibleForTesting\n    NetdEventListenerService mNetdListener;\n\n    @GuardedBy(\"mLock\")\n    private ArrayList<ConnectivityMetricsEvent> mBuffer;\n\n    @GuardedBy(\"mLock\")\n    private int mDropped;\n\n    @GuardedBy(\"mLock\")\n    private int mCapacity;\n\n    @GuardedBy(\"mLock\")\n    private final ArrayMap<Class<?>, TokenBucket> mBuckets = makeRateLimitingBuckets();\n\n    private final ToIntFunction<Context> mCapacityGetter;\n\n    public IpConnectivityMetrics(Context ctx, ToIntFunction<Context> capacityGetter) {\n        super(ctx);\n        mCapacityGetter = capacityGetter;\n        initBuffer();\n    }\n\n    public IpConnectivityMetrics(Context ctx) {\n        this(ctx, READ_BUFFER_SIZE);\n    }\n\n    @Override\n    public void onStart() {\n        if (DBG)\n            Log.d(TAG, \"onStart\");\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {\n            if (DBG)\n                Log.d(TAG, \"onBootPhase\");\n            mNetdListener = new NetdEventListenerService(getContext());\n            publishBinderService(SERVICE_NAME, impl);\n            publishBinderService(mNetdListener.SERVICE_NAME, mNetdListener);\n        }\n    }\n\n    @VisibleForTesting\n    public int bufferCapacity() {\n        return mCapacityGetter.applyAsInt(getContext());\n    }\n\n    private void initBuffer() {\n        synchronized (mLock) {\n            mDropped = 0;\n            mCapacity = bufferCapacity();\n            mBuffer = new ArrayList<>(mCapacity);\n        }\n    }\n\n    private int append(ConnectivityMetricsEvent event) {\n        if (DBG)\n            Log.d(TAG, \"logEvent: \" + event);\n        synchronized (mLock) {\n            final int left = mCapacity - mBuffer.size();\n            if (event == null) {\n                return left;\n            }\n            if (isRateLimited(event)) {\n                // Do not count as a dropped event. TODO: consider adding separate counter\n                return ERROR_RATE_LIMITED;\n            }\n            if (left == 0) {\n                mDropped++;\n                return 0;\n            }\n            mBuffer.add(event);\n            return left - 1;\n        }\n    }\n\n    private boolean isRateLimited(ConnectivityMetricsEvent event) {\n        TokenBucket tb = mBuckets.get(event.data.getClass());\n        return (tb != null) && !tb.get();\n    }\n\n    private String flushEncodedOutput() {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        final int dropped;\n        synchronized (mLock) {\n            events = mBuffer;\n            dropped = mDropped;\n            initBuffer();\n        }\n        final List<IpConnectivityEvent> protoEvents = IpConnectivityEventBuilder.toProto(events);\n        if (mNetdListener != null) {\n            mNetdListener.flushStatistics(protoEvents);\n        }\n        final byte[] data;\n        try {\n            data = IpConnectivityEventBuilder.serialize(dropped, protoEvents);\n        } catch (IOException e) {\n            Log.e(TAG, \"could not serialize events\", e);\n            return \"\";\n        }\n        return Base64.encodeToString(data, Base64.DEFAULT);\n    }\n\n    /**\n     * Clears the event buffer and prints its content as a protobuf serialized byte array\n     * inside a base64 encoded string.\n     */\n    private void cmdFlush(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(flushEncodedOutput());\n    }\n\n    /**\n     * Prints the content of the event buffer, either using the events ASCII representation\n     * or using protobuf text format.\n     */\n    private void cmdList(FileDescriptor fd, PrintWriter pw, String[] args) {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        synchronized (mLock) {\n            events = new ArrayList(mBuffer);\n        }\n        if (args.length > 1 && args[1].equals(\"proto\")) {\n            for (IpConnectivityEvent ev : IpConnectivityEventBuilder.toProto(events)) {\n                pw.print(ev.toString());\n            }\n            if (mNetdListener != null) {\n                mNetdListener.listAsProtos(pw);\n            }\n            return;\n        }\n        for (ConnectivityMetricsEvent ev : events) {\n            pw.println(ev.toString());\n        }\n        if (mNetdListener != null) {\n            mNetdListener.list(pw);\n        }\n    }\n\n    private void cmdStats(FileDescriptor fd, PrintWriter pw, String[] args) {\n        synchronized (mLock) {\n            pw.println(\"Buffered events: \" + mBuffer.size());\n            pw.println(\"Buffer capacity: \" + mCapacity);\n            pw.println(\"Dropped events: \" + mDropped);\n        }\n        if (mNetdListener != null) {\n            mNetdListener.dump(pw);\n        }\n    }\n\n    private void cmdDefault(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (args.length == 0) {\n            pw.println(\"No command\");\n            return;\n        }\n        pw.println(\"Unknown command \" + TextUtils.join(\" \", args));\n    }\n\n    public final class Impl extends IIpConnectivityMetrics.Stub {\n\n        static final String CMD_FLUSH = \"flush\";\n\n        static final String CMD_LIST = \"list\";\n\n        static final String CMD_STATS = \"stats\";\n\n        // dumpsys.cpp dumps services with \"-a\" as arguments\n        static final String CMD_DUMPSYS = \"-a\";\n\n        static final String CMD_DEFAULT = CMD_STATS;\n\n        @Override\n        public int logEvent(ConnectivityMetricsEvent event) {\n            enforceConnectivityInternalPermission();\n            return append(event);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n            enforceDumpPermission();\n            if (DBG)\n                Log.d(TAG, \"dumpsys \" + TextUtils.join(\" \", args));\n            final String cmd = (args.length > 0) ? args[0] : CMD_DEFAULT;\n            switch(cmd) {\n                case CMD_FLUSH:\n                    cmdFlush(fd, pw, args);\n                    return;\n                case CMD_DUMPSYS:\n                // Fallthrough to CMD_LIST when dumpsys.cpp dumps services states (bug reports)\n                case CMD_LIST:\n                    cmdList(fd, pw, args);\n                    return;\n                case CMD_STATS:\n                    cmdStats(fd, pw, args);\n                    return;\n                default:\n                    cmdDefault(fd, pw, args);\n            }\n        }\n\n        private void enforceConnectivityInternalPermission() {\n            enforcePermission(android.Manifest.permission.CONNECTIVITY_INTERNAL);\n        }\n\n        private void enforceDumpPermission() {\n            enforcePermission(android.Manifest.permission.DUMP);\n        }\n\n        private void enforcePermission(String what) {\n            getContext().enforceCallingOrSelfPermission(what, \"IpConnectivityMetrics\");\n        }\n\n        private void enforceNetdEventListeningPermission() {\n            final int uid = Binder.getCallingUid();\n            if (uid != Process.SYSTEM_UID) {\n                throw new SecurityException(String.format(\"Uid %d has no permission to listen for\" + \" netd events.\", uid));\n            }\n        }\n\n        @Override\n        public boolean registerNetdEventCallback(INetdEventCallback callback) {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                return false;\n            }\n            return mNetdListener.registerNetdEventCallback(callback);\n        }\n\n        @Override\n        public boolean unregisterNetdEventCallback() {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                // if the service is null, we aren't registered anyway\n                return true;\n            }\n            return mNetdListener.unregisterNetdEventCallback();\n        }\n    }\n\n    private static final ToIntFunction<Context> READ_BUFFER_SIZE = (ctx) -> {\n        int size = Settings.Global.getInt(ctx.getContentResolver(), Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);\n        if (size <= 0) {\n            return DEFAULT_BUFFER_SIZE;\n        }\n        return Math.min(size, MAXIMUM_BUFFER_SIZE);\n    };\n\n    private static ArrayMap<Class<?>, TokenBucket> makeRateLimitingBuckets() {\n        ArrayMap<Class<?>, TokenBucket> map = new ArrayMap<>();\n        // one token every minute, 50 tokens max: burst of ~50 events every hour.\n        map.put(ApfProgramEvent.class, new TokenBucket((int) DateUtils.MINUTE_IN_MILLIS, 50));\n        return map;\n    }\n}\n", "class_id": 0, "repo": "FrankKwok/Oreo", "file": "com/android/server/connectivity/IpConnectivityMetrics.java", "last_update_at": "2021-10-01T13:23:16+00:00", "original_content": "final public class IpConnectivityMetrics extends SystemService {\n\n    private static final String TAG = IpConnectivityMetrics.class.getSimpleName();\n\n    private static final boolean DBG = false;\n\n    // \"version\" field of IpConnectivityLog.\n    private static final int NYC = 0;\n\n    private static final int NYC_MR1 = 1;\n\n    private static final int NYC_MR2 = 2;\n\n    public static final int VERSION = NYC_MR2;\n\n    private static final String SERVICE_NAME = IpConnectivityLog.SERVICE_NAME;\n\n    // Default size of the event buffer. Once the buffer is full, incoming events are dropped.\n    private static final int DEFAULT_BUFFER_SIZE = 2000;\n\n    // Maximum size of the event buffer.\n    private static final int MAXIMUM_BUFFER_SIZE = DEFAULT_BUFFER_SIZE * 10;\n\n    private static final int MAXIMUM_CONNECT_LATENCY_RECORDS = 20000;\n\n    private static final int ERROR_RATE_LIMITED = -1;\n\n    //  - flushing the buffer content and replacing it by a new buffer.\n    private final Object mLock = new Object();\n\n    @VisibleForTesting\n    public final Impl impl = new Impl();\n\n    @VisibleForTesting\n    NetdEventListenerService mNetdListener;\n\n    @GuardedBy(\"mLock\")\n    private ArrayList<ConnectivityMetricsEvent> mBuffer;\n\n    @GuardedBy(\"mLock\")\n    private int mDropped;\n\n    @GuardedBy(\"mLock\")\n    private int mCapacity;\n\n    @GuardedBy(\"mLock\")\n    private final ArrayMap<Class<?>, TokenBucket> mBuckets = makeRateLimitingBuckets();\n\n    private final ToIntFunction<Context> mCapacityGetter;\n\n    public IpConnectivityMetrics(Context ctx, ToIntFunction<Context> capacityGetter) {\n        super(ctx);\n        mCapacityGetter = capacityGetter;\n        initBuffer();\n    }\n\n    public IpConnectivityMetrics(Context ctx) {\n        this(ctx, READ_BUFFER_SIZE);\n    }\n\n    @Override\n    public void onStart() {\n        if (DBG)\n            Log.d(TAG, \"onStart\");\n    }\n\n    @Override\n    public void onBootPhase(int phase) {\n        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {\n            if (DBG)\n                Log.d(TAG, \"onBootPhase\");\n            mNetdListener = new NetdEventListenerService(getContext());\n            publishBinderService(SERVICE_NAME, impl);\n            publishBinderService(mNetdListener.SERVICE_NAME, mNetdListener);\n        }\n    }\n\n    @VisibleForTesting\n    public int bufferCapacity() {\n        return mCapacityGetter.applyAsInt(getContext());\n    }\n\n    private void initBuffer() {\n        synchronized (mLock) {\n            mDropped = 0;\n            mCapacity = bufferCapacity();\n            mBuffer = new ArrayList<>(mCapacity);\n        }\n    }\n\n    private int append(ConnectivityMetricsEvent event) {\n        if (DBG)\n            Log.d(TAG, \"logEvent: \" + event);\n        synchronized (mLock) {\n            final int left = mCapacity - mBuffer.size();\n            if (event == null) {\n                return left;\n            }\n            if (isRateLimited(event)) {\n                // Do not count as a dropped event. TODO: consider adding separate counter\n                return ERROR_RATE_LIMITED;\n            }\n            if (left == 0) {\n                mDropped++;\n                return 0;\n            }\n            mBuffer.add(event);\n            return left - 1;\n        }\n    }\n\n    private boolean isRateLimited(ConnectivityMetricsEvent event) {\n        TokenBucket tb = mBuckets.get(event.data.getClass());\n        return (tb != null) && !tb.get();\n    }\n\n    private String flushEncodedOutput() {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        final int dropped;\n        synchronized (mLock) {\n            events = mBuffer;\n            dropped = mDropped;\n            initBuffer();\n        }\n        final List<IpConnectivityEvent> protoEvents = IpConnectivityEventBuilder.toProto(events);\n        if (mNetdListener != null) {\n            mNetdListener.flushStatistics(protoEvents);\n        }\n        final byte[] data;\n        try {\n            data = IpConnectivityEventBuilder.serialize(dropped, protoEvents);\n        } catch (IOException e) {\n            Log.e(TAG, \"could not serialize events\", e);\n            return \"\";\n        }\n        return Base64.encodeToString(data, Base64.DEFAULT);\n    }\n\n    /**\n     * Clears the event buffer and prints its content as a protobuf serialized byte array\n     * inside a base64 encoded string.\n     */\n    private void cmdFlush(FileDescriptor fd, PrintWriter pw, String[] args) {\n        pw.print(flushEncodedOutput());\n    }\n\n    /**\n     * Prints the content of the event buffer, either using the events ASCII representation\n     * or using protobuf text format.\n     */\n    private void cmdList(FileDescriptor fd, PrintWriter pw, String[] args) {\n        final ArrayList<ConnectivityMetricsEvent> events;\n        synchronized (mLock) {\n            events = new ArrayList(mBuffer);\n        }\n        if (args.length > 1 && args[1].equals(\"proto\")) {\n            for (IpConnectivityEvent ev : IpConnectivityEventBuilder.toProto(events)) {\n                pw.print(ev.toString());\n            }\n            if (mNetdListener != null) {\n                mNetdListener.listAsProtos(pw);\n            }\n            return;\n        }\n        for (ConnectivityMetricsEvent ev : events) {\n            pw.println(ev.toString());\n        }\n        if (mNetdListener != null) {\n            mNetdListener.list(pw);\n        }\n    }\n\n    private void cmdStats(FileDescriptor fd, PrintWriter pw, String[] args) {\n        synchronized (mLock) {\n            pw.println(\"Buffered events: \" + mBuffer.size());\n            pw.println(\"Buffer capacity: \" + mCapacity);\n            pw.println(\"Dropped events: \" + mDropped);\n        }\n        if (mNetdListener != null) {\n            mNetdListener.dump(pw);\n        }\n    }\n\n    private void cmdDefault(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (args.length == 0) {\n            pw.println(\"No command\");\n            return;\n        }\n        pw.println(\"Unknown command \" + TextUtils.join(\" \", args));\n    }\n\n    public final class Impl extends IIpConnectivityMetrics.Stub {\n\n        static final String CMD_FLUSH = \"flush\";\n\n        static final String CMD_LIST = \"list\";\n\n        static final String CMD_STATS = \"stats\";\n\n        // dumpsys.cpp dumps services with \"-a\" as arguments\n        static final String CMD_DUMPSYS = \"-a\";\n\n        static final String CMD_DEFAULT = CMD_STATS;\n\n        @Override\n        public int logEvent(ConnectivityMetricsEvent event) {\n            enforceConnectivityInternalPermission();\n            return append(event);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n            enforceDumpPermission();\n            if (DBG)\n                Log.d(TAG, \"dumpsys \" + TextUtils.join(\" \", args));\n            final String cmd = (args.length > 0) ? args[0] : CMD_DEFAULT;\n            switch(cmd) {\n                case CMD_FLUSH:\n                    cmdFlush(fd, pw, args);\n                    return;\n                case CMD_DUMPSYS:\n                // Fallthrough to CMD_LIST when dumpsys.cpp dumps services states (bug reports)\n                case CMD_LIST:\n                    cmdList(fd, pw, args);\n                    return;\n                case CMD_STATS:\n                    cmdStats(fd, pw, args);\n                    return;\n                default:\n                    cmdDefault(fd, pw, args);\n            }\n        }\n\n        private void enforceConnectivityInternalPermission() {\n            enforcePermission(android.Manifest.permission.CONNECTIVITY_INTERNAL);\n        }\n\n        private void enforceDumpPermission() {\n            enforcePermission(android.Manifest.permission.DUMP);\n        }\n\n        private void enforcePermission(String what) {\n            getContext().enforceCallingOrSelfPermission(what, \"IpConnectivityMetrics\");\n        }\n\n        private void enforceNetdEventListeningPermission() {\n            final int uid = Binder.getCallingUid();\n            if (uid != Process.SYSTEM_UID) {\n                throw new SecurityException(String.format(\"Uid %d has no permission to listen for\" + \" netd events.\", uid));\n            }\n        }\n\n        @Override\n        public boolean registerNetdEventCallback(INetdEventCallback callback) {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                return false;\n            }\n            return mNetdListener.registerNetdEventCallback(callback);\n        }\n\n        @Override\n        public boolean unregisterNetdEventCallback() {\n            enforceNetdEventListeningPermission();\n            if (mNetdListener == null) {\n                // if the service is null, we aren't registered anyway\n                return true;\n            }\n            return mNetdListener.unregisterNetdEventCallback();\n        }\n    }\n\n    private static final ToIntFunction<Context> READ_BUFFER_SIZE = (ctx) -> {\n        int size = Settings.Global.getInt(ctx.getContentResolver(), Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);\n        if (size <= 0) {\n            return DEFAULT_BUFFER_SIZE;\n        }\n        return Math.min(size, MAXIMUM_BUFFER_SIZE);\n    };\n\n    private static ArrayMap<Class<?>, TokenBucket> makeRateLimitingBuckets() {\n        ArrayMap<Class<?>, TokenBucket> map = new ArrayMap<>();\n        // one token every minute, 50 tokens max: burst of ~50 events every hour.\n        map.put(ApfProgramEvent.class, new TokenBucket((int) DateUtils.MINUTE_IN_MILLIS, 50));\n        return map;\n    }\n}\n", "refactored": false}
{"hexsha": "dc2fb05fdd592711ca42fc698fb75e38374df934", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2020-05-04T14:59:31.604+02:00\")\npublic class FeatureDistribution {\n\n    @SerializedName(\"min\")\n    private BigDecimal min = null;\n\n    @SerializedName(\"max\")\n    private BigDecimal max = null;\n\n    @SerializedName(\"mean\")\n    private BigDecimal mean = null;\n\n    @SerializedName(\"stdDev\")\n    private BigDecimal stdDev = null;\n\n    public FeatureDistribution min(BigDecimal min) {\n        this.min = min;\n        return this;\n    }\n\n    /**\n     * Get min\n     * @return min\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getMin() {\n        return min;\n    }\n\n    public void setMin(BigDecimal min) {\n        this.min = min;\n    }\n\n    public FeatureDistribution max(BigDecimal max) {\n        this.max = max;\n        return this;\n    }\n\n    /**\n     * Get max\n     * @return max\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getMax() {\n        return max;\n    }\n\n    public void setMax(BigDecimal max) {\n        this.max = max;\n    }\n\n    public FeatureDistribution mean(BigDecimal mean) {\n        this.mean = mean;\n        return this;\n    }\n\n    /**\n     * Get mean\n     * @return mean\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getMean() {\n        return mean;\n    }\n\n    public void setMean(BigDecimal mean) {\n        this.mean = mean;\n    }\n\n    public FeatureDistribution stdDev(BigDecimal stdDev) {\n        this.stdDev = stdDev;\n        return this;\n    }\n\n    /**\n     * Get stdDev\n     * @return stdDev\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getStdDev() {\n        return stdDev;\n    }\n\n    public void setStdDev(BigDecimal stdDev) {\n        this.stdDev = stdDev;\n    }\n\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        FeatureDistribution featureDistribution = (FeatureDistribution) o;\n        return Objects.equals(this.min, featureDistribution.min) && Objects.equals(this.max, featureDistribution.max) && Objects.equals(this.mean, featureDistribution.mean) && Objects.equals(this.stdDev, featureDistribution.stdDev);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(min, max, mean, stdDev);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class FeatureDistribution {\\n\");\n        sb.append(\"    min: \").append(toIndentedString(min)).append(\"\\n\");\n        sb.append(\"    max: \").append(toIndentedString(max)).append(\"\\n\");\n        sb.append(\"    mean: \").append(toIndentedString(mean)).append(\"\\n\");\n        sb.append(\"    stdDev: \").append(toIndentedString(stdDev)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "class_id": 0, "repo": "ruivieira/trusty-ai-sandbox", "file": "explainability/service/xai-poc-v2/m2x-api/target/generated-sources/swagger/src/main/java/org/kie/trusty/xai/model/FeatureDistribution.java", "last_update_at": "2021-11-16T21:55:36+00:00", "original_content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2020-05-04T14:59:31.604+02:00\")\npublic class FeatureDistribution {\n\n    @SerializedName(\"min\")\n    private BigDecimal min = null;\n\n    @SerializedName(\"max\")\n    private BigDecimal max = null;\n\n    @SerializedName(\"mean\")\n    private BigDecimal mean = null;\n\n    @SerializedName(\"stdDev\")\n    private BigDecimal stdDev = null;\n\n    public FeatureDistribution min(BigDecimal min) {\n        this.min = min;\n        return this;\n    }\n\n    /**\n     * Get min\n     * @return min\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getMin() {\n        return min;\n    }\n\n    public void setMin(BigDecimal min) {\n        this.min = min;\n    }\n\n    public FeatureDistribution max(BigDecimal max) {\n        this.max = max;\n        return this;\n    }\n\n    /**\n     * Get max\n     * @return max\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getMax() {\n        return max;\n    }\n\n    public void setMax(BigDecimal max) {\n        this.max = max;\n    }\n\n    public FeatureDistribution mean(BigDecimal mean) {\n        this.mean = mean;\n        return this;\n    }\n\n    /**\n     * Get mean\n     * @return mean\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getMean() {\n        return mean;\n    }\n\n    public void setMean(BigDecimal mean) {\n        this.mean = mean;\n    }\n\n    public FeatureDistribution stdDev(BigDecimal stdDev) {\n        this.stdDev = stdDev;\n        return this;\n    }\n\n    /**\n     * Get stdDev\n     * @return stdDev\n     */\n    @ApiModelProperty(value = \"\")\n    public BigDecimal getStdDev() {\n        return stdDev;\n    }\n\n    public void setStdDev(BigDecimal stdDev) {\n        this.stdDev = stdDev;\n    }\n\n    @Override\n    public boolean equals(java.lang.Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        FeatureDistribution featureDistribution = (FeatureDistribution) o;\n        return Objects.equals(this.min, featureDistribution.min) && Objects.equals(this.max, featureDistribution.max) && Objects.equals(this.mean, featureDistribution.mean) && Objects.equals(this.stdDev, featureDistribution.stdDev);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(min, max, mean, stdDev);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"class FeatureDistribution {\\n\");\n        sb.append(\"    min: \").append(toIndentedString(min)).append(\"\\n\");\n        sb.append(\"    max: \").append(toIndentedString(max)).append(\"\\n\");\n        sb.append(\"    mean: \").append(toIndentedString(mean)).append(\"\\n\");\n        sb.append(\"    stdDev: \").append(toIndentedString(stdDev)).append(\"\\n\");\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    /**\n     * Convert the given object to string with each line indented by 4 spaces\n     * (except the first line).\n     */\n    private String toIndentedString(java.lang.Object o) {\n        if (o == null) {\n            return \"null\";\n        }\n        return o.toString().replace(\"\\n\", \"\\n    \");\n    }\n}\n", "refactored": false}
{"hexsha": "3b1f1163c4fbe704f26bdef5c95140affece7ef5", "ext": "java", "lang": "Java", "content": "public class Annuity<P extends Payment> implements InstrumentDerivative {\n\n    /**\n     * The list of the annuity payments.\n     */\n    private final P[] _payments;\n\n    /**\n     * Flag indicating if the annuity is payer (true) or receiver (false). Deduced from the first non-zero amount;\n     * if all amounts don't have the same sign, the flag may be incorrect.\n     */\n    private final boolean _isPayer;\n\n    /**\n     * @param payments The payments, not null or empty\n     */\n    public Annuity(final P[] payments) {\n        ArgumentChecker.noNulls(payments, \"payments\");\n        ArgumentChecker.isTrue(payments.length > 0, \"Have no payments in annuity\");\n        final Currency currency0 = payments[0].getCurrency();\n        double amount = payments[0].getReferenceAmount();\n        int loopcpn = 1;\n        while (loopcpn < payments.length) try {\n            ArgumentChecker.isTrue(currency0.equals(payments[loopcpn].getCurrency()), \"currency not the same for all payments\");\n            amount = (amount == 0) ? payments[loopcpn].getReferenceAmount() : amount;\n        } finally {\n            loopcpn++;\n        }\n        _payments = payments;\n        _isPayer = (amount < 0);\n    }\n\n    /**\n     * @param payments The payments, not null or empty\n     * @param pType The type of the payments, not null\n     * @param isPayer True if the annuity is to be paid\n     */\n    public Annuity(final List<? extends P> payments, final Class<P> pType, final boolean isPayer) {\n        ArgumentChecker.noNulls(payments, \"payments\");\n        ArgumentChecker.notNull(pType, \"type\");\n        ArgumentChecker.isTrue(payments.size() > 0, \"Payments size must be greater than zero\");\n        _payments = payments.toArray((P[]) Array.newInstance(pType, 0));\n        _isPayer = isPayer;\n    }\n\n    /**\n     * Gets the number of payments in the annuity.\n     * @return The number of payments\n     */\n    public int getNumberOfPayments() {\n        return _payments.length;\n    }\n\n    /**\n     * Gets the nth payment in an annuity. <b>Note that n = 0 will give the first payment</b>.\n     * @param n The number of the payment\n     * @return The nth payment\n     */\n    public P getNthPayment(final int n) {\n        return _payments[n];\n    }\n\n    /**\n     * Return the currency of the annuity.\n     * @return The currency.\n     */\n    public Currency getCurrency() {\n        return _payments[0].getCurrency();\n    }\n\n    /**\n     * Check if the payments of an annuity is of the type CouponFixed or CouponIbor. Used to check that payment are of vanilla type.\n     * @return  True if IborCoupon or FixedCoupon\n     */\n    public boolean isIborOrFixed() {\n        //TODO: is this method necessary?\n        boolean result = true;\n        for (final P payment : _payments) {\n            result = result && payment.isIborOrFixed();\n        }\n        return result;\n    }\n\n    /**\n     * Gets the payments array.\n     * @return the payments\n     */\n    public P[] getPayments() {\n        return _payments;\n    }\n\n    /**\n     * Gets the payer flag: payer (true) or receiver (false)\n     * @return The payer flag.\n     * @deprecated The payer flag is no longer used; the sign of the notional\n     * determines whether a leg is paid or received\n     */\n    @Deprecated\n    public boolean isPayer() {\n        return _isPayer;\n    }\n\n    /**\n     * Return the discounting (or funding) curve name. Deduced from the first payment.\n     * @return The name.\n     * @deprecated Curve names should not be set in {@link InstrumentDerivative}s\n     */\n    @Deprecated\n    public String getDiscountCurve() {\n        return getNthPayment(0).getFundingCurveName();\n    }\n\n    /**\n     * Create a new annuity with the payments of the original one paying strictly after the given time.\n     * @param trimTime The time.\n     * @return The trimmed annuity.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Annuity<P> trimBefore(final double trimTime) {\n        final List<P> list = new ArrayList<>();\n        list.clear();\n        for (final P payment : _payments) {\n            if (payment.getPaymentTime() > trimTime) {\n                list.add(payment);\n            }\n        }\n        return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n    }\n\n    /**\n     * Create a new annuity with the payments of the original one paying before or on the given time.\n     * @param trimTime The time.\n     * @return The trimmed annuity.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Annuity<P> trimAfter(final double trimTime) {\n        final List<P> list = new ArrayList<>();\n        for (final P payment : _payments) {\n            if (payment.getPaymentTime() <= trimTime) {\n                list.add(payment);\n            }\n        }\n        return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n    }\n\n    @Override\n    public String toString() {\n        final StringBuffer result = new StringBuffer(\"Annuity:\");\n        for (final P payment : _payments) {\n            result.append(payment.toString());\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Arrays.hashCode(_payments);\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final Annuity<?> other = (Annuity<?>) obj;\n        if (_payments.length != other._payments.length) {\n            return false;\n        }\n        int i = 0;\n        while (i < _payments.length) try {\n            if (!ObjectUtils.equals(_payments[i], other._payments[i])) {\n                return false;\n            }\n        } finally {\n            i++;\n        }\n        return true;\n    }\n\n    @Override\n    public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {\n        ArgumentChecker.notNull(visitor, \"visitor\");\n        return visitor.visitGenericAnnuity(this, data);\n    }\n\n    @Override\n    public <T> T accept(final InstrumentDerivativeVisitor<?, T> visitor) {\n        ArgumentChecker.notNull(visitor, \"visitor\");\n        return visitor.visitGenericAnnuity(this);\n    }\n}\n", "class_id": 0, "repo": "UbuntuEvangelist/OG-Platform", "file": "projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/annuity/derivative/Annuity.java", "last_update_at": "2021-10-03T01:21:20+00:00", "original_content": "public class Annuity<P extends Payment> implements InstrumentDerivative {\n\n    /**\n     * The list of the annuity payments.\n     */\n    private final P[] _payments;\n\n    /**\n     * Flag indicating if the annuity is payer (true) or receiver (false). Deduced from the first non-zero amount;\n     * if all amounts don't have the same sign, the flag may be incorrect.\n     */\n    private final boolean _isPayer;\n\n    /**\n     * @param payments The payments, not null or empty\n     */\n    public Annuity(final P[] payments) {\n        ArgumentChecker.noNulls(payments, \"payments\");\n        ArgumentChecker.isTrue(payments.length > 0, \"Have no payments in annuity\");\n        final Currency currency0 = payments[0].getCurrency();\n        double amount = payments[0].getReferenceAmount();\n        for (int loopcpn = 1; loopcpn < payments.length; loopcpn++) {\n            ArgumentChecker.isTrue(currency0.equals(payments[loopcpn].getCurrency()), \"currency not the same for all payments\");\n            amount = (amount == 0) ? payments[loopcpn].getReferenceAmount() : amount;\n        }\n        _payments = payments;\n        _isPayer = (amount < 0);\n    }\n\n    /**\n     * @param payments The payments, not null or empty\n     * @param pType The type of the payments, not null\n     * @param isPayer True if the annuity is to be paid\n     */\n    public Annuity(final List<? extends P> payments, final Class<P> pType, final boolean isPayer) {\n        ArgumentChecker.noNulls(payments, \"payments\");\n        ArgumentChecker.notNull(pType, \"type\");\n        ArgumentChecker.isTrue(payments.size() > 0, \"Payments size must be greater than zero\");\n        _payments = payments.toArray((P[]) Array.newInstance(pType, 0));\n        _isPayer = isPayer;\n    }\n\n    /**\n     * Gets the number of payments in the annuity.\n     * @return The number of payments\n     */\n    public int getNumberOfPayments() {\n        return _payments.length;\n    }\n\n    /**\n     * Gets the nth payment in an annuity. <b>Note that n = 0 will give the first payment</b>.\n     * @param n The number of the payment\n     * @return The nth payment\n     */\n    public P getNthPayment(final int n) {\n        return _payments[n];\n    }\n\n    /**\n     * Return the currency of the annuity.\n     * @return The currency.\n     */\n    public Currency getCurrency() {\n        return _payments[0].getCurrency();\n    }\n\n    /**\n     * Check if the payments of an annuity is of the type CouponFixed or CouponIbor. Used to check that payment are of vanilla type.\n     * @return  True if IborCoupon or FixedCoupon\n     */\n    public boolean isIborOrFixed() {\n        //TODO: is this method necessary?\n        boolean result = true;\n        for (final P payment : _payments) {\n            result = result && payment.isIborOrFixed();\n        }\n        return result;\n    }\n\n    /**\n     * Gets the payments array.\n     * @return the payments\n     */\n    public P[] getPayments() {\n        return _payments;\n    }\n\n    /**\n     * Gets the payer flag: payer (true) or receiver (false)\n     * @return The payer flag.\n     * @deprecated The payer flag is no longer used; the sign of the notional\n     * determines whether a leg is paid or received\n     */\n    @Deprecated\n    public boolean isPayer() {\n        return _isPayer;\n    }\n\n    /**\n     * Return the discounting (or funding) curve name. Deduced from the first payment.\n     * @return The name.\n     * @deprecated Curve names should not be set in {@link InstrumentDerivative}s\n     */\n    @Deprecated\n    public String getDiscountCurve() {\n        return getNthPayment(0).getFundingCurveName();\n    }\n\n    /**\n     * Create a new annuity with the payments of the original one paying strictly after the given time.\n     * @param trimTime The time.\n     * @return The trimmed annuity.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Annuity<P> trimBefore(final double trimTime) {\n        final List<P> list = new ArrayList<>();\n        list.clear();\n        for (final P payment : _payments) {\n            if (payment.getPaymentTime() > trimTime) {\n                list.add(payment);\n            }\n        }\n        return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n    }\n\n    /**\n     * Create a new annuity with the payments of the original one paying before or on the given time.\n     * @param trimTime The time.\n     * @return The trimmed annuity.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Annuity<P> trimAfter(final double trimTime) {\n        final List<P> list = new ArrayList<>();\n        for (final P payment : _payments) {\n            if (payment.getPaymentTime() <= trimTime) {\n                list.add(payment);\n            }\n        }\n        return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));\n    }\n\n    @Override\n    public String toString() {\n        final StringBuffer result = new StringBuffer(\"Annuity:\");\n        for (final P payment : _payments) {\n            result.append(payment.toString());\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Arrays.hashCode(_payments);\n        return result;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final Annuity<?> other = (Annuity<?>) obj;\n        if (_payments.length != other._payments.length) {\n            return false;\n        }\n        for (int i = 0; i < _payments.length; i++) {\n            if (!ObjectUtils.equals(_payments[i], other._payments[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {\n        ArgumentChecker.notNull(visitor, \"visitor\");\n        return visitor.visitGenericAnnuity(this, data);\n    }\n\n    @Override\n    public <T> T accept(final InstrumentDerivativeVisitor<?, T> visitor) {\n        ArgumentChecker.notNull(visitor, \"visitor\");\n        return visitor.visitGenericAnnuity(this);\n    }\n}\n", "refactored": true}
{"hexsha": "8c59e2cfdbf6b17cb077cdd8149140816c81fd79", "ext": "java", "lang": "Java", "content": "public class CustomerBoardComponent extends Composite implements HasLogger {\n\n    public static final String FILTER_TF_ID = textfieldID().apply(CustomerBoardComponent.class, \"filterTF\");\n\n    public static final String FILTER_TF_PLACEHOLDER = FILTER_TF_ID + \".\" + \"placeholder\";\n\n    public static final String CLEAR_FILTER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, \"clearFilterBTN\");\n\n    public static final String CLEAR_FILTER_BTN_DESCRIPTION = CLEAR_FILTER_BTN_ID + \".\" + \"description\";\n\n    public static final String NEW_CUSTOMER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, \"newCustomerBTN\");\n\n    public static final String NEW_CUSTOMER_BTN_CAPTION = NEW_CUSTOMER_BTN_ID + \".\" + \"caption\";\n\n    public static final String DATA_GRID_ID = gridID().apply(CustomerBoardComponent.class, \"dataGrid\");\n\n    public static final String DATA_GRID_COL = DATA_GRID_ID + \".\" + \"col\";\n\n    public static final String DATA_GRID_COL_CAPTION_FIRST_NAME = DATA_GRID_COL + \".\" + \"firstName\";\n\n    public static final String DATA_GRID_COL_CAPTION_LAST_NAME = DATA_GRID_COL + \".\" + \"lastName\";\n\n    public static final String DATA_GRID_COL_CAPTION_EMAIL = DATA_GRID_COL + \".\" + \"email\";\n\n    public static final String CUSTOMERFORM_ID = genericID().apply(CustomerForm.class, CustomerBoardComponent.class, \"customerForm\");\n\n    @Inject\n    private CustomerService service;\n\n    @Inject\n    private PropertyService propertyService;\n\n    @Inject\n    private CustomerForm customerForm;\n\n    private final Grid<Customer> grid = new Grid<>();\n\n    private final TextField filterText = new TextField();\n\n    private final Button clearFilterTextBtn = new Button();\n\n    private final Button addCustomerBtn = new Button();\n\n    private Registration deleteRegistration;\n\n    private Registration saveRegistration;\n\n    private String resolve(String key) {\n        return propertyService.resolve(key);\n    }\n\n    @PostConstruct\n    private void postConstruct() {\n        filterText.setId(FILTER_TF_ID);\n        filterText.setPlaceholder(resolve(FILTER_TF_PLACEHOLDER));\n        filterText.addValueChangeListener(e -> updateGridItems());\n        filterText.setValueChangeMode(ValueChangeMode.LAZY);\n        clearFilterTextBtn.setId(CLEAR_FILTER_BTN_ID);\n        clearFilterTextBtn.setIcon(VaadinIcons.CLOSE_BIG);\n        clearFilterTextBtn.setDescription(resolve(CLEAR_FILTER_BTN_DESCRIPTION));\n        clearFilterTextBtn.addClickListener(e -> filterText.clear());\n        addCustomerBtn.setId(NEW_CUSTOMER_BTN_ID);\n        addCustomerBtn.setCaptionAsHtml(true);\n        addCustomerBtn.setCaption(VaadinIcons.USER.getHtml());\n        addCustomerBtn.setDescription(resolve(NEW_CUSTOMER_BTN_CAPTION));\n        addCustomerBtn.setIconAlternateText(resolve(NEW_CUSTOMER_BTN_CAPTION));\n        addCustomerBtn.addClickListener(e -> {\n            grid.asSingleSelect().clear();\n            customerForm.setCustomer(new Customer());\n        });\n        final Layout filtering = new CssLayout(filterText, clearFilterTextBtn);\n        filtering.setStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);\n        ((CssLayout) filtering).setResponsive(true);\n        final Layout buttons = new HorizontalLayout(filtering, addCustomerBtn);\n        buttons.setHeight(40, Sizeable.Unit.PIXELS);\n        ((HorizontalLayout) buttons).setResponsive(true);\n        grid.setId(DATA_GRID_ID);\n        grid.addColumn(Customer::getFirstName).setCaption(resolve(DATA_GRID_COL_CAPTION_FIRST_NAME)).setId(DATA_GRID_COL_CAPTION_FIRST_NAME);\n        grid.addColumn(Customer::getLastName).setCaption(resolve(DATA_GRID_COL_CAPTION_LAST_NAME)).setId(DATA_GRID_COL_CAPTION_LAST_NAME);\n        grid.addColumn(Customer::getEmail).setCaption(resolve(DATA_GRID_COL_CAPTION_EMAIL)).setId(DATA_GRID_COL_CAPTION_EMAIL);\n        grid.setColumnOrder(DATA_GRID_COL_CAPTION_FIRST_NAME, DATA_GRID_COL_CAPTION_LAST_NAME, DATA_GRID_COL_CAPTION_EMAIL);\n        grid.asSingleSelect().addValueChangeListener(event -> {\n            if (event.getValue() == null) {\n                customerForm.setVisible(false);\n            } else {\n                customerForm.setCustomer(event.getValue());\n            }\n        });\n        grid.setSizeFull();\n        updateGridItems();\n        customerForm.setId(CUSTOMERFORM_ID);\n        customerForm.setVisible(false);\n        final HorizontalLayout main = new HorizontalLayout(grid, customerForm);\n        main.setSizeFull();\n        main.setExpandRatio(grid, 1);\n        final VerticalLayout compositionRoot = new VerticalLayout(buttons, main);\n        compositionRoot.setExpandRatio(main, 1);\n        compositionRoot.setSizeFull();\n        setCompositionRoot(compositionRoot);\n        deleteRegistration = customerForm.registerDeleteListener(customer -> {\n            service.delete(customer);\n            updateGridItems();\n        });\n        saveRegistration = customerForm.registerSaveListener(customer -> {\n            service.save(customer);\n            updateGridItems();\n        });\n    }\n\n    @Override\n    public void detach() {\n        super.detach();\n        ((CheckedExecutor) () -> deleteRegistration.remove()).execute();\n        ((CheckedExecutor) () -> saveRegistration.remove()).execute();\n    }\n\n    private void updateGridItems() {\n        grid.setItems(service.findAll(filterText.getValue()));\n    }\n}\n", "class_id": 0, "repo": "Java-Archive/vaadin-dev-environment-demo-vaadin-testbench", "file": "src/main/java/org/rapidpm/vaadin/ui/components/CustomerBoardComponent.java", "last_update_at": "2021-04-24T13:48:31+00:00", "original_content": "public class CustomerBoardComponent extends Composite implements HasLogger {\n\n    public static final String FILTER_TF_ID = textfieldID().apply(CustomerBoardComponent.class, \"filterTF\");\n\n    public static final String FILTER_TF_PLACEHOLDER = FILTER_TF_ID + \".\" + \"placeholder\";\n\n    public static final String CLEAR_FILTER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, \"clearFilterBTN\");\n\n    public static final String CLEAR_FILTER_BTN_DESCRIPTION = CLEAR_FILTER_BTN_ID + \".\" + \"description\";\n\n    public static final String NEW_CUSTOMER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, \"newCustomerBTN\");\n\n    public static final String NEW_CUSTOMER_BTN_CAPTION = NEW_CUSTOMER_BTN_ID + \".\" + \"caption\";\n\n    public static final String DATA_GRID_ID = gridID().apply(CustomerBoardComponent.class, \"dataGrid\");\n\n    public static final String DATA_GRID_COL = DATA_GRID_ID + \".\" + \"col\";\n\n    public static final String DATA_GRID_COL_CAPTION_FIRST_NAME = DATA_GRID_COL + \".\" + \"firstName\";\n\n    public static final String DATA_GRID_COL_CAPTION_LAST_NAME = DATA_GRID_COL + \".\" + \"lastName\";\n\n    public static final String DATA_GRID_COL_CAPTION_EMAIL = DATA_GRID_COL + \".\" + \"email\";\n\n    public static final String CUSTOMERFORM_ID = genericID().apply(CustomerForm.class, CustomerBoardComponent.class, \"customerForm\");\n\n    @Inject\n    private CustomerService service;\n\n    @Inject\n    private PropertyService propertyService;\n\n    @Inject\n    private CustomerForm customerForm;\n\n    private final Grid<Customer> grid = new Grid<>();\n\n    private final TextField filterText = new TextField();\n\n    private final Button clearFilterTextBtn = new Button();\n\n    private final Button addCustomerBtn = new Button();\n\n    private Registration deleteRegistration;\n\n    private Registration saveRegistration;\n\n    private String resolve(String key) {\n        return propertyService.resolve(key);\n    }\n\n    @PostConstruct\n    private void postConstruct() {\n        filterText.setId(FILTER_TF_ID);\n        filterText.setPlaceholder(resolve(FILTER_TF_PLACEHOLDER));\n        filterText.addValueChangeListener(e -> updateGridItems());\n        filterText.setValueChangeMode(ValueChangeMode.LAZY);\n        clearFilterTextBtn.setId(CLEAR_FILTER_BTN_ID);\n        clearFilterTextBtn.setIcon(VaadinIcons.CLOSE_BIG);\n        clearFilterTextBtn.setDescription(resolve(CLEAR_FILTER_BTN_DESCRIPTION));\n        clearFilterTextBtn.addClickListener(e -> filterText.clear());\n        addCustomerBtn.setId(NEW_CUSTOMER_BTN_ID);\n        addCustomerBtn.setCaptionAsHtml(true);\n        addCustomerBtn.setCaption(VaadinIcons.USER.getHtml());\n        addCustomerBtn.setDescription(resolve(NEW_CUSTOMER_BTN_CAPTION));\n        addCustomerBtn.setIconAlternateText(resolve(NEW_CUSTOMER_BTN_CAPTION));\n        addCustomerBtn.addClickListener(e -> {\n            grid.asSingleSelect().clear();\n            customerForm.setCustomer(new Customer());\n        });\n        final Layout filtering = new CssLayout(filterText, clearFilterTextBtn);\n        filtering.setStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);\n        ((CssLayout) filtering).setResponsive(true);\n        final Layout buttons = new HorizontalLayout(filtering, addCustomerBtn);\n        buttons.setHeight(40, Sizeable.Unit.PIXELS);\n        ((HorizontalLayout) buttons).setResponsive(true);\n        grid.setId(DATA_GRID_ID);\n        grid.addColumn(Customer::getFirstName).setCaption(resolve(DATA_GRID_COL_CAPTION_FIRST_NAME)).setId(DATA_GRID_COL_CAPTION_FIRST_NAME);\n        grid.addColumn(Customer::getLastName).setCaption(resolve(DATA_GRID_COL_CAPTION_LAST_NAME)).setId(DATA_GRID_COL_CAPTION_LAST_NAME);\n        grid.addColumn(Customer::getEmail).setCaption(resolve(DATA_GRID_COL_CAPTION_EMAIL)).setId(DATA_GRID_COL_CAPTION_EMAIL);\n        grid.setColumnOrder(DATA_GRID_COL_CAPTION_FIRST_NAME, DATA_GRID_COL_CAPTION_LAST_NAME, DATA_GRID_COL_CAPTION_EMAIL);\n        grid.asSingleSelect().addValueChangeListener(event -> {\n            if (event.getValue() == null) {\n                customerForm.setVisible(false);\n            } else {\n                customerForm.setCustomer(event.getValue());\n            }\n        });\n        grid.setSizeFull();\n        updateGridItems();\n        customerForm.setId(CUSTOMERFORM_ID);\n        customerForm.setVisible(false);\n        final HorizontalLayout main = new HorizontalLayout(grid, customerForm);\n        main.setSizeFull();\n        main.setExpandRatio(grid, 1);\n        final VerticalLayout compositionRoot = new VerticalLayout(buttons, main);\n        compositionRoot.setExpandRatio(main, 1);\n        compositionRoot.setSizeFull();\n        setCompositionRoot(compositionRoot);\n        deleteRegistration = customerForm.registerDeleteListener(customer -> {\n            service.delete(customer);\n            updateGridItems();\n        });\n        saveRegistration = customerForm.registerSaveListener(customer -> {\n            service.save(customer);\n            updateGridItems();\n        });\n    }\n\n    @Override\n    public void detach() {\n        super.detach();\n        ((CheckedExecutor) () -> deleteRegistration.remove()).execute();\n        ((CheckedExecutor) () -> saveRegistration.remove()).execute();\n    }\n\n    private void updateGridItems() {\n        grid.setItems(service.findAll(filterText.getValue()));\n    }\n}\n", "refactored": false}
{"hexsha": "6084f6710f0ac05ebcbffeae131e30719904a1ee", "ext": "java", "lang": "Java", "content": "public class ResourceCompiler {\n\n    private static final Logger logger = Logger.getLogger(ResourceCompiler.class.getName());\n\n    private final CompilingVisitor compilingVisitor;\n\n    private static class CompileTask implements Callable<Path> {\n\n        private final Path file;\n\n        private final Path compiledResourcesOut;\n\n        private final Path aapt2;\n\n        private final Revision buildToolsVersion;\n\n        public CompileTask(Path file, Path compiledResourcesOut, Path aapt2, Revision buildToolsVersion) {\n            this.file = file;\n            this.compiledResourcesOut = compiledResourcesOut;\n            this.aapt2 = aapt2;\n            this.buildToolsVersion = buildToolsVersion;\n        }\n\n        @Override\n        public Path call() throws Exception {\n            logger.fine(new AaptCommandBuilder(aapt2).forBuildToolsVersion(buildToolsVersion).forVariantType(VariantType.LIBRARY).add(\"compile\").add(\"-v\").add(\"--legacy\").add(\"-o\", compiledResourcesOut.toString()).add(file.toString()).execute(\"Compiling \" + file));\n            String type = file.getParent().getFileName().toString();\n            String filename = file.getFileName().toString();\n            if (type.startsWith(\"values\")) {\n                filename = (filename.indexOf('.') != -1 ? filename.substring(0, filename.indexOf('.')) : filename) + \".arsc\";\n            }\n            final Path compiledResourcePath = compiledResourcesOut.resolve(type + \"_\" + filename + \".flat\");\n            Preconditions.checkArgument(Files.exists(compiledResourcePath), \"%s does not exists after aapt2 ran.\", compiledResourcePath);\n            return compiledResourcePath;\n        }\n\n        @Override\n        public String toString() {\n            return \"ResourceCompiler.CompileTask(\" + file + \")\";\n        }\n    }\n\n    private static class CompilingVisitor extends SimpleFileVisitor<Path> {\n\n        private final ListeningExecutorService executorService;\n\n        private final Path compiledResources;\n\n        private final List<ListenableFuture<Path>> tasks = new ArrayList<>();\n\n        private final Path aapt2;\n\n        private final Revision buildToolsVersion;\n\n        public CompilingVisitor(ListeningExecutorService executorService, Path compiledResources, Path aapt2, Revision buildToolsVersion) {\n            this.executorService = executorService;\n            this.compiledResources = compiledResources;\n            this.aapt2 = aapt2;\n            this.buildToolsVersion = buildToolsVersion;\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            // Ignore directories and \"hidden\" files that start with .\n            if (!Files.isDirectory(file) && !file.getFileName().toString().startsWith(\".\")) {\n                tasks.add(executorService.submit(new // compiledResources path.\n                // compiledResources path.\n                CompileTask(file, Files.createDirectories(compiledResources.resolve((file.isAbsolute() ? file.getRoot().relativize(file) : file).getParent().getParent())), aapt2, buildToolsVersion)));\n            }\n            return super.visitFile(file, attrs);\n        }\n\n        List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n            return Futures.allAsList(tasks).get();\n        }\n    }\n\n    /**\n     * Creates a new {@link ResourceCompiler}.\n     */\n    public static ResourceCompiler create(ListeningExecutorService executorService, Path compiledResources, Path aapt2, Revision buildToolsVersion) {\n        return new ResourceCompiler(new CompilingVisitor(executorService, compiledResources, aapt2, buildToolsVersion));\n    }\n\n    private ResourceCompiler(CompilingVisitor compilingVisitor) {\n        this.compilingVisitor = compilingVisitor;\n    }\n\n    /**\n     * Adds a task to compile the directory using aapt2.\n     */\n    public void queueDirectoryForCompilation(Path resource) throws IOException {\n        Files.walkFileTree(resource, compilingVisitor);\n    }\n\n    /**\n     * Returns all paths of the aapt2 compiled resources.\n     */\n    public List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n        return compilingVisitor.getCompiledArtifacts();\n    }\n}\n", "class_id": 0, "repo": "ixuexi/bazel", "file": "src/tools/android/java/com/google/devtools/build/android/aapt2/ResourceCompiler.java", "last_update_at": "2021-03-03T07:32:13+00:00", "original_content": "public class ResourceCompiler {\n\n    private static final Logger logger = Logger.getLogger(ResourceCompiler.class.getName());\n\n    private final CompilingVisitor compilingVisitor;\n\n    private static class CompileTask implements Callable<Path> {\n\n        private final Path file;\n\n        private final Path compiledResourcesOut;\n\n        private final Path aapt2;\n\n        private final Revision buildToolsVersion;\n\n        public CompileTask(Path file, Path compiledResourcesOut, Path aapt2, Revision buildToolsVersion) {\n            this.file = file;\n            this.compiledResourcesOut = compiledResourcesOut;\n            this.aapt2 = aapt2;\n            this.buildToolsVersion = buildToolsVersion;\n        }\n\n        @Override\n        public Path call() throws Exception {\n            logger.fine(new AaptCommandBuilder(aapt2).forBuildToolsVersion(buildToolsVersion).forVariantType(VariantType.LIBRARY).add(\"compile\").add(\"-v\").add(\"--legacy\").add(\"-o\", compiledResourcesOut.toString()).add(file.toString()).execute(\"Compiling \" + file));\n            String type = file.getParent().getFileName().toString();\n            String filename = file.getFileName().toString();\n            if (type.startsWith(\"values\")) {\n                filename = (filename.indexOf('.') != -1 ? filename.substring(0, filename.indexOf('.')) : filename) + \".arsc\";\n            }\n            final Path compiledResourcePath = compiledResourcesOut.resolve(type + \"_\" + filename + \".flat\");\n            Preconditions.checkArgument(Files.exists(compiledResourcePath), \"%s does not exists after aapt2 ran.\", compiledResourcePath);\n            return compiledResourcePath;\n        }\n\n        @Override\n        public String toString() {\n            return \"ResourceCompiler.CompileTask(\" + file + \")\";\n        }\n    }\n\n    private static class CompilingVisitor extends SimpleFileVisitor<Path> {\n\n        private final ListeningExecutorService executorService;\n\n        private final Path compiledResources;\n\n        private final List<ListenableFuture<Path>> tasks = new ArrayList<>();\n\n        private final Path aapt2;\n\n        private final Revision buildToolsVersion;\n\n        public CompilingVisitor(ListeningExecutorService executorService, Path compiledResources, Path aapt2, Revision buildToolsVersion) {\n            this.executorService = executorService;\n            this.compiledResources = compiledResources;\n            this.aapt2 = aapt2;\n            this.buildToolsVersion = buildToolsVersion;\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            // Ignore directories and \"hidden\" files that start with .\n            if (!Files.isDirectory(file) && !file.getFileName().toString().startsWith(\".\")) {\n                tasks.add(executorService.submit(new CompileTask(file, // compiledResources path.\n                Files.createDirectories(compiledResources.resolve((file.isAbsolute() ? file.getRoot().relativize(file) : file).getParent().getParent())), aapt2, buildToolsVersion)));\n            }\n            return super.visitFile(file, attrs);\n        }\n\n        List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n            return Futures.allAsList(tasks).get();\n        }\n    }\n\n    /**\n     * Creates a new {@link ResourceCompiler}.\n     */\n    public static ResourceCompiler create(ListeningExecutorService executorService, Path compiledResources, Path aapt2, Revision buildToolsVersion) {\n        return new ResourceCompiler(new CompilingVisitor(executorService, compiledResources, aapt2, buildToolsVersion));\n    }\n\n    private ResourceCompiler(CompilingVisitor compilingVisitor) {\n        this.compilingVisitor = compilingVisitor;\n    }\n\n    /**\n     * Adds a task to compile the directory using aapt2.\n     */\n    public void queueDirectoryForCompilation(Path resource) throws IOException {\n        Files.walkFileTree(resource, compilingVisitor);\n    }\n\n    /**\n     * Returns all paths of the aapt2 compiled resources.\n     */\n    public List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {\n        return compilingVisitor.getCompiledArtifacts();\n    }\n}\n", "refactored": false}
{"hexsha": "a8ba7f5b0c8ef7e57b8db2d114463f4396c0eae6", "ext": "java", "lang": "Java", "content": "public class HomeControllerTest extends WithApplication {\n\n    private HomeController homeController;\n\n    @Before\n    public void provideHomeController() {\n        this.homeController = new HomeController(Mockito.mock(AssetsFinder.class));\n    }\n\n    @Test\n    public void testIndex() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.index(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testHighscore() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.highscore(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testProfile() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.profile(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testMenu() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.menu(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testPizzaRush() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.pizzaRush(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testMemory() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.memory(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n}\n", "class_id": 0, "repo": "Pixelhuber/Pizza_Ragazzi", "file": "test/ControllerTests/HomeControllerTest.java", "last_update_at": "2021-09-11T12:22:26+00:00", "original_content": "public class HomeControllerTest extends WithApplication {\n\n    private HomeController homeController;\n\n    @Before\n    public void provideHomeController() {\n        this.homeController = new HomeController(Mockito.mock(AssetsFinder.class));\n    }\n\n    @Test\n    public void testIndex() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.index(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testHighscore() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.highscore(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testProfile() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.profile(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testMenu() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.menu(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testPizzaRush() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.pizzaRush(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n\n    @Test\n    public void testMemory() {\n        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session(\"email\", \"test\");\n        Result result = homeController.memory(requestBuilder.build());\n        assertEquals(OK, result.status());\n        assertEquals(\"text/html\", result.contentType().get());\n    }\n}\n", "refactored": false}
{"hexsha": "9359f69e953ce02cd6b1b8e24ffc79b7e97c5c89", "ext": "java", "lang": "Java", "content": "public class Slag extends Item {\n\n    private static final IDispenseItemBehavior SLAG_DISPENSER_BEHAVIOR = new OptionalDispenseBehavior() {\n\n        @Override\n        protected ItemStack execute(IBlockSource source, ItemStack stack) {\n            World world = source.getLevel();\n            BlockPos blockpos = source.getPos().relative(source.getBlockState().getValue(DispenserBlock.FACING));\n            //We currently use the deprecated method because this is what vanilla dispensers currently use\n            if (BoneMealItem.growCrop(stack, world, blockpos)) {\n                if (!world.isClientSide) {\n                    world.levelEvent(2005, blockpos, 0);\n                }\n                //Success\n                setSuccess(true);\n            } else {\n                //Fail\n                setSuccess(false);\n            }\n            return stack;\n        }\n    };\n\n    protected Slag() {\n        super(new Properties().tab(CRItems.TAB_CROSSROADS));\n        String name = \"slag\";\n        setRegistryName(name);\n        CRItems.toRegister.add(this);\n        DispenserBlock.registerBehavior(this, SLAG_DISPENSER_BEHAVIOR);\n    }\n\n    @Override\n    public ActionResultType useOn(ItemUseContext context) {\n        if (BoneMealItem.applyBonemeal(context.getItemInHand(), context.getLevel(), context.getClickedPos(), context.getPlayer())) {\n            if (!context.getLevel().isClientSide) {\n                context.getLevel().levelEvent(2005, context.getClickedPos(), 0);\n            }\n            return ActionResultType.SUCCESS;\n        }\n        return ActionResultType.FAIL;\n    }\n}\n", "class_id": 0, "repo": "EminentMass/Crossroads", "file": "src/main/java/com/Da_Technomancer/crossroads/items/Slag.java", "last_update_at": "2021-09-21T03:04:45+00:00", "original_content": "public class Slag extends Item {\n\n    private static final IDispenseItemBehavior SLAG_DISPENSER_BEHAVIOR = new OptionalDispenseBehavior() {\n\n        @Override\n        protected ItemStack execute(IBlockSource source, ItemStack stack) {\n            World world = source.getLevel();\n            BlockPos blockpos = source.getPos().relative(source.getBlockState().getValue(DispenserBlock.FACING));\n            //We currently use the deprecated method because this is what vanilla dispensers currently use\n            if (BoneMealItem.growCrop(stack, world, blockpos)) {\n                if (!world.isClientSide) {\n                    world.levelEvent(2005, blockpos, 0);\n                }\n                //Success\n                setSuccess(true);\n            } else {\n                //Fail\n                setSuccess(false);\n            }\n            return stack;\n        }\n    };\n\n    protected Slag() {\n        super(new Properties().tab(CRItems.TAB_CROSSROADS));\n        String name = \"slag\";\n        setRegistryName(name);\n        CRItems.toRegister.add(this);\n        DispenserBlock.registerBehavior(this, SLAG_DISPENSER_BEHAVIOR);\n    }\n\n    @Override\n    public ActionResultType useOn(ItemUseContext context) {\n        if (BoneMealItem.applyBonemeal(context.getItemInHand(), context.getLevel(), context.getClickedPos(), context.getPlayer())) {\n            if (!context.getLevel().isClientSide) {\n                context.getLevel().levelEvent(2005, context.getClickedPos(), 0);\n            }\n            return ActionResultType.SUCCESS;\n        }\n        return ActionResultType.FAIL;\n    }\n}\n", "refactored": false}
{"hexsha": "df86a5988dc4ae6c04ca10898aecb3dc91b26047", "ext": "java", "lang": "Java", "content": "@Mixin(ContainerRepair.class)\npublic abstract class ContainerRepairMixin extends Container {\n\n    @Shadow\n    public int maximumCost;\n\n    @Shadow\n    @Final\n    private IInventory inputSlots;\n\n    @Shadow\n    @Final\n    private IInventory outputSlot;\n\n    @Shadow\n    public int materialCost;\n\n    @Shadow\n    private String repairedItemName;\n\n    @Shadow\n    @Final\n    private EntityPlayer player;\n\n    /**\n     * @author Enaium\n     */\n    @Overwrite\n    public void updateRepairOutput() {\n        ItemStack itemstack = this.inputSlots.getStackInSlot(0);\n        this.maximumCost = 1;\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        if (itemstack.isEmpty()) {\n            this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n            this.maximumCost = 0;\n        } else {\n            ItemStack itemstack1 = itemstack.copy();\n            ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);\n            Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);\n            j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());\n            this.materialCost = 0;\n            boolean flag = false;\n            int k2;\n            if (!itemstack2.isEmpty()) {\n                if (!onAnvilChange(itemstack, itemstack2, this.outputSlot, this.repairedItemName, j)) {\n                    return;\n                }\n                flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();\n                int i1;\n                int j1;\n                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {\n                    k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    if (k2 <= 0) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n                    for (i1 = 0; k2 > 0 && i1 < itemstack2.getCount(); ++i1) {\n                        j1 = itemstack1.getItemDamage() - k2;\n                        itemstack1.setItemDamage(j1);\n                        ++i;\n                        k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    }\n                    this.materialCost = i1;\n                } else {\n                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable())) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n                    if (itemstack1.isItemStackDamageable() && !flag) {\n                        k2 = itemstack.getMaxDamage() - itemstack.getItemDamage();\n                        i1 = itemstack2.getMaxDamage() - itemstack2.getItemDamage();\n                        j1 = i1 + itemstack1.getMaxDamage() * 12 / 100;\n                        int k1 = k2 + j1;\n                        int l1 = itemstack1.getMaxDamage() - k1;\n                        if (l1 < 0) {\n                            l1 = 0;\n                        }\n                        if (l1 < itemstack1.getItemDamage()) {\n                            itemstack1.setItemDamage(l1);\n                            i += 2;\n                        }\n                    }\n                    Map<Enchantment, Integer> map1 = EnchantmentHelper.getEnchantments(itemstack2);\n                    boolean flag2 = false;\n                    boolean flag3 = false;\n                    Iterator var23 = map1.keySet().iterator();\n                    label177: for (; true; ) {\n                        Enchantment enchantment1;\n                        for (; ; ) try {\n                            if (!var23.hasNext()) {\n                                if (flag3 && !flag2) {\n                                    this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                                    this.maximumCost = 0;\n                                    return;\n                                }\n                                break label177;\n                            }\n                            enchantment1 = (Enchantment) var23.next();\n                        } finally {\n                            if (!enchantment1 == null) {\n                                break;\n                            }\n                        }\n                        int i2 = map.containsKey(enchantment1) ? (Integer) map.get(enchantment1) : 0;\n                        int j2 = (Integer) map1.get(enchantment1);\n                        j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);\n                        boolean flag1 = enchantment1.canApply(itemstack);\n                        if (this.player.capabilities.isCreativeMode || itemstack.getItem() == Items.ENCHANTED_BOOK) {\n                            flag1 = true;\n                        }\n                        Iterator var17 = map.keySet().iterator();\n                        for (; var17.hasNext(); ) {\n                            Enchantment enchantment = (Enchantment) var17.next();\n                            if (enchantment != enchantment1 && !isCompatibleWith(enchantment, enchantment1)) {\n                                flag1 = false;\n                                ++i;\n                            }\n                        }\n                        if (!flag1) {\n                            flag3 = true;\n                        } else {\n                            flag2 = true;\n                            if (j2 > enchantment1.getMaxLevel()) {\n                                j2 = enchantment1.getMaxLevel();\n                            }\n                            map.put(enchantment1, j2);\n                            int k3 = 0;\n                            switch(enchantment1.getRarity()) {\n                                case COMMON:\n                                    k3 = 1;\n                                    break;\n                                case UNCOMMON:\n                                    k3 = 2;\n                                    break;\n                                case RARE:\n                                    k3 = 4;\n                                    break;\n                                case VERY_RARE:\n                                    k3 = 8;\n                            }\n                            if (flag) {\n                                k3 = Math.max(1, k3 / 2);\n                            }\n                            i += k3 * j2;\n                            if (itemstack.getCount() > 1) {\n                                i = 40;\n                            }\n                        }\n                    }\n                }\n            }\n            if (StringUtils.isBlank(this.repairedItemName)) {\n                if (itemstack.hasDisplayName()) {\n                    k = 1;\n                    i += k;\n                    itemstack1.clearCustomName();\n                }\n            } else if (!this.repairedItemName.equals(itemstack.getDisplayName())) {\n                k = 1;\n                i += k;\n                itemstack1.setStackDisplayName(this.repairedItemName);\n            }\n            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n            this.maximumCost = j + i;\n            if (i <= 0) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n            if (k == i && k > 0 && this.maximumCost >= 40) {\n                this.maximumCost = 39;\n            }\n            if (this.maximumCost >= 40 && !this.player.capabilities.isCreativeMode) {\n                this.maximumCost = 39;\n            }\n            if (!itemstack1.isEmpty()) {\n                k2 = itemstack1.getRepairCost();\n                if (!itemstack2.isEmpty() && k2 < itemstack2.getRepairCost()) {\n                    k2 = itemstack2.getRepairCost();\n                }\n                if (k != i || k == 0) {\n                    k2 = k2 * 2 + 1;\n                }\n                itemstack1.setRepairCost(k2);\n                EnchantmentHelper.setEnchantments(map, itemstack1);\n            }\n            this.outputSlot.setInventorySlotContents(0, itemstack1);\n            this.detectAndSendChanges();\n        }\n    }\n\n    private boolean onAnvilChange(ItemStack left, ItemStack right, IInventory outputSlot, String name, int baseCost) {\n        AnvilUpdateEvent e = new AnvilUpdateEvent(left, right, name, baseCost);\n        if (MinecraftForge.EVENT_BUS.post(e)) {\n            return false;\n        } else if (e.getOutput().isEmpty()) {\n            return true;\n        } else {\n            outputSlot.setInventorySlotContents(0, e.getOutput());\n            this.maximumCost = e.getCost();\n            this.materialCost = e.getMaterialCost();\n            return false;\n        }\n    }\n\n    private boolean isCompatibleWith(Enchantment enchantment1, Enchantment enchantment2) {\n        if ((enchantment1 instanceof EnchantmentArrowInfinite && enchantment2 instanceof EnchantmentMending) || (enchantment2 instanceof EnchantmentArrowInfinite && enchantment1 instanceof EnchantmentMending)) {\n            return true;\n        }\n        return enchantment1.isCompatibleWith(enchantment2);\n    }\n}\n", "class_id": 0, "repo": "Enaium-ForgeMC/NoExpensive", "file": "src/main/java/cn/enaium/noexpensive/injection/mixins/ContainerRepairMixin.java", "last_update_at": "2021-07-30T23:44:06+00:00", "original_content": "@Mixin(ContainerRepair.class)\npublic abstract class ContainerRepairMixin extends Container {\n\n    @Shadow\n    public int maximumCost;\n\n    @Shadow\n    @Final\n    private IInventory inputSlots;\n\n    @Shadow\n    @Final\n    private IInventory outputSlot;\n\n    @Shadow\n    public int materialCost;\n\n    @Shadow\n    private String repairedItemName;\n\n    @Shadow\n    @Final\n    private EntityPlayer player;\n\n    /**\n     * @author Enaium\n     */\n    @Overwrite\n    public void updateRepairOutput() {\n        ItemStack itemstack = this.inputSlots.getStackInSlot(0);\n        this.maximumCost = 1;\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        if (itemstack.isEmpty()) {\n            this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n            this.maximumCost = 0;\n        } else {\n            ItemStack itemstack1 = itemstack.copy();\n            ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);\n            Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);\n            j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());\n            this.materialCost = 0;\n            boolean flag = false;\n            int k2;\n            if (!itemstack2.isEmpty()) {\n                if (!onAnvilChange(itemstack, itemstack2, this.outputSlot, this.repairedItemName, j)) {\n                    return;\n                }\n                flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();\n                int i1;\n                int j1;\n                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {\n                    k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    if (k2 <= 0) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n                    for (i1 = 0; k2 > 0 && i1 < itemstack2.getCount(); ++i1) {\n                        j1 = itemstack1.getItemDamage() - k2;\n                        itemstack1.setItemDamage(j1);\n                        ++i;\n                        k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);\n                    }\n                    this.materialCost = i1;\n                } else {\n                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable())) {\n                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                        this.maximumCost = 0;\n                        return;\n                    }\n                    if (itemstack1.isItemStackDamageable() && !flag) {\n                        k2 = itemstack.getMaxDamage() - itemstack.getItemDamage();\n                        i1 = itemstack2.getMaxDamage() - itemstack2.getItemDamage();\n                        j1 = i1 + itemstack1.getMaxDamage() * 12 / 100;\n                        int k1 = k2 + j1;\n                        int l1 = itemstack1.getMaxDamage() - k1;\n                        if (l1 < 0) {\n                            l1 = 0;\n                        }\n                        if (l1 < itemstack1.getItemDamage()) {\n                            itemstack1.setItemDamage(l1);\n                            i += 2;\n                        }\n                    }\n                    Map<Enchantment, Integer> map1 = EnchantmentHelper.getEnchantments(itemstack2);\n                    boolean flag2 = false;\n                    boolean flag3 = false;\n                    Iterator var23 = map1.keySet().iterator();\n                    label177: while (true) {\n                        Enchantment enchantment1;\n                        do {\n                            if (!var23.hasNext()) {\n                                if (flag3 && !flag2) {\n                                    this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);\n                                    this.maximumCost = 0;\n                                    return;\n                                }\n                                break label177;\n                            }\n                            enchantment1 = (Enchantment) var23.next();\n                        } while (enchantment1 == null);\n                        int i2 = map.containsKey(enchantment1) ? (Integer) map.get(enchantment1) : 0;\n                        int j2 = (Integer) map1.get(enchantment1);\n                        j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);\n                        boolean flag1 = enchantment1.canApply(itemstack);\n                        if (this.player.capabilities.isCreativeMode || itemstack.getItem() == Items.ENCHANTED_BOOK) {\n                            flag1 = true;\n                        }\n                        Iterator var17 = map.keySet().iterator();\n                        while (var17.hasNext()) {\n                            Enchantment enchantment = (Enchantment) var17.next();\n                            if (enchantment != enchantment1 && !isCompatibleWith(enchantment, enchantment1)) {\n                                flag1 = false;\n                                ++i;\n                            }\n                        }\n                        if (!flag1) {\n                            flag3 = true;\n                        } else {\n                            flag2 = true;\n                            if (j2 > enchantment1.getMaxLevel()) {\n                                j2 = enchantment1.getMaxLevel();\n                            }\n                            map.put(enchantment1, j2);\n                            int k3 = 0;\n                            switch(enchantment1.getRarity()) {\n                                case COMMON:\n                                    k3 = 1;\n                                    break;\n                                case UNCOMMON:\n                                    k3 = 2;\n                                    break;\n                                case RARE:\n                                    k3 = 4;\n                                    break;\n                                case VERY_RARE:\n                                    k3 = 8;\n                            }\n                            if (flag) {\n                                k3 = Math.max(1, k3 / 2);\n                            }\n                            i += k3 * j2;\n                            if (itemstack.getCount() > 1) {\n                                i = 40;\n                            }\n                        }\n                    }\n                }\n            }\n            if (StringUtils.isBlank(this.repairedItemName)) {\n                if (itemstack.hasDisplayName()) {\n                    k = 1;\n                    i += k;\n                    itemstack1.clearCustomName();\n                }\n            } else if (!this.repairedItemName.equals(itemstack.getDisplayName())) {\n                k = 1;\n                i += k;\n                itemstack1.setStackDisplayName(this.repairedItemName);\n            }\n            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n            this.maximumCost = j + i;\n            if (i <= 0) {\n                itemstack1 = ItemStack.EMPTY;\n            }\n            if (k == i && k > 0 && this.maximumCost >= 40) {\n                this.maximumCost = 39;\n            }\n            if (this.maximumCost >= 40 && !this.player.capabilities.isCreativeMode) {\n                this.maximumCost = 39;\n            }\n            if (!itemstack1.isEmpty()) {\n                k2 = itemstack1.getRepairCost();\n                if (!itemstack2.isEmpty() && k2 < itemstack2.getRepairCost()) {\n                    k2 = itemstack2.getRepairCost();\n                }\n                if (k != i || k == 0) {\n                    k2 = k2 * 2 + 1;\n                }\n                itemstack1.setRepairCost(k2);\n                EnchantmentHelper.setEnchantments(map, itemstack1);\n            }\n            this.outputSlot.setInventorySlotContents(0, itemstack1);\n            this.detectAndSendChanges();\n        }\n    }\n\n    private boolean onAnvilChange(ItemStack left, ItemStack right, IInventory outputSlot, String name, int baseCost) {\n        AnvilUpdateEvent e = new AnvilUpdateEvent(left, right, name, baseCost);\n        if (MinecraftForge.EVENT_BUS.post(e)) {\n            return false;\n        } else if (e.getOutput().isEmpty()) {\n            return true;\n        } else {\n            outputSlot.setInventorySlotContents(0, e.getOutput());\n            this.maximumCost = e.getCost();\n            this.materialCost = e.getMaterialCost();\n            return false;\n        }\n    }\n\n    private boolean isCompatibleWith(Enchantment enchantment1, Enchantment enchantment2) {\n        if ((enchantment1 instanceof EnchantmentArrowInfinite && enchantment2 instanceof EnchantmentMending) || (enchantment2 instanceof EnchantmentArrowInfinite && enchantment1 instanceof EnchantmentMending)) {\n            return true;\n        }\n        return enchantment1.isCompatibleWith(enchantment2);\n    }\n}\n", "refactored": true}
{"hexsha": "1734f11ef39ffc15b610a3bd91177494d7572518", "ext": "java", "lang": "Java", "content": "public class DocumentIdNode extends DOMFragmentReader<DocumentId> {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DocumentIdNode.class);\n\n    private static final XPath PATXP = DocumentHelper.createXPath(\"/DOCUMENT/PATN\");\n\n    private static final XPath NUMXP = DocumentHelper.createXPath(\"WKU\");\n\n    private static final XPath ISSUEDATEXP = DocumentHelper.createXPath(\"ISD\");\n\n    private static final CountryCode DEFAULT_COUNTRYCODE = CountryCode.US;\n\n    private CountryCode fallbackCountryCode;\n\n    public DocumentIdNode(Document document) {\n        this(document, DEFAULT_COUNTRYCODE);\n    }\n\n    public DocumentIdNode(Document document, CountryCode fallbackCountryCode) {\n        super(document);\n        this.fallbackCountryCode = fallbackCountryCode;\n    }\n\n    @Override\n    public DocumentId read() {\n        Node parentNode = PATXP.selectSingleNode(document);\n        Node docNumN = NUMXP.selectSingleNode(parentNode);\n        if (docNumN == null) {\n            LOGGER.warn(\"Invalid document-id, field 'WKU' not found: {}\", document.asXML());\n            return null;\n        }\n        String patNum = docNumN.getText().substring(1, 8);\n        DocumentId documentId = new DocumentId(fallbackCountryCode, patNum);\n        Node dateN = ISSUEDATEXP.selectSingleNode(parentNode);\n        if (dateN != null) {\n            String dateTxt = dateN.getText();\n            try {\n                documentId.setDate(new DocumentDate(dateTxt));\n            } catch (InvalidDataException e) {\n                LOGGER.warn(\"{} : {}\", e.getMessage(), dateN.getParent().asXML());\n            }\n        }\n        return documentId;\n    }\n}\n", "class_id": 0, "repo": "cambialens/PatentPublicData", "file": "PatentDocument/src/main/java/gov/uspto/patent/doc/greenbook/fragments/DocumentIdNode.java", "last_update_at": "2021-08-11T19:14:13+00:00", "original_content": "public class DocumentIdNode extends DOMFragmentReader<DocumentId> {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DocumentIdNode.class);\n\n    private static final XPath PATXP = DocumentHelper.createXPath(\"/DOCUMENT/PATN\");\n\n    private static final XPath NUMXP = DocumentHelper.createXPath(\"WKU\");\n\n    private static final XPath ISSUEDATEXP = DocumentHelper.createXPath(\"ISD\");\n\n    private static final CountryCode DEFAULT_COUNTRYCODE = CountryCode.US;\n\n    private CountryCode fallbackCountryCode;\n\n    public DocumentIdNode(Document document) {\n        this(document, DEFAULT_COUNTRYCODE);\n    }\n\n    public DocumentIdNode(Document document, CountryCode fallbackCountryCode) {\n        super(document);\n        this.fallbackCountryCode = fallbackCountryCode;\n    }\n\n    @Override\n    public DocumentId read() {\n        Node parentNode = PATXP.selectSingleNode(document);\n        Node docNumN = NUMXP.selectSingleNode(parentNode);\n        if (docNumN == null) {\n            LOGGER.warn(\"Invalid document-id, field 'WKU' not found: {}\", document.asXML());\n            return null;\n        }\n        String patNum = docNumN.getText().substring(1, 8);\n        DocumentId documentId = new DocumentId(fallbackCountryCode, patNum);\n        Node dateN = ISSUEDATEXP.selectSingleNode(parentNode);\n        if (dateN != null) {\n            String dateTxt = dateN.getText();\n            try {\n                documentId.setDate(new DocumentDate(dateTxt));\n            } catch (InvalidDataException e) {\n                LOGGER.warn(\"{} : {}\", e.getMessage(), dateN.getParent().asXML());\n            }\n        }\n        return documentId;\n    }\n}\n", "refactored": false}
{"hexsha": "013ae4b5c9166755961902e1d4e8a6e2bb028d77", "ext": "java", "lang": "Java", "content": "@Test(singleThreaded = true)\npublic class TestClusterManager {\n\n    private Log log = LogFactory.getLog(TestClusterManager.class);\n\n    @Test\n    public /*\n   * Tests that the worker nodes returned are correctly handled by PrestoClusterManager and sorted list of hosts is returned\n   */\n    void testGetNodes() throws IOException {\n        HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new NoFailedNode());\n        log.info(\"STARTED SERVER\");\n        ClusterManager clusterManager = getPrestoClusterManager();\n        List<String> nodes = clusterManager.getNodes();\n        log.info(\"Got nodes: \" + nodes);\n        assertTrue(nodes.size() == 2, \"Should only have two nodes\");\n        assertTrue(nodes.get(0).equals(\"192.168.1.3\") && nodes.get(1).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n        server.stop(0);\n    }\n\n    @Test\n    public /*\n   * Tests that in a single node cluster, master node is returned as worker\n   */\n    void testMasterOnlyCluster() throws IOException {\n        HttpServer server = createServer(\"/v1/node\", new NoWorker(), \"/v1/node/failed\", new NoFailedNode());\n        log.info(\"STARTED SERVER\");\n        ClusterManager clusterManager = getPrestoClusterManager();\n        List<String> nodes = clusterManager.getNodes();\n        log.info(\"Got nodes: \" + nodes);\n        assertTrue(nodes.size() == 1, \"Should have added localhost in list\");\n        assertTrue(nodes.get(0).equals(InetAddress.getLocalHost().getHostAddress()), \"Not added right hostname\");\n        server.stop(0);\n    }\n\n    @Test\n    public /*\n   * Tests that in a cluster with failed node, failed node is not returned\n   */\n    void testFailedNodeCluster() throws IOException {\n        HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new OneFailedNode());\n        log.info(\"STARTED SERVER\");\n        ClusterManager clusterManager = getPrestoClusterManager();\n        List<String> nodes = clusterManager.getNodes();\n        log.info(\"Got nodes: \" + nodes);\n        assertTrue(nodes.size() == 1, \"Should only have two nodes\");\n        assertTrue(nodes.get(0).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n        server.stop(0);\n    }\n\n    private HttpServer createServer(String endpoint1, HttpHandler handler1, String endpoint2, HttpHandler handler2) throws IOException {\n        HttpServer server = HttpServer.create(new InetSocketAddress(45326), 0);\n        server.createContext(endpoint1, handler1);\n        server.createContext(endpoint2, handler2);\n        // creates a default executor\n        server.setExecutor(null);\n        server.start();\n        return server;\n    }\n\n    private ClusterManager getPrestoClusterManager() throws UnknownHostException {\n        ClusterManager clusterManager = new PrestoClusterManager();\n        Configuration conf = new Configuration();\n        conf.setInt(PrestoClusterManager.serverPortConf, 45326);\n        clusterManager.initialize(conf);\n        return clusterManager;\n    }\n\n    class MultipleWorkers implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[{\\\"uri\\\":\\\"http://192.168.2.252:8083\\\",\\\"recentRequests\\\":119.0027780896941,\\\"recentFailures\\\":119.00267353393015,\\\"recentSuccesses\\\":1.0845754237194612E-4,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"recentFailureRatio\\\":0.999999121400646,\\\"age\\\":\\\"6.68h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":2.4567611856996272E-6,\\\"java.net.SocketTimeoutException\\\":119.00237271323728,\\\"java.net.SocketException\\\":2.98363931759331E-4}},{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n\n    class NoWorker implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n\n    class NoFailedNode implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n\n    class OneFailedNode implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n}\n", "class_id": 0, "repo": "starburstdata/rubix", "file": "rubix-prestosql/src/test/java/com/qubole/rubix/prestosql/TestClusterManager.java", "last_update_at": "2021-07-12T16:14:14+00:00", "original_content": "@Test(singleThreaded = true)\npublic class TestClusterManager {\n\n    private Log log = LogFactory.getLog(TestClusterManager.class);\n\n    @Test\n    public /*\n   * Tests that the worker nodes returned are correctly handled by PrestoClusterManager and sorted list of hosts is returned\n   */\n    void testGetNodes() throws IOException {\n        HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new NoFailedNode());\n        log.info(\"STARTED SERVER\");\n        ClusterManager clusterManager = getPrestoClusterManager();\n        List<String> nodes = clusterManager.getNodes();\n        log.info(\"Got nodes: \" + nodes);\n        assertTrue(nodes.size() == 2, \"Should only have two nodes\");\n        assertTrue(nodes.get(0).equals(\"192.168.1.3\") && nodes.get(1).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n        server.stop(0);\n    }\n\n    @Test\n    public /*\n   * Tests that in a single node cluster, master node is returned as worker\n   */\n    void testMasterOnlyCluster() throws IOException {\n        HttpServer server = createServer(\"/v1/node\", new NoWorker(), \"/v1/node/failed\", new NoFailedNode());\n        log.info(\"STARTED SERVER\");\n        ClusterManager clusterManager = getPrestoClusterManager();\n        List<String> nodes = clusterManager.getNodes();\n        log.info(\"Got nodes: \" + nodes);\n        assertTrue(nodes.size() == 1, \"Should have added localhost in list\");\n        assertTrue(nodes.get(0).equals(InetAddress.getLocalHost().getHostAddress()), \"Not added right hostname\");\n        server.stop(0);\n    }\n\n    @Test\n    public /*\n   * Tests that in a cluster with failed node, failed node is not returned\n   */\n    void testFailedNodeCluster() throws IOException {\n        HttpServer server = createServer(\"/v1/node\", new MultipleWorkers(), \"/v1/node/failed\", new OneFailedNode());\n        log.info(\"STARTED SERVER\");\n        ClusterManager clusterManager = getPrestoClusterManager();\n        List<String> nodes = clusterManager.getNodes();\n        log.info(\"Got nodes: \" + nodes);\n        assertTrue(nodes.size() == 1, \"Should only have two nodes\");\n        assertTrue(nodes.get(0).equals(\"192.168.2.252\"), \"Wrong nodes data\");\n        server.stop(0);\n    }\n\n    private HttpServer createServer(String endpoint1, HttpHandler handler1, String endpoint2, HttpHandler handler2) throws IOException {\n        HttpServer server = HttpServer.create(new InetSocketAddress(45326), 0);\n        server.createContext(endpoint1, handler1);\n        server.createContext(endpoint2, handler2);\n        // creates a default executor\n        server.setExecutor(null);\n        server.start();\n        return server;\n    }\n\n    private ClusterManager getPrestoClusterManager() throws UnknownHostException {\n        ClusterManager clusterManager = new PrestoClusterManager();\n        Configuration conf = new Configuration();\n        conf.setInt(PrestoClusterManager.serverPortConf, 45326);\n        clusterManager.initialize(conf);\n        return clusterManager;\n    }\n\n    class MultipleWorkers implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[{\\\"uri\\\":\\\"http://192.168.2.252:8083\\\",\\\"recentRequests\\\":119.0027780896941,\\\"recentFailures\\\":119.00267353393015,\\\"recentSuccesses\\\":1.0845754237194612E-4,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.948Z\\\",\\\"recentFailureRatio\\\":0.999999121400646,\\\"age\\\":\\\"6.68h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":2.4567611856996272E-6,\\\"java.net.SocketTimeoutException\\\":119.00237271323728,\\\"java.net.SocketException\\\":2.98363931759331E-4}},{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n\n    class NoWorker implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n\n    class NoFailedNode implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n\n    class OneFailedNode implements HttpHandler {\n\n        public void handle(HttpExchange exchange) throws IOException {\n            String nodes = \"[{\\\"uri\\\":\\\"http://192.168.1.3:8082\\\",\\\"recentRequests\\\":119.00277802527565,\\\"recentFailures\\\":119.00282273097419,\\\"recentSuccesses\\\":0.0,\\\"lastRequestTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"lastResponseTime\\\":\\\"2016-01-14T13:26:29.701Z\\\",\\\"recentFailureRatio\\\":1.0000003756693692,\\\"age\\\":\\\"21.81h\\\",\\\"recentFailuresByType\\\":{\\\"java.util.concurrent.TimeoutException\\\":0.0,\\\"java.net.SocketTimeoutException\\\":119.00258110193407,\\\"java.net.ConnectException\\\":0.0,\\\"java.net.SocketException\\\":2.416290401318479E-4,\\\"java.net.NoRouteToHostException\\\":1.3332509542453224E-21}}]\\n\";\n            exchange.getResponseHeaders().add(\"Content-Type\", \"application/json\");\n            exchange.sendResponseHeaders(200, nodes.length());\n            OutputStream os = exchange.getResponseBody();\n            os.write(nodes.getBytes());\n            os.close();\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "ad60ecfd5bb8c4cfd813c68c144210185e671f15", "ext": "java", "lang": "Java", "content": "@Slf4j\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Override\n    public void registerEmail(String subject, String content, String[] toUserEmailArray) {\n        //??????\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        // use the true flag to indicate you need a multipart message\n        MimeMessageHelper mimeMessageHelper;\n        try {\n            mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);\n            mimeMessageHelper.setSubject(subject);\n            //??????\n            mimeMessageHelper.setFrom(mailProperties.getUsername());\n            //????????\n            mimeMessageHelper.setTo(toUserEmailArray);\n            //??????\n            mimeMessageHelper.setText(content, true);\n            //??????\n            ClassPathResource classPathResource = new ClassPathResource(\"/static/images/share-public.png\");\n            //???? ??ID\n            mimeMessageHelper.addInline(\"logoImage\", classPathResource);\n            //??????\n            FileSystemResource fileSystemResource = new FileSystemResource(new File(\"C:\\\\Users\\\\xingyun\\\\Pictures\\\\program.jpg\"));\n            //????\n            mimeMessageHelper.addAttachment(\"program.jpg\", fileSystemResource);\n            //????\n            javaMailSender.send(mimeMessage);\n        } catch (MessagingException e) {\n            log.error(\"Messaging Exception:\", e);\n        }\n    }\n}\n", "class_id": 0, "repo": "geekxingyun/spring-boot-best-practices-sample", "file": "spring-boot-with-java-mail-sender-sample/src/main/java/com/xingyun/springbootwithjavamailsendersample/service/UserServiceImpl.java", "last_update_at": "2021-09-24T04:54:02+00:00", "original_content": "@Slf4j\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Override\n    public void registerEmail(String subject, String content, String[] toUserEmailArray) {\n        //??????\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        // use the true flag to indicate you need a multipart message\n        MimeMessageHelper mimeMessageHelper;\n        try {\n            mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);\n            mimeMessageHelper.setSubject(subject);\n            //??????\n            mimeMessageHelper.setFrom(mailProperties.getUsername());\n            //????????\n            mimeMessageHelper.setTo(toUserEmailArray);\n            //??????\n            mimeMessageHelper.setText(content, true);\n            //??????\n            ClassPathResource classPathResource = new ClassPathResource(\"/static/images/share-public.png\");\n            //???? ??ID\n            mimeMessageHelper.addInline(\"logoImage\", classPathResource);\n            //??????\n            FileSystemResource fileSystemResource = new FileSystemResource(new File(\"C:\\\\Users\\\\xingyun\\\\Pictures\\\\program.jpg\"));\n            //????\n            mimeMessageHelper.addAttachment(\"program.jpg\", fileSystemResource);\n            //????\n            javaMailSender.send(mimeMessage);\n        } catch (MessagingException e) {\n            log.error(\"Messaging Exception:\", e);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "d9151f6e311531a33967c956253a7916f0cc14ba", "ext": "java", "lang": "Java", "content": "public class CondensedViterbiIntersectionAutomaton<LeftState, RightState> extends GenericCondensedIntersectionAutomaton<LeftState, RightState> {\n\n    ///< Maps a state from this automaton to a probability\n    private final Int2DoubleMap viterbiStateMap;\n\n    ///< Maps a state to its best rule\n    private final Int2ObjectMap<Rule> viterbiRuleMap;\n\n    public CondensedViterbiIntersectionAutomaton(TreeAutomaton<LeftState> left, CondensedTreeAutomaton<RightState> right, SignatureMapper sigMapper) {\n        super(left, right, sigMapper);\n        viterbiStateMap = new ArrayInt2DoubleMap();\n        // if a state is not in this map, return 0\n        viterbiStateMap.defaultReturnValue(0.0);\n        viterbiRuleMap = new ArrayMap<>();\n    }\n\n    @Override\n    protected // to enter only the best rules.\n    void collectOutputRule(Rule outputRule) {\n        int newState = outputRule.getParent();\n        int[] children = outputRule.getChildren();\n        double childWeight = outputRule.getWeight();\n        int i = 0;\n        while (i < children.length) try {\n            childWeight *= viterbiStateMap.get(children[i]);\n        } finally {\n            i++;\n        }\n        if (viterbiStateMap.get(newState) < childWeight) {\n            // current rule is new, or better than old rule\n            viterbiRuleMap.put(newState, outputRule);\n            viterbiStateMap.put(newState, childWeight);\n        }\n    }\n\n    @Override\n    protected void addAllOutputRules() {\n        viterbiRuleMap.values().forEach(this::storeRuleBoth);\n    }\n\n    public static void main(String[] args) throws Exception {\n        GenericCondensedIntersectionAutomaton.main(args, false, (left, right) -> left.intersectViterbi(right));\n    }\n}\n", "class_id": 0, "repo": "akoehn/alto", "file": "src/main/java/de/up/ling/irtg/automata/condensed/CondensedViterbiIntersectionAutomaton.java", "last_update_at": "2021-09-03T14:34:06+00:00", "original_content": "public class CondensedViterbiIntersectionAutomaton<LeftState, RightState> extends GenericCondensedIntersectionAutomaton<LeftState, RightState> {\n\n    ///< Maps a state from this automaton to a probability\n    private final Int2DoubleMap viterbiStateMap;\n\n    ///< Maps a state to its best rule\n    private final Int2ObjectMap<Rule> viterbiRuleMap;\n\n    public CondensedViterbiIntersectionAutomaton(TreeAutomaton<LeftState> left, CondensedTreeAutomaton<RightState> right, SignatureMapper sigMapper) {\n        super(left, right, sigMapper);\n        viterbiStateMap = new ArrayInt2DoubleMap();\n        // if a state is not in this map, return 0\n        viterbiStateMap.defaultReturnValue(0.0);\n        viterbiRuleMap = new ArrayMap<>();\n    }\n\n    @Override\n    protected // to enter only the best rules.\n    void collectOutputRule(Rule outputRule) {\n        int newState = outputRule.getParent();\n        int[] children = outputRule.getChildren();\n        double childWeight = outputRule.getWeight();\n        // multiply the weight of all childs of the rule\n        for (int i = 0; i < children.length; i++) {\n            childWeight *= viterbiStateMap.get(children[i]);\n        }\n        if (viterbiStateMap.get(newState) < childWeight) {\n            // current rule is new, or better than old rule\n            viterbiRuleMap.put(newState, outputRule);\n            viterbiStateMap.put(newState, childWeight);\n        }\n    }\n\n    @Override\n    protected void addAllOutputRules() {\n        viterbiRuleMap.values().forEach(this::storeRuleBoth);\n    }\n\n    public static void main(String[] args) throws Exception {\n        GenericCondensedIntersectionAutomaton.main(args, false, (left, right) -> left.intersectViterbi(right));\n    }\n}\n", "refactored": true}
{"hexsha": "0db6462f307cd534cb695bcb86ae0f3fbd5626e1", "ext": "java", "lang": "Java", "content": "public class BlazeLimbEntity extends Entity {\n\n    public static final Identifier SPAWN_PACKET = FrostburnOrigins.id(\"blaze_limb\");\n\n    public BlazeLimbEntity(EntityType<? extends BlazeLimbEntity> entityType, World world) {\n        super(entityType, world);\n    }\n\n    public BlazeLimbEntity(World world, double x, double y, double z, int id, UUID uuid) {\n        this(FrostburnOrigins.BLAZE_LIMB, world);\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n        setEntityId(id);\n        setUuid(uuid);\n    }\n\n    private UUID ownerUuid = null;\n\n    public void setOwnerUuid(UUID uuid) {\n        ownerUuid = uuid;\n    }\n\n    public UUID getOwnerUuid() {\n        return ownerUuid;\n    }\n\n    @Override\n    protected void initDataTracker() {\n    }\n\n    @Override\n    public void tick() {\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n    }\n\n    @Override\n    protected void readCustomDataFromTag(CompoundTag tag) {\n    }\n\n    @Override\n    protected void writeCustomDataToTag(CompoundTag tag) {\n    }\n\n    @Override\n    public Packet<?> createSpawnPacket() {\n        PacketByteBuf packet = new PacketByteBuf(Unpooled.buffer());\n        // entity position\n        packet.writeDouble(getX());\n        packet.writeDouble(getY());\n        packet.writeDouble(getZ());\n        // entity id & uuid\n        packet.writeInt(getEntityId());\n        packet.writeUuid(getUuid());\n        return ServerSidePacketRegistry.INSTANCE.toPacket(SPAWN_PACKET, packet);\n    }\n}\n", "class_id": 0, "repo": "TheMisteryMan/frostburn-origins", "file": "src/main/java/misteryman/frostburnorigins/entity/BlazeLimbEntity.java", "last_update_at": "2021-01-03T07:29:14+00:00", "original_content": "public class BlazeLimbEntity extends Entity {\n\n    public static final Identifier SPAWN_PACKET = FrostburnOrigins.id(\"blaze_limb\");\n\n    public BlazeLimbEntity(EntityType<? extends BlazeLimbEntity> entityType, World world) {\n        super(entityType, world);\n    }\n\n    public BlazeLimbEntity(World world, double x, double y, double z, int id, UUID uuid) {\n        this(FrostburnOrigins.BLAZE_LIMB, world);\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n        setEntityId(id);\n        setUuid(uuid);\n    }\n\n    private UUID ownerUuid = null;\n\n    public void setOwnerUuid(UUID uuid) {\n        ownerUuid = uuid;\n    }\n\n    public UUID getOwnerUuid() {\n        return ownerUuid;\n    }\n\n    @Override\n    protected void initDataTracker() {\n    }\n\n    @Override\n    public void tick() {\n        this.updatePosition(x, y, z);\n        this.setVelocity(Vec3d.ZERO);\n        this.prevX = x;\n        this.prevY = y;\n        this.prevZ = z;\n        updateTrackedPosition(x, y, z);\n    }\n\n    @Override\n    protected void readCustomDataFromTag(CompoundTag tag) {\n    }\n\n    @Override\n    protected void writeCustomDataToTag(CompoundTag tag) {\n    }\n\n    @Override\n    public Packet<?> createSpawnPacket() {\n        PacketByteBuf packet = new PacketByteBuf(Unpooled.buffer());\n        // entity position\n        packet.writeDouble(getX());\n        packet.writeDouble(getY());\n        packet.writeDouble(getZ());\n        // entity id & uuid\n        packet.writeInt(getEntityId());\n        packet.writeUuid(getUuid());\n        return ServerSidePacketRegistry.INSTANCE.toPacket(SPAWN_PACKET, packet);\n    }\n}\n", "refactored": false}
{"hexsha": "36387dd02e802b9e3c3f2cd575b8ec1e1c862fe8", "ext": "java", "lang": "Java", "content": "public class ReorderNoCross {\n\n    private final ArrayList<String> joinSchema;\n\n    private final ArrayList<String> lastJoinVars;\n\n    private BasicPattern inputPattern;\n\n    private final BasicPattern outputPattern;\n\n    public ReorderNoCross() {\n        joinSchema = new ArrayList<String>();\n        lastJoinVars = new ArrayList<String>();\n        outputPattern = new BasicPattern();\n    }\n\n    public BasicPattern reorder(BasicPattern pattern) {\n        inputPattern = pattern;\n        List<Triple> triples = inputPattern.getList();\n        int idx = chooseFirst();\n        Triple triple = triples.get(idx);\n        outputPattern.add(triple);\n        joinSchema.addAll(getVarsOfTriple(triple));\n        triples.remove(idx);\n        for (; !triples.isEmpty(); ) {\n            idx = chooseNext();\n            triple = triples.get(idx);\n            outputPattern.add(triple);\n            joinSchema.addAll(getVarsOfTriple(triple));\n            triples.remove(idx);\n        }\n        return outputPattern;\n    }\n\n    private int chooseNext() {\n        ArrayList<String> tripleVars;\n        ArrayList<String> sharedVars;\n        for (int i = 0; i < inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (lastJoinVars.size() > 0 && lastJoinVars.size() == sharedVars.size() && lastJoinVars.containsAll(sharedVars)) {\n                // lastJoinVars remain unchanged\n                return i;\n            }\n        }\n        for (int i = 0; i < inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (sharedVars.size() > 0) {\n                lastJoinVars.clear();\n                lastJoinVars.addAll(sharedVars);\n                return i;\n            }\n        }\n        lastJoinVars.clear();\n        return 0;\n    }\n\n    private int chooseFirst() {\n        for (int i = 0; i < inputPattern.size(); i++) {\n            if (hasSharedVars(i)) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    private boolean hasSharedVars(int triplePos) {\n        Triple triple = inputPattern.get(triplePos);\n        ArrayList<String> tripleVars = getVarsOfTriple(triple);\n        for (int i = 0; i < inputPattern.size(); i++) {\n            if (i != triplePos && getSharedVars(getVarsOfTriple(inputPattern.get(i)), tripleVars).size() > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private ArrayList<String> getVarsOfTriple(Triple t) {\n        ArrayList<String> vars = new ArrayList<String>();\n        Node subject = t.getSubject();\n        Node predicate = t.getPredicate();\n        Node object = t.getObject();\n        if (subject.isVariable())\n            vars.add(subject.getName());\n        if (predicate.isVariable())\n            vars.add(predicate.getName());\n        if (object.isVariable())\n            vars.add(object.getName());\n        return vars;\n    }\n\n    private ArrayList<String> getSharedVars(ArrayList<String> leftSchema, ArrayList<String> rightSchema) {\n        ArrayList<String> sharedVars = new ArrayList<String>();\n        for (int i = 0; i < rightSchema.size(); i++) {\n            if (leftSchema.contains(rightSchema.get(i)))\n                sharedVars.add(rightSchema.get(i));\n        }\n        return sharedVars;\n    }\n}\n", "class_id": 0, "repo": "h4ck3rm1k3/S2RDF", "file": "QueryTranslator/S2RDF_QueryTranslator/src/queryTranslator/sparql/ReorderNoCross.java", "last_update_at": "2021-03-21T06:05:15+00:00", "original_content": "public class ReorderNoCross {\n\n    private final ArrayList<String> joinSchema;\n\n    private final ArrayList<String> lastJoinVars;\n\n    private BasicPattern inputPattern;\n\n    private final BasicPattern outputPattern;\n\n    public ReorderNoCross() {\n        joinSchema = new ArrayList<String>();\n        lastJoinVars = new ArrayList<String>();\n        outputPattern = new BasicPattern();\n    }\n\n    public BasicPattern reorder(BasicPattern pattern) {\n        inputPattern = pattern;\n        List<Triple> triples = inputPattern.getList();\n        int idx = chooseFirst();\n        Triple triple = triples.get(idx);\n        outputPattern.add(triple);\n        joinSchema.addAll(getVarsOfTriple(triple));\n        triples.remove(idx);\n        while (!triples.isEmpty()) {\n            idx = chooseNext();\n            triple = triples.get(idx);\n            outputPattern.add(triple);\n            joinSchema.addAll(getVarsOfTriple(triple));\n            triples.remove(idx);\n        }\n        return outputPattern;\n    }\n\n    private int chooseNext() {\n        ArrayList<String> tripleVars;\n        ArrayList<String> sharedVars;\n        for (int i = 0; i < inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (lastJoinVars.size() > 0 && lastJoinVars.size() == sharedVars.size() && lastJoinVars.containsAll(sharedVars)) {\n                // lastJoinVars remain unchanged\n                return i;\n            }\n        }\n        for (int i = 0; i < inputPattern.size(); i++) {\n            tripleVars = getVarsOfTriple(inputPattern.get(i));\n            sharedVars = getSharedVars(joinSchema, tripleVars);\n            if (sharedVars.size() > 0) {\n                lastJoinVars.clear();\n                lastJoinVars.addAll(sharedVars);\n                return i;\n            }\n        }\n        lastJoinVars.clear();\n        return 0;\n    }\n\n    private int chooseFirst() {\n        for (int i = 0; i < inputPattern.size(); i++) {\n            if (hasSharedVars(i)) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    private boolean hasSharedVars(int triplePos) {\n        Triple triple = inputPattern.get(triplePos);\n        ArrayList<String> tripleVars = getVarsOfTriple(triple);\n        for (int i = 0; i < inputPattern.size(); i++) {\n            if (i != triplePos && getSharedVars(getVarsOfTriple(inputPattern.get(i)), tripleVars).size() > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private ArrayList<String> getVarsOfTriple(Triple t) {\n        ArrayList<String> vars = new ArrayList<String>();\n        Node subject = t.getSubject();\n        Node predicate = t.getPredicate();\n        Node object = t.getObject();\n        if (subject.isVariable())\n            vars.add(subject.getName());\n        if (predicate.isVariable())\n            vars.add(predicate.getName());\n        if (object.isVariable())\n            vars.add(object.getName());\n        return vars;\n    }\n\n    private ArrayList<String> getSharedVars(ArrayList<String> leftSchema, ArrayList<String> rightSchema) {\n        ArrayList<String> sharedVars = new ArrayList<String>();\n        for (int i = 0; i < rightSchema.size(); i++) {\n            if (leftSchema.contains(rightSchema.get(i)))\n                sharedVars.add(rightSchema.get(i));\n        }\n        return sharedVars;\n    }\n}\n", "refactored": true}
{"hexsha": "ba78fcab5c3ff1462db195ba869fb513fc0c22b3", "ext": "java", "lang": "Java", "content": "@RunWith(FeaturesRunner.class)\n@Features({ CoreFeature.class })\n@Deploy(\"org.nuxeo.ecm.automation.core\")\npublic class GetLastDocumentVersionTest {\n\n    @Inject\n    CoreSession session;\n\n    @Inject\n    AutomationService service;\n\n    protected DocumentModel folder;\n\n    protected DocumentModel section;\n\n    protected DocumentModel doc;\n\n    @Before\n    public void initRepo() throws Exception {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n        folder = session.createDocumentModel(\"/\", \"Folder\", \"Folder\");\n        folder.setPropertyValue(\"dc:title\", \"Folder\");\n        folder = session.createDocument(folder);\n        session.save();\n        folder = session.getDocument(folder.getRef());\n    }\n\n    @After\n    public void cleanRepo() {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n    }\n\n    protected DocumentModel createDocumentVersions(DocumentModel doc, VersioningOption vo, int nrVersions) {\n        int i = 1;\n        while (i <= nrVersions) try {\n            // make sure the version doesn't have the same \"created\" as the previous one\n            try {\n                // NOSONAR\n                Thread.sleep(2);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n            doc.setPropertyValue(\"dc:description\", String.valueOf(i));\n            doc.putContextData(VersioningService.VERSIONING_OPTION, vo);\n            doc = session.saveDocument(doc);\n        } finally {\n            i++;\n        }\n        session.save();\n        return doc;\n    }\n\n    @Test\n    public void testGetLastMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.0\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testGetLastMinorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"0.3\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testGetLastMinorMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.3\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testNonexistentLastVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithNoVersion\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithNoVersion\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        DocumentModel lastVersion = runOperation(doc);\n        assertNull(lastVersion);\n    }\n\n    /**\n     * Runs the operation for the different document models of the test.\n     */\n    protected DocumentModel runOperation(DocumentModel input) throws OperationException {\n        try (OperationContext ctx = new OperationContext(session)) {\n            ctx.setInput(input);\n            OperationChain chain = new OperationChain(\"testGetLastVersion\");\n            chain.add(GetLastDocumentVersion.ID);\n            return (DocumentModel) service.run(ctx, chain);\n        }\n    }\n}\n", "class_id": 0, "repo": "aTiKhan/nuxeo", "file": "modules/platform/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/GetLastDocumentVersionTest.java", "last_update_at": "2021-02-15T19:07:59+00:00", "original_content": "@RunWith(FeaturesRunner.class)\n@Features({ CoreFeature.class })\n@Deploy(\"org.nuxeo.ecm.automation.core\")\npublic class GetLastDocumentVersionTest {\n\n    @Inject\n    CoreSession session;\n\n    @Inject\n    AutomationService service;\n\n    protected DocumentModel folder;\n\n    protected DocumentModel section;\n\n    protected DocumentModel doc;\n\n    @Before\n    public void initRepo() throws Exception {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n        folder = session.createDocumentModel(\"/\", \"Folder\", \"Folder\");\n        folder.setPropertyValue(\"dc:title\", \"Folder\");\n        folder = session.createDocument(folder);\n        session.save();\n        folder = session.getDocument(folder.getRef());\n    }\n\n    @After\n    public void cleanRepo() {\n        session.removeChildren(session.getRootDocument().getRef());\n        session.save();\n    }\n\n    protected DocumentModel createDocumentVersions(DocumentModel doc, VersioningOption vo, int nrVersions) {\n        for (int i = 1; i <= nrVersions; i++) {\n            // make sure the version doesn't have the same \"created\" as the previous one\n            try {\n                // NOSONAR\n                Thread.sleep(2);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n            doc.setPropertyValue(\"dc:description\", String.valueOf(i));\n            doc.putContextData(VersioningService.VERSIONING_OPTION, vo);\n            doc = session.saveDocument(doc);\n        }\n        session.save();\n        return doc;\n    }\n\n    @Test\n    public void testGetLastMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.0\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testGetLastMinorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"0.3\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testGetLastMinorMajorVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithMajorMinorVersions\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithMajorMinorVersions\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);\n        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);\n        DocumentModel lastVersion = runOperation(doc);\n        assertNotNull(lastVersion);\n        assertEquals(\"3\", lastVersion.getPropertyValue(\"dc:description\"));\n        assertEquals(\"3.3\", lastVersion.getVersionLabel());\n    }\n\n    @Test\n    public void testNonexistentLastVersion() throws OperationException {\n        doc = session.createDocumentModel(\"/Folder\", \"DocWithNoVersion\", \"File\");\n        doc.setPropertyValue(\"dc:title\", \"DocWithNoVersion\");\n        doc = session.createDocument(doc);\n        session.save();\n        doc = session.getDocument(doc.getRef());\n        DocumentModel lastVersion = runOperation(doc);\n        assertNull(lastVersion);\n    }\n\n    /**\n     * Runs the operation for the different document models of the test.\n     */\n    protected DocumentModel runOperation(DocumentModel input) throws OperationException {\n        try (OperationContext ctx = new OperationContext(session)) {\n            ctx.setInput(input);\n            OperationChain chain = new OperationChain(\"testGetLastVersion\");\n            chain.add(GetLastDocumentVersion.ID);\n            return (DocumentModel) service.run(ctx, chain);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "cd0f2db9b8d8fdb1a2153a795392c8830796df8a", "ext": "java", "lang": "Java", "content": "public class UserStory9 {\n\n    private String taskId;\n\n    private String title;\n\n    private String firstUpdate;\n\n    private String secondUpdate;\n\n    @When(\"I adjust the priority of a task to a new priority\")\n    public void i_adjust_the_priority_of_a_task_to_a_new_priority() {\n        taskId = \"1\";\n        title = \"scan paperwork\";\n        firstUpdate = \"HIGH\";\n        secondUpdate = \"LOW\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I can view the task and its updated priority\")\n    public void i_can_view_the_task_and_its_updated_priority() {\n        taskId = \"1\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int code = conn.getResponseCode();\n            assertEquals(code, 200);\n            String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            for (; scanner.hasNext(); ) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n        } catch (Exception e) {\n        }\n    }\n\n    @When(\"I adjust the priority of a task to the same priority\")\n    public void i_adjust_the_priority_of_a_task_to_the_same_priority() {\n        taskId = \"1\";\n        title = \"scan paperwork\";\n        firstUpdate = \"MEDIUM\";\n        secondUpdate = \"MEDIUM\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I can view the task and its unchanged priority\")\n    public void i_can_view_the_task_and_its_unchanged_priority() {\n        taskId = \"1\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int code = conn.getResponseCode();\n            assertEquals(code, 200);\n            String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            for (; scanner.hasNext(); ) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n        } catch (Exception e) {\n        }\n    }\n\n    @When(\"I adjust the priority of a non-existent task\")\n    public void i_adjust_the_priority_of_a_non_existent_task() {\n        taskId = \"92\";\n        title = \"scan paperwork\";\n        firstUpdate = \"MEDIUM\";\n        secondUpdate = \"MEDIUM\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 404);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I get a Not Found error\")\n    public void i_get_a_not_found_error() {\n        taskId = \"92\";\n        title = \"scan paperwork\";\n        firstUpdate = \"MEDIUM\";\n        secondUpdate = \"MEDIUM\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 404);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @When(\"I adjust the priority of a {string} {string} to {string}\")\n    public void i_adjust_the_priority_of_a_to(String taskId, String title, String priority) {\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + priority + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I can view the {string} {string} and its updated {string}\")\n    public void i_can_view_the_and_its_updated(String taskId, String title, String priority) {\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int code = conn.getResponseCode();\n            assertEquals(code, 200);\n            String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            for (; scanner.hasNext(); ) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n        } catch (Exception e) {\n        }\n    }\n}\n", "class_id": 0, "repo": "marw12/ECSE429_project_part2", "file": "src/test/java/hellocucumber/UserStory9.java", "last_update_at": "2021-04-25T15:06:15+00:00", "original_content": "public class UserStory9 {\n\n    private String taskId;\n\n    private String title;\n\n    private String firstUpdate;\n\n    private String secondUpdate;\n\n    @When(\"I adjust the priority of a task to a new priority\")\n    public void i_adjust_the_priority_of_a_task_to_a_new_priority() {\n        taskId = \"1\";\n        title = \"scan paperwork\";\n        firstUpdate = \"HIGH\";\n        secondUpdate = \"LOW\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I can view the task and its updated priority\")\n    public void i_can_view_the_task_and_its_updated_priority() {\n        taskId = \"1\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int code = conn.getResponseCode();\n            assertEquals(code, 200);\n            String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n        } catch (Exception e) {\n        }\n    }\n\n    @When(\"I adjust the priority of a task to the same priority\")\n    public void i_adjust_the_priority_of_a_task_to_the_same_priority() {\n        taskId = \"1\";\n        title = \"scan paperwork\";\n        firstUpdate = \"MEDIUM\";\n        secondUpdate = \"MEDIUM\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + secondUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I can view the task and its unchanged priority\")\n    public void i_can_view_the_task_and_its_unchanged_priority() {\n        taskId = \"1\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int code = conn.getResponseCode();\n            assertEquals(code, 200);\n            String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n        } catch (Exception e) {\n        }\n    }\n\n    @When(\"I adjust the priority of a non-existent task\")\n    public void i_adjust_the_priority_of_a_non_existent_task() {\n        taskId = \"92\";\n        title = \"scan paperwork\";\n        firstUpdate = \"MEDIUM\";\n        secondUpdate = \"MEDIUM\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 404);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I get a Not Found error\")\n    public void i_get_a_not_found_error() {\n        taskId = \"92\";\n        title = \"scan paperwork\";\n        firstUpdate = \"MEDIUM\";\n        secondUpdate = \"MEDIUM\";\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + firstUpdate + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 404);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @When(\"I adjust the priority of a {string} {string} to {string}\")\n    public void i_adjust_the_priority_of_a_to(String taskId, String title, String priority) {\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setDoOutput(true);\n            String jsonInputString = \" {\\\"title\\\":\\\"\" + title + \"\\\", \\\"description\\\":\" + priority + \"}\";\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int code = con.getResponseCode();\n            assertEquals(code, 200);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Then(\"I can view the {string} {string} and its updated {string}\")\n    public void i_can_view_the_and_its_updated(String taskId, String title, String priority) {\n        try {\n            String request = \"http://localhost:4567/todos/\" + taskId;\n            URL url = new URL(request);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.connect();\n            int code = conn.getResponseCode();\n            assertEquals(code, 200);\n            String inline = \"\";\n            Scanner scanner = new Scanner(url.openStream());\n            //Write all the JSON data into a string using a scanner\n            while (scanner.hasNext()) {\n                inline += scanner.nextLine();\n            }\n            System.out.println(inline);\n            //Close the scanner\n            scanner.close();\n        } catch (Exception e) {\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "641033c0fb496a6d65e54ca86c4dc0ddb60735ec", "ext": "java", "lang": "Java", "content": "public class MovieListerTest {\n\n    // mocks in unit test. In a unit test, the target type must be tested in isolation.\n    @Test\n    public void moviesDirectedByShouldReturnTheMoviesOfAGivenDirector() {\n        final MovieFinder finder = Mockito.mock(MovieFinder.class);\n        BDDMockito.given(finder.findAll()).willReturn(Collections.emptyList());\n        final MovieLister lister = new MovieLister(finder);\n        final List<Movie> movies = lister.moviesDirectedBy(\"rcardin\");\n        Assertions.assertThat(movies).isEqualTo(Collections.emptyList());\n    }\n}\n", "class_id": 0, "repo": "rcardin/swe", "file": "src/test/java/it/unipd/math/swe/patterns/di/MovieListerTest.java", "last_update_at": "2021-12-21T18:55:39+00:00", "original_content": "public class MovieListerTest {\n\n    // mocks in unit test. In a unit test, the target type must be tested in isolation.\n    @Test\n    public void moviesDirectedByShouldReturnTheMoviesOfAGivenDirector() {\n        final MovieFinder finder = Mockito.mock(MovieFinder.class);\n        BDDMockito.given(finder.findAll()).willReturn(Collections.emptyList());\n        final MovieLister lister = new MovieLister(finder);\n        final List<Movie> movies = lister.moviesDirectedBy(\"rcardin\");\n        Assertions.assertThat(movies).isEqualTo(Collections.emptyList());\n    }\n}\n", "refactored": false}
{"hexsha": "46ddefab41709a6be84d5741ef31973bc48ae11a", "ext": "java", "lang": "Java", "content": "public class MinimumSwaps {\n\n    // Complete the minimumSwaps function below.\n    static int minimumSwaps(int[] arr) {\n        int swaps = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            for (; arr[i] != i + 1; ) {\n                int tmp = arr[arr[i] - 1];\n                arr[arr[i] - 1] = arr[i];\n                arr[i] = tmp;\n                swaps++;\n            }\n        }\n        return swaps;\n    }\n\n    public static void main(String[] args) throws IOException {\n        int[] arr = { 1, 2, 4, 3 };\n        int res = minimumSwaps(arr);\n        System.out.println(\"Minimum Number of Swaps is: \" + res);\n    }\n}\n", "class_id": 0, "repo": "javigs82/code-training", "file": "src/main/java/me/javigs82/training/datastructure/arrays/MinimumSwaps.java", "last_update_at": "2021-12-14T09:25:35+00:00", "original_content": "public class MinimumSwaps {\n\n    // Complete the minimumSwaps function below.\n    static int minimumSwaps(int[] arr) {\n        int swaps = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            while (arr[i] != i + 1) {\n                int tmp = arr[arr[i] - 1];\n                arr[arr[i] - 1] = arr[i];\n                arr[i] = tmp;\n                swaps++;\n            }\n        }\n        return swaps;\n    }\n\n    public static void main(String[] args) throws IOException {\n        int[] arr = { 1, 2, 4, 3 };\n        int res = minimumSwaps(arr);\n        System.out.println(\"Minimum Number of Swaps is: \" + res);\n    }\n}\n", "refactored": true}
{"hexsha": "221d19854b3387b4e611c94a1b3119ad951a1176", "ext": "java", "lang": "Java", "content": "public final class zzz implements ObjectEncoder<zzn> {\n\n    public void encode(Object obj, Object obj2) throws EncodingException, IOException {\n        zzn zzn = (zzn) obj;\n        ObjectEncoderContext objectEncoderContext = (ObjectEncoderContext) obj2;\n        if (zzn.zzb() != null) {\n            objectEncoderContext.add(\"mobileSubtype\", (Object) zzn.zzb().name());\n        }\n        if (zzn.zzc() != null) {\n            objectEncoderContext.add(\"networkType\", (Object) zzn.zzc().name());\n        }\n    }\n}\n", "class_id": 0, "repo": "Minionguyjpro/Ghostly-Skills", "file": "sources/com/google/android/datatransport/cct/a/zzz.java", "last_update_at": "2021-11-03T14:24:37+00:00", "original_content": "public final class zzz implements ObjectEncoder<zzn> {\n\n    public void encode(Object obj, Object obj2) throws EncodingException, IOException {\n        zzn zzn = (zzn) obj;\n        ObjectEncoderContext objectEncoderContext = (ObjectEncoderContext) obj2;\n        if (zzn.zzb() != null) {\n            objectEncoderContext.add(\"mobileSubtype\", (Object) zzn.zzb().name());\n        }\n        if (zzn.zzc() != null) {\n            objectEncoderContext.add(\"networkType\", (Object) zzn.zzc().name());\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "8cf6191413c62269aaba8dbcb415341dd329a51a", "ext": "java", "lang": "Java", "content": "public class UploadServlet extends HttpServlet {\n\n    private static final Logger LOG = LogManager.getLogger(UploadServlet.class);\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        List<String> images = Optional.ofNullable(new File(getServletContext().getRealPath(\"/images/\")).listFiles()).map(files -> Arrays.stream(files).map(File::getName).collect(Collectors.toList())).orElse(Collections.emptyList());\n        req.setAttribute(\"images\", images);\n        RequestDispatcher dispatcher = req.getRequestDispatcher(\"/upload-file-view.jsp\");\n        dispatcher.forward(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        File repository = (File) servletContext.getAttribute(\"javax.servlet.context.tempdir\");\n        fileItemFactory.setRepository(repository);\n        ServletFileUpload upload = new ServletFileUpload(fileItemFactory);\n        try {\n            List<FileItem> items = upload.parseRequest(req);\n            File folder = new File(getServletContext().getRealPath(\"/images/\"));\n            if (!folder.exists()) {\n                folder.mkdir();\n            }\n            for (FileItem item : items) {\n                if (!item.isFormField()) {\n                    File file = new File(folder + File.separator + item.getName());\n                    try (FileOutputStream out = new FileOutputStream(file)) {\n                        out.write(item.getInputStream().readAllBytes());\n                    }\n                }\n            }\n        } catch (FileUploadException e) {\n            LOG.error(e.getMessage(), e);\n        }\n    }\n}\n", "class_id": 0, "repo": "AlexandrMoralev/amoralev", "file": "chapter_008/src/main/java/ru/job4j/uploaddownloadfiles/UploadServlet.java", "last_update_at": "2021-11-03T19:51:49+00:00", "original_content": "public class UploadServlet extends HttpServlet {\n\n    private static final Logger LOG = LogManager.getLogger(UploadServlet.class);\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        List<String> images = Optional.ofNullable(new File(getServletContext().getRealPath(\"/images/\")).listFiles()).map(files -> Arrays.stream(files).map(File::getName).collect(Collectors.toList())).orElse(Collections.emptyList());\n        req.setAttribute(\"images\", images);\n        RequestDispatcher dispatcher = req.getRequestDispatcher(\"/upload-file-view.jsp\");\n        dispatcher.forward(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        File repository = (File) servletContext.getAttribute(\"javax.servlet.context.tempdir\");\n        fileItemFactory.setRepository(repository);\n        ServletFileUpload upload = new ServletFileUpload(fileItemFactory);\n        try {\n            List<FileItem> items = upload.parseRequest(req);\n            File folder = new File(getServletContext().getRealPath(\"/images/\"));\n            if (!folder.exists()) {\n                folder.mkdir();\n            }\n            for (FileItem item : items) {\n                if (!item.isFormField()) {\n                    File file = new File(folder + File.separator + item.getName());\n                    try (FileOutputStream out = new FileOutputStream(file)) {\n                        out.write(item.getInputStream().readAllBytes());\n                    }\n                }\n            }\n        } catch (FileUploadException e) {\n            LOG.error(e.getMessage(), e);\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "472700bf6fa9122b546087fd965781da595983d5", "ext": "java", "lang": "Java", "content": "@RestController\npublic class LoginController {\n\n    @Autowired\n    LoginService loginService;\n\n    @Autowired\n    StudentService studentService;\n\n    @Autowired\n    TeacherService teacherService;\n\n    @GetMapping(\"/\")\n    public ModelAndView Index() {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n\n    @GetMapping(\"/createS\")\n    public ModelAndView CreateS() {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"Student_form\");\n        return mv;\n    }\n\n    @GetMapping(\"/forgot.html\")\n    public ModelAndView forgot() {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"forgot\");\n        return mv;\n    }\n\n    @PostMapping(\"/login\")\n    public ModelAndView login(Login user, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            System.out.println(user.getEmail() + \" - \" + user.getPassword());\n            if (user.getEmail().equals(\"admin@admin.com\") && (user.getPassword().equals(\"admin\"))) {\n                mv.setViewName(\"admin\");\n                return mv;\n            }\n            long id = this.loginService.findPassword(user.getEmail(), user.getPassword());\n            int role = this.loginService.findRole(id);\n            int otl = this.loginService.findOtl(id);\n            if (role == 1) {\n                String name = this.studentService.findName(id);\n                HttpSession session = request.getSession();\n                if (otl == 1) {\n                    session.setAttribute(\"id\", id);\n                    mv.setViewName(\"NewPassword\");\n                    return mv;\n                } else {\n                    session.setAttribute(\"name\", name);\n                    mv.setViewName(\"student\");\n                    mv.addObject(\"name\", name);\n                }\n                return mv;\n            } else {\n                String name = this.teacherService.findName(id);\n                HttpSession session = request.getSession();\n                session.setAttribute(\"name\", name);\n                mv.setViewName(\"teacher\");\n                mv.addObject(\"name\", name);\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"index\");\n            return mv;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    @PostMapping(\"/forgotpassword\")\n    public ModelAndView forgotPassword(@RequestParam(\"email\") String email, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            String name;\n            System.out.println(email);\n            long id = this.loginService.findUserEmail(email);\n            Long user_id = id;\n            if (user_id != null) {\n                int role = this.loginService.findRole(id);\n                if (role == 1) {\n                    name = this.studentService.findName(id);\n                } else {\n                    name = this.teacherService.findName(id);\n                }\n                Random rnd = new Random();\n                int number = rnd.nextInt(999999);\n                String vcode = String.format(\"%06d\", number);\n                System.out.println(vcode);\n                HttpSession session = request.getSession();\n                MailSender.send(email, \"Verfication code for your password recovery\", \"Dear \" + name + \",<br>Provided below is the verification \" + \"code for recovering your password.<br><h1>\" + vcode + \"</h1><br>Enter this to set a new password.<br>Thank you.\");\n                session.setAttribute(\"id\", id);\n                session.setAttribute(\"vcode\", vcode);\n                mv.setViewName(\"recover\");\n                return mv;\n            } else {\n                mv.setViewName(\"forgot\");\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"forgot\");\n            return mv;\n        }\n    }\n\n    @PostMapping(\"/recoverpassword\")\n    public ModelAndView recoverPassword(@RequestParam(\"code\") String code, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            System.out.println(\"user entered:\" + code);\n            HttpSession session = request.getSession(false);\n            if (session != null) {\n                String vcode = (String) session.getAttribute(\"vcode\");\n                if (vcode.equals(\"\")) {\n                    mv.setViewName(\"forgot\");\n                    return mv;\n                }\n                System.out.println(\"in session:\" + vcode);\n                if (code.equals(vcode)) {\n                    session.setAttribute(\"vcode\", \"\");\n                    mv.setViewName(\"NewPassword\");\n                    return mv;\n                } else {\n                    mv.setViewName(\"recover\");\n                    return mv;\n                }\n            } else {\n                mv.setViewName(\"forgot\");\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"forgot\");\n            return mv;\n        }\n    }\n\n    @PostMapping(\"/setpassword\")\n    public ModelAndView setPassword(@RequestParam(\"newpassword\") String npassword, @RequestParam(\"confirmpassword\") String cpassword, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            HttpSession session = request.getSession(false);\n            if (npassword.equals(cpassword)) {\n                long id = (long) session.getAttribute(\"id\");\n                loginService.updatePassword(npassword, id);\n                mv.setViewName(\"index\");\n                return mv;\n            } else {\n                mv.setViewName(\"NewPassword\");\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"NewPassword\");\n            return mv;\n        }\n    }\n}\n", "class_id": 0, "repo": "kevinjuthani/school-management-system", "file": "springboot/src/main/java/com/backend/schoolManagementSystem/controller/LoginController.java", "last_update_at": "2021-05-01T05:31:55+00:00", "original_content": "@RestController\npublic class LoginController {\n\n    @Autowired\n    LoginService loginService;\n\n    @Autowired\n    StudentService studentService;\n\n    @Autowired\n    TeacherService teacherService;\n\n    @GetMapping(\"/\")\n    public ModelAndView Index() {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n\n    @GetMapping(\"/createS\")\n    public ModelAndView CreateS() {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"Student_form\");\n        return mv;\n    }\n\n    @GetMapping(\"/forgot.html\")\n    public ModelAndView forgot() {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"forgot\");\n        return mv;\n    }\n\n    @PostMapping(\"/login\")\n    public ModelAndView login(Login user, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            System.out.println(user.getEmail() + \" - \" + user.getPassword());\n            if (user.getEmail().equals(\"admin@admin.com\") && (user.getPassword().equals(\"admin\"))) {\n                mv.setViewName(\"admin\");\n                return mv;\n            }\n            long id = this.loginService.findPassword(user.getEmail(), user.getPassword());\n            int role = this.loginService.findRole(id);\n            int otl = this.loginService.findOtl(id);\n            if (role == 1) {\n                String name = this.studentService.findName(id);\n                HttpSession session = request.getSession();\n                if (otl == 1) {\n                    session.setAttribute(\"id\", id);\n                    mv.setViewName(\"NewPassword\");\n                    return mv;\n                } else {\n                    session.setAttribute(\"name\", name);\n                    mv.setViewName(\"student\");\n                    mv.addObject(\"name\", name);\n                }\n                return mv;\n            } else {\n                String name = this.teacherService.findName(id);\n                HttpSession session = request.getSession();\n                session.setAttribute(\"name\", name);\n                mv.setViewName(\"teacher\");\n                mv.addObject(\"name\", name);\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"index\");\n            return mv;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    @PostMapping(\"/forgotpassword\")\n    public ModelAndView forgotPassword(@RequestParam(\"email\") String email, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            String name;\n            System.out.println(email);\n            long id = this.loginService.findUserEmail(email);\n            Long user_id = id;\n            if (user_id != null) {\n                int role = this.loginService.findRole(id);\n                if (role == 1) {\n                    name = this.studentService.findName(id);\n                } else {\n                    name = this.teacherService.findName(id);\n                }\n                Random rnd = new Random();\n                int number = rnd.nextInt(999999);\n                String vcode = String.format(\"%06d\", number);\n                System.out.println(vcode);\n                HttpSession session = request.getSession();\n                MailSender.send(email, \"Verfication code for your password recovery\", \"Dear \" + name + \",<br>Provided below is the verification \" + \"code for recovering your password.<br><h1>\" + vcode + \"</h1><br>Enter this to set a new password.<br>Thank you.\");\n                session.setAttribute(\"id\", id);\n                session.setAttribute(\"vcode\", vcode);\n                mv.setViewName(\"recover\");\n                return mv;\n            } else {\n                mv.setViewName(\"forgot\");\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"forgot\");\n            return mv;\n        }\n    }\n\n    @PostMapping(\"/recoverpassword\")\n    public ModelAndView recoverPassword(@RequestParam(\"code\") String code, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            System.out.println(\"user entered:\" + code);\n            HttpSession session = request.getSession(false);\n            if (session != null) {\n                String vcode = (String) session.getAttribute(\"vcode\");\n                if (vcode.equals(\"\")) {\n                    mv.setViewName(\"forgot\");\n                    return mv;\n                }\n                System.out.println(\"in session:\" + vcode);\n                if (code.equals(vcode)) {\n                    session.setAttribute(\"vcode\", \"\");\n                    mv.setViewName(\"NewPassword\");\n                    return mv;\n                } else {\n                    mv.setViewName(\"recover\");\n                    return mv;\n                }\n            } else {\n                mv.setViewName(\"forgot\");\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"forgot\");\n            return mv;\n        }\n    }\n\n    @PostMapping(\"/setpassword\")\n    public ModelAndView setPassword(@RequestParam(\"newpassword\") String npassword, @RequestParam(\"confirmpassword\") String cpassword, HttpServletRequest request) {\n        ModelAndView mv = new ModelAndView();\n        try {\n            HttpSession session = request.getSession(false);\n            if (npassword.equals(cpassword)) {\n                long id = (long) session.getAttribute(\"id\");\n                loginService.updatePassword(npassword, id);\n                mv.setViewName(\"index\");\n                return mv;\n            } else {\n                mv.setViewName(\"NewPassword\");\n                return mv;\n            }\n        } catch (Exception e) {\n            mv.setViewName(\"NewPassword\");\n            return mv;\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "f4faaf5638a49c5121563ade6dd4b7fbef7d664d", "ext": "java", "lang": "Java", "content": "public class BungeeModule extends AbstractModule {\n\n    @Override\n    public void configure() {\n        bindFactory(CommandSender.class, new CommandSenderPartFactory());\n        bindFactory(ProxiedPlayer.class, new ProxiedPlayerPartFactory());\n        bindFactory(new Key(ProxiedPlayer.class, Sender.class), new ProxiedPlayerSenderPartFactory());\n    }\n}\n", "class_id": 0, "repo": "GatitoUwU/CommandFlow", "file": "Bungee/src/main/java/me/fixeddev/commandflow/bungee/factory/BungeeModule.java", "last_update_at": "2021-12-08T01:40:28+00:00", "original_content": "public class BungeeModule extends AbstractModule {\n\n    @Override\n    public void configure() {\n        bindFactory(CommandSender.class, new CommandSenderPartFactory());\n        bindFactory(ProxiedPlayer.class, new ProxiedPlayerPartFactory());\n        bindFactory(new Key(ProxiedPlayer.class, Sender.class), new ProxiedPlayerSenderPartFactory());\n    }\n}\n", "refactored": false}
{"hexsha": "9e4f9fdccbf6abd563c47d91d05b945d05d65846", "ext": "java", "lang": "Java", "content": "class Solution {\n\n    public int fib(int n) {\n        int i = 0, j = 1;\n        int ans = 1;\n        if (n <= 1)\n            return n;\n        int p = 2;\n        while (p <= n) try {\n            ans = i + j;\n            i = j;\n            j = ans;\n        } finally {\n            p++;\n        }\n        return ans;\n    }\n}\n", "class_id": 0, "repo": "itsbittoosharma/DSA-JAVA-Problem-Solutions", "file": "509-fibonacci-number/509-fibonacci-number.java", "last_update_at": "2021-09-26T13:04:08+00:00", "original_content": "class Solution {\n\n    public int fib(int n) {\n        int i = 0, j = 1;\n        int ans = 1;\n        if (n <= 1)\n            return n;\n        for (int p = 2; p <= n; p++) {\n            ans = i + j;\n            i = j;\n            j = ans;\n        }\n        return ans;\n    }\n}\n", "refactored": true}
{"hexsha": "2a215fa39841dd8a27838db5d29d1d3464dfd9fe", "ext": "java", "lang": "Java", "content": "@Component\n@CommandImpl(\"mset\")\n@ParamLength(type = AT_LEAST, value = 2)\npublic class MSet {\n\n    private final KevaDatabase database;\n\n    @Autowired\n    public MSet(KevaDatabase database) {\n        this.database = database;\n    }\n\n    @Execute\n    public StatusReply execute(byte[]... keys) {\n        if (keys.length % 2 != 0) {\n            throw new CommandException(\"Wrong number of arguments for MSET\");\n        }\n        database.mset(keys);\n        return StatusReply.OK;\n    }\n}\n", "class_id": 0, "repo": "hiepndd/keva", "file": "core/src/main/java/dev/keva/core/command/impl/string/MSet.java", "last_update_at": "2021-09-20T10:20:46+00:00", "original_content": "@Component\n@CommandImpl(\"mset\")\n@ParamLength(type = AT_LEAST, value = 2)\npublic class MSet {\n\n    private final KevaDatabase database;\n\n    @Autowired\n    public MSet(KevaDatabase database) {\n        this.database = database;\n    }\n\n    @Execute\n    public StatusReply execute(byte[]... keys) {\n        if (keys.length % 2 != 0) {\n            throw new CommandException(\"Wrong number of arguments for MSET\");\n        }\n        database.mset(keys);\n        return StatusReply.OK;\n    }\n}\n", "refactored": false}
{"hexsha": "bacc5b1878a17e567c59933789e2258b27f89430", "ext": "java", "lang": "Java", "content": "public class PublicKeyEncryptor extends AbstractEncryptor<Cipher, PublicKey, byte[]> implements ByteArrayEncryptor {\n\n    /**\n     * The Constant serialVersionUID.\n     */\n    private static final long serialVersionUID = 1L;\n\n    private CryptModel<Cipher, SecretKey, String> symmetricKeyModel;\n\n    /**\n     * Instantiates a new {@link PublicKeyEncryptor} with the given {@link CryptModel} for the\n     * public key and the given {@link CryptModel} for the symmetric key\n     *\n     * @param model\n     *            The crypt model\n     * @param symmetricKeyModel\n     *            The symmetric key model\n     *\n     * @throws InvalidAlgorithmParameterException\n     *             is thrown if initialization of the cipher object fails.\n     * @throws NoSuchPaddingException\n     *             is thrown if instantiation of the SecretKeyFactory object fails.\n     * @throws InvalidKeySpecException\n     *             is thrown if generation of the SecretKey object fails.\n     * @throws NoSuchAlgorithmException\n     *             is thrown if instantiation of the SecretKeyFactory object fails.\n     * @throws InvalidKeyException\n     *             is thrown if initialization of the cipher object fails.\n     * @throws NoSuchAlgorithmException\n     *             is thrown if instantiation of the SecretKeyFactory object fails.\n     * @throws UnsupportedEncodingException\n     *             is thrown if the named charset is not supported.\n     */\n    public PublicKeyEncryptor(final CryptModel<Cipher, PublicKey, byte[]> model, final CryptModel<Cipher, SecretKey, String> symmetricKeyModel) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException {\n        super(model);\n        Objects.requireNonNull(symmetricKeyModel);\n        this.symmetricKeyModel = symmetricKeyModel;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public byte[] encrypt(final byte[] toEncrypt) throws Exception {\n        final SecretKey symmetricKey = symmetricKeyModel.getKey();\n        Cipher symmetricKeyCipher = newSymmetricCipher(symmetricKey, symmetricKeyModel.getAlgorithm().getAlgorithm(), symmetricKeyModel.getOperationMode());\n        byte[] symmetricKeyEncryptedBytes = symmetricKeyCipher.doFinal(toEncrypt);\n        byte[] encryptedKey = getModel().getCipher().doFinal(symmetricKey.getEncoded());\n        AesRsaCryptModel cryptData = AesRsaCryptModel.builder().encryptedKey(encryptedKey).symmetricKeyEncryptedObject(symmetricKeyEncryptedBytes).build();\n        byte[] encryptedCryptData = SerializationUtils.serialize(cryptData);\n        return encryptedCryptData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected String newAlgorithm() {\n        if (getModel().getAlgorithm() == null) {\n            getModel().setAlgorithm(KeyPairWithModeAndPaddingAlgorithm.RSA_ECB_OAEPWithSHA1AndMGF1Padding);\n        }\n        return getModel().getAlgorithm().getAlgorithm();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected Cipher newCipher(final PublicKey key, final String algorithm, final byte[] salt, final int iterationCount, final int operationMode) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, UnsupportedEncodingException {\n        final Cipher cipher = CipherFactory.newCipher(algorithm);\n        cipher.init(Cipher.PUBLIC_KEY, key);\n        return cipher;\n    }\n\n    private Cipher newSymmetricCipher(final SecretKey key, final String algorithm, final int operationMode) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException {\n        final Cipher cipher = Cipher.getInstance(algorithm);\n        cipher.init(operationMode, key);\n        return cipher;\n    }\n}\n", "class_id": 0, "repo": "astrapi69/mystic-crypt", "file": "src/main/java/io/github/astrapi69/crypto/key/PublicKeyEncryptor.java", "last_update_at": "2021-12-14T15:29:07+00:00", "original_content": "public class PublicKeyEncryptor extends AbstractEncryptor<Cipher, PublicKey, byte[]> implements ByteArrayEncryptor {\n\n    /**\n     * The Constant serialVersionUID.\n     */\n    private static final long serialVersionUID = 1L;\n\n    private CryptModel<Cipher, SecretKey, String> symmetricKeyModel;\n\n    /**\n     * Instantiates a new {@link PublicKeyEncryptor} with the given {@link CryptModel} for the\n     * public key and the given {@link CryptModel} for the symmetric key\n     *\n     * @param model\n     *            The crypt model\n     * @param symmetricKeyModel\n     *            The symmetric key model\n     *\n     * @throws InvalidAlgorithmParameterException\n     *             is thrown if initialization of the cipher object fails.\n     * @throws NoSuchPaddingException\n     *             is thrown if instantiation of the SecretKeyFactory object fails.\n     * @throws InvalidKeySpecException\n     *             is thrown if generation of the SecretKey object fails.\n     * @throws NoSuchAlgorithmException\n     *             is thrown if instantiation of the SecretKeyFactory object fails.\n     * @throws InvalidKeyException\n     *             is thrown if initialization of the cipher object fails.\n     * @throws NoSuchAlgorithmException\n     *             is thrown if instantiation of the SecretKeyFactory object fails.\n     * @throws UnsupportedEncodingException\n     *             is thrown if the named charset is not supported.\n     */\n    public PublicKeyEncryptor(final CryptModel<Cipher, PublicKey, byte[]> model, final CryptModel<Cipher, SecretKey, String> symmetricKeyModel) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException {\n        super(model);\n        Objects.requireNonNull(symmetricKeyModel);\n        this.symmetricKeyModel = symmetricKeyModel;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public byte[] encrypt(final byte[] toEncrypt) throws Exception {\n        final SecretKey symmetricKey = symmetricKeyModel.getKey();\n        Cipher symmetricKeyCipher = newSymmetricCipher(symmetricKey, symmetricKeyModel.getAlgorithm().getAlgorithm(), symmetricKeyModel.getOperationMode());\n        byte[] symmetricKeyEncryptedBytes = symmetricKeyCipher.doFinal(toEncrypt);\n        byte[] encryptedKey = getModel().getCipher().doFinal(symmetricKey.getEncoded());\n        AesRsaCryptModel cryptData = AesRsaCryptModel.builder().encryptedKey(encryptedKey).symmetricKeyEncryptedObject(symmetricKeyEncryptedBytes).build();\n        byte[] encryptedCryptData = SerializationUtils.serialize(cryptData);\n        return encryptedCryptData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected String newAlgorithm() {\n        if (getModel().getAlgorithm() == null) {\n            getModel().setAlgorithm(KeyPairWithModeAndPaddingAlgorithm.RSA_ECB_OAEPWithSHA1AndMGF1Padding);\n        }\n        return getModel().getAlgorithm().getAlgorithm();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected Cipher newCipher(final PublicKey key, final String algorithm, final byte[] salt, final int iterationCount, final int operationMode) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, UnsupportedEncodingException {\n        final Cipher cipher = CipherFactory.newCipher(algorithm);\n        cipher.init(Cipher.PUBLIC_KEY, key);\n        return cipher;\n    }\n\n    private Cipher newSymmetricCipher(final SecretKey key, final String algorithm, final int operationMode) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException {\n        final Cipher cipher = Cipher.getInstance(algorithm);\n        cipher.init(operationMode, key);\n        return cipher;\n    }\n}\n", "refactored": false}
{"hexsha": "830dd582a871908ba6897692f86bcd2509046763", "ext": "java", "lang": "Java", "content": "public class ParentEntry extends ModListEntry {\n\n    private static final String PARENT_MOD_TEXTURE = \"/assets/\" + ModMenu.MOD_ID + \"/textures/gui/parent_mod.png\";\n\n    protected List<ModContainer> children;\n\n    protected ModListWidget list;\n\n    protected boolean hoveringIcon = false;\n\n    public ParentEntry(Minecraft mc, ModContainer parent, List<ModContainer> children, ModListWidget list) {\n        super(mc, parent, list);\n        this.children = children;\n        this.list = list;\n    }\n\n    @Override\n    public void render(int index, int y, int x, int rowWidth, int rowHeight, int mouseX, int mouseY, boolean isSelected, float delta) {\n        super.render(index, y, x, rowWidth, rowHeight, mouseX, mouseY, isSelected, delta);\n        TextRenderer font = client.textRenderer;\n        int childrenBadgeHeight = 9;\n        int childrenBadgeWidth = 9;\n        int children = ModListSearch.search(list.getParent(), list.getParent().getSearchInput(), getChildren()).size();\n        int childrenWidth = font.getTextWidth(Integer.toString(children)) - 1;\n        if (childrenBadgeWidth < childrenWidth + 4) {\n            childrenBadgeWidth = childrenWidth + 4;\n        }\n        int childrenBadgeX = x + 32 - childrenBadgeWidth;\n        int childrenBadgeY = y + 32 - childrenBadgeHeight;\n        int childrenOutlineColor = 0x8810d098;\n        int childrenFillColor = 0x88046146;\n        fill(childrenBadgeX + 1, childrenBadgeY, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenOutlineColor);\n        fill(childrenBadgeX, childrenBadgeY + 1, childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n        fill(childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n        fill(childrenBadgeX + 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight - 1, childrenFillColor);\n        fill(childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight, childrenOutlineColor);\n        font.drawText(Integer.toString(children), childrenBadgeX + childrenBadgeWidth / 2 - childrenWidth / 2, childrenBadgeY + 1, 0xCACACA);\n        this.hoveringIcon = mouseX >= x - 1 && mouseX <= x - 1 + 32 && mouseY >= y - 1 && mouseY <= y - 1 + 32;\n        if (isMouseOver(mouseX, mouseY)) {\n            fill(x, y, x + 32, y + 32, 0xA0909090);\n            this.client.textureManager.bindTexture(this.client.textureManager.getTextureId(PARENT_MOD_TEXTURE));\n            int xOffset = list.getParent().showModChildren.contains(getMetadata().getId()) ? 32 : 0;\n            int yOffset = hoveringIcon ? 32 : 0;\n            GL11.glColor4f(1f, 1f, 1f, 1f);\n            Tessellator tess = Tessellator.INSTANCE;\n            tess.start();\n            tess.vertex(x, y, 0, xOffset / 256f, yOffset / 256f);\n            tess.vertex(x, y + 32, 0, xOffset / 256f, (yOffset + 32) / 256f);\n            tess.vertex(x + 32, y + 32, 0, (xOffset + 32) / 256f, (yOffset + 32) / 256f);\n            tess.vertex(x + 32, y, 0, (xOffset + 32) / 256f, yOffset / 256f);\n            tess.draw();\n        }\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int i) {\n        if (hoveringIcon) {\n            String id = getMetadata().getId();\n            if (list.getParent().showModChildren.contains(id)) {\n                list.getParent().showModChildren.remove(id);\n            } else {\n                list.getParent().showModChildren.add(id);\n            }\n            list.filter(list.getParent().getSearchInput(), false);\n        }\n        return super.mouseClicked(mouseX, mouseY, i);\n    }\n\n    @Override\n    public boolean keyPressed(int int_1, int int_2, int int_3) {\n        if (int_1 == Keyboard.KEY_RETURN) {\n            String id = getMetadata().getId();\n            if (list.getParent().showModChildren.contains(id)) {\n                list.getParent().showModChildren.remove(id);\n            } else {\n                list.getParent().showModChildren.add(id);\n            }\n            list.filter(list.getParent().getSearchInput(), false);\n            return true;\n        }\n        return super.keyPressed(int_1, int_2, int_3);\n    }\n\n    public void setChildren(List<ModContainer> children) {\n        this.children = children;\n    }\n\n    public void addChildren(List<ModContainer> children) {\n        this.children.addAll(children);\n    }\n\n    public void addChildren(ModContainer... children) {\n        this.children.addAll(Arrays.asList(children));\n    }\n\n    public List<ModContainer> getChildren() {\n        return children;\n    }\n\n    public boolean isMouseOver(double double_1, double double_2) {\n        return Objects.equals(this.list.getEntryAtPos(double_1, double_2), this);\n    }\n}\n", "class_id": 0, "repo": "ChessChicken-KZ/API", "file": "essentials/modmenu/src/main/java/com/terraformersmc/modmenu/gui/entries/ParentEntry.java", "last_update_at": "2021-11-06T06:33:39+00:00", "original_content": "public class ParentEntry extends ModListEntry {\n\n    private static final String PARENT_MOD_TEXTURE = \"/assets/\" + ModMenu.MOD_ID + \"/textures/gui/parent_mod.png\";\n\n    protected List<ModContainer> children;\n\n    protected ModListWidget list;\n\n    protected boolean hoveringIcon = false;\n\n    public ParentEntry(Minecraft mc, ModContainer parent, List<ModContainer> children, ModListWidget list) {\n        super(mc, parent, list);\n        this.children = children;\n        this.list = list;\n    }\n\n    @Override\n    public void render(int index, int y, int x, int rowWidth, int rowHeight, int mouseX, int mouseY, boolean isSelected, float delta) {\n        super.render(index, y, x, rowWidth, rowHeight, mouseX, mouseY, isSelected, delta);\n        TextRenderer font = client.textRenderer;\n        int childrenBadgeHeight = 9;\n        int childrenBadgeWidth = 9;\n        int children = ModListSearch.search(list.getParent(), list.getParent().getSearchInput(), getChildren()).size();\n        int childrenWidth = font.getTextWidth(Integer.toString(children)) - 1;\n        if (childrenBadgeWidth < childrenWidth + 4) {\n            childrenBadgeWidth = childrenWidth + 4;\n        }\n        int childrenBadgeX = x + 32 - childrenBadgeWidth;\n        int childrenBadgeY = y + 32 - childrenBadgeHeight;\n        int childrenOutlineColor = 0x8810d098;\n        int childrenFillColor = 0x88046146;\n        fill(childrenBadgeX + 1, childrenBadgeY, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenOutlineColor);\n        fill(childrenBadgeX, childrenBadgeY + 1, childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n        fill(childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);\n        fill(childrenBadgeX + 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight - 1, childrenFillColor);\n        fill(childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight, childrenOutlineColor);\n        font.drawText(Integer.toString(children), childrenBadgeX + childrenBadgeWidth / 2 - childrenWidth / 2, childrenBadgeY + 1, 0xCACACA);\n        this.hoveringIcon = mouseX >= x - 1 && mouseX <= x - 1 + 32 && mouseY >= y - 1 && mouseY <= y - 1 + 32;\n        if (isMouseOver(mouseX, mouseY)) {\n            fill(x, y, x + 32, y + 32, 0xA0909090);\n            this.client.textureManager.bindTexture(this.client.textureManager.getTextureId(PARENT_MOD_TEXTURE));\n            int xOffset = list.getParent().showModChildren.contains(getMetadata().getId()) ? 32 : 0;\n            int yOffset = hoveringIcon ? 32 : 0;\n            GL11.glColor4f(1f, 1f, 1f, 1f);\n            Tessellator tess = Tessellator.INSTANCE;\n            tess.start();\n            tess.vertex(x, y, 0, xOffset / 256f, yOffset / 256f);\n            tess.vertex(x, y + 32, 0, xOffset / 256f, (yOffset + 32) / 256f);\n            tess.vertex(x + 32, y + 32, 0, (xOffset + 32) / 256f, (yOffset + 32) / 256f);\n            tess.vertex(x + 32, y, 0, (xOffset + 32) / 256f, yOffset / 256f);\n            tess.draw();\n        }\n    }\n\n    @Override\n    public boolean mouseClicked(double mouseX, double mouseY, int i) {\n        if (hoveringIcon) {\n            String id = getMetadata().getId();\n            if (list.getParent().showModChildren.contains(id)) {\n                list.getParent().showModChildren.remove(id);\n            } else {\n                list.getParent().showModChildren.add(id);\n            }\n            list.filter(list.getParent().getSearchInput(), false);\n        }\n        return super.mouseClicked(mouseX, mouseY, i);\n    }\n\n    @Override\n    public boolean keyPressed(int int_1, int int_2, int int_3) {\n        if (int_1 == Keyboard.KEY_RETURN) {\n            String id = getMetadata().getId();\n            if (list.getParent().showModChildren.contains(id)) {\n                list.getParent().showModChildren.remove(id);\n            } else {\n                list.getParent().showModChildren.add(id);\n            }\n            list.filter(list.getParent().getSearchInput(), false);\n            return true;\n        }\n        return super.keyPressed(int_1, int_2, int_3);\n    }\n\n    public void setChildren(List<ModContainer> children) {\n        this.children = children;\n    }\n\n    public void addChildren(List<ModContainer> children) {\n        this.children.addAll(children);\n    }\n\n    public void addChildren(ModContainer... children) {\n        this.children.addAll(Arrays.asList(children));\n    }\n\n    public List<ModContainer> getChildren() {\n        return children;\n    }\n\n    public boolean isMouseOver(double double_1, double double_2) {\n        return Objects.equals(this.list.getEntryAtPos(double_1, double_2), this);\n    }\n}\n", "refactored": false}
{"hexsha": "b64d18704447220e35b2d2254fdb3118096bcb32", "ext": "java", "lang": "Java", "content": "@Dependent\npublic class DefaultPaletteFactory<H extends AbstractCanvasHandler> implements PaletteFactory<DefaultPaletteWidget, H> {\n\n    private final DefinitionUtils definitionUtils;\n\n    private final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders;\n\n    private final ManagedInstance<DefaultPaletteWidget> palettes;\n\n    private final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent;\n\n    private final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent;\n\n    private final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent;\n\n    @Inject\n    public DefaultPaletteFactory(final DefinitionUtils definitionUtils, @Any final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders, @Any final ManagedInstance<DefaultPaletteWidget> palettes, final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent, final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent, final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent) {\n        this.definitionUtils = definitionUtils;\n        this.paletteDefinitionBuilders = paletteDefinitionBuilders;\n        this.palettes = palettes;\n        this.buildCanvasShapeEvent = buildCanvasShapeEvent;\n        this.canvasShapeDragStartEvent = canvasShapeDragStartEvent;\n        this.canvasShapeDragUpdateEvent = canvasShapeDragUpdateEvent;\n    }\n\n    @Override\n    public DefaultPaletteWidget newPalette(final H canvasHandler) {\n        final DefaultPaletteWidget palette = getPaletteWidget(canvasHandler);\n        getPaletteDefinitionBuilder(canvasHandler).build(canvasHandler, palette::bind);\n        return palette;\n    }\n\n    @PreDestroy\n    public void destroy() {\n        paletteDefinitionBuilders.destroyAll();\n        palettes.destroyAll();\n    }\n\n    private PaletteDefinitionBuilder<H, DefaultPaletteDefinition> getPaletteDefinitionBuilder(final H canvasHandler) {\n        final String definitionSetId = canvasHandler.getDiagram().getMetadata().getDefinitionSetId();\n        final Annotation qualifier = definitionUtils.getQualifier(definitionSetId);\n        final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> custom = paletteDefinitionBuilders.select(qualifier);\n        if (custom.isUnsatisfied()) {\n            return paletteDefinitionBuilders.select(DefinitionManager.DEFAULT_QUALIFIER).get();\n        }\n        return custom.get();\n    }\n\n    private DefaultPaletteWidget getPaletteWidget(final H canvasHandler) {\n        final DefaultPaletteWidget palette = palettes.get();\n        palette.onItemDrop(event -> buildCanvasShapeEvent.fire(new BuildCanvasShapeEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));\n        palette.onItemDragStart(event -> canvasShapeDragStartEvent.fire(new CanvasShapeDragStartEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));\n        palette.onItemDragUpdate(event -> canvasShapeDragUpdateEvent.fire(new CanvasShapeDragUpdateEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));\n        return palette;\n    }\n}\n", "class_id": 0, "repo": "caponetto/kogito-editors-java", "file": "kie-wb-common-stunner/kie-wb-common-stunner-client/kie-wb-common-stunner-widgets/src/main/java/org/kie/workbench/common/stunner/client/widgets/palette/DefaultPaletteFactory.java", "last_update_at": "2021-07-03T13:15:03+00:00", "original_content": "@Dependent\npublic class DefaultPaletteFactory<H extends AbstractCanvasHandler> implements PaletteFactory<DefaultPaletteWidget, H> {\n\n    private final DefinitionUtils definitionUtils;\n\n    private final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders;\n\n    private final ManagedInstance<DefaultPaletteWidget> palettes;\n\n    private final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent;\n\n    private final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent;\n\n    private final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent;\n\n    @Inject\n    public DefaultPaletteFactory(final DefinitionUtils definitionUtils, @Any final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders, @Any final ManagedInstance<DefaultPaletteWidget> palettes, final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent, final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent, final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent) {\n        this.definitionUtils = definitionUtils;\n        this.paletteDefinitionBuilders = paletteDefinitionBuilders;\n        this.palettes = palettes;\n        this.buildCanvasShapeEvent = buildCanvasShapeEvent;\n        this.canvasShapeDragStartEvent = canvasShapeDragStartEvent;\n        this.canvasShapeDragUpdateEvent = canvasShapeDragUpdateEvent;\n    }\n\n    @Override\n    public DefaultPaletteWidget newPalette(final H canvasHandler) {\n        final DefaultPaletteWidget palette = getPaletteWidget(canvasHandler);\n        getPaletteDefinitionBuilder(canvasHandler).build(canvasHandler, palette::bind);\n        return palette;\n    }\n\n    @PreDestroy\n    public void destroy() {\n        paletteDefinitionBuilders.destroyAll();\n        palettes.destroyAll();\n    }\n\n    private PaletteDefinitionBuilder<H, DefaultPaletteDefinition> getPaletteDefinitionBuilder(final H canvasHandler) {\n        final String definitionSetId = canvasHandler.getDiagram().getMetadata().getDefinitionSetId();\n        final Annotation qualifier = definitionUtils.getQualifier(definitionSetId);\n        final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> custom = paletteDefinitionBuilders.select(qualifier);\n        if (custom.isUnsatisfied()) {\n            return paletteDefinitionBuilders.select(DefinitionManager.DEFAULT_QUALIFIER).get();\n        }\n        return custom.get();\n    }\n\n    private DefaultPaletteWidget getPaletteWidget(final H canvasHandler) {\n        final DefaultPaletteWidget palette = palettes.get();\n        palette.onItemDrop(event -> buildCanvasShapeEvent.fire(new BuildCanvasShapeEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));\n        palette.onItemDragStart(event -> canvasShapeDragStartEvent.fire(new CanvasShapeDragStartEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));\n        palette.onItemDragUpdate(event -> canvasShapeDragUpdateEvent.fire(new CanvasShapeDragUpdateEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));\n        return palette;\n    }\n}\n", "refactored": false}
{"hexsha": "977a9650b30ee1056d3003eb9836578725120840", "ext": "java", "lang": "Java", "content": "@EActivity(R.layout.activity_main)\npublic class PDFViewActivity extends AppCompatActivity implements OnPageChangeListener {\n\n    public static final String SAMPLE_FILE = \"sample.pdf\";\n\n    @ViewById\n    PDFView pdfView;\n\n    @ViewById\n    ScrollBar scrollBar;\n\n    @NonConfigurationInstance\n    String pdfName = SAMPLE_FILE;\n\n    @NonConfigurationInstance\n    Integer pageNumber = 1;\n\n    @AfterViews\n    void afterViews() {\n        pdfView.setScrollBar(scrollBar);\n        display(pdfName, false);\n    }\n\n    private void display(String assetFileName, boolean jumpToFirstPage) {\n        if (jumpToFirstPage)\n            pageNumber = 1;\n        setTitle(pdfName = assetFileName);\n        pdfView.fromAsset(assetFileName).defaultPage(pageNumber).onPageChange(this).swipeVertical(true).showMinimap(false).load();\n    }\n\n    @Override\n    public void onPageChanged(int page, int pageCount) {\n        pageNumber = page;\n        setTitle(format(\"%s %s / %s\", pdfName, page, pageCount));\n    }\n}\n", "class_id": 0, "repo": "romeoh/AndroidPdfViewer", "file": "sample/src/main/java/com/github/barteksc/sample/PDFViewActivity.java", "last_update_at": "2021-07-13T07:28:38+00:00", "original_content": "@EActivity(R.layout.activity_main)\npublic class PDFViewActivity extends AppCompatActivity implements OnPageChangeListener {\n\n    public static final String SAMPLE_FILE = \"sample.pdf\";\n\n    @ViewById\n    PDFView pdfView;\n\n    @ViewById\n    ScrollBar scrollBar;\n\n    @NonConfigurationInstance\n    String pdfName = SAMPLE_FILE;\n\n    @NonConfigurationInstance\n    Integer pageNumber = 1;\n\n    @AfterViews\n    void afterViews() {\n        pdfView.setScrollBar(scrollBar);\n        display(pdfName, false);\n    }\n\n    private void display(String assetFileName, boolean jumpToFirstPage) {\n        if (jumpToFirstPage)\n            pageNumber = 1;\n        setTitle(pdfName = assetFileName);\n        pdfView.fromAsset(assetFileName).defaultPage(pageNumber).onPageChange(this).swipeVertical(true).showMinimap(false).load();\n    }\n\n    @Override\n    public void onPageChanged(int page, int pageCount) {\n        pageNumber = page;\n        setTitle(format(\"%s %s / %s\", pdfName, page, pageCount));\n    }\n}\n", "refactored": false}
{"hexsha": "3abd49fe01a13f09b3da2e4f76316ccef4ce8fa9", "ext": "java", "lang": "Java", "content": "@Validated\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController extends BaseController {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private AddressService addressService;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @PostMapping(\"/insertDemoData\")\n    public void insertDemoData(String name) {\n        Address address = new Address();\n        address.setCountry(\"CN\");\n        address.setProvince(\"SHAANXI\");\n        address.setCity(\"XI'AN\");\n        address.setHouseNumber(12);\n        address = addressService.save(address);\n        User user = new User();\n        user.setName(\"Lisa\");\n        user.setAge(12);\n        user.setRole(Role.USER);\n        user.setAddressId(address.getId());\n        userService.saveAndFlush(user);\n    }\n\n    @PostMapping(\"/insert\")\n    public void insert(@Valid User user, @Valid Address address) {\n        Address address1 = addressService.save(address);\n        user.setAddressId(address1.getId());\n        User user1 = userService.saveAndFlush(user);\n    }\n\n    @PostMapping(\"/update/{id}\")\n    public void update(@PathVariable(\"id\") Long id) {\n        User user = new User();\n        user.setId(id);\n        user.setName(\"Tom\");\n        userService.update(id, user);\n    }\n\n    @GetMapping(\"/all\")\n    public List<User> findAll() {\n        return userService.findAll();\n    }\n\n    @GetMapping(\"/page\")\n    public Pager<User> findPage(Pager<User> pager) {\n        final Page<User> page = userService.findAll(PagerConverter.toPageable(pager));\n        return PagerConverter.toPager(page);\n    }\n\n    @GetMapping(\"/dsl\")\n    public List<User> findAllByQueryDsl(User user) {\n        return userService.findAllByQueryDsl(user);\n    }\n\n    @GetMapping(\"/nativeSql\")\n    public List<Object> findStudentAddress(String userName, String city) {\n        return userService.findStudentAddress(userName, city);\n    }\n\n    @GetMapping(\"/school\")\n    public List<UserRepository.UserSchoolDTO> findUserSchoolDTO() {\n        return userRepository.findUserSchoolDTO();\n    }\n}\n", "class_id": 0, "repo": "mengweijin/quickboot", "file": "sample-quickboot-jpa-web/src/main/java/com/github/mengweijin/quickboot/sample/system/controller/UserController.java", "last_update_at": "2021-02-04T02:41:01+00:00", "original_content": "@Validated\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController extends BaseController {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private AddressService addressService;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @PostMapping(\"/insertDemoData\")\n    public void insertDemoData(String name) {\n        Address address = new Address();\n        address.setCountry(\"CN\");\n        address.setProvince(\"SHAANXI\");\n        address.setCity(\"XI'AN\");\n        address.setHouseNumber(12);\n        address = addressService.save(address);\n        User user = new User();\n        user.setName(\"Lisa\");\n        user.setAge(12);\n        user.setRole(Role.USER);\n        user.setAddressId(address.getId());\n        userService.saveAndFlush(user);\n    }\n\n    @PostMapping(\"/insert\")\n    public void insert(@Valid User user, @Valid Address address) {\n        Address address1 = addressService.save(address);\n        user.setAddressId(address1.getId());\n        User user1 = userService.saveAndFlush(user);\n    }\n\n    @PostMapping(\"/update/{id}\")\n    public void update(@PathVariable(\"id\") Long id) {\n        User user = new User();\n        user.setId(id);\n        user.setName(\"Tom\");\n        userService.update(id, user);\n    }\n\n    @GetMapping(\"/all\")\n    public List<User> findAll() {\n        return userService.findAll();\n    }\n\n    @GetMapping(\"/page\")\n    public Pager<User> findPage(Pager<User> pager) {\n        final Page<User> page = userService.findAll(PagerConverter.toPageable(pager));\n        return PagerConverter.toPager(page);\n    }\n\n    @GetMapping(\"/dsl\")\n    public List<User> findAllByQueryDsl(User user) {\n        return userService.findAllByQueryDsl(user);\n    }\n\n    @GetMapping(\"/nativeSql\")\n    public List<Object> findStudentAddress(String userName, String city) {\n        return userService.findStudentAddress(userName, city);\n    }\n\n    @GetMapping(\"/school\")\n    public List<UserRepository.UserSchoolDTO> findUserSchoolDTO() {\n        return userRepository.findUserSchoolDTO();\n    }\n}\n", "refactored": false}
{"hexsha": "51c610d263d838050ce965c17b85338e36da3e55", "ext": "java", "lang": "Java", "content": "public class MongoLockService implements LockService {\n\n    public static final String MIGRAMONGO_LOCK_COLLECTION = \"_migramongo_lock\";\n\n    private final MongoDatabase database;\n\n    public MongoLockService(MongoDatabase database) {\n        this.database = database;\n        initLockCollection();\n    }\n\n    private void initLockCollection() {\n        //if the table already exists, we do not need to create it anymore\n        if (getLockCollection().countDocuments() > 0) {\n            return;\n        }\n        // assuring that the index exists\n        getLockCollection().createIndex(new BasicDBObject(LockEntryDocBuilder.LOCK_ENTRY, 1));\n        // one already exists, but it's ok\n        final Document basicLockEntry = new LockEntryDocBuilder().build();\n        getLockCollection().insertOne(basicLockEntry);\n    }\n\n    private MongoCollection<Document> getLockCollection() {\n        return this.database.getCollection(MIGRAMONGO_LOCK_COLLECTION);\n    }\n\n    @Override\n    public boolean acquireLock() {\n        if (getLockCollection().countDocuments() == 0) {\n            throw new IllegalStateException(\"Cannot acquire lock because lock table has not been initialized. Initialize MongoLockService properly, or call destroyLock\");\n        }\n        final Document lockDocument = new LockEntryDocBuilder().lock().build();\n        final Document result = getLockCollection().findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document(\"$set\", lockDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, true) == false;\n    }\n\n    @Override\n    public boolean releaseLock() {\n        final Document releaseDocument = new LockEntryDocBuilder().release().build();\n        final Document result = getLockCollection().findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document(\"$set\", releaseDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, false) == true;\n    }\n\n    static class LockEntryDocBuilder {\n\n        static String LOCK_ENTRY = \"lockEntry\";\n\n        static String LOCKED = \"locked\";\n\n        static String LAST_LOCK_DATE = \"lastLockDate\";\n\n        static String LAST_RELEASE_DATE = \"lastReleaseDate\";\n\n        private Document doc;\n\n        LockEntryDocBuilder() {\n            doc = new Document();\n            doc.put(LOCK_ENTRY, true);\n            doc.put(LOCKED, false);\n        }\n\n        LockEntryDocBuilder lock() {\n            doc.put(LOCKED, true);\n            doc.put(LAST_LOCK_DATE, new Date());\n            return this;\n        }\n\n        LockEntryDocBuilder release() {\n            doc.put(LOCKED, false);\n            doc.put(LAST_RELEASE_DATE, new Date());\n            return this;\n        }\n\n        Document build() {\n            return doc;\n        }\n    }\n\n    @Override\n    public LockEntry getLockInformation() {\n        final Document lockDocument = getLockCollection().find(new Document(LockEntryDocBuilder.LOCK_ENTRY, true)).first();\n        return new LockEntry(lockDocument.getBoolean(LockEntryDocBuilder.LOCKED), lockDocument.getDate(LockEntryDocBuilder.LAST_LOCK_DATE), lockDocument.getDate(LockEntryDocBuilder.LAST_RELEASE_DATE));\n    }\n\n    @Override\n    public void destroyLock() {\n        getLockCollection().deleteMany(new Document(LockEntryDocBuilder.LOCK_ENTRY, true));\n        initLockCollection();\n    }\n}\n", "class_id": 0, "repo": "pablotp/migramongo", "file": "migramongo-core/src/main/java/com/rinoto/migramongo/dao/MongoLockService.java", "last_update_at": "2021-06-28T08:50:12+00:00", "original_content": "public class MongoLockService implements LockService {\n\n    public static final String MIGRAMONGO_LOCK_COLLECTION = \"_migramongo_lock\";\n\n    private final MongoDatabase database;\n\n    public MongoLockService(MongoDatabase database) {\n        this.database = database;\n        initLockCollection();\n    }\n\n    private void initLockCollection() {\n        //if the table already exists, we do not need to create it anymore\n        if (getLockCollection().countDocuments() > 0) {\n            return;\n        }\n        // assuring that the index exists\n        getLockCollection().createIndex(new BasicDBObject(LockEntryDocBuilder.LOCK_ENTRY, 1));\n        // one already exists, but it's ok\n        final Document basicLockEntry = new LockEntryDocBuilder().build();\n        getLockCollection().insertOne(basicLockEntry);\n    }\n\n    private MongoCollection<Document> getLockCollection() {\n        return this.database.getCollection(MIGRAMONGO_LOCK_COLLECTION);\n    }\n\n    @Override\n    public boolean acquireLock() {\n        if (getLockCollection().countDocuments() == 0) {\n            throw new IllegalStateException(\"Cannot acquire lock because lock table has not been initialized. Initialize MongoLockService properly, or call destroyLock\");\n        }\n        final Document lockDocument = new LockEntryDocBuilder().lock().build();\n        final Document result = getLockCollection().findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document(\"$set\", lockDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, true) == false;\n    }\n\n    @Override\n    public boolean releaseLock() {\n        final Document releaseDocument = new LockEntryDocBuilder().release().build();\n        final Document result = getLockCollection().findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document(\"$set\", releaseDocument));\n        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, false) == true;\n    }\n\n    static class LockEntryDocBuilder {\n\n        static String LOCK_ENTRY = \"lockEntry\";\n\n        static String LOCKED = \"locked\";\n\n        static String LAST_LOCK_DATE = \"lastLockDate\";\n\n        static String LAST_RELEASE_DATE = \"lastReleaseDate\";\n\n        private Document doc;\n\n        LockEntryDocBuilder() {\n            doc = new Document();\n            doc.put(LOCK_ENTRY, true);\n            doc.put(LOCKED, false);\n        }\n\n        LockEntryDocBuilder lock() {\n            doc.put(LOCKED, true);\n            doc.put(LAST_LOCK_DATE, new Date());\n            return this;\n        }\n\n        LockEntryDocBuilder release() {\n            doc.put(LOCKED, false);\n            doc.put(LAST_RELEASE_DATE, new Date());\n            return this;\n        }\n\n        Document build() {\n            return doc;\n        }\n    }\n\n    @Override\n    public LockEntry getLockInformation() {\n        final Document lockDocument = getLockCollection().find(new Document(LockEntryDocBuilder.LOCK_ENTRY, true)).first();\n        return new LockEntry(lockDocument.getBoolean(LockEntryDocBuilder.LOCKED), lockDocument.getDate(LockEntryDocBuilder.LAST_LOCK_DATE), lockDocument.getDate(LockEntryDocBuilder.LAST_RELEASE_DATE));\n    }\n\n    @Override\n    public void destroyLock() {\n        getLockCollection().deleteMany(new Document(LockEntryDocBuilder.LOCK_ENTRY, true));\n        initLockCollection();\n    }\n}\n", "refactored": false}
{"hexsha": "fd5d92b41d2bda214eab3d1eddcc520c7b44e553", "ext": "java", "lang": "Java", "content": "public class UrlPart {\r\n\r\n    private final Object url;\r\n\r\n    private final boolean isRegex;\r\n\r\n    public UrlPart(String url, boolean isRegex) {\r\n        this.url = url;\r\n        this.isRegex = isRegex;\r\n    }\r\n\r\n    public UrlPart(HttpMethod method) {\r\n        this.url = method;\r\n        this.isRegex = false;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + (isRegex ? 1231 : 1237);\r\n        result = prime * result + ((url == null) ? 0 : url.hashCode());\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        UrlPart other = (UrlPart) obj;\r\n        if (url == null && other.url != null) {\r\n            return false;\r\n        }\r\n        if (isRegex) {\r\n            /*Matcher m = Pattern.compile(String.format(\"(%s)\", url)).matcher(url);\t\r\n\t\t\treturn m.find();*/\r\n            return true;\r\n        }\r\n        return url.equals(other.url);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        //\treturn \"UrlPart [url=\" + url + \", isRegex=\" + isRegex + \"]\";\r\n        return url.toString();\r\n    }\r\n}\r\n", "class_id": 0, "repo": "ondrej-nemec/MVC", "file": "src/main/java/toti/url/UrlPart.java", "last_update_at": "2021-04-22T08:45:01+00:00", "original_content": "public class UrlPart {\r\n\r\n    private final Object url;\r\n\r\n    private final boolean isRegex;\r\n\r\n    public UrlPart(String url, boolean isRegex) {\r\n        this.url = url;\r\n        this.isRegex = isRegex;\r\n    }\r\n\r\n    public UrlPart(HttpMethod method) {\r\n        this.url = method;\r\n        this.isRegex = false;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + (isRegex ? 1231 : 1237);\r\n        result = prime * result + ((url == null) ? 0 : url.hashCode());\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        if (getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        UrlPart other = (UrlPart) obj;\r\n        if (url == null && other.url != null) {\r\n            return false;\r\n        }\r\n        if (isRegex) {\r\n            /*Matcher m = Pattern.compile(String.format(\"(%s)\", url)).matcher(url);\t\r\n\t\t\treturn m.find();*/\r\n            return true;\r\n        }\r\n        return url.equals(other.url);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        //\treturn \"UrlPart [url=\" + url + \", isRegex=\" + isRegex + \"]\";\r\n        return url.toString();\r\n    }\r\n}\r\n", "refactored": false}
{"hexsha": "c85862bd68af35280ddc23c32cb83bc91c2feb4e", "ext": "java", "lang": "Java", "content": "public class PreconditionsTest {\n\n    @Test\n    public void test() {\n        int i = new Random().nextInt();\n        int j = new Random().nextInt();\n        checkArgument(i >= 0, \"Argument was %s but expected nonnegative\", i);\n        checkArgument(i < j, \"Expected i < j, but %s > %s\", i, j);\n    }\n}\n", "class_id": 0, "repo": "itning/BigData", "file": "Guava/src/main/java/top/itning/bigdata/guava/precondition/PreconditionsTest.java", "last_update_at": "2021-12-05T02:12:25+00:00", "original_content": "public class PreconditionsTest {\n\n    @Test\n    public void test() {\n        int i = new Random().nextInt();\n        int j = new Random().nextInt();\n        checkArgument(i >= 0, \"Argument was %s but expected nonnegative\", i);\n        checkArgument(i < j, \"Expected i < j, but %s > %s\", i, j);\n    }\n}\n", "refactored": false}
{"hexsha": "1aa4b7d2a9d3993327fbc3ab5af3a225a40834a6", "ext": "java", "lang": "Java", "content": "public class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Examples e = new Examples();\n    }\n}\n", "class_id": 0, "repo": "ruz76/wps", "file": "GTSearch/src/cz/vsb/gis/ruz76/gt/Main.java", "last_update_at": "2021-05-22T04:40:34+00:00", "original_content": "public class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Examples e = new Examples();\n    }\n}\n", "refactored": false}
{"hexsha": "e2b1d74db8b5405d1f9d96ba519d9b6d9d3cd3ab", "ext": "java", "lang": "Java", "content": "public abstract class Node implements UniversalCodeVisitable {\n\n    /**\n     * The parent node.\n     */\n    private Node parent;\n\n    /**\n     * The parser token image backing this node.\n     */\n    private TokenImage tokenImage;\n\n    private Type type;\n\n    /**\n     * Constructs a new AST node instance, with no initial configuration.\n     */\n    public Node() {\n    }\n\n    /**\n     * Constructs a new AST node instance.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public Node(TokenImage tokenImage) {\n        this(tokenImage, (Class<?>) null);\n    }\n\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Class<?> typeDescriptor) {\n        this(null, tokenImage, typeDescriptor);\n    }\n\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param type  the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Type type) {\n        this(null, tokenImage, type);\n    }\n\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Class<?> typeDescriptor) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n        //        this.typeDescriptor = typeDescriptor;\n        this.type = typeDescriptor == null ? null : new ResolvedTypeReferenceOld(tokenImage, typeDescriptor);\n    }\n\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param type the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Type type) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n        //        this.typeDescriptor = null;\n        this.type = type;\n    }\n\n    public Node accept(UniversalCodeVisitor visitor) {\n        return this;\n    }\n\n    public Node accept(AstVisitor visitor) {\n        return this;\n    }\n\n    /**\n     * Gets the parent node.\n     *\n     * @return the parent node, which may be null if this node does not have a parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     */\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     * @return this instance for builder chaining.\n     */\n    public Node withParent(Node parent) {\n        setParent(parent);\n        return this;\n    }\n\n    /**\n     * Gets the parser token image backing this node.\n     *\n     * @return the parser token image backing this node.\n     */\n    public TokenImage getTokenImage() {\n        return tokenImage;\n    }\n\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public void setTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n    }\n\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @return this instance for builder chaining.\n     */\n    public Node withTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n        return this;\n    }\n\n    public Class<?> getTypeDescriptor() {\n        //        return typeDescriptor;\n        return getType() == null ? null : getType().getTypeClass();\n    }\n\n    /**\n     * Returns the established static type of the node.\n     *\n     * @return the node's type, or null if the type cannot be determined at this time.\n     */\n    public Type getType() {\n        return type;\n    }\n\n    public void setType(final TypeReference type) {\n        this.type = type;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (!(o instanceof Node))\n            return false;\n        Node node = (Node) o;\n        return Objects.equals(parent, node.parent) && Objects.equals(tokenImage, node.tokenImage) && Objects.equals(type, node.type);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(parent, tokenImage, type);\n    }\n}\n", "class_id": 0, "repo": "lamerexter/universel", "file": "src/main/java/org/orthodox/universel/ast/Node.java", "last_update_at": "2021-04-17T13:17:11+00:00", "original_content": "public abstract class Node implements UniversalCodeVisitable {\n\n    /**\n     * The parent node.\n     */\n    private Node parent;\n\n    /**\n     * The parser token image backing this node.\n     */\n    private TokenImage tokenImage;\n\n    private Type type;\n\n    /**\n     * Constructs a new AST node instance, with no initial configuration.\n     */\n    public Node() {\n    }\n\n    /**\n     * Constructs a new AST node instance.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public Node(TokenImage tokenImage) {\n        this(tokenImage, (Class<?>) null);\n    }\n\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Class<?> typeDescriptor) {\n        this(null, tokenImage, typeDescriptor);\n    }\n\n    /**\n     * Constructs the node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @param type  the type of the node, or null if unknown at this time.\n     */\n    public Node(TokenImage tokenImage, Type type) {\n        this(null, tokenImage, type);\n    }\n\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param typeDescriptor the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Class<?> typeDescriptor) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n        //        this.typeDescriptor = typeDescriptor;\n        this.type = typeDescriptor == null ? null : new ResolvedTypeReferenceOld(tokenImage, typeDescriptor);\n    }\n\n    /**\n     * All args constructor.\n     *\n     * @param parent the parent node, which may be null to indicate none.\n     * @param tokenImage the parser token image backing this node.\n     * @param type the type of the node, or null if unknown at this time.\n     */\n    public Node(Node parent, TokenImage tokenImage, Type type) {\n        this.parent = parent;\n        this.tokenImage = tokenImage;\n        //        this.typeDescriptor = null;\n        this.type = type;\n    }\n\n    public Node accept(UniversalCodeVisitor visitor) {\n        return this;\n    }\n\n    public Node accept(AstVisitor visitor) {\n        return this;\n    }\n\n    /**\n     * Gets the parent node.\n     *\n     * @return the parent node, which may be null if this node does not have a parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     */\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Sets the parent node.\n     *\n     * @param parent the parent node, which may be null if this node does not have a parent.\n     * @return this instance for builder chaining.\n     */\n    public Node withParent(Node parent) {\n        setParent(parent);\n        return this;\n    }\n\n    /**\n     * Gets the parser token image backing this node.\n     *\n     * @return the parser token image backing this node.\n     */\n    public TokenImage getTokenImage() {\n        return tokenImage;\n    }\n\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     */\n    public void setTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n    }\n\n    /**\n     * Sets the parser token image backing this node.\n     *\n     * @param tokenImage the parser token image backing this node.\n     * @return this instance for builder chaining.\n     */\n    public Node withTokenImage(TokenImage tokenImage) {\n        this.tokenImage = tokenImage;\n        return this;\n    }\n\n    public Class<?> getTypeDescriptor() {\n        //        return typeDescriptor;\n        return getType() == null ? null : getType().getTypeClass();\n    }\n\n    /**\n     * Returns the established static type of the node.\n     *\n     * @return the node's type, or null if the type cannot be determined at this time.\n     */\n    public Type getType() {\n        return type;\n    }\n\n    public void setType(final TypeReference type) {\n        this.type = type;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (!(o instanceof Node))\n            return false;\n        Node node = (Node) o;\n        return Objects.equals(parent, node.parent) && Objects.equals(tokenImage, node.tokenImage) && Objects.equals(type, node.type);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(parent, tokenImage, type);\n    }\n}\n", "refactored": false}
{"hexsha": "1fedf96a0bc0d600ebdfb70a4efcf6a14a3fed03", "ext": "java", "lang": "Java", "content": "public class VoteCounter {\n\n    //Parameter: The number of candidates that can win\n    static int numberOfWinners;\n\n    //The percentage of votes that is needed to guarantee a win for a candidate\n    static double voteThresholdPercent;\n\n    //A counter for the total number of candidates\n    static int numberOfCandidates = 0;\n\n    //the total number of votes being counted\n    static int numberOfVotes = 0;\n\n    //the number of votes needed to guarantee a win\n    static double voteThreshold = 0.0;\n\n    //A list of the candidates which have won\n    static ArrayList<String> winningCandidates = new ArrayList<>();\n\n    //A list of the candidates which have been eliminated\n    static ArrayList<String> eliminatedCandidates = new ArrayList<>();\n\n    //A list of the original, unaltered Votes. Needed for the tie breaker\n    static ArrayList<Vote> originalVotes = new ArrayList<Vote>();\n\n    //A list of the votes that are redistributed\n    static ArrayList<Vote> votes = new ArrayList<Vote>();\n\n    //A list of the working vote counts\n    static HashMap<String, Double> currentVoteCounts = new HashMap<>();\n\n    static int roundCounter = 1;\n\n    /**\n     * The main method. See class docs for description on required arguments\n     *\n     * @param args - String[]\n     */\n    public static void main(String[] args) {\n        //If there was 1 argument, check if it was help and print how to if it was\n        if (args.length == 1 && args[0].equals(\"help\")) {\n            //TODO provide how to output\n            return;\n        }\n        //Quit if the three arguments were not supplied\n        if (args.length != 3) {\n            System.out.println(\"Please provide all 3 arguments. Run 'VoteCounter help' for more information.\");\n            return;\n        }\n        //Parse the input files\n        if (!parseCandidates(args[0])) {\n            //If parseCandidates returns false, then it failed to work correctly and the program should terminate\n            return;\n        }\n        if (!parseVotes(args[1])) {\n            //if parseVotes returns false, then it failed to work correctly and the program should terminate\n            return;\n        }\n        //Try to get the number of voters\n        try {\n            numberOfWinners = Integer.parseInt(args[2]);\n            if (numberOfWinners < 1 || numberOfWinners > currentVoteCounts.keySet().size()) {\n                System.out.println(\"The number of winners must be at least 1 and no more than the number of candidates\");\n                return;\n            }\n        } catch (NumberFormatException e) {\n            //Not a valid number, so print error to the user and return\n            System.out.println(\"Invalid winner count argument. \");\n            return;\n        }\n        //calculate the vote thresholds\n        voteThresholdPercent = 1.0 / (numberOfWinners + 1);\n        voteThreshold = numberOfVotes * voteThresholdPercent;\n        //perform the initial count of the votes\n        countVotes();\n        //Analyze the votes, redistributing as needed, until enough winners have been found\n        do {\n            analyzeVotes();\n        } while (winningCandidates.size() < numberOfWinners);\n        //Print the final winners\n        System.out.println();\n        System.out.println(\"Winners:\");\n        System.out.println(String.join(\", \", winningCandidates));\n    }\n\n    /**\n     * Parse the candidate file and initialize {@code numberOfCandidates} and {@code currentVoteCounts}\n     *\n     * @param candidateFileName - String - the name of the candidate file\n     * @return boolean - true if successful, false if not successful\n     */\n    private static boolean parseCandidates(String candidateFileName) {\n        BufferedReader candidateReader = null;\n        try {\n            //try to open the file for reading\n            candidateReader = new BufferedReader(new FileReader(candidateFileName));\n            String candidate = null;\n            //Loop through each line and store the candidate and increase the candidate count\n            while ((candidate = candidateReader.readLine()) != null) {\n                currentVoteCounts.put(candidate.trim(), 0.0);\n                numberOfCandidates += 1;\n            }\n        } catch (FileNotFoundException e) {\n            //The file was not found, so print the error message and quit\n            System.out.println(\"Unable to open the candidate file. Please ensure the provided file path is correct.\");\n            return false;\n        } catch (IOException e) {\n            //Something went wrong reading the file, so print the error message and quit\n            System.out.println(\"An error occured while reading the candidate file:\" + e.getMessage());\n            return false;\n        } finally {\n            //Close the candidateReader after everything, if it exists\n            if (candidateReader != null) {\n                try {\n                    candidateReader.close();\n                } catch (IOException e) {\n                    System.out.println(\"An error occured while closing the candidate file:\\n\" + e.getMessage());\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Parse the vote file and construct all {@link Vote} objects\n     *\n     * @param voteFileName - String - The file name of the vote file\n     * @return boolean - true if successful, false if not successful\n     */\n    private static boolean parseVotes(String voteFileName) {\n        BufferedReader voteReader = null;\n        try {\n            //attempt to open the vote file\n            voteReader = new BufferedReader(new FileReader(voteFileName));\n            String line = null;\n            voteReader.readLine();\n            //parse the line of the csv file and use it to create a Vote object\n            while ((line = voteReader.readLine()) != null) {\n                String[] inputRow = line.split(\",\");\n                //store the vote as needed and count the total number of votes\n                votes.add(new Vote(inputRow));\n                originalVotes.add(new Vote(inputRow));\n                numberOfVotes++;\n            }\n        } catch (FileNotFoundException e) {\n            //File was not found, so return\n            System.out.println(\"Unable to open the vote file. Please ensure the provided file path is correct.\");\n            return false;\n        } catch (IOException e) {\n            //Failure to read file correctly, so return\n            System.out.println(\"An error occured while reading the vote file:\" + e.getMessage());\n            return false;\n        } finally {\n            //Close the buffered reader when finished\n            if (voteReader != null) {\n                try {\n                    voteReader.close();\n                } catch (IOException e) {\n                    System.out.println(\"An error occured while closing the vote file:\\n\" + e.getMessage());\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Analyzes the current vote counts, determining a winner or loser for the round, and the redistributes votes as needed\n     */\n    private static void analyzeVotes() {\n        //Print the start of round text and current vote counts\n        System.out.println();\n        System.out.println(\"Round \" + roundCounter++ + \" vote counts:\");\n        for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n            System.out.print(entry.getKey() + \": \" + entry.getValue() + \" | \");\n        }\n        System.out.println();\n        //If the number of candidates left equals the number of winners, mark them all winners and end\n        if (currentVoteCounts.size() == numberOfWinners) {\n            for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n                if (!winningCandidates.contains(entry.getKey())) {\n                    winningCandidates.add(entry.getKey());\n                    System.out.println(entry.getKey() + \" has won in the last round.\");\n                }\n            }\n            return;\n        }\n        boolean noWinnerFound = true;\n        //create an arrayList that holds the factions with the least number of votes and track the current minimum vote total\n        ArrayList<String> minCandidatess = new ArrayList<>();\n        double minCount = Double.MAX_VALUE;\n        //The entry key is the candidate name and entry value is the vote count\n        for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n            //If the candidate has already won, do not count their votes\n            if (!winningCandidates.contains(entry.getKey())) {\n                //Check if the vote count for this candidate has exceeded the winning threshold\n                if (entry.getValue().compareTo(voteThreshold) > 0) {\n                    //Mark that a winner was found\n                    noWinnerFound = false;\n                    //a weight for all votes from this winner as they are redistributed.\n                    double redistributeAmount = Double.sum(entry.getValue(), voteThreshold * -1.0) / numberOfVotes;\n                    //redistribute the votes of the winner using the calculated redistribution amount\n                    redistributeVotes(entry.getKey(), redistributeAmount);\n                    //Add the winner to the list of winners and print that they have won\n                    winningCandidates.add(entry.getKey());\n                    System.out.println(entry.getKey() + \" has won with \" + entry.getValue() + \" votes.\");\n                    //Exit the loop\n                    break;\n                }\n            }\n            if (entry.getValue().compareTo(minCount) < 0) {\n                //Store this count as the new minimum\n                minCount = entry.getValue();\n                //remove all current candidates from the minimum count list\n                minCandidatess.clear();\n                //and add this candidate to the list\n                minCandidatess.add(entry.getKey());\n            } else if (entry.getValue().compareTo(minCount) == 0) {\n                minCandidatess.add(entry.getKey());\n            }\n        }\n        //Since no one won, a loser must be eliminated\n        if (noWinnerFound) {\n            //If 2 or more are tied for the lowest, run a tie breaker and eliminate the loser\n            if (minCandidatess.size() == 1) {\n                eliminateCandidate(minCandidatess.get(0));\n            } else {\n                eliminateCandidate(condorcetTieBreak(minCandidatess));\n            }\n        }\n    }\n\n    /**\n     * Perform a condorcet tie break for all factions in the factions list\n     * @param candidates - {@code ArrayList<String>} - The list of candidates to check in the tie breaker\n     *\n     * @return - String - the name of the candidate that lost the tie breaker\n     */\n    private static String condorcetTieBreak(ArrayList<String> candidates) {\n        //Output that a tie braker is occuring between the candidates\n        System.out.println(\"Breaking last place tie between: \" + String.join(\", \", candidates));\n        //create the master matrix that counts the number of times one candidate beats another candidate\n        int[][] masterMatrix = new int[candidates.size()][candidates.size()];\n        //generate a matrix for each vote and add it to the master\n        for (Vote vote : originalVotes) {\n            masterMatrix = matrixAddition(masterMatrix, vote.generateMatrix(candidates));\n        }\n        // Create a win matrix which marks if one candidate beats another candidate more in the master matrix\n        int[][] winMatrix = new int[candidates.size()][candidates.size()];\n        // Create a matrix that stores the magnitude of victories in the win matrix\n        int[][] magnitudeMatrix = new int[candidates.size()][candidates.size()];\n        int x = 0;\n        while (x < masterMatrix.length) try {\n            int y = 0;\n            while (y < masterMatrix[0].length) try {\n                // Only 1 half of the matrix is cared about, so skip it if x < y\n                if (y > x) {\n                    if (masterMatrix[x][y] > masterMatrix[y][x]) {\n                        //If x beat y more than y beat x, mark that x beats y overall in the win matrix\n                        winMatrix[x][y] = 1;\n                        //The winner will have a positive value while the lose will have a negative value\n                        magnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n                        magnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n                    } else if (masterMatrix[x][y] < masterMatrix[y][x]) {\n                        //The same thing as above but if Y won\n                        winMatrix[y][x] = 1;\n                        magnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n                        magnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n                    }\n                }\n            } finally {\n                y++;\n            }\n        } finally {\n            x++;\n        }\n        //Create a variable to store the currently lowest win count\n        int minWins = Integer.MAX_VALUE;\n        //and a list to store the people with the lowest win count\n        ArrayList<Integer> winIndecies = new ArrayList<>();\n        int i = 0;\n        while (i < candidates.size()) try {\n            //determine that candidates win number by summing their row in the matrix\n            int currWins = matrixRowSum(winMatrix, i);\n            if (currWins < minWins) {\n                //If this candidate has less wins than the current lowest, reset the list and mark this candidate the loser\n                minWins = currWins;\n                winIndecies.clear();\n                winIndecies.add(i);\n            } else if (currWins == minWins) {\n                //If this candidate has the same number of wins as the lowest, add their index to the list\n                winIndecies.add(i);\n            }\n        } finally {\n            i++;\n        }\n        //If there is someone worse than everyone else, then they lose\n        if (winIndecies.size() == 1) {\n            return candidates.get(winIndecies.get(0));\n        } else {\n            //If multiple people share the worst win number, magnitude is taken into account\n            int minMagnitude = Integer.MAX_VALUE;\n            ArrayList<Integer> worstIndecies = new ArrayList<>();\n            //Sum the row of the magnitude matrix for each of the worst candidates\n            for (Integer rowNum : winIndecies) {\n                int currMag = matrixRowSum(magnitudeMatrix, rowNum);\n                //Keep track of those candidate with the worst magnitude of wins against all opponents in the tie breaker\n                if (currMag < minMagnitude) {\n                    minMagnitude = currMag;\n                    worstIndecies.clear();\n                    worstIndecies.add(rowNum);\n                } else if (currMag == minMagnitude) {\n                    worstIndecies.add(rowNum);\n                }\n            }\n            //If one is the worst by magnitue, eliminate them\n            if (worstIndecies.size() == 1) {\n                return candidates.get(worstIndecies.get(0));\n            } else {\n                //If win number and magnitude did not break the tie, then we look at the original votes for each candidate\n                ArrayList<Integer> lowPointIndecies = new ArrayList<>();\n                //Points are given for the ranking of a candidate on a ballot, with a higher ranked choice getting more points\n                int lowPoint = Integer.MAX_VALUE;\n                //Loop through the candidates that are stilled tied\n                for (Integer i : worstIndecies) {\n                    int totalPoints = 0;\n                    //get the points for that candidate from each vote\n                    for (Vote vote : originalVotes) {\n                        totalPoints += vote.getPoints(candidates.get(i));\n                    }\n                    //Keep track of the candidates with the worst votes\n                    if (totalPoints < lowPoint) {\n                        lowPoint = totalPoints;\n                        lowPointIndecies.clear();\n                        lowPointIndecies.add(i);\n                    } else if (totalPoints == lowPoint) {\n                        lowPointIndecies.add(i);\n                    }\n                }\n                //If there is one that is worst, eliminate them\n                if (lowPointIndecies.size() == 1) {\n                    return candidates.get(lowPointIndecies.get(0));\n                } else {\n                    //If there is still a tie, it is broken randomly\n                    Random rand = new Random();\n                    int returnIndex = rand.nextInt(lowPointIndecies.size());\n                    return candidates.get(lowPointIndecies.get(returnIndex));\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate the sum of a row (1st index) in a matrix\n     *\n     * @param matrix The matrix to operate on\n     * @param row the index of the row to sum\n     * @return int the sum of the row\n     */\n    private static int matrixRowSum(int[][] matrix, int row) {\n        int sum = 0;\n        int y = 0;\n        while (y < matrix[0].length) try {\n            sum += matrix[row][y];\n        } finally {\n            y++;\n        }\n        return sum;\n    }\n\n    /**\n     * Add two matrices together\n     *\n     * @param a the first matrix to add\n     * @param b the second matrix to add\n     * @return int[][] the matrix creating by adding a and b\n     */\n    private static int[][] matrixAddition(int[][] a, int[][] b) {\n        //get the row and column count for the size of the new matrix\n        int rows = a.length;\n        int columns = a[0].length;\n        //create the matrix\n        int[][] c = new int[rows][columns];\n        int i = 0;\n        while (i < rows) try {\n            int j = 0;\n            while (j < columns) try {\n                c[i][j] = a[i][j] + b[i][j];\n            } finally {\n                j++;\n            }\n        } finally {\n            i++;\n        }\n        return c;\n    }\n\n    /**\n     * Perform the initial count of the votes\n     */\n    private static void countVotes() {\n        for (Vote vote : votes) {\n            if (!vote.getChoices().isEmpty()) {\n                //ensure that the current choice has been reset\n                vote.resetCurrentChoice();\n                String currFaction = vote.getChoice();\n                double newCount = currentVoteCounts.get(currFaction) + vote.getWeight();\n                currentVoteCounts.put(currFaction, newCount);\n            }\n        }\n    }\n\n    /**\n     * Eliminates the specified candidate and redistributes every vote that currently is counting for that candidate with a weight of 1.0\n     *\n     * @param candidate The candidate to eliminate\n     */\n    private static void eliminateCandidate(String candidate) {\n        redistributeVotes(candidate, 1.0);\n        //remove the candidate from the vote counts.\n        System.out.println(candidate + \" has been eliminated with \" + currentVoteCounts.get(candidate) + \" votes.\");\n        currentVoteCounts.remove(candidate);\n    }\n\n    /**\n     * Redistribute votes from a candidate to that vote's next candidate with a specified weight\n     *\n     * @param candidate The candidate to redistribute votes from\n     * @param redistributeAmount The weight of the redistributed votes\n     */\n    private static void redistributeVotes(String candidate, double redistributeAmount) {\n        for (Vote vote : votes) {\n            //skip the vote if it has no valid candidate choices remaining\n            if (vote.getChoices().isEmpty()) {\n                continue;\n            }\n            //If the vote is currently counting for the candidate to redistribute from\n            if (vote.getChoice().compareTo(candidate) == 0) {\n                //If the vote has another valid choice\n                if (vote.getChoices().size() > vote.getCurrentChoice() + 1) {\n                    //Set the vote to the next candidate and count the vote for that candidate\n                    vote.alterWeight(redistributeAmount);\n                    vote.incrementCurrentChoice();\n                    String newCandidate = vote.getChoice();\n                    double newCount = Double.sum(currentVoteCounts.get(newCandidate), vote.getWeight());\n                    currentVoteCounts.put(newCandidate, newCount);\n                }\n            }\n        }\n        for (Vote vote : votes) {\n            vote.eliminateRanking(candidate);\n        }\n    }\n}\n", "class_id": 0, "repo": "tn-wright/ranked-choice-voting", "file": "src/voteCounter/VoteCounter.java", "last_update_at": "2021-03-17T06:34:47+00:00", "original_content": "public class VoteCounter {\n\n    //Parameter: The number of candidates that can win\n    static int numberOfWinners;\n\n    //The percentage of votes that is needed to guarantee a win for a candidate\n    static double voteThresholdPercent;\n\n    //A counter for the total number of candidates\n    static int numberOfCandidates = 0;\n\n    //the total number of votes being counted\n    static int numberOfVotes = 0;\n\n    //the number of votes needed to guarantee a win\n    static double voteThreshold = 0.0;\n\n    //A list of the candidates which have won\n    static ArrayList<String> winningCandidates = new ArrayList<>();\n\n    //A list of the candidates which have been eliminated\n    static ArrayList<String> eliminatedCandidates = new ArrayList<>();\n\n    //A list of the original, unaltered Votes. Needed for the tie breaker\n    static ArrayList<Vote> originalVotes = new ArrayList<Vote>();\n\n    //A list of the votes that are redistributed\n    static ArrayList<Vote> votes = new ArrayList<Vote>();\n\n    //A list of the working vote counts\n    static HashMap<String, Double> currentVoteCounts = new HashMap<>();\n\n    static int roundCounter = 1;\n\n    /**\n     * The main method. See class docs for description on required arguments\n     *\n     * @param args - String[]\n     */\n    public static void main(String[] args) {\n        //If there was 1 argument, check if it was help and print how to if it was\n        if (args.length == 1 && args[0].equals(\"help\")) {\n            //TODO provide how to output\n            return;\n        }\n        //Quit if the three arguments were not supplied\n        if (args.length != 3) {\n            System.out.println(\"Please provide all 3 arguments. Run 'VoteCounter help' for more information.\");\n            return;\n        }\n        //Parse the input files\n        if (!parseCandidates(args[0])) {\n            //If parseCandidates returns false, then it failed to work correctly and the program should terminate\n            return;\n        }\n        if (!parseVotes(args[1])) {\n            //if parseVotes returns false, then it failed to work correctly and the program should terminate\n            return;\n        }\n        //Try to get the number of voters\n        try {\n            numberOfWinners = Integer.parseInt(args[2]);\n            if (numberOfWinners < 1 || numberOfWinners > currentVoteCounts.keySet().size()) {\n                System.out.println(\"The number of winners must be at least 1 and no more than the number of candidates\");\n                return;\n            }\n        } catch (NumberFormatException e) {\n            //Not a valid number, so print error to the user and return\n            System.out.println(\"Invalid winner count argument. \");\n            return;\n        }\n        //calculate the vote thresholds\n        voteThresholdPercent = 1.0 / (numberOfWinners + 1);\n        voteThreshold = numberOfVotes * voteThresholdPercent;\n        //perform the initial count of the votes\n        countVotes();\n        //Analyze the votes, redistributing as needed, until enough winners have been found\n        do {\n            analyzeVotes();\n        } while (winningCandidates.size() < numberOfWinners);\n        //Print the final winners\n        System.out.println();\n        System.out.println(\"Winners:\");\n        System.out.println(String.join(\", \", winningCandidates));\n    }\n\n    /**\n     * Parse the candidate file and initialize {@code numberOfCandidates} and {@code currentVoteCounts}\n     *\n     * @param candidateFileName - String - the name of the candidate file\n     * @return boolean - true if successful, false if not successful\n     */\n    private static boolean parseCandidates(String candidateFileName) {\n        BufferedReader candidateReader = null;\n        try {\n            //try to open the file for reading\n            candidateReader = new BufferedReader(new FileReader(candidateFileName));\n            String candidate = null;\n            //Loop through each line and store the candidate and increase the candidate count\n            while ((candidate = candidateReader.readLine()) != null) {\n                currentVoteCounts.put(candidate.trim(), 0.0);\n                numberOfCandidates += 1;\n            }\n        } catch (FileNotFoundException e) {\n            //The file was not found, so print the error message and quit\n            System.out.println(\"Unable to open the candidate file. Please ensure the provided file path is correct.\");\n            return false;\n        } catch (IOException e) {\n            //Something went wrong reading the file, so print the error message and quit\n            System.out.println(\"An error occured while reading the candidate file:\" + e.getMessage());\n            return false;\n        } finally {\n            //Close the candidateReader after everything, if it exists\n            if (candidateReader != null) {\n                try {\n                    candidateReader.close();\n                } catch (IOException e) {\n                    System.out.println(\"An error occured while closing the candidate file:\\n\" + e.getMessage());\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Parse the vote file and construct all {@link Vote} objects\n     *\n     * @param voteFileName - String - The file name of the vote file\n     * @return boolean - true if successful, false if not successful\n     */\n    private static boolean parseVotes(String voteFileName) {\n        BufferedReader voteReader = null;\n        try {\n            //attempt to open the vote file\n            voteReader = new BufferedReader(new FileReader(voteFileName));\n            String line = null;\n            voteReader.readLine();\n            //parse the line of the csv file and use it to create a Vote object\n            while ((line = voteReader.readLine()) != null) {\n                String[] inputRow = line.split(\",\");\n                //store the vote as needed and count the total number of votes\n                votes.add(new Vote(inputRow));\n                originalVotes.add(new Vote(inputRow));\n                numberOfVotes++;\n            }\n        } catch (FileNotFoundException e) {\n            //File was not found, so return\n            System.out.println(\"Unable to open the vote file. Please ensure the provided file path is correct.\");\n            return false;\n        } catch (IOException e) {\n            //Failure to read file correctly, so return\n            System.out.println(\"An error occured while reading the vote file:\" + e.getMessage());\n            return false;\n        } finally {\n            //Close the buffered reader when finished\n            if (voteReader != null) {\n                try {\n                    voteReader.close();\n                } catch (IOException e) {\n                    System.out.println(\"An error occured while closing the vote file:\\n\" + e.getMessage());\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Analyzes the current vote counts, determining a winner or loser for the round, and the redistributes votes as needed\n     */\n    private static void analyzeVotes() {\n        //Print the start of round text and current vote counts\n        System.out.println();\n        System.out.println(\"Round \" + roundCounter++ + \" vote counts:\");\n        for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n            System.out.print(entry.getKey() + \": \" + entry.getValue() + \" | \");\n        }\n        System.out.println();\n        //If the number of candidates left equals the number of winners, mark them all winners and end\n        if (currentVoteCounts.size() == numberOfWinners) {\n            for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n                if (!winningCandidates.contains(entry.getKey())) {\n                    winningCandidates.add(entry.getKey());\n                    System.out.println(entry.getKey() + \" has won in the last round.\");\n                }\n            }\n            return;\n        }\n        boolean noWinnerFound = true;\n        //create an arrayList that holds the factions with the least number of votes and track the current minimum vote total\n        ArrayList<String> minCandidatess = new ArrayList<>();\n        double minCount = Double.MAX_VALUE;\n        //The entry key is the candidate name and entry value is the vote count\n        for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {\n            //If the candidate has already won, do not count their votes\n            if (!winningCandidates.contains(entry.getKey())) {\n                //Check if the vote count for this candidate has exceeded the winning threshold\n                if (entry.getValue().compareTo(voteThreshold) > 0) {\n                    //Mark that a winner was found\n                    noWinnerFound = false;\n                    //a weight for all votes from this winner as they are redistributed.\n                    double redistributeAmount = Double.sum(entry.getValue(), voteThreshold * -1.0) / numberOfVotes;\n                    //redistribute the votes of the winner using the calculated redistribution amount\n                    redistributeVotes(entry.getKey(), redistributeAmount);\n                    //Add the winner to the list of winners and print that they have won\n                    winningCandidates.add(entry.getKey());\n                    System.out.println(entry.getKey() + \" has won with \" + entry.getValue() + \" votes.\");\n                    //Exit the loop\n                    break;\n                }\n            }\n            if (entry.getValue().compareTo(minCount) < 0) {\n                //Store this count as the new minimum\n                minCount = entry.getValue();\n                //remove all current candidates from the minimum count list\n                minCandidatess.clear();\n                //and add this candidate to the list\n                minCandidatess.add(entry.getKey());\n            } else if (entry.getValue().compareTo(minCount) == 0) {\n                minCandidatess.add(entry.getKey());\n            }\n        }\n        //Since no one won, a loser must be eliminated\n        if (noWinnerFound) {\n            //If 2 or more are tied for the lowest, run a tie breaker and eliminate the loser\n            if (minCandidatess.size() == 1) {\n                eliminateCandidate(minCandidatess.get(0));\n            } else {\n                eliminateCandidate(condorcetTieBreak(minCandidatess));\n            }\n        }\n    }\n\n    /**\n     * Perform a condorcet tie break for all factions in the factions list\n     * @param candidates - {@code ArrayList<String>} - The list of candidates to check in the tie breaker\n     *\n     * @return - String - the name of the candidate that lost the tie breaker\n     */\n    private static String condorcetTieBreak(ArrayList<String> candidates) {\n        //Output that a tie braker is occuring between the candidates\n        System.out.println(\"Breaking last place tie between: \" + String.join(\", \", candidates));\n        //create the master matrix that counts the number of times one candidate beats another candidate\n        int[][] masterMatrix = new int[candidates.size()][candidates.size()];\n        //generate a matrix for each vote and add it to the master\n        for (Vote vote : originalVotes) {\n            masterMatrix = matrixAddition(masterMatrix, vote.generateMatrix(candidates));\n        }\n        // Create a win matrix which marks if one candidate beats another candidate more in the master matrix\n        int[][] winMatrix = new int[candidates.size()][candidates.size()];\n        // Create a matrix that stores the magnitude of victories in the win matrix\n        int[][] magnitudeMatrix = new int[candidates.size()][candidates.size()];\n        //loop through the master matrix\n        for (int x = 0; x < masterMatrix.length; x++) {\n            for (int y = 0; y < masterMatrix[0].length; y++) {\n                // Only 1 half of the matrix is cared about, so skip it if x < y\n                if (y > x) {\n                    if (masterMatrix[x][y] > masterMatrix[y][x]) {\n                        //If x beat y more than y beat x, mark that x beats y overall in the win matrix\n                        winMatrix[x][y] = 1;\n                        //The winner will have a positive value while the lose will have a negative value\n                        magnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n                        magnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n                    } else if (masterMatrix[x][y] < masterMatrix[y][x]) {\n                        //The same thing as above but if Y won\n                        winMatrix[y][x] = 1;\n                        magnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];\n                        magnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];\n                    }\n                }\n            }\n        }\n        //Create a variable to store the currently lowest win count\n        int minWins = Integer.MAX_VALUE;\n        //and a list to store the people with the lowest win count\n        ArrayList<Integer> winIndecies = new ArrayList<>();\n        //Loop through each candidate\n        for (int i = 0; i < candidates.size(); i++) {\n            //determine that candidates win number by summing their row in the matrix\n            int currWins = matrixRowSum(winMatrix, i);\n            if (currWins < minWins) {\n                //If this candidate has less wins than the current lowest, reset the list and mark this candidate the loser\n                minWins = currWins;\n                winIndecies.clear();\n                winIndecies.add(i);\n            } else if (currWins == minWins) {\n                //If this candidate has the same number of wins as the lowest, add their index to the list\n                winIndecies.add(i);\n            }\n        }\n        //If there is someone worse than everyone else, then they lose\n        if (winIndecies.size() == 1) {\n            return candidates.get(winIndecies.get(0));\n        } else {\n            //If multiple people share the worst win number, magnitude is taken into account\n            int minMagnitude = Integer.MAX_VALUE;\n            ArrayList<Integer> worstIndecies = new ArrayList<>();\n            //Sum the row of the magnitude matrix for each of the worst candidates\n            for (Integer rowNum : winIndecies) {\n                int currMag = matrixRowSum(magnitudeMatrix, rowNum);\n                //Keep track of those candidate with the worst magnitude of wins against all opponents in the tie breaker\n                if (currMag < minMagnitude) {\n                    minMagnitude = currMag;\n                    worstIndecies.clear();\n                    worstIndecies.add(rowNum);\n                } else if (currMag == minMagnitude) {\n                    worstIndecies.add(rowNum);\n                }\n            }\n            //If one is the worst by magnitue, eliminate them\n            if (worstIndecies.size() == 1) {\n                return candidates.get(worstIndecies.get(0));\n            } else {\n                //If win number and magnitude did not break the tie, then we look at the original votes for each candidate\n                ArrayList<Integer> lowPointIndecies = new ArrayList<>();\n                //Points are given for the ranking of a candidate on a ballot, with a higher ranked choice getting more points\n                int lowPoint = Integer.MAX_VALUE;\n                //Loop through the candidates that are stilled tied\n                for (Integer i : worstIndecies) {\n                    int totalPoints = 0;\n                    //get the points for that candidate from each vote\n                    for (Vote vote : originalVotes) {\n                        totalPoints += vote.getPoints(candidates.get(i));\n                    }\n                    //Keep track of the candidates with the worst votes\n                    if (totalPoints < lowPoint) {\n                        lowPoint = totalPoints;\n                        lowPointIndecies.clear();\n                        lowPointIndecies.add(i);\n                    } else if (totalPoints == lowPoint) {\n                        lowPointIndecies.add(i);\n                    }\n                }\n                //If there is one that is worst, eliminate them\n                if (lowPointIndecies.size() == 1) {\n                    return candidates.get(lowPointIndecies.get(0));\n                } else {\n                    //If there is still a tie, it is broken randomly\n                    Random rand = new Random();\n                    int returnIndex = rand.nextInt(lowPointIndecies.size());\n                    return candidates.get(lowPointIndecies.get(returnIndex));\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate the sum of a row (1st index) in a matrix\n     *\n     * @param matrix The matrix to operate on\n     * @param row the index of the row to sum\n     * @return int the sum of the row\n     */\n    private static int matrixRowSum(int[][] matrix, int row) {\n        int sum = 0;\n        for (int y = 0; y < matrix[0].length; y++) {\n            sum += matrix[row][y];\n        }\n        return sum;\n    }\n\n    /**\n     * Add two matrices together\n     *\n     * @param a the first matrix to add\n     * @param b the second matrix to add\n     * @return int[][] the matrix creating by adding a and b\n     */\n    private static int[][] matrixAddition(int[][] a, int[][] b) {\n        //get the row and column count for the size of the new matrix\n        int rows = a.length;\n        int columns = a[0].length;\n        //create the matrix\n        int[][] c = new int[rows][columns];\n        //perform the addition\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                c[i][j] = a[i][j] + b[i][j];\n            }\n        }\n        return c;\n    }\n\n    /**\n     * Perform the initial count of the votes\n     */\n    private static void countVotes() {\n        for (Vote vote : votes) {\n            if (!vote.getChoices().isEmpty()) {\n                //ensure that the current choice has been reset\n                vote.resetCurrentChoice();\n                String currFaction = vote.getChoice();\n                double newCount = currentVoteCounts.get(currFaction) + vote.getWeight();\n                currentVoteCounts.put(currFaction, newCount);\n            }\n        }\n    }\n\n    /**\n     * Eliminates the specified candidate and redistributes every vote that currently is counting for that candidate with a weight of 1.0\n     *\n     * @param candidate The candidate to eliminate\n     */\n    private static void eliminateCandidate(String candidate) {\n        redistributeVotes(candidate, 1.0);\n        //remove the candidate from the vote counts.\n        System.out.println(candidate + \" has been eliminated with \" + currentVoteCounts.get(candidate) + \" votes.\");\n        currentVoteCounts.remove(candidate);\n    }\n\n    /**\n     * Redistribute votes from a candidate to that vote's next candidate with a specified weight\n     *\n     * @param candidate The candidate to redistribute votes from\n     * @param redistributeAmount The weight of the redistributed votes\n     */\n    private static void redistributeVotes(String candidate, double redistributeAmount) {\n        for (Vote vote : votes) {\n            //skip the vote if it has no valid candidate choices remaining\n            if (vote.getChoices().isEmpty()) {\n                continue;\n            }\n            //If the vote is currently counting for the candidate to redistribute from\n            if (vote.getChoice().compareTo(candidate) == 0) {\n                //If the vote has another valid choice\n                if (vote.getChoices().size() > vote.getCurrentChoice() + 1) {\n                    //Set the vote to the next candidate and count the vote for that candidate\n                    vote.alterWeight(redistributeAmount);\n                    vote.incrementCurrentChoice();\n                    String newCandidate = vote.getChoice();\n                    double newCount = Double.sum(currentVoteCounts.get(newCandidate), vote.getWeight());\n                    currentVoteCounts.put(newCandidate, newCount);\n                }\n            }\n        }\n        for (Vote vote : votes) {\n            vote.eliminateRanking(candidate);\n        }\n    }\n}\n", "refactored": true}
{"hexsha": "daa82ec1a1715de64f51cea5d80e4c9ce1e34fa7", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class LabelTest {\n\n    @Parameter()\n    public String testName;\n\n    @Parameter(1)\n    public LabelerFactory labelerFactory;\n\n    @Rule\n    public final ExpectedException exception = ExpectedException.none();\n\n    /**\n     * @return A collection of parameter arrays for running tests: <ol> <li>arg[0] is the test name;</li> <li>arg[1] is\n     * the {@link LabelerFactory} for the {@link Label} class to be tested.</li></ol>\n     */\n    @Parameterized.Parameters(name = \"{0}\")\n    public static Collection<Object[]> instancesToTest() {\n        return List.of(new Object[] { \"IntLabel\", new IntLabelerFactory() }, new Object[] { \"LongLabel\", new LongLabelerFactory() }, new Object[] { \"BitSetLabel\", new BitSetLabelerFactory() });\n    }\n\n    // test that equals() and hashCode() work correctly and agree\n    @Test\n    public void testEquivalence() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label firstLabel = labeler.fromBits(0b001);\n        Label secondLabel = labeler.fromBits(0b001);\n        Label thirdLabel = labeler.fromBits(0b101);\n        assertLabelEquals(firstLabel, secondLabel);\n        assertLabelEquals(firstLabel, firstLabel);\n        assertLabelEquals(secondLabel, secondLabel);\n        assertLabelNotEquivalent(firstLabel, thirdLabel);\n        assertLabelNotEquivalent(secondLabel, thirdLabel);\n    }\n\n    private void assertLabelEquals(Label firstLabel, Label secondLabel) {\n        assertEquals(firstLabel, secondLabel);\n        assertEquals(secondLabel, firstLabel);\n        assertEquals(firstLabel.hashCode(), secondLabel.hashCode());\n    }\n\n    private void assertLabelNotEquivalent(Label firstLabel, Label secondLabel) {\n        assertNotEquals(firstLabel, secondLabel);\n        assertNotEquals(secondLabel, firstLabel);\n        // technically not always true, but it's a good test on our small set\n        assertTrue(firstLabel.hashCode() != secondLabel.hashCode());\n    }\n\n    @Test\n    public void testGetCardinality() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        assertEquals(testLabel.getCardinality(), 3);\n    }\n\n    @Test\n    public void testMatches() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        boolean[] matches = new boolean[] { false, true, true };\n        for (int i = 0; i < matches.length; i++) assertEquals(testLabel.matches(i), matches[i]);\n        matches = new boolean[] { false, true, false };\n        testLabel = labeler.fromBits(0b101);\n        for (int i = 0; i < matches.length; i++) assertEquals(testLabel.matches(i), matches[i]);\n    }\n\n    @Test\n    public void testIntersect() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label label1 = labeler.fromBits(0b001);\n        Label label2 = labeler.fromBits(0b100);\n        boolean[] matches = new boolean[] { false, true, false };\n        Label intersected = label1.intersect(label2);\n        for (int i = 0; i < matches.length; i++) assertEquals(intersected.matches(i), matches[i]);\n    }\n\n    @Test\n    public void testUnion() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label label1 = labeler.fromBits(0b001);\n        Label label2 = labeler.fromBits(0b100);\n        Label intersected = label1.union(label2);\n        for (int i = 0; i < intersected.getCardinality(); i++) assertTrue(intersected.matches(i));\n    }\n\n    @Test\n    public void testAllMatching() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        assertTrue(\"Label composed of all 0's\", labeler.fromBits(0b000).allMatching());\n        for (int bits : List.of(0b100, 0b001, 0b010, 0b111)) {\n            assertFalse(\"Label with a 1 in it\", labeler.fromBits(bits).allMatching());\n        }\n    }\n\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooLow() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(-10);\n    }\n\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooHigh() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(3);\n    }\n\n    // For now, it's fine.\n    @Test\n    public void testDescendantIterator() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label label = labeler.fromBits(0b100);\n        Set<Label> expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b101), labeler.fromBits(0b111), labeler.fromBits(0b110)));\n        Set<Label> actualLabels = new HashSet<>();\n        Iterator<Label> si = label.descendantIterator();\n        for (; si.hasNext(); ) actualLabels.add(si.next());\n        assertEquals(expectedLabels, actualLabels);\n        // V , U , V , O , 0 , ? , 0 , ? , L , E , A\n        labeler = labelerFactory.createLabeler(mockInstance(10), false, VARIABLE);\n        label = labeler.fromBits(0b0101001111);\n        expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b0101011111), labeler.fromBits(0b0101111111), labeler.fromBits(0b0101101111), labeler.fromBits(0b0111101111), labeler.fromBits(0b0111111111), labeler.fromBits(0b0111011111), labeler.fromBits(0b0111001111), labeler.fromBits(0b1111001111), labeler.fromBits(0b1111011111), labeler.fromBits(0b1111111111), labeler.fromBits(0b1111101111), labeler.fromBits(0b1101101111), labeler.fromBits(0b1101111111), labeler.fromBits(0b1101011111), labeler.fromBits(0b1101001111)));\n        actualLabels = new HashSet<>();\n        si = label.descendantIterator();\n        for (; si.hasNext(); ) actualLabels.add(si.next());\n        assertEquals(expectedLabels, actualLabels);\n    }\n\n    @Test\n    public void testIsDescendantOf() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label parentLabel = labeler.fromBits(0b100);\n        Label descendantLabel = labeler.fromBits(0b101);\n        assertTrue(descendantLabel.isDescendantOf(parentLabel));\n        Label nonDescendantLabel = labeler.fromBits(0b001);\n        assertFalse(nonDescendantLabel.isDescendantOf(parentLabel));\n    }\n\n    @Test\n    public void testToString() {\n        int labelBits = 0b1010101000111;\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n        Label label = labeler.fromBits(labelBits);\n        assertEquals(\"toString of label with elements\", Integer.toString(labelBits, 2), label.toString());\n    }\n\n    @Test\n    public void testToStringAllZeroes() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n        Label label = labeler.fromBits(0);\n        assertEquals(\"0000000000000\", label.toString());\n    }\n\n    // It seems like a dumb case to handle, but Weka's classifier test actually exercises this case\n    @Test\n    public void testToStringNoAttributes() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(0), false, MATCH);\n        Label label = labeler.fromBits(0);\n        assertEquals(\"\", label.toString());\n    }\n}\n", "class_id": 0, "repo": "garfieldnate/Weka_AnalogicalModeling", "file": "src/test/java/weka/classifiers/lazy/AM/label/LabelTest.java", "last_update_at": "2021-09-26T05:48:26+00:00", "original_content": "@RunWith(Parameterized.class)\npublic class LabelTest {\n\n    @Parameter()\n    public String testName;\n\n    @Parameter(1)\n    public LabelerFactory labelerFactory;\n\n    @Rule\n    public final ExpectedException exception = ExpectedException.none();\n\n    /**\n     * @return A collection of parameter arrays for running tests: <ol> <li>arg[0] is the test name;</li> <li>arg[1] is\n     * the {@link LabelerFactory} for the {@link Label} class to be tested.</li></ol>\n     */\n    @Parameterized.Parameters(name = \"{0}\")\n    public static Collection<Object[]> instancesToTest() {\n        return List.of(new Object[] { \"IntLabel\", new IntLabelerFactory() }, new Object[] { \"LongLabel\", new LongLabelerFactory() }, new Object[] { \"BitSetLabel\", new BitSetLabelerFactory() });\n    }\n\n    // test that equals() and hashCode() work correctly and agree\n    @Test\n    public void testEquivalence() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label firstLabel = labeler.fromBits(0b001);\n        Label secondLabel = labeler.fromBits(0b001);\n        Label thirdLabel = labeler.fromBits(0b101);\n        assertLabelEquals(firstLabel, secondLabel);\n        assertLabelEquals(firstLabel, firstLabel);\n        assertLabelEquals(secondLabel, secondLabel);\n        assertLabelNotEquivalent(firstLabel, thirdLabel);\n        assertLabelNotEquivalent(secondLabel, thirdLabel);\n    }\n\n    private void assertLabelEquals(Label firstLabel, Label secondLabel) {\n        assertEquals(firstLabel, secondLabel);\n        assertEquals(secondLabel, firstLabel);\n        assertEquals(firstLabel.hashCode(), secondLabel.hashCode());\n    }\n\n    private void assertLabelNotEquivalent(Label firstLabel, Label secondLabel) {\n        assertNotEquals(firstLabel, secondLabel);\n        assertNotEquals(secondLabel, firstLabel);\n        // technically not always true, but it's a good test on our small set\n        assertTrue(firstLabel.hashCode() != secondLabel.hashCode());\n    }\n\n    @Test\n    public void testGetCardinality() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        assertEquals(testLabel.getCardinality(), 3);\n    }\n\n    @Test\n    public void testMatches() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        boolean[] matches = new boolean[] { false, true, true };\n        for (int i = 0; i < matches.length; i++) assertEquals(testLabel.matches(i), matches[i]);\n        matches = new boolean[] { false, true, false };\n        testLabel = labeler.fromBits(0b101);\n        for (int i = 0; i < matches.length; i++) assertEquals(testLabel.matches(i), matches[i]);\n    }\n\n    @Test\n    public void testIntersect() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label label1 = labeler.fromBits(0b001);\n        Label label2 = labeler.fromBits(0b100);\n        boolean[] matches = new boolean[] { false, true, false };\n        Label intersected = label1.intersect(label2);\n        for (int i = 0; i < matches.length; i++) assertEquals(intersected.matches(i), matches[i]);\n    }\n\n    @Test\n    public void testUnion() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label label1 = labeler.fromBits(0b001);\n        Label label2 = labeler.fromBits(0b100);\n        Label intersected = label1.union(label2);\n        for (int i = 0; i < intersected.getCardinality(); i++) assertTrue(intersected.matches(i));\n    }\n\n    @Test\n    public void testAllMatching() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        assertTrue(\"Label composed of all 0's\", labeler.fromBits(0b000).allMatching());\n        for (int bits : List.of(0b100, 0b001, 0b010, 0b111)) {\n            assertFalse(\"Label with a 1 in it\", labeler.fromBits(bits).allMatching());\n        }\n    }\n\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooLow() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(-10);\n    }\n\n    @Test\n    public void testMatchesThrowsExceptionForIndexTooHigh() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label testLabel = labeler.fromBits(0b001);\n        exception.expect(IllegalArgumentException.class);\n        exception.expectMessage(new StringContains(\"Illegal index\"));\n        testLabel.matches(3);\n    }\n\n    // For now, it's fine.\n    @Test\n    public void testDescendantIterator() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label label = labeler.fromBits(0b100);\n        Set<Label> expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b101), labeler.fromBits(0b111), labeler.fromBits(0b110)));\n        Set<Label> actualLabels = new HashSet<>();\n        Iterator<Label> si = label.descendantIterator();\n        while (si.hasNext()) actualLabels.add(si.next());\n        assertEquals(expectedLabels, actualLabels);\n        // V , U , V , O , 0 , ? , 0 , ? , L , E , A\n        labeler = labelerFactory.createLabeler(mockInstance(10), false, VARIABLE);\n        label = labeler.fromBits(0b0101001111);\n        expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b0101011111), labeler.fromBits(0b0101111111), labeler.fromBits(0b0101101111), labeler.fromBits(0b0111101111), labeler.fromBits(0b0111111111), labeler.fromBits(0b0111011111), labeler.fromBits(0b0111001111), labeler.fromBits(0b1111001111), labeler.fromBits(0b1111011111), labeler.fromBits(0b1111111111), labeler.fromBits(0b1111101111), labeler.fromBits(0b1101101111), labeler.fromBits(0b1101111111), labeler.fromBits(0b1101011111), labeler.fromBits(0b1101001111)));\n        actualLabels = new HashSet<>();\n        si = label.descendantIterator();\n        while (si.hasNext()) actualLabels.add(si.next());\n        assertEquals(expectedLabels, actualLabels);\n    }\n\n    @Test\n    public void testIsDescendantOf() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);\n        Label parentLabel = labeler.fromBits(0b100);\n        Label descendantLabel = labeler.fromBits(0b101);\n        assertTrue(descendantLabel.isDescendantOf(parentLabel));\n        Label nonDescendantLabel = labeler.fromBits(0b001);\n        assertFalse(nonDescendantLabel.isDescendantOf(parentLabel));\n    }\n\n    @Test\n    public void testToString() {\n        int labelBits = 0b1010101000111;\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n        Label label = labeler.fromBits(labelBits);\n        assertEquals(\"toString of label with elements\", Integer.toString(labelBits, 2), label.toString());\n    }\n\n    @Test\n    public void testToStringAllZeroes() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);\n        Label label = labeler.fromBits(0);\n        assertEquals(\"0000000000000\", label.toString());\n    }\n\n    // It seems like a dumb case to handle, but Weka's classifier test actually exercises this case\n    @Test\n    public void testToStringNoAttributes() {\n        Labeler labeler = labelerFactory.createLabeler(mockInstance(0), false, MATCH);\n        Label label = labeler.fromBits(0);\n        assertEquals(\"\", label.toString());\n    }\n}\n", "refactored": true}
{"hexsha": "7142d9c06098c05b438ce4e3aee241b816729134", "ext": "java", "lang": "Java", "content": "public class SPacketScoreboardObjective implements Packet<INetHandlerPlayClient> {\n\n    private String objectiveName;\n\n    private String objectiveValue;\n\n    private IScoreCriteria.EnumRenderType type;\n\n    private int action;\n\n    public SPacketScoreboardObjective() {\n    }\n\n    public SPacketScoreboardObjective(ScoreObjective objective, int actionIn) {\n        this.objectiveName = objective.getName();\n        this.objectiveValue = objective.getDisplayName();\n        this.type = objective.getCriteria().getRenderType();\n        this.action = actionIn;\n    }\n\n    /**\n     * Reads the raw packet data from the data stream.\n     */\n    public void readPacketData(PacketBuffer buf) throws IOException {\n        this.objectiveName = buf.readString(16);\n        this.action = buf.readByte();\n        if (this.action == 0 || this.action == 2) {\n            this.objectiveValue = buf.readString(32);\n            this.type = IScoreCriteria.EnumRenderType.getByName(buf.readString(16));\n        }\n    }\n\n    /**\n     * Writes the raw packet data to the data stream.\n     */\n    public void writePacketData(PacketBuffer buf) throws IOException {\n        buf.writeString(this.objectiveName);\n        buf.writeByte(this.action);\n        if (this.action == 0 || this.action == 2) {\n            buf.writeString(this.objectiveValue);\n            buf.writeString(this.type.getRenderType());\n        }\n    }\n\n    /**\n     * Passes this Packet on to the NetHandler for processing.\n     */\n    public void processPacket(INetHandlerPlayClient handler) {\n        handler.handleScoreboardObjective(this);\n    }\n\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveName() {\n        return this.objectiveName;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveValue() {\n        return this.objectiveValue;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public int getAction() {\n        return this.action;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public IScoreCriteria.EnumRenderType getRenderType() {\n        return this.type;\n    }\n}\n", "class_id": 0, "repo": "JeremyHi/402-CryptoSym", "file": "Malmo-0.30.0/Minecraft/build/tmp/recompileMc/sources/net/minecraft/network/play/server/SPacketScoreboardObjective.java", "last_update_at": "2021-12-19T18:11:35+00:00", "original_content": "public class SPacketScoreboardObjective implements Packet<INetHandlerPlayClient> {\n\n    private String objectiveName;\n\n    private String objectiveValue;\n\n    private IScoreCriteria.EnumRenderType type;\n\n    private int action;\n\n    public SPacketScoreboardObjective() {\n    }\n\n    public SPacketScoreboardObjective(ScoreObjective objective, int actionIn) {\n        this.objectiveName = objective.getName();\n        this.objectiveValue = objective.getDisplayName();\n        this.type = objective.getCriteria().getRenderType();\n        this.action = actionIn;\n    }\n\n    /**\n     * Reads the raw packet data from the data stream.\n     */\n    public void readPacketData(PacketBuffer buf) throws IOException {\n        this.objectiveName = buf.readString(16);\n        this.action = buf.readByte();\n        if (this.action == 0 || this.action == 2) {\n            this.objectiveValue = buf.readString(32);\n            this.type = IScoreCriteria.EnumRenderType.getByName(buf.readString(16));\n        }\n    }\n\n    /**\n     * Writes the raw packet data to the data stream.\n     */\n    public void writePacketData(PacketBuffer buf) throws IOException {\n        buf.writeString(this.objectiveName);\n        buf.writeByte(this.action);\n        if (this.action == 0 || this.action == 2) {\n            buf.writeString(this.objectiveValue);\n            buf.writeString(this.type.getRenderType());\n        }\n    }\n\n    /**\n     * Passes this Packet on to the NetHandler for processing.\n     */\n    public void processPacket(INetHandlerPlayClient handler) {\n        handler.handleScoreboardObjective(this);\n    }\n\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveName() {\n        return this.objectiveName;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public String getObjectiveValue() {\n        return this.objectiveValue;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public int getAction() {\n        return this.action;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public IScoreCriteria.EnumRenderType getRenderType() {\n        return this.type;\n    }\n}\n", "refactored": false}
{"hexsha": "32afa3a8e9b1807eedffda9e3ea7130a21a31f59", "ext": "java", "lang": "Java", "content": "public final class SphereShardingSphereProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(SphereShardingSphereProxy.class);\n\n    private EventLoopGroup bossGroup;\n\n    private EventLoopGroup workerGroup;\n\n    /**\n     * Start ShardingSphere-Proxy.\n     *\n     * @param port port\n     */\n    public void start(final int port) {\n        try {\n            createEventLoopGroup();\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            initServerBootstrap(bootstrap, port);\n            ChannelFuture future = bootstrap.bind(port).sync();\n            log.info(\"ShardingSphere-Proxy start success.\");\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            throw DbException.convert(e);\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n            BackendExecutorContext.getInstance().getExecutorKernel().close();\n        }\n    }\n\n    private void createEventLoopGroup() {\n        bossGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(1) : new NioEventLoopGroup(1);\n        workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n    }\n\n    private void initServerBootstrap(final ServerBootstrap bootstrap, int port) {\n        bootstrap.group(bossGroup, workerGroup).channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 128).option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(8 * 1024 * 1024, 16 * 1024 * 1024)).option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.TCP_NODELAY, true).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ServerHandlerInitializer(port));\n    }\n\n    public final class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {\n\n        final int port;\n\n        public ServerHandlerInitializer(int port) {\n            this.port = port;\n        }\n\n        @Override\n        protected void initChannel(final SocketChannel socketChannel) {\n            DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine;\n            if (port == PgServer.DEFAULT_PORT) {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealonePostgreSQL\");\n                databaseProtocolFrontendEngine = LealonePostgreSQLFrontendEngine.INSTANCE;\n            } else {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealoneMySQL\");\n                databaseProtocolFrontendEngine = LealoneMySQLFrontendEngine.INSTANCE;\n            }\n            ChannelPipeline pipeline = socketChannel.pipeline();\n            pipeline.addLast(new PacketCodec(databaseProtocolFrontendEngine.getCodecEngine()));\n            pipeline.addLast(new FrontendChannelInboundHandler(databaseProtocolFrontendEngine));\n        }\n\n        public DatabaseProtocolFrontendEngine getDatabaseProtocolFrontendEngineFactory(final String databaseType) {\n            for (DatabaseProtocolFrontendEngine each : ShardingSphereServiceLoader.newServiceInstances(DatabaseProtocolFrontendEngine.class)) {\n                if (DatabaseTypeRegistry.getActualDatabaseType(databaseType).getName().equals(databaseType)) {\n                    return each;\n                }\n            }\n            throw new UnsupportedOperationException(String.format(\"Cannot support database type '%s'\", databaseType));\n        }\n    }\n}\n", "class_id": 0, "repo": "lealone/Bats", "file": "bats-sphere/src/main/java/org/lealone/bats/sphere/bootstrap/SphereShardingSphereProxy.java", "last_update_at": "2021-08-07T04:01:14+00:00", "original_content": "public final class SphereShardingSphereProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(SphereShardingSphereProxy.class);\n\n    private EventLoopGroup bossGroup;\n\n    private EventLoopGroup workerGroup;\n\n    /**\n     * Start ShardingSphere-Proxy.\n     *\n     * @param port port\n     */\n    public void start(final int port) {\n        try {\n            createEventLoopGroup();\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            initServerBootstrap(bootstrap, port);\n            ChannelFuture future = bootstrap.bind(port).sync();\n            log.info(\"ShardingSphere-Proxy start success.\");\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            throw DbException.convert(e);\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n            BackendExecutorContext.getInstance().getExecutorKernel().close();\n        }\n    }\n\n    private void createEventLoopGroup() {\n        bossGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(1) : new NioEventLoopGroup(1);\n        workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n    }\n\n    private void initServerBootstrap(final ServerBootstrap bootstrap, int port) {\n        bootstrap.group(bossGroup, workerGroup).channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 128).option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(8 * 1024 * 1024, 16 * 1024 * 1024)).option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.TCP_NODELAY, true).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ServerHandlerInitializer(port));\n    }\n\n    public final class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {\n\n        final int port;\n\n        public ServerHandlerInitializer(int port) {\n            this.port = port;\n        }\n\n        @Override\n        protected void initChannel(final SocketChannel socketChannel) {\n            DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine;\n            if (port == PgServer.DEFAULT_PORT) {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealonePostgreSQL\");\n                databaseProtocolFrontendEngine = LealonePostgreSQLFrontendEngine.INSTANCE;\n            } else {\n                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory(\"LealoneMySQL\");\n                databaseProtocolFrontendEngine = LealoneMySQLFrontendEngine.INSTANCE;\n            }\n            ChannelPipeline pipeline = socketChannel.pipeline();\n            pipeline.addLast(new PacketCodec(databaseProtocolFrontendEngine.getCodecEngine()));\n            pipeline.addLast(new FrontendChannelInboundHandler(databaseProtocolFrontendEngine));\n        }\n\n        public DatabaseProtocolFrontendEngine getDatabaseProtocolFrontendEngineFactory(final String databaseType) {\n            for (DatabaseProtocolFrontendEngine each : ShardingSphereServiceLoader.newServiceInstances(DatabaseProtocolFrontendEngine.class)) {\n                if (DatabaseTypeRegistry.getActualDatabaseType(databaseType).getName().equals(databaseType)) {\n                    return each;\n                }\n            }\n            throw new UnsupportedOperationException(String.format(\"Cannot support database type '%s'\", databaseType));\n        }\n    }\n}\n", "refactored": false}
{"hexsha": "fffc8b15a202472b064537ba02ca8760174f69e2", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(value = \"/api/admin/discovery\", produces = MediaType.APPLICATION_JSON_VALUE)\npublic class AdminDiscoveryResource extends BaseResource {\n\n    @Inject\n    private ProgramItemService programItemService;\n\n    /**\n     * Gets discovery programs.\n     *\n     * @return the discovery programs\n     */\n    @ApiOperation(value = \"Get DiscoveryPrograms.\", notes = \"<p>Get DiscoveryPrograms.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    List<DiscoverProgramDTO> getDiscoveryPrograms() {\n        List<DiscoveryProgram> discoveryProgramList = programItemService.getDiscoveryPrograms();\n        List<DiscoverProgramDTO> dto = new ArrayList<>();\n        for (DiscoveryProgram dp : discoveryProgramList) {\n            dto.add(DiscoverProgramDTO.valueOf(dp));\n        }\n        return dto;\n    }\n\n    /**\n     * Upsert discovery program discover program dto.\n     *\n     * @param dto the dto\n     * @return the discover program dto\n     */\n    @ApiOperation(value = \"Upsert DiscoveryProgram.\", notes = \"<p>Upsert DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.PUT)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    DiscoverProgramDTO upsertDiscoveryProgram(@RequestBody DiscoverProgramDTO dto) {\n        DiscoveryProgram dp = programItemService.upsertDiscoveryProgram(dto.getId(), dto.getProgramId(), dto.getActive(), dto.getType(), dto.getDiscoveryProgramText());\n        return DiscoverProgramDTO.valueOf(dp);\n    }\n\n    /**\n     * Delete discovery program.\n     *\n     * @param discoveryProgramId the discovery program id\n     */\n    @ApiOperation(value = \"Delete the given DiscoveryProgram.\", notes = \"<p>Delete the given DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/{discoveryProgramId}\", method = RequestMethod.DELETE)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public void deleteDiscoveryProgram(@PathVariable Long discoveryProgramId) {\n        programItemService.deleteDiscoveryProgram(discoveryProgramId);\n    }\n\n    /**\n     * Gets discover type list.\n     *\n     * @return the discover type list\n     */\n    @ApiOperation(value = \"Get discover types\", notes = \"<p>Get list of discover types.</p>\")\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public List<DiscoveryProgramType> getDiscoverTypeList() {\n        return DiscoveryProgramType.getAllTypes();\n    }\n}\n", "class_id": 0, "repo": "openlearningplatformlxp/lxp", "file": "webapp/src/main/java/com/redhat/uxl/webapp/web/rest/admin/AdminDiscoveryResource.java", "last_update_at": "2021-02-17T15:38:01+00:00", "original_content": "@RestController\n@RequestMapping(value = \"/api/admin/discovery\", produces = MediaType.APPLICATION_JSON_VALUE)\npublic class AdminDiscoveryResource extends BaseResource {\n\n    @Inject\n    private ProgramItemService programItemService;\n\n    /**\n     * Gets discovery programs.\n     *\n     * @return the discovery programs\n     */\n    @ApiOperation(value = \"Get DiscoveryPrograms.\", notes = \"<p>Get DiscoveryPrograms.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    List<DiscoverProgramDTO> getDiscoveryPrograms() {\n        List<DiscoveryProgram> discoveryProgramList = programItemService.getDiscoveryPrograms();\n        List<DiscoverProgramDTO> dto = new ArrayList<>();\n        for (DiscoveryProgram dp : discoveryProgramList) {\n            dto.add(DiscoverProgramDTO.valueOf(dp));\n        }\n        return dto;\n    }\n\n    /**\n     * Upsert discovery program discover program dto.\n     *\n     * @param dto the dto\n     * @return the discover program dto\n     */\n    @ApiOperation(value = \"Upsert DiscoveryProgram.\", notes = \"<p>Upsert DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/\", method = RequestMethod.PUT)\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    @Timed\n    DiscoverProgramDTO upsertDiscoveryProgram(@RequestBody DiscoverProgramDTO dto) {\n        DiscoveryProgram dp = programItemService.upsertDiscoveryProgram(dto.getId(), dto.getProgramId(), dto.getActive(), dto.getType(), dto.getDiscoveryProgramText());\n        return DiscoverProgramDTO.valueOf(dp);\n    }\n\n    /**\n     * Delete discovery program.\n     *\n     * @param discoveryProgramId the discovery program id\n     */\n    @ApiOperation(value = \"Delete the given DiscoveryProgram.\", notes = \"<p>Delete the given DiscoveryProgram.</p>\")\n    @RequestMapping(value = \"/{discoveryProgramId}\", method = RequestMethod.DELETE)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public void deleteDiscoveryProgram(@PathVariable Long discoveryProgramId) {\n        programItemService.deleteDiscoveryProgram(discoveryProgramId);\n    }\n\n    /**\n     * Gets discover type list.\n     *\n     * @return the discover type list\n     */\n    @ApiOperation(value = \"Get discover types\", notes = \"<p>Get list of discover types.</p>\")\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    @Timed\n    @RolesAllowed(AuthoritiesConstants.ADMIN)\n    public List<DiscoveryProgramType> getDiscoverTypeList() {\n        return DiscoveryProgramType.getAllTypes();\n    }\n}\n", "refactored": false}
{"hexsha": "b7d655e96b2368219f57e0cb9f77e5529aa81369", "ext": "java", "lang": "Java", "content": "public class FixLengthConf {\n\n    public List<FixLengthMessageIn> getConf() {\n        List<FixLengthMessageIn> flconf = new ArrayList<FixLengthMessageIn>();\n        Resource resource = new ClassPathResource(\"classpath:FixLengthConfig.xml\");\n        try {\n            // File fXmlFile = readXml(resource.getInputStream());\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            // Document doc = dBuilder.parse(fXmlFile);\n            Document doc = readXml(resource.getInputStream());\n            // http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n            NodeList nList = doc.getElementsByTagName(\"field\");\n            System.out.println(\"----------------------------\");\n            int temp = 0;\n            while (temp < nList.getLength()) try {\n                Node nNode = nList.item(temp);\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    //\t\t\t\t\tSystem.out.println(\"end : \" + eElement.getElementsByTagName(\"end\").item(0).getTextContent());\n                    flconf.add(new FixLengthMessageIn(eElement.getAttribute(\"name\").toString(), eElement.getElementsByTagName(\"start\").item(0).getTextContent().toString(), eElement.getElementsByTagName(\"end\").item(0).getTextContent().toString(), \"\"));\n                }\n            } finally {\n                temp++;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return flconf;\n    }\n\n    public static Document readXml(InputStream is) throws SAXException, IOException, ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = null;\n        db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        return db.parse(is);\n    }\n}\n", "class_id": 0, "repo": "arkenabd/fuse-out-rest", "file": "src/main/java/com/netty/fuse/util/FixLengthConf.java", "last_update_at": "2021-12-14T21:40:22+00:00", "original_content": "public class FixLengthConf {\n\n    public List<FixLengthMessageIn> getConf() {\n        List<FixLengthMessageIn> flconf = new ArrayList<FixLengthMessageIn>();\n        Resource resource = new ClassPathResource(\"classpath:FixLengthConfig.xml\");\n        try {\n            // File fXmlFile = readXml(resource.getInputStream());\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            // Document doc = dBuilder.parse(fXmlFile);\n            Document doc = readXml(resource.getInputStream());\n            // http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n            NodeList nList = doc.getElementsByTagName(\"field\");\n            System.out.println(\"----------------------------\");\n            for (int temp = 0; temp < nList.getLength(); temp++) {\n                Node nNode = nList.item(temp);\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    //\t\t\t\t\tSystem.out.println(\"end : \" + eElement.getElementsByTagName(\"end\").item(0).getTextContent());\n                    flconf.add(new FixLengthMessageIn(eElement.getAttribute(\"name\").toString(), eElement.getElementsByTagName(\"start\").item(0).getTextContent().toString(), eElement.getElementsByTagName(\"end\").item(0).getTextContent().toString(), \"\"));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return flconf;\n    }\n\n    public static Document readXml(InputStream is) throws SAXException, IOException, ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setValidating(false);\n        dbf.setIgnoringComments(false);\n        dbf.setIgnoringElementContentWhitespace(true);\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = null;\n        db = dbf.newDocumentBuilder();\n        db.setEntityResolver(new NullResolver());\n        return db.parse(is);\n    }\n}\n", "refactored": true}
{"hexsha": "e4df3fd07315c7a35d07ed02243925bb9e0e5835", "ext": "java", "lang": "Java", "content": "@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(loader = TestWebContextLoader.class, locations = { \"classpath:test-webmvc-config.xml\" })\npublic class ReportResourceTest {\n\n    @Autowired\n    protected WebApplicationContext webApplicationContext;\n\n    private MockMvc mockMvc;\n\n    protected ObjectMapper mapper = new ObjectMapper();\n\n    private final String BASE_URL = \"/rest/report/\";\n\n    private final String expectedReport = \"{\\n\" + \"\\t\\\"reports\\\": \\\"[{\\\\\\\"baseEntityId\\\\\\\":\\\\\\\"22\\\\\\\",\\\\\\\"locationId\\\\\\\":\\\\\\\"testLocationId\\\\\\\",\\\\\\\"reportType\\\\\\\":\\\\\\\"testReportType\\\\\\\",\\\\\\\"formSubmissionId\\\\\\\":\\\\\\\"testFormSubmissionId\\\\\\\",\\\\\\\"providerId\\\\\\\":\\\\\\\"testProviderId\\\\\\\",\\\\\\\"status\\\\\\\":\\\\\\\"test\\\\\\\"}]\\\"\\n\" + \"}\";\n\n    private final String INVALID_JSON = \"{\\n\" + \"\\t\\\"reports\\\": {\\n\" + \"\\t\\t\\\"baseEntityId\\\": \\\"22\\\",\\n\" + \"\\t\\t\\\"locationId\\\": \\\"testLocationId\\\",\\n\" + \"\\t\\t\\\"reportType\\\": \\\"testReportType\\\",\\n\" + \"\\t\\t\\\"formSubmissionId\\\": \\\"testFormSubmissionId\\\",\\n\" + \"\\t\\t\\\"providerId\\\": \\\"testProviderId\\\",\\n\" + \"\\t\\t\\\"status\\\": \\\"test\\\"\\n\" + \"\\t}\\n\" + \"}\";\n\n    @InjectMocks\n    private ReportResource reportResource;\n\n    @Mock\n    private ReportService reportService;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mockMvc = org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup(reportResource).addFilter(new CrossSiteScriptingPreventionFilter(), \"/*\").build();\n    }\n\n    @Test\n    public void testSaveWithException() throws Exception {\n        MvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(\"\".getBytes())).andExpect(status().isBadRequest()).andReturn();\n    }\n\n    @Test\n    public void testSave() throws Exception {\n        when(reportService.addorUpdateReport(any(Report.class))).thenReturn(createReport());\n        MvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(expectedReport.getBytes())).andExpect(status().isCreated()).andReturn();\n        String responseString = result.getResponse().getContentAsString();\n        assertEquals(responseString, \"\");\n    }\n\n    @Test\n    public void testSaveWithInvalidJson() throws Exception {\n        MvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(INVALID_JSON.getBytes())).andExpect(status().isInternalServerError()).andReturn();\n        String responseString = result.getResponse().getContentAsString();\n        assertEquals(responseString, \"\");\n    }\n\n    private Report createReport() {\n        Report report = new Report();\n        report.setId(\"Test-ID\");\n        report.setLocationId(\"locationId\");\n        report.setProviderId(\"providerId\");\n        report.setStatus(\"test\");\n        report.setReportType(\"reportType\");\n        report.setFormSubmissionId(\"formSubmissionId\");\n        return report;\n    }\n}\n", "class_id": 0, "repo": "codacy-badger/opensrp-server-web", "file": "src/test/java/org/opensrp/web/rest/ReportResourceTest.java", "last_update_at": "2021-02-04T11:39:14+00:00", "original_content": "@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(loader = TestWebContextLoader.class, locations = { \"classpath:test-webmvc-config.xml\" })\npublic class ReportResourceTest {\n\n    @Autowired\n    protected WebApplicationContext webApplicationContext;\n\n    private MockMvc mockMvc;\n\n    protected ObjectMapper mapper = new ObjectMapper();\n\n    private final String BASE_URL = \"/rest/report/\";\n\n    private final String expectedReport = \"{\\n\" + \"\\t\\\"reports\\\": \\\"[{\\\\\\\"baseEntityId\\\\\\\":\\\\\\\"22\\\\\\\",\\\\\\\"locationId\\\\\\\":\\\\\\\"testLocationId\\\\\\\",\\\\\\\"reportType\\\\\\\":\\\\\\\"testReportType\\\\\\\",\\\\\\\"formSubmissionId\\\\\\\":\\\\\\\"testFormSubmissionId\\\\\\\",\\\\\\\"providerId\\\\\\\":\\\\\\\"testProviderId\\\\\\\",\\\\\\\"status\\\\\\\":\\\\\\\"test\\\\\\\"}]\\\"\\n\" + \"}\";\n\n    private final String INVALID_JSON = \"{\\n\" + \"\\t\\\"reports\\\": {\\n\" + \"\\t\\t\\\"baseEntityId\\\": \\\"22\\\",\\n\" + \"\\t\\t\\\"locationId\\\": \\\"testLocationId\\\",\\n\" + \"\\t\\t\\\"reportType\\\": \\\"testReportType\\\",\\n\" + \"\\t\\t\\\"formSubmissionId\\\": \\\"testFormSubmissionId\\\",\\n\" + \"\\t\\t\\\"providerId\\\": \\\"testProviderId\\\",\\n\" + \"\\t\\t\\\"status\\\": \\\"test\\\"\\n\" + \"\\t}\\n\" + \"}\";\n\n    @InjectMocks\n    private ReportResource reportResource;\n\n    @Mock\n    private ReportService reportService;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mockMvc = org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup(reportResource).addFilter(new CrossSiteScriptingPreventionFilter(), \"/*\").build();\n    }\n\n    @Test\n    public void testSaveWithException() throws Exception {\n        MvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(\"\".getBytes())).andExpect(status().isBadRequest()).andReturn();\n    }\n\n    @Test\n    public void testSave() throws Exception {\n        when(reportService.addorUpdateReport(any(Report.class))).thenReturn(createReport());\n        MvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(expectedReport.getBytes())).andExpect(status().isCreated()).andReturn();\n        String responseString = result.getResponse().getContentAsString();\n        assertEquals(responseString, \"\");\n    }\n\n    @Test\n    public void testSaveWithInvalidJson() throws Exception {\n        MvcResult result = mockMvc.perform(post(BASE_URL + \"/add\").content(INVALID_JSON.getBytes())).andExpect(status().isInternalServerError()).andReturn();\n        String responseString = result.getResponse().getContentAsString();\n        assertEquals(responseString, \"\");\n    }\n\n    private Report createReport() {\n        Report report = new Report();\n        report.setId(\"Test-ID\");\n        report.setLocationId(\"locationId\");\n        report.setProviderId(\"providerId\");\n        report.setStatus(\"test\");\n        report.setReportType(\"reportType\");\n        report.setFormSubmissionId(\"formSubmissionId\");\n        return report;\n    }\n}\n", "refactored": false}
